var __renderjsModules={};

__renderjsModules["55b5cda2"] = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/static/leaflet/leaflet.js
  var require_leaflet = __commonJS({
    "C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/static/leaflet/leaflet.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).leaflet = {});
      }(exports, function(t) {
        "use strict";
        function l(t2) {
          for (var e2, i2, n2 = 1, o2 = arguments.length; n2 < o2; n2++)
            for (e2 in i2 = arguments[n2])
              t2[e2] = i2[e2];
          return t2;
        }
        var R = Object.create || function(t2) {
          return N.prototype = t2, new N();
        };
        function N() {
        }
        function a(t2, e2) {
          var i2, n2 = Array.prototype.slice;
          return t2.bind ? t2.bind.apply(t2, n2.call(arguments, 1)) : (i2 = n2.call(arguments, 2), function() {
            return t2.apply(e2, i2.length ? i2.concat(n2.call(arguments)) : arguments);
          });
        }
        var D = 0;
        function h(t2) {
          return "_leaflet_id" in t2 || (t2._leaflet_id = ++D), t2._leaflet_id;
        }
        function j(t2, e2, i2) {
          var n2, o2, s2 = function() {
            n2 = false, o2 && (r2.apply(i2, o2), o2 = false);
          }, r2 = function() {
            n2 ? o2 = arguments : (t2.apply(i2, arguments), setTimeout(s2, e2), n2 = true);
          };
          return r2;
        }
        function H(t2, e2, i2) {
          var n2 = e2[1], e2 = e2[0], o2 = n2 - e2;
          return t2 === n2 && i2 ? t2 : ((t2 - e2) % o2 + o2) % o2 + e2;
        }
        function u() {
          return false;
        }
        function i(t2, e2) {
          return false === e2 ? t2 : (e2 = Math.pow(10, void 0 === e2 ? 6 : e2), Math.round(t2 * e2) / e2);
        }
        function W(t2) {
          return t2.trim ? t2.trim() : t2.replace(/^\s+|\s+$/g, "");
        }
        function F(t2) {
          return W(t2).split(/\s+/);
        }
        function c(t2, e2) {
          for (var i2 in Object.prototype.hasOwnProperty.call(t2, "options") || (t2.options = t2.options ? R(t2.options) : {}), e2)
            t2.options[i2] = e2[i2];
          return t2.options;
        }
        function U(t2, e2, i2) {
          var n2, o2 = [];
          for (n2 in t2)
            o2.push(encodeURIComponent(i2 ? n2.toUpperCase() : n2) + "=" + encodeURIComponent(t2[n2]));
          return (e2 && -1 !== e2.indexOf("?") ? "&" : "?") + o2.join("&");
        }
        var V = /\{ *([\w_ -]+) *\}/g;
        function q(t2, i2) {
          return t2.replace(V, function(t3, e2) {
            e2 = i2[e2];
            if (void 0 === e2)
              throw new Error("No value provided for variable " + t3);
            return e2 = "function" == typeof e2 ? e2(i2) : e2;
          });
        }
        var d = Array.isArray || function(t2) {
          return "[object Array]" === Object.prototype.toString.call(t2);
        };
        function G(t2, e2) {
          for (var i2 = 0; i2 < t2.length; i2++)
            if (t2[i2] === e2)
              return i2;
          return -1;
        }
        var K = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function Y(t2) {
          return window["webkit" + t2] || window["moz" + t2] || window["ms" + t2];
        }
        var X = 0;
        function J(t2) {
          var e2 = +/* @__PURE__ */ new Date(), i2 = Math.max(0, 16 - (e2 - X));
          return X = e2 + i2, window.setTimeout(t2, i2);
        }
        var $ = window.requestAnimationFrame || Y("RequestAnimationFrame") || J, Q = window.cancelAnimationFrame || Y("CancelAnimationFrame") || Y("CancelRequestAnimationFrame") || function(t2) {
          window.clearTimeout(t2);
        };
        function x(t2, e2, i2) {
          if (!i2 || $ !== J)
            return $.call(window, a(t2, e2));
          t2.call(e2);
        }
        function r(t2) {
          t2 && Q.call(window, t2);
        }
        var tt = {
          __proto__: null,
          extend: l,
          create: R,
          bind: a,
          get lastId() {
            return D;
          },
          stamp: h,
          throttle: j,
          wrapNum: H,
          falseFn: u,
          formatNum: i,
          trim: W,
          splitWords: F,
          setOptions: c,
          getParamString: U,
          template: q,
          isArray: d,
          indexOf: G,
          emptyImageUrl: K,
          requestFn: $,
          cancelFn: Q,
          requestAnimFrame: x,
          cancelAnimFrame: r
        };
        function et() {
        }
        et.extend = function(t2) {
          function e2() {
            c(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
          }
          var i2, n2 = e2.__super__ = this.prototype, o2 = R(n2);
          for (i2 in (o2.constructor = e2).prototype = o2, this)
            Object.prototype.hasOwnProperty.call(this, i2) && "prototype" !== i2 && "__super__" !== i2 && (e2[i2] = this[i2]);
          if (t2.statics && l(e2, t2.statics), t2.includes) {
            var s2 = t2.includes;
            if ("undefined" != typeof L && L && L.Mixin) {
              s2 = d(s2) ? s2 : [s2];
              for (var r2 = 0; r2 < s2.length; r2++)
                s2[r2] === L.Mixin.Events && console.warn(
                  "Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.",
                  new Error().stack
                );
            }
            l.apply(null, [o2].concat(t2.includes));
          }
          return l(o2, t2), delete o2.statics, delete o2.includes, o2.options && (o2.options = n2.options ? R(n2.options) : {}, l(o2.options, t2.options)), o2._initHooks = [], o2.callInitHooks = function() {
            if (!this._initHooksCalled) {
              n2.callInitHooks && n2.callInitHooks.call(this), this._initHooksCalled = true;
              for (var t3 = 0, e3 = o2._initHooks.length; t3 < e3; t3++)
                o2._initHooks[t3].call(this);
            }
          }, e2;
        }, et.include = function(t2) {
          var e2 = this.prototype.options;
          return l(this.prototype, t2), t2.options && (this.prototype.options = e2, this.mergeOptions(t2.options)), this;
        }, et.mergeOptions = function(t2) {
          return l(this.prototype.options, t2), this;
        }, et.addInitHook = function(t2) {
          var e2 = Array.prototype.slice.call(arguments, 1), i2 = "function" == typeof t2 ? t2 : function() {
            this[t2].apply(this, e2);
          };
          return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i2), this;
        };
        var e = {
          on: function(t2, e2, i2) {
            if ("object" == typeof t2)
              for (var n2 in t2)
                this._on(n2, t2[n2], e2);
            else
              for (var o2 = 0, s2 = (t2 = F(t2)).length; o2 < s2; o2++)
                this._on(t2[o2], e2, i2);
            return this;
          },
          off: function(t2, e2, i2) {
            if (arguments.length)
              if ("object" == typeof t2)
                for (var n2 in t2)
                  this._off(n2, t2[n2], e2);
              else {
                t2 = F(t2);
                for (var o2 = 1 === arguments.length, s2 = 0, r2 = t2.length; s2 < r2; s2++)
                  o2 ? this._off(t2[s2]) : this._off(t2[s2], e2, i2);
              }
            else
              delete this._events;
            return this;
          },
          _on: function(t2, e2, i2, n2) {
            "function" != typeof e2 ? console.warn("wrong listener type: " + typeof e2) : false === this._listens(t2, e2, i2) && (e2 = {
              fn: e2,
              ctx: i2 = i2 === this ? void 0 : i2
            }, n2 && (e2.once = true), this._events = this._events || {}, this._events[t2] = this._events[t2] || [], this._events[t2].push(e2));
          },
          _off: function(t2, e2, i2) {
            var n2, o2, s2;
            if (this._events && (n2 = this._events[t2]))
              if (1 === arguments.length) {
                if (this._firingCount)
                  for (o2 = 0, s2 = n2.length; o2 < s2; o2++)
                    n2[o2].fn = u;
                delete this._events[t2];
              } else
                "function" != typeof e2 ? console.warn("wrong listener type: " + typeof e2) : false !== (e2 = this._listens(t2, e2, i2)) && (i2 = n2[e2], this._firingCount && (i2.fn = u, this._events[t2] = n2 = n2.slice()), n2.splice(e2, 1));
          },
          fire: function(t2, e2, i2) {
            if (this.listens(t2, i2)) {
              var n2 = l({}, e2, {
                type: t2,
                target: this,
                sourceTarget: e2 && e2.sourceTarget || this
              });
              if (this._events) {
                var o2 = this._events[t2];
                if (o2) {
                  this._firingCount = this._firingCount + 1 || 1;
                  for (var s2 = 0, r2 = o2.length; s2 < r2; s2++) {
                    var a2 = o2[s2], h2 = a2.fn;
                    a2.once && this.off(t2, h2, a2.ctx), h2.call(a2.ctx || this, n2);
                  }
                  this._firingCount--;
                }
              }
              i2 && this._propagateEvent(n2);
            }
            return this;
          },
          listens: function(t2, e2, i2, n2) {
            "string" != typeof t2 && console.warn('"string" type argument expected');
            var o2 = e2, s2 = ("function" != typeof e2 && (n2 = !!e2, i2 = o2 = void 0), this._events && this._events[t2]);
            if (s2 && s2.length && false !== this._listens(t2, o2, i2))
              return true;
            if (n2) {
              for (var r2 in this._eventParents)
                if (this._eventParents[r2].listens(t2, e2, i2, n2))
                  return true;
            }
            return false;
          },
          _listens: function(t2, e2, i2) {
            if (this._events) {
              var n2 = this._events[t2] || [];
              if (!e2)
                return !!n2.length;
              i2 === this && (i2 = void 0);
              for (var o2 = 0, s2 = n2.length; o2 < s2; o2++)
                if (n2[o2].fn === e2 && n2[o2].ctx === i2)
                  return o2;
            }
            return false;
          },
          once: function(t2, e2, i2) {
            if ("object" == typeof t2)
              for (var n2 in t2)
                this._on(n2, t2[n2], e2, true);
            else
              for (var o2 = 0, s2 = (t2 = F(t2)).length; o2 < s2; o2++)
                this._on(t2[o2], e2, i2, true);
            return this;
          },
          addEventParent: function(t2) {
            return this._eventParents = this._eventParents || {}, this._eventParents[h(t2)] = t2, this;
          },
          removeEventParent: function(t2) {
            return this._eventParents && delete this._eventParents[h(t2)], this;
          },
          _propagateEvent: function(t2) {
            for (var e2 in this._eventParents)
              this._eventParents[e2].fire(t2.type, l({
                layer: t2.target,
                propagatedFrom: t2.target
              }, t2), true);
          }
        }, it = (e.addEventListener = e.on, e.removeEventListener = e.clearAllEventListeners = e.off, e.addOneTimeEventListener = e.once, e.fireEvent = e.fire, e.hasEventListeners = e.listens, et.extend(e));
        function p(t2, e2, i2) {
          this.x = i2 ? Math.round(t2) : t2, this.y = i2 ? Math.round(e2) : e2;
        }
        var nt = Math.trunc || function(t2) {
          return 0 < t2 ? Math.floor(t2) : Math.ceil(t2);
        };
        function m(t2, e2, i2) {
          return t2 instanceof p ? t2 : d(t2) ? new p(t2[0], t2[1]) : null == t2 ? t2 : "object" == typeof t2 && "x" in t2 && "y" in t2 ? new p(t2.x, t2.y) : new p(t2, e2, i2);
        }
        function f(t2, e2) {
          if (t2)
            for (var i2 = e2 ? [t2, e2] : t2, n2 = 0, o2 = i2.length; n2 < o2; n2++)
              this.extend(i2[n2]);
        }
        function _(t2, e2) {
          return !t2 || t2 instanceof f ? t2 : new f(t2, e2);
        }
        function s(t2, e2) {
          if (t2)
            for (var i2 = e2 ? [t2, e2] : t2, n2 = 0, o2 = i2.length; n2 < o2; n2++)
              this.extend(i2[n2]);
        }
        function g(t2, e2) {
          return t2 instanceof s ? t2 : new s(t2, e2);
        }
        function v(t2, e2, i2) {
          if (isNaN(t2) || isNaN(e2))
            throw new Error("Invalid LatLng object: (" + t2 + ", " + e2 + ")");
          this.lat = +t2, this.lng = +e2, void 0 !== i2 && (this.alt = +i2);
        }
        function w(t2, e2, i2) {
          return t2 instanceof v ? t2 : d(t2) && "object" != typeof t2[0] ? 3 === t2.length ? new v(t2[0], t2[1], t2[2]) : 2 === t2.length ? new v(t2[0], t2[1]) : null : null == t2 ? t2 : "object" == typeof t2 && "lat" in t2 ? new v(t2.lat, "lng" in t2 ? t2.lng : t2.lon, t2.alt) : void 0 === e2 ? null : new v(t2, e2, i2);
        }
        p.prototype = {
          clone: function() {
            return new p(this.x, this.y);
          },
          add: function(t2) {
            return this.clone()._add(m(t2));
          },
          _add: function(t2) {
            return this.x += t2.x, this.y += t2.y, this;
          },
          subtract: function(t2) {
            return this.clone()._subtract(m(t2));
          },
          _subtract: function(t2) {
            return this.x -= t2.x, this.y -= t2.y, this;
          },
          divideBy: function(t2) {
            return this.clone()._divideBy(t2);
          },
          _divideBy: function(t2) {
            return this.x /= t2, this.y /= t2, this;
          },
          multiplyBy: function(t2) {
            return this.clone()._multiplyBy(t2);
          },
          _multiplyBy: function(t2) {
            return this.x *= t2, this.y *= t2, this;
          },
          scaleBy: function(t2) {
            return new p(this.x * t2.x, this.y * t2.y);
          },
          unscaleBy: function(t2) {
            return new p(this.x / t2.x, this.y / t2.y);
          },
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          },
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
          },
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
          },
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            return this.x = nt(this.x), this.y = nt(this.y), this;
          },
          distanceTo: function(t2) {
            var e2 = (t2 = m(t2)).x - this.x, t2 = t2.y - this.y;
            return Math.sqrt(e2 * e2 + t2 * t2);
          },
          equals: function(t2) {
            return (t2 = m(t2)).x === this.x && t2.y === this.y;
          },
          contains: function(t2) {
            return t2 = m(t2), Math.abs(t2.x) <= Math.abs(this.x) && Math.abs(t2.y) <= Math.abs(this.y);
          },
          toString: function() {
            return "Point(" + i(this.x) + ", " + i(this.y) + ")";
          }
        }, f.prototype = {
          extend: function(t2) {
            var e2, i2;
            if (t2) {
              if (t2 instanceof p || "number" == typeof t2[0] || "x" in t2)
                e2 = i2 = m(t2);
              else if (e2 = (t2 = _(t2)).min, i2 = t2.max, !e2 || !i2)
                return this;
              this.min || this.max ? (this.min.x = Math.min(e2.x, this.min.x), this.max.x = Math.max(
                i2.x,
                this.max.x
              ), this.min.y = Math.min(e2.y, this.min.y), this.max.y = Math.max(
                i2.y,
                this.max.y
              )) : (this.min = e2.clone(), this.max = i2.clone());
            }
            return this;
          },
          getCenter: function(t2) {
            return m((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t2);
          },
          getBottomLeft: function() {
            return m(this.min.x, this.max.y);
          },
          getTopRight: function() {
            return m(this.max.x, this.min.y);
          },
          getTopLeft: function() {
            return this.min;
          },
          getBottomRight: function() {
            return this.max;
          },
          getSize: function() {
            return this.max.subtract(this.min);
          },
          contains: function(t2) {
            var e2, i2;
            return (t2 = ("number" == typeof t2[0] || t2 instanceof p ? m : _)(t2)) instanceof f ? (e2 = t2.min, i2 = t2.max) : e2 = i2 = t2, e2.x >= this.min.x && i2.x <= this.max.x && e2.y >= this.min.y && i2.y <= this.max.y;
          },
          intersects: function(t2) {
            t2 = _(t2);
            var e2 = this.min, i2 = this.max, n2 = t2.min, t2 = t2.max, o2 = t2.x >= e2.x && n2.x <= i2.x, t2 = t2.y >= e2.y && n2.y <= i2.y;
            return o2 && t2;
          },
          overlaps: function(t2) {
            t2 = _(t2);
            var e2 = this.min, i2 = this.max, n2 = t2.min, t2 = t2.max, o2 = t2.x > e2.x && n2.x < i2.x, t2 = t2.y > e2.y && n2.y < i2.y;
            return o2 && t2;
          },
          isValid: function() {
            return !(!this.min || !this.max);
          },
          pad: function(t2) {
            var e2 = this.min, i2 = this.max, n2 = Math.abs(e2.x - i2.x) * t2, t2 = Math.abs(e2.y - i2.y) * t2;
            return _(m(e2.x - n2, e2.y - t2), m(i2.x + n2, i2.y + t2));
          },
          equals: function(t2) {
            return !!t2 && (t2 = _(t2), this.min.equals(t2.getTopLeft()) && this.max.equals(t2.getBottomRight()));
          }
        }, s.prototype = {
          extend: function(t2) {
            var e2, i2, n2 = this._southWest, o2 = this._northEast;
            if (t2 instanceof v)
              i2 = e2 = t2;
            else {
              if (!(t2 instanceof s))
                return t2 ? this.extend(w(t2) || g(t2)) : this;
              if (e2 = t2._southWest, i2 = t2._northEast, !e2 || !i2)
                return this;
            }
            return n2 || o2 ? (n2.lat = Math.min(e2.lat, n2.lat), n2.lng = Math.min(e2.lng, n2.lng), o2.lat = Math.max(i2.lat, o2.lat), o2.lng = Math.max(i2.lng, o2.lng)) : (this._southWest = new v(e2.lat, e2.lng), this._northEast = new v(i2.lat, i2.lng)), this;
          },
          pad: function(t2) {
            var e2 = this._southWest, i2 = this._northEast, n2 = Math.abs(e2.lat - i2.lat) * t2, t2 = Math.abs(e2.lng - i2.lng) * t2;
            return new s(new v(e2.lat - n2, e2.lng - t2), new v(i2.lat + n2, i2.lng + t2));
          },
          getCenter: function() {
            return new v((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
          },
          getSouthWest: function() {
            return this._southWest;
          },
          getNorthEast: function() {
            return this._northEast;
          },
          getNorthWest: function() {
            return new v(this.getNorth(), this.getWest());
          },
          getSouthEast: function() {
            return new v(this.getSouth(), this.getEast());
          },
          getWest: function() {
            return this._southWest.lng;
          },
          getSouth: function() {
            return this._southWest.lat;
          },
          getEast: function() {
            return this._northEast.lng;
          },
          getNorth: function() {
            return this._northEast.lat;
          },
          contains: function(t2) {
            t2 = ("number" == typeof t2[0] || t2 instanceof v || "lat" in t2 ? w : g)(t2);
            var e2, i2, n2 = this._southWest, o2 = this._northEast;
            return t2 instanceof s ? (e2 = t2.getSouthWest(), i2 = t2.getNorthEast()) : e2 = i2 = t2, e2.lat >= n2.lat && i2.lat <= o2.lat && e2.lng >= n2.lng && i2.lng <= o2.lng;
          },
          intersects: function(t2) {
            t2 = g(t2);
            var e2 = this._southWest, i2 = this._northEast, n2 = t2.getSouthWest(), t2 = t2.getNorthEast(), o2 = t2.lat >= e2.lat && n2.lat <= i2.lat, t2 = t2.lng >= e2.lng && n2.lng <= i2.lng;
            return o2 && t2;
          },
          overlaps: function(t2) {
            t2 = g(t2);
            var e2 = this._southWest, i2 = this._northEast, n2 = t2.getSouthWest(), t2 = t2.getNorthEast(), o2 = t2.lat > e2.lat && n2.lat < i2.lat, t2 = t2.lng > e2.lng && n2.lng < i2.lng;
            return o2 && t2;
          },
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          equals: function(t2, e2) {
            return !!t2 && (t2 = g(t2), this._southWest.equals(t2.getSouthWest(), e2) && this._northEast.equals(t2.getNorthEast(), e2));
          },
          isValid: function() {
            return !(!this._southWest || !this._northEast);
          }
        };
        var ot = {
          latLngToPoint: function(t2, e2) {
            t2 = this.projection.project(t2), e2 = this.scale(e2);
            return this.transformation._transform(t2, e2);
          },
          pointToLatLng: function(t2, e2) {
            e2 = this.scale(e2), t2 = this.transformation.untransform(t2, e2);
            return this.projection.unproject(t2);
          },
          project: function(t2) {
            return this.projection.project(t2);
          },
          unproject: function(t2) {
            return this.projection.unproject(t2);
          },
          scale: function(t2) {
            return 256 * Math.pow(2, t2);
          },
          zoom: function(t2) {
            return Math.log(t2 / 256) / Math.LN2;
          },
          getProjectedBounds: function(t2) {
            var e2;
            return this.infinite ? null : (e2 = this.projection.bounds, t2 = this.scale(t2), new f(this.transformation.transform(e2.min, t2), this.transformation.transform(e2.max, t2)));
          },
          infinite: !(v.prototype = {
            equals: function(t2, e2) {
              return !!t2 && (t2 = w(t2), Math.max(Math.abs(this.lat - t2.lat), Math.abs(this.lng - t2.lng)) <= (void 0 === e2 ? 1e-9 : e2));
            },
            toString: function(t2) {
              return "LatLng(" + i(this.lat, t2) + ", " + i(this.lng, t2) + ")";
            },
            distanceTo: function(t2) {
              return st.distance(this, w(t2));
            },
            wrap: function() {
              return st.wrapLatLng(this);
            },
            toBounds: function(t2) {
              var t2 = 180 * t2 / 40075017, e2 = t2 / Math.cos(Math.PI / 180 * this.lat);
              return g([this.lat - t2, this.lng - e2], [this.lat + t2, this.lng + e2]);
            },
            clone: function() {
              return new v(this.lat, this.lng, this.alt);
            }
          }),
          wrapLatLng: function(t2) {
            var e2 = this.wrapLng ? H(t2.lng, this.wrapLng, true) : t2.lng;
            return new v(this.wrapLat ? H(t2.lat, this.wrapLat, true) : t2.lat, e2, t2.alt);
          },
          wrapLatLngBounds: function(t2) {
            var e2 = t2.getCenter(), i2 = this.wrapLatLng(e2), n2 = e2.lat - i2.lat, e2 = e2.lng - i2.lng;
            return 0 == n2 && 0 == e2 ? t2 : (i2 = t2.getSouthWest(), t2 = t2.getNorthEast(), new s(new v(i2.lat - n2, i2.lng - e2), new v(t2.lat - n2, t2.lng - e2)));
          }
        }, st = l({}, ot, {
          wrapLng: [-180, 180],
          R: 6371e3,
          distance: function(t2, e2) {
            var i2 = Math.PI / 180, n2 = t2.lat * i2, o2 = e2.lat * i2, s2 = Math.sin((e2.lat - t2.lat) * i2 / 2), e2 = Math.sin((e2.lng - t2.lng) * i2 / 2), t2 = s2 * s2 + Math.cos(n2) * Math.cos(o2) * e2 * e2, i2 = 2 * Math.atan2(Math.sqrt(t2), Math.sqrt(1 - t2));
            return this.R * i2;
          }
        }), rt = 6378137, rt = {
          R: rt,
          MAX_LATITUDE: 85.0511287798,
          project: function(t2) {
            var e2 = Math.PI / 180, i2 = this.MAX_LATITUDE, i2 = Math.max(Math.min(i2, t2.lat), -i2), i2 = Math.sin(i2 * e2);
            return new p(this.R * t2.lng * e2, this.R * Math.log((1 + i2) / (1 - i2)) / 2);
          },
          unproject: function(t2) {
            var e2 = 180 / Math.PI;
            return new v((2 * Math.atan(Math.exp(t2.y / this.R)) - Math.PI / 2) * e2, t2.x * e2 / this.R);
          },
          bounds: new f([-(rt = rt * Math.PI), -rt], [rt, rt])
        };
        function at(t2, e2, i2, n2) {
          d(t2) ? (this._a = t2[0], this._b = t2[1], this._c = t2[2], this._d = t2[3]) : (this._a = t2, this._b = e2, this._c = i2, this._d = n2);
        }
        function ht(t2, e2, i2, n2) {
          return new at(t2, e2, i2, n2);
        }
        at.prototype = {
          transform: function(t2, e2) {
            return this._transform(t2.clone(), e2);
          },
          _transform: function(t2, e2) {
            return t2.x = (e2 = e2 || 1) * (this._a * t2.x + this._b), t2.y = e2 * (this._c * t2.y + this._d), t2;
          },
          untransform: function(t2, e2) {
            return new p((t2.x / (e2 = e2 || 1) - this._b) / this._a, (t2.y / e2 - this._d) / this._c);
          }
        };
        var lt = l({}, st, {
          code: "EPSG:3857",
          projection: rt,
          transformation: ht(lt = 0.5 / (Math.PI * rt.R), 0.5, -lt, 0.5)
        }), ut = l({}, lt, {
          code: "EPSG:900913"
        });
        function ct(t2) {
          return document.createElementNS("http://www.w3.org/2000/svg", t2);
        }
        function dt(t2, e2) {
          for (var i2, n2, o2, s2, r2 = "", a2 = 0, h2 = t2.length; a2 < h2; a2++) {
            for (i2 = 0, n2 = (o2 = t2[a2]).length; i2 < n2; i2++)
              r2 += (i2 ? "L" : "M") + (s2 = o2[i2]).x + " " + s2.y;
            r2 += e2 ? b.svg ? "z" : "x" : "";
          }
          return r2 || "M0 0";
        }
        var _t = document.documentElement.style, pt = "ActiveXObject" in window, mt = pt && !document.addEventListener, n = "msLaunchUri" in navigator && !("documentMode" in document), ft = y("webkit"), gt = y("android"), vt = y("android 2") || y("android 3"), yt = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), yt = gt && y("Google") && yt < 537 && !("AudioNode" in window), xt = !!window.opera, wt = !n && y("chrome"), bt = y("gecko") && !ft && !xt && !pt, Pt = !wt && y("safari"), Lt = y("phantom"), o = "OTransition" in _t, Tt = 0 === navigator.platform.indexOf("Win"), Mt = pt && "transition" in _t, zt = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !vt, _t = "MozPerspective" in _t, Ct = !window.L_DISABLE_3D && (Mt || zt || _t) && !o && !Lt, Zt = "undefined" != typeof orientation || y("mobile"), St = Zt && ft, Et = Zt && zt, kt = !window.PointerEvent && window.MSPointerEvent, Ot = !(!window.PointerEvent && !kt), At = "ontouchstart" in window || !!window.TouchEvent, Bt = !window.L_NO_TOUCH && (At || Ot), It = Zt && xt, Rt = Zt && bt, Nt = 1 < (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI), Dt = function() {
          var t2 = false;
          try {
            var e2 = Object.defineProperty({}, "passive", {
              get: function() {
                t2 = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", u, e2), window.removeEventListener(
              "testPassiveEventSupport",
              u,
              e2
            );
          } catch (t3) {
          }
          return t2;
        }(), jt = !!document.createElement("canvas").getContext, Ht = !(!document.createElementNS || !ct("svg").createSVGRect), Wt = !!Ht && ((Wt = document.createElement("div")).innerHTML = "<svg/>", "http://www.w3.org/2000/svg" === (Wt.firstChild && Wt.firstChild.namespaceURI));
        function y(t2) {
          return 0 <= navigator.userAgent.toLowerCase().indexOf(t2);
        }
        var b = {
          ie: pt,
          ielt9: mt,
          edge: n,
          webkit: ft,
          android: gt,
          android23: vt,
          androidStock: yt,
          opera: xt,
          chrome: wt,
          gecko: bt,
          safari: Pt,
          phantom: Lt,
          opera12: o,
          win: Tt,
          ie3d: Mt,
          webkit3d: zt,
          gecko3d: _t,
          any3d: Ct,
          mobile: Zt,
          mobileWebkit: St,
          mobileWebkit3d: Et,
          msPointer: kt,
          pointer: Ot,
          touch: Bt,
          touchNative: At,
          mobileOpera: It,
          mobileGecko: Rt,
          retina: Nt,
          passiveEvents: Dt,
          canvas: jt,
          svg: Ht,
          vml: !Ht && function() {
            try {
              var t2 = document.createElement("div"), e2 = (t2.innerHTML = '<v:shape adj="1"/>', t2.firstChild);
              return e2.style.behavior = "url(#default#VML)", e2 && "object" == typeof e2.adj;
            } catch (t3) {
              return false;
            }
          }(),
          inlineSvg: Wt,
          mac: 0 === navigator.platform.indexOf("Mac"),
          linux: 0 === navigator.platform.indexOf("Linux")
        }, Ft = b.msPointer ? "MSPointerDown" : "pointerdown", Ut = b.msPointer ? "MSPointerMove" : "pointermove", Vt = b.msPointer ? "MSPointerUp" : "pointerup", qt = b.msPointer ? "MSPointerCancel" : "pointercancel", Gt = {
          touchstart: Ft,
          touchmove: Ut,
          touchend: Vt,
          touchcancel: qt
        }, Kt = {
          touchstart: function(t2, e2) {
            e2.MSPOINTER_TYPE_TOUCH && e2.pointerType === e2.MSPOINTER_TYPE_TOUCH && O(e2);
            ee(t2, e2);
          },
          touchmove: ee,
          touchend: ee,
          touchcancel: ee
        }, Yt = {}, Xt = false;
        function Jt(t2, e2, i2) {
          return "touchstart" !== e2 || Xt || (document.addEventListener(Ft, $t, true), document.addEventListener(
            Ut,
            Qt,
            true
          ), document.addEventListener(Vt, te, true), document.addEventListener(qt, te, true), Xt = true), Kt[e2] ? (i2 = Kt[e2].bind(this, i2), t2.addEventListener(Gt[e2], i2, false), i2) : (console.warn(
            "wrong event specified:",
            e2
          ), u);
        }
        function $t(t2) {
          Yt[t2.pointerId] = t2;
        }
        function Qt(t2) {
          Yt[t2.pointerId] && (Yt[t2.pointerId] = t2);
        }
        function te(t2) {
          delete Yt[t2.pointerId];
        }
        function ee(t2, e2) {
          if (e2.pointerType !== (e2.MSPOINTER_TYPE_MOUSE || "mouse")) {
            for (var i2 in e2.touches = [], Yt)
              e2.touches.push(Yt[i2]);
            e2.changedTouches = [e2], t2(e2);
          }
        }
        var ie = 200;
        function ne(t2, i2) {
          t2.addEventListener("dblclick", i2);
          var n2, o2 = 0;
          function e2(t3) {
            var e3;
            1 !== t3.detail ? n2 = t3.detail : "mouse" === t3.pointerType || t3.sourceCapabilities && !t3.sourceCapabilities.firesTouchEvents || ((e3 = Ne(t3)).some(function(t4) {
              return t4 instanceof HTMLLabelElement && t4.attributes.for;
            }) && !e3.some(function(t4) {
              return t4 instanceof HTMLInputElement || t4 instanceof HTMLSelectElement;
            }) || ((e3 = Date.now()) - o2 <= ie ? 2 === ++n2 && i2(function(t4) {
              var e4, i3, n3 = {};
              for (i3 in t4)
                e4 = t4[i3], n3[i3] = e4 && e4.bind ? e4.bind(t4) : e4;
              return (t4 = n3).type = "dblclick", n3.detail = 2, n3.isTrusted = false, n3._simulated = true, n3;
            }(t3)) : n2 = 1, o2 = e3));
          }
          return t2.addEventListener("click", e2), {
            dblclick: i2,
            simDblclick: e2
          };
        }
        var oe, se, re, ae, he, le, ue = we([
          "transform",
          "webkitTransform",
          "OTransform",
          "MozTransform",
          "msTransform"
        ]), ce = we(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), de = "webkitTransition" === ce || "OTransition" === ce ? ce + "End" : "transitionend";
        function _e(t2) {
          return "string" == typeof t2 ? document.getElementById(t2) : t2;
        }
        function pe(t2, e2) {
          var i2 = t2.style[e2] || t2.currentStyle && t2.currentStyle[e2];
          return "auto" === (i2 = i2 && "auto" !== i2 || !document.defaultView ? i2 : (t2 = document.defaultView.getComputedStyle(t2, null)) ? t2[e2] : null) ? null : i2;
        }
        function P(t2, e2, i2) {
          t2 = document.createElement(t2);
          return t2.className = e2 || "", i2 && i2.appendChild(t2), t2;
        }
        function T(t2) {
          var e2 = t2.parentNode;
          e2 && e2.removeChild(t2);
        }
        function me(t2) {
          for (; t2.firstChild; )
            t2.removeChild(t2.firstChild);
        }
        function fe(t2) {
          var e2 = t2.parentNode;
          e2 && e2.lastChild !== t2 && e2.appendChild(t2);
        }
        function ge(t2) {
          var e2 = t2.parentNode;
          e2 && e2.firstChild !== t2 && e2.insertBefore(t2, e2.firstChild);
        }
        function ve(t2, e2) {
          return void 0 !== t2.classList ? t2.classList.contains(e2) : 0 < (t2 = xe(t2)).length && new RegExp("(^|\\s)" + e2 + "(\\s|$)").test(t2);
        }
        function M(t2, e2) {
          var i2;
          if (void 0 !== t2.classList)
            for (var n2 = F(e2), o2 = 0, s2 = n2.length; o2 < s2; o2++)
              t2.classList.add(n2[o2]);
          else
            ve(t2, e2) || ye(t2, ((i2 = xe(t2)) ? i2 + " " : "") + e2);
        }
        function z(t2, e2) {
          void 0 !== t2.classList ? t2.classList.remove(e2) : ye(t2, W((" " + xe(t2) + " ").replace(" " + e2 + " ", " ")));
        }
        function ye(t2, e2) {
          void 0 === t2.className.baseVal ? t2.className = e2 : t2.className.baseVal = e2;
        }
        function xe(t2) {
          return void 0 === (t2 = t2.correspondingElement ? t2.correspondingElement : t2).className.baseVal ? t2.className : t2.className.baseVal;
        }
        function C(t2, e2) {
          if ("opacity" in t2.style)
            t2.style.opacity = e2;
          else if ("filter" in t2.style) {
            var i2 = false, n2 = "DXImageTransform.Microsoft.Alpha";
            try {
              i2 = t2.filters.item(n2);
            } catch (t3) {
              if (1 === e2)
                return;
            }
            e2 = Math.round(100 * e2), i2 ? (i2.Enabled = 100 !== e2, i2.Opacity = e2) : t2.style.filter += " progid:" + n2 + "(opacity=" + e2 + ")";
          }
        }
        function we(t2) {
          for (var e2 = document.documentElement.style, i2 = 0; i2 < t2.length; i2++)
            if (t2[i2] in e2)
              return t2[i2];
          return false;
        }
        function be(t2, e2, i2) {
          e2 = e2 || new p(0, 0);
          t2.style[ue] = (b.ie3d ? "translate(" + e2.x + "px," + e2.y + "px)" : "translate3d(" + e2.x + "px," + e2.y + "px,0)") + (i2 ? " scale(" + i2 + ")" : "");
        }
        function Z(t2, e2) {
          t2._leaflet_pos = e2, b.any3d ? be(t2, e2) : (t2.style.left = e2.x + "px", t2.style.top = e2.y + "px");
        }
        function Pe(t2) {
          return t2._leaflet_pos || new p(0, 0);
        }
        function Le() {
          S(window, "dragstart", O);
        }
        function Te() {
          k(window, "dragstart", O);
        }
        function Me(t2) {
          for (; -1 === t2.tabIndex; )
            t2 = t2.parentNode;
          t2.style && (ze(), le = (he = t2).style.outlineStyle, t2.style.outlineStyle = "none", S(window, "keydown", ze));
        }
        function ze() {
          he && (he.style.outlineStyle = le, le = he = void 0, k(window, "keydown", ze));
        }
        function Ce(t2) {
          for (; !((t2 = t2.parentNode).offsetWidth && t2.offsetHeight || t2 === document.body); )
            ;
          return t2;
        }
        function Ze(t2) {
          var e2 = t2.getBoundingClientRect();
          return {
            x: e2.width / t2.offsetWidth || 1,
            y: e2.height / t2.offsetHeight || 1,
            boundingClientRect: e2
          };
        }
        ae = "onselectstart" in document ? (re = function() {
          S(window, "selectstart", O);
        }, function() {
          k(window, "selectstart", O);
        }) : (se = we(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]), re = function() {
          var t2;
          se && (t2 = document.documentElement.style, oe = t2[se], t2[se] = "none");
        }, function() {
          se && (document.documentElement.style[se] = oe, oe = void 0);
        });
        pt = {
          __proto__: null,
          TRANSFORM: ue,
          TRANSITION: ce,
          TRANSITION_END: de,
          get: _e,
          getStyle: pe,
          create: P,
          remove: T,
          empty: me,
          toFront: fe,
          toBack: ge,
          hasClass: ve,
          addClass: M,
          removeClass: z,
          setClass: ye,
          getClass: xe,
          setOpacity: C,
          testProp: we,
          setTransform: be,
          setPosition: Z,
          getPosition: Pe,
          get disableTextSelection() {
            return re;
          },
          get enableTextSelection() {
            return ae;
          },
          disableImageDrag: Le,
          enableImageDrag: Te,
          preventOutline: Me,
          restoreOutline: ze,
          getSizedParentNode: Ce,
          getScale: Ze
        };
        function S(t2, e2, i2, n2) {
          if (e2 && "object" == typeof e2)
            for (var o2 in e2)
              ke(t2, o2, e2[o2], i2);
          else
            for (var s2 = 0, r2 = (e2 = F(e2)).length; s2 < r2; s2++)
              ke(t2, e2[s2], i2, n2);
          return this;
        }
        var E = "_leaflet_events";
        function k(t2, e2, i2, n2) {
          if (1 === arguments.length)
            Se(t2), delete t2[E];
          else if (e2 && "object" == typeof e2)
            for (var o2 in e2)
              Oe(t2, o2, e2[o2], i2);
          else if (e2 = F(e2), 2 === arguments.length)
            Se(t2, function(t3) {
              return -1 !== G(e2, t3);
            });
          else
            for (var s2 = 0, r2 = e2.length; s2 < r2; s2++)
              Oe(t2, e2[s2], i2, n2);
          return this;
        }
        function Se(t2, e2) {
          for (var i2 in t2[E]) {
            var n2 = i2.split(/\d/)[0];
            e2 && !e2(n2) || Oe(t2, n2, null, null, i2);
          }
        }
        var Ee = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function ke(e2, t2, i2, n2) {
          var o2, s2, r2 = t2 + h(i2) + (n2 ? "_" + h(n2) : "");
          e2[E] && e2[E][r2] || (s2 = o2 = function(t3) {
            return i2.call(n2 || e2, t3 || window.event);
          }, !b.touchNative && b.pointer && 0 === t2.indexOf("touch") ? o2 = Jt(e2, t2, o2) : b.touch && "dblclick" === t2 ? o2 = ne(e2, o2) : "addEventListener" in e2 ? "touchstart" === t2 || "touchmove" === t2 || "wheel" === t2 || "mousewheel" === t2 ? e2.addEventListener(Ee[t2] || t2, o2, !!b.passiveEvents && {
            passive: false
          }) : "mouseenter" === t2 || "mouseleave" === t2 ? e2.addEventListener(Ee[t2], o2 = function(t3) {
            t3 = t3 || window.event, We(e2, t3) && s2(t3);
          }, false) : e2.addEventListener(t2, s2, false) : e2.attachEvent("on" + t2, o2), e2[E] = e2[E] || {}, e2[E][r2] = o2);
        }
        function Oe(t2, e2, i2, n2, o2) {
          o2 = o2 || e2 + h(i2) + (n2 ? "_" + h(n2) : "");
          var s2, r2, i2 = t2[E] && t2[E][o2];
          i2 && (!b.touchNative && b.pointer && 0 === e2.indexOf("touch") ? (n2 = t2, r2 = i2, Gt[s2 = e2] ? n2.removeEventListener(Gt[s2], r2, false) : console.warn("wrong event specified:", s2)) : b.touch && "dblclick" === e2 ? (n2 = i2, (r2 = t2).removeEventListener("dblclick", n2.dblclick), r2.removeEventListener("click", n2.simDblclick)) : "removeEventListener" in t2 ? t2.removeEventListener(Ee[e2] || e2, i2, false) : t2.detachEvent("on" + e2, i2), t2[E][o2] = null);
        }
        function Ae(t2) {
          return t2.stopPropagation ? t2.stopPropagation() : t2.originalEvent ? t2.originalEvent._stopped = true : t2.cancelBubble = true, this;
        }
        function Be(t2) {
          return ke(t2, "wheel", Ae), this;
        }
        function Ie(t2) {
          return S(t2, "mousedown touchstart dblclick contextmenu", Ae), t2._leaflet_disable_click = true, this;
        }
        function O(t2) {
          return t2.preventDefault ? t2.preventDefault() : t2.returnValue = false, this;
        }
        function Re(t2) {
          return O(t2), Ae(t2), this;
        }
        function Ne(t2) {
          if (t2.composedPath)
            return t2.composedPath();
          for (var e2 = [], i2 = t2.target; i2; )
            e2.push(i2), i2 = i2.parentNode;
          return e2;
        }
        function De(t2, e2) {
          var i2, n2;
          return e2 ? (n2 = (i2 = Ze(e2)).boundingClientRect, new p((t2.clientX - n2.left) / i2.x - e2.clientLeft, (t2.clientY - n2.top) / i2.y - e2.clientTop)) : new p(t2.clientX, t2.clientY);
        }
        var je = b.linux && b.chrome ? window.devicePixelRatio : b.mac ? 3 * window.devicePixelRatio : 0 < window.devicePixelRatio ? 2 * window.devicePixelRatio : 1;
        function He(t2) {
          return b.edge ? t2.wheelDeltaY / 2 : t2.deltaY && 0 === t2.deltaMode ? -t2.deltaY / je : t2.deltaY && 1 === t2.deltaMode ? 20 * -t2.deltaY : t2.deltaY && 2 === t2.deltaMode ? 60 * -t2.deltaY : t2.deltaX || t2.deltaZ ? 0 : t2.wheelDelta ? (t2.wheelDeltaY || t2.wheelDelta) / 2 : t2.detail && Math.abs(t2.detail) < 32765 ? 20 * -t2.detail : t2.detail ? t2.detail / -32765 * 60 : 0;
        }
        function We(t2, e2) {
          var i2 = e2.relatedTarget;
          if (!i2)
            return true;
          try {
            for (; i2 && i2 !== t2; )
              i2 = i2.parentNode;
          } catch (t3) {
            return false;
          }
          return i2 !== t2;
        }
        var mt = {
          __proto__: null,
          on: S,
          off: k,
          stopPropagation: Ae,
          disableScrollPropagation: Be,
          disableClickPropagation: Ie,
          preventDefault: O,
          stop: Re,
          getPropagationPath: Ne,
          getMousePosition: De,
          getWheelDelta: He,
          isExternalTarget: We,
          addListener: S,
          removeListener: k
        }, Fe = it.extend({
          run: function(t2, e2, i2, n2) {
            this.stop(), this._el = t2, this._inProgress = true, this._duration = i2 || 0.25, this._easeOutPower = 1 / Math.max(n2 || 0.5, 0.2), this._startPos = Pe(t2), this._offset = e2.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
          },
          stop: function() {
            this._inProgress && (this._step(true), this._complete());
          },
          _animate: function() {
            this._animId = x(this._animate, this), this._step();
          },
          _step: function(t2) {
            var e2 = +/* @__PURE__ */ new Date() - this._startTime, i2 = 1e3 * this._duration;
            e2 < i2 ? this._runFrame(this._easeOut(e2 / i2), t2) : (this._runFrame(1), this._complete());
          },
          _runFrame: function(t2, e2) {
            t2 = this._startPos.add(this._offset.multiplyBy(t2));
            e2 && t2._round(), Z(this._el, t2), this.fire("step");
          },
          _complete: function() {
            r(this._animId), this._inProgress = false, this.fire("end");
          },
          _easeOut: function(t2) {
            return 1 - Math.pow(1 - t2, this._easeOutPower);
          }
        }), A = it.extend({
          options: {
            crs: lt,
            center: void 0,
            zoom: void 0,
            minZoom: void 0,
            maxZoom: void 0,
            layers: [],
            maxBounds: void 0,
            renderer: void 0,
            zoomAnimation: true,
            zoomAnimationThreshold: 4,
            fadeAnimation: true,
            markerZoomAnimation: true,
            transform3DLimit: 8388608,
            zoomSnap: 1,
            zoomDelta: 1,
            trackResize: true
          },
          initialize: function(t2, e2) {
            e2 = c(this, e2), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = true, this._initContainer(t2), this._initLayout(), this._onResize = a(this._onResize, this), this._initEvents(), e2.maxBounds && this.setMaxBounds(e2.maxBounds), void 0 !== e2.zoom && (this._zoom = this._limitZoom(e2.zoom)), e2.center && void 0 !== e2.zoom && this.setView(w(e2.center), e2.zoom, {
              reset: true
            }), this.callInitHooks(), this._zoomAnimated = ce && b.any3d && !b.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), S(
              this._proxy,
              de,
              this._catchTransitionEnd,
              this
            )), this._addLayers(this.options.layers);
          },
          setView: function(t2, e2, i2) {
            if ((e2 = void 0 === e2 ? this._zoom : this._limitZoom(e2), t2 = this._limitCenter(w(t2), e2, this.options.maxBounds), i2 = i2 || {}, this._stop(), this._loaded && !i2.reset && true !== i2) && (void 0 !== i2.animate && (i2.zoom = l({
              animate: i2.animate
            }, i2.zoom), i2.pan = l({
              animate: i2.animate,
              duration: i2.duration
            }, i2.pan)), this._zoom !== e2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(
              t2,
              e2,
              i2.zoom
            ) : this._tryAnimatedPan(t2, i2.pan)))
              return clearTimeout(this._sizeTimer), this;
            return this._resetView(t2, e2, i2.pan && i2.pan.noMoveStart), this;
          },
          setZoom: function(t2, e2) {
            return this._loaded ? this.setView(this.getCenter(), t2, {
              zoom: e2
            }) : (this._zoom = t2, this);
          },
          zoomIn: function(t2, e2) {
            return t2 = t2 || (b.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t2, e2);
          },
          zoomOut: function(t2, e2) {
            return t2 = t2 || (b.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t2, e2);
          },
          setZoomAround: function(t2, e2, i2) {
            var n2 = this.getZoomScale(e2), o2 = this.getSize().divideBy(2), t2 = (t2 instanceof p ? t2 : this.latLngToContainerPoint(t2)).subtract(o2).multiplyBy(1 - 1 / n2), n2 = this.containerPointToLatLng(o2.add(t2));
            return this.setView(n2, e2, {
              zoom: i2
            });
          },
          _getBoundsCenterZoom: function(t2, e2) {
            e2 = e2 || {}, t2 = t2.getBounds ? t2.getBounds() : g(t2);
            var i2 = m(e2.paddingTopLeft || e2.padding || [0, 0]), n2 = m(e2.paddingBottomRight || e2.padding || [0, 0]), o2 = this.getBoundsZoom(t2, false, i2.add(n2));
            return (o2 = "number" == typeof e2.maxZoom ? Math.min(e2.maxZoom, o2) : o2) === 1 / 0 ? {
              center: t2.getCenter(),
              zoom: o2
            } : (e2 = n2.subtract(i2).divideBy(2), n2 = this.project(t2.getSouthWest(), o2), i2 = this.project(t2.getNorthEast(), o2), {
              center: this.unproject(n2.add(i2).divideBy(2).add(e2), o2),
              zoom: o2
            });
          },
          fitBounds: function(t2, e2) {
            if ((t2 = g(t2)).isValid())
              return t2 = this._getBoundsCenterZoom(t2, e2), this.setView(
                t2.center,
                t2.zoom,
                e2
              );
            throw new Error("Bounds are not valid.");
          },
          fitWorld: function(t2) {
            return this.fitBounds([
              [-90, -180],
              [90, 180]
            ], t2);
          },
          panTo: function(t2, e2) {
            return this.setView(t2, this._zoom, {
              pan: e2
            });
          },
          panBy: function(t2, e2) {
            var i2;
            return e2 = e2 || {}, (t2 = m(t2).round()).x || t2.y ? (true === e2.animate || this.getSize().contains(t2) ? (this._panAnim || (this._panAnim = new Fe(), this._panAnim.on({
              step: this._onPanTransitionStep,
              end: this._onPanTransitionEnd
            }, this)), e2.noMoveStart || this.fire("movestart"), false !== e2.animate ? (M(this._mapPane, "leaflet-pan-anim"), i2 = this._getMapPanePos().subtract(t2).round(), this._panAnim.run(this._mapPane, i2, e2.duration || 0.25, e2.easeLinearity)) : (this._rawPanBy(t2), this.fire("move").fire(
              "moveend"
            ))) : this._resetView(this.unproject(this.project(this.getCenter()).add(t2)), this.getZoom()), this) : this.fire("moveend");
          },
          flyTo: function(n2, o2, t2) {
            if (false === (t2 = t2 || {}).animate || !b.any3d)
              return this.setView(n2, o2, t2);
            this._stop();
            var s2 = this.project(this.getCenter()), r2 = this.project(n2), e2 = this.getSize(), a2 = this._zoom, h2 = (n2 = w(n2), o2 = void 0 === o2 ? a2 : o2, Math.max(e2.x, e2.y)), i2 = h2 * this.getZoomScale(a2, o2), l2 = r2.distanceTo(s2) || 1, u2 = 1.42, c2 = u2 * u2;
            function d2(t3) {
              t3 = (i2 * i2 - h2 * h2 + (t3 ? -1 : 1) * c2 * c2 * l2 * l2) / (2 * (t3 ? i2 : h2) * c2 * l2), t3 = Math.sqrt(t3 * t3 + 1) - t3;
              return t3 < 1e-9 ? -18 : Math.log(t3);
            }
            function _2(t3) {
              return (Math.exp(t3) - Math.exp(-t3)) / 2;
            }
            function p2(t3) {
              return (Math.exp(t3) + Math.exp(-t3)) / 2;
            }
            var m2 = d2(0);
            function f2(t3) {
              return h2 * (p2(m2) * (_2(t3 = m2 + u2 * t3) / p2(t3)) - _2(m2)) / c2;
            }
            var g2 = Date.now(), v2 = (d2(1) - m2) / u2, y2 = t2.duration ? 1e3 * t2.duration : 1e3 * v2 * 0.8;
            return this._moveStart(true, t2.noMoveStart), function t3() {
              var e3 = (Date.now() - g2) / y2, i3 = (1 - Math.pow(1 - e3, 1.5)) * v2;
              e3 <= 1 ? (this._flyToFrame = x(t3, this), this._move(this.unproject(s2.add(r2.subtract(
                s2
              ).multiplyBy(f2(i3) / l2)), a2), this.getScaleZoom(h2 / (e3 = i3, h2 * (p2(
                m2
              ) / p2(m2 + u2 * e3))), a2), {
                flyTo: true
              })) : this._move(n2, o2)._moveEnd(true);
            }.call(this), this;
          },
          flyToBounds: function(t2, e2) {
            t2 = this._getBoundsCenterZoom(t2, e2);
            return this.flyTo(t2.center, t2.zoom, e2);
          },
          setMaxBounds: function(t2) {
            return t2 = g(t2), this.listens("moveend", this._panInsideMaxBounds) && this.off(
              "moveend",
              this._panInsideMaxBounds
            ), t2.isValid() ? (this.options.maxBounds = t2, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
          },
          setMinZoom: function(t2) {
            var e2 = this.options.minZoom;
            return this.options.minZoom = t2, this._loaded && e2 !== t2 && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t2) : this;
          },
          setMaxZoom: function(t2) {
            var e2 = this.options.maxZoom;
            return this.options.maxZoom = t2, this._loaded && e2 !== t2 && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t2) : this;
          },
          panInsideBounds: function(t2, e2) {
            this._enforcingBounds = true;
            var i2 = this.getCenter(), t2 = this._limitCenter(i2, this._zoom, g(t2));
            return i2.equals(t2) || this.panTo(t2, e2), this._enforcingBounds = false, this;
          },
          panInside: function(t2, e2) {
            var i2 = m((e2 = e2 || {}).paddingTopLeft || e2.padding || [0, 0]), n2 = m(e2.paddingBottomRight || e2.padding || [0, 0]), o2 = this.project(this.getCenter()), t2 = this.project(t2), s2 = this.getPixelBounds(), i2 = _([s2.min.add(i2), s2.max.subtract(n2)]), s2 = i2.getSize();
            return i2.contains(t2) || (this._enforcingBounds = true, n2 = t2.subtract(i2.getCenter()), i2 = i2.extend(t2).getSize().subtract(s2), o2.x += n2.x < 0 ? -i2.x : i2.x, o2.y += n2.y < 0 ? -i2.y : i2.y, this.panTo(this.unproject(o2), e2), this._enforcingBounds = false), this;
          },
          invalidateSize: function(t2) {
            if (!this._loaded)
              return this;
            t2 = l({
              animate: false,
              pan: true
            }, true === t2 ? {
              animate: true
            } : t2);
            var e2 = this.getSize(), i2 = (this._sizeChanged = true, this._lastCenter = null, this.getSize()), n2 = e2.divideBy(2).round(), o2 = i2.divideBy(2).round(), n2 = n2.subtract(o2);
            return n2.x || n2.y ? (t2.animate && t2.pan ? this.panBy(n2) : (t2.pan && this._rawPanBy(n2), this.fire("move"), t2.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(a(this.fire, this, "moveend"), 200)) : this.fire(
              "moveend"
            )), this.fire("resize", {
              oldSize: e2,
              newSize: i2
            })) : this;
          },
          stop: function() {
            return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire(
              "viewreset"
            ), this._stop();
          },
          locate: function(t2) {
            var e2, i2;
            return t2 = this._locateOptions = l({
              timeout: 1e4,
              watch: false
            }, t2), "geolocation" in navigator ? (e2 = a(this._handleGeolocationResponse, this), i2 = a(this._handleGeolocationError, this), t2.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e2, i2, t2) : navigator.geolocation.getCurrentPosition(
              e2,
              i2,
              t2
            )) : this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            }), this;
          },
          stopLocate: function() {
            return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = false), this;
          },
          _handleGeolocationError: function(t2) {
            var e2;
            this._container._leaflet_id && (e2 = t2.code, t2 = t2.message || (1 === e2 ? "permission denied" : 2 === e2 ? "position unavailable" : "timeout"), this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire(
              "locationerror",
              {
                code: e2,
                message: "Geolocation error: " + t2 + "."
              }
            ));
          },
          _handleGeolocationResponse: function(t2) {
            if (this._container._leaflet_id) {
              var e2, i2, n2 = new v(t2.coords.latitude, t2.coords.longitude), o2 = n2.toBounds(2 * t2.coords.accuracy), s2 = this._locateOptions, r2 = (s2.setView && (e2 = this.getBoundsZoom(o2), this.setView(n2, s2.maxZoom ? Math.min(
                e2,
                s2.maxZoom
              ) : e2)), {
                latlng: n2,
                bounds: o2,
                timestamp: t2.timestamp
              });
              for (i2 in t2.coords)
                "number" == typeof t2.coords[i2] && (r2[i2] = t2.coords[i2]);
              this.fire("locationfound", r2);
            }
          },
          addHandler: function(t2, e2) {
            return e2 && (e2 = this[t2] = new e2(this), this._handlers.push(e2), this.options[t2] && e2.enable()), this;
          },
          remove: function() {
            if (this._initEvents(true), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
              throw new Error("Map container is being reused by another instance");
            try {
              delete this._container._leaflet_id, delete this._containerId;
            } catch (t3) {
              this._container._leaflet_id = void 0, this._containerId = void 0;
            }
            for (var t2 in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), T(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (r(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload"), this._layers)
              this._layers[t2].remove();
            for (t2 in this._panes)
              T(this._panes[t2]);
            return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
          },
          createPane: function(t2, e2) {
            e2 = P("div", "leaflet-pane" + (t2 ? " leaflet-" + t2.replace("Pane", "") + "-pane" : ""), e2 || this._mapPane);
            return t2 && (this._panes[t2] = e2), e2;
          },
          getCenter: function() {
            return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          getZoom: function() {
            return this._zoom;
          },
          getBounds: function() {
            var t2 = this.getPixelBounds();
            return new s(this.unproject(t2.getBottomLeft()), this.unproject(t2.getTopRight()));
          },
          getMinZoom: function() {
            return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          getMaxZoom: function() {
            return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
          },
          getBoundsZoom: function(t2, e2, i2) {
            t2 = g(t2), i2 = m(i2 || [0, 0]);
            var n2 = this.getZoom() || 0, o2 = this.getMinZoom(), s2 = this.getMaxZoom(), r2 = t2.getNorthWest(), t2 = t2.getSouthEast(), i2 = this.getSize().subtract(i2), t2 = _(this.project(t2, n2), this.project(r2, n2)).getSize(), r2 = b.any3d ? this.options.zoomSnap : 1, a2 = i2.x / t2.x, i2 = i2.y / t2.y, t2 = e2 ? Math.max(a2, i2) : Math.min(a2, i2), n2 = this.getScaleZoom(t2, n2);
            return r2 && (n2 = Math.round(n2 / (r2 / 100)) * (r2 / 100), n2 = e2 ? Math.ceil(n2 / r2) * r2 : Math.floor(n2 / r2) * r2), Math.max(o2, Math.min(s2, n2));
          },
          getSize: function() {
            return this._size && !this._sizeChanged || (this._size = new p(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = false), this._size.clone();
          },
          getPixelBounds: function(t2, e2) {
            t2 = this._getTopLeftPoint(t2, e2);
            return new f(t2, t2.add(this.getSize()));
          },
          getPixelOrigin: function() {
            return this._checkIfLoaded(), this._pixelOrigin;
          },
          getPixelWorldBounds: function(t2) {
            return this.options.crs.getProjectedBounds(void 0 === t2 ? this.getZoom() : t2);
          },
          getPane: function(t2) {
            return "string" == typeof t2 ? this._panes[t2] : t2;
          },
          getPanes: function() {
            return this._panes;
          },
          getContainer: function() {
            return this._container;
          },
          getZoomScale: function(t2, e2) {
            var i2 = this.options.crs;
            return e2 = void 0 === e2 ? this._zoom : e2, i2.scale(t2) / i2.scale(e2);
          },
          getScaleZoom: function(t2, e2) {
            var i2 = this.options.crs, t2 = (e2 = void 0 === e2 ? this._zoom : e2, i2.zoom(t2 * i2.scale(e2)));
            return isNaN(t2) ? 1 / 0 : t2;
          },
          project: function(t2, e2) {
            return e2 = void 0 === e2 ? this._zoom : e2, this.options.crs.latLngToPoint(w(t2), e2);
          },
          unproject: function(t2, e2) {
            return e2 = void 0 === e2 ? this._zoom : e2, this.options.crs.pointToLatLng(m(t2), e2);
          },
          layerPointToLatLng: function(t2) {
            t2 = m(t2).add(this.getPixelOrigin());
            return this.unproject(t2);
          },
          latLngToLayerPoint: function(t2) {
            return this.project(w(t2))._round()._subtract(this.getPixelOrigin());
          },
          wrapLatLng: function(t2) {
            return this.options.crs.wrapLatLng(w(t2));
          },
          wrapLatLngBounds: function(t2) {
            return this.options.crs.wrapLatLngBounds(g(t2));
          },
          distance: function(t2, e2) {
            return this.options.crs.distance(w(t2), w(e2));
          },
          containerPointToLayerPoint: function(t2) {
            return m(t2).subtract(this._getMapPanePos());
          },
          layerPointToContainerPoint: function(t2) {
            return m(t2).add(this._getMapPanePos());
          },
          containerPointToLatLng: function(t2) {
            t2 = this.containerPointToLayerPoint(m(t2));
            return this.layerPointToLatLng(t2);
          },
          latLngToContainerPoint: function(t2) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(w(t2)));
          },
          mouseEventToContainerPoint: function(t2) {
            return De(t2, this._container);
          },
          mouseEventToLayerPoint: function(t2) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t2));
          },
          mouseEventToLatLng: function(t2) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(t2));
          },
          _initContainer: function(t2) {
            t2 = this._container = _e(t2);
            if (!t2)
              throw new Error("Map container not found.");
            if (t2._leaflet_id)
              throw new Error("Map container is already initialized.");
            S(t2, "scroll", this._onScroll, this), this._containerId = h(t2);
          },
          _initLayout: function() {
            var t2 = this._container, e2 = (this._fadeAnimated = this.options.fadeAnimation && b.any3d, M(
              t2,
              "leaflet-container" + (b.touch ? " leaflet-touch" : "") + (b.retina ? " leaflet-retina" : "") + (b.ielt9 ? " leaflet-oldie" : "") + (b.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : "")
            ), pe(t2, "position"));
            "absolute" !== e2 && "relative" !== e2 && "fixed" !== e2 && "sticky" !== e2 && (t2.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
          },
          _initPanes: function() {
            var t2 = this._panes = {};
            this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), Z(
              this._mapPane,
              new p(0, 0)
            ), this.createPane("tilePane"), this.createPane(
              "overlayPane"
            ), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (M(t2.markerPane, "leaflet-zoom-hide"), M(
              t2.shadowPane,
              "leaflet-zoom-hide"
            ));
          },
          _resetView: function(t2, e2, i2) {
            Z(this._mapPane, new p(0, 0));
            var n2 = !this._loaded, o2 = (this._loaded = true, e2 = this._limitZoom(e2), this.fire("viewprereset"), this._zoom !== e2);
            this._moveStart(o2, i2)._move(t2, e2)._moveEnd(o2), this.fire("viewreset"), n2 && this.fire(
              "load"
            );
          },
          _moveStart: function(t2, e2) {
            return t2 && this.fire("zoomstart"), e2 || this.fire("movestart"), this;
          },
          _move: function(t2, e2, i2, n2) {
            void 0 === e2 && (e2 = this._zoom);
            var o2 = this._zoom !== e2;
            return this._zoom = e2, this._lastCenter = t2, this._pixelOrigin = this._getNewPixelOrigin(t2), n2 ? i2 && i2.pinch && this.fire("zoom", i2) : ((o2 || i2 && i2.pinch) && this.fire("zoom", i2), this.fire("move", i2)), this;
          },
          _moveEnd: function(t2) {
            return t2 && this.fire("zoomend"), this.fire("moveend");
          },
          _stop: function() {
            return r(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
          },
          _rawPanBy: function(t2) {
            Z(this._mapPane, this._getMapPanePos().subtract(t2));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
          },
          _checkIfLoaded: function() {
            if (!this._loaded)
              throw new Error("Set map center and zoom first.");
          },
          _initEvents: function(t2) {
            this._targets = {};
            var e2 = t2 ? k : S;
            e2(
              (this._targets[h(this._container)] = this)._container,
              "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup",
              this._handleDOMEvent,
              this
            ), this.options.trackResize && e2(window, "resize", this._onResize, this), b.any3d && this.options.transform3DLimit && (t2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
          },
          _onResize: function() {
            r(this._resizeRequest), this._resizeRequest = x(function() {
              this.invalidateSize({
                debounceMoveend: true
              });
            }, this);
          },
          _onScroll: function() {
            this._container.scrollTop = 0, this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var t2 = this._getMapPanePos();
            Math.max(Math.abs(t2.x), Math.abs(t2.y)) >= this.options.transform3DLimit && this._resetView(
              this.getCenter(),
              this.getZoom()
            );
          },
          _findEventTargets: function(t2, e2) {
            for (var i2, n2 = [], o2 = "mouseout" === e2 || "mouseover" === e2, s2 = t2.target || t2.srcElement, r2 = false; s2; ) {
              if ((i2 = this._targets[h(s2)]) && ("click" === e2 || "preclick" === e2) && this._draggableMoved(i2)) {
                r2 = true;
                break;
              }
              if (i2 && i2.listens(e2, true)) {
                if (o2 && !We(s2, t2))
                  break;
                if (n2.push(i2), o2)
                  break;
              }
              if (s2 === this._container)
                break;
              s2 = s2.parentNode;
            }
            return n2 = n2.length || r2 || o2 || !this.listens(e2, true) ? n2 : [this];
          },
          _isClickDisabled: function(t2) {
            for (; t2 && t2 !== this._container; ) {
              if (t2._leaflet_disable_click)
                return true;
              t2 = t2.parentNode;
            }
          },
          _handleDOMEvent: function(t2) {
            var e2, i2 = t2.target || t2.srcElement;
            !this._loaded || i2._leaflet_disable_events || "click" === t2.type && this._isClickDisabled(
              i2
            ) || ("mousedown" === (e2 = t2.type) && Me(i2), this._fireDOMEvent(t2, e2));
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(t2, e2, i2) {
            "click" === t2.type && ((a2 = l({}, t2)).type = "preclick", this._fireDOMEvent(a2, a2.type, i2));
            var n2 = this._findEventTargets(t2, e2);
            if (i2) {
              for (var o2 = [], s2 = 0; s2 < i2.length; s2++)
                i2[s2].listens(e2, true) && o2.push(i2[s2]);
              n2 = o2.concat(n2);
            }
            if (n2.length) {
              "contextmenu" === e2 && O(t2);
              var r2, a2 = n2[0], h2 = {
                originalEvent: t2
              };
              for ("keypress" !== t2.type && "keydown" !== t2.type && "keyup" !== t2.type && (r2 = a2.getLatLng && (!a2._radius || a2._radius <= 10), h2.containerPoint = r2 ? this.latLngToContainerPoint(a2.getLatLng()) : this.mouseEventToContainerPoint(t2), h2.layerPoint = this.containerPointToLayerPoint(h2.containerPoint), h2.latlng = r2 ? a2.getLatLng() : this.layerPointToLatLng(h2.layerPoint)), s2 = 0; s2 < n2.length; s2++)
                if (n2[s2].fire(e2, h2, true), h2.originalEvent._stopped || false === n2[s2].options.bubblingMouseEvents && -1 !== G(this._mouseEvents, e2))
                  return;
            }
          },
          _draggableMoved: function(t2) {
            return (t2 = t2.dragging && t2.dragging.enabled() ? t2 : this).dragging && t2.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var t2 = 0, e2 = this._handlers.length; t2 < e2; t2++)
              this._handlers[t2].disable();
          },
          whenReady: function(t2, e2) {
            return this._loaded ? t2.call(e2 || this, {
              target: this
            }) : this.on("load", t2, e2), this;
          },
          _getMapPanePos: function() {
            return Pe(this._mapPane) || new p(0, 0);
          },
          _moved: function() {
            var t2 = this._getMapPanePos();
            return t2 && !t2.equals([0, 0]);
          },
          _getTopLeftPoint: function(t2, e2) {
            return (t2 && void 0 !== e2 ? this._getNewPixelOrigin(t2, e2) : this.getPixelOrigin()).subtract(
              this._getMapPanePos()
            );
          },
          _getNewPixelOrigin: function(t2, e2) {
            var i2 = this.getSize()._divideBy(2);
            return this.project(t2, e2)._subtract(i2)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(t2, e2, i2) {
            i2 = this._getNewPixelOrigin(i2, e2);
            return this.project(t2, e2)._subtract(i2);
          },
          _latLngBoundsToNewLayerBounds: function(t2, e2, i2) {
            i2 = this._getNewPixelOrigin(i2, e2);
            return _([
              this.project(t2.getSouthWest(), e2)._subtract(i2),
              this.project(t2.getNorthWest(), e2)._subtract(i2),
              this.project(t2.getSouthEast(), e2)._subtract(i2),
              this.project(t2.getNorthEast(), e2)._subtract(i2)
            ]);
          },
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          _getCenterOffset: function(t2) {
            return this.latLngToLayerPoint(t2).subtract(this._getCenterLayerPoint());
          },
          _limitCenter: function(t2, e2, i2) {
            var n2, o2;
            return !i2 || (n2 = this.project(t2, e2), o2 = this.getSize().divideBy(2), o2 = new f(n2.subtract(
              o2
            ), n2.add(o2)), o2 = this._getBoundsOffset(o2, i2, e2), Math.abs(o2.x) <= 1 && Math.abs(o2.y) <= 1) ? t2 : this.unproject(n2.add(o2), e2);
          },
          _limitOffset: function(t2, e2) {
            var i2;
            return e2 ? (i2 = new f((i2 = this.getPixelBounds()).min.add(t2), i2.max.add(t2)), t2.add(this._getBoundsOffset(i2, e2))) : t2;
          },
          _getBoundsOffset: function(t2, e2, i2) {
            e2 = _(this.project(e2.getNorthEast(), i2), this.project(e2.getSouthWest(), i2)), i2 = e2.min.subtract(t2.min), e2 = e2.max.subtract(t2.max);
            return new p(this._rebound(i2.x, -e2.x), this._rebound(i2.y, -e2.y));
          },
          _rebound: function(t2, e2) {
            return 0 < t2 + e2 ? Math.round(t2 - e2) / 2 : Math.max(0, Math.ceil(t2)) - Math.max(0, Math.floor(e2));
          },
          _limitZoom: function(t2) {
            var e2 = this.getMinZoom(), i2 = this.getMaxZoom(), n2 = b.any3d ? this.options.zoomSnap : 1;
            return n2 && (t2 = Math.round(t2 / n2) * n2), Math.max(e2, Math.min(i2, t2));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            z(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
          },
          _tryAnimatedPan: function(t2, e2) {
            t2 = this._getCenterOffset(t2)._trunc();
            return !(true !== (e2 && e2.animate) && !this.getSize().contains(t2)) && (this.panBy(t2, e2), true);
          },
          _createAnimProxy: function() {
            var t2 = this._proxy = P("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(t2), this.on("zoomanim", function(t3) {
              var e2 = ue, i2 = this._proxy.style[e2];
              be(this._proxy, this.project(t3.center, t3.zoom), this.getZoomScale(t3.zoom, 1)), i2 === this._proxy.style[e2] && this._animatingZoom && this._onZoomTransitionEnd();
            }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            T(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
          },
          _animMoveEnd: function() {
            var t2 = this.getCenter(), e2 = this.getZoom();
            be(this._proxy, this.project(t2, e2), this.getZoomScale(e2, 1));
          },
          _catchTransitionEnd: function(t2) {
            this._animatingZoom && 0 <= t2.propertyName.indexOf("transform") && this._onZoomTransitionEnd();
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(t2, e2, i2) {
            if (!this._animatingZoom) {
              if (i2 = i2 || {}, !this._zoomAnimated || false === i2.animate || this._nothingToAnimate() || Math.abs(e2 - this._zoom) > this.options.zoomAnimationThreshold)
                return false;
              var n2 = this.getZoomScale(e2), n2 = this._getCenterOffset(t2)._divideBy(1 - 1 / n2);
              if (true !== i2.animate && !this.getSize().contains(n2))
                return false;
              x(function() {
                this._moveStart(true, i2.noMoveStart || false)._animateZoom(t2, e2, true);
              }, this);
            }
            return true;
          },
          _animateZoom: function(t2, e2, i2, n2) {
            this._mapPane && (i2 && (this._animatingZoom = true, this._animateToCenter = t2, this._animateToZoom = e2, M(this._mapPane, "leaflet-zoom-anim")), this.fire(
              "zoomanim",
              {
                center: t2,
                zoom: e2,
                noUpdate: n2
              }
            ), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(
              this._animateToCenter,
              this._animateToZoom,
              void 0,
              true
            ), setTimeout(a(this._onZoomTransitionEnd, this), 250));
          },
          _onZoomTransitionEnd: function() {
            this._animatingZoom && (this._mapPane && z(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = false, this._move(
              this._animateToCenter,
              this._animateToZoom,
              void 0,
              true
            ), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(true));
          }
        });
        function Ue(t2) {
          return new B(t2);
        }
        var B = et.extend({
          options: {
            position: "topright"
          },
          initialize: function(t2) {
            c(this, t2);
          },
          getPosition: function() {
            return this.options.position;
          },
          setPosition: function(t2) {
            var e2 = this._map;
            return e2 && e2.removeControl(this), this.options.position = t2, e2 && e2.addControl(this), this;
          },
          getContainer: function() {
            return this._container;
          },
          addTo: function(t2) {
            this.remove(), this._map = t2;
            var e2 = this._container = this.onAdd(t2), i2 = this.getPosition(), t2 = t2._controlCorners[i2];
            return M(e2, "leaflet-control"), -1 !== i2.indexOf("bottom") ? t2.insertBefore(e2, t2.firstChild) : t2.appendChild(e2), this._map.on("unload", this.remove, this), this;
          },
          remove: function() {
            return this._map && (T(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null), this;
          },
          _refocusOnMap: function(t2) {
            this._map && t2 && 0 < t2.screenX && 0 < t2.screenY && this._map.getContainer().focus();
          }
        }), Ve = (A.include({
          addControl: function(t2) {
            return t2.addTo(this), this;
          },
          removeControl: function(t2) {
            return t2.remove(), this;
          },
          _initControlPos: function() {
            var i2 = this._controlCorners = {}, n2 = "leaflet-", o2 = this._controlContainer = P("div", n2 + "control-container", this._container);
            function t2(t3, e2) {
              i2[t3 + e2] = P("div", n2 + t3 + " " + n2 + e2, o2);
            }
            t2("top", "left"), t2("top", "right"), t2("bottom", "left"), t2("bottom", "right");
          },
          _clearControlPos: function() {
            for (var t2 in this._controlCorners)
              T(this._controlCorners[t2]);
            T(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
          }
        }), B.extend({
          options: {
            collapsed: true,
            position: "topright",
            autoZIndex: true,
            hideSingleBase: false,
            sortLayers: false,
            sortFunction: function(t2, e2, i2, n2) {
              return i2 < n2 ? -1 : n2 < i2 ? 1 : 0;
            }
          },
          initialize: function(t2, e2, i2) {
            for (var n2 in c(this, i2), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = false, this._preventClick = false, t2)
              this._addLayer(t2[n2], n2);
            for (n2 in e2)
              this._addLayer(e2[n2], n2, true);
          },
          onAdd: function(t2) {
            this._initLayout(), this._update(), (this._map = t2).on("zoomend", this._checkDisabledLayers, this);
            for (var e2 = 0; e2 < this._layers.length; e2++)
              this._layers[e2].layer.on(
                "add remove",
                this._onLayerChange,
                this
              );
            return this._container;
          },
          addTo: function(t2) {
            return B.prototype.addTo.call(this, t2), this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var t2 = 0; t2 < this._layers.length; t2++)
              this._layers[t2].layer.off(
                "add remove",
                this._onLayerChange,
                this
              );
          },
          addBaseLayer: function(t2, e2) {
            return this._addLayer(t2, e2), this._map ? this._update() : this;
          },
          addOverlay: function(t2, e2) {
            return this._addLayer(t2, e2, true), this._map ? this._update() : this;
          },
          removeLayer: function(t2) {
            t2.off("add remove", this._onLayerChange, this);
            t2 = this._getLayer(h(t2));
            return t2 && this._layers.splice(this._layers.indexOf(t2), 1), this._map ? this._update() : this;
          },
          expand: function() {
            M(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
            var t2 = this._map.getSize().y - (this._container.offsetTop + 50);
            return t2 < this._section.clientHeight ? (M(
              this._section,
              "leaflet-control-layers-scrollbar"
            ), this._section.style.height = t2 + "px") : z(
              this._section,
              "leaflet-control-layers-scrollbar"
            ), this._checkDisabledLayers(), this;
          },
          collapse: function() {
            return z(this._container, "leaflet-control-layers-expanded"), this;
          },
          _initLayout: function() {
            var t2 = "leaflet-control-layers", e2 = this._container = P("div", t2), i2 = this.options.collapsed, n2 = (e2.setAttribute("aria-haspopup", true), Ie(e2), Be(e2), this._section = P(
              "section",
              t2 + "-list"
            )), o2 = (i2 && (this._map.on("click", this.collapse, this), S(e2, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
            }, this)), this._layersLink = P("a", t2 + "-toggle", e2));
            o2.href = "#", o2.title = "Layers", o2.setAttribute("role", "button"), S(o2, {
              keydown: function(t3) {
                13 === t3.keyCode && this._expandSafely();
              },
              click: function(t3) {
                O(t3), this._expandSafely();
              }
            }, this), i2 || this.expand(), this._baseLayersList = P("div", t2 + "-base", n2), this._separator = P("div", t2 + "-separator", n2), this._overlaysList = P("div", t2 + "-overlays", n2), e2.appendChild(n2);
          },
          _getLayer: function(t2) {
            for (var e2 = 0; e2 < this._layers.length; e2++)
              if (this._layers[e2] && h(this._layers[e2].layer) === t2)
                return this._layers[e2];
          },
          _addLayer: function(t2, e2, i2) {
            this._map && t2.on("add remove", this._onLayerChange, this), this._layers.push({
              layer: t2,
              name: e2,
              overlay: i2
            }), this.options.sortLayers && this._layers.sort(a(function(t3, e3) {
              return this.options.sortFunction(t3.layer, e3.layer, t3.name, e3.name);
            }, this)), this.options.autoZIndex && t2.setZIndex && (this._lastZIndex++, t2.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
          },
          _update: function() {
            if (this._container) {
              me(this._baseLayersList), me(this._overlaysList), this._layerControlInputs = [];
              for (var t2, e2, i2, n2 = 0, o2 = 0; o2 < this._layers.length; o2++)
                i2 = this._layers[o2], this._addItem(i2), e2 = e2 || i2.overlay, t2 = t2 || !i2.overlay, n2 += i2.overlay ? 0 : 1;
              this.options.hideSingleBase && (this._baseLayersList.style.display = (t2 = t2 && 1 < n2) ? "" : "none"), this._separator.style.display = e2 && t2 ? "" : "none";
            }
            return this;
          },
          _onLayerChange: function(t2) {
            this._handlingClick || this._update();
            var e2 = this._getLayer(h(t2.target)), t2 = e2.overlay ? "add" === t2.type ? "overlayadd" : "overlayremove" : "add" === t2.type ? "baselayerchange" : null;
            t2 && this._map.fire(t2, e2);
          },
          _createRadioElement: function(t2, e2) {
            t2 = '<input type="radio" class="leaflet-control-layers-selector" name="' + t2 + '"' + (e2 ? ' checked="checked"' : "") + "/>", e2 = document.createElement("div");
            return e2.innerHTML = t2, e2.firstChild;
          },
          _addItem: function(t2) {
            var e2, i2 = document.createElement("label"), n2 = this._map.hasLayer(t2.layer), n2 = (t2.overlay ? ((e2 = document.createElement("input")).type = "checkbox", e2.className = "leaflet-control-layers-selector", e2.defaultChecked = n2) : e2 = this._createRadioElement("leaflet-base-layers_" + h(this), n2), this._layerControlInputs.push(e2), e2.layerId = h(t2.layer), S(e2, "click", this._onInputClick, this), document.createElement("span")), o2 = (n2.innerHTML = " " + t2.name, document.createElement("span"));
            return i2.appendChild(o2), o2.appendChild(e2), o2.appendChild(n2), (t2.overlay ? this._overlaysList : this._baseLayersList).appendChild(i2), this._checkDisabledLayers(), i2;
          },
          _onInputClick: function() {
            if (!this._preventClick) {
              var t2, e2, i2 = this._layerControlInputs, n2 = [], o2 = [];
              this._handlingClick = true;
              for (var s2 = i2.length - 1; 0 <= s2; s2--)
                t2 = i2[s2], e2 = this._getLayer(t2.layerId).layer, t2.checked ? n2.push(e2) : t2.checked || o2.push(e2);
              for (s2 = 0; s2 < o2.length; s2++)
                this._map.hasLayer(o2[s2]) && this._map.removeLayer(o2[s2]);
              for (s2 = 0; s2 < n2.length; s2++)
                this._map.hasLayer(n2[s2]) || this._map.addLayer(n2[s2]);
              this._handlingClick = false, this._refocusOnMap();
            }
          },
          _checkDisabledLayers: function() {
            for (var t2, e2, i2 = this._layerControlInputs, n2 = this._map.getZoom(), o2 = i2.length - 1; 0 <= o2; o2--)
              t2 = i2[o2], e2 = this._getLayer(t2.layerId).layer, t2.disabled = void 0 !== e2.options.minZoom && n2 < e2.options.minZoom || void 0 !== e2.options.maxZoom && n2 > e2.options.maxZoom;
          },
          _expandIfNotCollapsed: function() {
            return this._map && !this.options.collapsed && this.expand(), this;
          },
          _expandSafely: function() {
            var t2 = this._section, e2 = (this._preventClick = true, S(t2, "click", O), this.expand(), this);
            setTimeout(function() {
              k(t2, "click", O), e2._preventClick = false;
            });
          }
        })), qe = B.extend({
          options: {
            position: "topleft",
            zoomInText: '<span aria-hidden="true">+</span>',
            zoomInTitle: "Zoom in",
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(t2) {
            var e2 = "leaflet-control-zoom", i2 = P("div", e2 + " leaflet-bar"), n2 = this.options;
            return this._zoomInButton = this._createButton(
              n2.zoomInText,
              n2.zoomInTitle,
              e2 + "-in",
              i2,
              this._zoomIn
            ), this._zoomOutButton = this._createButton(n2.zoomOutText, n2.zoomOutTitle, e2 + "-out", i2, this._zoomOut), this._updateDisabled(), t2.on(
              "zoomend zoomlevelschange",
              this._updateDisabled,
              this
            ), i2;
          },
          onRemove: function(t2) {
            t2.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            return this._disabled = true, this._updateDisabled(), this;
          },
          enable: function() {
            return this._disabled = false, this._updateDisabled(), this;
          },
          _zoomIn: function(t2) {
            !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t2.shiftKey ? 3 : 1));
          },
          _zoomOut: function(t2) {
            !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t2.shiftKey ? 3 : 1));
          },
          _createButton: function(t2, e2, i2, n2, o2) {
            i2 = P("a", i2, n2);
            return i2.innerHTML = t2, i2.href = "#", i2.title = e2, i2.setAttribute("role", "button"), i2.setAttribute("aria-label", e2), Ie(i2), S(i2, "click", Re), S(i2, "click", o2, this), S(
              i2,
              "click",
              this._refocusOnMap,
              this
            ), i2;
          },
          _updateDisabled: function() {
            var t2 = this._map, e2 = "leaflet-disabled";
            z(this._zoomInButton, e2), z(this._zoomOutButton, e2), this._zoomInButton.setAttribute(
              "aria-disabled",
              "false"
            ), this._zoomOutButton.setAttribute(
              "aria-disabled",
              "false"
            ), !this._disabled && t2._zoom !== t2.getMinZoom() || (M(
              this._zoomOutButton,
              e2
            ), this._zoomOutButton.setAttribute("aria-disabled", "true")), !this._disabled && t2._zoom !== t2.getMaxZoom() || (M(this._zoomInButton, e2), this._zoomInButton.setAttribute(
              "aria-disabled",
              "true"
            ));
          }
        }), Ge = (A.mergeOptions({
          zoomControl: true
        }), A.addInitHook(function() {
          this.options.zoomControl && (this.zoomControl = new qe(), this.addControl(this.zoomControl));
        }), B.extend({
          options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: true,
            imperial: true
          },
          onAdd: function(t2) {
            var e2 = "leaflet-control-scale", i2 = P("div", e2), n2 = this.options;
            return this._addScales(n2, e2 + "-line", i2), t2.on(
              n2.updateWhenIdle ? "moveend" : "move",
              this._update,
              this
            ), t2.whenReady(this._update, this), i2;
          },
          onRemove: function(t2) {
            t2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(t2, e2, i2) {
            t2.metric && (this._mScale = P("div", e2, i2)), t2.imperial && (this._iScale = P(
              "div",
              e2,
              i2
            ));
          },
          _update: function() {
            var t2 = this._map, e2 = t2.getSize().y / 2, t2 = t2.distance(t2.containerPointToLatLng([0, e2]), t2.containerPointToLatLng([
              this.options.maxWidth,
              e2
            ]));
            this._updateScales(t2);
          },
          _updateScales: function(t2) {
            this.options.metric && t2 && this._updateMetric(t2), this.options.imperial && t2 && this._updateImperial(t2);
          },
          _updateMetric: function(t2) {
            var e2 = this._getRoundNum(t2);
            this._updateScale(this._mScale, e2 < 1e3 ? e2 + " m" : e2 / 1e3 + " km", e2 / t2);
          },
          _updateImperial: function(t2) {
            var e2, i2, t2 = 3.2808399 * t2;
            5280 < t2 ? (i2 = this._getRoundNum(e2 = t2 / 5280), this._updateScale(this._iScale, i2 + " mi", i2 / e2)) : (i2 = this._getRoundNum(t2), this._updateScale(this._iScale, i2 + " ft", i2 / t2));
          },
          _updateScale: function(t2, e2, i2) {
            t2.style.width = Math.round(this.options.maxWidth * i2) + "px", t2.innerHTML = e2;
          },
          _getRoundNum: function(t2) {
            var e2 = Math.pow(10, (Math.floor(t2) + "").length - 1), t2 = t2 / e2;
            return e2 * (t2 = 10 <= t2 ? 10 : 5 <= t2 ? 5 : 3 <= t2 ? 3 : 2 <= t2 ? 2 : 1);
          }
        })), Ke = B.extend({
          options: {
            position: "bottomright",
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (b.inlineSvg ? '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg> ' : "") + "Leaflet</a>"
          },
          initialize: function(t2) {
            c(this, t2), this._attributions = {};
          },
          onAdd: function(t2) {
            for (var e2 in (t2.attributionControl = this)._container = P(
              "div",
              "leaflet-control-attribution"
            ), Ie(this._container), t2._layers)
              t2._layers[e2].getAttribution && this.addAttribution(t2._layers[e2].getAttribution());
            return this._update(), t2.on("layeradd", this._addAttribution, this), this._container;
          },
          onRemove: function(t2) {
            t2.off("layeradd", this._addAttribution, this);
          },
          _addAttribution: function(t2) {
            t2.layer.getAttribution && (this.addAttribution(t2.layer.getAttribution()), t2.layer.once(
              "remove",
              function() {
                this.removeAttribution(t2.layer.getAttribution());
              },
              this
            ));
          },
          setPrefix: function(t2) {
            return this.options.prefix = t2, this._update(), this;
          },
          addAttribution: function(t2) {
            return t2 && (this._attributions[t2] || (this._attributions[t2] = 0), this._attributions[t2]++, this._update()), this;
          },
          removeAttribution: function(t2) {
            return t2 && this._attributions[t2] && (this._attributions[t2]--, this._update()), this;
          },
          _update: function() {
            if (this._map) {
              var t2, e2 = [];
              for (t2 in this._attributions)
                this._attributions[t2] && e2.push(t2);
              var i2 = [];
              this.options.prefix && i2.push(this.options.prefix), e2.length && i2.push(e2.join(", ")), this._container.innerHTML = i2.join(' <span aria-hidden="true">|</span> ');
            }
          }
        }), n = (A.mergeOptions({
          attributionControl: true
        }), A.addInitHook(function() {
          this.options.attributionControl && new Ke().addTo(this);
        }), B.Layers = Ve, B.Zoom = qe, B.Scale = Ge, B.Attribution = Ke, Ue.layers = function(t2, e2, i2) {
          return new Ve(t2, e2, i2);
        }, Ue.zoom = function(t2) {
          return new qe(t2);
        }, Ue.scale = function(t2) {
          return new Ge(t2);
        }, Ue.attribution = function(t2) {
          return new Ke(t2);
        }, et.extend({
          initialize: function(t2) {
            this._map = t2;
          },
          enable: function() {
            return this._enabled || (this._enabled = true, this.addHooks()), this;
          },
          disable: function() {
            return this._enabled && (this._enabled = false, this.removeHooks()), this;
          },
          enabled: function() {
            return !!this._enabled;
          }
        })), ft = (n.addTo = function(t2, e2) {
          return t2.addHandler(e2, this), this;
        }, {
          Events: e
        }), Ye = b.touch ? "touchstart mousedown" : "mousedown", Xe = it.extend({
          options: {
            clickTolerance: 3
          },
          initialize: function(t2, e2, i2, n2) {
            c(this, n2), this._element = t2, this._dragStartTarget = e2 || t2, this._preventOutline = i2;
          },
          enable: function() {
            this._enabled || (S(this._dragStartTarget, Ye, this._onDown, this), this._enabled = true);
          },
          disable: function() {
            this._enabled && (Xe._dragging === this && this.finishDrag(true), k(
              this._dragStartTarget,
              Ye,
              this._onDown,
              this
            ), this._enabled = false, this._moved = false);
          },
          _onDown: function(t2) {
            var e2, i2;
            this._enabled && (this._moved = false, ve(this._element, "leaflet-zoom-anim") || (t2.touches && 1 !== t2.touches.length ? Xe._dragging === this && this.finishDrag() : Xe._dragging || t2.shiftKey || 1 !== t2.which && 1 !== t2.button && !t2.touches || ((Xe._dragging = this)._preventOutline && Me(this._element), Le(), re(), this._moving || (this.fire("down"), i2 = t2.touches ? t2.touches[0] : t2, e2 = Ce(this._element), this._startPoint = new p(i2.clientX, i2.clientY), this._startPos = Pe(this._element), this._parentScale = Ze(e2), i2 = "mousedown" === t2.type, S(document, i2 ? "mousemove" : "touchmove", this._onMove, this), S(
              document,
              i2 ? "mouseup" : "touchend touchcancel",
              this._onUp,
              this
            )))));
          },
          _onMove: function(t2) {
            var e2;
            this._enabled && (t2.touches && 1 < t2.touches.length ? this._moved = true : !(e2 = new p((e2 = t2.touches && 1 === t2.touches.length ? t2.touches[0] : t2).clientX, e2.clientY)._subtract(this._startPoint)).x && !e2.y || Math.abs(e2.x) + Math.abs(e2.y) < this.options.clickTolerance || (e2.x /= this._parentScale.x, e2.y /= this._parentScale.y, O(t2), this._moved || (this.fire("dragstart"), this._moved = true, M(document.body, "leaflet-dragging"), this._lastTarget = t2.target || t2.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), M(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(e2), this._moving = true, this._lastEvent = t2, this._updatePosition()));
          },
          _updatePosition: function() {
            var t2 = {
              originalEvent: this._lastEvent
            };
            this.fire("predrag", t2), Z(this._element, this._newPos), this.fire("drag", t2);
          },
          _onUp: function() {
            this._enabled && this.finishDrag();
          },
          finishDrag: function(t2) {
            z(document.body, "leaflet-dragging"), this._lastTarget && (z(
              this._lastTarget,
              "leaflet-drag-target"
            ), this._lastTarget = null), k(
              document,
              "mousemove touchmove",
              this._onMove,
              this
            ), k(document, "mouseup touchend touchcancel", this._onUp, this), Te(), ae();
            var e2 = this._moved && this._moving;
            this._moving = false, Xe._dragging = false, e2 && this.fire("dragend", {
              noInertia: t2,
              distance: this._newPos.distanceTo(this._startPos)
            });
          }
        });
        function Je(t2, e2, i2) {
          for (var n2, o2, s2, r2, a2, h2, l2, u2 = [1, 4, 2, 8], c2 = 0, d2 = t2.length; c2 < d2; c2++)
            t2[c2]._code = si(t2[c2], e2);
          for (s2 = 0; s2 < 4; s2++) {
            for (h2 = u2[s2], n2 = [], c2 = 0, o2 = (d2 = t2.length) - 1; c2 < d2; o2 = c2++)
              r2 = t2[c2], a2 = t2[o2], r2._code & h2 ? a2._code & h2 || ((l2 = oi(a2, r2, h2, e2, i2))._code = si(l2, e2), n2.push(l2)) : (a2._code & h2 && ((l2 = oi(
                a2,
                r2,
                h2,
                e2,
                i2
              ))._code = si(l2, e2), n2.push(l2)), n2.push(r2));
            t2 = n2;
          }
          return t2;
        }
        function $e(t2, e2) {
          var i2, n2, o2, s2, r2, a2, h2;
          if (!t2 || 0 === t2.length)
            throw new Error("latlngs not passed");
          I(t2) || (console.warn("latlngs are not flat! Only the first ring will be used"), t2 = t2[0]);
          for (var l2 = w([0, 0]), u2 = g(t2), c2 = (u2.getNorthWest().distanceTo(u2.getSouthWest()) * u2.getNorthEast().distanceTo(u2.getNorthWest()) < 1700 && (l2 = Qe(t2)), t2.length), d2 = [], _2 = 0; _2 < c2; _2++) {
            var p2 = w(t2[_2]);
            d2.push(e2.project(w([p2.lat - l2.lat, p2.lng - l2.lng])));
          }
          for (_2 = r2 = a2 = h2 = 0, i2 = c2 - 1; _2 < c2; i2 = _2++)
            n2 = d2[_2], o2 = d2[i2], s2 = n2.y * o2.x - o2.y * n2.x, a2 += (n2.x + o2.x) * s2, h2 += (n2.y + o2.y) * s2, r2 += 3 * s2;
          u2 = 0 === r2 ? d2[0] : [a2 / r2, h2 / r2], u2 = e2.unproject(m(u2));
          return w([u2.lat + l2.lat, u2.lng + l2.lng]);
        }
        function Qe(t2) {
          for (var e2 = 0, i2 = 0, n2 = 0, o2 = 0; o2 < t2.length; o2++) {
            var s2 = w(t2[o2]);
            e2 += s2.lat, i2 += s2.lng, n2++;
          }
          return w([e2 / n2, i2 / n2]);
        }
        var ti, gt = {
          __proto__: null,
          clipPolygon: Je,
          polygonCenter: $e,
          centroid: Qe
        };
        function ei(t2, e2) {
          if (e2 && t2.length) {
            var i2 = t2 = function(t3, e3) {
              for (var i3 = [t3[0]], n3 = 1, o3 = 0, s3 = t3.length; n3 < s3; n3++)
                (function(t4, e4) {
                  var i4 = e4.x - t4.x, e4 = e4.y - t4.y;
                  return i4 * i4 + e4 * e4;
                })(t3[n3], t3[o3]) > e3 && (i3.push(t3[n3]), o3 = n3);
              o3 < s3 - 1 && i3.push(t3[s3 - 1]);
              return i3;
            }(t2, e2 = e2 * e2), n2 = i2.length, o2 = new (typeof Uint8Array != "undefined" ? Uint8Array : Array)(n2);
            o2[0] = o2[n2 - 1] = 1, function t3(e3, i3, n3, o3, s3) {
              var r3, a2, h2, l2 = 0;
              for (a2 = o3 + 1; a2 <= s3 - 1; a2++)
                h2 = ri(e3[a2], e3[o3], e3[s3], true), l2 < h2 && (r3 = a2, l2 = h2);
              n3 < l2 && (i3[r3] = 1, t3(e3, i3, n3, o3, r3), t3(e3, i3, n3, r3, s3));
            }(i2, o2, e2, 0, n2 - 1);
            var s2, r2 = [];
            for (s2 = 0; s2 < n2; s2++)
              o2[s2] && r2.push(i2[s2]);
            return r2;
          }
          return t2.slice();
        }
        function ii(t2, e2, i2) {
          return Math.sqrt(ri(t2, e2, i2, true));
        }
        function ni(t2, e2, i2, n2, o2) {
          var s2, r2, a2, h2 = n2 ? ti : si(t2, i2), l2 = si(e2, i2);
          for (ti = l2; ; ) {
            if (!(h2 | l2))
              return [t2, e2];
            if (h2 & l2)
              return false;
            a2 = si(r2 = oi(t2, e2, s2 = h2 || l2, i2, o2), i2), s2 === h2 ? (t2 = r2, h2 = a2) : (e2 = r2, l2 = a2);
          }
        }
        function oi(t2, e2, i2, n2, o2) {
          var s2, r2, a2 = e2.x - t2.x, e2 = e2.y - t2.y, h2 = n2.min, n2 = n2.max;
          return 8 & i2 ? (s2 = t2.x + a2 * (n2.y - t2.y) / e2, r2 = n2.y) : 4 & i2 ? (s2 = t2.x + a2 * (h2.y - t2.y) / e2, r2 = h2.y) : 2 & i2 ? (s2 = n2.x, r2 = t2.y + e2 * (n2.x - t2.x) / a2) : 1 & i2 && (s2 = h2.x, r2 = t2.y + e2 * (h2.x - t2.x) / a2), new p(s2, r2, o2);
        }
        function si(t2, e2) {
          var i2 = 0;
          return t2.x < e2.min.x ? i2 |= 1 : t2.x > e2.max.x && (i2 |= 2), t2.y < e2.min.y ? i2 |= 4 : t2.y > e2.max.y && (i2 |= 8), i2;
        }
        function ri(t2, e2, i2, n2) {
          var o2 = e2.x, e2 = e2.y, s2 = i2.x - o2, r2 = i2.y - e2, a2 = s2 * s2 + r2 * r2;
          return 0 < a2 && (1 < (a2 = ((t2.x - o2) * s2 + (t2.y - e2) * r2) / a2) ? (o2 = i2.x, e2 = i2.y) : 0 < a2 && (o2 += s2 * a2, e2 += r2 * a2)), s2 = t2.x - o2, r2 = t2.y - e2, n2 ? s2 * s2 + r2 * r2 : new p(o2, e2);
        }
        function I(t2) {
          return !d(t2[0]) || "object" != typeof t2[0][0] && void 0 !== t2[0][0];
        }
        function ai(t2) {
          return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), I(t2);
        }
        function hi(t2, e2) {
          var i2, n2, o2, s2, r2, a2;
          if (!t2 || 0 === t2.length)
            throw new Error("latlngs not passed");
          I(t2) || (console.warn("latlngs are not flat! Only the first ring will be used"), t2 = t2[0]);
          for (var h2 = w([0, 0]), l2 = g(t2), u2 = (l2.getNorthWest().distanceTo(l2.getSouthWest()) * l2.getNorthEast().distanceTo(l2.getNorthWest()) < 1700 && (h2 = Qe(t2)), t2.length), c2 = [], d2 = 0; d2 < u2; d2++) {
            var _2 = w(t2[d2]);
            c2.push(e2.project(w([_2.lat - h2.lat, _2.lng - h2.lng])));
          }
          for (i2 = d2 = 0; d2 < u2 - 1; d2++)
            i2 += c2[d2].distanceTo(c2[d2 + 1]) / 2;
          if (0 === i2)
            a2 = c2[0];
          else
            for (n2 = d2 = 0; d2 < u2 - 1; d2++)
              if (o2 = c2[d2], s2 = c2[d2 + 1], i2 < (n2 += r2 = o2.distanceTo(s2))) {
                a2 = [s2.x - (r2 = (n2 - i2) / r2) * (s2.x - o2.x), s2.y - r2 * (s2.y - o2.y)];
                break;
              }
          l2 = e2.unproject(m(a2));
          return w([l2.lat + h2.lat, l2.lng + h2.lng]);
        }
        var vt = {
          __proto__: null,
          simplify: ei,
          pointToSegmentDistance: ii,
          closestPointOnSegment: function(t2, e2, i2) {
            return ri(t2, e2, i2);
          },
          clipSegment: ni,
          _getEdgeIntersection: oi,
          _getBitCode: si,
          _sqClosestPointOnSegment: ri,
          isFlat: I,
          _flat: ai,
          polylineCenter: hi
        }, yt = {
          project: function(t2) {
            return new p(t2.lng, t2.lat);
          },
          unproject: function(t2) {
            return new v(t2.y, t2.x);
          },
          bounds: new f([-180, -90], [180, 90])
        }, xt = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new f([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(t2) {
            var e2 = Math.PI / 180, i2 = this.R, n2 = t2.lat * e2, o2 = this.R_MINOR / i2, o2 = Math.sqrt(1 - o2 * o2), s2 = o2 * Math.sin(n2), s2 = Math.tan(Math.PI / 4 - n2 / 2) / Math.pow((1 - s2) / (1 + s2), o2 / 2), n2 = -i2 * Math.log(Math.max(s2, 1e-10));
            return new p(t2.lng * e2 * i2, n2);
          },
          unproject: function(t2) {
            for (var e2, i2 = 180 / Math.PI, n2 = this.R, o2 = this.R_MINOR / n2, s2 = Math.sqrt(1 - o2 * o2), r2 = Math.exp(-t2.y / n2), a2 = Math.PI / 2 - 2 * Math.atan(r2), h2 = 0, l2 = 0.1; h2 < 15 && 1e-7 < Math.abs(l2); h2++)
              e2 = s2 * Math.sin(a2), e2 = Math.pow((1 - e2) / (1 + e2), s2 / 2), a2 += l2 = Math.PI / 2 - 2 * Math.atan(r2 * e2) - a2;
            return new v(a2 * i2, t2.x * i2 / n2);
          }
        }, wt = {
          __proto__: null,
          LonLat: yt,
          Mercator: xt,
          SphericalMercator: rt
        }, Pt = l({}, st, {
          code: "EPSG:3395",
          projection: xt,
          transformation: ht(bt = 0.5 / (Math.PI * xt.R), 0.5, -bt, 0.5)
        }), li = l({}, st, {
          code: "EPSG:4326",
          projection: yt,
          transformation: ht(1 / 180, 1, -1 / 180, 0.5)
        }), Lt = l({}, ot, {
          projection: yt,
          transformation: ht(1, 0, -1, 0),
          scale: function(t2) {
            return Math.pow(2, t2);
          },
          zoom: function(t2) {
            return Math.log(t2) / Math.LN2;
          },
          distance: function(t2, e2) {
            var i2 = e2.lng - t2.lng, e2 = e2.lat - t2.lat;
            return Math.sqrt(i2 * i2 + e2 * e2);
          },
          infinite: true
        }), o = (ot.Earth = st, ot.EPSG3395 = Pt, ot.EPSG3857 = lt, ot.EPSG900913 = ut, ot.EPSG4326 = li, ot.Simple = Lt, it.extend({
          options: {
            pane: "overlayPane",
            attribution: null,
            bubblingMouseEvents: true
          },
          addTo: function(t2) {
            return t2.addLayer(this), this;
          },
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          removeFrom: function(t2) {
            return t2 && t2.removeLayer(this), this;
          },
          getPane: function(t2) {
            return this._map.getPane(t2 ? this.options[t2] || t2 : this.options.pane);
          },
          addInteractiveTarget: function(t2) {
            return this._map._targets[h(t2)] = this;
          },
          removeInteractiveTarget: function(t2) {
            return delete this._map._targets[h(t2)], this;
          },
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(t2) {
            var e2, i2 = t2.target;
            i2.hasLayer(this) && (this._map = i2, this._zoomAnimated = i2._zoomAnimated, this.getEvents && (e2 = this.getEvents(), i2.on(e2, this), this.once(
              "remove",
              function() {
                i2.off(e2, this);
              },
              this
            )), this.onAdd(i2), this.fire("add"), i2.fire("layeradd", {
              layer: this
            }));
          }
        })), ui = (A.include({
          addLayer: function(t2) {
            var e2;
            if (t2._layerAdd)
              return e2 = h(t2), this._layers[e2] || ((this._layers[e2] = t2)._mapToAdd = this, t2.beforeAdd && t2.beforeAdd(this), this.whenReady(t2._layerAdd, t2)), this;
            throw new Error("The provided object is not a Layer.");
          },
          removeLayer: function(t2) {
            var e2 = h(t2);
            return this._layers[e2] && (this._loaded && t2.onRemove(this), delete this._layers[e2], this._loaded && (this.fire("layerremove", {
              layer: t2
            }), t2.fire("remove")), t2._map = t2._mapToAdd = null), this;
          },
          hasLayer: function(t2) {
            return h(t2) in this._layers;
          },
          eachLayer: function(t2, e2) {
            for (var i2 in this._layers)
              t2.call(e2, this._layers[i2]);
            return this;
          },
          _addLayers: function(t2) {
            for (var e2 = 0, i2 = (t2 = t2 ? d(t2) ? t2 : [t2] : []).length; e2 < i2; e2++)
              this.addLayer(t2[e2]);
          },
          _addZoomLimit: function(t2) {
            isNaN(t2.options.maxZoom) && isNaN(t2.options.minZoom) || (this._zoomBoundLayers[h(t2)] = t2, this._updateZoomLevels());
          },
          _removeZoomLimit: function(t2) {
            t2 = h(t2);
            this._zoomBoundLayers[t2] && (delete this._zoomBoundLayers[t2], this._updateZoomLevels());
          },
          _updateZoomLevels: function() {
            var t2, e2 = 1 / 0, i2 = -1 / 0, n2 = this._getZoomSpan();
            for (t2 in this._zoomBoundLayers)
              var o2 = this._zoomBoundLayers[t2].options, e2 = void 0 === o2.minZoom ? e2 : Math.min(e2, o2.minZoom), i2 = void 0 === o2.maxZoom ? i2 : Math.max(i2, o2.maxZoom);
            this._layersMaxZoom = i2 === -1 / 0 ? void 0 : i2, this._layersMinZoom = e2 === 1 / 0 ? void 0 : e2, n2 !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
          }
        }), o.extend({
          initialize: function(t2, e2) {
            var i2, n2;
            if (c(this, e2), this._layers = {}, t2)
              for (i2 = 0, n2 = t2.length; i2 < n2; i2++)
                this.addLayer(t2[i2]);
          },
          addLayer: function(t2) {
            var e2 = this.getLayerId(t2);
            return this._layers[e2] = t2, this._map && this._map.addLayer(t2), this;
          },
          removeLayer: function(t2) {
            t2 = t2 in this._layers ? t2 : this.getLayerId(t2);
            return this._map && this._layers[t2] && this._map.removeLayer(this._layers[t2]), delete this._layers[t2], this;
          },
          hasLayer: function(t2) {
            return ("number" == typeof t2 ? t2 : this.getLayerId(t2)) in this._layers;
          },
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          invoke: function(t2) {
            var e2, i2, n2 = Array.prototype.slice.call(arguments, 1);
            for (e2 in this._layers)
              (i2 = this._layers[e2])[t2] && i2[t2].apply(i2, n2);
            return this;
          },
          onAdd: function(t2) {
            this.eachLayer(t2.addLayer, t2);
          },
          onRemove: function(t2) {
            this.eachLayer(t2.removeLayer, t2);
          },
          eachLayer: function(t2, e2) {
            for (var i2 in this._layers)
              t2.call(e2, this._layers[i2]);
            return this;
          },
          getLayer: function(t2) {
            return this._layers[t2];
          },
          getLayers: function() {
            var t2 = [];
            return this.eachLayer(t2.push, t2), t2;
          },
          setZIndex: function(t2) {
            return this.invoke("setZIndex", t2);
          },
          getLayerId: h
        })), ci = ui.extend({
          addLayer: function(t2) {
            return this.hasLayer(t2) ? this : (t2.addEventParent(this), ui.prototype.addLayer.call(
              this,
              t2
            ), this.fire("layeradd", {
              layer: t2
            }));
          },
          removeLayer: function(t2) {
            return this.hasLayer(t2) ? ((t2 = t2 in this._layers ? this._layers[t2] : t2).removeEventParent(
              this
            ), ui.prototype.removeLayer.call(this, t2), this.fire("layerremove", {
              layer: t2
            })) : this;
          },
          setStyle: function(t2) {
            return this.invoke("setStyle", t2);
          },
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          getBounds: function() {
            var t2, e2 = new s();
            for (t2 in this._layers) {
              var i2 = this._layers[t2];
              e2.extend(i2.getBounds ? i2.getBounds() : i2.getLatLng());
            }
            return e2;
          }
        }), di = et.extend({
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0],
            crossOrigin: false
          },
          initialize: function(t2) {
            c(this, t2);
          },
          createIcon: function(t2) {
            return this._createIcon("icon", t2);
          },
          createShadow: function(t2) {
            return this._createIcon("shadow", t2);
          },
          _createIcon: function(t2, e2) {
            var i2 = this._getIconUrl(t2);
            if (i2)
              return i2 = this._createImg(i2, e2 && "IMG" === e2.tagName ? e2 : null), this._setIconStyles(i2, t2), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i2.crossOrigin = true === this.options.crossOrigin ? "" : this.options.crossOrigin), i2;
            if ("icon" === t2)
              throw new Error("iconUrl not set in Icon options (see the docs).");
            return null;
          },
          _setIconStyles: function(t2, e2) {
            var i2 = this.options, n2 = i2[e2 + "Size"], n2 = m(n2 = "number" == typeof n2 ? [n2, n2] : n2), o2 = m("shadow" === e2 && i2.shadowAnchor || i2.iconAnchor || n2 && n2.divideBy(2, true));
            t2.className = "leaflet-marker-" + e2 + " " + (i2.className || ""), o2 && (t2.style.marginLeft = -o2.x + "px", t2.style.marginTop = -o2.y + "px"), n2 && (t2.style.width = n2.x + "px", t2.style.height = n2.y + "px");
          },
          _createImg: function(t2, e2) {
            return (e2 = e2 || document.createElement("img")).src = t2, e2;
          },
          _getIconUrl: function(t2) {
            return b.retina && this.options[t2 + "RetinaUrl"] || this.options[t2 + "Url"];
          }
        });
        var _i = di.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(t2) {
            return "string" != typeof _i.imagePath && (_i.imagePath = this._detectIconPath()), (this.options.imagePath || _i.imagePath) + di.prototype._getIconUrl.call(this, t2);
          },
          _stripUrl: function(t2) {
            function e2(t3, e3, i2) {
              return (e3 = e3.exec(t3)) && e3[i2];
            }
            return (t2 = e2(t2, /^url\((['"])?(.+)\1\)$/, 2)) && e2(t2, /^(.*)marker-icon\.png$/, 1);
          },
          _detectIconPath: function() {
            var t2 = P("div", "leaflet-default-icon-path", document.body), e2 = pe(t2, "background-image") || pe(t2, "backgroundImage");
            return document.body.removeChild(t2), (e2 = this._stripUrl(e2)) ? e2 : (t2 = document.querySelector('link[href$="leaflet.css"]')) ? t2.href.substring(0, t2.href.length - "leaflet.css".length - 1) : "";
          }
        }), pi = n.extend({
          initialize: function(t2) {
            this._marker = t2;
          },
          addHooks: function() {
            var t2 = this._marker._icon;
            this._draggable || (this._draggable = new Xe(t2, t2, true)), this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable(), M(t2, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable(), this._marker._icon && z(
              this._marker._icon,
              "leaflet-marker-draggable"
            );
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(t2) {
            var e2 = this._marker, i2 = e2._map, n2 = this._marker.options.autoPanSpeed, o2 = this._marker.options.autoPanPadding, s2 = Pe(e2._icon), r2 = i2.getPixelBounds(), a2 = i2.getPixelOrigin(), a2 = _(r2.min._subtract(a2).add(o2), r2.max._subtract(a2).subtract(o2));
            a2.contains(s2) || (o2 = m((Math.max(a2.max.x, s2.x) - a2.max.x) / (r2.max.x - a2.max.x) - (Math.min(a2.min.x, s2.x) - a2.min.x) / (r2.min.x - a2.min.x), (Math.max(a2.max.y, s2.y) - a2.max.y) / (r2.max.y - a2.max.y) - (Math.min(a2.min.y, s2.y) - a2.min.y) / (r2.min.y - a2.min.y)).multiplyBy(n2), i2.panBy(o2, {
              animate: false
            }), this._draggable._newPos._add(o2), this._draggable._startPos._add(o2), Z(
              e2._icon,
              this._draggable._newPos
            ), this._onDrag(t2), this._panRequest = x(this._adjustPan.bind(this, t2)));
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(t2) {
            this._marker.options.autoPan && (r(this._panRequest), this._panRequest = x(this._adjustPan.bind(this, t2)));
          },
          _onDrag: function(t2) {
            var e2 = this._marker, i2 = e2._shadow, n2 = Pe(e2._icon), o2 = e2._map.layerPointToLatLng(n2);
            i2 && Z(i2, n2), e2._latlng = o2, t2.latlng = o2, t2.oldLatLng = this._oldLatLng, e2.fire("move", t2).fire("drag", t2);
          },
          _onDragEnd: function(t2) {
            r(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t2);
          }
        }), mi = o.extend({
          options: {
            icon: new _i(),
            interactive: true,
            keyboard: true,
            title: "",
            alt: "Marker",
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: false,
            riseOffset: 250,
            pane: "markerPane",
            shadowPane: "shadowPane",
            bubblingMouseEvents: false,
            autoPanOnFocus: true,
            draggable: false,
            autoPan: false,
            autoPanPadding: [50, 50],
            autoPanSpeed: 10
          },
          initialize: function(t2, e2) {
            c(this, e2), this._latlng = w(t2);
          },
          onAdd: function(t2) {
            this._zoomAnimated = this._zoomAnimated && t2.options.markerZoomAnimation, this._zoomAnimated && t2.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
          },
          onRemove: function(t2) {
            this.dragging && this.dragging.enabled() && (this.options.draggable = true, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t2.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(t2) {
            var e2 = this._latlng;
            return this._latlng = w(t2), this.update(), this.fire("move", {
              oldLatLng: e2,
              latlng: this._latlng
            });
          },
          setZIndexOffset: function(t2) {
            return this.options.zIndexOffset = t2, this.update();
          },
          getIcon: function() {
            return this.options.icon;
          },
          setIcon: function(t2) {
            return this.options.icon = t2, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            var t2;
            return this._icon && this._map && (t2 = this._map.latLngToLayerPoint(this._latlng).round(), this._setPos(t2)), this;
          },
          _initIcon: function() {
            var t2 = this.options, e2 = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), i2 = t2.icon.createIcon(this._icon), n2 = false, i2 = (i2 !== this._icon && (this._icon && this._removeIcon(), n2 = true, t2.title && (i2.title = t2.title), "IMG" === i2.tagName && (i2.alt = t2.alt || "")), M(i2, e2), t2.keyboard && (i2.tabIndex = "0", i2.setAttribute("role", "button")), this._icon = i2, t2.riseOnHover && this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            }), this.options.autoPanOnFocus && S(i2, "focus", this._panOnFocus, this), t2.icon.createShadow(this._shadow)), o2 = false;
            i2 !== this._shadow && (this._removeShadow(), o2 = true), i2 && (M(i2, e2), i2.alt = ""), this._shadow = i2, t2.opacity < 1 && this._updateOpacity(), n2 && this.getPane().appendChild(
              this._icon
            ), this._initInteraction(), i2 && o2 && this.getPane(t2.shadowPane).appendChild(this._shadow);
          },
          _removeIcon: function() {
            this.options.riseOnHover && this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            }), this.options.autoPanOnFocus && k(this._icon, "focus", this._panOnFocus, this), T(
              this._icon
            ), this.removeInteractiveTarget(this._icon), this._icon = null;
          },
          _removeShadow: function() {
            this._shadow && T(this._shadow), this._shadow = null;
          },
          _setPos: function(t2) {
            this._icon && Z(this._icon, t2), this._shadow && Z(this._shadow, t2), this._zIndex = t2.y + this.options.zIndexOffset, this._resetZIndex();
          },
          _updateZIndex: function(t2) {
            this._icon && (this._icon.style.zIndex = this._zIndex + t2);
          },
          _animateZoom: function(t2) {
            t2 = this._map._latLngToNewLayerPoint(this._latlng, t2.zoom, t2.center).round();
            this._setPos(t2);
          },
          _initInteraction: function() {
            var t2;
            this.options.interactive && (M(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), pi && (t2 = this.options.draggable, this.dragging && (t2 = this.dragging.enabled(), this.dragging.disable()), this.dragging = new pi(this), t2 && this.dragging.enable()));
          },
          setOpacity: function(t2) {
            return this.options.opacity = t2, this._map && this._updateOpacity(), this;
          },
          _updateOpacity: function() {
            var t2 = this.options.opacity;
            this._icon && C(this._icon, t2), this._shadow && C(this._shadow, t2);
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _panOnFocus: function() {
            var t2, e2, i2 = this._map;
            i2 && (t2 = (e2 = this.options.icon.options).iconSize ? m(e2.iconSize) : m(0, 0), e2 = e2.iconAnchor ? m(e2.iconAnchor) : m(0, 0), i2.panInside(this._latlng, {
              paddingTopLeft: e2,
              paddingBottomRight: t2.subtract(e2)
            }));
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        var fi = o.extend({
          options: {
            stroke: true,
            color: "#3388ff",
            weight: 3,
            opacity: 1,
            lineCap: "round",
            lineJoin: "round",
            dashArray: null,
            dashOffset: null,
            fill: false,
            fillColor: null,
            fillOpacity: 0.2,
            fillRule: "evenodd",
            interactive: true,
            bubblingMouseEvents: true
          },
          beforeAdd: function(t2) {
            this._renderer = t2.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          redraw: function() {
            return this._map && this._renderer._updatePath(this), this;
          },
          setStyle: function(t2) {
            return c(this, t2), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t2 && Object.prototype.hasOwnProperty.call(t2, "weight") && this._updateBounds()), this;
          },
          bringToFront: function() {
            return this._renderer && this._renderer._bringToFront(this), this;
          },
          bringToBack: function() {
            return this._renderer && this._renderer._bringToBack(this), this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project(), this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
          }
        }), gi = fi.extend({
          options: {
            fill: true,
            radius: 10
          },
          initialize: function(t2, e2) {
            c(this, e2), this._latlng = w(t2), this._radius = this.options.radius;
          },
          setLatLng: function(t2) {
            var e2 = this._latlng;
            return this._latlng = w(t2), this.redraw(), this.fire("move", {
              oldLatLng: e2,
              latlng: this._latlng
            });
          },
          getLatLng: function() {
            return this._latlng;
          },
          setRadius: function(t2) {
            return this.options.radius = this._radius = t2, this.redraw();
          },
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(t2) {
            var e2 = t2 && t2.radius || this._radius;
            return fi.prototype.setStyle.call(this, t2), this.setRadius(e2), this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
          },
          _updateBounds: function() {
            var t2 = this._radius, e2 = this._radiusY || t2, i2 = this._clickTolerance(), t2 = [t2 + i2, e2 + i2];
            this._pxBounds = new f(this._point.subtract(t2), this._point.add(t2));
          },
          _update: function() {
            this._map && this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          _containsPoint: function(t2) {
            return t2.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        var vi = gi.extend({
          initialize: function(t2, e2, i2) {
            if (c(this, e2 = "number" == typeof e2 ? l({}, i2, {
              radius: e2
            }) : e2), this._latlng = w(t2), isNaN(this.options.radius))
              throw new Error(
                "Circle radius cannot be NaN"
              );
            this._mRadius = this.options.radius;
          },
          setRadius: function(t2) {
            return this._mRadius = t2, this.redraw();
          },
          getRadius: function() {
            return this._mRadius;
          },
          getBounds: function() {
            var t2 = [this._radius, this._radiusY || this._radius];
            return new s(this._map.layerPointToLatLng(this._point.subtract(t2)), this._map.layerPointToLatLng(this._point.add(t2)));
          },
          setStyle: fi.prototype.setStyle,
          _project: function() {
            var t2, e2, i2, n2, o2, s2 = this._latlng.lng, r2 = this._latlng.lat, a2 = this._map, h2 = a2.options.crs;
            h2.distance === st.distance ? (n2 = Math.PI / 180, o2 = this._mRadius / st.R / n2, t2 = a2.project([r2 + o2, s2]), e2 = a2.project([r2 - o2, s2]), e2 = t2.add(e2).divideBy(2), i2 = a2.unproject(e2).lat, n2 = Math.acos((Math.cos(o2 * n2) - Math.sin(r2 * n2) * Math.sin(i2 * n2)) / (Math.cos(r2 * n2) * Math.cos(i2 * n2))) / n2, !isNaN(n2) && 0 !== n2 || (n2 = o2 / Math.cos(Math.PI / 180 * r2)), this._point = e2.subtract(a2.getPixelOrigin()), this._radius = isNaN(n2) ? 0 : e2.x - a2.project([i2, s2 - n2]).x, this._radiusY = e2.y - t2.y) : (o2 = h2.unproject(h2.project(this._latlng).subtract([this._mRadius, 0])), this._point = a2.latLngToLayerPoint(this._latlng), this._radius = this._point.x - a2.latLngToLayerPoint(o2).x), this._updateBounds();
          }
        });
        var yi = fi.extend({
          options: {
            smoothFactor: 1,
            noClip: false
          },
          initialize: function(t2, e2) {
            c(this, e2), this._setLatLngs(t2);
          },
          getLatLngs: function() {
            return this._latlngs;
          },
          setLatLngs: function(t2) {
            return this._setLatLngs(t2), this.redraw();
          },
          isEmpty: function() {
            return !this._latlngs.length;
          },
          closestLayerPoint: function(t2) {
            for (var e2 = 1 / 0, i2 = null, n2 = ri, o2 = 0, s2 = this._parts.length; o2 < s2; o2++)
              for (var r2 = this._parts[o2], a2 = 1, h2 = r2.length; a2 < h2; a2++) {
                var l2, u2, c2 = n2(t2, l2 = r2[a2 - 1], u2 = r2[a2], true);
                c2 < e2 && (e2 = c2, i2 = n2(t2, l2, u2));
              }
            return i2 && (i2.distance = Math.sqrt(e2)), i2;
          },
          getCenter: function() {
            if (this._map)
              return hi(this._defaultShape(), this._map.options.crs);
            throw new Error("Must add layer to map before using getCenter()");
          },
          getBounds: function() {
            return this._bounds;
          },
          addLatLng: function(t2, e2) {
            return e2 = e2 || this._defaultShape(), t2 = w(t2), e2.push(t2), this._bounds.extend(t2), this.redraw();
          },
          _setLatLngs: function(t2) {
            this._bounds = new s(), this._latlngs = this._convertLatLngs(t2);
          },
          _defaultShape: function() {
            return I(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          _convertLatLngs: function(t2) {
            for (var e2 = [], i2 = I(t2), n2 = 0, o2 = t2.length; n2 < o2; n2++)
              i2 ? (e2[n2] = w(t2[n2]), this._bounds.extend(e2[n2])) : e2[n2] = this._convertLatLngs(t2[n2]);
            return e2;
          },
          _project: function() {
            var t2 = new f();
            this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t2), this._bounds.isValid() && t2.isValid() && (this._rawPxBounds = t2, this._updateBounds());
          },
          _updateBounds: function() {
            var t2 = this._clickTolerance(), t2 = new p(t2, t2);
            this._rawPxBounds && (this._pxBounds = new f([
              this._rawPxBounds.min.subtract(t2),
              this._rawPxBounds.max.add(t2)
            ]));
          },
          _projectLatlngs: function(t2, e2, i2) {
            var n2, o2, s2 = t2[0] instanceof v, r2 = t2.length;
            if (s2) {
              for (o2 = [], n2 = 0; n2 < r2; n2++)
                o2[n2] = this._map.latLngToLayerPoint(t2[n2]), i2.extend(o2[n2]);
              e2.push(o2);
            } else
              for (n2 = 0; n2 < r2; n2++)
                this._projectLatlngs(t2[n2], e2, i2);
          },
          _clipPoints: function() {
            var t2 = this._renderer._bounds;
            if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t2))
              if (this.options.noClip)
                this._parts = this._rings;
              else
                for (var e2, i2, n2, o2, s2 = this._parts, r2 = 0, a2 = 0, h2 = this._rings.length; r2 < h2; r2++)
                  for (e2 = 0, i2 = (o2 = this._rings[r2]).length; e2 < i2 - 1; e2++)
                    (n2 = ni(o2[e2], o2[e2 + 1], t2, e2, true)) && (s2[a2] = s2[a2] || [], s2[a2].push(n2[0]), n2[1] === o2[e2 + 1] && e2 !== i2 - 2 || (s2[a2].push(n2[1]), a2++));
          },
          _simplifyPoints: function() {
            for (var t2 = this._parts, e2 = this.options.smoothFactor, i2 = 0, n2 = t2.length; i2 < n2; i2++)
              t2[i2] = ei(t2[i2], e2);
          },
          _update: function() {
            this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          _containsPoint: function(t2, e2) {
            var i2, n2, o2, s2, r2, a2, h2 = this._clickTolerance();
            if (this._pxBounds && this._pxBounds.contains(t2)) {
              for (i2 = 0, s2 = this._parts.length; i2 < s2; i2++)
                for (n2 = 0, o2 = (r2 = (a2 = this._parts[i2]).length) - 1; n2 < r2; o2 = n2++)
                  if ((e2 || 0 !== n2) && ii(t2, a2[o2], a2[n2]) <= h2)
                    return true;
            }
            return false;
          }
        });
        yi._flat = ai;
        var xi = yi.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          getCenter: function() {
            if (this._map)
              return $e(this._defaultShape(), this._map.options.crs);
            throw new Error("Must add layer to map before using getCenter()");
          },
          _convertLatLngs: function(t2) {
            var t2 = yi.prototype._convertLatLngs.call(this, t2), e2 = t2.length;
            return 2 <= e2 && t2[0] instanceof v && t2[0].equals(t2[e2 - 1]) && t2.pop(), t2;
          },
          _setLatLngs: function(t2) {
            yi.prototype._setLatLngs.call(this, t2), I(this._latlngs) && (this._latlngs = [this._latlngs]);
          },
          _defaultShape: function() {
            return (I(this._latlngs[0]) ? this._latlngs : this._latlngs[0])[0];
          },
          _clipPoints: function() {
            var t2 = this._renderer._bounds, e2 = this.options.weight, e2 = new p(e2, e2), t2 = new f(t2.min.subtract(e2), t2.max.add(e2));
            if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t2))
              if (this.options.noClip)
                this._parts = this._rings;
              else
                for (var i2, n2 = 0, o2 = this._rings.length; n2 < o2; n2++)
                  (i2 = Je(this._rings[n2], t2, true)).length && this._parts.push(i2);
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          _containsPoint: function(t2) {
            var e2, i2, n2, o2, s2, r2, a2, h2, l2 = false;
            if (!this._pxBounds || !this._pxBounds.contains(t2))
              return false;
            for (o2 = 0, a2 = this._parts.length; o2 < a2; o2++)
              for (s2 = 0, r2 = (h2 = (e2 = this._parts[o2]).length) - 1; s2 < h2; r2 = s2++)
                i2 = e2[s2], n2 = e2[r2], i2.y > t2.y != n2.y > t2.y && t2.x < (n2.x - i2.x) * (t2.y - i2.y) / (n2.y - i2.y) + i2.x && (l2 = !l2);
            return l2 || yi.prototype._containsPoint.call(this, t2, true);
          }
        });
        var wi = ci.extend({
          initialize: function(t2, e2) {
            c(this, e2), this._layers = {}, t2 && this.addData(t2);
          },
          addData: function(t2) {
            var e2, i2, n2, o2 = d(t2) ? t2 : t2.features;
            if (o2) {
              for (e2 = 0, i2 = o2.length; e2 < i2; e2++)
                ((n2 = o2[e2]).geometries || n2.geometry || n2.features || n2.coordinates) && this.addData(n2);
              return this;
            }
            var s2, r2 = this.options;
            return (!r2.filter || r2.filter(t2)) && (s2 = bi(t2, r2)) ? (s2.feature = Zi(t2), s2.defaultOptions = s2.options, this.resetStyle(s2), r2.onEachFeature && r2.onEachFeature(t2, s2), this.addLayer(s2)) : this;
          },
          resetStyle: function(t2) {
            return void 0 === t2 ? this.eachLayer(this.resetStyle, this) : (t2.options = l({}, t2.defaultOptions), this._setLayerStyle(t2, this.options.style), this);
          },
          setStyle: function(e2) {
            return this.eachLayer(function(t2) {
              this._setLayerStyle(t2, e2);
            }, this);
          },
          _setLayerStyle: function(t2, e2) {
            t2.setStyle && ("function" == typeof e2 && (e2 = e2(t2.feature)), t2.setStyle(e2));
          }
        });
        function bi(t2, e2) {
          var i2, n2, o2, s2, r2 = "Feature" === t2.type ? t2.geometry : t2, a2 = r2 ? r2.coordinates : null, h2 = [], l2 = e2 && e2.pointToLayer, u2 = e2 && e2.coordsToLatLng || Li;
          if (!a2 && !r2)
            return null;
          switch (r2.type) {
            case "Point":
              return Pi(l2, t2, i2 = u2(a2), e2);
            case "MultiPoint":
              for (o2 = 0, s2 = a2.length; o2 < s2; o2++)
                i2 = u2(a2[o2]), h2.push(Pi(l2, t2, i2, e2));
              return new ci(h2);
            case "LineString":
            case "MultiLineString":
              return n2 = Ti(a2, "LineString" === r2.type ? 0 : 1, u2), new yi(n2, e2);
            case "Polygon":
            case "MultiPolygon":
              return n2 = Ti(a2, "Polygon" === r2.type ? 1 : 2, u2), new xi(n2, e2);
            case "GeometryCollection":
              for (o2 = 0, s2 = r2.geometries.length; o2 < s2; o2++) {
                var c2 = bi({
                  geometry: r2.geometries[o2],
                  type: "Feature",
                  properties: t2.properties
                }, e2);
                c2 && h2.push(c2);
              }
              return new ci(h2);
            case "FeatureCollection":
              for (o2 = 0, s2 = r2.features.length; o2 < s2; o2++) {
                var d2 = bi(r2.features[o2], e2);
                d2 && h2.push(d2);
              }
              return new ci(h2);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        function Pi(t2, e2, i2, n2) {
          return t2 ? t2(e2, i2) : new mi(i2, n2 && n2.markersInheritOptions && n2);
        }
        function Li(t2) {
          return new v(t2[1], t2[0], t2[2]);
        }
        function Ti(t2, e2, i2) {
          for (var n2, o2 = [], s2 = 0, r2 = t2.length; s2 < r2; s2++)
            n2 = e2 ? Ti(t2[s2], e2 - 1, i2) : (i2 || Li)(t2[s2]), o2.push(
              n2
            );
          return o2;
        }
        function Mi(t2, e2) {
          return void 0 !== (t2 = w(t2)).alt ? [i(t2.lng, e2), i(t2.lat, e2), i(t2.alt, e2)] : [i(t2.lng, e2), i(t2.lat, e2)];
        }
        function zi(t2, e2, i2, n2) {
          for (var o2 = [], s2 = 0, r2 = t2.length; s2 < r2; s2++)
            o2.push(e2 ? zi(t2[s2], I(t2[s2]) ? 0 : e2 - 1, i2, n2) : Mi(
              t2[s2],
              n2
            ));
          return !e2 && i2 && 0 < o2.length && o2.push(o2[0].slice()), o2;
        }
        function Ci(t2, e2) {
          return t2.feature ? l({}, t2.feature, {
            geometry: e2
          }) : Zi(e2);
        }
        function Zi(t2) {
          return "Feature" === t2.type || "FeatureCollection" === t2.type ? t2 : {
            type: "Feature",
            properties: {},
            geometry: t2
          };
        }
        Tt = {
          toGeoJSON: function(t2) {
            return Ci(this, {
              type: "Point",
              coordinates: Mi(this.getLatLng(), t2)
            });
          }
        };
        function Si(t2, e2) {
          return new wi(t2, e2);
        }
        mi.include(Tt), vi.include(Tt), gi.include(Tt), yi.include({
          toGeoJSON: function(t2) {
            var e2 = !I(this._latlngs);
            return Ci(this, {
              type: (e2 ? "Multi" : "") + "LineString",
              coordinates: zi(this._latlngs, e2 ? 1 : 0, false, t2)
            });
          }
        }), xi.include({
          toGeoJSON: function(t2) {
            var e2 = !I(this._latlngs), i2 = e2 && !I(this._latlngs[0]), t2 = zi(this._latlngs, i2 ? 2 : e2 ? 1 : 0, true, t2);
            return Ci(this, {
              type: (i2 ? "Multi" : "") + "Polygon",
              coordinates: t2 = e2 ? t2 : [t2]
            });
          }
        }), ui.include({
          toMultiPoint: function(e2) {
            var i2 = [];
            return this.eachLayer(function(t2) {
              i2.push(t2.toGeoJSON(e2).geometry.coordinates);
            }), Ci(this, {
              type: "MultiPoint",
              coordinates: i2
            });
          },
          toGeoJSON: function(e2) {
            var i2, n2, t2 = this.feature && this.feature.geometry && this.feature.geometry.type;
            return "MultiPoint" === t2 ? this.toMultiPoint(e2) : (i2 = "GeometryCollection" === t2, n2 = [], this.eachLayer(function(t3) {
              t3.toGeoJSON && (t3 = t3.toGeoJSON(e2), i2 ? n2.push(t3.geometry) : "FeatureCollection" === (t3 = Zi(t3)).type ? n2.push.apply(n2, t3.features) : n2.push(t3));
            }), i2 ? Ci(this, {
              geometries: n2,
              type: "GeometryCollection"
            }) : {
              type: "FeatureCollection",
              features: n2
            });
          }
        });
        var Mt = Si, Ei = o.extend({
          options: {
            opacity: 1,
            alt: "",
            interactive: false,
            crossOrigin: false,
            errorOverlayUrl: "",
            zIndex: 1,
            className: ""
          },
          initialize: function(t2, e2, i2) {
            this._url = t2, this._bounds = g(e2), c(this, i2);
          },
          onAdd: function() {
            this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (M(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
          },
          onRemove: function() {
            T(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
          },
          setOpacity: function(t2) {
            return this.options.opacity = t2, this._image && this._updateOpacity(), this;
          },
          setStyle: function(t2) {
            return t2.opacity && this.setOpacity(t2.opacity), this;
          },
          bringToFront: function() {
            return this._map && fe(this._image), this;
          },
          bringToBack: function() {
            return this._map && ge(this._image), this;
          },
          setUrl: function(t2) {
            return this._url = t2, this._image && (this._image.src = t2), this;
          },
          setBounds: function(t2) {
            return this._bounds = g(t2), this._map && this._reset(), this;
          },
          getEvents: function() {
            var t2 = {
              zoom: this._reset,
              viewreset: this._reset
            };
            return this._zoomAnimated && (t2.zoomanim = this._animateZoom), t2;
          },
          setZIndex: function(t2) {
            return this.options.zIndex = t2, this._updateZIndex(), this;
          },
          getBounds: function() {
            return this._bounds;
          },
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var t2 = "IMG" === this._url.tagName, e2 = this._image = t2 ? this._url : P("img");
            M(e2, "leaflet-image-layer"), this._zoomAnimated && M(e2, "leaflet-zoom-animated"), this.options.className && M(e2, this.options.className), e2.onselectstart = u, e2.onmousemove = u, e2.onload = a(this.fire, this, "load"), e2.onerror = a(
              this._overlayOnError,
              this,
              "error"
            ), !this.options.crossOrigin && "" !== this.options.crossOrigin || (e2.crossOrigin = true === this.options.crossOrigin ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t2 ? this._url = e2.src : (e2.src = this._url, e2.alt = this.options.alt);
          },
          _animateZoom: function(t2) {
            var e2 = this._map.getZoomScale(t2.zoom), t2 = this._map._latLngBoundsToNewLayerBounds(this._bounds, t2.zoom, t2.center).min;
            be(this._image, t2, e2);
          },
          _reset: function() {
            var t2 = this._image, e2 = new f(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), i2 = e2.getSize();
            Z(t2, e2.min), t2.style.width = i2.x + "px", t2.style.height = i2.y + "px";
          },
          _updateOpacity: function() {
            C(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex);
          },
          _overlayOnError: function() {
            this.fire("error");
            var t2 = this.options.errorOverlayUrl;
            t2 && this._url !== t2 && (this._url = t2, this._image.src = t2);
          },
          getCenter: function() {
            return this._bounds.getCenter();
          }
        }), ki = Ei.extend({
          options: {
            autoplay: true,
            loop: true,
            keepAspectRatio: true,
            muted: false,
            playsInline: true
          },
          _initImage: function() {
            var t2 = "VIDEO" === this._url.tagName, e2 = this._image = t2 ? this._url : P("video");
            if (M(e2, "leaflet-image-layer"), this._zoomAnimated && M(e2, "leaflet-zoom-animated"), this.options.className && M(e2, this.options.className), e2.onselectstart = u, e2.onmousemove = u, e2.onloadeddata = a(this.fire, this, "load"), t2) {
              for (var i2 = e2.getElementsByTagName("source"), n2 = [], o2 = 0; o2 < i2.length; o2++)
                n2.push(
                  i2[o2].src
                );
              this._url = 0 < i2.length ? n2 : [e2.src];
            } else {
              d(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(e2.style, "objectFit") && (e2.style.objectFit = "fill"), e2.autoplay = !!this.options.autoplay, e2.loop = !!this.options.loop, e2.muted = !!this.options.muted, e2.playsInline = !!this.options.playsInline;
              for (var s2 = 0; s2 < this._url.length; s2++) {
                var r2 = P("source");
                r2.src = this._url[s2], e2.appendChild(r2);
              }
            }
          }
        });
        var Oi = Ei.extend({
          _initImage: function() {
            var t2 = this._image = this._url;
            M(t2, "leaflet-image-layer"), this._zoomAnimated && M(t2, "leaflet-zoom-animated"), this.options.className && M(t2, this.options.className), t2.onselectstart = u, t2.onmousemove = u;
          }
        });
        var Ai = o.extend({
          options: {
            interactive: false,
            offset: [0, 0],
            className: "",
            pane: void 0,
            content: ""
          },
          initialize: function(t2, e2) {
            t2 && (t2 instanceof v || d(t2)) ? (this._latlng = w(t2), c(this, e2)) : (c(this, t2), this._source = e2), this.options.content && (this._content = this.options.content);
          },
          openOn: function(t2) {
            return (t2 = arguments.length ? t2 : this._source._map).hasLayer(this) || t2.addLayer(this), this;
          },
          close: function() {
            return this._map && this._map.removeLayer(this), this;
          },
          toggle: function(t2) {
            return this._map ? this.close() : (arguments.length ? this._source = t2 : t2 = this._source, this._prepareOpen(), this.openOn(t2._map)), this;
          },
          onAdd: function(t2) {
            this._zoomAnimated = t2._zoomAnimated, this._container || this._initLayout(), t2._fadeAnimated && C(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t2._fadeAnimated && C(this._container, 1), this.bringToFront(), this.options.interactive && (M(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
          },
          onRemove: function(t2) {
            t2._fadeAnimated ? (C(this._container, 0), this._removeTimeout = setTimeout(a(T, void 0, this._container), 200)) : T(this._container), this.options.interactive && (z(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(t2) {
            return this._latlng = w(t2), this._map && (this._updatePosition(), this._adjustPan()), this;
          },
          getContent: function() {
            return this._content;
          },
          setContent: function(t2) {
            return this._content = t2, this.update(), this;
          },
          getElement: function() {
            return this._container;
          },
          update: function() {
            this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
          },
          getEvents: function() {
            var t2 = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            return this._zoomAnimated && (t2.zoomanim = this._animateZoom), t2;
          },
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          bringToFront: function() {
            return this._map && fe(this._container), this;
          },
          bringToBack: function() {
            return this._map && ge(this._container), this;
          },
          _prepareOpen: function(t2) {
            if (!(i2 = this._source)._map)
              return false;
            if (i2 instanceof ci) {
              var e2, i2 = null, n2 = this._source._layers;
              for (e2 in n2)
                if (n2[e2]._map) {
                  i2 = n2[e2];
                  break;
                }
              if (!i2)
                return false;
              this._source = i2;
            }
            if (!t2)
              if (i2.getCenter)
                t2 = i2.getCenter();
              else if (i2.getLatLng)
                t2 = i2.getLatLng();
              else {
                if (!i2.getBounds)
                  throw new Error("Unable to get source layer LatLng.");
                t2 = i2.getBounds().getCenter();
              }
            return this.setLatLng(t2), this._map && this.update(), true;
          },
          _updateContent: function() {
            if (this._content) {
              var t2 = this._contentNode, e2 = "function" == typeof this._content ? this._content(this._source || this) : this._content;
              if ("string" == typeof e2)
                t2.innerHTML = e2;
              else {
                for (; t2.hasChildNodes(); )
                  t2.removeChild(t2.firstChild);
                t2.appendChild(e2);
              }
              this.fire("contentupdate");
            }
          },
          _updatePosition: function() {
            var t2, e2, i2;
            this._map && (e2 = this._map.latLngToLayerPoint(this._latlng), t2 = m(this.options.offset), i2 = this._getAnchor(), this._zoomAnimated ? Z(this._container, e2.add(i2)) : t2 = t2.add(e2).add(i2), e2 = this._containerBottom = -t2.y, i2 = this._containerLeft = -Math.round(this._containerWidth / 2) + t2.x, this._container.style.bottom = e2 + "px", this._container.style.left = i2 + "px");
          },
          _getAnchor: function() {
            return [0, 0];
          }
        }), Bi = (A.include({
          _initOverlay: function(t2, e2, i2, n2) {
            var o2 = e2;
            return o2 instanceof t2 || (o2 = new t2(n2).setContent(e2)), i2 && o2.setLatLng(i2), o2;
          }
        }), o.include({
          _initOverlay: function(t2, e2, i2, n2) {
            var o2 = i2;
            return o2 instanceof t2 ? (c(o2, n2), o2._source = this) : (o2 = e2 && !n2 ? e2 : new t2(n2, this)).setContent(i2), o2;
          }
        }), Ai.extend({
          options: {
            pane: "popupPane",
            offset: [0, 7],
            maxWidth: 300,
            minWidth: 50,
            maxHeight: null,
            autoPan: true,
            autoPanPaddingTopLeft: null,
            autoPanPaddingBottomRight: null,
            autoPanPadding: [5, 5],
            keepInView: false,
            closeButton: true,
            autoClose: true,
            closeOnEscapeKey: true,
            className: ""
          },
          openOn: function(t2) {
            return !(t2 = arguments.length ? t2 : this._source._map).hasLayer(this) && t2._popup && t2._popup.options.autoClose && t2.removeLayer(t2._popup), t2._popup = this, Ai.prototype.openOn.call(this, t2);
          },
          onAdd: function(t2) {
            Ai.prototype.onAdd.call(this, t2), t2.fire("popupopen", {
              popup: this
            }), this._source && (this._source.fire("popupopen", {
              popup: this
            }, true), this._source instanceof fi || this._source.on("preclick", Ae));
          },
          onRemove: function(t2) {
            Ai.prototype.onRemove.call(this, t2), t2.fire("popupclose", {
              popup: this
            }), this._source && (this._source.fire("popupclose", {
              popup: this
            }, true), this._source instanceof fi || this._source.off("preclick", Ae));
          },
          getEvents: function() {
            var t2 = Ai.prototype.getEvents.call(this);
            return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t2.preclick = this.close), this.options.keepInView && (t2.moveend = this._adjustPan), t2;
          },
          _initLayout: function() {
            var t2 = "leaflet-popup", e2 = this._container = P("div", t2 + " " + (this.options.className || "") + " leaflet-zoom-animated"), i2 = this._wrapper = P("div", t2 + "-content-wrapper", e2);
            this._contentNode = P("div", t2 + "-content", i2), Ie(e2), Be(this._contentNode), S(
              e2,
              "contextmenu",
              Ae
            ), this._tipContainer = P("div", t2 + "-tip-container", e2), this._tip = P("div", t2 + "-tip", this._tipContainer), this.options.closeButton && ((i2 = this._closeButton = P("a", t2 + "-close-button", e2)).setAttribute(
              "role",
              "button"
            ), i2.setAttribute("aria-label", "Close popup"), i2.href = "#close", i2.innerHTML = '<span aria-hidden="true">&#215;</span>', S(i2, "click", function(t3) {
              O(t3), this.close();
            }, this));
          },
          _updateLayout: function() {
            var t2 = this._contentNode, e2 = t2.style, i2 = (e2.width = "", e2.whiteSpace = "nowrap", t2.offsetWidth), i2 = Math.min(i2, this.options.maxWidth), i2 = (i2 = Math.max(i2, this.options.minWidth), e2.width = i2 + 1 + "px", e2.whiteSpace = "", e2.height = "", t2.offsetHeight), n2 = this.options.maxHeight, o2 = "leaflet-popup-scrolled";
            (n2 && n2 < i2 ? (e2.height = n2 + "px", M) : z)(t2, o2), this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(t2) {
            var t2 = this._map._latLngToNewLayerPoint(this._latlng, t2.zoom, t2.center), e2 = this._getAnchor();
            Z(this._container, t2.add(e2));
          },
          _adjustPan: function() {
            var t2, e2, i2, n2, o2, s2, r2, a2;
            this.options.autoPan && (this._map._panAnim && this._map._panAnim.stop(), this._autopanning ? this._autopanning = false : (t2 = this._map, e2 = parseInt(pe(this._container, "marginBottom"), 10) || 0, e2 = this._container.offsetHeight + e2, a2 = this._containerWidth, (i2 = new p(
              this._containerLeft,
              -e2 - this._containerBottom
            ))._add(Pe(this._container)), i2 = t2.layerPointToContainerPoint(i2), o2 = m(this.options.autoPanPadding), n2 = m(
              this.options.autoPanPaddingTopLeft || o2
            ), o2 = m(this.options.autoPanPaddingBottomRight || o2), s2 = t2.getSize(), r2 = 0, i2.x + a2 + o2.x > s2.x && (r2 = i2.x + a2 - s2.x + o2.x), i2.x - r2 - n2.x < (a2 = 0) && (r2 = i2.x - n2.x), i2.y + e2 + o2.y > s2.y && (a2 = i2.y + e2 - s2.y + o2.y), i2.y - a2 - n2.y < 0 && (a2 = i2.y - n2.y), (r2 || a2) && (this.options.keepInView && (this._autopanning = true), t2.fire("autopanstart").panBy([r2, a2]))));
          },
          _getAnchor: function() {
            return m(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        })), Ii = (A.mergeOptions({
          closePopupOnClick: true
        }), A.include({
          openPopup: function(t2, e2, i2) {
            return this._initOverlay(Bi, t2, e2, i2).openOn(this), this;
          },
          closePopup: function(t2) {
            return (t2 = arguments.length ? t2 : this._popup) && t2.close(), this;
          }
        }), o.include({
          bindPopup: function(t2, e2) {
            return this._popup = this._initOverlay(Bi, this._popup, t2, e2), this._popupHandlersAdded || (this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            }), this._popupHandlersAdded = true), this;
          },
          unbindPopup: function() {
            return this._popup && (this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            }), this._popupHandlersAdded = false, this._popup = null), this;
          },
          openPopup: function(t2) {
            return this._popup && (this instanceof ci || (this._popup._source = this), this._popup._prepareOpen(t2 || this._latlng) && this._popup.openOn(this._map)), this;
          },
          closePopup: function() {
            return this._popup && this._popup.close(), this;
          },
          togglePopup: function() {
            return this._popup && this._popup.toggle(this), this;
          },
          isPopupOpen: function() {
            return !!this._popup && this._popup.isOpen();
          },
          setPopupContent: function(t2) {
            return this._popup && this._popup.setContent(t2), this;
          },
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(t2) {
            var e2;
            this._popup && this._map && (Re(t2), e2 = t2.layer || t2.target, this._popup._source !== e2 || e2 instanceof fi ? (this._popup._source = e2, this.openPopup(t2.latlng)) : this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(t2.latlng));
          },
          _movePopup: function(t2) {
            this._popup.setLatLng(t2.latlng);
          },
          _onKeyPress: function(t2) {
            13 === t2.originalEvent.keyCode && this._openPopup(t2);
          }
        }), Ai.extend({
          options: {
            pane: "tooltipPane",
            offset: [0, 0],
            direction: "auto",
            permanent: false,
            sticky: false,
            opacity: 0.9
          },
          onAdd: function(t2) {
            Ai.prototype.onAdd.call(this, t2), this.setOpacity(this.options.opacity), t2.fire(
              "tooltipopen",
              {
                tooltip: this
              }
            ), this._source && (this.addEventParent(this._source), this._source.fire(
              "tooltipopen",
              {
                tooltip: this
              },
              true
            ));
          },
          onRemove: function(t2) {
            Ai.prototype.onRemove.call(this, t2), t2.fire("tooltipclose", {
              tooltip: this
            }), this._source && (this.removeEventParent(this._source), this._source.fire(
              "tooltipclose",
              {
                tooltip: this
              },
              true
            ));
          },
          getEvents: function() {
            var t2 = Ai.prototype.getEvents.call(this);
            return this.options.permanent || (t2.preclick = this.close), t2;
          },
          _initLayout: function() {
            var t2 = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = P("div", t2), this._container.setAttribute(
              "role",
              "tooltip"
            ), this._container.setAttribute("id", "leaflet-tooltip-" + h(this));
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(t2) {
            var e2, i2 = this._map, n2 = this._container, o2 = i2.latLngToContainerPoint(i2.getCenter()), i2 = i2.layerPointToContainerPoint(t2), s2 = this.options.direction, r2 = n2.offsetWidth, a2 = n2.offsetHeight, h2 = m(this.options.offset), l2 = this._getAnchor(), i2 = "top" === s2 ? (e2 = r2 / 2, a2) : "bottom" === s2 ? (e2 = r2 / 2, 0) : (e2 = "center" === s2 ? r2 / 2 : "right" === s2 ? 0 : "left" === s2 ? r2 : i2.x < o2.x ? (s2 = "right", 0) : (s2 = "left", r2 + 2 * (h2.x + l2.x)), a2 / 2);
            t2 = t2.subtract(m(e2, i2, true)).add(h2).add(l2), z(n2, "leaflet-tooltip-right"), z(
              n2,
              "leaflet-tooltip-left"
            ), z(n2, "leaflet-tooltip-top"), z(
              n2,
              "leaflet-tooltip-bottom"
            ), M(n2, "leaflet-tooltip-" + s2), Z(n2, t2);
          },
          _updatePosition: function() {
            var t2 = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(t2);
          },
          setOpacity: function(t2) {
            this.options.opacity = t2, this._container && C(this._container, t2);
          },
          _animateZoom: function(t2) {
            t2 = this._map._latLngToNewLayerPoint(this._latlng, t2.zoom, t2.center);
            this._setPosition(t2);
          },
          _getAnchor: function() {
            return m(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        })), Ri = (A.include({
          openTooltip: function(t2, e2, i2) {
            return this._initOverlay(Ii, t2, e2, i2).openOn(this), this;
          },
          closeTooltip: function(t2) {
            return t2.close(), this;
          }
        }), o.include({
          bindTooltip: function(t2, e2) {
            return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Ii, this._tooltip, t2, e2), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
          },
          unbindTooltip: function() {
            return this._tooltip && (this._initTooltipInteractions(true), this.closeTooltip(), this._tooltip = null), this;
          },
          _initTooltipInteractions: function(t2) {
            var e2, i2;
            !t2 && this._tooltipHandlersAdded || (e2 = t2 ? "off" : "on", i2 = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            }, this._tooltip.options.permanent ? i2.add = this._openTooltip : (i2.mouseover = this._openTooltip, i2.mouseout = this.closeTooltip, i2.click = this._openTooltip, this._map ? this._addFocusListeners() : i2.add = this._addFocusListeners), this._tooltip.options.sticky && (i2.mousemove = this._moveTooltip), this[e2](i2), this._tooltipHandlersAdded = !t2);
          },
          openTooltip: function(t2) {
            return this._tooltip && (this instanceof ci || (this._tooltip._source = this), this._tooltip._prepareOpen(t2) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(
              this._setAriaDescribedByOnLayer,
              this
            ))), this;
          },
          closeTooltip: function() {
            if (this._tooltip)
              return this._tooltip.close();
          },
          toggleTooltip: function() {
            return this._tooltip && this._tooltip.toggle(this), this;
          },
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          setTooltipContent: function(t2) {
            return this._tooltip && this._tooltip.setContent(t2), this;
          },
          getTooltip: function() {
            return this._tooltip;
          },
          _addFocusListeners: function() {
            this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
          },
          _addFocusListenersOnLayer: function(t2) {
            var e2 = "function" == typeof t2.getElement && t2.getElement();
            e2 && (S(e2, "focus", function() {
              this._tooltip._source = t2, this.openTooltip();
            }, this), S(e2, "blur", this.closeTooltip, this));
          },
          _setAriaDescribedByOnLayer: function(t2) {
            t2 = "function" == typeof t2.getElement && t2.getElement();
            t2 && t2.setAttribute("aria-describedby", this._tooltip._container.id);
          },
          _openTooltip: function(t2) {
            var e2;
            this._tooltip && this._map && (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag ? (this._openOnceFlag = true, (e2 = this)._map.once(
              "moveend",
              function() {
                e2._openOnceFlag = false, e2._openTooltip(t2);
              }
            )) : (this._tooltip._source = t2.layer || t2.target, this.openTooltip(this._tooltip.options.sticky ? t2.latlng : void 0)));
          },
          _moveTooltip: function(t2) {
            var e2 = t2.latlng;
            this._tooltip.options.sticky && t2.originalEvent && (t2 = this._map.mouseEventToContainerPoint(t2.originalEvent), t2 = this._map.containerPointToLayerPoint(t2), e2 = this._map.layerPointToLatLng(t2)), this._tooltip.setLatLng(e2);
          }
        }), di.extend({
          options: {
            iconSize: [12, 12],
            html: false,
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(t2) {
            var t2 = t2 && "DIV" === t2.tagName ? t2 : document.createElement("div"), e2 = this.options;
            return e2.html instanceof Element ? (me(t2), t2.appendChild(e2.html)) : t2.innerHTML = false !== e2.html ? e2.html : "", e2.bgPos && (e2 = m(e2.bgPos), t2.style.backgroundPosition = -e2.x + "px " + -e2.y + "px"), this._setIconStyles(t2, "icon"), t2;
          },
          createShadow: function() {
            return null;
          }
        }));
        di.Default = _i;
        var Ni = o.extend({
          options: {
            tileSize: 256,
            opacity: 1,
            updateWhenIdle: b.mobile,
            updateWhenZooming: true,
            updateInterval: 200,
            zIndex: 1,
            bounds: null,
            minZoom: 0,
            maxZoom: void 0,
            maxNativeZoom: void 0,
            minNativeZoom: void 0,
            noWrap: false,
            pane: "tilePane",
            className: "",
            keepBuffer: 2
          },
          initialize: function(t2) {
            c(this, t2);
          },
          onAdd: function() {
            this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
          },
          beforeAdd: function(t2) {
            t2._addZoomLimit(this);
          },
          onRemove: function(t2) {
            this._removeAllTiles(), T(this._container), t2._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
          },
          bringToFront: function() {
            return this._map && (fe(this._container), this._setAutoZIndex(Math.max)), this;
          },
          bringToBack: function() {
            return this._map && (ge(this._container), this._setAutoZIndex(Math.min)), this;
          },
          getContainer: function() {
            return this._container;
          },
          setOpacity: function(t2) {
            return this.options.opacity = t2, this._updateOpacity(), this;
          },
          setZIndex: function(t2) {
            return this.options.zIndex = t2, this._updateZIndex(), this;
          },
          isLoading: function() {
            return this._loading;
          },
          redraw: function() {
            var t2;
            return this._map && (this._removeAllTiles(), (t2 = this._clampZoom(this._map.getZoom())) !== this._tileZoom && (this._tileZoom = t2, this._updateLevels()), this._update()), this;
          },
          getEvents: function() {
            var t2 = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            return this.options.updateWhenIdle || (this._onMove || (this._onMove = j(
              this._onMoveEnd,
              this.options.updateInterval,
              this
            )), t2.move = this._onMove), this._zoomAnimated && (t2.zoomanim = this._animateZoom), t2;
          },
          createTile: function() {
            return document.createElement("div");
          },
          getTileSize: function() {
            var t2 = this.options.tileSize;
            return t2 instanceof p ? t2 : new p(t2, t2);
          },
          _updateZIndex: function() {
            this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex);
          },
          _setAutoZIndex: function(t2) {
            for (var e2, i2 = this.getPane().children, n2 = -t2(-1 / 0, 1 / 0), o2 = 0, s2 = i2.length; o2 < s2; o2++)
              e2 = i2[o2].style.zIndex, i2[o2] !== this._container && e2 && (n2 = t2(n2, +e2));
            isFinite(n2) && (this.options.zIndex = n2 + t2(-1, 1), this._updateZIndex());
          },
          _updateOpacity: function() {
            if (this._map && !b.ielt9) {
              C(this._container, this.options.opacity);
              var t2, e2 = +/* @__PURE__ */ new Date(), i2 = false, n2 = false;
              for (t2 in this._tiles) {
                var o2, s2 = this._tiles[t2];
                s2.current && s2.loaded && (o2 = Math.min(1, (e2 - s2.loaded) / 200), C(s2.el, o2), o2 < 1 ? i2 = true : (s2.active ? n2 = true : this._onOpaqueTile(s2), s2.active = true));
              }
              n2 && !this._noPrune && this._pruneTiles(), i2 && (r(this._fadeFrame), this._fadeFrame = x(this._updateOpacity, this));
            }
          },
          _onOpaqueTile: u,
          _initContainer: function() {
            this._container || (this._container = P("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
          },
          _updateLevels: function() {
            var t2 = this._tileZoom, e2 = this.options.maxZoom;
            if (void 0 !== t2) {
              for (var i2 in this._levels)
                i2 = Number(i2), this._levels[i2].el.children.length || i2 === t2 ? (this._levels[i2].el.style.zIndex = e2 - Math.abs(t2 - i2), this._onUpdateLevel(
                  i2
                )) : (T(this._levels[i2].el), this._removeTilesAtZoom(i2), this._onRemoveLevel(i2), delete this._levels[i2]);
              var n2 = this._levels[t2], o2 = this._map;
              return n2 || ((n2 = this._levels[t2] = {}).el = P(
                "div",
                "leaflet-tile-container leaflet-zoom-animated",
                this._container
              ), n2.el.style.zIndex = e2, n2.origin = o2.project(o2.unproject(o2.getPixelOrigin()), t2).round(), n2.zoom = t2, this._setZoomTransform(n2, o2.getCenter(), o2.getZoom()), u(n2.el.offsetWidth), this._onCreateLevel(n2)), this._level = n2;
            }
          },
          _onUpdateLevel: u,
          _onRemoveLevel: u,
          _onCreateLevel: u,
          _pruneTiles: function() {
            if (this._map) {
              var t2, e2, i2, n2 = this._map.getZoom();
              if (n2 > this.options.maxZoom || n2 < this.options.minZoom)
                this._removeAllTiles();
              else {
                for (t2 in this._tiles)
                  (i2 = this._tiles[t2]).retain = i2.current;
                for (t2 in this._tiles)
                  (i2 = this._tiles[t2]).current && !i2.active && (e2 = i2.coords, this._retainParent(e2.x, e2.y, e2.z, e2.z - 5) || this._retainChildren(
                    e2.x,
                    e2.y,
                    e2.z,
                    e2.z + 2
                  ));
                for (t2 in this._tiles)
                  this._tiles[t2].retain || this._removeTile(t2);
              }
            }
          },
          _removeTilesAtZoom: function(t2) {
            for (var e2 in this._tiles)
              this._tiles[e2].coords.z === t2 && this._removeTile(e2);
          },
          _removeAllTiles: function() {
            for (var t2 in this._tiles)
              this._removeTile(t2);
          },
          _invalidateAll: function() {
            for (var t2 in this._levels)
              T(this._levels[t2].el), this._onRemoveLevel(Number(t2)), delete this._levels[t2];
            this._removeAllTiles(), this._tileZoom = void 0;
          },
          _retainParent: function(t2, e2, i2, n2) {
            var t2 = Math.floor(t2 / 2), e2 = Math.floor(e2 / 2), i2 = i2 - 1, o2 = new p(+t2, +e2), o2 = (o2.z = i2, this._tileCoordsToKey(o2)), o2 = this._tiles[o2];
            return o2 && o2.active ? o2.retain = true : (o2 && o2.loaded && (o2.retain = true), n2 < i2 && this._retainParent(t2, e2, i2, n2));
          },
          _retainChildren: function(t2, e2, i2, n2) {
            for (var o2 = 2 * t2; o2 < 2 * t2 + 2; o2++)
              for (var s2 = 2 * e2; s2 < 2 * e2 + 2; s2++) {
                var r2 = new p(o2, s2), r2 = (r2.z = i2 + 1, this._tileCoordsToKey(r2)), r2 = this._tiles[r2];
                r2 && r2.active ? r2.retain = true : (r2 && r2.loaded && (r2.retain = true), i2 + 1 < n2 && this._retainChildren(o2, s2, i2 + 1, n2));
              }
          },
          _resetView: function(t2) {
            t2 = t2 && (t2.pinch || t2.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), t2, t2);
          },
          _animateZoom: function(t2) {
            this._setView(t2.center, t2.zoom, true, t2.noUpdate);
          },
          _clampZoom: function(t2) {
            var e2 = this.options;
            return void 0 !== e2.minNativeZoom && t2 < e2.minNativeZoom ? e2.minNativeZoom : void 0 !== e2.maxNativeZoom && e2.maxNativeZoom < t2 ? e2.maxNativeZoom : t2;
          },
          _setView: function(t2, e2, i2, n2) {
            var o2 = Math.round(e2), o2 = void 0 !== this.options.maxZoom && o2 > this.options.maxZoom || void 0 !== this.options.minZoom && o2 < this.options.minZoom ? void 0 : this._clampZoom(o2), s2 = this.options.updateWhenZooming && o2 !== this._tileZoom;
            n2 && !s2 || (this._tileZoom = o2, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o2 && this._update(t2), i2 || this._pruneTiles(), this._noPrune = !!i2), this._setZoomTransforms(t2, e2);
          },
          _setZoomTransforms: function(t2, e2) {
            for (var i2 in this._levels)
              this._setZoomTransform(this._levels[i2], t2, e2);
          },
          _setZoomTransform: function(t2, e2, i2) {
            var n2 = this._map.getZoomScale(i2, t2.zoom), e2 = t2.origin.multiplyBy(n2).subtract(this._map._getNewPixelOrigin(e2, i2)).round();
            b.any3d ? be(t2.el, e2, n2) : Z(t2.el, e2);
          },
          _resetGrid: function() {
            var t2 = this._map, e2 = t2.options.crs, i2 = this._tileSize = this.getTileSize(), n2 = this._tileZoom, o2 = this._map.getPixelWorldBounds(this._tileZoom);
            o2 && (this._globalTileRange = this._pxBoundsToTileRange(o2)), this._wrapX = e2.wrapLng && !this.options.noWrap && [Math.floor(t2.project([0, e2.wrapLng[0]], n2).x / i2.x), Math.ceil(t2.project([0, e2.wrapLng[1]], n2).x / i2.y)], this._wrapY = e2.wrapLat && !this.options.noWrap && [Math.floor(t2.project([e2.wrapLat[0], 0], n2).y / i2.x), Math.ceil(t2.project([
              e2.wrapLat[1],
              0
            ], n2).y / i2.y)];
          },
          _onMoveEnd: function() {
            this._map && !this._map._animatingZoom && this._update();
          },
          _getTiledPixelBounds: function(t2) {
            var e2 = this._map, i2 = e2._animatingZoom ? Math.max(e2._animateToZoom, e2.getZoom()) : e2.getZoom(), i2 = e2.getZoomScale(i2, this._tileZoom), t2 = e2.project(t2, this._tileZoom).floor(), e2 = e2.getSize().divideBy(2 * i2);
            return new f(t2.subtract(e2), t2.add(e2));
          },
          _update: function(t2) {
            var e2 = this._map;
            if (e2) {
              var i2 = this._clampZoom(e2.getZoom());
              if (void 0 === t2 && (t2 = e2.getCenter()), void 0 !== this._tileZoom) {
                var n2, e2 = this._getTiledPixelBounds(t2), o2 = this._pxBoundsToTileRange(e2), s2 = o2.getCenter(), r2 = [], e2 = this.options.keepBuffer, a2 = new f(o2.getBottomLeft().subtract([e2, -e2]), o2.getTopRight().add([e2, -e2]));
                if (!(isFinite(o2.min.x) && isFinite(o2.min.y) && isFinite(o2.max.x) && isFinite(o2.max.y)))
                  throw new Error("Attempted to load an infinite number of tiles");
                for (n2 in this._tiles) {
                  var h2 = this._tiles[n2].coords;
                  h2.z === this._tileZoom && a2.contains(new p(h2.x, h2.y)) || (this._tiles[n2].current = false);
                }
                if (1 < Math.abs(i2 - this._tileZoom))
                  this._setView(t2, i2);
                else {
                  for (var l2 = o2.min.y; l2 <= o2.max.y; l2++)
                    for (var u2 = o2.min.x; u2 <= o2.max.x; u2++) {
                      var c2, d2 = new p(u2, l2);
                      d2.z = this._tileZoom, this._isValidTile(d2) && ((c2 = this._tiles[this._tileCoordsToKey(d2)]) ? c2.current = true : r2.push(d2));
                    }
                  if (r2.sort(function(t3, e3) {
                    return t3.distanceTo(s2) - e3.distanceTo(s2);
                  }), 0 !== r2.length) {
                    this._loading || (this._loading = true, this.fire("loading"));
                    for (var _2 = document.createDocumentFragment(), u2 = 0; u2 < r2.length; u2++)
                      this._addTile(r2[u2], _2);
                    this._level.el.appendChild(_2);
                  }
                }
              }
            }
          },
          _isValidTile: function(t2) {
            var e2 = this._map.options.crs;
            if (!e2.infinite) {
              var i2 = this._globalTileRange;
              if (!e2.wrapLng && (t2.x < i2.min.x || t2.x > i2.max.x) || !e2.wrapLat && (t2.y < i2.min.y || t2.y > i2.max.y))
                return false;
            }
            return !this.options.bounds || (e2 = this._tileCoordsToBounds(t2), g(this.options.bounds).overlaps(e2));
          },
          _keyToBounds: function(t2) {
            return this._tileCoordsToBounds(this._keyToTileCoords(t2));
          },
          _tileCoordsToNwSe: function(t2) {
            var e2 = this._map, i2 = this.getTileSize(), n2 = t2.scaleBy(i2), i2 = n2.add(i2);
            return [e2.unproject(n2, t2.z), e2.unproject(i2, t2.z)];
          },
          _tileCoordsToBounds: function(t2) {
            t2 = this._tileCoordsToNwSe(t2), t2 = new s(t2[0], t2[1]);
            return t2 = this.options.noWrap ? t2 : this._map.wrapLatLngBounds(t2);
          },
          _tileCoordsToKey: function(t2) {
            return t2.x + ":" + t2.y + ":" + t2.z;
          },
          _keyToTileCoords: function(t2) {
            var t2 = t2.split(":"), e2 = new p(+t2[0], +t2[1]);
            return e2.z = +t2[2], e2;
          },
          _removeTile: function(t2) {
            var e2 = this._tiles[t2];
            e2 && (T(e2.el), delete this._tiles[t2], this.fire("tileunload", {
              tile: e2.el,
              coords: this._keyToTileCoords(t2)
            }));
          },
          _initTile: function(t2) {
            M(t2, "leaflet-tile");
            var e2 = this.getTileSize();
            t2.style.width = e2.x + "px", t2.style.height = e2.y + "px", t2.onselectstart = u, t2.onmousemove = u, b.ielt9 && this.options.opacity < 1 && C(t2, this.options.opacity);
          },
          _addTile: function(t2, e2) {
            var i2 = this._getTilePos(t2), n2 = this._tileCoordsToKey(t2), o2 = this.createTile(this._wrapCoords(t2), a(this._tileReady, this, t2));
            this._initTile(o2), this.createTile.length < 2 && x(a(this._tileReady, this, t2, null, o2)), Z(
              o2,
              i2
            ), this._tiles[n2] = {
              el: o2,
              coords: t2,
              current: true
            }, e2.appendChild(o2), this.fire("tileloadstart", {
              tile: o2,
              coords: t2
            });
          },
          _tileReady: function(t2, e2, i2) {
            e2 && this.fire("tileerror", {
              error: e2,
              tile: i2,
              coords: t2
            });
            var n2 = this._tileCoordsToKey(t2);
            (i2 = this._tiles[n2]) && (i2.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (C(i2.el, 0), r(this._fadeFrame), this._fadeFrame = x(this._updateOpacity, this)) : (i2.active = true, this._pruneTiles()), e2 || (M(i2.el, "leaflet-tile-loaded"), this.fire("tileload", {
              tile: i2.el,
              coords: t2
            })), this._noTilesToLoad() && (this._loading = false, this.fire("load"), b.ielt9 || !this._map._fadeAnimated ? x(this._pruneTiles, this) : setTimeout(a(
              this._pruneTiles,
              this
            ), 250)));
          },
          _getTilePos: function(t2) {
            return t2.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(t2) {
            var e2 = new p(this._wrapX ? H(t2.x, this._wrapX) : t2.x, this._wrapY ? H(t2.y, this._wrapY) : t2.y);
            return e2.z = t2.z, e2;
          },
          _pxBoundsToTileRange: function(t2) {
            var e2 = this.getTileSize();
            return new f(t2.min.unscaleBy(e2).floor(), t2.max.unscaleBy(e2).ceil().subtract([1, 1]));
          },
          _noTilesToLoad: function() {
            for (var t2 in this._tiles)
              if (!this._tiles[t2].loaded)
                return false;
            return true;
          }
        });
        var Di = Ni.extend({
          options: {
            minZoom: 0,
            maxZoom: 18,
            subdomains: "abc",
            errorTileUrl: "",
            zoomOffset: 0,
            tms: false,
            zoomReverse: false,
            detectRetina: false,
            crossOrigin: false,
            referrerPolicy: false
          },
          initialize: function(t2, e2) {
            this._url = t2, (e2 = c(this, e2)).detectRetina && b.retina && 0 < e2.maxZoom ? (e2.tileSize = Math.floor(e2.tileSize / 2), e2.zoomReverse ? (e2.zoomOffset--, e2.minZoom = Math.min(e2.maxZoom, e2.minZoom + 1)) : (e2.zoomOffset++, e2.maxZoom = Math.max(e2.minZoom, e2.maxZoom - 1)), e2.minZoom = Math.max(0, e2.minZoom)) : e2.zoomReverse ? e2.minZoom = Math.min(e2.maxZoom, e2.minZoom) : e2.maxZoom = Math.max(e2.minZoom, e2.maxZoom), "string" == typeof e2.subdomains && (e2.subdomains = e2.subdomains.split("")), this.on(
              "tileunload",
              this._onTileRemove
            );
          },
          setUrl: function(t2, e2) {
            return this._url === t2 && void 0 === e2 && (e2 = true), this._url = t2, e2 || this.redraw(), this;
          },
          createTile: function(t2, e2) {
            var i2 = document.createElement("img");
            return S(i2, "load", a(this._tileOnLoad, this, e2, i2)), S(i2, "error", a(
              this._tileOnError,
              this,
              e2,
              i2
            )), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i2.crossOrigin = true === this.options.crossOrigin ? "" : this.options.crossOrigin), "string" == typeof this.options.referrerPolicy && (i2.referrerPolicy = this.options.referrerPolicy), i2.alt = "", i2.src = this.getTileUrl(t2), i2;
          },
          getTileUrl: function(t2) {
            var e2 = {
              r: b.retina ? "@2x" : "",
              s: this._getSubdomain(t2),
              x: t2.x,
              y: t2.y,
              z: this._getZoomForUrl()
            };
            return this._map && !this._map.options.crs.infinite && (t2 = this._globalTileRange.max.y - t2.y, this.options.tms && (e2.y = t2), e2["-y"] = t2), q(this._url, l(e2, this.options));
          },
          _tileOnLoad: function(t2, e2) {
            b.ielt9 ? setTimeout(a(t2, this, null, e2), 0) : t2(null, e2);
          },
          _tileOnError: function(t2, e2, i2) {
            var n2 = this.options.errorTileUrl;
            n2 && e2.getAttribute("src") !== n2 && (e2.src = n2), t2(i2, e2);
          },
          _onTileRemove: function(t2) {
            t2.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var t2 = this._tileZoom, e2 = this.options.maxZoom;
            return (t2 = this.options.zoomReverse ? e2 - t2 : t2) + this.options.zoomOffset;
          },
          _getSubdomain: function(t2) {
            t2 = Math.abs(t2.x + t2.y) % this.options.subdomains.length;
            return this.options.subdomains[t2];
          },
          _abortLoading: function() {
            var t2, e2, i2;
            for (t2 in this._tiles)
              this._tiles[t2].coords.z !== this._tileZoom && ((i2 = this._tiles[t2].el).onload = u, i2.onerror = u, i2.complete || (i2.src = K, e2 = this._tiles[t2].coords, T(i2), delete this._tiles[t2], this.fire("tileabort", {
                tile: i2,
                coords: e2
              })));
          },
          _removeTile: function(t2) {
            var e2 = this._tiles[t2];
            if (e2)
              return e2.el.setAttribute("src", K), Ni.prototype._removeTile.call(this, t2);
          },
          _tileReady: function(t2, e2, i2) {
            if (this._map && (!i2 || i2.getAttribute("src") !== K))
              return Ni.prototype._tileReady.call(
                this,
                t2,
                e2,
                i2
              );
          }
        });
        function ji(t2, e2) {
          return new Di(t2, e2);
        }
        var Hi = Di.extend({
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: false,
            version: "1.1.1"
          },
          options: {
            crs: null,
            uppercase: false
          },
          initialize: function(t2, e2) {
            this._url = t2;
            var i2, n2 = l({}, this.defaultWmsParams);
            for (i2 in e2)
              i2 in this.options || (n2[i2] = e2[i2]);
            var t2 = (e2 = c(this, e2)).detectRetina && b.retina ? 2 : 1, o2 = this.getTileSize();
            n2.width = o2.x * t2, n2.height = o2.y * t2, this.wmsParams = n2;
          },
          onAdd: function(t2) {
            this._crs = this.options.crs || t2.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
            var e2 = 1.3 <= this._wmsVersion ? "crs" : "srs";
            this.wmsParams[e2] = this._crs.code, Di.prototype.onAdd.call(this, t2);
          },
          getTileUrl: function(t2) {
            var e2 = this._tileCoordsToNwSe(t2), i2 = this._crs, i2 = _(i2.project(e2[0]), i2.project(e2[1])), e2 = i2.min, i2 = i2.max, e2 = (1.3 <= this._wmsVersion && this._crs === li ? [e2.y, e2.x, i2.y, i2.x] : [
              e2.x,
              e2.y,
              i2.x,
              i2.y
            ]).join(","), i2 = Di.prototype.getTileUrl.call(this, t2);
            return i2 + U(this.wmsParams, i2, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + e2;
          },
          setParams: function(t2, e2) {
            return l(this.wmsParams, t2), e2 || this.redraw(), this;
          }
        });
        Di.WMS = Hi, ji.wms = function(t2, e2) {
          return new Hi(t2, e2);
        };
        var Wi = o.extend({
          options: {
            padding: 0.1
          },
          initialize: function(t2) {
            c(this, t2), h(this), this._layers = this._layers || {};
          },
          onAdd: function() {
            this._container || (this._initContainer(), M(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this), this._destroyContainer();
          },
          getEvents: function() {
            var t2 = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            return this._zoomAnimated && (t2.zoomanim = this._onAnimZoom), t2;
          },
          _onAnimZoom: function(t2) {
            this._updateTransform(t2.center, t2.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(t2, e2) {
            var i2 = this._map.getZoomScale(e2, this._zoom), n2 = this._map.getSize().multiplyBy(0.5 + this.options.padding), o2 = this._map.project(this._center, e2), n2 = n2.multiplyBy(-i2).add(o2).subtract(this._map._getNewPixelOrigin(t2, e2));
            b.any3d ? be(this._container, n2, i2) : Z(this._container, n2);
          },
          _reset: function() {
            for (var t2 in this._update(), this._updateTransform(this._center, this._zoom), this._layers)
              this._layers[t2]._reset();
          },
          _onZoomEnd: function() {
            for (var t2 in this._layers)
              this._layers[t2]._project();
          },
          _updatePaths: function() {
            for (var t2 in this._layers)
              this._layers[t2]._update();
          },
          _update: function() {
            var t2 = this.options.padding, e2 = this._map.getSize(), i2 = this._map.containerPointToLayerPoint(e2.multiplyBy(-t2)).round();
            this._bounds = new f(i2, i2.add(e2.multiplyBy(1 + 2 * t2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
          }
        }), Fi = Wi.extend({
          options: {
            tolerance: 0
          },
          getEvents: function() {
            var t2 = Wi.prototype.getEvents.call(this);
            return t2.viewprereset = this._onViewPreReset, t2;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Wi.prototype.onAdd.call(this), this._draw();
          },
          _initContainer: function() {
            var t2 = this._container = document.createElement("canvas");
            S(t2, "mousemove", this._onMouseMove, this), S(
              t2,
              "click dblclick mousedown mouseup contextmenu",
              this._onClick,
              this
            ), S(
              t2,
              "mouseout",
              this._handleMouseOut,
              this
            ), t2._leaflet_disable_events = true, this._ctx = t2.getContext("2d");
          },
          _destroyContainer: function() {
            r(this._redrawRequest), delete this._ctx, T(this._container), k(this._container), delete this._container;
          },
          _updatePaths: function() {
            if (!this._postponeUpdatePaths) {
              for (var t2 in this._redrawBounds = null, this._layers)
                this._layers[t2]._update();
              this._redraw();
            }
          },
          _update: function() {
            var t2, e2, i2, n2;
            this._map._animatingZoom && this._bounds || (Wi.prototype._update.call(this), t2 = this._bounds, e2 = this._container, i2 = t2.getSize(), n2 = b.retina ? 2 : 1, Z(e2, t2.min), e2.width = n2 * i2.x, e2.height = n2 * i2.y, e2.style.width = i2.x + "px", e2.style.height = i2.y + "px", b.retina && this._ctx.scale(2, 2), this._ctx.translate(-t2.min.x, -t2.min.y), this.fire("update"));
          },
          _reset: function() {
            Wi.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = false, this._updatePaths());
          },
          _initPath: function(t2) {
            this._updateDashArray(t2);
            t2 = (this._layers[h(t2)] = t2)._order = {
              layer: t2,
              prev: this._drawLast,
              next: null
            };
            this._drawLast && (this._drawLast.next = t2), this._drawLast = t2, this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(t2) {
            this._requestRedraw(t2);
          },
          _removePath: function(t2) {
            var e2 = t2._order, i2 = e2.next, e2 = e2.prev;
            i2 ? i2.prev = e2 : this._drawLast = e2, e2 ? e2.next = i2 : this._drawFirst = i2, delete t2._order, delete this._layers[h(t2)], this._requestRedraw(t2);
          },
          _updatePath: function(t2) {
            this._extendRedrawBounds(t2), t2._project(), t2._update(), this._requestRedraw(t2);
          },
          _updateStyle: function(t2) {
            this._updateDashArray(t2), this._requestRedraw(t2);
          },
          _updateDashArray: function(t2) {
            if ("string" == typeof t2.options.dashArray) {
              for (var e2, i2 = t2.options.dashArray.split(/[, ]+/), n2 = [], o2 = 0; o2 < i2.length; o2++) {
                if (e2 = Number(i2[o2]), isNaN(e2))
                  return;
                n2.push(e2);
              }
              t2.options._dashArray = n2;
            } else
              t2.options._dashArray = t2.options.dashArray;
          },
          _requestRedraw: function(t2) {
            this._map && (this._extendRedrawBounds(t2), this._redrawRequest = this._redrawRequest || x(
              this._redraw,
              this
            ));
          },
          _extendRedrawBounds: function(t2) {
            var e2;
            t2._pxBounds && (e2 = (t2.options.weight || 0) + 1, this._redrawBounds = this._redrawBounds || new f(), this._redrawBounds.extend(t2._pxBounds.min.subtract([e2, e2])), this._redrawBounds.extend(t2._pxBounds.max.add([e2, e2])));
          },
          _redraw: function() {
            this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
          },
          _clear: function() {
            var t2, e2 = this._redrawBounds;
            e2 ? (t2 = e2.getSize(), this._ctx.clearRect(e2.min.x, e2.min.y, t2.x, t2.y)) : (this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore());
          },
          _draw: function() {
            var t2, e2, i2 = this._redrawBounds;
            this._ctx.save(), i2 && (e2 = i2.getSize(), this._ctx.beginPath(), this._ctx.rect(i2.min.x, i2.min.y, e2.x, e2.y), this._ctx.clip()), this._drawing = true;
            for (var n2 = this._drawFirst; n2; n2 = n2.next)
              t2 = n2.layer, (!i2 || t2._pxBounds && t2._pxBounds.intersects(i2)) && t2._updatePath();
            this._drawing = false, this._ctx.restore();
          },
          _updatePoly: function(t2, e2) {
            if (this._drawing) {
              var i2, n2, o2, s2, r2 = t2._parts, a2 = r2.length, h2 = this._ctx;
              if (a2) {
                for (h2.beginPath(), i2 = 0; i2 < a2; i2++) {
                  for (n2 = 0, o2 = r2[i2].length; n2 < o2; n2++)
                    s2 = r2[i2][n2], h2[n2 ? "lineTo" : "moveTo"](s2.x, s2.y);
                  e2 && h2.closePath();
                }
                this._fillStroke(h2, t2);
              }
            }
          },
          _updateCircle: function(t2) {
            var e2, i2, n2, o2;
            this._drawing && !t2._empty() && (e2 = t2._point, i2 = this._ctx, n2 = Math.max(Math.round(t2._radius), 1), 1 != (o2 = (Math.max(Math.round(t2._radiusY), 1) || n2) / n2) && (i2.save(), i2.scale(1, o2)), i2.beginPath(), i2.arc(e2.x, e2.y / o2, n2, 0, 2 * Math.PI, false), 1 != o2 && i2.restore(), this._fillStroke(i2, t2));
          },
          _fillStroke: function(t2, e2) {
            var i2 = e2.options;
            i2.fill && (t2.globalAlpha = i2.fillOpacity, t2.fillStyle = i2.fillColor || i2.color, t2.fill(i2.fillRule || "evenodd")), i2.stroke && 0 !== i2.weight && (t2.setLineDash && t2.setLineDash(e2.options && e2.options._dashArray || []), t2.globalAlpha = i2.opacity, t2.lineWidth = i2.weight, t2.strokeStyle = i2.color, t2.lineCap = i2.lineCap, t2.lineJoin = i2.lineJoin, t2.stroke());
          },
          _onClick: function(t2) {
            for (var e2, i2, n2 = this._map.mouseEventToLayerPoint(t2), o2 = this._drawFirst; o2; o2 = o2.next)
              (e2 = o2.layer).options.interactive && e2._containsPoint(n2) && (("click" === t2.type || "preclick" === t2.type) && this._map._draggableMoved(e2) || (i2 = e2));
            this._fireEvent(!!i2 && [i2], t2);
          },
          _onMouseMove: function(t2) {
            var e2;
            !this._map || this._map.dragging.moving() || this._map._animatingZoom || (e2 = this._map.mouseEventToLayerPoint(t2), this._handleMouseHover(t2, e2));
          },
          _handleMouseOut: function(t2) {
            var e2 = this._hoveredLayer;
            e2 && (z(this._container, "leaflet-interactive"), this._fireEvent([e2], t2, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = false);
          },
          _handleMouseHover: function(t2, e2) {
            if (!this._mouseHoverThrottled) {
              for (var i2, n2, o2 = this._drawFirst; o2; o2 = o2.next)
                (i2 = o2.layer).options.interactive && i2._containsPoint(e2) && (n2 = i2);
              n2 !== this._hoveredLayer && (this._handleMouseOut(t2), n2 && (M(
                this._container,
                "leaflet-interactive"
              ), this._fireEvent([n2], t2, "mouseover"), this._hoveredLayer = n2)), this._fireEvent(!!this._hoveredLayer && [
                this._hoveredLayer
              ], t2), this._mouseHoverThrottled = true, setTimeout(a(function() {
                this._mouseHoverThrottled = false;
              }, this), 32);
            }
          },
          _fireEvent: function(t2, e2, i2) {
            this._map._fireDOMEvent(e2, i2 || e2.type, t2);
          },
          _bringToFront: function(t2) {
            var e2, i2, n2 = t2._order;
            n2 && (e2 = n2.next, i2 = n2.prev, e2 && ((e2.prev = i2) ? i2.next = e2 : e2 && (this._drawFirst = e2), n2.prev = this._drawLast, (this._drawLast.next = n2).next = null, this._drawLast = n2, this._requestRedraw(t2)));
          },
          _bringToBack: function(t2) {
            var e2, i2, n2 = t2._order;
            n2 && (e2 = n2.next, (i2 = n2.prev) && ((i2.next = e2) ? e2.prev = i2 : i2 && (this._drawLast = i2), n2.prev = null, n2.next = this._drawFirst, this._drawFirst.prev = n2, this._drawFirst = n2, this._requestRedraw(t2)));
          }
        });
        function Ui(t2) {
          return b.canvas ? new Fi(t2) : null;
        }
        var Vi = function() {
          try {
            return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(t2) {
              return document.createElement("<lvml:" + t2 + ' class="lvml">');
            };
          } catch (t2) {
          }
          return function(t2) {
            return document.createElement("<" + t2 + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
          };
        }(), zt = {
          _initContainer: function() {
            this._container = P("div", "leaflet-vml-container");
          },
          _update: function() {
            this._map._animatingZoom || (Wi.prototype._update.call(this), this.fire("update"));
          },
          _initPath: function(t2) {
            var e2 = t2._container = Vi("shape");
            M(e2, "leaflet-vml-shape " + (this.options.className || "")), e2.coordsize = "1 1", t2._path = Vi(
              "path"
            ), e2.appendChild(t2._path), this._updateStyle(t2), this._layers[h(t2)] = t2;
          },
          _addPath: function(t2) {
            var e2 = t2._container;
            this._container.appendChild(e2), t2.options.interactive && t2.addInteractiveTarget(e2);
          },
          _removePath: function(t2) {
            var e2 = t2._container;
            T(e2), t2.removeInteractiveTarget(e2), delete this._layers[h(t2)];
          },
          _updateStyle: function(t2) {
            var e2 = t2._stroke, i2 = t2._fill, n2 = t2.options, o2 = t2._container;
            o2.stroked = !!n2.stroke, o2.filled = !!n2.fill, n2.stroke ? (e2 = e2 || (t2._stroke = Vi("stroke")), o2.appendChild(e2), e2.weight = n2.weight + "px", e2.color = n2.color, e2.opacity = n2.opacity, n2.dashArray ? e2.dashStyle = d(n2.dashArray) ? n2.dashArray.join(" ") : n2.dashArray.replace(
              /( *, *)/g,
              " "
            ) : e2.dashStyle = "", e2.endcap = n2.lineCap.replace("butt", "flat"), e2.joinstyle = n2.lineJoin) : e2 && (o2.removeChild(e2), t2._stroke = null), n2.fill ? (i2 = i2 || (t2._fill = Vi("fill")), o2.appendChild(i2), i2.color = n2.fillColor || n2.color, i2.opacity = n2.fillOpacity) : i2 && (o2.removeChild(i2), t2._fill = null);
          },
          _updateCircle: function(t2) {
            var e2 = t2._point.round(), i2 = Math.round(t2._radius), n2 = Math.round(t2._radiusY || i2);
            this._setPath(t2, t2._empty() ? "M0 0" : "AL " + e2.x + "," + e2.y + " " + i2 + "," + n2 + " 0,23592600");
          },
          _setPath: function(t2, e2) {
            t2._path.v = e2;
          },
          _bringToFront: function(t2) {
            fe(t2._container);
          },
          _bringToBack: function(t2) {
            ge(t2._container);
          }
        }, qi = b.vml ? Vi : ct, Gi = Wi.extend({
          _initContainer: function() {
            this._container = qi("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = qi("g"), this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            T(this._container), k(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
          },
          _update: function() {
            var t2, e2, i2;
            this._map._animatingZoom && this._bounds || (Wi.prototype._update.call(this), e2 = (t2 = this._bounds).getSize(), i2 = this._container, this._svgSize && this._svgSize.equals(
              e2
            ) || (this._svgSize = e2, i2.setAttribute("width", e2.x), i2.setAttribute(
              "height",
              e2.y
            )), Z(i2, t2.min), i2.setAttribute("viewBox", [t2.min.x, t2.min.y, e2.x, e2.y].join(
              " "
            )), this.fire("update"));
          },
          _initPath: function(t2) {
            var e2 = t2._path = qi("path");
            t2.options.className && M(e2, t2.options.className), t2.options.interactive && M(
              e2,
              "leaflet-interactive"
            ), this._updateStyle(t2), this._layers[h(t2)] = t2;
          },
          _addPath: function(t2) {
            this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t2._path), t2.addInteractiveTarget(t2._path);
          },
          _removePath: function(t2) {
            T(t2._path), t2.removeInteractiveTarget(t2._path), delete this._layers[h(t2)];
          },
          _updatePath: function(t2) {
            t2._project(), t2._update();
          },
          _updateStyle: function(t2) {
            var e2 = t2._path, t2 = t2.options;
            e2 && (t2.stroke ? (e2.setAttribute("stroke", t2.color), e2.setAttribute("stroke-opacity", t2.opacity), e2.setAttribute("stroke-width", t2.weight), e2.setAttribute(
              "stroke-linecap",
              t2.lineCap
            ), e2.setAttribute("stroke-linejoin", t2.lineJoin), t2.dashArray ? e2.setAttribute("stroke-dasharray", t2.dashArray) : e2.removeAttribute("stroke-dasharray"), t2.dashOffset ? e2.setAttribute(
              "stroke-dashoffset",
              t2.dashOffset
            ) : e2.removeAttribute("stroke-dashoffset")) : e2.setAttribute("stroke", "none"), t2.fill ? (e2.setAttribute("fill", t2.fillColor || t2.color), e2.setAttribute("fill-opacity", t2.fillOpacity), e2.setAttribute("fill-rule", t2.fillRule || "evenodd")) : e2.setAttribute(
              "fill",
              "none"
            ));
          },
          _updatePoly: function(t2, e2) {
            this._setPath(t2, dt(t2._parts, e2));
          },
          _updateCircle: function(t2) {
            var e2 = t2._point, i2 = Math.max(Math.round(t2._radius), 1), n2 = "a" + i2 + "," + (Math.max(Math.round(t2._radiusY), 1) || i2) + " 0 1,0 ", e2 = t2._empty() ? "M0 0" : "M" + (e2.x - i2) + "," + e2.y + n2 + 2 * i2 + ",0 " + n2 + 2 * -i2 + ",0 ";
            this._setPath(t2, e2);
          },
          _setPath: function(t2, e2) {
            t2._path.setAttribute("d", e2);
          },
          _bringToFront: function(t2) {
            fe(t2._path);
          },
          _bringToBack: function(t2) {
            ge(t2._path);
          }
        });
        function Ki(t2) {
          return b.svg || b.vml ? new Gi(t2) : null;
        }
        b.vml && Gi.include(zt), A.include({
          getRenderer: function(t2) {
            t2 = (t2 = t2.options.renderer || this._getPaneRenderer(t2.options.pane) || this.options.renderer || this._renderer) || (this._renderer = this._createRenderer());
            return this.hasLayer(t2) || this.addLayer(t2), t2;
          },
          _getPaneRenderer: function(t2) {
            var e2;
            return "overlayPane" !== t2 && void 0 !== t2 && (void 0 === (e2 = this._paneRenderers[t2]) && (e2 = this._createRenderer({
              pane: t2
            }), this._paneRenderers[t2] = e2), e2);
          },
          _createRenderer: function(t2) {
            return this.options.preferCanvas && Ui(t2) || Ki(t2);
          }
        });
        var Yi = xi.extend({
          initialize: function(t2, e2) {
            xi.prototype.initialize.call(this, this._boundsToLatLngs(t2), e2);
          },
          setBounds: function(t2) {
            return this.setLatLngs(this._boundsToLatLngs(t2));
          },
          _boundsToLatLngs: function(t2) {
            return [(t2 = g(t2)).getSouthWest(), t2.getNorthWest(), t2.getNorthEast(), t2.getSouthEast()];
          }
        });
        Gi.create = qi, Gi.pointsToPath = dt, wi.geometryToLayer = bi, wi.coordsToLatLng = Li, wi.coordsToLatLngs = Ti, wi.latLngToCoords = Mi, wi.latLngsToCoords = zi, wi.getFeature = Ci, wi.asFeature = Zi, A.mergeOptions({
          boxZoom: true
        });
        var _t = n.extend({
          initialize: function(t2) {
            this._map = t2, this._container = t2._container, this._pane = t2._panes.overlayPane, this._resetStateTimeout = 0, t2.on("unload", this._destroy, this);
          },
          addHooks: function() {
            S(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            k(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            T(this._pane), delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0, this._moved = false;
          },
          _clearDeferredResetState: function() {
            0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
          },
          _onMouseDown: function(t2) {
            if (!t2.shiftKey || 1 !== t2.which && 1 !== t2.button)
              return false;
            this._clearDeferredResetState(), this._resetState(), re(), Le(), this._startPoint = this._map.mouseEventToContainerPoint(t2), S(document, {
              contextmenu: Re,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(t2) {
            this._moved || (this._moved = true, this._box = P("div", "leaflet-zoom-box", this._container), M(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t2);
            var t2 = new f(this._point, this._startPoint), e2 = t2.getSize();
            Z(this._box, t2.min), this._box.style.width = e2.x + "px", this._box.style.height = e2.y + "px";
          },
          _finish: function() {
            this._moved && (T(this._box), z(this._container, "leaflet-crosshair")), ae(), Te(), k(
              document,
              {
                contextmenu: Re,
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp,
                keydown: this._onKeyDown
              },
              this
            );
          },
          _onMouseUp: function(t2) {
            1 !== t2.which && 1 !== t2.button || (this._finish(), this._moved && (this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(a(this._resetState, this), 0), t2 = new s(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point)), this._map.fitBounds(t2).fire("boxzoomend", {
              boxZoomBounds: t2
            })));
          },
          _onKeyDown: function(t2) {
            27 === t2.keyCode && (this._finish(), this._clearDeferredResetState(), this._resetState());
          }
        }), Ct = (A.addInitHook("addHandler", "boxZoom", _t), A.mergeOptions({
          doubleClickZoom: true
        }), n.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(t2) {
            var e2 = this._map, i2 = e2.getZoom(), n2 = e2.options.zoomDelta, i2 = t2.originalEvent.shiftKey ? i2 - n2 : i2 + n2;
            "center" === e2.options.doubleClickZoom ? e2.setZoom(i2) : e2.setZoomAround(t2.containerPoint, i2);
          }
        })), Zt = (A.addInitHook("addHandler", "doubleClickZoom", Ct), A.mergeOptions({
          dragging: true,
          inertia: true,
          inertiaDeceleration: 3400,
          inertiaMaxSpeed: 1 / 0,
          easeLinearity: 0.2,
          worldCopyJump: false,
          maxBoundsViscosity: 0
        }), n.extend({
          addHooks: function() {
            var t2;
            this._draggable || (t2 = this._map, this._draggable = new Xe(t2._mapPane, t2._container), this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t2.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t2.on("zoomend", this._onZoomEnd, this), t2.whenReady(this._onZoomEnd, this))), M(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
          },
          removeHooks: function() {
            z(this._map._container, "leaflet-grab"), z(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var t2, e2 = this._map;
            e2._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity ? (t2 = g(
              this._map.options.maxBounds
            ), this._offsetLimit = _(this._map.latLngToContainerPoint(t2.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(t2.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))) : this._offsetLimit = null, e2.fire("movestart").fire("dragstart"), e2.options.inertia && (this._positions = [], this._times = []);
          },
          _onDrag: function(t2) {
            var e2, i2;
            this._map.options.inertia && (e2 = this._lastTime = +/* @__PURE__ */ new Date(), i2 = this._lastPos = this._draggable._absPos || this._draggable._newPos, this._positions.push(i2), this._times.push(e2), this._prunePositions(e2)), this._map.fire("move", t2).fire(
              "drag",
              t2
            );
          },
          _prunePositions: function(t2) {
            for (; 1 < this._positions.length && 50 < t2 - this._times[0]; )
              this._positions.shift(), this._times.shift();
          },
          _onZoomEnd: function() {
            var t2 = this._map.getSize().divideBy(2), e2 = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = e2.subtract(t2).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(t2, e2) {
            return t2 - (t2 - e2) * this._viscosity;
          },
          _onPreDragLimit: function() {
            var t2, e2;
            this._viscosity && this._offsetLimit && (t2 = this._draggable._newPos.subtract(this._draggable._startPos), e2 = this._offsetLimit, t2.x < e2.min.x && (t2.x = this._viscousLimit(t2.x, e2.min.x)), t2.y < e2.min.y && (t2.y = this._viscousLimit(t2.y, e2.min.y)), t2.x > e2.max.x && (t2.x = this._viscousLimit(t2.x, e2.max.x)), t2.y > e2.max.y && (t2.y = this._viscousLimit(t2.y, e2.max.y)), this._draggable._newPos = this._draggable._startPos.add(t2));
          },
          _onPreDragWrap: function() {
            var t2 = this._worldWidth, e2 = Math.round(t2 / 2), i2 = this._initialWorldOffset, n2 = this._draggable._newPos.x, o2 = (n2 - e2 + i2) % t2 + e2 - i2, n2 = (n2 + e2 + i2) % t2 - e2 - i2, t2 = Math.abs(o2 + i2) < Math.abs(n2 + i2) ? o2 : n2;
            this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = t2;
          },
          _onDragEnd: function(t2) {
            var e2, i2, n2, o2, s2 = this._map, r2 = s2.options, a2 = !r2.inertia || t2.noInertia || this._times.length < 2;
            s2.fire("dragend", t2), !a2 && (this._prunePositions(+/* @__PURE__ */ new Date()), t2 = this._lastPos.subtract(this._positions[0]), a2 = (this._lastTime - this._times[0]) / 1e3, e2 = r2.easeLinearity, a2 = (t2 = t2.multiplyBy(e2 / a2)).distanceTo([0, 0]), i2 = Math.min(
              r2.inertiaMaxSpeed,
              a2
            ), t2 = t2.multiplyBy(i2 / a2), n2 = i2 / (r2.inertiaDeceleration * e2), (o2 = t2.multiplyBy(-n2 / 2).round()).x || o2.y) ? (o2 = s2._limitOffset(o2, s2.options.maxBounds), x(function() {
              s2.panBy(o2, {
                duration: n2,
                easeLinearity: e2,
                noMoveStart: true,
                animate: true
              });
            })) : s2.fire("moveend");
          }
        })), St = (A.addInitHook("addHandler", "dragging", Zt), A.mergeOptions({
          keyboard: true,
          keyboardPanDelta: 80
        }), n.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(t2) {
            this._map = t2, this._setPanDelta(t2.options.keyboardPanDelta), this._setZoomDelta(t2.options.zoomDelta);
          },
          addHooks: function() {
            var t2 = this._map._container;
            t2.tabIndex <= 0 && (t2.tabIndex = "0"), S(t2, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this), this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks(), k(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this), this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            var t2, e2, i2;
            this._focused || (i2 = document.body, t2 = document.documentElement, e2 = i2.scrollTop || t2.scrollTop, i2 = i2.scrollLeft || t2.scrollLeft, this._map._container.focus(), window.scrollTo(i2, e2));
          },
          _onFocus: function() {
            this._focused = true, this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false, this._map.fire("blur");
          },
          _setPanDelta: function(t2) {
            for (var e2 = this._panKeys = {}, i2 = this.keyCodes, n2 = 0, o2 = i2.left.length; n2 < o2; n2++)
              e2[i2.left[n2]] = [-1 * t2, 0];
            for (n2 = 0, o2 = i2.right.length; n2 < o2; n2++)
              e2[i2.right[n2]] = [t2, 0];
            for (n2 = 0, o2 = i2.down.length; n2 < o2; n2++)
              e2[i2.down[n2]] = [0, t2];
            for (n2 = 0, o2 = i2.up.length; n2 < o2; n2++)
              e2[i2.up[n2]] = [0, -1 * t2];
          },
          _setZoomDelta: function(t2) {
            for (var e2 = this._zoomKeys = {}, i2 = this.keyCodes, n2 = 0, o2 = i2.zoomIn.length; n2 < o2; n2++)
              e2[i2.zoomIn[n2]] = t2;
            for (n2 = 0, o2 = i2.zoomOut.length; n2 < o2; n2++)
              e2[i2.zoomOut[n2]] = -t2;
          },
          _addHooks: function() {
            S(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            k(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(t2) {
            if (!(t2.altKey || t2.ctrlKey || t2.metaKey)) {
              var e2, i2, n2 = t2.keyCode, o2 = this._map;
              if (n2 in this._panKeys)
                o2._panAnim && o2._panAnim._inProgress || (i2 = this._panKeys[n2], t2.shiftKey && (i2 = m(i2).multiplyBy(3)), o2.options.maxBounds && (i2 = o2._limitOffset(m(i2), o2.options.maxBounds)), o2.options.worldCopyJump ? (e2 = o2.wrapLatLng(o2.unproject(o2.project(o2.getCenter()).add(i2))), o2.panTo(
                  e2
                )) : o2.panBy(i2));
              else if (n2 in this._zoomKeys)
                o2.setZoom(o2.getZoom() + (t2.shiftKey ? 3 : 1) * this._zoomKeys[n2]);
              else {
                if (27 !== n2 || !o2._popup || !o2._popup.options.closeOnEscapeKey)
                  return;
                o2.closePopup();
              }
              Re(t2);
            }
          }
        })), Et = (A.addInitHook("addHandler", "keyboard", St), A.mergeOptions({
          scrollWheelZoom: true,
          wheelDebounceTime: 40,
          wheelPxPerZoomLevel: 60
        }), n.extend({
          addHooks: function() {
            S(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
          },
          removeHooks: function() {
            k(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(t2) {
            var e2 = He(t2), i2 = this._map.options.wheelDebounceTime, e2 = (this._delta += e2, this._lastMousePos = this._map.mouseEventToContainerPoint(t2), this._startTime || (this._startTime = +/* @__PURE__ */ new Date()), Math.max(i2 - (+/* @__PURE__ */ new Date() - this._startTime), 0));
            clearTimeout(this._timer), this._timer = setTimeout(a(this._performZoom, this), e2), Re(
              t2
            );
          },
          _performZoom: function() {
            var t2 = this._map, e2 = t2.getZoom(), i2 = this._map.options.zoomSnap || 0, n2 = (t2._stop(), this._delta / (4 * this._map.options.wheelPxPerZoomLevel)), n2 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n2)))) / Math.LN2, i2 = i2 ? Math.ceil(n2 / i2) * i2 : n2, n2 = t2._limitZoom(e2 + (0 < this._delta ? i2 : -i2)) - e2;
            this._delta = 0, this._startTime = null, n2 && ("center" === t2.options.scrollWheelZoom ? t2.setZoom(e2 + n2) : t2.setZoomAround(this._lastMousePos, e2 + n2));
          }
        })), kt = (A.addInitHook("addHandler", "scrollWheelZoom", Et), A.mergeOptions({
          tapHold: b.touchNative && b.safari && b.mobile,
          tapTolerance: 15
        }), n.extend({
          addHooks: function() {
            S(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            k(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(t2) {
            var e2;
            clearTimeout(this._holdTimeout), 1 === t2.touches.length && (e2 = t2.touches[0], this._startPos = this._newPos = new p(e2.clientX, e2.clientY), this._holdTimeout = setTimeout(a(function() {
              this._cancel(), this._isTapValid() && (S(document, "touchend", O), S(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent(
                "contextmenu",
                e2
              ));
            }, this), 600), S(
              document,
              "touchend touchcancel contextmenu",
              this._cancel,
              this
            ), S(document, "touchmove", this._onMove, this));
          },
          _cancelClickPrevent: function t2() {
            k(document, "touchend", O), k(document, "touchend touchcancel", t2);
          },
          _cancel: function() {
            clearTimeout(this._holdTimeout), k(document, "touchend touchcancel contextmenu", this._cancel, this), k(document, "touchmove", this._onMove, this);
          },
          _onMove: function(t2) {
            t2 = t2.touches[0];
            this._newPos = new p(t2.clientX, t2.clientY);
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _simulateEvent: function(t2, e2) {
            t2 = new MouseEvent(t2, {
              bubbles: true,
              cancelable: true,
              view: window,
              screenX: e2.screenX,
              screenY: e2.screenY,
              clientX: e2.clientX,
              clientY: e2.clientY
            });
            t2._simulated = true, e2.target.dispatchEvent(t2);
          }
        })), Ot = (A.addInitHook("addHandler", "tapHold", kt), A.mergeOptions({
          touchZoom: b.touch,
          bounceAtZoomLimits: true
        }), n.extend({
          addHooks: function() {
            M(this._map._container, "leaflet-touch-zoom"), S(
              this._map._container,
              "touchstart",
              this._onTouchStart,
              this
            );
          },
          removeHooks: function() {
            z(this._map._container, "leaflet-touch-zoom"), k(
              this._map._container,
              "touchstart",
              this._onTouchStart,
              this
            );
          },
          _onTouchStart: function(t2) {
            var e2, i2, n2 = this._map;
            !t2.touches || 2 !== t2.touches.length || n2._animatingZoom || this._zooming || (e2 = n2.mouseEventToContainerPoint(t2.touches[0]), i2 = n2.mouseEventToContainerPoint(t2.touches[1]), this._centerPoint = n2.getSize()._divideBy(2), this._startLatLng = n2.containerPointToLatLng(this._centerPoint), "center" !== n2.options.touchZoom && (this._pinchStartLatLng = n2.containerPointToLatLng(e2.add(
              i2
            )._divideBy(2))), this._startDist = e2.distanceTo(i2), this._startZoom = n2.getZoom(), this._moved = false, this._zooming = true, n2._stop(), S(
              document,
              "touchmove",
              this._onTouchMove,
              this
            ), S(
              document,
              "touchend touchcancel",
              this._onTouchEnd,
              this
            ), O(t2));
          },
          _onTouchMove: function(t2) {
            if (t2.touches && 2 === t2.touches.length && this._zooming) {
              var e2 = this._map, i2 = e2.mouseEventToContainerPoint(t2.touches[0]), n2 = e2.mouseEventToContainerPoint(t2.touches[1]), o2 = i2.distanceTo(n2) / this._startDist;
              if (this._zoom = e2.getScaleZoom(o2, this._startZoom), !e2.options.bounceAtZoomLimits && (this._zoom < e2.getMinZoom() && o2 < 1 || this._zoom > e2.getMaxZoom() && 1 < o2) && (this._zoom = e2._limitZoom(this._zoom)), "center" === e2.options.touchZoom) {
                if (this._center = this._startLatLng, 1 == o2)
                  return;
              } else {
                i2 = i2._add(n2)._divideBy(2)._subtract(this._centerPoint);
                if (1 == o2 && 0 === i2.x && 0 === i2.y)
                  return;
                this._center = e2.unproject(e2.project(this._pinchStartLatLng, this._zoom).subtract(i2), this._zoom);
              }
              this._moved || (e2._moveStart(true, false), this._moved = true), r(this._animRequest);
              n2 = a(e2._move, e2, this._center, this._zoom, {
                pinch: true,
                round: false
              }, void 0);
              this._animRequest = x(n2, this, true), O(t2);
            }
          },
          _onTouchEnd: function() {
            this._moved && this._zooming ? (this._zooming = false, r(this._animRequest), k(
              document,
              "touchmove",
              this._onTouchMove,
              this
            ), k(
              document,
              "touchend touchcancel",
              this._onTouchEnd,
              this
            ), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = false;
          }
        })), Xi = (A.addInitHook("addHandler", "touchZoom", Ot), A.BoxZoom = _t, A.DoubleClickZoom = Ct, A.Drag = Zt, A.Keyboard = St, A.ScrollWheelZoom = Et, A.TapHold = kt, A.TouchZoom = Ot, t.Bounds = f, t.Browser = b, t.CRS = ot, t.Canvas = Fi, t.Circle = vi, t.CircleMarker = gi, t.Class = et, t.Control = B, t.DivIcon = Ri, t.DivOverlay = Ai, t.DomEvent = mt, t.DomUtil = pt, t.Draggable = Xe, t.Evented = it, t.FeatureGroup = ci, t.GeoJSON = wi, t.GridLayer = Ni, t.Handler = n, t.Icon = di, t.ImageOverlay = Ei, t.LatLng = v, t.LatLngBounds = s, t.Layer = o, t.LayerGroup = ui, t.LineUtil = vt, t.Map = A, t.Marker = mi, t.Mixin = ft, t.Path = fi, t.Point = p, t.PolyUtil = gt, t.Polygon = xi, t.Polyline = yi, t.Popup = Bi, t.PosAnimation = Fe, t.Projection = wt, t.Rectangle = Yi, t.Renderer = Wi, t.SVG = Gi, t.SVGOverlay = Oi, t.TileLayer = Di, t.Tooltip = Ii, t.Transformation = at, t.Util = tt, t.VideoOverlay = ki, t.bind = a, t.bounds = _, t.canvas = Ui, t.circle = function(t2, e2, i2) {
          return new vi(t2, e2, i2);
        }, t.circleMarker = function(t2, e2) {
          return new gi(t2, e2);
        }, t.control = Ue, t.divIcon = function(t2) {
          return new Ri(t2);
        }, t.extend = l, t.featureGroup = function(t2, e2) {
          return new ci(t2, e2);
        }, t.geoJSON = Si, t.geoJson = Mt, t.gridLayer = function(t2) {
          return new Ni(t2);
        }, t.icon = function(t2) {
          return new di(t2);
        }, t.imageOverlay = function(t2, e2, i2) {
          return new Ei(t2, e2, i2);
        }, t.latLng = w, t.latLngBounds = g, t.layerGroup = function(t2, e2) {
          return new ui(t2, e2);
        }, t.map = function(t2, e2) {
          return new A(t2, e2);
        }, t.marker = function(t2, e2) {
          return new mi(t2, e2);
        }, t.point = m, t.polygon = function(t2, e2) {
          return new xi(t2, e2);
        }, t.polyline = function(t2, e2) {
          return new yi(t2, e2);
        }, t.popup = function(t2, e2) {
          return new Bi(t2, e2);
        }, t.rectangle = function(t2, e2) {
          return new Yi(t2, e2);
        }, t.setOptions = c, t.stamp = h, t.svg = Ki, t.svgOverlay = function(t2, e2, i2) {
          return new Oi(t2, e2, i2);
        }, t.tileLayer = ji, t.tooltip = function(t2, e2) {
          return new Ii(t2, e2);
        }, t.transformation = ht, t.version = "1.9.4", t.videoOverlay = function(t2, e2, i2) {
          return new ki(t2, e2, i2);
        }, window.L);
        t.noConflict = function() {
          return window.L = Xi, this;
        }, window.L = t;
      });
    }
  });

  // C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/static/leaflet/proj4.js
  var require_proj4 = __commonJS({
    "C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/static/leaflet/proj4.js"(exports, module) {
      (function(global, factory) {
        if (typeof exports === "object" && typeof module !== "undefined") {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          global.proj4 = factory();
        }
      })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports, function() {
        "use strict";
        function t(t2, s2) {
          if (t2[s2])
            return t2[s2];
          for (var i2, a2 = Object.keys(t2), h2 = s2.toLowerCase().replace(Lt, ""), e2 = -1; ++e2 < a2.length; )
            if (i2 = a2[e2], i2.toLowerCase().replace(Lt, "") === h2)
              return t2[i2];
        }
        function s(t2) {
          if ("string" != typeof t2)
            throw new Error("not a string");
          this.text = t2.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = jt;
        }
        function i(t2) {
          return new s(t2).output();
        }
        function a(t2, s2, i2) {
          Array.isArray(s2) && (i2.unshift(s2), s2 = null);
          var a2 = s2 ? {} : t2, e2 = i2.reduce(function(t3, s3) {
            return h(s3, t3), t3;
          }, a2);
          s2 && (t2[s2] = e2);
        }
        function h(t2, s2) {
          if (Array.isArray(t2)) {
            var i2 = t2.shift();
            if ("PARAMETER" === i2 && (i2 = t2.shift()), 1 === t2.length)
              return Array.isArray(t2[0]) ? (s2[i2] = {}, void h(t2[0], s2[i2])) : void (s2[i2] = t2[0]);
            if (t2.length)
              if ("TOWGS84" !== i2) {
                if ("AXIS" === i2)
                  return i2 in s2 || (s2[i2] = []), void s2[i2].push(t2);
                Array.isArray(i2) || (s2[i2] = {});
                var e2;
                switch (i2) {
                  case "UNIT":
                  case "PRIMEM":
                  case "VERT_DATUM":
                    return s2[i2] = {
                      name: t2[0].toLowerCase(),
                      convert: t2[1]
                    }, void (3 === t2.length && h(t2[2], s2[i2]));
                  case "SPHEROID":
                  case "ELLIPSOID":
                    return s2[i2] = {
                      name: t2[0],
                      a: t2[1],
                      rf: t2[2]
                    }, void (4 === t2.length && h(t2[3], s2[i2]));
                  case "PROJECTEDCRS":
                  case "PROJCRS":
                  case "GEOGCS":
                  case "GEOCCS":
                  case "PROJCS":
                  case "LOCAL_CS":
                  case "GEODCRS":
                  case "GEODETICCRS":
                  case "GEODETICDATUM":
                  case "EDATUM":
                  case "ENGINEERINGDATUM":
                  case "VERT_CS":
                  case "VERTCRS":
                  case "VERTICALCRS":
                  case "COMPD_CS":
                  case "COMPOUNDCRS":
                  case "ENGINEERINGCRS":
                  case "ENGCRS":
                  case "FITTED_CS":
                  case "LOCAL_DATUM":
                  case "DATUM":
                    return t2[0] = ["name", t2[0]], void a(s2, i2, t2);
                  default:
                    for (e2 = -1; ++e2 < t2.length; )
                      if (!Array.isArray(t2[e2]))
                        return h(t2, s2[i2]);
                    return a(s2, i2, t2);
                }
              } else
                s2[i2] = t2;
            else
              s2[i2] = true;
          } else
            s2[t2] = true;
        }
        function e(t2, s2) {
          var i2 = s2[0], a2 = s2[1];
          !(i2 in t2) && a2 in t2 && (t2[i2] = t2[a2], 3 === s2.length && (t2[i2] = s2[2](t2[i2])));
        }
        function n(t2) {
          return t2 * Ut;
        }
        function r(t2) {
          function s2(s3) {
            return s3 * (t2.to_meter || 1);
          }
          if ("GEOGCS" === t2.type ? t2.projName = "longlat" : "LOCAL_CS" === t2.type ? (t2.projName = "identity", t2.local = true) : "object" == typeof t2.PROJECTION ? t2.projName = Object.keys(t2.PROJECTION)[0] : t2.projName = t2.PROJECTION, t2.AXIS) {
            for (var i2 = "", a2 = 0, h2 = t2.AXIS.length; a2 < h2; ++a2) {
              var r2 = [t2.AXIS[a2][0].toLowerCase(), t2.AXIS[a2][1].toLowerCase()];
              -1 !== r2[0].indexOf("north") || ("y" === r2[0] || "lat" === r2[0]) && "north" === r2[1] ? i2 += "n" : -1 !== r2[0].indexOf(
                "south"
              ) || ("y" === r2[0] || "lat" === r2[0]) && "south" === r2[1] ? i2 += "s" : -1 !== r2[0].indexOf("east") || ("x" === r2[0] || "lon" === r2[0]) && "east" === r2[1] ? i2 += "e" : -1 === r2[0].indexOf("west") && ("x" !== r2[0] && "lon" !== r2[0] || "west" !== r2[1]) || (i2 += "w");
            }
            2 === i2.length && (i2 += "u"), 3 === i2.length && (t2.axis = i2);
          }
          t2.UNIT && (t2.units = t2.UNIT.name.toLowerCase(), "metre" === t2.units && (t2.units = "meter"), t2.UNIT.convert && ("GEOGCS" === t2.type ? t2.DATUM && t2.DATUM.SPHEROID && (t2.to_meter = t2.UNIT.convert * t2.DATUM.SPHEROID.a) : t2.to_meter = t2.UNIT.convert));
          var o2 = t2.GEOGCS;
          "GEOGCS" === t2.type && (o2 = t2), o2 && (o2.DATUM ? t2.datumCode = o2.DATUM.name.toLowerCase() : t2.datumCode = o2.name.toLowerCase(), "d_" === t2.datumCode.slice(0, 2) && (t2.datumCode = t2.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== t2.datumCode && "new_zealand_1949" !== t2.datumCode || (t2.datumCode = "nzgd49"), "wgs_1984" !== t2.datumCode && "world_geodetic_system_1984" !== t2.datumCode || ("Mercator_Auxiliary_Sphere" === t2.PROJECTION && (t2.sphere = true), t2.datumCode = "wgs84"), "_ferro" === t2.datumCode.slice(-6) && (t2.datumCode = t2.datumCode.slice(0, -6)), "_jakarta" === t2.datumCode.slice(-8) && (t2.datumCode = t2.datumCode.slice(0, -8)), ~t2.datumCode.indexOf("belge") && (t2.datumCode = "rnb72"), o2.DATUM && o2.DATUM.SPHEROID && (t2.ellps = o2.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === t2.ellps.toLowerCase().slice(0, 13) && (t2.ellps = "intl"), t2.a = o2.DATUM.SPHEROID.a, t2.rf = parseFloat(o2.DATUM.SPHEROID.rf, 10)), o2.DATUM && o2.DATUM.TOWGS84 && (t2.datum_params = o2.DATUM.TOWGS84), ~t2.datumCode.indexOf("osgb_1936") && (t2.datumCode = "osgb36"), ~t2.datumCode.indexOf("osni_1952") && (t2.datumCode = "osni52"), (~t2.datumCode.indexOf("tm65") || ~t2.datumCode.indexOf(
            "geodetic_datum_of_1965"
          )) && (t2.datumCode = "ire65"), "ch1903+" === t2.datumCode && (t2.datumCode = "ch1903"), ~t2.datumCode.indexOf("israel") && (t2.datumCode = "isr93")), t2.b && !isFinite(t2.b) && (t2.b = t2.a);
          [
            ["standard_parallel_1", "Standard_Parallel_1"],
            ["standard_parallel_1", "Latitude of 1st standard parallel"],
            ["standard_parallel_2", "Standard_Parallel_2"],
            ["standard_parallel_2", "Latitude of 2nd standard parallel"],
            ["false_easting", "False_Easting"],
            ["false_easting", "False easting"],
            ["false-easting", "Easting at false origin"],
            ["false_northing", "False_Northing"],
            ["false_northing", "False northing"],
            ["false_northing", "Northing at false origin"],
            ["central_meridian", "Central_Meridian"],
            ["central_meridian", "Longitude of natural origin"],
            ["central_meridian", "Longitude of false origin"],
            ["latitude_of_origin", "Latitude_Of_Origin"],
            ["latitude_of_origin", "Central_Parallel"],
            ["latitude_of_origin", "Latitude of natural origin"],
            ["latitude_of_origin", "Latitude of false origin"],
            ["scale_factor", "Scale_Factor"],
            ["k0", "scale_factor"],
            ["latitude_of_center", "Latitude_Of_Center"],
            ["latitude_of_center", "Latitude_of_center"],
            ["lat0", "latitude_of_center", n],
            ["longitude_of_center", "Longitude_Of_Center"],
            ["longitude_of_center", "Longitude_of_center"],
            ["longc", "longitude_of_center", n],
            ["x0", "false_easting", s2],
            ["y0", "false_northing", s2],
            ["long0", "central_meridian", n],
            ["lat0", "latitude_of_origin", n],
            ["lat0", "standard_parallel_1", n],
            ["lat1", "standard_parallel_1", n],
            ["lat2", "standard_parallel_2", n],
            ["azimuth", "Azimuth"],
            ["alpha", "azimuth", n],
            ["srsCode", "name"]
          ].forEach(function(s3) {
            return e(t2, s3);
          }), t2.long0 || !t2.longc || "Albers_Conic_Equal_Area" !== t2.projName && "Lambert_Azimuthal_Equal_Area" !== t2.projName || (t2.long0 = t2.longc), t2.lat_ts || !t2.lat1 || "Stereographic_South_Pole" !== t2.projName && "Polar Stereographic (variant B)" !== t2.projName ? !t2.lat_ts && t2.lat0 && "Polar_Stereographic" === t2.projName && (t2.lat_ts = t2.lat0, t2.lat0 = n(t2.lat0 > 0 ? 90 : -90)) : (t2.lat0 = n(t2.lat1 > 0 ? 90 : -90), t2.lat_ts = t2.lat1);
        }
        function o(t2) {
          var s2 = this;
          if (2 === arguments.length) {
            var i2 = arguments[1];
            "string" == typeof i2 ? "+" === i2.charAt(0) ? o[t2] = Gt(arguments[1]) : o[t2] = Qt(arguments[1]) : o[t2] = i2;
          } else if (1 === arguments.length) {
            if (Array.isArray(t2))
              return t2.map(function(t3) {
                Array.isArray(t3) ? o.apply(s2, t3) : o(t3);
              });
            if ("string" == typeof t2) {
              if (t2 in o)
                return o[t2];
            } else
              "EPSG" in t2 ? o["EPSG:" + t2.EPSG] = t2 : "ESRI" in t2 ? o["ESRI:" + t2.ESRI] = t2 : "IAU2000" in t2 ? o["IAU2000:" + t2.IAU2000] = t2 : console.log(t2);
            return;
          }
        }
        function l(t2) {
          return "string" == typeof t2;
        }
        function u(t2) {
          return t2 in o;
        }
        function c(t2) {
          return Wt.some(function(s2) {
            return t2.indexOf(s2) > -1;
          });
        }
        function M(s2) {
          var i2 = t(s2, "authority");
          if (i2) {
            var a2 = t(i2, "epsg");
            return a2 && Ht.indexOf(a2) > -1;
          }
        }
        function f(s2) {
          var i2 = t(s2, "extension");
          if (i2)
            return t(i2, "proj4");
        }
        function d(t2) {
          return "+" === t2[0];
        }
        function m(t2) {
          if (!l(t2))
            return t2;
          if (u(t2))
            return o[t2];
          if (c(t2)) {
            var s2 = Qt(t2);
            if (M(s2))
              return o["EPSG:3857"];
            var i2 = f(s2);
            return i2 ? Gt(i2) : s2;
          }
          return d(t2) ? Gt(t2) : void 0;
        }
        function p(t2) {
          return t2;
        }
        function y(t2, s2) {
          var i2 = ss.length;
          return t2.names ? (ss[i2] = t2, t2.names.forEach(function(t3) {
            ts[t3.toLowerCase()] = i2;
          }), this) : (console.log(s2), true);
        }
        function _(t2, s2, i2, a2) {
          var h2 = t2 * t2, e2 = s2 * s2, n2 = (h2 - e2) / h2, r2 = 0;
          return a2 ? (h2 = (t2 *= 1 - n2 * (Nt + n2 * (Et + n2 * At))) * t2, n2 = 0) : r2 = Math.sqrt(n2), {
            es: n2,
            e: r2,
            ep2: (h2 - e2) / e2
          };
        }
        function x(s2, i2, a2, h2, e2) {
          if (!s2) {
            var n2 = t(as, h2);
            n2 || (n2 = hs), s2 = n2.a, i2 = n2.b, a2 = n2.rf;
          }
          return a2 && !i2 && (i2 = (1 - 1 / a2) * s2), (0 === a2 || Math.abs(s2 - i2) < Ct) && (e2 = true, i2 = s2), {
            a: s2,
            b: i2,
            rf: a2,
            sphere: e2
          };
        }
        function g(t2, s2, i2, a2, h2, e2, n2) {
          var r2 = {};
          return r2.datum_type = void 0 === t2 || "none" === t2 ? vt : gt, s2 && (r2.datum_params = s2.map(parseFloat), 0 === r2.datum_params[0] && 0 === r2.datum_params[1] && 0 === r2.datum_params[2] || (r2.datum_type = yt), r2.datum_params.length > 3 && (0 === r2.datum_params[3] && 0 === r2.datum_params[4] && 0 === r2.datum_params[5] && 0 === r2.datum_params[6] || (r2.datum_type = _t, r2.datum_params[3] *= bt, r2.datum_params[4] *= bt, r2.datum_params[5] *= bt, r2.datum_params[6] = r2.datum_params[6] / 1e6 + 1))), n2 && (r2.datum_type = xt, r2.grids = n2), r2.a = i2, r2.b = a2, r2.es = h2, r2.ep2 = e2, r2;
        }
        function v(t2) {
          return void 0 === t2 ? null : t2.split(",").map(b);
        }
        function b(t2) {
          if (0 === t2.length)
            return null;
          var s2 = "@" === t2[0];
          return s2 && (t2 = t2.slice(1)), "null" === t2 ? {
            name: "null",
            mandatory: !s2,
            grid: null,
            isNull: true
          } : {
            name: t2,
            mandatory: !s2,
            grid: os[t2] || null,
            isNull: false
          };
        }
        function w(t2) {
          return t2 / 3600 * Math.PI / 180;
        }
        function N(t2) {
          var s2 = t2.getInt32(8, false);
          return 11 !== s2 && (11 !== (s2 = t2.getInt32(8, true)) && console.warn(
            "Failed to detect nadgrid endian-ness, defaulting to little-endian"
          ), true);
        }
        function E(t2, s2) {
          return {
            nFields: t2.getInt32(8, s2),
            nSubgridFields: t2.getInt32(24, s2),
            nSubgrids: t2.getInt32(40, s2),
            shiftType: A(t2, 56, 64).trim(),
            fromSemiMajorAxis: t2.getFloat64(120, s2),
            fromSemiMinorAxis: t2.getFloat64(136, s2),
            toSemiMajorAxis: t2.getFloat64(152, s2),
            toSemiMinorAxis: t2.getFloat64(168, s2)
          };
        }
        function A(t2, s2, i2) {
          return String.fromCharCode.apply(null, new Uint8Array(t2.buffer.slice(s2, i2)));
        }
        function C(t2, s2, i2) {
          for (var a2 = 176, h2 = [], e2 = 0; e2 < s2.nSubgrids; e2++) {
            var n2 = S(t2, a2, i2), r2 = I(t2, a2, n2, i2), o2 = Math.round(1 + (n2.upperLongitude - n2.lowerLongitude) / n2.longitudeInterval), l2 = Math.round(1 + (n2.upperLatitude - n2.lowerLatitude) / n2.latitudeInterval);
            h2.push({
              ll: [w(n2.lowerLongitude), w(n2.lowerLatitude)],
              del: [w(n2.longitudeInterval), w(n2.latitudeInterval)],
              lim: [o2, l2],
              count: n2.gridNodeCount,
              cvs: P(r2)
            }), a2 += 176 + 16 * n2.gridNodeCount;
          }
          return h2;
        }
        function P(t2) {
          return t2.map(function(t3) {
            return [w(t3.longitudeShift), w(t3.latitudeShift)];
          });
        }
        function S(t2, s2, i2) {
          return {
            name: A(t2, s2 + 8, s2 + 16).trim(),
            parent: A(t2, s2 + 24, s2 + 24 + 8).trim(),
            lowerLatitude: t2.getFloat64(s2 + 72, i2),
            upperLatitude: t2.getFloat64(s2 + 88, i2),
            lowerLongitude: t2.getFloat64(s2 + 104, i2),
            upperLongitude: t2.getFloat64(s2 + 120, i2),
            latitudeInterval: t2.getFloat64(s2 + 136, i2),
            longitudeInterval: t2.getFloat64(s2 + 152, i2),
            gridNodeCount: t2.getInt32(s2 + 168, i2)
          };
        }
        function I(t2, s2, i2, a2) {
          for (var h2 = s2 + 176, e2 = [], n2 = 0; n2 < i2.gridNodeCount; n2++) {
            var r2 = {
              latitudeShift: t2.getFloat32(h2 + 16 * n2, a2),
              longitudeShift: t2.getFloat32(h2 + 16 * n2 + 4, a2),
              latitudeAccuracy: t2.getFloat32(h2 + 16 * n2 + 8, a2),
              longitudeAccuracy: t2.getFloat32(h2 + 16 * n2 + 12, a2)
            };
            e2.push(r2);
          }
          return e2;
        }
        function Projection(s2, i2) {
          if (!(this instanceof Projection))
            return new Projection(s2);
          i2 = i2 || function(t2) {
            if (t2)
              throw t2;
          };
          var a2 = m(s2);
          if ("object" == typeof a2) {
            var h2 = Projection.projections.get(a2.projName);
            if (h2) {
              if (a2.datumCode && "none" !== a2.datumCode) {
                var e2 = t(es, a2.datumCode);
                e2 && (a2.datum_params = a2.datum_params || (e2.towgs84 ? e2.towgs84.split(",") : null), a2.ellps = e2.ellipse, a2.datumName = e2.datumName ? e2.datumName : a2.datumCode);
              }
              a2.k0 = a2.k0 || 1, a2.axis = a2.axis || "enu", a2.ellps = a2.ellps || "wgs84", a2.lat1 = a2.lat1 || a2.lat0;
              var n2 = x(a2.a, a2.b, a2.rf, a2.ellps, a2.sphere), r2 = _(n2.a, n2.b, n2.rf, a2.R_A), o2 = v(a2.nadgrids), l2 = a2.datum || g(a2.datumCode, a2.datum_params, n2.a, n2.b, r2.es, r2.ep2, o2);
              Xt(this, a2), Xt(this, h2), this.a = n2.a, this.b = n2.b, this.rf = n2.rf, this.sphere = n2.sphere, this.es = r2.es, this.e = r2.e, this.ep2 = r2.ep2, this.datum = l2, this.init(), i2(null, this);
            } else
              i2("Could not get projection name from: " + s2);
          } else
            i2("Could not parse to valid json: " + s2);
        }
        function O(t2, s2) {
          return t2.datum_type === s2.datum_type && (!(t2.a !== s2.a || Math.abs(t2.es - s2.es) > 5e-11) && (t2.datum_type === yt ? t2.datum_params[0] === s2.datum_params[0] && t2.datum_params[1] === s2.datum_params[1] && t2.datum_params[2] === s2.datum_params[2] : t2.datum_type !== _t || t2.datum_params[0] === s2.datum_params[0] && t2.datum_params[1] === s2.datum_params[1] && t2.datum_params[2] === s2.datum_params[2] && t2.datum_params[3] === s2.datum_params[3] && t2.datum_params[4] === s2.datum_params[4] && t2.datum_params[5] === s2.datum_params[5] && t2.datum_params[6] === s2.datum_params[6]));
        }
        function k(t2, s2, i2) {
          var a2, h2, e2, n2, r2 = t2.x, o2 = t2.y, l2 = t2.z ? t2.z : 0;
          if (o2 < -wt && o2 > -1.001 * wt)
            o2 = -wt;
          else if (o2 > wt && o2 < 1.001 * wt)
            o2 = wt;
          else {
            if (o2 < -wt)
              return {
                x: -1 / 0,
                y: -1 / 0,
                z: t2.z
              };
            if (o2 > wt)
              return {
                x: 1 / 0,
                y: 1 / 0,
                z: t2.z
              };
          }
          return r2 > Math.PI && (r2 -= 2 * Math.PI), h2 = Math.sin(o2), n2 = Math.cos(o2), e2 = h2 * h2, a2 = i2 / Math.sqrt(1 - s2 * e2), {
            x: (a2 + l2) * n2 * Math.cos(r2),
            y: (a2 + l2) * n2 * Math.sin(r2),
            z: (a2 * (1 - s2) + l2) * h2
          };
        }
        function q(t2, s2, i2, a2) {
          var h2, e2, n2, r2, o2, l2, u2, c2, M2, f2, d2, m2, p2, y2, _2, x2, g2 = t2.x, v2 = t2.y, b2 = t2.z ? t2.z : 0;
          if (h2 = Math.sqrt(g2 * g2 + v2 * v2), e2 = Math.sqrt(g2 * g2 + v2 * v2 + b2 * b2), h2 / i2 < 1e-12) {
            if (y2 = 0, e2 / i2 < 1e-12)
              return _2 = wt, x2 = -a2, {
                x: t2.x,
                y: t2.y,
                z: t2.z
              };
          } else
            y2 = Math.atan2(v2, g2);
          n2 = b2 / e2, c2 = (r2 = h2 / e2) * (1 - s2) * (o2 = 1 / Math.sqrt(1 - s2 * (2 - s2) * r2 * r2)), M2 = n2 * o2, p2 = 0;
          do {
            p2++, l2 = s2 * (u2 = i2 / Math.sqrt(1 - s2 * M2 * M2)) / (u2 + (x2 = h2 * c2 + b2 * M2 - u2 * (1 - s2 * M2 * M2))), m2 = (d2 = n2 * (o2 = 1 / Math.sqrt(1 - l2 * (2 - l2) * r2 * r2))) * c2 - (f2 = r2 * (1 - l2) * o2) * M2, c2 = f2, M2 = d2;
          } while (m2 * m2 > 1e-24 && p2 < 30);
          return _2 = Math.atan(d2 / Math.abs(f2)), {
            x: y2,
            y: _2,
            z: x2
          };
        }
        function R(t2, s2, i2) {
          if (s2 === yt)
            return {
              x: t2.x + i2[0],
              y: t2.y + i2[1],
              z: t2.z + i2[2]
            };
          if (s2 === _t) {
            var a2 = i2[0], h2 = i2[1], e2 = i2[2], n2 = i2[3], r2 = i2[4], o2 = i2[5], l2 = i2[6];
            return {
              x: l2 * (t2.x - o2 * t2.y + r2 * t2.z) + a2,
              y: l2 * (o2 * t2.x + t2.y - n2 * t2.z) + h2,
              z: l2 * (-r2 * t2.x + n2 * t2.y + t2.z) + e2
            };
          }
        }
        function L2(t2, s2, i2) {
          if (s2 === yt)
            return {
              x: t2.x - i2[0],
              y: t2.y - i2[1],
              z: t2.z - i2[2]
            };
          if (s2 === _t) {
            var a2 = i2[0], h2 = i2[1], e2 = i2[2], n2 = i2[3], r2 = i2[4], o2 = i2[5], l2 = i2[6], u2 = (t2.x - a2) / l2, c2 = (t2.y - h2) / l2, M2 = (t2.z - e2) / l2;
            return {
              x: u2 + o2 * c2 - r2 * M2,
              y: -o2 * u2 + c2 + n2 * M2,
              z: r2 * u2 - n2 * c2 + M2
            };
          }
        }
        function G(t2) {
          return t2 === yt || t2 === _t;
        }
        function j(t2, s2, i2) {
          if (null === t2.grids || 0 === t2.grids.length)
            return console.log("Grid shift grids not found"), -1;
          var a2 = {
            x: -i2.x,
            y: i2.y
          }, h2 = {
            x: Number.NaN,
            y: Number.NaN
          }, e2 = [];
          t:
            for (var n2 = 0; n2 < t2.grids.length; n2++) {
              var r2 = t2.grids[n2];
              if (e2.push(r2.name), r2.isNull) {
                h2 = a2;
                break;
              }
              if (null !== r2.grid)
                for (var o2 = r2.grid.subgrids, l2 = 0, u2 = o2.length; l2 < u2; l2++) {
                  var c2 = o2[l2], M2 = (Math.abs(c2.del[1]) + Math.abs(c2.del[0])) / 1e4, f2 = c2.ll[0] - M2, d2 = c2.ll[1] - M2, m2 = c2.ll[0] + (c2.lim[0] - 1) * c2.del[0] + M2, p2 = c2.ll[1] + (c2.lim[1] - 1) * c2.del[1] + M2;
                  if (!(d2 > a2.y || f2 > a2.x || p2 < a2.y || m2 < a2.x) && (h2 = T(a2, s2, c2), !isNaN(h2.x)))
                    break t;
                }
              else if (r2.mandatory)
                return console.log("Unable to find mandatory grid '" + r2.name + "'"), -1;
            }
          return isNaN(h2.x) ? (console.log("Failed to find a grid shift table for location '" + -a2.x * St + " " + a2.y * St + " tried: '" + e2 + "'"), -1) : (i2.x = -h2.x, i2.y = h2.y, 0);
        }
        function T(t2, s2, i2) {
          var a2 = {
            x: Number.NaN,
            y: Number.NaN
          };
          if (isNaN(t2.x))
            return a2;
          var h2 = {
            x: t2.x,
            y: t2.y
          };
          h2.x -= i2.ll[0], h2.y -= i2.ll[1], h2.x = Vt(h2.x - Math.PI) + Math.PI;
          var e2 = B(h2, i2);
          if (s2) {
            if (isNaN(e2.x))
              return a2;
            e2.x = h2.x - e2.x, e2.y = h2.y - e2.y;
            var n2, r2, o2 = 9;
            do {
              if (r2 = B(e2, i2), isNaN(r2.x)) {
                console.log(
                  "Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation."
                );
                break;
              }
              n2 = {
                x: h2.x - (r2.x + e2.x),
                y: h2.y - (r2.y + e2.y)
              }, e2.x += n2.x, e2.y += n2.y;
            } while (o2-- && Math.abs(n2.x) > 1e-12 && Math.abs(n2.y) > 1e-12);
            if (o2 < 0)
              return console.log("Inverse grid shift iterator failed to converge."), a2;
            a2.x = Vt(e2.x + i2.ll[0]), a2.y = e2.y + i2.ll[1];
          } else
            isNaN(e2.x) || (a2.x = t2.x + e2.x, a2.y = t2.y + e2.y);
          return a2;
        }
        function B(t2, s2) {
          var i2, a2 = {
            x: t2.x / s2.del[0],
            y: t2.y / s2.del[1]
          }, h2 = {
            x: Math.floor(a2.x),
            y: Math.floor(a2.y)
          }, e2 = {
            x: a2.x - 1 * h2.x,
            y: a2.y - 1 * h2.y
          }, n2 = {
            x: Number.NaN,
            y: Number.NaN
          };
          if (h2.x < 0 || h2.x >= s2.lim[0])
            return n2;
          if (h2.y < 0 || h2.y >= s2.lim[1])
            return n2;
          i2 = h2.y * s2.lim[0] + h2.x;
          var r2 = {
            x: s2.cvs[i2][0],
            y: s2.cvs[i2][1]
          };
          i2++;
          var o2 = {
            x: s2.cvs[i2][0],
            y: s2.cvs[i2][1]
          };
          i2 += s2.lim[0];
          var l2 = {
            x: s2.cvs[i2][0],
            y: s2.cvs[i2][1]
          };
          i2--;
          var u2 = {
            x: s2.cvs[i2][0],
            y: s2.cvs[i2][1]
          }, c2 = e2.x * e2.y, M2 = e2.x * (1 - e2.y), f2 = (1 - e2.x) * (1 - e2.y), d2 = (1 - e2.x) * e2.y;
          return n2.x = f2 * r2.x + M2 * o2.x + d2 * u2.x + c2 * l2.x, n2.y = f2 * r2.y + M2 * o2.y + d2 * u2.y + c2 * l2.y, n2;
        }
        function z(t2) {
          if ("function" == typeof Number.isFinite) {
            if (Number.isFinite(t2))
              return;
            throw new TypeError("coordinates must be finite numbers");
          }
          if ("number" != typeof t2 || t2 !== t2 || !isFinite(t2))
            throw new TypeError(
              "coordinates must be finite numbers"
            );
        }
        function F(t2, s2) {
          return (t2.datum.datum_type === yt || t2.datum.datum_type === _t || t2.datum.datum_type === xt) && "WGS84" !== s2.datumCode || (s2.datum.datum_type === yt || s2.datum.datum_type === _t || s2.datum.datum_type === xt) && "WGS84" !== t2.datumCode;
        }
        function D(t2, s2, i2, a2) {
          var h2, e2 = void 0 !== (i2 = Array.isArray(i2) ? cs(i2) : {
            x: i2.x,
            y: i2.y,
            z: i2.z,
            m: i2.m
          }).z;
          if (Ms(i2), t2.datum && s2.datum && F(t2, s2) && (i2 = D(t2, h2 = new Projection("WGS84"), i2, a2), t2 = h2), a2 && "enu" !== t2.axis && (i2 = us(t2, false, i2)), "longlat" === t2.projName)
            i2 = {
              x: i2.x * Pt,
              y: i2.y * Pt,
              z: i2.z || 0
            };
          else if (t2.to_meter && (i2 = {
            x: i2.x * t2.to_meter,
            y: i2.y * t2.to_meter,
            z: i2.z || 0
          }), !(i2 = t2.inverse(i2)))
            return;
          if (t2.from_greenwich && (i2.x += t2.from_greenwich), i2 = ls(t2.datum, s2.datum, i2))
            return s2.from_greenwich && (i2 = {
              x: i2.x - s2.from_greenwich,
              y: i2.y,
              z: i2.z || 0
            }), "longlat" === s2.projName ? i2 = {
              x: i2.x * St,
              y: i2.y * St,
              z: i2.z || 0
            } : (i2 = s2.forward(i2), s2.to_meter && (i2 = {
              x: i2.x / s2.to_meter,
              y: i2.y / s2.to_meter,
              z: i2.z || 0
            })), a2 && "enu" !== s2.axis ? us(s2, true, i2) : (i2 && !e2 && delete i2.z, i2);
        }
        function U(t2, s2, i2, a2) {
          var h2, e2, n2;
          return Array.isArray(i2) ? (h2 = D(t2, s2, i2, a2) || {
            x: NaN,
            y: NaN
          }, i2.length > 2 ? void 0 !== t2.name && "geocent" === t2.name || void 0 !== s2.name && "geocent" === s2.name ? "number" == typeof h2.z ? [h2.x, h2.y, h2.z].concat(i2.slice(3)) : [h2.x, h2.y, i2[2]].concat(i2.slice(3)) : [h2.x, h2.y].concat(i2.slice(2)) : [h2.x, h2.y]) : (e2 = D(t2, s2, i2, a2), 2 === (n2 = Object.keys(i2)).length ? e2 : (n2.forEach(function(a3) {
            if (void 0 !== t2.name && "geocent" === t2.name || void 0 !== s2.name && "geocent" === s2.name) {
              if ("x" === a3 || "y" === a3 || "z" === a3)
                return;
            } else if ("x" === a3 || "y" === a3)
              return;
            e2[a3] = i2[a3];
          }), e2));
        }
        function Q(t2) {
          return t2 instanceof Projection ? t2 : t2.oProj ? t2.oProj : Projection(t2);
        }
        function W(t2, s2, i2) {
          t2 = Q(t2);
          var a2, h2 = false;
          return void 0 === s2 ? (s2 = t2, t2 = fs, h2 = true) : (void 0 !== s2.x || Array.isArray(s2)) && (i2 = s2, s2 = t2, t2 = fs, h2 = true), s2 = Q(s2), i2 ? U(t2, s2, i2) : (a2 = {
            forward: function(i3, a3) {
              return U(t2, s2, i3, a3);
            },
            inverse: function(i3, a3) {
              return U(s2, t2, i3, a3);
            }
          }, h2 && (a2.oProj = s2), a2);
        }
        function H(t2, s2) {
          return s2 = s2 || 5, $(V({
            lat: t2[1],
            lon: t2[0]
          }), s2);
        }
        function X(t2) {
          var s2 = Z(at(t2.toUpperCase()));
          return s2.lat && s2.lon ? [s2.lon, s2.lat] : [(s2.left + s2.right) / 2, (s2.top + s2.bottom) / 2];
        }
        function K(t2) {
          return t2 * (Math.PI / 180);
        }
        function J(t2) {
          return t2 / Math.PI * 180;
        }
        function V(t2) {
          var s2, i2, a2, h2, e2, n2, r2, o2 = t2.lat, l2 = t2.lon, u2 = 6378137, c2 = K(o2), M2 = K(l2);
          r2 = Math.floor((l2 + 180) / 6) + 1, 180 === l2 && (r2 = 60), o2 >= 56 && o2 < 64 && l2 >= 3 && l2 < 12 && (r2 = 32), o2 >= 72 && o2 < 84 && (l2 >= 0 && l2 < 9 ? r2 = 31 : l2 >= 9 && l2 < 21 ? r2 = 33 : l2 >= 21 && l2 < 33 ? r2 = 35 : l2 >= 33 && l2 < 42 && (r2 = 37)), n2 = K(6 * (r2 - 1) - 180 + 3), s2 = u2 / Math.sqrt(1 - 669438e-8 * Math.sin(c2) * Math.sin(c2)), i2 = Math.tan(c2) * Math.tan(c2), a2 = 0.006739496752268451 * Math.cos(c2) * Math.cos(c2);
          var f2 = 0.9996 * s2 * ((h2 = Math.cos(c2) * (M2 - n2)) + (1 - i2 + a2) * h2 * h2 * h2 / 6 + (5 - 18 * i2 + i2 * i2 + 72 * a2 - 0.39089081163157013) * h2 * h2 * h2 * h2 * h2 / 120) + 5e5, d2 = 0.9996 * ((e2 = u2 * (0.9983242984503243 * c2 - 0.002514607064228144 * Math.sin(2 * c2) + 2639046602129982e-21 * Math.sin(4 * c2) - 3418046101696858e-24 * Math.sin(6 * c2))) + s2 * Math.tan(c2) * (h2 * h2 / 2 + (5 - i2 + 9 * a2 + 4 * a2 * a2) * h2 * h2 * h2 * h2 / 24 + (61 - 58 * i2 + i2 * i2 + 600 * a2 - 2.2240339282485886) * h2 * h2 * h2 * h2 * h2 * h2 / 720));
          return o2 < 0 && (d2 += 1e7), {
            northing: Math.round(d2),
            easting: Math.round(f2),
            zoneNumber: r2,
            zoneLetter: Y(o2)
          };
        }
        function Z(t2) {
          var s2 = t2.northing, i2 = t2.easting, a2 = t2.zoneLetter, h2 = t2.zoneNumber;
          if (h2 < 0 || h2 > 60)
            return null;
          var e2, n2, r2, o2, l2, u2, c2, M2, f2 = 6378137, d2 = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)), m2 = i2 - 5e5, p2 = s2;
          a2 < "N" && (p2 -= 1e7), u2 = 6 * (h2 - 1) - 180 + 3, M2 = (c2 = p2 / 0.9996 / 6367449145945056e-9) + (3 * d2 / 2 - 27 * d2 * d2 * d2 / 32) * Math.sin(2 * c2) + (21 * d2 * d2 / 16 - 55 * d2 * d2 * d2 * d2 / 32) * Math.sin(4 * c2) + 151 * d2 * d2 * d2 / 96 * Math.sin(6 * c2), e2 = f2 / Math.sqrt(1 - 669438e-8 * Math.sin(M2) * Math.sin(M2)), n2 = Math.tan(M2) * Math.tan(M2), r2 = 0.006739496752268451 * Math.cos(M2) * Math.cos(M2), o2 = 0.99330562 * f2 / Math.pow(1 - 669438e-8 * Math.sin(M2) * Math.sin(M2), 1.5), l2 = m2 / (0.9996 * e2);
          var y2 = M2 - e2 * Math.tan(M2) / o2 * (l2 * l2 / 2 - (5 + 3 * n2 + 10 * r2 - 4 * r2 * r2 - 0.06065547077041606) * l2 * l2 * l2 * l2 / 24 + (61 + 90 * n2 + 298 * r2 + 45 * n2 * n2 - 1.6983531815716497 - 3 * r2 * r2) * l2 * l2 * l2 * l2 * l2 * l2 / 720);
          y2 = J(y2);
          var _2 = (l2 - (1 + 2 * n2 + r2) * l2 * l2 * l2 / 6 + (5 - 2 * r2 + 28 * n2 - 3 * r2 * r2 + 0.05391597401814761 + 24 * n2 * n2) * l2 * l2 * l2 * l2 * l2 / 120) / Math.cos(M2);
          _2 = u2 + J(_2);
          var x2;
          if (t2.accuracy) {
            var g2 = Z({
              northing: t2.northing + t2.accuracy,
              easting: t2.easting + t2.accuracy,
              zoneLetter: t2.zoneLetter,
              zoneNumber: t2.zoneNumber
            });
            x2 = {
              top: g2.lat,
              right: g2.lon,
              bottom: y2,
              left: _2
            };
          } else
            x2 = {
              lat: y2,
              lon: _2
            };
          return x2;
        }
        function Y(t2) {
          var s2 = "Z";
          return 84 >= t2 && t2 >= 72 ? s2 = "X" : 72 > t2 && t2 >= 64 ? s2 = "W" : 64 > t2 && t2 >= 56 ? s2 = "V" : 56 > t2 && t2 >= 48 ? s2 = "U" : 48 > t2 && t2 >= 40 ? s2 = "T" : 40 > t2 && t2 >= 32 ? s2 = "S" : 32 > t2 && t2 >= 24 ? s2 = "R" : 24 > t2 && t2 >= 16 ? s2 = "Q" : 16 > t2 && t2 >= 8 ? s2 = "P" : 8 > t2 && t2 >= 0 ? s2 = "N" : 0 > t2 && t2 >= -8 ? s2 = "M" : -8 > t2 && t2 >= -16 ? s2 = "L" : -16 > t2 && t2 >= -24 ? s2 = "K" : -24 > t2 && t2 >= -32 ? s2 = "J" : -32 > t2 && t2 >= -40 ? s2 = "H" : -40 > t2 && t2 >= -48 ? s2 = "G" : -48 > t2 && t2 >= -56 ? s2 = "F" : -56 > t2 && t2 >= -64 ? s2 = "E" : -64 > t2 && t2 >= -72 ? s2 = "D" : -72 > t2 && t2 >= -80 && (s2 = "C"), s2;
        }
        function $(t2, s2) {
          var i2 = "00000" + t2.easting, a2 = "00000" + t2.northing;
          return t2.zoneNumber + t2.zoneLetter + tt(t2.easting, t2.northing, t2.zoneNumber) + i2.substr(i2.length - 5, s2) + a2.substr(a2.length - 5, s2);
        }
        function tt(t2, s2, i2) {
          var a2 = st(i2);
          return it(Math.floor(t2 / 1e5), Math.floor(s2 / 1e5) % 20, a2);
        }
        function st(t2) {
          var s2 = t2 % ds;
          return 0 === s2 && (s2 = ds), s2;
        }
        function it(t2, s2, i2) {
          var a2 = i2 - 1, h2 = ms.charCodeAt(a2), e2 = ps.charCodeAt(a2), n2 = h2 + t2 - 1, r2 = e2 + s2, o2 = false;
          return n2 > vs && (n2 = n2 - vs + ys - 1, o2 = true), (n2 === _s || h2 < _s && n2 > _s || (n2 > _s || h2 < _s) && o2) && n2++, (n2 === xs || h2 < xs && n2 > xs || (n2 > xs || h2 < xs) && o2) && ++n2 === _s && n2++, n2 > vs && (n2 = n2 - vs + ys - 1), r2 > gs ? (r2 = r2 - gs + ys - 1, o2 = true) : o2 = false, (r2 === _s || e2 < _s && r2 > _s || (r2 > _s || e2 < _s) && o2) && r2++, (r2 === xs || e2 < xs && r2 > xs || (r2 > xs || e2 < xs) && o2) && ++r2 === _s && r2++, r2 > gs && (r2 = r2 - gs + ys - 1), String.fromCharCode(n2) + String.fromCharCode(r2);
        }
        function at(t2) {
          if (t2 && 0 === t2.length)
            throw "MGRSPoint coverting from nothing";
          for (var s2, i2 = t2.length, a2 = null, h2 = "", e2 = 0; !/[A-Z]/.test(s2 = t2.charAt(e2)); ) {
            if (e2 >= 2)
              throw "MGRSPoint bad conversion from: " + t2;
            h2 += s2, e2++;
          }
          var n2 = parseInt(h2, 10);
          if (0 === e2 || e2 + 3 > i2)
            throw "MGRSPoint bad conversion from: " + t2;
          var r2 = t2.charAt(e2++);
          if (r2 <= "A" || "B" === r2 || "Y" === r2 || r2 >= "Z" || "I" === r2 || "O" === r2)
            throw "MGRSPoint zone letter " + r2 + " not handled: " + t2;
          a2 = t2.substring(e2, e2 += 2);
          for (var o2 = st(n2), l2 = ht(a2.charAt(0), o2), u2 = et(a2.charAt(1), o2); u2 < nt(r2); )
            u2 += 2e6;
          var c2 = i2 - e2;
          if (c2 % 2 != 0)
            throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + t2;
          var M2, f2, d2, m2, p2, y2 = c2 / 2, _2 = 0, x2 = 0;
          return y2 > 0 && (M2 = 1e5 / Math.pow(10, y2), f2 = t2.substring(e2, e2 + y2), _2 = parseFloat(f2) * M2, d2 = t2.substring(e2 + y2), x2 = parseFloat(d2) * M2), m2 = _2 + l2, p2 = x2 + u2, {
            easting: m2,
            northing: p2,
            zoneLetter: r2,
            zoneNumber: n2,
            accuracy: M2
          };
        }
        function ht(t2, s2) {
          for (var i2 = ms.charCodeAt(s2 - 1), a2 = 1e5, h2 = false; i2 !== t2.charCodeAt(0); ) {
            if (++i2 === _s && i2++, i2 === xs && i2++, i2 > vs) {
              if (h2)
                throw "Bad character: " + t2;
              i2 = ys, h2 = true;
            }
            a2 += 1e5;
          }
          return a2;
        }
        function et(t2, s2) {
          if (t2 > "V")
            throw "MGRSPoint given invalid Northing " + t2;
          for (var i2 = ps.charCodeAt(s2 - 1), a2 = 0, h2 = false; i2 !== t2.charCodeAt(0); ) {
            if (++i2 === _s && i2++, i2 === xs && i2++, i2 > gs) {
              if (h2)
                throw "Bad character: " + t2;
              i2 = ys, h2 = true;
            }
            a2 += 1e5;
          }
          return a2;
        }
        function nt(t2) {
          var s2;
          switch (t2) {
            case "C":
              s2 = 11e5;
              break;
            case "D":
              s2 = 2e6;
              break;
            case "E":
              s2 = 28e5;
              break;
            case "F":
              s2 = 37e5;
              break;
            case "G":
              s2 = 46e5;
              break;
            case "H":
              s2 = 55e5;
              break;
            case "J":
              s2 = 64e5;
              break;
            case "K":
              s2 = 73e5;
              break;
            case "L":
              s2 = 82e5;
              break;
            case "M":
              s2 = 91e5;
              break;
            case "N":
              s2 = 0;
              break;
            case "P":
              s2 = 8e5;
              break;
            case "Q":
              s2 = 17e5;
              break;
            case "R":
              s2 = 26e5;
              break;
            case "S":
              s2 = 35e5;
              break;
            case "T":
              s2 = 44e5;
              break;
            case "U":
              s2 = 53e5;
              break;
            case "V":
              s2 = 62e5;
              break;
            case "W":
              s2 = 7e6;
              break;
            case "X":
              s2 = 79e5;
              break;
            default:
              s2 = -1;
          }
          if (s2 >= 0)
            return s2;
          throw "Invalid zone letter: " + t2;
        }
        function Point(t2, s2, i2) {
          if (!(this instanceof Point))
            return new Point(t2, s2, i2);
          if (Array.isArray(t2))
            this.x = t2[0], this.y = t2[1], this.z = t2[2] || 0;
          else if ("object" == typeof t2)
            this.x = t2.x, this.y = t2.y, this.z = t2.z || 0;
          else if ("string" == typeof t2 && void 0 === s2) {
            var a2 = t2.split(",");
            this.x = parseFloat(a2[0], 10), this.y = parseFloat(a2[1], 10), this.z = parseFloat(a2[2], 10) || 0;
          } else
            this.x = t2, this.y = s2, this.z = i2 || 0;
          console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
        }
        function rt(t2) {
          var s2 = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], i2 = "object" == typeof t2.PROJECTION ? Object.keys(t2.PROJECTION)[0] : t2.PROJECTION;
          return "no_uoff" in t2 || "no_off" in t2 || -1 !== s2.indexOf(i2);
        }
        function ot(t2) {
          var s2, i2 = [];
          return i2[0] = t2 * ei, s2 = t2 * t2, i2[0] += s2 * ni, i2[1] = s2 * oi, s2 *= t2, i2[0] += s2 * ri, i2[1] += s2 * li, i2[2] = s2 * ui, i2;
        }
        function lt(t2, s2) {
          var i2 = t2 + t2;
          return t2 + s2[0] * Math.sin(i2) + s2[1] * Math.sin(i2 + i2) + s2[2] * Math.sin(i2 + i2 + i2);
        }
        function ut(t2, s2, i2, a2) {
          var h2;
          return t2 < Ct ? (a2.value = Ii.AREA_0, h2 = 0) : (h2 = Math.atan2(s2, i2), Math.abs(h2) <= It ? a2.value = Ii.AREA_0 : h2 > It && h2 <= wt + It ? (a2.value = Ii.AREA_1, h2 -= wt) : h2 > wt + It || h2 <= -(wt + It) ? (a2.value = Ii.AREA_2, h2 = h2 >= 0 ? h2 - kt : h2 + kt) : (a2.value = Ii.AREA_3, h2 += wt)), h2;
        }
        function ct(t2, s2) {
          var i2 = t2 + s2;
          return i2 < -kt ? i2 += Ot : i2 > +kt && (i2 -= Ot), i2;
        }
        function Mt(t2, s2, i2, a2) {
          for (var h2 = s2; a2; --a2) {
            var e2 = t2(h2);
            if (h2 -= e2, Math.abs(e2) < i2)
              break;
          }
          return h2;
        }
        function ft(t2) {
          var s2, i2, a2, h2 = Vt(t2.x - (this.long0 || 0)), e2 = t2.y;
          return s2 = this.am1 + this.m1 - Es(e2, i2 = Math.sin(e2), a2 = Math.cos(e2), this.en), i2 = a2 * h2 / (s2 * Math.sqrt(1 - this.es * i2 * i2)), t2.x = s2 * Math.sin(i2), t2.y = this.am1 - s2 * Math.cos(i2), t2.x = this.a * t2.x + (this.x0 || 0), t2.y = this.a * t2.y + (this.y0 || 0), t2;
        }
        function dt(t2) {
          t2.x = (t2.x - (this.x0 || 0)) / this.a, t2.y = (t2.y - (this.y0 || 0)) / this.a;
          var s2, i2, a2, h2;
          if (i2 = Ss(t2.x, t2.y = this.am1 - t2.y), h2 = As(this.am1 + this.m1 - i2, this.es, this.en), (s2 = Math.abs(h2)) < wt)
            s2 = Math.sin(h2), a2 = i2 * Math.atan2(t2.x, t2.y) * Math.sqrt(1 - this.es * s2 * s2) / Math.cos(h2);
          else {
            if (!(Math.abs(s2 - wt) <= $i))
              throw new Error();
            a2 = 0;
          }
          return t2.x = Vt(a2 + (this.long0 || 0)), t2.y = si(h2), t2;
        }
        function mt(t2) {
          var s2, i2, a2 = Vt(t2.x - (this.long0 || 0)), h2 = t2.y;
          return i2 = this.cphi1 + this.phi1 - h2, Math.abs(i2) > $i ? (t2.x = i2 * Math.sin(s2 = a2 * Math.cos(h2) / i2), t2.y = this.cphi1 - i2 * Math.cos(s2)) : t2.x = t2.y = 0, t2.x = this.a * t2.x + (this.x0 || 0), t2.y = this.a * t2.y + (this.y0 || 0), t2;
        }
        function pt(t2) {
          t2.x = (t2.x - (this.x0 || 0)) / this.a, t2.y = (t2.y - (this.y0 || 0)) / this.a;
          var s2, i2, a2 = Ss(t2.x, t2.y = this.cphi1 - t2.y);
          if (i2 = this.cphi1 + this.phi1 - a2, Math.abs(i2) > wt)
            throw new Error();
          return s2 = Math.abs(Math.abs(i2) - wt) <= $i ? 0 : a2 * Math.atan2(t2.x, t2.y) / Math.cos(i2), t2.x = Vt(s2 + (this.long0 || 0)), t2.y = si(i2), t2;
        }
        var yt = 1, _t = 2, xt = 3, gt = 4, vt = 5, bt = 484813681109536e-20, wt = Math.PI / 2, Nt = 0.16666666666666666, Et = 0.04722222222222222, At = 0.022156084656084655, Ct = 1e-10, Pt = 0.017453292519943295, St = 57.29577951308232, It = Math.PI / 4, Ot = 2 * Math.PI, kt = 3.14159265359, qt = {};
        qt.greenwich = 0, qt.lisbon = -9.131906111111, qt.paris = 2.337229166667, qt.bogota = -74.080916666667, qt.madrid = -3.687938888889, qt.rome = 12.452333333333, qt.bern = 7.439583333333, qt.jakarta = 106.807719444444, qt.ferro = -17.666666666667, qt.brussels = 4.367975, qt.stockholm = 18.058277777778, qt.athens = 23.7163375, qt.oslo = 10.722916666667;
        var Rt = {
          mm: {
            to_meter: 1e-3
          },
          cm: {
            to_meter: 0.01
          },
          ft: {
            to_meter: 0.3048
          },
          "us-ft": {
            to_meter: 1200 / 3937
          },
          fath: {
            to_meter: 1.8288
          },
          kmi: {
            to_meter: 1852
          },
          "us-ch": {
            to_meter: 20.1168402336805
          },
          "us-mi": {
            to_meter: 1609.34721869444
          },
          km: {
            to_meter: 1e3
          },
          "ind-ft": {
            to_meter: 0.30479841
          },
          "ind-yd": {
            to_meter: 0.91439523
          },
          mi: {
            to_meter: 1609.344
          },
          yd: {
            to_meter: 0.9144
          },
          ch: {
            to_meter: 20.1168
          },
          link: {
            to_meter: 0.201168
          },
          dm: {
            to_meter: 0.01
          },
          in: {
            to_meter: 0.0254
          },
          "ind-ch": {
            to_meter: 20.11669506
          },
          "us-in": {
            to_meter: 0.025400050800101
          },
          "us-yd": {
            to_meter: 0.914401828803658
          }
        }, Lt = /[\s_\-\/\(\)]/g, Gt = function(s2) {
          var i2, a2, h2, e2 = {}, n2 = s2.split("+").map(function(t2) {
            return t2.trim();
          }).filter(function(t2) {
            return t2;
          }).reduce(function(t2, s3) {
            var i3 = s3.split("=");
            return i3.push(true), t2[i3[0].toLowerCase()] = i3[1], t2;
          }, {}), r2 = {
            proj: "projName",
            datum: "datumCode",
            rf: function(t2) {
              e2.rf = parseFloat(t2);
            },
            lat_0: function(t2) {
              e2.lat0 = t2 * Pt;
            },
            lat_1: function(t2) {
              e2.lat1 = t2 * Pt;
            },
            lat_2: function(t2) {
              e2.lat2 = t2 * Pt;
            },
            lat_ts: function(t2) {
              e2.lat_ts = t2 * Pt;
            },
            lon_0: function(t2) {
              e2.long0 = t2 * Pt;
            },
            lon_1: function(t2) {
              e2.long1 = t2 * Pt;
            },
            lon_2: function(t2) {
              e2.long2 = t2 * Pt;
            },
            alpha: function(t2) {
              e2.alpha = parseFloat(t2) * Pt;
            },
            gamma: function(t2) {
              e2.rectified_grid_angle = parseFloat(t2);
            },
            lonc: function(t2) {
              e2.longc = t2 * Pt;
            },
            x_0: function(t2) {
              e2.x0 = parseFloat(t2);
            },
            y_0: function(t2) {
              e2.y0 = parseFloat(t2);
            },
            k_0: function(t2) {
              e2.k0 = parseFloat(t2);
            },
            k: function(t2) {
              e2.k0 = parseFloat(t2);
            },
            a: function(t2) {
              e2.a = parseFloat(t2);
            },
            b: function(t2) {
              e2.b = parseFloat(t2);
            },
            r: function(t2) {
              e2.a = e2.b = parseFloat(t2);
            },
            r_a: function() {
              e2.R_A = true;
            },
            zone: function(t2) {
              e2.zone = parseInt(t2, 10);
            },
            south: function() {
              e2.utmSouth = true;
            },
            towgs84: function(t2) {
              e2.datum_params = t2.split(",").map(function(t3) {
                return parseFloat(t3);
              });
            },
            to_meter: function(t2) {
              e2.to_meter = parseFloat(t2);
            },
            units: function(s3) {
              e2.units = s3;
              var i3 = t(Rt, s3);
              i3 && (e2.to_meter = i3.to_meter);
            },
            from_greenwich: function(t2) {
              e2.from_greenwich = t2 * Pt;
            },
            pm: function(s3) {
              var i3 = t(qt, s3);
              e2.from_greenwich = (i3 || parseFloat(s3)) * Pt;
            },
            nadgrids: function(t2) {
              "@null" === t2 ? e2.datumCode = "none" : e2.nadgrids = t2;
            },
            axis: function(t2) {
              3 === t2.length && -1 !== "ewnsud".indexOf(t2.substr(0, 1)) && -1 !== "ewnsud".indexOf(t2.substr(1, 1)) && -1 !== "ewnsud".indexOf(t2.substr(2, 1)) && (e2.axis = t2);
            },
            approx: function() {
              e2.approx = true;
            }
          };
          for (i2 in n2)
            a2 = n2[i2], i2 in r2 ? "function" == typeof (h2 = r2[i2]) ? h2(a2) : e2[h2] = a2 : e2[i2] = a2;
          return "string" == typeof e2.datumCode && "WGS84" !== e2.datumCode && (e2.datumCode = e2.datumCode.toLowerCase()), e2;
        }, jt = 1, Tt = /\s/, Bt = /[A-Za-z]/, zt = /[A-Za-z84_]/, Ft = /[,\]]/, Dt = /[\d\.E\-\+]/;
        s.prototype.readCharicter = function() {
          var t2 = this.text[this.place++];
          if (4 !== this.state)
            for (; Tt.test(t2); ) {
              if (this.place >= this.text.length)
                return;
              t2 = this.text[this.place++];
            }
          switch (this.state) {
            case jt:
              return this.neutral(t2);
            case 2:
              return this.keyword(t2);
            case 4:
              return this.quoted(t2);
            case 5:
              return this.afterquote(t2);
            case 3:
              return this.number(t2);
            case -1:
              return;
          }
        }, s.prototype.afterquote = function(t2) {
          if ('"' === t2)
            return this.word += '"', void (this.state = 4);
          if (Ft.test(t2))
            return this.word = this.word.trim(), void this.afterItem(t2);
          throw new Error(`havn't handled "` + t2 + '" in afterquote yet, index ' + this.place);
        }, s.prototype.afterItem = function(t2) {
          return "," === t2 ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = jt)) : "]" === t2 ? (this.level--, null !== this.word && (this.currentObject.push(
            this.word
          ), this.word = null), this.state = jt, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0;
        }, s.prototype.number = function(t2) {
          if (!Dt.test(t2)) {
            if (Ft.test(t2))
              return this.word = parseFloat(this.word), void this.afterItem(t2);
            throw new Error(`havn't handled "` + t2 + '" in number yet, index ' + this.place);
          }
          this.word += t2;
        }, s.prototype.quoted = function(t2) {
          '"' !== t2 ? this.word += t2 : this.state = 5;
        }, s.prototype.keyword = function(t2) {
          if (zt.test(t2))
            this.word += t2;
          else {
            if ("[" === t2) {
              var s2 = [];
              return s2.push(this.word), this.level++, null === this.root ? this.root = s2 : this.currentObject.push(s2), this.stack.push(this.currentObject), this.currentObject = s2, void (this.state = jt);
            }
            if (!Ft.test(t2))
              throw new Error(`havn't handled "` + t2 + '" in keyword yet, index ' + this.place);
            this.afterItem(t2);
          }
        }, s.prototype.neutral = function(t2) {
          if (Bt.test(t2))
            return this.word = t2, void (this.state = 2);
          if ('"' === t2)
            return this.word = "", void (this.state = 4);
          if (Dt.test(t2))
            return this.word = t2, void (this.state = 3);
          {
            if (!Ft.test(t2))
              throw new Error(`havn't handled "` + t2 + '" in neutral yet, index ' + this.place);
            this.afterItem(t2);
          }
        }, s.prototype.output = function() {
          for (; this.place < this.text.length; )
            this.readCharicter();
          if (-1 === this.state)
            return this.root;
          throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
        };
        var Ut = 0.017453292519943295, Qt = function(t2) {
          var s2 = i(t2), a2 = s2.shift(), e2 = s2.shift();
          s2.unshift(["name", e2]), s2.unshift(["type", a2]);
          var n2 = {};
          return h(s2, n2), r(n2), n2;
        };
        !function(t2) {
          t2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t2(
            "EPSG:4269",
            "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"
          ), t2(
            "EPSG:3857",
            "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"
          );
          for (var s2 = 0; s2 <= 60; ++s2)
            t2("EPSG:" + (32600 + s2), "+proj=utm +zone=" + s2 + " +datum=WGS84 +units=m"), t2("EPSG:" + (32700 + s2), "+proj=utm +zone=" + s2 + " +south +datum=WGS84 +units=m");
          t2.WGS84 = t2["EPSG:4326"], t2["EPSG:3785"] = t2["EPSG:3857"], t2.GOOGLE = t2["EPSG:3857"], t2["EPSG:900913"] = t2["EPSG:3857"], t2["EPSG:102113"] = t2["EPSG:3857"];
        }(o);
        var Wt = [
          "PROJECTEDCRS",
          "PROJCRS",
          "GEOGCS",
          "GEOCCS",
          "PROJCS",
          "LOCAL_CS",
          "GEODCRS",
          "GEODETICCRS",
          "GEODETICDATUM",
          "ENGCRS",
          "ENGINEERINGCRS"
        ], Ht = ["3857", "900913", "3785", "102113"], Xt = function(t2, s2) {
          t2 = t2 || {};
          var i2, a2;
          if (!s2)
            return t2;
          for (a2 in s2)
            void 0 !== (i2 = s2[a2]) && (t2[a2] = i2);
          return t2;
        }, Kt = function(t2, s2, i2) {
          var a2 = t2 * s2;
          return i2 / Math.sqrt(1 - a2 * a2);
        }, Jt = function(t2) {
          return t2 < 0 ? -1 : 1;
        }, Vt = function(t2) {
          return Math.abs(t2) <= kt ? t2 : t2 - Jt(t2) * Ot;
        }, Zt = function(t2, s2, i2) {
          var a2 = t2 * i2, h2 = 0.5 * t2;
          return a2 = Math.pow((1 - a2) / (1 + a2), h2), Math.tan(0.5 * (wt - s2)) / a2;
        }, Yt = function(t2, s2) {
          for (var i2, a2, h2 = 0.5 * t2, e2 = wt - 2 * Math.atan(s2), n2 = 0; n2 <= 15; n2++)
            if (i2 = t2 * Math.sin(e2), a2 = wt - 2 * Math.atan(s2 * Math.pow((1 - i2) / (1 + i2), h2)) - e2, e2 += a2, Math.abs(a2) <= 1e-10)
              return e2;
          return -9999;
        }, $t = [{
          init: function() {
            var t2 = this.b / this.a;
            this.es = 1 - t2 * t2, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Kt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
          },
          forward: function(t2) {
            var s2 = t2.x, i2 = t2.y;
            if (i2 * St > 90 && i2 * St < -90 && s2 * St > 180 && s2 * St < -180)
              return null;
            var a2, h2;
            if (Math.abs(Math.abs(i2) - wt) <= Ct)
              return null;
            if (this.sphere)
              a2 = this.x0 + this.a * this.k0 * Vt(s2 - this.long0), h2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(It + 0.5 * i2));
            else {
              var e2 = Math.sin(i2), n2 = Zt(this.e, i2, e2);
              a2 = this.x0 + this.a * this.k0 * Vt(s2 - this.long0), h2 = this.y0 - this.a * this.k0 * Math.log(n2);
            }
            return t2.x = a2, t2.y = h2, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2 = t2.x - this.x0, h2 = t2.y - this.y0;
            if (this.sphere)
              i2 = wt - 2 * Math.atan(Math.exp(-h2 / (this.a * this.k0)));
            else {
              var e2 = Math.exp(-h2 / (this.a * this.k0));
              if (-9999 === (i2 = Yt(this.e, e2)))
                return null;
            }
            return s2 = Vt(this.long0 + a2 / (this.a * this.k0)), t2.x = s2, t2.y = i2, t2;
          },
          names: [
            "Mercator",
            "Popular Visualisation Pseudo Mercator",
            "Mercator_1SP",
            "Mercator_Auxiliary_Sphere",
            "merc"
          ]
        }, {
          init: function() {
          },
          forward: p,
          inverse: p,
          names: ["longlat", "identity"]
        }], ts = {}, ss = [], is = {
          start: function() {
            $t.forEach(y);
          },
          add: y,
          get: function(t2) {
            if (!t2)
              return false;
            var s2 = t2.toLowerCase();
            return void 0 !== ts[s2] && ss[ts[s2]] ? ss[ts[s2]] : void 0;
          }
        }, as = {};
        as.MERIT = {
          a: 6378137,
          rf: 298.257,
          ellipseName: "MERIT 1983"
        }, as.SGS85 = {
          a: 6378136,
          rf: 298.257,
          ellipseName: "Soviet Geodetic System 85"
        }, as.GRS80 = {
          a: 6378137,
          rf: 298.257222101,
          ellipseName: "GRS 1980(IUGG, 1980)"
        }, as.IAU76 = {
          a: 6378140,
          rf: 298.257,
          ellipseName: "IAU 1976"
        }, as.airy = {
          a: 6377563396e-3,
          b: 635625691e-2,
          ellipseName: "Airy 1830"
        }, as.APL4 = {
          a: 6378137,
          rf: 298.25,
          ellipseName: "Appl. Physics. 1965"
        }, as.NWL9D = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "Naval Weapons Lab., 1965"
        }, as.mod_airy = {
          a: 6377340189e-3,
          b: 6356034446e-3,
          ellipseName: "Modified Airy"
        }, as.andrae = {
          a: 637710443e-2,
          rf: 300,
          ellipseName: "Andrae 1876 (Den., Iclnd.)"
        }, as.aust_SA = {
          a: 6378160,
          rf: 298.25,
          ellipseName: "Australian Natl & S. Amer. 1969"
        }, as.GRS67 = {
          a: 6378160,
          rf: 298.247167427,
          ellipseName: "GRS 67(IUGG 1967)"
        }, as.bessel = {
          a: 6377397155e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841"
        }, as.bess_nam = {
          a: 6377483865e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841 (Namibia)"
        }, as.clrk66 = {
          a: 63782064e-1,
          b: 63565838e-1,
          ellipseName: "Clarke 1866"
        }, as.clrk80 = {
          a: 6378249145e-3,
          rf: 293.4663,
          ellipseName: "Clarke 1880 mod."
        }, as.clrk80ign = {
          a: 63782492e-1,
          b: 6356515,
          rf: 293.4660213,
          ellipseName: "Clarke 1880 (IGN)"
        }, as.clrk58 = {
          a: 6378293645208759e-9,
          rf: 294.2606763692654,
          ellipseName: "Clarke 1858"
        }, as.CPM = {
          a: 63757387e-1,
          rf: 334.29,
          ellipseName: "Comm. des Poids et Mesures 1799"
        }, as.delmbr = {
          a: 6376428,
          rf: 311.5,
          ellipseName: "Delambre 1810 (Belgium)"
        }, as.engelis = {
          a: 637813605e-2,
          rf: 298.2566,
          ellipseName: "Engelis 1985"
        }, as.evrst30 = {
          a: 6377276345e-3,
          rf: 300.8017,
          ellipseName: "Everest 1830"
        }, as.evrst48 = {
          a: 6377304063e-3,
          rf: 300.8017,
          ellipseName: "Everest 1948"
        }, as.evrst56 = {
          a: 6377301243e-3,
          rf: 300.8017,
          ellipseName: "Everest 1956"
        }, as.evrst69 = {
          a: 6377295664e-3,
          rf: 300.8017,
          ellipseName: "Everest 1969"
        }, as.evrstSS = {
          a: 6377298556e-3,
          rf: 300.8017,
          ellipseName: "Everest (Sabah & Sarawak)"
        }, as.fschr60 = {
          a: 6378166,
          rf: 298.3,
          ellipseName: "Fischer (Mercury Datum) 1960"
        }, as.fschr60m = {
          a: 6378155,
          rf: 298.3,
          ellipseName: "Fischer 1960"
        }, as.fschr68 = {
          a: 6378150,
          rf: 298.3,
          ellipseName: "Fischer 1968"
        }, as.helmert = {
          a: 6378200,
          rf: 298.3,
          ellipseName: "Helmert 1906"
        }, as.hough = {
          a: 6378270,
          rf: 297,
          ellipseName: "Hough"
        }, as.intl = {
          a: 6378388,
          rf: 297,
          ellipseName: "International 1909 (Hayford)"
        }, as.kaula = {
          a: 6378163,
          rf: 298.24,
          ellipseName: "Kaula 1961"
        }, as.lerch = {
          a: 6378139,
          rf: 298.257,
          ellipseName: "Lerch 1979"
        }, as.mprts = {
          a: 6397300,
          rf: 191,
          ellipseName: "Maupertius 1738"
        }, as.new_intl = {
          a: 63781575e-1,
          b: 63567722e-1,
          ellipseName: "New International 1967"
        }, as.plessis = {
          a: 6376523,
          rf: 6355863,
          ellipseName: "Plessis 1817 (France)"
        }, as.krass = {
          a: 6378245,
          rf: 298.3,
          ellipseName: "Krassovsky, 1942"
        }, as.SEasia = {
          a: 6378155,
          b: 63567733205e-4,
          ellipseName: "Southeast Asia"
        }, as.walbeck = {
          a: 6376896,
          b: 63558348467e-4,
          ellipseName: "Walbeck"
        }, as.WGS60 = {
          a: 6378165,
          rf: 298.3,
          ellipseName: "WGS 60"
        }, as.WGS66 = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "WGS 66"
        }, as.WGS7 = {
          a: 6378135,
          rf: 298.26,
          ellipseName: "WGS 72"
        };
        var hs = as.WGS84 = {
          a: 6378137,
          rf: 298.257223563,
          ellipseName: "WGS 84"
        };
        as.sphere = {
          a: 6370997,
          b: 6370997,
          ellipseName: "Normal Sphere (r=6370997)"
        };
        var es = {
          wgs84: {
            towgs84: "0,0,0",
            ellipse: "WGS84",
            datumName: "WGS84"
          },
          ch1903: {
            towgs84: "674.374,15.056,405.346",
            ellipse: "bessel",
            datumName: "swiss"
          },
          ggrs87: {
            towgs84: "-199.87,74.79,246.62",
            ellipse: "GRS80",
            datumName: "Greek_Geodetic_Reference_System_1987"
          },
          nad83: {
            towgs84: "0,0,0",
            ellipse: "GRS80",
            datumName: "North_American_Datum_1983"
          },
          nad27: {
            nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
            ellipse: "clrk66",
            datumName: "North_American_Datum_1927"
          },
          potsdam: {
            towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
            ellipse: "bessel",
            datumName: "Potsdam Rauenberg 1950 DHDN"
          },
          carthage: {
            towgs84: "-263.0,6.0,431.0",
            ellipse: "clark80",
            datumName: "Carthage 1934 Tunisia"
          },
          hermannskogel: {
            towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
            ellipse: "bessel",
            datumName: "Hermannskogel"
          },
          militargeographische_institut: {
            towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
            ellipse: "bessel",
            datumName: "Militar-Geographische Institut"
          },
          osni52: {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "airy",
            datumName: "Irish National"
          },
          ire65: {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "mod_airy",
            datumName: "Ireland 1965"
          },
          rassadiran: {
            towgs84: "-133.63,-157.5,-158.62",
            ellipse: "intl",
            datumName: "Rassadiran"
          },
          nzgd49: {
            towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
            ellipse: "intl",
            datumName: "New Zealand Geodetic Datum 1949"
          },
          osgb36: {
            towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
            ellipse: "airy",
            datumName: "Ordnance Survey of Great Britain 1936"
          },
          s_jtsk: {
            towgs84: "589,76,480",
            ellipse: "bessel",
            datumName: "S-JTSK (Ferro)"
          },
          beduaram: {
            towgs84: "-106,-87,188",
            ellipse: "clrk80",
            datumName: "Beduaram"
          },
          gunung_segara: {
            towgs84: "-403,684,41",
            ellipse: "bessel",
            datumName: "Gunung Segara Jakarta"
          },
          rnb72: {
            towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
            ellipse: "intl",
            datumName: "Reseau National Belge 1972"
          }
        };
        for (var ns in es) {
          var rs = es[ns];
          es[rs.datumName] = rs;
        }
        var os = {};
        Projection.projections = is, Projection.projections.start();
        var ls = function(t2, s2, i2) {
          if (O(t2, s2))
            return i2;
          if (t2.datum_type === vt || s2.datum_type === vt)
            return i2;
          var a2 = t2.a, h2 = t2.es;
          if (t2.datum_type === xt) {
            if (0 !== j(t2, false, i2))
              return;
            a2 = 6378137, h2 = 0.0066943799901413165;
          }
          var e2 = s2.a, n2 = s2.b, r2 = s2.es;
          return s2.datum_type === xt && (e2 = 6378137, n2 = 6356752314e-3, r2 = 0.0066943799901413165), h2 !== r2 || a2 !== e2 || G(t2.datum_type) || G(s2.datum_type) ? (i2 = k(i2, h2, a2), G(t2.datum_type) && (i2 = R(i2, t2.datum_type, t2.datum_params)), G(s2.datum_type) && (i2 = L2(i2, s2.datum_type, s2.datum_params)), i2 = q(i2, r2, e2, n2), s2.datum_type !== xt || 0 === j(s2, true, i2) ? i2 : void 0) : i2;
        }, us = function(t2, s2, i2) {
          var a2, h2, e2, n2 = i2.x, r2 = i2.y, o2 = i2.z || 0, l2 = {};
          for (e2 = 0; e2 < 3; e2++)
            if (!s2 || 2 !== e2 || void 0 !== i2.z)
              switch (0 === e2 ? (a2 = n2, h2 = -1 !== "ew".indexOf(t2.axis[e2]) ? "x" : "y") : 1 === e2 ? (a2 = r2, h2 = -1 !== "ns".indexOf(t2.axis[e2]) ? "y" : "x") : (a2 = o2, h2 = "z"), t2.axis[e2]) {
                case "e":
                  l2[h2] = a2;
                  break;
                case "w":
                  l2[h2] = -a2;
                  break;
                case "n":
                  l2[h2] = a2;
                  break;
                case "s":
                  l2[h2] = -a2;
                  break;
                case "u":
                  void 0 !== i2[h2] && (l2.z = a2);
                  break;
                case "d":
                  void 0 !== i2[h2] && (l2.z = -a2);
                  break;
                default:
                  return null;
              }
          return l2;
        }, cs = function(t2) {
          var s2 = {
            x: t2[0],
            y: t2[1]
          };
          return t2.length > 2 && (s2.z = t2[2]), t2.length > 3 && (s2.m = t2[3]), s2;
        }, Ms = function(t2) {
          z(t2.x), z(t2.y);
        }, fs = Projection("WGS84"), ds = 6, ms = "AJSAJS", ps = "AFAFAF", ys = 65, _s = 73, xs = 79, gs = 86, vs = 90, bs = {
          forward: H,
          inverse: function(t2) {
            var s2 = Z(at(t2.toUpperCase()));
            return s2.lat && s2.lon ? [s2.lon, s2.lat, s2.lon, s2.lat] : [s2.left, s2.bottom, s2.right, s2.top];
          },
          toPoint: X
        };
        Point.fromMGRS = function(t2) {
          return new Point(X(t2));
        }, Point.prototype.toMGRS = function(t2) {
          return H([this.x, this.y], t2);
        };
        var ws = 0.01068115234375, Ns = function(t2) {
          var s2 = [];
          s2[0] = 1 - t2 * (0.25 + t2 * (0.046875 + t2 * (0.01953125 + t2 * ws))), s2[1] = t2 * (0.75 - t2 * (0.046875 + t2 * (0.01953125 + t2 * ws)));
          var i2 = t2 * t2;
          return s2[2] = i2 * (0.46875 - t2 * (0.013020833333333334 + 0.007120768229166667 * t2)), i2 *= t2, s2[3] = i2 * (0.3645833333333333 - 0.005696614583333333 * t2), s2[4] = i2 * t2 * 0.3076171875, s2;
        }, Es = function(t2, s2, i2, a2) {
          return i2 *= s2, s2 *= s2, a2[0] * t2 - i2 * (a2[1] + s2 * (a2[2] + s2 * (a2[3] + s2 * a2[4])));
        }, As = function(t2, s2, i2) {
          for (var a2 = 1 / (1 - s2), h2 = t2, e2 = 20; e2; --e2) {
            var n2 = Math.sin(h2), r2 = 1 - s2 * n2 * n2;
            if (r2 = (Es(h2, n2, Math.cos(h2), i2) - t2) * (r2 * Math.sqrt(r2)) * a2, h2 -= r2, Math.abs(r2) < Ct)
              return h2;
          }
          return h2;
        }, Cs = {
          init: function() {
            this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.es && (this.en = Ns(this.es), this.ml0 = Es(
              this.lat0,
              Math.sin(this.lat0),
              Math.cos(this.lat0),
              this.en
            ));
          },
          forward: function(t2) {
            var s2, i2, a2, h2 = t2.x, e2 = t2.y, n2 = Vt(h2 - this.long0), r2 = Math.sin(e2), o2 = Math.cos(e2);
            if (this.es) {
              var l2 = o2 * n2, u2 = Math.pow(l2, 2), c2 = this.ep2 * Math.pow(o2, 2), M2 = Math.pow(c2, 2), f2 = Math.abs(o2) > Ct ? Math.tan(e2) : 0, d2 = Math.pow(f2, 2), m2 = Math.pow(d2, 2);
              s2 = 1 - this.es * Math.pow(r2, 2), l2 /= Math.sqrt(s2);
              var p2 = Es(e2, r2, o2, this.en);
              i2 = this.a * (this.k0 * l2 * (1 + u2 / 6 * (1 - d2 + c2 + u2 / 20 * (5 - 18 * d2 + m2 + 14 * c2 - 58 * d2 * c2 + u2 / 42 * (61 + 179 * m2 - m2 * d2 - 479 * d2))))) + this.x0, a2 = this.a * (this.k0 * (p2 - this.ml0 + r2 * n2 * l2 / 2 * (1 + u2 / 12 * (5 - d2 + 9 * c2 + 4 * M2 + u2 / 30 * (61 + m2 - 58 * d2 + 270 * c2 - 330 * d2 * c2 + u2 / 56 * (1385 + 543 * m2 - m2 * d2 - 3111 * d2)))))) + this.y0;
            } else {
              var y2 = o2 * Math.sin(n2);
              if (Math.abs(Math.abs(y2) - 1) < Ct)
                return 93;
              if (i2 = 0.5 * this.a * this.k0 * Math.log((1 + y2) / (1 - y2)) + this.x0, a2 = o2 * Math.cos(n2) / Math.sqrt(1 - Math.pow(y2, 2)), (y2 = Math.abs(a2)) >= 1) {
                if (y2 - 1 > Ct)
                  return 93;
                a2 = 0;
              } else
                a2 = Math.acos(a2);
              e2 < 0 && (a2 = -a2), a2 = this.a * this.k0 * (a2 - this.lat0) + this.y0;
            }
            return t2.x = i2, t2.y = a2, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2 = (t2.x - this.x0) * (1 / this.a), n2 = (t2.y - this.y0) * (1 / this.a);
            if (this.es)
              if (s2 = this.ml0 + n2 / this.k0, i2 = As(s2, this.es, this.en), Math.abs(i2) < wt) {
                var r2 = Math.sin(i2), o2 = Math.cos(i2), l2 = Math.abs(o2) > Ct ? Math.tan(i2) : 0, u2 = this.ep2 * Math.pow(o2, 2), c2 = Math.pow(u2, 2), M2 = Math.pow(l2, 2), f2 = Math.pow(M2, 2);
                s2 = 1 - this.es * Math.pow(r2, 2);
                var d2 = e2 * Math.sqrt(s2) / this.k0, m2 = Math.pow(d2, 2);
                a2 = i2 - (s2 *= l2) * m2 / (1 - this.es) * 0.5 * (1 - m2 / 12 * (5 + 3 * M2 - 9 * u2 * M2 + u2 - 4 * c2 - m2 / 30 * (61 + 90 * M2 - 252 * u2 * M2 + 45 * f2 + 46 * u2 - m2 / 56 * (1385 + 3633 * M2 + 4095 * f2 + 1574 * f2 * M2)))), h2 = Vt(this.long0 + d2 * (1 - m2 / 6 * (1 + 2 * M2 + u2 - m2 / 20 * (5 + 28 * M2 + 24 * f2 + 8 * u2 * M2 + 6 * u2 - m2 / 42 * (61 + 662 * M2 + 1320 * f2 + 720 * f2 * M2)))) / o2);
              } else
                a2 = wt * Jt(n2), h2 = 0;
            else {
              var p2 = Math.exp(e2 / this.k0), y2 = 0.5 * (p2 - 1 / p2), _2 = this.lat0 + n2 / this.k0, x2 = Math.cos(_2);
              s2 = Math.sqrt((1 - Math.pow(x2, 2)) / (1 + Math.pow(y2, 2))), a2 = Math.asin(s2), n2 < 0 && (a2 = -a2), h2 = 0 === y2 && 0 === x2 ? 0 : Vt(Math.atan2(y2, x2) + this.long0);
            }
            return t2.x = h2, t2.y = a2, t2;
          },
          names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"]
        }, Ps = function(t2) {
          var s2 = Math.exp(t2);
          return s2 = (s2 - 1 / s2) / 2;
        }, Ss = function(t2, s2) {
          t2 = Math.abs(t2), s2 = Math.abs(s2);
          var i2 = Math.max(t2, s2), a2 = Math.min(t2, s2) / (i2 || 1);
          return i2 * Math.sqrt(1 + Math.pow(a2, 2));
        }, Is = function(t2) {
          var s2 = 1 + t2, i2 = s2 - 1;
          return 0 === i2 ? t2 : t2 * Math.log(s2) / i2;
        }, Os = function(t2) {
          var s2 = Math.abs(t2);
          return s2 = Is(s2 * (1 + s2 / (Ss(1, s2) + 1))), t2 < 0 ? -s2 : s2;
        }, ks = function(t2, s2) {
          for (var i2, a2 = 2 * Math.cos(2 * s2), h2 = t2.length - 1, e2 = t2[h2], n2 = 0; --h2 >= 0; )
            i2 = a2 * e2 - n2 + t2[h2], n2 = e2, e2 = i2;
          return s2 + i2 * Math.sin(2 * s2);
        }, qs = function(t2, s2) {
          for (var i2, a2 = 2 * Math.cos(s2), h2 = t2.length - 1, e2 = t2[h2], n2 = 0; --h2 >= 0; )
            i2 = a2 * e2 - n2 + t2[h2], n2 = e2, e2 = i2;
          return Math.sin(s2) * i2;
        }, Rs = function(t2) {
          var s2 = Math.exp(t2);
          return s2 = (s2 + 1 / s2) / 2;
        }, Ls = function(t2, s2, i2) {
          for (var a2, h2, e2 = Math.sin(s2), n2 = Math.cos(s2), r2 = Ps(i2), o2 = Rs(i2), l2 = 2 * n2 * o2, u2 = -2 * e2 * r2, c2 = t2.length - 1, M2 = t2[c2], f2 = 0, d2 = 0, m2 = 0; --c2 >= 0; )
            a2 = d2, h2 = f2, M2 = l2 * (d2 = M2) - a2 - u2 * (f2 = m2) + t2[c2], m2 = u2 * d2 - h2 + l2 * f2;
          return l2 = e2 * o2, u2 = n2 * r2, [l2 * M2 - u2 * m2, l2 * m2 + u2 * M2];
        }, Gs = {
          init: function() {
            if (!this.approx && (isNaN(this.es) || this.es <= 0))
              throw new Error(
                'Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.'
              );
            this.approx && (Cs.init.apply(this), this.forward = Cs.forward, this.inverse = Cs.inverse), this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
            var t2 = this.es / (1 + Math.sqrt(1 - this.es)), s2 = t2 / (2 - t2), i2 = s2;
            this.cgb[0] = s2 * (2 + s2 * (-2 / 3 + s2 * (s2 * (116 / 45 + s2 * (26 / 45 + s2 * (-2854 / 675))) - 2))), this.cbg[0] = s2 * (s2 * (2 / 3 + s2 * (4 / 3 + s2 * (-82 / 45 + s2 * (32 / 45 + s2 * (4642 / 4725))))) - 2), i2 *= s2, this.cgb[1] = i2 * (7 / 3 + s2 * (s2 * (-227 / 45 + s2 * (2704 / 315 + s2 * (2323 / 945))) - 1.6)), this.cbg[1] = i2 * (5 / 3 + s2 * (-16 / 15 + s2 * (-13 / 9 + s2 * (904 / 315 + s2 * (-1522 / 945))))), i2 *= s2, this.cgb[2] = i2 * (56 / 15 + s2 * (-136 / 35 + s2 * (-1262 / 105 + s2 * (73814 / 2835)))), this.cbg[2] = i2 * (-26 / 15 + s2 * (34 / 21 + s2 * (1.6 + s2 * (-12686 / 2835)))), i2 *= s2, this.cgb[3] = i2 * (4279 / 630 + s2 * (-332 / 35 + s2 * (-399572 / 14175))), this.cbg[3] = i2 * (1237 / 630 + s2 * (s2 * (-24832 / 14175) - 2.4)), i2 *= s2, this.cgb[4] = i2 * (4174 / 315 + s2 * (-144838 / 6237)), this.cbg[4] = i2 * (-734 / 315 + s2 * (109598 / 31185)), i2 *= s2, this.cgb[5] = i2 * (601676 / 22275), this.cbg[5] = i2 * (444337 / 155925), i2 = Math.pow(s2, 2), this.Qn = this.k0 / (1 + s2) * (1 + i2 * (0.25 + i2 * (1 / 64 + i2 / 256))), this.utg[0] = s2 * (s2 * (2 / 3 + s2 * (-37 / 96 + s2 * (1 / 360 + s2 * (81 / 512 + s2 * (-96199 / 604800))))) - 0.5), this.gtu[0] = s2 * (0.5 + s2 * (-2 / 3 + s2 * (5 / 16 + s2 * (41 / 180 + s2 * (-127 / 288 + s2 * (7891 / 37800)))))), this.utg[1] = i2 * (-1 / 48 + s2 * (-1 / 15 + s2 * (437 / 1440 + s2 * (-46 / 105 + s2 * (1118711 / 3870720))))), this.gtu[1] = i2 * (13 / 48 + s2 * (s2 * (557 / 1440 + s2 * (281 / 630 + s2 * (-1983433 / 1935360))) - 0.6)), i2 *= s2, this.utg[2] = i2 * (-17 / 480 + s2 * (37 / 840 + s2 * (209 / 4480 + s2 * (-5569 / 90720)))), this.gtu[2] = i2 * (61 / 240 + s2 * (-103 / 140 + s2 * (15061 / 26880 + s2 * (167603 / 181440)))), i2 *= s2, this.utg[3] = i2 * (-4397 / 161280 + s2 * (11 / 504 + s2 * (830251 / 7257600))), this.gtu[3] = i2 * (49561 / 161280 + s2 * (-179 / 168 + s2 * (6601661 / 7257600))), i2 *= s2, this.utg[4] = i2 * (-4583 / 161280 + s2 * (108847 / 3991680)), this.gtu[4] = i2 * (34729 / 80640 + s2 * (-3418889 / 1995840)), i2 *= s2, this.utg[5] = -0.03233083094085698 * i2, this.gtu[5] = 0.6650675310896665 * i2;
            var a2 = ks(this.cbg, this.lat0);
            this.Zb = -this.Qn * (a2 + qs(this.gtu, 2 * a2));
          },
          forward: function(t2) {
            var s2 = Vt(t2.x - this.long0), i2 = t2.y;
            i2 = ks(this.cbg, i2);
            var a2 = Math.sin(i2), h2 = Math.cos(i2), e2 = Math.sin(s2), n2 = Math.cos(s2);
            i2 = Math.atan2(a2, n2 * h2), s2 = Math.atan2(e2 * h2, Ss(a2, h2 * n2)), s2 = Os(Math.tan(s2));
            var r2 = Ls(this.gtu, 2 * i2, 2 * s2);
            i2 += r2[0], s2 += r2[1];
            var o2, l2;
            return Math.abs(s2) <= 2.623395162778 ? (o2 = this.a * (this.Qn * s2) + this.x0, l2 = this.a * (this.Qn * i2 + this.Zb) + this.y0) : (o2 = 1 / 0, l2 = 1 / 0), t2.x = o2, t2.y = l2, t2;
          },
          inverse: function(t2) {
            var s2 = (t2.x - this.x0) * (1 / this.a), i2 = (t2.y - this.y0) * (1 / this.a);
            i2 = (i2 - this.Zb) / this.Qn, s2 /= this.Qn;
            var a2, h2;
            if (Math.abs(s2) <= 2.623395162778) {
              var e2 = Ls(this.utg, 2 * i2, 2 * s2);
              i2 += e2[0], s2 += e2[1], s2 = Math.atan(Ps(s2));
              var n2 = Math.sin(i2), r2 = Math.cos(i2), o2 = Math.sin(s2), l2 = Math.cos(s2);
              i2 = Math.atan2(n2 * l2, Ss(o2, l2 * r2)), s2 = Math.atan2(o2, l2 * r2), a2 = Vt(s2 + this.long0), h2 = ks(this.cgb, i2);
            } else
              a2 = 1 / 0, h2 = 1 / 0;
            return t2.x = a2, t2.y = h2, t2;
          },
          names: [
            "Extended_Transverse_Mercator",
            "Extended Transverse Mercator",
            "etmerc",
            "Transverse_Mercator",
            "Transverse Mercator",
            "Gauss Kruger",
            "Gauss_Kruger",
            "tmerc"
          ]
        }, js = function(t2, s2) {
          if (void 0 === t2) {
            if ((t2 = Math.floor(30 * (Vt(s2) + Math.PI) / Math.PI) + 1) < 0)
              return 0;
            if (t2 > 60)
              return 60;
          }
          return t2;
        }, Ts = {
          init: function() {
            var t2 = js(this.zone, this.long0);
            if (void 0 === t2)
              throw new Error("unknown utm zone");
            this.lat0 = 0, this.long0 = (6 * Math.abs(t2) - 183) * Pt, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, Gs.init.apply(this), this.forward = Gs.forward, this.inverse = Gs.inverse;
          },
          names: ["Universal Transverse Mercator System", "utm"],
          dependsOn: "etmerc"
        }, Bs = function(t2, s2) {
          return Math.pow((1 - t2) / (1 + t2), s2);
        }, zs = 20, Fs = {
          init: function() {
            var t2 = Math.sin(this.lat0), s2 = Math.cos(this.lat0);
            s2 *= s2, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t2 * t2), this.C = Math.sqrt(1 + this.es * s2 * s2 / (1 - this.es)), this.phic0 = Math.asin(t2 / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + It) / (Math.pow(Math.tan(0.5 * this.lat0 + It), this.C) * Bs(this.e * t2, this.ratexp));
          },
          forward: function(t2) {
            var s2 = t2.x, i2 = t2.y;
            return t2.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * i2 + It), this.C) * Bs(this.e * Math.sin(i2), this.ratexp)) - wt, t2.x = this.C * s2, t2;
          },
          inverse: function(t2) {
            for (var s2 = t2.x / this.C, i2 = t2.y, a2 = Math.pow(Math.tan(0.5 * i2 + It) / this.K, 1 / this.C), h2 = zs; h2 > 0 && (i2 = 2 * Math.atan(a2 * Bs(this.e * Math.sin(t2.y), -0.5 * this.e)) - wt, !(Math.abs(i2 - t2.y) < 1e-14)); --h2)
              t2.y = i2;
            return h2 ? (t2.x = s2, t2.y = i2, t2) : null;
          },
          names: ["gauss"]
        }, Ds = {
          init: function() {
            Fs.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
          },
          forward: function(t2) {
            var s2, i2, a2, h2;
            return t2.x = Vt(t2.x - this.long0), Fs.forward.apply(this, [t2]), s2 = Math.sin(t2.y), i2 = Math.cos(
              t2.y
            ), a2 = Math.cos(t2.x), h2 = this.k0 * this.R2 / (1 + this.sinc0 * s2 + this.cosc0 * i2 * a2), t2.x = h2 * i2 * Math.sin(t2.x), t2.y = h2 * (this.cosc0 * s2 - this.sinc0 * i2 * a2), t2.x = this.a * t2.x + this.x0, t2.y = this.a * t2.y + this.y0, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2;
            if (t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, t2.x /= this.k0, t2.y /= this.k0, e2 = Ss(t2.x, t2.y)) {
              var n2 = 2 * Math.atan2(e2, this.R2);
              s2 = Math.sin(n2), i2 = Math.cos(n2), h2 = Math.asin(i2 * this.sinc0 + t2.y * s2 * this.cosc0 / e2), a2 = Math.atan2(t2.x * s2, e2 * this.cosc0 * i2 - t2.y * this.sinc0 * s2);
            } else
              h2 = this.phic0, a2 = 0;
            return t2.x = a2, t2.y = h2, Fs.inverse.apply(this, [t2]), t2.x = Vt(t2.x + this.long0), t2;
          },
          names: [
            "Stereographic_North_Pole",
            "Oblique_Stereographic",
            "sterea",
            "Oblique Stereographic Alternative",
            "Double_Stereographic"
          ]
        }, Us = {
          init: function() {
            this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * (1 + Jt(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Ct && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(
              this.lat_ts
            ) && Math.abs(this.coslat0) <= Ct && Math.abs(Math.cos(this.lat_ts)) > Ct && (this.k0 = 0.5 * this.cons * Kt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Zt(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Kt(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - wt, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2 = t2.x, o2 = t2.y, l2 = Math.sin(o2), u2 = Math.cos(o2), c2 = Vt(r2 - this.long0);
            return Math.abs(Math.abs(r2 - this.long0) - Math.PI) <= Ct && Math.abs(o2 + this.lat0) <= Ct ? (t2.x = NaN, t2.y = NaN, t2) : this.sphere ? (s2 = 2 * this.k0 / (1 + this.sinlat0 * l2 + this.coslat0 * u2 * Math.cos(c2)), t2.x = this.a * s2 * u2 * Math.sin(c2) + this.x0, t2.y = this.a * s2 * (this.coslat0 * l2 - this.sinlat0 * u2 * Math.cos(c2)) + this.y0, t2) : (i2 = 2 * Math.atan(this.ssfn_(o2, l2, this.e)) - wt, h2 = Math.cos(i2), a2 = Math.sin(i2), Math.abs(this.coslat0) <= Ct ? (e2 = Zt(this.e, o2 * this.con, this.con * l2), n2 = 2 * this.a * this.k0 * e2 / this.cons, t2.x = this.x0 + n2 * Math.sin(r2 - this.long0), t2.y = this.y0 - this.con * n2 * Math.cos(r2 - this.long0), t2) : (Math.abs(this.sinlat0) < Ct ? (s2 = 2 * this.a * this.k0 / (1 + h2 * Math.cos(c2)), t2.y = s2 * a2) : (s2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * a2 + this.cosX0 * h2 * Math.cos(c2))), t2.y = s2 * (this.cosX0 * a2 - this.sinX0 * h2 * Math.cos(c2)) + this.y0), t2.x = s2 * h2 * Math.sin(c2) + this.x0, t2));
          },
          inverse: function(t2) {
            t2.x -= this.x0, t2.y -= this.y0;
            var s2, i2, a2, h2, e2, n2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y);
            if (this.sphere) {
              var r2 = 2 * Math.atan(n2 / (2 * this.a * this.k0));
              return s2 = this.long0, i2 = this.lat0, n2 <= Ct ? (t2.x = s2, t2.y = i2, t2) : (i2 = Math.asin(Math.cos(r2) * this.sinlat0 + t2.y * Math.sin(r2) * this.coslat0 / n2), s2 = Vt(Math.abs(
                this.coslat0
              ) < Ct ? this.lat0 > 0 ? this.long0 + Math.atan2(t2.x, -1 * t2.y) : this.long0 + Math.atan2(t2.x, t2.y) : this.long0 + Math.atan2(t2.x * Math.sin(r2), n2 * this.coslat0 * Math.cos(r2) - t2.y * this.sinlat0 * Math.sin(r2))), t2.x = s2, t2.y = i2, t2);
            }
            if (Math.abs(this.coslat0) <= Ct) {
              if (n2 <= Ct)
                return i2 = this.lat0, s2 = this.long0, t2.x = s2, t2.y = i2, t2;
              t2.x *= this.con, t2.y *= this.con, a2 = n2 * this.cons / (2 * this.a * this.k0), i2 = this.con * Yt(this.e, a2), s2 = this.con * Vt(this.con * this.long0 + Math.atan2(t2.x, -1 * t2.y));
            } else
              h2 = 2 * Math.atan(n2 * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), s2 = this.long0, n2 <= Ct ? e2 = this.X0 : (e2 = Math.asin(Math.cos(h2) * this.sinX0 + t2.y * Math.sin(h2) * this.cosX0 / n2), s2 = Vt(this.long0 + Math.atan2(t2.x * Math.sin(h2), n2 * this.cosX0 * Math.cos(h2) - t2.y * this.sinX0 * Math.sin(h2)))), i2 = -1 * Yt(this.e, Math.tan(0.5 * (wt + e2)));
            return t2.x = s2, t2.y = i2, t2;
          },
          names: ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"],
          ssfn_: function(t2, s2, i2) {
            return s2 *= i2, Math.tan(0.5 * (wt + t2)) * Math.pow((1 - s2) / (1 + s2), 0.5 * i2);
          }
        }, Qs = {
          init: function() {
            var t2 = this.lat0;
            this.lambda0 = this.long0;
            var s2 = Math.sin(t2), i2 = this.a, a2 = 1 / this.rf, h2 = 2 * a2 - Math.pow(a2, 2), e2 = this.e = Math.sqrt(h2);
            this.R = this.k0 * i2 * Math.sqrt(1 - h2) / (1 - h2 * Math.pow(s2, 2)), this.alpha = Math.sqrt(1 + h2 / (1 - h2) * Math.pow(Math.cos(t2), 4)), this.b0 = Math.asin(s2 / this.alpha);
            var n2 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), r2 = Math.log(Math.tan(Math.PI / 4 + t2 / 2)), o2 = Math.log((1 + e2 * s2) / (1 - e2 * s2));
            this.K = n2 - this.alpha * r2 + this.alpha * e2 / 2 * o2;
          },
          forward: function(t2) {
            var s2 = Math.log(Math.tan(Math.PI / 4 - t2.y / 2)), i2 = this.e / 2 * Math.log((1 + this.e * Math.sin(t2.y)) / (1 - this.e * Math.sin(t2.y))), a2 = -this.alpha * (s2 + i2) + this.K, h2 = 2 * (Math.atan(Math.exp(a2)) - Math.PI / 4), e2 = this.alpha * (t2.x - this.lambda0), n2 = Math.atan(Math.sin(e2) / (Math.sin(this.b0) * Math.tan(h2) + Math.cos(this.b0) * Math.cos(
              e2
            ))), r2 = Math.asin(Math.cos(this.b0) * Math.sin(h2) - Math.sin(this.b0) * Math.cos(h2) * Math.cos(
              e2
            ));
            return t2.y = this.R / 2 * Math.log((1 + Math.sin(r2)) / (1 - Math.sin(r2))) + this.y0, t2.x = this.R * n2 + this.x0, t2;
          },
          inverse: function(t2) {
            for (var s2 = t2.x - this.x0, i2 = t2.y - this.y0, a2 = s2 / this.R, h2 = 2 * (Math.atan(Math.exp(i2 / this.R)) - Math.PI / 4), e2 = Math.asin(Math.cos(this.b0) * Math.sin(h2) + Math.sin(
              this.b0
            ) * Math.cos(h2) * Math.cos(a2)), n2 = Math.atan(Math.sin(a2) / (Math.cos(this.b0) * Math.cos(a2) - Math.sin(this.b0) * Math.tan(h2))), r2 = this.lambda0 + n2 / this.alpha, o2 = 0, l2 = e2, u2 = -1e3, c2 = 0; Math.abs(l2 - u2) > 1e-7; ) {
              if (++c2 > 20)
                return;
              o2 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + e2 / 2)) - this.K) + this.e * Math.log(
                Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l2)) / 2)
              ), u2 = l2, l2 = 2 * Math.atan(Math.exp(o2)) - Math.PI / 2;
            }
            return t2.x = r2, t2.y = l2, t2;
          },
          names: ["somerc"]
        }, Ws = 1e-7, Hs = {
          init: function() {
            var t2, s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2 = 0, M2 = 0, f2 = 0, d2 = 0, m2 = 0, p2 = 0, y2 = 0;
            this.no_off = rt(this), this.no_rot = "no_rot" in this;
            var _2 = false;
            "alpha" in this && (_2 = true);
            var x2 = false;
            if ("rectified_grid_angle" in this && (x2 = true), _2 && (y2 = this.alpha), x2 && (c2 = this.rectified_grid_angle * Pt), _2 || x2)
              M2 = this.longc;
            else if (f2 = this.long1, m2 = this.lat1, d2 = this.long2, p2 = this.lat2, Math.abs(m2 - p2) <= Ws || (t2 = Math.abs(m2)) <= Ws || Math.abs(t2 - wt) <= Ws || Math.abs(Math.abs(this.lat0) - wt) <= Ws || Math.abs(Math.abs(p2) - wt) <= Ws)
              throw new Error();
            var g2 = 1 - this.es;
            s2 = Math.sqrt(g2), Math.abs(this.lat0) > Ct ? (r2 = Math.sin(this.lat0), i2 = Math.cos(this.lat0), t2 = 1 - this.es * r2 * r2, this.B = i2 * i2, this.B = Math.sqrt(1 + this.es * this.B * this.B / g2), this.A = this.B * this.k0 * s2 / t2, (h2 = (a2 = this.B * s2 / (i2 * Math.sqrt(
              t2
            ))) * a2 - 1) <= 0 ? h2 = 0 : (h2 = Math.sqrt(h2), this.lat0 < 0 && (h2 = -h2)), this.E = h2 += a2, this.E *= Math.pow(Zt(this.e, this.lat0, r2), this.B)) : (this.B = 1 / s2, this.A = this.k0, this.E = a2 = h2 = 1), _2 || x2 ? (_2 ? (u2 = Math.asin(Math.sin(y2) / a2), x2 || (c2 = y2)) : (u2 = c2, y2 = Math.asin(a2 * Math.sin(u2))), this.lam0 = M2 - Math.asin(0.5 * (h2 - 1 / h2) * Math.tan(u2)) / this.B) : (e2 = Math.pow(Zt(this.e, m2, Math.sin(m2)), this.B), n2 = Math.pow(Zt(this.e, p2, Math.sin(p2)), this.B), h2 = this.E / e2, o2 = (n2 - e2) / (n2 + e2), l2 = ((l2 = this.E * this.E) - n2 * e2) / (l2 + n2 * e2), (t2 = f2 - d2) < -Math.pi ? d2 -= Ot : t2 > Math.pi && (d2 += Ot), this.lam0 = Vt(0.5 * (f2 + d2) - Math.atan(l2 * Math.tan(0.5 * this.B * (f2 - d2)) / o2) / this.B), u2 = Math.atan(2 * Math.sin(this.B * Vt(f2 - this.lam0)) / (h2 - 1 / h2)), c2 = y2 = Math.asin(a2 * Math.sin(u2))), this.singam = Math.sin(
              u2
            ), this.cosgam = Math.cos(u2), this.sinrot = Math.sin(c2), this.cosrot = Math.cos(c2), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(a2 * a2 - 1) / Math.cos(
              y2
            ))), this.lat0 < 0 && (this.u_0 = -this.u_0)), h2 = 0.5 * u2, this.v_pole_n = this.ArB * Math.log(Math.tan(It - h2)), this.v_pole_s = this.ArB * Math.log(Math.tan(It + h2));
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2, l2 = {};
            if (t2.x = t2.x - this.lam0, Math.abs(Math.abs(t2.y) - wt) > Ct) {
              if (e2 = this.E / Math.pow(Zt(this.e, t2.y, Math.sin(t2.y)), this.B), n2 = 1 / e2, s2 = 0.5 * (e2 - n2), i2 = 0.5 * (e2 + n2), h2 = Math.sin(this.B * t2.x), a2 = (s2 * this.singam - h2 * this.cosgam) / i2, Math.abs(Math.abs(a2) - 1) < Ct)
                throw new Error();
              o2 = 0.5 * this.ArB * Math.log((1 - a2) / (1 + a2)), n2 = Math.cos(this.B * t2.x), r2 = Math.abs(
                n2
              ) < Ws ? this.A * t2.x : this.ArB * Math.atan2(s2 * this.cosgam + h2 * this.singam, n2);
            } else
              o2 = t2.y > 0 ? this.v_pole_n : this.v_pole_s, r2 = this.ArB * t2.y;
            return this.no_rot ? (l2.x = r2, l2.y = o2) : (r2 -= this.u_0, l2.x = o2 * this.cosrot + r2 * this.sinrot, l2.y = r2 * this.cosrot - o2 * this.sinrot), l2.x = this.a * l2.x + this.x0, l2.y = this.a * l2.y + this.y0, l2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2 = {};
            if (t2.x = (t2.x - this.x0) * (1 / this.a), t2.y = (t2.y - this.y0) * (1 / this.a), this.no_rot ? (i2 = t2.y, s2 = t2.x) : (i2 = t2.x * this.cosrot - t2.y * this.sinrot, s2 = t2.y * this.cosrot + t2.x * this.sinrot + this.u_0), a2 = Math.exp(-this.BrA * i2), h2 = 0.5 * (a2 - 1 / a2), e2 = 0.5 * (a2 + 1 / a2), n2 = Math.sin(this.BrA * s2), r2 = (n2 * this.cosgam + h2 * this.singam) / e2, Math.abs(Math.abs(r2) - 1) < Ct)
              o2.x = 0, o2.y = r2 < 0 ? -wt : wt;
            else {
              if (o2.y = this.E / Math.sqrt((1 + r2) / (1 - r2)), o2.y = Yt(this.e, Math.pow(o2.y, 1 / this.B)), o2.y === 1 / 0)
                throw new Error();
              o2.x = -this.rB * Math.atan2(h2 * this.cosgam - n2 * this.singam, Math.cos(this.BrA * s2));
            }
            return o2.x += this.lam0, o2;
          },
          names: [
            "Hotine_Oblique_Mercator",
            "Hotine Oblique Mercator",
            "Hotine_Oblique_Mercator_Azimuth_Natural_Origin",
            "Hotine_Oblique_Mercator_Two_Point_Natural_Origin",
            "Hotine_Oblique_Mercator_Azimuth_Center",
            "Oblique_Mercator",
            "omerc"
          ]
        }, Xs = {
          init: function() {
            if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Ct)) {
              var t2 = this.b / this.a;
              this.e = Math.sqrt(1 - t2 * t2);
              var s2 = Math.sin(this.lat1), i2 = Math.cos(this.lat1), a2 = Kt(this.e, s2, i2), h2 = Zt(this.e, this.lat1, s2), e2 = Math.sin(this.lat2), n2 = Math.cos(this.lat2), r2 = Kt(this.e, e2, n2), o2 = Zt(this.e, this.lat2, e2), l2 = Zt(this.e, this.lat0, Math.sin(this.lat0));
              Math.abs(this.lat1 - this.lat2) > Ct ? this.ns = Math.log(a2 / r2) / Math.log(h2 / o2) : this.ns = s2, isNaN(this.ns) && (this.ns = s2), this.f0 = a2 / (this.ns * Math.pow(h2, this.ns)), this.rh = this.a * this.f0 * Math.pow(l2, this.ns), this.title || (this.title = "Lambert Conformal Conic");
            }
          },
          forward: function(t2) {
            var s2 = t2.x, i2 = t2.y;
            Math.abs(2 * Math.abs(i2) - Math.PI) <= Ct && (i2 = Jt(i2) * (wt - 2 * Ct));
            var a2, h2, e2 = Math.abs(Math.abs(i2) - wt);
            if (e2 > Ct)
              a2 = Zt(this.e, i2, Math.sin(i2)), h2 = this.a * this.f0 * Math.pow(a2, this.ns);
            else {
              if ((e2 = i2 * this.ns) <= 0)
                return null;
              h2 = 0;
            }
            var n2 = this.ns * Vt(s2 - this.long0);
            return t2.x = this.k0 * (h2 * Math.sin(n2)) + this.x0, t2.y = this.k0 * (this.rh - h2 * Math.cos(
              n2
            )) + this.y0, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2 = (t2.x - this.x0) / this.k0, r2 = this.rh - (t2.y - this.y0) / this.k0;
            this.ns > 0 ? (s2 = Math.sqrt(n2 * n2 + r2 * r2), i2 = 1) : (s2 = -Math.sqrt(n2 * n2 + r2 * r2), i2 = -1);
            var o2 = 0;
            if (0 !== s2 && (o2 = Math.atan2(i2 * n2, i2 * r2)), 0 !== s2 || this.ns > 0) {
              if (i2 = 1 / this.ns, a2 = Math.pow(s2 / (this.a * this.f0), i2), -9999 === (h2 = Yt(this.e, a2)))
                return null;
            } else
              h2 = -wt;
            return e2 = Vt(o2 / this.ns + this.long0), t2.x = e2, t2.y = h2, t2;
          },
          names: [
            "Lambert Tangential Conformal Conic Projection",
            "Lambert_Conformal_Conic",
            "Lambert_Conformal_Conic_1SP",
            "Lambert_Conformal_Conic_2SP",
            "lcc",
            "Lambert Conic Conformal (1SP)",
            "Lambert Conic Conformal (2SP)"
          ]
        }, Ks = {
          init: function() {
            this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.4334234309119251), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(
              this.fi0
            )) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(
              Math.sin(this.fi0),
              2
            )), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y, u2 = Vt(o2 - this.long0);
            return s2 = Math.pow((1 + this.e * Math.sin(l2)) / (1 - this.e * Math.sin(l2)), this.alfa * this.e / 2), i2 = 2 * (Math.atan(this.k * Math.pow(Math.tan(l2 / 2 + this.s45), this.alfa) / s2) - this.s45), a2 = -u2 * this.alfa, h2 = Math.asin(Math.cos(this.ad) * Math.sin(i2) + Math.sin(this.ad) * Math.cos(i2) * Math.cos(a2)), e2 = Math.asin(Math.cos(i2) * Math.sin(a2) / Math.cos(h2)), n2 = this.n * e2, r2 = this.ro0 * Math.pow(
              Math.tan(this.s0 / 2 + this.s45),
              this.n
            ) / Math.pow(Math.tan(h2 / 2 + this.s45), this.n), t2.y = r2 * Math.cos(n2) / 1, t2.x = r2 * Math.sin(n2) / 1, this.czech || (t2.y *= -1, t2.x *= -1), t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x;
            t2.x = t2.y, t2.y = o2, this.czech || (t2.y *= -1, t2.x *= -1), e2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), h2 = Math.atan2(t2.y, t2.x) / Math.sin(this.s0), a2 = 2 * (Math.atan(Math.pow(this.ro0 / e2, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), s2 = Math.asin(Math.cos(this.ad) * Math.sin(a2) - Math.sin(this.ad) * Math.cos(a2) * Math.cos(h2)), i2 = Math.asin(Math.cos(a2) * Math.sin(h2) / Math.cos(s2)), t2.x = this.long0 - i2 / this.alfa, n2 = s2, r2 = 0;
            var l2 = 0;
            do {
              t2.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(
                Math.tan(s2 / 2 + this.s45),
                1 / this.alfa
              ) * Math.pow((1 + this.e * Math.sin(n2)) / (1 - this.e * Math.sin(n2)), this.e / 2)) - this.s45), Math.abs(n2 - t2.y) < 1e-10 && (r2 = 1), n2 = t2.y, l2 += 1;
            } while (0 === r2 && l2 < 15);
            return l2 >= 15 ? null : t2;
          },
          names: ["Krovak", "krovak"]
        }, Js = function(t2, s2, i2, a2, h2) {
          return t2 * h2 - s2 * Math.sin(2 * h2) + i2 * Math.sin(4 * h2) - a2 * Math.sin(6 * h2);
        }, Vs = function(t2) {
          return 1 - 0.25 * t2 * (1 + t2 / 16 * (3 + 1.25 * t2));
        }, Zs = function(t2) {
          return 0.375 * t2 * (1 + 0.25 * t2 * (1 + 0.46875 * t2));
        }, Ys = function(t2) {
          return 0.05859375 * t2 * t2 * (1 + 0.75 * t2);
        }, $s = function(t2) {
          return t2 * t2 * t2 * (35 / 3072);
        }, ti = function(t2, s2, i2) {
          var a2 = s2 * i2;
          return t2 / Math.sqrt(1 - a2 * a2);
        }, si = function(t2) {
          return Math.abs(t2) < wt ? t2 : t2 - Jt(t2) * Math.PI;
        }, ii = function(t2, s2, i2, a2, h2) {
          var e2, n2;
          e2 = t2 / s2;
          for (var r2 = 0; r2 < 15; r2++)
            if (n2 = (t2 - (s2 * e2 - i2 * Math.sin(2 * e2) + a2 * Math.sin(4 * e2) - h2 * Math.sin(6 * e2))) / (s2 - 2 * i2 * Math.cos(2 * e2) + 4 * a2 * Math.cos(4 * e2) - 6 * h2 * Math.cos(6 * e2)), e2 += n2, Math.abs(
              n2
            ) <= 1e-10)
              return e2;
          return NaN;
        }, ai = {
          init: function() {
            this.sphere || (this.e0 = Vs(this.es), this.e1 = Zs(this.es), this.e2 = Ys(this.es), this.e3 = $s(this.es), this.ml0 = this.a * Js(this.e0, this.e1, this.e2, this.e3, this.lat0));
          },
          forward: function(t2) {
            var s2, i2, a2 = t2.x, h2 = t2.y;
            if (a2 = Vt(a2 - this.long0), this.sphere)
              s2 = this.a * Math.asin(Math.cos(h2) * Math.sin(a2)), i2 = this.a * (Math.atan2(Math.tan(h2), Math.cos(a2)) - this.lat0);
            else {
              var e2 = Math.sin(h2), n2 = Math.cos(h2), r2 = ti(this.a, this.e, e2), o2 = Math.tan(h2) * Math.tan(h2), l2 = a2 * Math.cos(h2), u2 = l2 * l2, c2 = this.es * n2 * n2 / (1 - this.es);
              s2 = r2 * l2 * (1 - u2 * o2 * (1 / 6 - (8 - o2 + 8 * c2) * u2 / 120)), i2 = this.a * Js(this.e0, this.e1, this.e2, this.e3, h2) - this.ml0 + r2 * e2 / n2 * u2 * (0.5 + (5 - o2 + 6 * c2) * u2 / 24);
            }
            return t2.x = s2 + this.x0, t2.y = i2 + this.y0, t2;
          },
          inverse: function(t2) {
            t2.x -= this.x0, t2.y -= this.y0;
            var s2, i2, a2 = t2.x / this.a, h2 = t2.y / this.a;
            if (this.sphere) {
              var e2 = h2 + this.lat0;
              s2 = Math.asin(Math.sin(e2) * Math.cos(a2)), i2 = Math.atan2(Math.tan(a2), Math.cos(e2));
            } else {
              var n2 = this.ml0 / this.a + h2, r2 = ii(n2, this.e0, this.e1, this.e2, this.e3);
              if (Math.abs(Math.abs(r2) - wt) <= Ct)
                return t2.x = this.long0, t2.y = wt, h2 < 0 && (t2.y *= -1), t2;
              var o2 = ti(this.a, this.e, Math.sin(r2)), l2 = o2 * o2 * o2 / this.a / this.a * (1 - this.es), u2 = Math.pow(Math.tan(r2), 2), c2 = a2 * this.a / o2, M2 = c2 * c2;
              s2 = r2 - o2 * Math.tan(r2) / l2 * c2 * c2 * (0.5 - (1 + 3 * u2) * c2 * c2 / 24), i2 = c2 * (1 - M2 * (u2 / 3 + (1 + 3 * u2) * u2 * M2 / 15)) / Math.cos(r2);
            }
            return t2.x = Vt(i2 + this.long0), t2.y = si(s2), t2;
          },
          names: ["Cassini", "Cassini_Soldner", "cass"]
        }, hi = function(t2, s2) {
          var i2;
          return t2 > 1e-7 ? (i2 = t2 * s2, (1 - t2 * t2) * (s2 / (1 - i2 * i2) - 0.5 / t2 * Math.log((1 - i2) / (1 + i2)))) : 2 * s2;
        }, ei = 0.3333333333333333, ni = 0.17222222222222222, ri = 0.10257936507936508, oi = 0.06388888888888888, li = 0.0664021164021164, ui = 0.016415012942191543, ci = {
          init: function() {
            var t2 = Math.abs(this.lat0);
            if (Math.abs(t2 - wt) < Ct ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(
              t2
            ) < Ct ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
              var s2;
              switch (this.qp = hi(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = ot(this.es), this.mode) {
                case this.N_POLE:
                case this.S_POLE:
                  this.dd = 1;
                  break;
                case this.EQUIT:
                  this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
                  break;
                case this.OBLIQ:
                  this.rq = Math.sqrt(0.5 * this.qp), s2 = Math.sin(this.lat0), this.sinb1 = hi(
                    this.e,
                    s2
                  ) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * s2 * s2) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
              }
            } else
              this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(
                this.lat0
              ));
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2 = t2.x, M2 = t2.y;
            if (c2 = Vt(c2 - this.long0), this.sphere) {
              if (e2 = Math.sin(M2), u2 = Math.cos(M2), a2 = Math.cos(c2), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                if ((i2 = this.mode === this.EQUIT ? 1 + u2 * a2 : 1 + this.sinph0 * e2 + this.cosph0 * u2 * a2) <= Ct)
                  return null;
                s2 = (i2 = Math.sqrt(2 / i2)) * u2 * Math.sin(c2), i2 *= this.mode === this.EQUIT ? e2 : this.cosph0 * e2 - this.sinph0 * u2 * a2;
              } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                if (this.mode === this.N_POLE && (a2 = -a2), Math.abs(M2 + this.lat0) < Ct)
                  return null;
                i2 = It - 0.5 * M2, s2 = (i2 = 2 * (this.mode === this.S_POLE ? Math.cos(i2) : Math.sin(i2))) * Math.sin(c2), i2 *= a2;
              }
            } else {
              switch (r2 = 0, o2 = 0, l2 = 0, a2 = Math.cos(c2), h2 = Math.sin(c2), e2 = Math.sin(M2), n2 = hi(this.e, e2), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (r2 = n2 / this.qp, o2 = Math.sqrt(1 - r2 * r2)), this.mode) {
                case this.OBLIQ:
                  l2 = 1 + this.sinb1 * r2 + this.cosb1 * o2 * a2;
                  break;
                case this.EQUIT:
                  l2 = 1 + o2 * a2;
                  break;
                case this.N_POLE:
                  l2 = wt + M2, n2 = this.qp - n2;
                  break;
                case this.S_POLE:
                  l2 = M2 - wt, n2 = this.qp + n2;
              }
              if (Math.abs(l2) < Ct)
                return null;
              switch (this.mode) {
                case this.OBLIQ:
                case this.EQUIT:
                  l2 = Math.sqrt(2 / l2), i2 = this.mode === this.OBLIQ ? this.ymf * l2 * (this.cosb1 * r2 - this.sinb1 * o2 * a2) : (l2 = Math.sqrt(2 / (1 + o2 * a2))) * r2 * this.ymf, s2 = this.xmf * l2 * o2 * h2;
                  break;
                case this.N_POLE:
                case this.S_POLE:
                  n2 >= 0 ? (s2 = (l2 = Math.sqrt(n2)) * h2, i2 = a2 * (this.mode === this.S_POLE ? l2 : -l2)) : s2 = i2 = 0;
              }
            }
            return t2.x = this.a * s2 + this.x0, t2.y = this.a * i2 + this.y0, t2;
          },
          inverse: function(t2) {
            t2.x -= this.x0, t2.y -= this.y0;
            var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x / this.a, l2 = t2.y / this.a;
            if (this.sphere) {
              var u2, c2 = 0, M2 = 0;
              if (u2 = Math.sqrt(o2 * o2 + l2 * l2), (i2 = 0.5 * u2) > 1)
                return null;
              switch (i2 = 2 * Math.asin(i2), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (M2 = Math.sin(i2), c2 = Math.cos(i2)), this.mode) {
                case this.EQUIT:
                  i2 = Math.abs(u2) <= Ct ? 0 : Math.asin(l2 * M2 / u2), o2 *= M2, l2 = c2 * u2;
                  break;
                case this.OBLIQ:
                  i2 = Math.abs(u2) <= Ct ? this.lat0 : Math.asin(c2 * this.sinph0 + l2 * M2 * this.cosph0 / u2), o2 *= M2 * this.cosph0, l2 = (c2 - Math.sin(i2) * this.sinph0) * u2;
                  break;
                case this.N_POLE:
                  l2 = -l2, i2 = wt - i2;
                  break;
                case this.S_POLE:
                  i2 -= wt;
              }
              s2 = 0 !== l2 || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(o2, l2) : 0;
            } else {
              if (r2 = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                if (o2 /= this.dd, l2 *= this.dd, (n2 = Math.sqrt(o2 * o2 + l2 * l2)) < Ct)
                  return t2.x = this.long0, t2.y = this.lat0, t2;
                h2 = 2 * Math.asin(0.5 * n2 / this.rq), a2 = Math.cos(h2), o2 *= h2 = Math.sin(h2), this.mode === this.OBLIQ ? (r2 = a2 * this.sinb1 + l2 * h2 * this.cosb1 / n2, e2 = this.qp * r2, l2 = n2 * this.cosb1 * a2 - l2 * this.sinb1 * h2) : (r2 = l2 * h2 / n2, e2 = this.qp * r2, l2 = n2 * a2);
              } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                if (this.mode === this.N_POLE && (l2 = -l2), !(e2 = o2 * o2 + l2 * l2))
                  return t2.x = this.long0, t2.y = this.lat0, t2;
                r2 = 1 - e2 / this.qp, this.mode === this.S_POLE && (r2 = -r2);
              }
              s2 = Math.atan2(o2, l2), i2 = lt(Math.asin(r2), this.apa);
            }
            return t2.x = Vt(this.long0 + s2), t2.y = i2, t2;
          },
          names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"],
          S_POLE: 1,
          N_POLE: 2,
          EQUIT: 3,
          OBLIQ: 4
        }, Mi = function(t2) {
          return Math.abs(t2) > 1 && (t2 = t2 > 1 ? 1 : -1), Math.asin(t2);
        }, fi = {
          init: function() {
            Math.abs(this.lat1 + this.lat2) < Ct || (this.temp = this.b / this.a, this.es = 1 - Math.pow(
              this.temp,
              2
            ), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Kt(this.e3, this.sin_po, this.cos_po), this.qs1 = hi(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Kt(this.e3, this.sin_po, this.cos_po), this.qs2 = hi(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = hi(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Ct ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
          },
          forward: function(t2) {
            var s2 = t2.x, i2 = t2.y;
            this.sin_phi = Math.sin(i2), this.cos_phi = Math.cos(i2);
            var a2 = hi(this.e3, this.sin_phi), h2 = this.a * Math.sqrt(this.c - this.ns0 * a2) / this.ns0, e2 = this.ns0 * Vt(s2 - this.long0), n2 = h2 * Math.sin(e2) + this.x0, r2 = this.rh - h2 * Math.cos(e2) + this.y0;
            return t2.x = n2, t2.y = r2, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2;
            return t2.x -= this.x0, t2.y = this.rh - t2.y + this.y0, this.ns0 >= 0 ? (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), a2 = 1) : (s2 = -Math.sqrt(t2.x * t2.x + t2.y * t2.y), a2 = -1), h2 = 0, 0 !== s2 && (h2 = Math.atan2(a2 * t2.x, a2 * t2.y)), a2 = s2 * this.ns0 / this.a, this.sphere ? n2 = Math.asin((this.c - a2 * a2) / (2 * this.ns0)) : (i2 = (this.c - a2 * a2) / this.ns0, n2 = this.phi1z(
              this.e3,
              i2
            )), e2 = Vt(h2 / this.ns0 + this.long0), t2.x = e2, t2.y = n2, t2;
          },
          names: ["Albers_Conic_Equal_Area", "Albers", "aea"],
          phi1z: function(t2, s2) {
            var i2, a2, h2, e2, n2, r2 = Mi(0.5 * s2);
            if (t2 < Ct)
              return r2;
            for (var o2 = t2 * t2, l2 = 1; l2 <= 25; l2++)
              if (i2 = Math.sin(r2), a2 = Math.cos(r2), h2 = t2 * i2, e2 = 1 - h2 * h2, n2 = 0.5 * e2 * e2 / a2 * (s2 / (1 - o2) - i2 / e2 + 0.5 / t2 * Math.log((1 - h2) / (1 + h2))), r2 += n2, Math.abs(n2) <= 1e-7)
                return r2;
            return null;
          }
        }, di = {
          init: function() {
            this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y;
            return a2 = Vt(o2 - this.long0), s2 = Math.sin(l2), i2 = Math.cos(l2), h2 = Math.cos(a2), (e2 = this.sin_p14 * s2 + this.cos_p14 * i2 * h2) > 0 || Math.abs(e2) <= Ct ? (n2 = this.x0 + 1 * this.a * i2 * Math.sin(a2) / e2, r2 = this.y0 + 1 * this.a * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2) / e2) : (n2 = this.x0 + this.infinity_dist * i2 * Math.sin(a2), r2 = this.y0 + this.infinity_dist * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2)), t2.x = n2, t2.y = r2, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2;
            return t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, t2.x /= this.k0, t2.y /= this.k0, (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) ? (h2 = Math.atan2(s2, this.rc), i2 = Math.sin(
              h2
            ), a2 = Math.cos(h2), n2 = Mi(a2 * this.sin_p14 + t2.y * i2 * this.cos_p14 / s2), e2 = Math.atan2(t2.x * i2, s2 * this.cos_p14 * a2 - t2.y * this.sin_p14 * i2), e2 = Vt(this.long0 + e2)) : (n2 = this.phic0, e2 = 0), t2.x = e2, t2.y = n2, t2;
          },
          names: ["gnom"]
        }, mi = function(t2, s2) {
          var i2 = 1 - (1 - t2 * t2) / (2 * t2) * Math.log((1 - t2) / (1 + t2));
          if (Math.abs(Math.abs(s2) - i2) < 1e-6)
            return s2 < 0 ? -1 * wt : wt;
          for (var a2, h2, e2, n2, r2 = Math.asin(0.5 * s2), o2 = 0; o2 < 30; o2++)
            if (h2 = Math.sin(r2), e2 = Math.cos(r2), n2 = t2 * h2, a2 = Math.pow(1 - n2 * n2, 2) / (2 * e2) * (s2 / (1 - t2 * t2) - h2 / (1 - n2 * n2) + 0.5 / t2 * Math.log((1 - n2) / (1 + n2))), r2 += a2, Math.abs(a2) <= 1e-10)
              return r2;
          return NaN;
        }, pi = {
          init: function() {
            this.sphere || (this.k0 = Kt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
          },
          forward: function(t2) {
            var s2, i2, a2 = t2.x, h2 = t2.y, e2 = Vt(a2 - this.long0);
            if (this.sphere)
              s2 = this.x0 + this.a * e2 * Math.cos(this.lat_ts), i2 = this.y0 + this.a * Math.sin(h2) / Math.cos(this.lat_ts);
            else {
              var n2 = hi(this.e, Math.sin(h2));
              s2 = this.x0 + this.a * this.k0 * e2, i2 = this.y0 + this.a * n2 * 0.5 / this.k0;
            }
            return t2.x = s2, t2.y = i2, t2;
          },
          inverse: function(t2) {
            t2.x -= this.x0, t2.y -= this.y0;
            var s2, i2;
            return this.sphere ? (s2 = Vt(this.long0 + t2.x / this.a / Math.cos(this.lat_ts)), i2 = Math.asin(t2.y / this.a * Math.cos(this.lat_ts))) : (i2 = mi(this.e, 2 * t2.y * this.k0 / this.a), s2 = Vt(this.long0 + t2.x / (this.a * this.k0))), t2.x = s2, t2.y = i2, t2;
          },
          names: ["cea"]
        }, yi = {
          init: function() {
            this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
          },
          forward: function(t2) {
            var s2 = t2.x, i2 = t2.y, a2 = Vt(s2 - this.long0), h2 = si(i2 - this.lat0);
            return t2.x = this.x0 + this.a * a2 * this.rc, t2.y = this.y0 + this.a * h2, t2;
          },
          inverse: function(t2) {
            var s2 = t2.x, i2 = t2.y;
            return t2.x = Vt(this.long0 + (s2 - this.x0) / (this.a * this.rc)), t2.y = si(this.lat0 + (i2 - this.y0) / this.a), t2;
          },
          names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"]
        }, _i = 20, xi = {
          init: function() {
            this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Vs(this.es), this.e1 = Zs(this.es), this.e2 = Ys(this.es), this.e3 = $s(this.es), this.ml0 = this.a * Js(this.e0, this.e1, this.e2, this.e3, this.lat0);
          },
          forward: function(t2) {
            var s2, i2, a2, h2 = t2.x, e2 = t2.y, n2 = Vt(h2 - this.long0);
            if (a2 = n2 * Math.sin(e2), this.sphere)
              Math.abs(e2) <= Ct ? (s2 = this.a * n2, i2 = -1 * this.a * this.lat0) : (s2 = this.a * Math.sin(a2) / Math.tan(e2), i2 = this.a * (si(e2 - this.lat0) + (1 - Math.cos(a2)) / Math.tan(e2)));
            else if (Math.abs(e2) <= Ct)
              s2 = this.a * n2, i2 = -1 * this.ml0;
            else {
              var r2 = ti(this.a, this.e, Math.sin(e2)) / Math.tan(e2);
              s2 = r2 * Math.sin(a2), i2 = this.a * Js(this.e0, this.e1, this.e2, this.e3, e2) - this.ml0 + r2 * (1 - Math.cos(a2));
            }
            return t2.x = s2 + this.x0, t2.y = i2 + this.y0, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2, l2;
            if (a2 = t2.x - this.x0, h2 = t2.y - this.y0, this.sphere)
              if (Math.abs(h2 + this.a * this.lat0) <= Ct)
                s2 = Vt(a2 / this.a + this.long0), i2 = 0;
              else {
                n2 = this.lat0 + h2 / this.a, r2 = a2 * a2 / this.a / this.a + n2 * n2, o2 = n2;
                var u2;
                for (e2 = _i; e2; --e2)
                  if (u2 = Math.tan(o2), l2 = -1 * (n2 * (o2 * u2 + 1) - o2 - 0.5 * (o2 * o2 + r2) * u2) / ((o2 - n2) / u2 - 1), o2 += l2, Math.abs(l2) <= Ct) {
                    i2 = o2;
                    break;
                  }
                s2 = Vt(this.long0 + Math.asin(a2 * Math.tan(o2) / this.a) / Math.sin(i2));
              }
            else if (Math.abs(h2 + this.ml0) <= Ct)
              i2 = 0, s2 = Vt(this.long0 + a2 / this.a);
            else {
              n2 = (this.ml0 + h2) / this.a, r2 = a2 * a2 / this.a / this.a + n2 * n2, o2 = n2;
              var c2, M2, f2, d2, m2;
              for (e2 = _i; e2; --e2)
                if (m2 = this.e * Math.sin(o2), c2 = Math.sqrt(1 - m2 * m2) * Math.tan(o2), M2 = this.a * Js(
                  this.e0,
                  this.e1,
                  this.e2,
                  this.e3,
                  o2
                ), f2 = this.e0 - 2 * this.e1 * Math.cos(2 * o2) + 4 * this.e2 * Math.cos(4 * o2) - 6 * this.e3 * Math.cos(6 * o2), d2 = M2 / this.a, l2 = (n2 * (c2 * d2 + 1) - d2 - 0.5 * c2 * (d2 * d2 + r2)) / (this.es * Math.sin(2 * o2) * (d2 * d2 + r2 - 2 * n2 * d2) / (4 * c2) + (n2 - d2) * (c2 * f2 - 2 / Math.sin(2 * o2)) - f2), o2 -= l2, Math.abs(l2) <= Ct) {
                  i2 = o2;
                  break;
                }
              c2 = Math.sqrt(1 - this.es * Math.pow(Math.sin(i2), 2)) * Math.tan(i2), s2 = Vt(this.long0 + Math.asin(a2 * c2 / this.a) / Math.sin(i2));
            }
            return t2.x = s2, t2.y = i2, t2;
          },
          names: ["Polyconic", "poly"]
        }, gi = {
          init: function() {
            this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
          },
          forward: function(t2) {
            var s2, i2 = t2.x, a2 = t2.y - this.lat0, h2 = i2 - this.long0, e2 = a2 / bt * 1e-5, n2 = h2, r2 = 1, o2 = 0;
            for (s2 = 1; s2 <= 10; s2++)
              r2 *= e2, o2 += this.A[s2] * r2;
            var l2, u2 = o2, c2 = n2, M2 = 1, f2 = 0, d2 = 0, m2 = 0;
            for (s2 = 1; s2 <= 6; s2++)
              l2 = f2 * u2 + M2 * c2, M2 = M2 * u2 - f2 * c2, f2 = l2, d2 = d2 + this.B_re[s2] * M2 - this.B_im[s2] * f2, m2 = m2 + this.B_im[s2] * M2 + this.B_re[s2] * f2;
            return t2.x = m2 * this.a + this.x0, t2.y = d2 * this.a + this.y0, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2 = t2.x, h2 = t2.y, e2 = a2 - this.x0, n2 = (h2 - this.y0) / this.a, r2 = e2 / this.a, o2 = 1, l2 = 0, u2 = 0, c2 = 0;
            for (s2 = 1; s2 <= 6; s2++)
              i2 = l2 * n2 + o2 * r2, o2 = o2 * n2 - l2 * r2, l2 = i2, u2 = u2 + this.C_re[s2] * o2 - this.C_im[s2] * l2, c2 = c2 + this.C_im[s2] * o2 + this.C_re[s2] * l2;
            for (var M2 = 0; M2 < this.iterations; M2++) {
              var f2, d2 = u2, m2 = c2, p2 = n2, y2 = r2;
              for (s2 = 2; s2 <= 6; s2++)
                f2 = m2 * u2 + d2 * c2, d2 = d2 * u2 - m2 * c2, m2 = f2, p2 += (s2 - 1) * (this.B_re[s2] * d2 - this.B_im[s2] * m2), y2 += (s2 - 1) * (this.B_im[s2] * d2 + this.B_re[s2] * m2);
              d2 = 1, m2 = 0;
              var _2 = this.B_re[1], x2 = this.B_im[1];
              for (s2 = 2; s2 <= 6; s2++)
                f2 = m2 * u2 + d2 * c2, d2 = d2 * u2 - m2 * c2, m2 = f2, _2 += s2 * (this.B_re[s2] * d2 - this.B_im[s2] * m2), x2 += s2 * (this.B_im[s2] * d2 + this.B_re[s2] * m2);
              var g2 = _2 * _2 + x2 * x2;
              u2 = (p2 * _2 + y2 * x2) / g2, c2 = (y2 * _2 - p2 * x2) / g2;
            }
            var v2 = u2, b2 = c2, w2 = 1, N2 = 0;
            for (s2 = 1; s2 <= 9; s2++)
              w2 *= v2, N2 += this.D[s2] * w2;
            var E2 = this.lat0 + N2 * bt * 1e5, A2 = this.long0 + b2;
            return t2.x = A2, t2.y = E2, t2;
          },
          names: ["New_Zealand_Map_Grid", "nzmg"]
        }, vi = {
          init: function() {
          },
          forward: function(t2) {
            var s2 = t2.x, i2 = t2.y, a2 = Vt(s2 - this.long0), h2 = this.x0 + this.a * a2, e2 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i2 / 2.5)) * 1.25;
            return t2.x = h2, t2.y = e2, t2;
          },
          inverse: function(t2) {
            t2.x -= this.x0, t2.y -= this.y0;
            var s2 = Vt(this.long0 + t2.x / this.a), i2 = 2.5 * (Math.atan(Math.exp(0.8 * t2.y / this.a)) - Math.PI / 4);
            return t2.x = s2, t2.y = i2, t2;
          },
          names: ["Miller_Cylindrical", "mill"]
        }, bi = 20, wi = {
          init: function() {
            this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = Ns(this.es);
          },
          forward: function(t2) {
            var s2, i2, a2 = t2.x, h2 = t2.y;
            if (a2 = Vt(a2 - this.long0), this.sphere) {
              if (this.m)
                for (var e2 = this.n * Math.sin(h2), n2 = bi; n2; --n2) {
                  var r2 = (this.m * h2 + Math.sin(h2) - e2) / (this.m + Math.cos(h2));
                  if (h2 -= r2, Math.abs(r2) < Ct)
                    break;
                }
              else
                h2 = 1 !== this.n ? Math.asin(this.n * Math.sin(h2)) : h2;
              s2 = this.a * this.C_x * a2 * (this.m + Math.cos(h2)), i2 = this.a * this.C_y * h2;
            } else {
              var o2 = Math.sin(h2), l2 = Math.cos(h2);
              i2 = this.a * Es(h2, o2, l2, this.en), s2 = this.a * a2 * l2 / Math.sqrt(1 - this.es * o2 * o2);
            }
            return t2.x = s2, t2.y = i2, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2;
            return t2.x -= this.x0, a2 = t2.x / this.a, t2.y -= this.y0, s2 = t2.y / this.a, this.sphere ? (s2 /= this.C_y, a2 /= this.C_x * (this.m + Math.cos(s2)), this.m ? s2 = Mi((this.m * s2 + Math.sin(s2)) / this.n) : 1 !== this.n && (s2 = Mi(Math.sin(s2) / this.n)), a2 = Vt(a2 + this.long0), s2 = si(s2)) : (s2 = As(t2.y / this.a, this.es, this.en), (h2 = Math.abs(s2)) < wt ? (h2 = Math.sin(s2), i2 = this.long0 + t2.x * Math.sqrt(1 - this.es * h2 * h2) / (this.a * Math.cos(s2)), a2 = Vt(i2)) : h2 - Ct < wt && (a2 = this.long0)), t2.x = a2, t2.y = s2, t2;
          },
          names: ["Sinusoidal", "sinu"]
        }, Ni = {
          init: function() {
          },
          forward: function(t2) {
            for (var s2 = t2.x, i2 = t2.y, a2 = Vt(s2 - this.long0), h2 = i2, e2 = Math.PI * Math.sin(i2); ; ) {
              var n2 = -(h2 + Math.sin(h2) - e2) / (1 + Math.cos(h2));
              if (h2 += n2, Math.abs(n2) < Ct)
                break;
            }
            h2 /= 2, Math.PI / 2 - Math.abs(i2) < Ct && (a2 = 0);
            var r2 = 0.900316316158 * this.a * a2 * Math.cos(h2) + this.x0, o2 = 1.4142135623731 * this.a * Math.sin(h2) + this.y0;
            return t2.x = r2, t2.y = o2, t2;
          },
          inverse: function(t2) {
            var s2, i2;
            t2.x -= this.x0, t2.y -= this.y0, i2 = t2.y / (1.4142135623731 * this.a), Math.abs(i2) > 0.999999999999 && (i2 = 0.999999999999), s2 = Math.asin(i2);
            var a2 = Vt(this.long0 + t2.x / (0.900316316158 * this.a * Math.cos(s2)));
            a2 < -Math.PI && (a2 = -Math.PI), a2 > Math.PI && (a2 = Math.PI), i2 = (2 * s2 + Math.sin(2 * s2)) / Math.PI, Math.abs(i2) > 1 && (i2 = 1);
            var h2 = Math.asin(i2);
            return t2.x = a2, t2.y = h2, t2;
          },
          names: ["Mollweide", "moll"]
        }, Ei = {
          init: function() {
            Math.abs(this.lat1 + this.lat2) < Ct || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Vs(this.es), this.e1 = Zs(this.es), this.e2 = Ys(this.es), this.e3 = $s(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Kt(this.e, this.sinphi, this.cosphi), this.ml1 = Js(
              this.e0,
              this.e1,
              this.e2,
              this.e3,
              this.lat1
            ), Math.abs(this.lat1 - this.lat2) < Ct ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Kt(this.e, this.sinphi, this.cosphi), this.ml2 = Js(
              this.e0,
              this.e1,
              this.e2,
              this.e3,
              this.lat2
            ), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Js(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
          },
          forward: function(t2) {
            var s2, i2 = t2.x, a2 = t2.y;
            if (this.sphere)
              s2 = this.a * (this.g - a2);
            else {
              var h2 = Js(this.e0, this.e1, this.e2, this.e3, a2);
              s2 = this.a * (this.g - h2);
            }
            var e2 = this.ns * Vt(i2 - this.long0), n2 = this.x0 + s2 * Math.sin(e2), r2 = this.y0 + this.rh - s2 * Math.cos(e2);
            return t2.x = n2, t2.y = r2, t2;
          },
          inverse: function(t2) {
            t2.x -= this.x0, t2.y = this.rh - t2.y + this.y0;
            var s2, i2, a2, h2;
            this.ns >= 0 ? (i2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), s2 = 1) : (i2 = -Math.sqrt(t2.x * t2.x + t2.y * t2.y), s2 = -1);
            var e2 = 0;
            if (0 !== i2 && (e2 = Math.atan2(s2 * t2.x, s2 * t2.y)), this.sphere)
              return h2 = Vt(this.long0 + e2 / this.ns), a2 = si(this.g - i2 / this.a), t2.x = h2, t2.y = a2, t2;
            var n2 = this.g - i2 / this.a;
            return a2 = ii(n2, this.e0, this.e1, this.e2, this.e3), h2 = Vt(this.long0 + e2 / this.ns), t2.x = h2, t2.y = a2, t2;
          },
          names: ["Equidistant_Conic", "eqdc"]
        }, Ai = {
          init: function() {
            this.R = this.a;
          },
          forward: function(t2) {
            var s2, i2, a2 = t2.x, h2 = t2.y, e2 = Vt(a2 - this.long0);
            Math.abs(h2) <= Ct && (s2 = this.x0 + this.R * e2, i2 = this.y0);
            var n2 = Mi(2 * Math.abs(h2 / Math.PI));
            (Math.abs(e2) <= Ct || Math.abs(Math.abs(h2) - wt) <= Ct) && (s2 = this.x0, i2 = h2 >= 0 ? this.y0 + Math.PI * this.R * Math.tan(0.5 * n2) : this.y0 + Math.PI * this.R * -Math.tan(0.5 * n2));
            var r2 = 0.5 * Math.abs(Math.PI / e2 - e2 / Math.PI), o2 = r2 * r2, l2 = Math.sin(n2), u2 = Math.cos(n2), c2 = u2 / (l2 + u2 - 1), M2 = c2 * c2, f2 = c2 * (2 / l2 - 1), d2 = f2 * f2, m2 = Math.PI * this.R * (r2 * (c2 - d2) + Math.sqrt(o2 * (c2 - d2) * (c2 - d2) - (d2 + o2) * (M2 - d2))) / (d2 + o2);
            e2 < 0 && (m2 = -m2), s2 = this.x0 + m2;
            var p2 = o2 + c2;
            return m2 = Math.PI * this.R * (f2 * p2 - r2 * Math.sqrt((d2 + o2) * (o2 + 1) - p2 * p2)) / (d2 + o2), i2 = h2 >= 0 ? this.y0 + m2 : this.y0 - m2, t2.x = s2, t2.y = i2, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2, M2, f2;
            return t2.x -= this.x0, t2.y -= this.y0, c2 = Math.PI * this.R, a2 = t2.x / c2, h2 = t2.y / c2, e2 = a2 * a2 + h2 * h2, n2 = -Math.abs(h2) * (1 + e2), r2 = n2 - 2 * h2 * h2 + a2 * a2, o2 = -2 * n2 + 1 + 2 * h2 * h2 + e2 * e2, f2 = h2 * h2 / o2 + (2 * r2 * r2 * r2 / o2 / o2 / o2 - 9 * n2 * r2 / o2 / o2) / 27, l2 = (n2 - r2 * r2 / 3 / o2) / o2, u2 = 2 * Math.sqrt(-l2 / 3), c2 = 3 * f2 / l2 / u2, Math.abs(c2) > 1 && (c2 = c2 >= 0 ? 1 : -1), M2 = Math.acos(c2) / 3, i2 = t2.y >= 0 ? (-u2 * Math.cos(M2 + Math.PI / 3) - r2 / 3 / o2) * Math.PI : -(-u2 * Math.cos(M2 + Math.PI / 3) - r2 / 3 / o2) * Math.PI, s2 = Math.abs(a2) < Ct ? this.long0 : Vt(this.long0 + Math.PI * (e2 - 1 + Math.sqrt(1 + 2 * (a2 * a2 - h2 * h2) + e2 * e2)) / 2 / a2), t2.x = s2, t2.y = i2, t2;
          },
          names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"]
        }, Ci = {
          init: function() {
            this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2, M2, f2, d2, m2, p2, y2, _2, x2, g2, v2, b2, w2, N2 = t2.x, E2 = t2.y, A2 = Math.sin(t2.y), C2 = Math.cos(t2.y), P2 = Vt(N2 - this.long0);
            return this.sphere ? Math.abs(this.sin_p12 - 1) <= Ct ? (t2.x = this.x0 + this.a * (wt - E2) * Math.sin(P2), t2.y = this.y0 - this.a * (wt - E2) * Math.cos(P2), t2) : Math.abs(this.sin_p12 + 1) <= Ct ? (t2.x = this.x0 + this.a * (wt + E2) * Math.sin(P2), t2.y = this.y0 + this.a * (wt + E2) * Math.cos(P2), t2) : (_2 = this.sin_p12 * A2 + this.cos_p12 * C2 * Math.cos(P2), p2 = Math.acos(_2), y2 = p2 ? p2 / Math.sin(p2) : 1, t2.x = this.x0 + this.a * y2 * C2 * Math.sin(P2), t2.y = this.y0 + this.a * y2 * (this.cos_p12 * A2 - this.sin_p12 * C2 * Math.cos(P2)), t2) : (s2 = Vs(this.es), i2 = Zs(this.es), a2 = Ys(this.es), h2 = $s(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (e2 = this.a * Js(s2, i2, a2, h2, wt), n2 = this.a * Js(
              s2,
              i2,
              a2,
              h2,
              E2
            ), t2.x = this.x0 + (e2 - n2) * Math.sin(P2), t2.y = this.y0 - (e2 - n2) * Math.cos(P2), t2) : Math.abs(this.sin_p12 + 1) <= Ct ? (e2 = this.a * Js(
              s2,
              i2,
              a2,
              h2,
              wt
            ), n2 = this.a * Js(s2, i2, a2, h2, E2), t2.x = this.x0 + (e2 + n2) * Math.sin(P2), t2.y = this.y0 + (e2 + n2) * Math.cos(P2), t2) : (r2 = A2 / C2, o2 = ti(this.a, this.e, this.sin_p12), l2 = ti(this.a, this.e, A2), u2 = Math.atan((1 - this.es) * r2 + this.es * o2 * this.sin_p12 / (l2 * C2)), c2 = Math.atan2(Math.sin(P2), this.cos_p12 * Math.tan(u2) - this.sin_p12 * Math.cos(P2)), x2 = 0 === c2 ? Math.asin(this.cos_p12 * Math.sin(u2) - this.sin_p12 * Math.cos(u2)) : Math.abs(Math.abs(c2) - Math.PI) <= Ct ? -Math.asin(this.cos_p12 * Math.sin(u2) - this.sin_p12 * Math.cos(u2)) : Math.asin(Math.sin(P2) * Math.cos(u2) / Math.sin(c2)), M2 = this.e * this.sin_p12 / Math.sqrt(1 - this.es), f2 = this.e * this.cos_p12 * Math.cos(c2) / Math.sqrt(1 - this.es), d2 = M2 * f2, m2 = f2 * f2, g2 = x2 * x2, v2 = g2 * x2, b2 = v2 * x2, w2 = b2 * x2, p2 = o2 * x2 * (1 - g2 * m2 * (1 - m2) / 6 + v2 / 8 * d2 * (1 - 2 * m2) + b2 / 120 * (m2 * (4 - 7 * m2) - 3 * M2 * M2 * (1 - 7 * m2)) - w2 / 48 * d2), t2.x = this.x0 + p2 * Math.sin(c2), t2.y = this.y0 + p2 * Math.cos(c2), t2));
          },
          inverse: function(t2) {
            t2.x -= this.x0, t2.y -= this.y0;
            var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2, M2, f2, d2, m2, p2, y2, _2, x2, g2, v2, b2, w2, N2;
            if (this.sphere) {
              if ((s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) > 2 * wt * this.a)
                return;
              return i2 = s2 / this.a, a2 = Math.sin(i2), h2 = Math.cos(i2), e2 = this.long0, Math.abs(s2) <= Ct ? n2 = this.lat0 : (n2 = Mi(h2 * this.sin_p12 + t2.y * a2 * this.cos_p12 / s2), r2 = Math.abs(
                this.lat0
              ) - wt, e2 = Vt(Math.abs(r2) <= Ct ? this.lat0 >= 0 ? this.long0 + Math.atan2(t2.x, -t2.y) : this.long0 - Math.atan2(-t2.x, t2.y) : this.long0 + Math.atan2(t2.x * a2, s2 * this.cos_p12 * h2 - t2.y * this.sin_p12 * a2))), t2.x = e2, t2.y = n2, t2;
            }
            return o2 = Vs(this.es), l2 = Zs(this.es), u2 = Ys(this.es), c2 = $s(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (M2 = this.a * Js(o2, l2, u2, c2, wt), s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), f2 = M2 - s2, n2 = ii(f2 / this.a, o2, l2, u2, c2), e2 = Vt(this.long0 + Math.atan2(
              t2.x,
              -1 * t2.y
            )), t2.x = e2, t2.y = n2, t2) : Math.abs(this.sin_p12 + 1) <= Ct ? (M2 = this.a * Js(
              o2,
              l2,
              u2,
              c2,
              wt
            ), s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), f2 = s2 - M2, n2 = ii(
              f2 / this.a,
              o2,
              l2,
              u2,
              c2
            ), e2 = Vt(this.long0 + Math.atan2(t2.x, t2.y)), t2.x = e2, t2.y = n2, t2) : (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), p2 = Math.atan2(t2.x, t2.y), d2 = ti(this.a, this.e, this.sin_p12), y2 = Math.cos(p2), _2 = this.e * this.cos_p12 * y2, x2 = -_2 * _2 / (1 - this.es), g2 = 3 * this.es * (1 - x2) * this.sin_p12 * this.cos_p12 * y2 / (1 - this.es), v2 = s2 / d2, b2 = v2 - x2 * (1 + x2) * Math.pow(v2, 3) / 6 - g2 * (1 + 3 * x2) * Math.pow(v2, 4) / 24, w2 = 1 - x2 * b2 * b2 / 2 - v2 * b2 * b2 * b2 / 6, m2 = Math.asin(this.sin_p12 * Math.cos(
              b2
            ) + this.cos_p12 * Math.sin(b2) * y2), e2 = Vt(this.long0 + Math.asin(Math.sin(p2) * Math.sin(b2) / Math.cos(m2))), N2 = Math.sin(m2), n2 = Math.atan2((N2 - this.es * w2 * this.sin_p12) * Math.tan(m2), N2 * (1 - this.es)), t2.x = e2, t2.y = n2, t2);
          },
          names: ["Azimuthal_Equidistant", "aeqd"]
        }, Pi = {
          init: function() {
            this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y;
            return a2 = Vt(o2 - this.long0), s2 = Math.sin(l2), i2 = Math.cos(l2), h2 = Math.cos(a2), ((e2 = this.sin_p14 * s2 + this.cos_p14 * i2 * h2) > 0 || Math.abs(e2) <= Ct) && (n2 = 1 * this.a * i2 * Math.sin(a2), r2 = this.y0 + 1 * this.a * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2)), t2.x = n2, t2.y = r2, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2;
            return t2.x -= this.x0, t2.y -= this.y0, s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), i2 = Mi(s2 / this.a), a2 = Math.sin(i2), h2 = Math.cos(i2), n2 = this.long0, Math.abs(s2) <= Ct ? (r2 = this.lat0, t2.x = n2, t2.y = r2, t2) : (r2 = Mi(h2 * this.sin_p14 + t2.y * a2 * this.cos_p14 / s2), e2 = Math.abs(
              this.lat0
            ) - wt, Math.abs(e2) <= Ct ? (n2 = Vt(this.lat0 >= 0 ? this.long0 + Math.atan2(t2.x, -t2.y) : this.long0 - Math.atan2(-t2.x, t2.y)), t2.x = n2, t2.y = r2, t2) : (n2 = Vt(this.long0 + Math.atan2(t2.x * a2, s2 * this.cos_p14 * h2 - t2.y * this.sin_p14 * a2)), t2.x = n2, t2.y = r2, t2));
          },
          names: ["ortho"]
        }, Si = {
          FRONT: 1,
          RIGHT: 2,
          BACK: 3,
          LEFT: 4,
          TOP: 5,
          BOTTOM: 6
        }, Ii = {
          AREA_0: 1,
          AREA_1: 2,
          AREA_2: 3,
          AREA_3: 4
        }, Oi = {
          init: function() {
            this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= wt - It / 2 ? this.face = Si.TOP : this.lat0 <= -(wt - It / 2) ? this.face = Si.BOTTOM : Math.abs(this.long0) <= It ? this.face = Si.FRONT : Math.abs(this.long0) <= wt + It ? this.face = this.long0 > 0 ? Si.RIGHT : Si.LEFT : this.face = Si.BACK, 0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2 = {
              x: 0,
              y: 0
            }, o2 = {
              value: 0
            };
            if (t2.x -= this.long0, s2 = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(t2.y)) : t2.y, i2 = t2.x, this.face === Si.TOP)
              h2 = wt - s2, i2 >= It && i2 <= wt + It ? (o2.value = Ii.AREA_0, a2 = i2 - wt) : i2 > wt + It || i2 <= -(wt + It) ? (o2.value = Ii.AREA_1, a2 = i2 > 0 ? i2 - kt : i2 + kt) : i2 > -(wt + It) && i2 <= -It ? (o2.value = Ii.AREA_2, a2 = i2 + wt) : (o2.value = Ii.AREA_3, a2 = i2);
            else if (this.face === Si.BOTTOM)
              h2 = wt + s2, i2 >= It && i2 <= wt + It ? (o2.value = Ii.AREA_0, a2 = -i2 + wt) : i2 < It && i2 >= -It ? (o2.value = Ii.AREA_1, a2 = -i2) : i2 < -It && i2 >= -(wt + It) ? (o2.value = Ii.AREA_2, a2 = -i2 - wt) : (o2.value = Ii.AREA_3, a2 = i2 > 0 ? -i2 + kt : -i2 - kt);
            else {
              var l2, u2, c2, M2, f2, d2;
              this.face === Si.RIGHT ? i2 = ct(i2, +wt) : this.face === Si.BACK ? i2 = ct(i2, +kt) : this.face === Si.LEFT && (i2 = ct(i2, -wt)), M2 = Math.sin(s2), f2 = Math.cos(s2), d2 = Math.sin(
                i2
              ), l2 = f2 * Math.cos(i2), u2 = f2 * d2, c2 = M2, this.face === Si.FRONT ? a2 = ut(h2 = Math.acos(l2), c2, u2, o2) : this.face === Si.RIGHT ? a2 = ut(h2 = Math.acos(u2), c2, -l2, o2) : this.face === Si.BACK ? a2 = ut(h2 = Math.acos(-l2), c2, -u2, o2) : this.face === Si.LEFT ? a2 = ut(h2 = Math.acos(-u2), c2, l2, o2) : (h2 = a2 = 0, o2.value = Ii.AREA_0);
            }
            return n2 = Math.atan(12 / kt * (a2 + Math.acos(Math.sin(a2) * Math.cos(It)) - wt)), e2 = Math.sqrt(
              (1 - Math.cos(h2)) / (Math.cos(n2) * Math.cos(n2)) / (1 - Math.cos(Math.atan(1 / Math.cos(
                a2
              ))))
            ), o2.value === Ii.AREA_1 ? n2 += wt : o2.value === Ii.AREA_2 ? n2 += kt : o2.value === Ii.AREA_3 && (n2 += 1.5 * kt), r2.x = e2 * Math.cos(n2), r2.y = e2 * Math.sin(n2), r2.x = r2.x * this.a + this.x0, r2.y = r2.y * this.a + this.y0, t2.x = r2.x, t2.y = r2.y, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2 = {
              lam: 0,
              phi: 0
            }, c2 = {
              value: 0
            };
            if (t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, i2 = Math.atan(Math.sqrt(t2.x * t2.x + t2.y * t2.y)), s2 = Math.atan2(t2.y, t2.x), t2.x >= 0 && t2.x >= Math.abs(t2.y) ? c2.value = Ii.AREA_0 : t2.y >= 0 && t2.y >= Math.abs(t2.x) ? (c2.value = Ii.AREA_1, s2 -= wt) : t2.x < 0 && -t2.x >= Math.abs(t2.y) ? (c2.value = Ii.AREA_2, s2 = s2 < 0 ? s2 + kt : s2 - kt) : (c2.value = Ii.AREA_3, s2 += wt), l2 = kt / 12 * Math.tan(s2), e2 = Math.sin(l2) / (Math.cos(
              l2
            ) - 1 / Math.sqrt(2)), n2 = Math.atan(e2), a2 = Math.cos(s2), h2 = Math.tan(i2), (r2 = 1 - a2 * a2 * h2 * h2 * (1 - Math.cos(Math.atan(1 / Math.cos(n2))))) < -1 ? r2 = -1 : r2 > 1 && (r2 = 1), this.face === Si.TOP)
              o2 = Math.acos(r2), u2.phi = wt - o2, c2.value === Ii.AREA_0 ? u2.lam = n2 + wt : c2.value === Ii.AREA_1 ? u2.lam = n2 < 0 ? n2 + kt : n2 - kt : c2.value === Ii.AREA_2 ? u2.lam = n2 - wt : u2.lam = n2;
            else if (this.face === Si.BOTTOM)
              o2 = Math.acos(r2), u2.phi = o2 - wt, c2.value === Ii.AREA_0 ? u2.lam = -n2 + wt : c2.value === Ii.AREA_1 ? u2.lam = -n2 : c2.value === Ii.AREA_2 ? u2.lam = -n2 - wt : u2.lam = n2 < 0 ? -n2 - kt : -n2 + kt;
            else {
              var M2, f2, d2;
              l2 = (M2 = r2) * M2, f2 = (l2 += (d2 = l2 >= 1 ? 0 : Math.sqrt(1 - l2) * Math.sin(n2)) * d2) >= 1 ? 0 : Math.sqrt(1 - l2), c2.value === Ii.AREA_1 ? (l2 = f2, f2 = -d2, d2 = l2) : c2.value === Ii.AREA_2 ? (f2 = -f2, d2 = -d2) : c2.value === Ii.AREA_3 && (l2 = f2, f2 = d2, d2 = -l2), this.face === Si.RIGHT ? (l2 = M2, M2 = -f2, f2 = l2) : this.face === Si.BACK ? (M2 = -M2, f2 = -f2) : this.face === Si.LEFT && (l2 = M2, M2 = f2, f2 = -l2), u2.phi = Math.acos(-d2) - wt, u2.lam = Math.atan2(f2, M2), this.face === Si.RIGHT ? u2.lam = ct(u2.lam, -wt) : this.face === Si.BACK ? u2.lam = ct(u2.lam, -kt) : this.face === Si.LEFT && (u2.lam = ct(u2.lam, +wt));
            }
            if (0 !== this.es) {
              var m2, p2, y2;
              m2 = u2.phi < 0 ? 1 : 0, p2 = Math.tan(u2.phi), y2 = this.b / Math.sqrt(p2 * p2 + this.one_minus_f_squared), u2.phi = Math.atan(Math.sqrt(this.a * this.a - y2 * y2) / (this.one_minus_f * y2)), m2 && (u2.phi = -u2.phi);
            }
            return u2.lam += this.long0, t2.x = u2.lam, t2.y = u2.phi, t2;
          },
          names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"]
        }, ki = [
          [1, 22199e-21, -715515e-10, 31103e-10],
          [0.9986, -482243e-9, -24897e-9, -13309e-10],
          [0.9954, -83103e-8, -448605e-10, -986701e-12],
          [0.99, -135364e-8, -59661e-9, 36777e-10],
          [0.9822, -167442e-8, -449547e-11, -572411e-11],
          [0.973, -214868e-8, -903571e-10, 18736e-12],
          [0.96, -305085e-8, -900761e-10, 164917e-11],
          [0.9427, -382792e-8, -653386e-10, -26154e-10],
          [0.9216, -467746e-8, -10457e-8, 481243e-11],
          [0.8962, -536223e-8, -323831e-10, -543432e-11],
          [0.8679, -609363e-8, -113898e-9, 332484e-11],
          [0.835, -698325e-8, -640253e-10, 934959e-12],
          [0.7986, -755338e-8, -500009e-10, 935324e-12],
          [0.7597, -798324e-8, -35971e-9, -227626e-11],
          [0.7186, -851367e-8, -701149e-10, -86303e-10],
          [0.6732, -986209e-8, -199569e-9, 191974e-10],
          [0.6213, -0.010418, 883923e-10, 624051e-11],
          [0.5722, -906601e-8, 182e-6, 624051e-11],
          [0.5322, -677797e-8, 275608e-9, 624051e-11]
        ], qi = [
          [-520417e-23, 0.0124, 121431e-23, -845284e-16],
          [0.062, 0.0124, -126793e-14, 422642e-15],
          [0.124, 0.0124, 507171e-14, -160604e-14],
          [0.186, 0.0123999, -190189e-13, 600152e-14],
          [0.248, 0.0124002, 710039e-13, -224e-10],
          [0.31, 0.0123992, -264997e-12, 835986e-13],
          [0.372, 0.0124029, 988983e-12, -311994e-12],
          [0.434, 0.0123893, -369093e-11, -435621e-12],
          [0.4958, 0.0123198, -102252e-10, -345523e-12],
          [0.5571, 0.0121916, -154081e-10, -582288e-12],
          [0.6176, 0.0119938, -241424e-10, -525327e-12],
          [0.6769, 0.011713, -320223e-10, -516405e-12],
          [0.7346, 0.0113541, -397684e-10, -609052e-12],
          [0.7903, 0.0109107, -489042e-10, -104739e-11],
          [0.8435, 0.0103431, -64615e-9, -140374e-14],
          [0.8936, 969686e-8, -64636e-9, -8547e-9],
          [0.9394, 840947e-8, -192841e-9, -42106e-10],
          [0.9761, 616527e-8, -256e-6, -42106e-10],
          [1, 328947e-8, -319159e-9, -42106e-10]
        ], Ri = 0.8487, Li = 1.3523, Gi = St / 5, ji = 1 / Gi, Ti = 18, Bi = function(t2, s2) {
          return t2[0] + s2 * (t2[1] + s2 * (t2[2] + s2 * t2[3]));
        }, zi = function(t2, s2) {
          return t2[1] + s2 * (2 * t2[2] + 3 * s2 * t2[3]);
        }, Fi = {
          init: function() {
            this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
          },
          forward: function(t2) {
            var s2 = Vt(t2.x - this.long0), i2 = Math.abs(t2.y), a2 = Math.floor(i2 * Gi);
            a2 < 0 ? a2 = 0 : a2 >= Ti && (a2 = Ti - 1), i2 = St * (i2 - ji * a2);
            var h2 = {
              x: Bi(ki[a2], i2) * s2,
              y: Bi(qi[a2], i2)
            };
            return t2.y < 0 && (h2.y = -h2.y), h2.x = h2.x * this.a * Ri + this.x0, h2.y = h2.y * this.a * Li + this.y0, h2;
          },
          inverse: function(t2) {
            var s2 = {
              x: (t2.x - this.x0) / (this.a * Ri),
              y: Math.abs(t2.y - this.y0) / (this.a * Li)
            };
            if (s2.y >= 1)
              s2.x /= ki[Ti][0], s2.y = t2.y < 0 ? -wt : wt;
            else {
              var i2 = Math.floor(s2.y * Ti);
              for (i2 < 0 ? i2 = 0 : i2 >= Ti && (i2 = Ti - 1); ; )
                if (qi[i2][0] > s2.y)
                  --i2;
                else {
                  if (!(qi[i2 + 1][0] <= s2.y))
                    break;
                  ++i2;
                }
              var a2 = qi[i2], h2 = 5 * (s2.y - a2[0]) / (qi[i2 + 1][0] - a2[0]);
              h2 = Mt(function(t3) {
                return (Bi(a2, t3) - s2.y) / zi(a2, t3);
              }, h2, Ct, 100), s2.x /= Bi(ki[i2], h2), s2.y = (5 * i2 + h2) * Pt, t2.y < 0 && (s2.y = -s2.y);
            }
            return s2.x = Vt(s2.x + this.long0), s2;
          },
          names: ["Robinson", "robin"]
        }, Di = {
          init: function() {
            this.name = "geocent";
          },
          forward: function(t2) {
            return k(t2, this.es, this.a);
          },
          inverse: function(t2) {
            return q(t2, this.es, this.a, this.b);
          },
          names: ["Geocentric", "geocentric", "geocent", "Geocent"]
        }, Ui = {
          N_POLE: 0,
          S_POLE: 1,
          EQUIT: 2,
          OBLIQ: 3
        }, Qi = {
          h: {
            def: 1e5,
            num: true
          },
          azi: {
            def: 0,
            num: true,
            degrees: true
          },
          tilt: {
            def: 0,
            num: true,
            degrees: true
          },
          long0: {
            def: 0,
            num: true
          },
          lat0: {
            def: 0,
            num: true
          }
        }, Wi = {
          init: function() {
            if (Object.keys(Qi).forEach(function(t3) {
              if (void 0 === this[t3])
                this[t3] = Qi[t3].def;
              else {
                if (Qi[t3].num && isNaN(this[t3]))
                  throw new Error(
                    "Invalid parameter value, must be numeric " + t3 + " = " + this[t3]
                  );
                Qi[t3].num && (this[t3] = parseFloat(this[t3]));
              }
              Qi[t3].degrees && (this[t3] = this[t3] * Pt);
            }.bind(this)), Math.abs(Math.abs(this.lat0) - wt) < Ct ? this.mode = this.lat0 < 0 ? Ui.S_POLE : Ui.N_POLE : Math.abs(this.lat0) < Ct ? this.mode = Ui.EQUIT : (this.mode = Ui.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
              throw new Error("Invalid height");
            this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
            var t2 = this.tilt, s2 = this.azi;
            this.cg = Math.cos(s2), this.sg = Math.sin(s2), this.cw = Math.cos(t2), this.sw = Math.sin(t2);
          },
          forward: function(t2) {
            t2.x -= this.long0;
            var s2, i2, a2 = Math.sin(t2.y), h2 = Math.cos(t2.y), e2 = Math.cos(t2.x);
            switch (this.mode) {
              case Ui.OBLIQ:
                i2 = this.sinph0 * a2 + this.cosph0 * h2 * e2;
                break;
              case Ui.EQUIT:
                i2 = h2 * e2;
                break;
              case Ui.S_POLE:
                i2 = -a2;
                break;
              case Ui.N_POLE:
                i2 = a2;
            }
            switch (i2 = this.pn1 / (this.p - i2), s2 = i2 * h2 * Math.sin(t2.x), this.mode) {
              case Ui.OBLIQ:
                i2 *= this.cosph0 * a2 - this.sinph0 * h2 * e2;
                break;
              case Ui.EQUIT:
                i2 *= a2;
                break;
              case Ui.N_POLE:
                i2 *= -h2 * e2;
                break;
              case Ui.S_POLE:
                i2 *= h2 * e2;
            }
            var n2, r2;
            return n2 = i2 * this.cg + s2 * this.sg, r2 = 1 / (n2 * this.sw * this.h1 + this.cw), s2 = (s2 * this.cg - i2 * this.sg) * this.cw * r2, i2 = n2 * r2, t2.x = s2 * this.a, t2.y = i2 * this.a, t2;
          },
          inverse: function(t2) {
            t2.x /= this.a, t2.y /= this.a;
            var s2, i2, a2, h2 = {
              x: t2.x,
              y: t2.y
            };
            a2 = 1 / (this.pn1 - t2.y * this.sw), s2 = this.pn1 * t2.x * a2, i2 = this.pn1 * t2.y * this.cw * a2, t2.x = s2 * this.cg + i2 * this.sg, t2.y = i2 * this.cg - s2 * this.sg;
            var e2 = Ss(t2.x, t2.y);
            if (Math.abs(e2) < Ct)
              h2.x = 0, h2.y = t2.y;
            else {
              var n2, r2;
              switch (r2 = 1 - e2 * e2 * this.pfact, r2 = (this.p - Math.sqrt(r2)) / (this.pn1 / e2 + e2 / this.pn1), n2 = Math.sqrt(1 - r2 * r2), this.mode) {
                case Ui.OBLIQ:
                  h2.y = Math.asin(n2 * this.sinph0 + t2.y * r2 * this.cosph0 / e2), t2.y = (n2 - this.sinph0 * Math.sin(h2.y)) * e2, t2.x *= r2 * this.cosph0;
                  break;
                case Ui.EQUIT:
                  h2.y = Math.asin(t2.y * r2 / e2), t2.y = n2 * e2, t2.x *= r2;
                  break;
                case Ui.N_POLE:
                  h2.y = Math.asin(n2), t2.y = -t2.y;
                  break;
                case Ui.S_POLE:
                  h2.y = -Math.asin(n2);
              }
              h2.x = Math.atan2(t2.x, t2.y);
            }
            return t2.x = h2.x + this.long0, t2.y = h2.y, t2;
          },
          names: ["Tilted_Perspective", "tpers"]
        }, Hi = {
          init: function() {
            if (this.flip_axis = "x" === this.sweep ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
              throw new Error();
            if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, 0 !== this.es) {
              var t2 = 1 - this.es, s2 = 1 / t2;
              this.radius_p = Math.sqrt(t2), this.radius_p2 = t2, this.radius_p_inv2 = s2, this.shape = "ellipse";
            } else
              this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
            this.title || (this.title = "Geostationary Satellite View");
          },
          forward: function(t2) {
            var s2, i2, a2, h2, e2 = t2.x, n2 = t2.y;
            if (e2 -= this.long0, "ellipse" === this.shape) {
              n2 = Math.atan(this.radius_p2 * Math.tan(n2));
              var r2 = this.radius_p / Ss(this.radius_p * Math.cos(n2), Math.sin(n2));
              if (i2 = r2 * Math.cos(e2) * Math.cos(n2), a2 = r2 * Math.sin(e2) * Math.cos(n2), h2 = r2 * Math.sin(
                n2
              ), (this.radius_g - i2) * i2 - a2 * a2 - h2 * h2 * this.radius_p_inv2 < 0)
                return t2.x = Number.NaN, t2.y = Number.NaN, t2;
              s2 = this.radius_g - i2, this.flip_axis ? (t2.x = this.radius_g_1 * Math.atan(a2 / Ss(h2, s2)), t2.y = this.radius_g_1 * Math.atan(h2 / s2)) : (t2.x = this.radius_g_1 * Math.atan(a2 / s2), t2.y = this.radius_g_1 * Math.atan(h2 / Ss(a2, s2)));
            } else
              "sphere" === this.shape && (s2 = Math.cos(n2), i2 = Math.cos(e2) * s2, a2 = Math.sin(e2) * s2, h2 = Math.sin(n2), s2 = this.radius_g - i2, this.flip_axis ? (t2.x = this.radius_g_1 * Math.atan(a2 / Ss(h2, s2)), t2.y = this.radius_g_1 * Math.atan(h2 / s2)) : (t2.x = this.radius_g_1 * Math.atan(a2 / s2), t2.y = this.radius_g_1 * Math.atan(h2 / Ss(a2, s2))));
            return t2.x = t2.x * this.a, t2.y = t2.y * this.a, t2;
          },
          inverse: function(t2) {
            var s2, i2, a2, h2, e2 = -1, n2 = 0, r2 = 0;
            if (t2.x = t2.x / this.a, t2.y = t2.y / this.a, "ellipse" === this.shape) {
              this.flip_axis ? (r2 = Math.tan(t2.y / this.radius_g_1), n2 = Math.tan(t2.x / this.radius_g_1) * Ss(1, r2)) : (n2 = Math.tan(t2.x / this.radius_g_1), r2 = Math.tan(t2.y / this.radius_g_1) * Ss(1, n2));
              var o2 = r2 / this.radius_p;
              if (s2 = n2 * n2 + o2 * o2 + e2 * e2, i2 = 2 * this.radius_g * e2, (a2 = i2 * i2 - 4 * s2 * this.C) < 0)
                return t2.x = Number.NaN, t2.y = Number.NaN, t2;
              h2 = (-i2 - Math.sqrt(a2)) / (2 * s2), e2 = this.radius_g + h2 * e2, n2 *= h2, r2 *= h2, t2.x = Math.atan2(n2, e2), t2.y = Math.atan(r2 * Math.cos(t2.x) / e2), t2.y = Math.atan(this.radius_p_inv2 * Math.tan(t2.y));
            } else if ("sphere" === this.shape) {
              if (this.flip_axis ? (r2 = Math.tan(t2.y / this.radius_g_1), n2 = Math.tan(t2.x / this.radius_g_1) * Math.sqrt(1 + r2 * r2)) : (n2 = Math.tan(t2.x / this.radius_g_1), r2 = Math.tan(t2.y / this.radius_g_1) * Math.sqrt(1 + n2 * n2)), s2 = n2 * n2 + r2 * r2 + e2 * e2, i2 = 2 * this.radius_g * e2, (a2 = i2 * i2 - 4 * s2 * this.C) < 0)
                return t2.x = Number.NaN, t2.y = Number.NaN, t2;
              h2 = (-i2 - Math.sqrt(a2)) / (2 * s2), e2 = this.radius_g + h2 * e2, n2 *= h2, r2 *= h2, t2.x = Math.atan2(n2, e2), t2.y = Math.atan(r2 * Math.cos(t2.x) / e2);
            }
            return t2.x = t2.x + this.long0, t2;
          },
          names: ["Geostationary Satellite View", "Geostationary_Satellite", "geos"]
        }, Xi = 1.340264, Ki = -0.081106, Ji = 893e-6, Vi = 3796e-6, Zi = Math.sqrt(3) / 2, Yi = {
          init: function() {
            this.es = 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0;
          },
          forward: function(t2) {
            var s2 = Vt(t2.x - this.long0), i2 = t2.y, a2 = Math.asin(Zi * Math.sin(i2)), h2 = a2 * a2, e2 = h2 * h2 * h2;
            return t2.x = s2 * Math.cos(a2) / (Zi * (Xi + 3 * Ki * h2 + e2 * (7 * Ji + 9 * Vi * h2))), t2.y = a2 * (Xi + Ki * h2 + e2 * (Ji + Vi * h2)), t2.x = this.a * t2.x + this.x0, t2.y = this.a * t2.y + this.y0, t2;
          },
          inverse: function(t2) {
            t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a;
            var s2, i2, a2, h2, e2, n2, r2 = t2.y;
            for (n2 = 0; n2 < 12 && (s2 = r2 * r2, i2 = s2 * s2 * s2, a2 = r2 * (Xi + Ki * s2 + i2 * (Ji + Vi * s2)) - t2.y, h2 = Xi + 3 * Ki * s2 + i2 * (7 * Ji + 9 * Vi * s2), r2 -= e2 = a2 / h2, !(Math.abs(e2) < 1e-9)); ++n2)
              ;
            return s2 = r2 * r2, i2 = s2 * s2 * s2, t2.x = Zi * t2.x * (Xi + 3 * Ki * s2 + i2 * (7 * Ji + 9 * Vi * s2)) / Math.cos(r2), t2.y = Math.asin(Math.sin(r2) / Zi), t2.x = Vt(t2.x + this.long0), t2;
          },
          names: ["eqearth", "Equal Earth", "Equal_Earth"]
        }, $i = 1e-10, ta = {
          init: function() {
            var t2;
            if (this.phi1 = this.lat1, Math.abs(this.phi1) < $i)
              throw new Error();
            this.es ? (this.en = Ns(this.es), this.m1 = Es(this.phi1, this.am1 = Math.sin(this.phi1), t2 = Math.cos(this.phi1), this.en), this.am1 = t2 / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = dt, this.forward = ft) : (Math.abs(this.phi1) + $i >= wt ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = pt, this.forward = mt);
          },
          names: ["bonne", "Bonne (Werner lat_1=90)"]
        };
        return W.defaultDatum = "WGS84", W.Proj = Projection, W.WGS84 = new W.Proj("WGS84"), W.Point = Point, W.toPoint = cs, W.defs = o, W.nadgrid = function(t2, s2) {
          var i2 = new DataView(s2), a2 = N(i2), h2 = E(i2, a2), e2 = {
            header: h2,
            subgrids: C(i2, h2, a2)
          };
          return os[t2] = e2, e2;
        }, W.transform = D, W.mgrs = bs, W.version = "2.14.0", function(proj4) {
          proj4.Proj.projections.add(Cs), proj4.Proj.projections.add(Gs), proj4.Proj.projections.add(Ts), proj4.Proj.projections.add(Ds), proj4.Proj.projections.add(Us), proj4.Proj.projections.add(Qs), proj4.Proj.projections.add(Hs), proj4.Proj.projections.add(Xs), proj4.Proj.projections.add(Ks), proj4.Proj.projections.add(ai), proj4.Proj.projections.add(ci), proj4.Proj.projections.add(fi), proj4.Proj.projections.add(di), proj4.Proj.projections.add(pi), proj4.Proj.projections.add(yi), proj4.Proj.projections.add(xi), proj4.Proj.projections.add(gi), proj4.Proj.projections.add(vi), proj4.Proj.projections.add(wi), proj4.Proj.projections.add(Ni), proj4.Proj.projections.add(Ei), proj4.Proj.projections.add(Ai), proj4.Proj.projections.add(Ci), proj4.Proj.projections.add(Pi), proj4.Proj.projections.add(Oi), proj4.Proj.projections.add(Fi), proj4.Proj.projections.add(Di), proj4.Proj.projections.add(Wi), proj4.Proj.projections.add(Hi), proj4.Proj.projections.add(Yi), proj4.Proj.projections.add(ta);
        }(W), W;
      });
    }
  });

  // C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/node_modules/leaflet/dist/leaflet-src.js
  var require_leaflet_src = __commonJS({
    "C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.leaflet = {}));
      })(exports, function(exports2) {
        "use strict";
        var version = "1.9.4";
        function extend(dest) {
          var i, j, len, src;
          for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
              dest[i] = src[i];
            }
          }
          return dest;
        }
        var create$2 = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(proto) {
            F.prototype = proto;
            return new F();
          };
        }();
        function bind(fn, obj) {
          var slice = Array.prototype.slice;
          if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
          }
          var args = slice.call(arguments, 2);
          return function() {
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
          };
        }
        var lastId = 0;
        function stamp(obj) {
          if (!("_leaflet_id" in obj)) {
            obj["_leaflet_id"] = ++lastId;
          }
          return obj._leaflet_id;
        }
        function throttle(fn, time, context) {
          var lock, args, wrapperFn, later;
          later = function() {
            lock = false;
            if (args) {
              wrapperFn.apply(context, args);
              args = false;
            }
          };
          wrapperFn = function() {
            if (lock) {
              args = arguments;
            } else {
              fn.apply(context, arguments);
              setTimeout(later, time);
              lock = true;
            }
          };
          return wrapperFn;
        }
        function wrapNum(x, range, includeMax) {
          var max = range[1], min = range[0], d = max - min;
          return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
        }
        function falseFn() {
          return false;
        }
        function formatNum(num, precision) {
          if (precision === false) {
            return num;
          }
          var pow = Math.pow(10, precision === void 0 ? 6 : precision);
          return Math.round(num * pow) / pow;
        }
        function trim(str) {
          return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
        }
        function splitWords(str) {
          return trim(str).split(/\s+/);
        }
        function setOptions(obj, options) {
          if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
            obj.options = obj.options ? create$2(obj.options) : {};
          }
          for (var i in options) {
            obj.options[i] = options[i];
          }
          return obj.options;
        }
        function getParamString(obj, existingUrl, uppercase) {
          var params = [];
          for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
          }
          return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        }
        var templateRe = /\{ *([\w_ -]+) *\}/g;
        function template(str, data) {
          return str.replace(templateRe, function(str2, key) {
            var value = data[key];
            if (value === void 0) {
              throw new Error("No value provided for variable " + str2);
            } else if (typeof value === "function") {
              value = value(data);
            }
            return value;
          });
        }
        var isArray = Array.isArray || function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        function indexOf(array, el) {
          for (var i = 0; i < array.length; i++) {
            if (array[i] === el) {
              return i;
            }
          }
          return -1;
        }
        var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function getPrefixed(name) {
          return window["webkit" + name] || window["moz" + name] || window["ms" + name];
        }
        var lastTime = 0;
        function timeoutDefer(fn) {
          var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
          lastTime = time + timeToCall;
          return window.setTimeout(fn, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
          window.clearTimeout(id);
        };
        function requestAnimFrame(fn, context, immediate) {
          if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
          } else {
            return requestFn.call(window, bind(fn, context));
          }
        }
        function cancelAnimFrame(id) {
          if (id) {
            cancelFn.call(window, id);
          }
        }
        var Util = {
          __proto__: null,
          extend,
          create: create$2,
          bind,
          get lastId() {
            return lastId;
          },
          stamp,
          throttle,
          wrapNum,
          falseFn,
          formatNum,
          trim,
          splitWords,
          setOptions,
          getParamString,
          template,
          isArray,
          indexOf,
          emptyImageUrl,
          requestFn,
          cancelFn,
          requestAnimFrame,
          cancelAnimFrame
        };
        function Class() {
        }
        Class.extend = function(props) {
          var NewClass = function() {
            setOptions(this);
            if (this.initialize) {
              this.initialize.apply(this, arguments);
            }
            this.callInitHooks();
          };
          var parentProto = NewClass.__super__ = this.prototype;
          var proto = create$2(parentProto);
          proto.constructor = NewClass;
          NewClass.prototype = proto;
          for (var i in this) {
            if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
              NewClass[i] = this[i];
            }
          }
          if (props.statics) {
            extend(NewClass, props.statics);
          }
          if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend.apply(null, [proto].concat(props.includes));
          }
          extend(proto, props);
          delete proto.statics;
          delete proto.includes;
          if (proto.options) {
            proto.options = parentProto.options ? create$2(parentProto.options) : {};
            extend(proto.options, props.options);
          }
          proto._initHooks = [];
          proto.callInitHooks = function() {
            if (this._initHooksCalled) {
              return;
            }
            if (parentProto.callInitHooks) {
              parentProto.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
              proto._initHooks[i2].call(this);
            }
          };
          return NewClass;
        };
        Class.include = function(props) {
          var parentOptions = this.prototype.options;
          extend(this.prototype, props);
          if (props.options) {
            this.prototype.options = parentOptions;
            this.mergeOptions(props.options);
          }
          return this;
        };
        Class.mergeOptions = function(options) {
          extend(this.prototype.options, options);
          return this;
        };
        Class.addInitHook = function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          var init = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
          };
          this.prototype._initHooks = this.prototype._initHooks || [];
          this.prototype._initHooks.push(init);
          return this;
        };
        function checkDeprecatedMixinEvents(includes) {
          if (typeof L === "undefined" || !L || !L.Mixin) {
            return;
          }
          includes = isArray(includes) ? includes : [includes];
          for (var i = 0; i < includes.length; i++) {
            if (includes[i] === L.Mixin.Events) {
              console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
            }
          }
        }
        var Events = {
          /* @method on(type: String, fn: Function, context?: Object): this
           * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
           *
           * @alternative
           * @method on(eventMap: Object): this
           * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
           */
          on: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._on(types[i], fn, context);
              }
            }
            return this;
          },
          /* @method off(type: String, fn?: Function, context?: Object): this
           * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
           *
           * @alternative
           * @method off(eventMap: Object): this
           * Removes a set of type/listener pairs.
           *
           * @alternative
           * @method off: this
           * Removes all listeners to all events on the object. This includes implicitly attached events.
           */
          off: function(types, fn, context) {
            if (!arguments.length) {
              delete this._events;
            } else if (typeof types === "object") {
              for (var type in types) {
                this._off(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              var removeAll = arguments.length === 1;
              for (var i = 0, len = types.length; i < len; i++) {
                if (removeAll) {
                  this._off(types[i]);
                } else {
                  this._off(types[i], fn, context);
                }
              }
            }
            return this;
          },
          // attach listener (without syntactic sugar now)
          _on: function(type, fn, context, _once) {
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            if (this._listens(type, fn, context) !== false) {
              return;
            }
            if (context === this) {
              context = void 0;
            }
            var newListener = { fn, ctx: context };
            if (_once) {
              newListener.once = true;
            }
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(newListener);
          },
          _off: function(type, fn, context) {
            var listeners, i, len;
            if (!this._events) {
              return;
            }
            listeners = this._events[type];
            if (!listeners) {
              return;
            }
            if (arguments.length === 1) {
              if (this._firingCount) {
                for (i = 0, len = listeners.length; i < len; i++) {
                  listeners[i].fn = falseFn;
                }
              }
              delete this._events[type];
              return;
            }
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            var index2 = this._listens(type, fn, context);
            if (index2 !== false) {
              var listener = listeners[index2];
              if (this._firingCount) {
                listener.fn = falseFn;
                this._events[type] = listeners = listeners.slice();
              }
              listeners.splice(index2, 1);
            }
          },
          // @method fire(type: String, data?: Object, propagate?: Boolean): this
          // Fires an event of the specified type. You can optionally provide a data
          // object  the first argument of the listener function will contain its
          // properties. The event can optionally be propagated to event parents.
          fire: function(type, data, propagate) {
            if (!this.listens(type, propagate)) {
              return this;
            }
            var event = extend({}, data, {
              type,
              target: this,
              sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
              var listeners = this._events[type];
              if (listeners) {
                this._firingCount = this._firingCount + 1 || 1;
                for (var i = 0, len = listeners.length; i < len; i++) {
                  var l = listeners[i];
                  var fn = l.fn;
                  if (l.once) {
                    this.off(type, fn, l.ctx);
                  }
                  fn.call(l.ctx || this, event);
                }
                this._firingCount--;
              }
            }
            if (propagate) {
              this._propagateEvent(event);
            }
            return this;
          },
          // @method listens(type: String, propagate?: Boolean): Boolean
          // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
          // Returns `true` if a particular event type has any listeners attached to it.
          // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
          listens: function(type, fn, context, propagate) {
            if (typeof type !== "string") {
              console.warn('"string" type argument expected');
            }
            var _fn = fn;
            if (typeof fn !== "function") {
              propagate = !!fn;
              _fn = void 0;
              context = void 0;
            }
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
              if (this._listens(type, _fn, context) !== false) {
                return true;
              }
            }
            if (propagate) {
              for (var id in this._eventParents) {
                if (this._eventParents[id].listens(type, fn, context, propagate)) {
                  return true;
                }
              }
            }
            return false;
          },
          // returns the index (number) or false
          _listens: function(type, fn, context) {
            if (!this._events) {
              return false;
            }
            var listeners = this._events[type] || [];
            if (!fn) {
              return !!listeners.length;
            }
            if (context === this) {
              context = void 0;
            }
            for (var i = 0, len = listeners.length; i < len; i++) {
              if (listeners[i].fn === fn && listeners[i].ctx === context) {
                return i;
              }
            }
            return false;
          },
          // @method once(): this
          // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
          once: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn, true);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._on(types[i], fn, context, true);
              }
            }
            return this;
          },
          // @method addEventParent(obj: Evented): this
          // Adds an event parent - an `Evented` that will receive propagated events
          addEventParent: function(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
          },
          // @method removeEventParent(obj: Evented): this
          // Removes an event parent, so it will stop receiving propagated events
          removeEventParent: function(obj) {
            if (this._eventParents) {
              delete this._eventParents[stamp(obj)];
            }
            return this;
          },
          _propagateEvent: function(e) {
            for (var id in this._eventParents) {
              this._eventParents[id].fire(e.type, extend({
                layer: e.target,
                propagatedFrom: e.target
              }, e), true);
            }
          }
        };
        Events.addEventListener = Events.on;
        Events.removeEventListener = Events.clearAllEventListeners = Events.off;
        Events.addOneTimeEventListener = Events.once;
        Events.fireEvent = Events.fire;
        Events.hasEventListeners = Events.listens;
        var Evented = Class.extend(Events);
        function Point(x, y, round) {
          this.x = round ? Math.round(x) : x;
          this.y = round ? Math.round(y) : y;
        }
        var trunc = Math.trunc || function(v) {
          return v > 0 ? Math.floor(v) : Math.ceil(v);
        };
        Point.prototype = {
          // @method clone(): Point
          // Returns a copy of the current point.
          clone: function() {
            return new Point(this.x, this.y);
          },
          // @method add(otherPoint: Point): Point
          // Returns the result of addition of the current and the given points.
          add: function(point) {
            return this.clone()._add(toPoint(point));
          },
          _add: function(point) {
            this.x += point.x;
            this.y += point.y;
            return this;
          },
          // @method subtract(otherPoint: Point): Point
          // Returns the result of subtraction of the given point from the current.
          subtract: function(point) {
            return this.clone()._subtract(toPoint(point));
          },
          _subtract: function(point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
          },
          // @method divideBy(num: Number): Point
          // Returns the result of division of the current point by the given number.
          divideBy: function(num) {
            return this.clone()._divideBy(num);
          },
          _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
          },
          // @method multiplyBy(num: Number): Point
          // Returns the result of multiplication of the current point by the given number.
          multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
          },
          _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
          },
          // @method scaleBy(scale: Point): Point
          // Multiply each coordinate of the current point by each coordinate of
          // `scale`. In linear algebra terms, multiply the point by the
          // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
          // defined by `scale`.
          scaleBy: function(point) {
            return new Point(this.x * point.x, this.y * point.y);
          },
          // @method unscaleBy(scale: Point): Point
          // Inverse of `scaleBy`. Divide each coordinate of the current point by
          // each coordinate of `scale`.
          unscaleBy: function(point) {
            return new Point(this.x / point.x, this.y / point.y);
          },
          // @method round(): Point
          // Returns a copy of the current point with rounded coordinates.
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          // @method floor(): Point
          // Returns a copy of the current point with floored coordinates (rounded down).
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          // @method ceil(): Point
          // Returns a copy of the current point with ceiled coordinates (rounded up).
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          // @method trunc(): Point
          // Returns a copy of the current point with truncated coordinates (rounded towards zero).
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
          },
          // @method distanceTo(otherPoint: Point): Number
          // Returns the cartesian distance between the current and the given points.
          distanceTo: function(point) {
            point = toPoint(point);
            var x = point.x - this.x, y = point.y - this.y;
            return Math.sqrt(x * x + y * y);
          },
          // @method equals(otherPoint: Point): Boolean
          // Returns `true` if the given point has the same coordinates.
          equals: function(point) {
            point = toPoint(point);
            return point.x === this.x && point.y === this.y;
          },
          // @method contains(otherPoint: Point): Boolean
          // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
          contains: function(point) {
            point = toPoint(point);
            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
          },
          // @method toString(): String
          // Returns a string representation of the point for debugging purposes.
          toString: function() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
          }
        };
        function toPoint(x, y, round) {
          if (x instanceof Point) {
            return x;
          }
          if (isArray(x)) {
            return new Point(x[0], x[1]);
          }
          if (x === void 0 || x === null) {
            return x;
          }
          if (typeof x === "object" && "x" in x && "y" in x) {
            return new Point(x.x, x.y);
          }
          return new Point(x, y, round);
        }
        function Bounds(a, b) {
          if (!a) {
            return;
          }
          var points2 = b ? [a, b] : a;
          for (var i = 0, len = points2.length; i < len; i++) {
            this.extend(points2[i]);
          }
        }
        Bounds.prototype = {
          // @method extend(point: Point): this
          // Extends the bounds to contain the given point.
          // @alternative
          // @method extend(otherBounds: Bounds): this
          // Extend the bounds to contain the given bounds
          extend: function(obj) {
            var min2, max2;
            if (!obj) {
              return this;
            }
            if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
              min2 = max2 = toPoint(obj);
            } else {
              obj = toBounds(obj);
              min2 = obj.min;
              max2 = obj.max;
              if (!min2 || !max2) {
                return this;
              }
            }
            if (!this.min && !this.max) {
              this.min = min2.clone();
              this.max = max2.clone();
            } else {
              this.min.x = Math.min(min2.x, this.min.x);
              this.max.x = Math.max(max2.x, this.max.x);
              this.min.y = Math.min(min2.y, this.min.y);
              this.max.y = Math.max(max2.y, this.max.y);
            }
            return this;
          },
          // @method getCenter(round?: Boolean): Point
          // Returns the center point of the bounds.
          getCenter: function(round) {
            return toPoint(
              (this.min.x + this.max.x) / 2,
              (this.min.y + this.max.y) / 2,
              round
            );
          },
          // @method getBottomLeft(): Point
          // Returns the bottom-left point of the bounds.
          getBottomLeft: function() {
            return toPoint(this.min.x, this.max.y);
          },
          // @method getTopRight(): Point
          // Returns the top-right point of the bounds.
          getTopRight: function() {
            return toPoint(this.max.x, this.min.y);
          },
          // @method getTopLeft(): Point
          // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
          getTopLeft: function() {
            return this.min;
          },
          // @method getBottomRight(): Point
          // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
          getBottomRight: function() {
            return this.max;
          },
          // @method getSize(): Point
          // Returns the size of the given bounds
          getSize: function() {
            return this.max.subtract(this.min);
          },
          // @method contains(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle contains the given one.
          // @alternative
          // @method contains(point: Point): Boolean
          // Returns `true` if the rectangle contains the given point.
          contains: function(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof Point) {
              obj = toPoint(obj);
            } else {
              obj = toBounds(obj);
            }
            if (obj instanceof Bounds) {
              min = obj.min;
              max = obj.max;
            } else {
              min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
          },
          // @method intersects(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle intersects the given bounds. Two bounds
          // intersect if they have at least one point in common.
          intersects: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
          },
          // @method overlaps(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle overlaps the given bounds. Two bounds
          // overlap if their intersection is an area.
          overlaps: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
            return xOverlaps && yOverlaps;
          },
          // @method isValid(): Boolean
          // Returns `true` if the bounds are properly initialized.
          isValid: function() {
            return !!(this.min && this.max);
          },
          // @method pad(bufferRatio: Number): Bounds
          // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
          // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
          // Negative values will retract the bounds.
          pad: function(bufferRatio) {
            var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
            return toBounds(
              toPoint(min.x - heightBuffer, min.y - widthBuffer),
              toPoint(max.x + heightBuffer, max.y + widthBuffer)
            );
          },
          // @method equals(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle is equivalent to the given bounds.
          equals: function(bounds) {
            if (!bounds) {
              return false;
            }
            bounds = toBounds(bounds);
            return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
          }
        };
        function toBounds(a, b) {
          if (!a || a instanceof Bounds) {
            return a;
          }
          return new Bounds(a, b);
        }
        function LatLngBounds(corner1, corner2) {
          if (!corner1) {
            return;
          }
          var latlngs = corner2 ? [corner1, corner2] : corner1;
          for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
          }
        }
        LatLngBounds.prototype = {
          // @method extend(latlng: LatLng): this
          // Extend the bounds to contain the given point
          // @alternative
          // @method extend(otherBounds: LatLngBounds): this
          // Extend the bounds to contain the given bounds
          extend: function(obj) {
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLng) {
              sw2 = obj;
              ne2 = obj;
            } else if (obj instanceof LatLngBounds) {
              sw2 = obj._southWest;
              ne2 = obj._northEast;
              if (!sw2 || !ne2) {
                return this;
              }
            } else {
              return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            }
            if (!sw && !ne) {
              this._southWest = new LatLng(sw2.lat, sw2.lng);
              this._northEast = new LatLng(ne2.lat, ne2.lng);
            } else {
              sw.lat = Math.min(sw2.lat, sw.lat);
              sw.lng = Math.min(sw2.lng, sw.lng);
              ne.lat = Math.max(ne2.lat, ne.lat);
              ne.lng = Math.max(ne2.lng, ne.lng);
            }
            return this;
          },
          // @method pad(bufferRatio: Number): LatLngBounds
          // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
          // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
          // Negative values will retract the bounds.
          pad: function(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new LatLngBounds(
              new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
              new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
            );
          },
          // @method getCenter(): LatLng
          // Returns the center point of the bounds.
          getCenter: function() {
            return new LatLng(
              (this._southWest.lat + this._northEast.lat) / 2,
              (this._southWest.lng + this._northEast.lng) / 2
            );
          },
          // @method getSouthWest(): LatLng
          // Returns the south-west point of the bounds.
          getSouthWest: function() {
            return this._southWest;
          },
          // @method getNorthEast(): LatLng
          // Returns the north-east point of the bounds.
          getNorthEast: function() {
            return this._northEast;
          },
          // @method getNorthWest(): LatLng
          // Returns the north-west point of the bounds.
          getNorthWest: function() {
            return new LatLng(this.getNorth(), this.getWest());
          },
          // @method getSouthEast(): LatLng
          // Returns the south-east point of the bounds.
          getSouthEast: function() {
            return new LatLng(this.getSouth(), this.getEast());
          },
          // @method getWest(): Number
          // Returns the west longitude of the bounds
          getWest: function() {
            return this._southWest.lng;
          },
          // @method getSouth(): Number
          // Returns the south latitude of the bounds
          getSouth: function() {
            return this._southWest.lat;
          },
          // @method getEast(): Number
          // Returns the east longitude of the bounds
          getEast: function() {
            return this._northEast.lng;
          },
          // @method getNorth(): Number
          // Returns the north latitude of the bounds
          getNorth: function() {
            return this._northEast.lat;
          },
          // @method contains(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle contains the given one.
          // @alternative
          // @method contains (latlng: LatLng): Boolean
          // Returns `true` if the rectangle contains the given point.
          contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
              obj = toLatLng(obj);
            } else {
              obj = toLatLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLngBounds) {
              sw2 = obj.getSouthWest();
              ne2 = obj.getNorthEast();
            } else {
              sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
          },
          // @method intersects(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
          intersects: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
          },
          // @method overlaps(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
          overlaps: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
            return latOverlaps && lngOverlaps;
          },
          // @method toBBoxString(): String
          // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
          // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
          equals: function(bounds, maxMargin) {
            if (!bounds) {
              return false;
            }
            bounds = toLatLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
          },
          // @method isValid(): Boolean
          // Returns `true` if the bounds are properly initialized.
          isValid: function() {
            return !!(this._southWest && this._northEast);
          }
        };
        function toLatLngBounds(a, b) {
          if (a instanceof LatLngBounds) {
            return a;
          }
          return new LatLngBounds(a, b);
        }
        function LatLng(lat, lng, alt) {
          if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
          }
          this.lat = +lat;
          this.lng = +lng;
          if (alt !== void 0) {
            this.alt = +alt;
          }
        }
        LatLng.prototype = {
          // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
          // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
          equals: function(obj, maxMargin) {
            if (!obj) {
              return false;
            }
            obj = toLatLng(obj);
            var margin = Math.max(
              Math.abs(this.lat - obj.lat),
              Math.abs(this.lng - obj.lng)
            );
            return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
          },
          // @method toString(): String
          // Returns a string representation of the point (for debugging purposes).
          toString: function(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
          },
          // @method distanceTo(otherLatLng: LatLng): Number
          // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
          distanceTo: function(other) {
            return Earth.distance(this, toLatLng(other));
          },
          // @method wrap(): LatLng
          // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
          wrap: function() {
            return Earth.wrapLatLng(this);
          },
          // @method toBounds(sizeInMeters: Number): LatLngBounds
          // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
          toBounds: function(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds(
              [this.lat - latAccuracy, this.lng - lngAccuracy],
              [this.lat + latAccuracy, this.lng + lngAccuracy]
            );
          },
          clone: function() {
            return new LatLng(this.lat, this.lng, this.alt);
          }
        };
        function toLatLng(a, b, c) {
          if (a instanceof LatLng) {
            return a;
          }
          if (isArray(a) && typeof a[0] !== "object") {
            if (a.length === 3) {
              return new LatLng(a[0], a[1], a[2]);
            }
            if (a.length === 2) {
              return new LatLng(a[0], a[1]);
            }
            return null;
          }
          if (a === void 0 || a === null) {
            return a;
          }
          if (typeof a === "object" && "lat" in a) {
            return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
          }
          if (b === void 0) {
            return null;
          }
          return new LatLng(a, b, c);
        }
        var CRS = {
          // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
          // Projects geographical coordinates into pixel coordinates for a given zoom.
          latLngToPoint: function(latlng, zoom2) {
            var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
            return this.transformation._transform(projectedPoint, scale2);
          },
          // @method pointToLatLng(point: Point, zoom: Number): LatLng
          // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
          // zoom into geographical coordinates.
          pointToLatLng: function(point, zoom2) {
            var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
            return this.projection.unproject(untransformedPoint);
          },
          // @method project(latlng: LatLng): Point
          // Projects geographical coordinates into coordinates in units accepted for
          // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
          project: function(latlng) {
            return this.projection.project(latlng);
          },
          // @method unproject(point: Point): LatLng
          // Given a projected coordinate returns the corresponding LatLng.
          // The inverse of `project`.
          unproject: function(point) {
            return this.projection.unproject(point);
          },
          // @method scale(zoom: Number): Number
          // Returns the scale used when transforming projected coordinates into
          // pixel coordinates for a particular zoom. For example, it returns
          // `256 * 2^zoom` for Mercator-based CRS.
          scale: function(zoom2) {
            return 256 * Math.pow(2, zoom2);
          },
          // @method zoom(scale: Number): Number
          // Inverse of `scale()`, returns the zoom level corresponding to a scale
          // factor of `scale`.
          zoom: function(scale2) {
            return Math.log(scale2 / 256) / Math.LN2;
          },
          // @method getProjectedBounds(zoom: Number): Bounds
          // Returns the projection's bounds scaled and transformed for the provided `zoom`.
          getProjectedBounds: function(zoom2) {
            if (this.infinite) {
              return null;
            }
            var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
            return new Bounds(min, max);
          },
          // @method distance(latlng1: LatLng, latlng2: LatLng): Number
          // Returns the distance between two geographical coordinates.
          // @property code: String
          // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
          //
          // @property wrapLng: Number[]
          // An array of two numbers defining whether the longitude (horizontal) coordinate
          // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
          // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
          //
          // @property wrapLat: Number[]
          // Like `wrapLng`, but for the latitude (vertical) axis.
          // wrapLng: [min, max],
          // wrapLat: [min, max],
          // @property infinite: Boolean
          // If true, the coordinate space will be unbounded (infinite in both axes)
          infinite: false,
          // @method wrapLatLng(latlng: LatLng): LatLng
          // Returns a `LatLng` where lat and lng has been wrapped according to the
          // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
          wrapLatLng: function(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng(lat, lng, alt);
          },
          // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
          // Returns a `LatLngBounds` with the same size as the given one, ensuring
          // that its center is within the CRS's bounds.
          // Only accepts actual `L.LatLngBounds` instances, not arrays.
          wrapLatLngBounds: function(bounds) {
            var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) {
              return bounds;
            }
            var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
            return new LatLngBounds(newSw, newNe);
          }
        };
        var Earth = extend({}, CRS, {
          wrapLng: [-180, 180],
          // Mean Earth Radius, as recommended for use by
          // the International Union of Geodesy and Geophysics,
          // see https://rosettacode.org/wiki/Haversine_formula
          R: 6371e3,
          // distance between two geographical points using spherical law of cosines approximation
          distance: function(latlng1, latlng2) {
            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return this.R * c;
          }
        });
        var earthRadius = 6378137;
        var SphericalMercator = {
          R: earthRadius,
          MAX_LATITUDE: 85.0511287798,
          project: function(latlng) {
            var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
            return new Point(
              this.R * latlng.lng * d,
              this.R * Math.log((1 + sin) / (1 - sin)) / 2
            );
          },
          unproject: function(point) {
            var d = 180 / Math.PI;
            return new LatLng(
              (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d,
              point.x * d / this.R
            );
          },
          bounds: function() {
            var d = earthRadius * Math.PI;
            return new Bounds([-d, -d], [d, d]);
          }()
        };
        function Transformation(a, b, c, d) {
          if (isArray(a)) {
            this._a = a[0];
            this._b = a[1];
            this._c = a[2];
            this._d = a[3];
            return;
          }
          this._a = a;
          this._b = b;
          this._c = c;
          this._d = d;
        }
        Transformation.prototype = {
          // @method transform(point: Point, scale?: Number): Point
          // Returns a transformed point, optionally multiplied by the given scale.
          // Only accepts actual `L.Point` instances, not arrays.
          transform: function(point, scale2) {
            return this._transform(point.clone(), scale2);
          },
          // destructive transform (faster)
          _transform: function(point, scale2) {
            scale2 = scale2 || 1;
            point.x = scale2 * (this._a * point.x + this._b);
            point.y = scale2 * (this._c * point.y + this._d);
            return point;
          },
          // @method untransform(point: Point, scale?: Number): Point
          // Returns the reverse transformation of the given point, optionally divided
          // by the given scale. Only accepts actual `L.Point` instances, not arrays.
          untransform: function(point, scale2) {
            scale2 = scale2 || 1;
            return new Point(
              (point.x / scale2 - this._b) / this._a,
              (point.y / scale2 - this._d) / this._c
            );
          }
        };
        function toTransformation(a, b, c, d) {
          return new Transformation(a, b, c, d);
        }
        var EPSG3857 = extend({}, Earth, {
          code: "EPSG:3857",
          projection: SphericalMercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG900913 = extend({}, EPSG3857, {
          code: "EPSG:900913"
        });
        function svgCreate(name) {
          return document.createElementNS("http://www.w3.org/2000/svg", name);
        }
        function pointsToPath(rings, closed) {
          var str = "", i, j, len, len2, points2, p;
          for (i = 0, len = rings.length; i < len; i++) {
            points2 = rings[i];
            for (j = 0, len2 = points2.length; j < len2; j++) {
              p = points2[j];
              str += (j ? "L" : "M") + p.x + " " + p.y;
            }
            str += closed ? Browser.svg ? "z" : "x" : "";
          }
          return str || "M0 0";
        }
        var style = document.documentElement.style;
        var ie = "ActiveXObject" in window;
        var ielt9 = ie && !document.addEventListener;
        var edge = "msLaunchUri" in navigator && !("documentMode" in document);
        var webkit = userAgentContains("webkit");
        var android = userAgentContains("android");
        var android23 = userAgentContains("android 2") || userAgentContains("android 3");
        var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
        var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
        var opera = !!window.opera;
        var chrome = !edge && userAgentContains("chrome");
        var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
        var safari = !chrome && userAgentContains("safari");
        var phantom = userAgentContains("phantom");
        var opera12 = "OTransition" in style;
        var win = navigator.platform.indexOf("Win") === 0;
        var ie3d = ie && "transition" in style;
        var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
        var gecko3d = "MozPerspective" in style;
        var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
        var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
        var mobileWebkit = mobile && webkit;
        var mobileWebkit3d = mobile && webkit3d;
        var msPointer = !window.PointerEvent && window.MSPointerEvent;
        var pointer = !!(window.PointerEvent || msPointer);
        var touchNative = "ontouchstart" in window || !!window.TouchEvent;
        var touch = !window.L_NO_TOUCH && (touchNative || pointer);
        var mobileOpera = mobile && opera;
        var mobileGecko = mobile && gecko;
        var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
        var passiveEvents = function() {
          var supportsPassiveOption = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassiveOption = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
          } catch (e) {
          }
          return supportsPassiveOption;
        }();
        var canvas$1 = function() {
          return !!document.createElement("canvas").getContext;
        }();
        var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
        var inlineSvg = !!svg$1 && function() {
          var div = document.createElement("div");
          div.innerHTML = "<svg/>";
          return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
        }();
        var vml = !svg$1 && function() {
          try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
          } catch (e) {
            return false;
          }
        }();
        var mac = navigator.platform.indexOf("Mac") === 0;
        var linux = navigator.platform.indexOf("Linux") === 0;
        function userAgentContains(str) {
          return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
        }
        var Browser = {
          ie,
          ielt9,
          edge,
          webkit,
          android,
          android23,
          androidStock,
          opera,
          chrome,
          gecko,
          safari,
          phantom,
          opera12,
          win,
          ie3d,
          webkit3d,
          gecko3d,
          any3d,
          mobile,
          mobileWebkit,
          mobileWebkit3d,
          msPointer,
          pointer,
          touch,
          touchNative,
          mobileOpera,
          mobileGecko,
          retina,
          passiveEvents,
          canvas: canvas$1,
          svg: svg$1,
          vml,
          inlineSvg,
          mac,
          linux
        };
        var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
        var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
        var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
        var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
        var pEvent = {
          touchstart: POINTER_DOWN,
          touchmove: POINTER_MOVE,
          touchend: POINTER_UP,
          touchcancel: POINTER_CANCEL
        };
        var handle = {
          touchstart: _onPointerStart,
          touchmove: _handlePointer,
          touchend: _handlePointer,
          touchcancel: _handlePointer
        };
        var _pointers = {};
        var _pointerDocListener = false;
        function addPointerListener(obj, type, handler) {
          if (type === "touchstart") {
            _addPointerDocListener();
          }
          if (!handle[type]) {
            console.warn("wrong event specified:", type);
            return falseFn;
          }
          handler = handle[type].bind(this, handler);
          obj.addEventListener(pEvent[type], handler, false);
          return handler;
        }
        function removePointerListener(obj, type, handler) {
          if (!pEvent[type]) {
            console.warn("wrong event specified:", type);
            return;
          }
          obj.removeEventListener(pEvent[type], handler, false);
        }
        function _globalPointerDown(e) {
          _pointers[e.pointerId] = e;
        }
        function _globalPointerMove(e) {
          if (_pointers[e.pointerId]) {
            _pointers[e.pointerId] = e;
          }
        }
        function _globalPointerUp(e) {
          delete _pointers[e.pointerId];
        }
        function _addPointerDocListener() {
          if (!_pointerDocListener) {
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
          }
        }
        function _handlePointer(handler, e) {
          if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
            return;
          }
          e.touches = [];
          for (var i in _pointers) {
            e.touches.push(_pointers[i]);
          }
          e.changedTouches = [e];
          handler(e);
        }
        function _onPointerStart(handler, e) {
          if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
            preventDefault(e);
          }
          _handlePointer(handler, e);
        }
        function makeDblclick(event) {
          var newEvent = {}, prop, i;
          for (i in event) {
            prop = event[i];
            newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
          }
          event = newEvent;
          newEvent.type = "dblclick";
          newEvent.detail = 2;
          newEvent.isTrusted = false;
          newEvent._simulated = true;
          return newEvent;
        }
        var delay = 200;
        function addDoubleTapListener(obj, handler) {
          obj.addEventListener("dblclick", handler);
          var last = 0, detail;
          function simDblclick(e) {
            if (e.detail !== 1) {
              detail = e.detail;
              return;
            }
            if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
              return;
            }
            var path = getPropagationPath(e);
            if (path.some(function(el) {
              return el instanceof HTMLLabelElement && el.attributes.for;
            }) && !path.some(function(el) {
              return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
            })) {
              return;
            }
            var now = Date.now();
            if (now - last <= delay) {
              detail++;
              if (detail === 2) {
                handler(makeDblclick(e));
              }
            } else {
              detail = 1;
            }
            last = now;
          }
          obj.addEventListener("click", simDblclick);
          return {
            dblclick: handler,
            simDblclick
          };
        }
        function removeDoubleTapListener(obj, handlers) {
          obj.removeEventListener("dblclick", handlers.dblclick);
          obj.removeEventListener("click", handlers.simDblclick);
        }
        var TRANSFORM = testProp(
          ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
        );
        var TRANSITION = testProp(
          ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
        );
        var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
        function get(id) {
          return typeof id === "string" ? document.getElementById(id) : id;
        }
        function getStyle(el, style2) {
          var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
          if ((!value || value === "auto") && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style2] : null;
          }
          return value === "auto" ? null : value;
        }
        function create$1(tagName, className, container) {
          var el = document.createElement(tagName);
          el.className = className || "";
          if (container) {
            container.appendChild(el);
          }
          return el;
        }
        function remove(el) {
          var parent = el.parentNode;
          if (parent) {
            parent.removeChild(el);
          }
        }
        function empty(el) {
          while (el.firstChild) {
            el.removeChild(el.firstChild);
          }
        }
        function toFront(el) {
          var parent = el.parentNode;
          if (parent && parent.lastChild !== el) {
            parent.appendChild(el);
          }
        }
        function toBack(el) {
          var parent = el.parentNode;
          if (parent && parent.firstChild !== el) {
            parent.insertBefore(el, parent.firstChild);
          }
        }
        function hasClass(el, name) {
          if (el.classList !== void 0) {
            return el.classList.contains(name);
          }
          var className = getClass(el);
          return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        }
        function addClass(el, name) {
          if (el.classList !== void 0) {
            var classes = splitWords(name);
            for (var i = 0, len = classes.length; i < len; i++) {
              el.classList.add(classes[i]);
            }
          } else if (!hasClass(el, name)) {
            var className = getClass(el);
            setClass(el, (className ? className + " " : "") + name);
          }
        }
        function removeClass(el, name) {
          if (el.classList !== void 0) {
            el.classList.remove(name);
          } else {
            setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
          }
        }
        function setClass(el, name) {
          if (el.className.baseVal === void 0) {
            el.className = name;
          } else {
            el.className.baseVal = name;
          }
        }
        function getClass(el) {
          if (el.correspondingElement) {
            el = el.correspondingElement;
          }
          return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
        }
        function setOpacity(el, value) {
          if ("opacity" in el.style) {
            el.style.opacity = value;
          } else if ("filter" in el.style) {
            _setOpacityIE(el, value);
          }
        }
        function _setOpacityIE(el, value) {
          var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
          try {
            filter = el.filters.item(filterName);
          } catch (e) {
            if (value === 1) {
              return;
            }
          }
          value = Math.round(value * 100);
          if (filter) {
            filter.Enabled = value !== 100;
            filter.Opacity = value;
          } else {
            el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
          }
        }
        function testProp(props) {
          var style2 = document.documentElement.style;
          for (var i = 0; i < props.length; i++) {
            if (props[i] in style2) {
              return props[i];
            }
          }
          return false;
        }
        function setTransform(el, offset, scale2) {
          var pos = offset || new Point(0, 0);
          el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
        }
        function setPosition(el, point) {
          el._leaflet_pos = point;
          if (Browser.any3d) {
            setTransform(el, point);
          } else {
            el.style.left = point.x + "px";
            el.style.top = point.y + "px";
          }
        }
        function getPosition(el) {
          return el._leaflet_pos || new Point(0, 0);
        }
        var disableTextSelection;
        var enableTextSelection;
        var _userSelect;
        if ("onselectstart" in document) {
          disableTextSelection = function() {
            on(window, "selectstart", preventDefault);
          };
          enableTextSelection = function() {
            off(window, "selectstart", preventDefault);
          };
        } else {
          var userSelectProperty = testProp(
            ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
          );
          disableTextSelection = function() {
            if (userSelectProperty) {
              var style2 = document.documentElement.style;
              _userSelect = style2[userSelectProperty];
              style2[userSelectProperty] = "none";
            }
          };
          enableTextSelection = function() {
            if (userSelectProperty) {
              document.documentElement.style[userSelectProperty] = _userSelect;
              _userSelect = void 0;
            }
          };
        }
        function disableImageDrag() {
          on(window, "dragstart", preventDefault);
        }
        function enableImageDrag() {
          off(window, "dragstart", preventDefault);
        }
        var _outlineElement, _outlineStyle;
        function preventOutline(element) {
          while (element.tabIndex === -1) {
            element = element.parentNode;
          }
          if (!element.style) {
            return;
          }
          restoreOutline();
          _outlineElement = element;
          _outlineStyle = element.style.outlineStyle;
          element.style.outlineStyle = "none";
          on(window, "keydown", restoreOutline);
        }
        function restoreOutline() {
          if (!_outlineElement) {
            return;
          }
          _outlineElement.style.outlineStyle = _outlineStyle;
          _outlineElement = void 0;
          _outlineStyle = void 0;
          off(window, "keydown", restoreOutline);
        }
        function getSizedParentNode(element) {
          do {
            element = element.parentNode;
          } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
          return element;
        }
        function getScale(element) {
          var rect = element.getBoundingClientRect();
          return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
          };
        }
        var DomUtil = {
          __proto__: null,
          TRANSFORM,
          TRANSITION,
          TRANSITION_END,
          get,
          getStyle,
          create: create$1,
          remove,
          empty,
          toFront,
          toBack,
          hasClass,
          addClass,
          removeClass,
          setClass,
          getClass,
          setOpacity,
          testProp,
          setTransform,
          setPosition,
          getPosition,
          get disableTextSelection() {
            return disableTextSelection;
          },
          get enableTextSelection() {
            return enableTextSelection;
          },
          disableImageDrag,
          enableImageDrag,
          preventOutline,
          restoreOutline,
          getSizedParentNode,
          getScale
        };
        function on(obj, types, fn, context) {
          if (types && typeof types === "object") {
            for (var type in types) {
              addOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              addOne(obj, types[i], fn, context);
            }
          }
          return this;
        }
        var eventsKey = "_leaflet_events";
        function off(obj, types, fn, context) {
          if (arguments.length === 1) {
            batchRemove(obj);
            delete obj[eventsKey];
          } else if (types && typeof types === "object") {
            for (var type in types) {
              removeOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            if (arguments.length === 2) {
              batchRemove(obj, function(type2) {
                return indexOf(types, type2) !== -1;
              });
            } else {
              for (var i = 0, len = types.length; i < len; i++) {
                removeOne(obj, types[i], fn, context);
              }
            }
          }
          return this;
        }
        function batchRemove(obj, filterFn) {
          for (var id in obj[eventsKey]) {
            var type = id.split(/\d/)[0];
            if (!filterFn || filterFn(type)) {
              removeOne(obj, type, null, null, id);
            }
          }
        }
        var mouseSubst = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function addOne(obj, type, fn, context) {
          var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
          if (obj[eventsKey] && obj[eventsKey][id]) {
            return this;
          }
          var handler = function(e) {
            return fn.call(context || obj, e || window.event);
          };
          var originalHandler = handler;
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            handler = addPointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            handler = addDoubleTapListener(obj, handler);
          } else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
              obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
            } else if (type === "mouseenter" || type === "mouseleave") {
              handler = function(e) {
                e = e || window.event;
                if (isExternalTarget(obj, e)) {
                  originalHandler(e);
                }
              };
              obj.addEventListener(mouseSubst[type], handler, false);
            } else {
              obj.addEventListener(type, originalHandler, false);
            }
          } else {
            obj.attachEvent("on" + type, handler);
          }
          obj[eventsKey] = obj[eventsKey] || {};
          obj[eventsKey][id] = handler;
        }
        function removeOne(obj, type, fn, context, id) {
          id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
          var handler = obj[eventsKey] && obj[eventsKey][id];
          if (!handler) {
            return this;
          }
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            removePointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            removeDoubleTapListener(obj, handler);
          } else if ("removeEventListener" in obj) {
            obj.removeEventListener(mouseSubst[type] || type, handler, false);
          } else {
            obj.detachEvent("on" + type, handler);
          }
          obj[eventsKey][id] = null;
        }
        function stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else if (e.originalEvent) {
            e.originalEvent._stopped = true;
          } else {
            e.cancelBubble = true;
          }
          return this;
        }
        function disableScrollPropagation(el) {
          addOne(el, "wheel", stopPropagation);
          return this;
        }
        function disableClickPropagation(el) {
          on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
          el["_leaflet_disable_click"] = true;
          return this;
        }
        function preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
          return this;
        }
        function stop(e) {
          preventDefault(e);
          stopPropagation(e);
          return this;
        }
        function getPropagationPath(ev) {
          if (ev.composedPath) {
            return ev.composedPath();
          }
          var path = [];
          var el = ev.target;
          while (el) {
            path.push(el);
            el = el.parentNode;
          }
          return path;
        }
        function getMousePosition(e, container) {
          if (!container) {
            return new Point(e.clientX, e.clientY);
          }
          var scale2 = getScale(container), offset = scale2.boundingClientRect;
          return new Point(
            // offset.left/top values are in page scale (like clientX/Y),
            // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
            (e.clientX - offset.left) / scale2.x - container.clientLeft,
            (e.clientY - offset.top) / scale2.y - container.clientTop
          );
        }
        var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
        function getWheelDelta(e) {
          return Browser.edge ? e.wheelDeltaY / 2 : (
            // Don't trust window-geometry-based delta
            e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : (
              // Pixels
              e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : (
                // Lines
                e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : (
                  // Pages
                  e.deltaX || e.deltaZ ? 0 : (
                    // Skip horizontal/depth wheel events
                    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : (
                      // Legacy IE pixels
                      e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : (
                        // Legacy Moz lines
                        e.detail ? e.detail / -32765 * 60 : (
                          // Legacy Moz pages
                          0
                        )
                      )
                    )
                  )
                )
              )
            )
          );
        }
        function isExternalTarget(el, e) {
          var related = e.relatedTarget;
          if (!related) {
            return true;
          }
          try {
            while (related && related !== el) {
              related = related.parentNode;
            }
          } catch (err) {
            return false;
          }
          return related !== el;
        }
        var DomEvent = {
          __proto__: null,
          on,
          off,
          stopPropagation,
          disableScrollPropagation,
          disableClickPropagation,
          preventDefault,
          stop,
          getPropagationPath,
          getMousePosition,
          getWheelDelta,
          isExternalTarget,
          addListener: on,
          removeListener: off
        };
        var PosAnimation = Evented.extend({
          // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
          // Run an animation of a given element to a new position, optionally setting
          // duration in seconds (`0.25` by default) and easing linearity factor (3rd
          // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
          // `0.5` by default).
          run: function(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +/* @__PURE__ */ new Date();
            this.fire("start");
            this._animate();
          },
          // @method stop()
          // Stops the animation (if currently running).
          stop: function() {
            if (!this._inProgress) {
              return;
            }
            this._step(true);
            this._complete();
          },
          _animate: function() {
            this._animId = requestAnimFrame(this._animate, this);
            this._step();
          },
          _step: function(round) {
            var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
              this._runFrame(this._easeOut(elapsed / duration), round);
            } else {
              this._runFrame(1);
              this._complete();
            }
          },
          _runFrame: function(progress, round) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round) {
              pos._round();
            }
            setPosition(this._el, pos);
            this.fire("step");
          },
          _complete: function() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
          },
          _easeOut: function(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
          }
        });
        var Map = Evented.extend({
          options: {
            // @section Map State Options
            // @option crs: CRS = L.CRS.EPSG3857
            // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
            // sure what it means.
            crs: EPSG3857,
            // @option center: LatLng = undefined
            // Initial geographic center of the map
            center: void 0,
            // @option zoom: Number = undefined
            // Initial map zoom level
            zoom: void 0,
            // @option minZoom: Number = *
            // Minimum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the lowest of their `minZoom` options will be used instead.
            minZoom: void 0,
            // @option maxZoom: Number = *
            // Maximum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the highest of their `maxZoom` options will be used instead.
            maxZoom: void 0,
            // @option layers: Layer[] = []
            // Array of layers that will be added to the map initially
            layers: [],
            // @option maxBounds: LatLngBounds = null
            // When this option is set, the map restricts the view to the given
            // geographical bounds, bouncing the user back if the user tries to pan
            // outside the view. To set the restriction dynamically, use
            // [`setMaxBounds`](#map-setmaxbounds) method.
            maxBounds: void 0,
            // @option renderer: Renderer = *
            // The default method for drawing vector layers on the map. `L.SVG`
            // or `L.Canvas` by default depending on browser support.
            renderer: void 0,
            // @section Animation Options
            // @option zoomAnimation: Boolean = true
            // Whether the map zoom animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            zoomAnimation: true,
            // @option zoomAnimationThreshold: Number = 4
            // Won't animate zoom if the zoom difference exceeds this value.
            zoomAnimationThreshold: 4,
            // @option fadeAnimation: Boolean = true
            // Whether the tile fade animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            fadeAnimation: true,
            // @option markerZoomAnimation: Boolean = true
            // Whether markers animate their zoom with the zoom animation, if disabled
            // they will disappear for the length of the animation. By default it's
            // enabled in all browsers that support CSS3 Transitions except Android.
            markerZoomAnimation: true,
            // @option transform3DLimit: Number = 2^23
            // Defines the maximum size of a CSS translation transform. The default
            // value should not be changed unless a web browser positions layers in
            // the wrong place after doing a large `panBy`.
            transform3DLimit: 8388608,
            // Precision limit of a 32-bit float
            // @section Interaction Options
            // @option zoomSnap: Number = 1
            // Forces the map's zoom level to always be a multiple of this, particularly
            // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
            // By default, the zoom level snaps to the nearest integer; lower values
            // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
            // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
            zoomSnap: 1,
            // @option zoomDelta: Number = 1
            // Controls how much the map's zoom level will change after a
            // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
            // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
            // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
            zoomDelta: 1,
            // @option trackResize: Boolean = true
            // Whether the map automatically handles browser window resize to update itself.
            trackResize: true
          },
          initialize: function(id, options) {
            options = setOptions(this, options);
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id);
            this._initLayout();
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
              this.setMaxBounds(options.maxBounds);
            }
            if (options.zoom !== void 0) {
              this._zoom = this._limitZoom(options.zoom);
            }
            if (options.center && options.zoom !== void 0) {
              this.setView(toLatLng(options.center), options.zoom, { reset: true });
            }
            this.callInitHooks();
            this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
            if (this._zoomAnimated) {
              this._createAnimProxy();
              on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
          },
          // @section Methods for modifying map state
          // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
          // Sets the view of the map (geographical center and zoom) with the given
          // animation options.
          setView: function(center, zoom2, options) {
            zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
            center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
            options = options || {};
            this._stop();
            if (this._loaded && !options.reset && options !== true) {
              if (options.animate !== void 0) {
                options.zoom = extend({ animate: options.animate }, options.zoom);
                options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
              }
              var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
              if (moved) {
                clearTimeout(this._sizeTimer);
                return this;
              }
            }
            this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
            return this;
          },
          // @method setZoom(zoom: Number, options?: Zoom/pan options): this
          // Sets the zoom of the map.
          setZoom: function(zoom2, options) {
            if (!this._loaded) {
              this._zoom = zoom2;
              return this;
            }
            return this.setView(this.getCenter(), zoom2, { zoom: options });
          },
          // @method zoomIn(delta?: Number, options?: Zoom options): this
          // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
          zoomIn: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
          },
          // @method zoomOut(delta?: Number, options?: Zoom options): this
          // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
          zoomOut: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
          },
          // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
          // Zooms the map while keeping a specified geographical point on the map
          // stationary (e.g. used internally for scroll zoom and double-click zoom).
          // @alternative
          // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
          // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
          setZoomAround: function(latlng, zoom2, options) {
            var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom2, { zoom: options });
          },
          _getBoundsCenterZoom: function(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
            zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
            if (zoom2 === Infinity) {
              return {
                center: bounds.getCenter(),
                zoom: zoom2
              };
            }
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
            return {
              center,
              zoom: zoom2
            };
          },
          // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
          // Sets a map view that contains the given geographical bounds with the
          // maximum zoom level possible.
          fitBounds: function(bounds, options) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) {
              throw new Error("Bounds are not valid.");
            }
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.setView(target.center, target.zoom, options);
          },
          // @method fitWorld(options?: fitBounds options): this
          // Sets a map view that mostly contains the whole world with the maximum
          // zoom level possible.
          fitWorld: function(options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
          },
          // @method panTo(latlng: LatLng, options?: Pan options): this
          // Pans the map to a given center.
          panTo: function(center, options) {
            return this.setView(center, this._zoom, { pan: options });
          },
          // @method panBy(offset: Point, options?: Pan options): this
          // Pans the map by a given number of pixels (animated).
          panBy: function(offset, options) {
            offset = toPoint(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
              return this.fire("moveend");
            }
            if (options.animate !== true && !this.getSize().contains(offset)) {
              this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
              return this;
            }
            if (!this._panAnim) {
              this._panAnim = new PosAnimation();
              this._panAnim.on({
                "step": this._onPanTransitionStep,
                "end": this._onPanTransitionEnd
              }, this);
            }
            if (!options.noMoveStart) {
              this.fire("movestart");
            }
            if (options.animate !== false) {
              addClass(this._mapPane, "leaflet-pan-anim");
              var newPos = this._getMapPanePos().subtract(offset).round();
              this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
              this._rawPanBy(offset);
              this.fire("move").fire("moveend");
            }
            return this;
          },
          // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
          // Sets the view of the map (geographical center and zoom) performing a smooth
          // pan-zoom animation.
          flyTo: function(targetCenter, targetZoom, options) {
            options = options || {};
            if (options.animate === false || !Browser.any3d) {
              return this.setView(targetCenter, targetZoom, options);
            }
            this._stop();
            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
            function r(i) {
              var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
              var log = sq < 1e-9 ? -18 : Math.log(sq);
              return log;
            }
            function sinh(n) {
              return (Math.exp(n) - Math.exp(-n)) / 2;
            }
            function cosh(n) {
              return (Math.exp(n) + Math.exp(-n)) / 2;
            }
            function tanh(n) {
              return sinh(n) / cosh(n);
            }
            var r0 = r(0);
            function w(s) {
              return w0 * (cosh(r0) / cosh(r0 + rho * s));
            }
            function u(s) {
              return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
            }
            function easeOut(t) {
              return 1 - Math.pow(1 - t, 1.5);
            }
            var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
            function frame() {
              var t = (Date.now() - start) / duration, s = easeOut(t) * S;
              if (t <= 1) {
                this._flyToFrame = requestAnimFrame(frame, this);
                this._move(
                  this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                  this.getScaleZoom(w0 / w(s), startZoom),
                  { flyTo: true }
                );
              } else {
                this._move(targetCenter, targetZoom)._moveEnd(true);
              }
            }
            this._moveStart(true, options.noMoveStart);
            frame.call(this);
            return this;
          },
          // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
          // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
          // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
          flyToBounds: function(bounds, options) {
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.flyTo(target.center, target.zoom, options);
          },
          // @method setMaxBounds(bounds: LatLngBounds): this
          // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
          setMaxBounds: function(bounds) {
            bounds = toLatLngBounds(bounds);
            if (this.listens("moveend", this._panInsideMaxBounds)) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (!bounds.isValid()) {
              this.options.maxBounds = null;
              return this;
            }
            this.options.maxBounds = bounds;
            if (this._loaded) {
              this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds);
          },
          // @method setMinZoom(zoom: Number): this
          // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
          setMinZoom: function(zoom2) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() < this.options.minZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          // @method setMaxZoom(zoom: Number): this
          // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
          setMaxZoom: function(zoom2) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() > this.options.maxZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
          // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
          panInsideBounds: function(bounds, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
            if (!center.equals(newCenter)) {
              this.panTo(newCenter, options);
            }
            this._enforcingBounds = false;
            return this;
          },
          // @method panInside(latlng: LatLng, options?: padding options): this
          // Pans the map the minimum amount to make the `latlng` visible. Use
          // padding options to fit the display to more restricted bounds.
          // If `latlng` is already within the (optionally padded) display bounds,
          // the map will not be panned.
          panInside: function(latlng, options) {
            options = options || {};
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
            if (!paddedBounds.contains(pixelPoint)) {
              this._enforcingBounds = true;
              var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
              var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
              pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
              pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
              this.panTo(this.unproject(pixelCenter), options);
              this._enforcingBounds = false;
            }
            return this;
          },
          // @method invalidateSize(options: Zoom/pan options): this
          // Checks if the map container size changed and updates the map if so 
          // call it after you've changed the map size dynamically, also animating
          // pan by default. If `options.pan` is `false`, panning will not occur.
          // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
          // that it doesn't happen often even if the method is called many
          // times in a row.
          // @alternative
          // @method invalidateSize(animate: Boolean): this
          // Checks if the map container size changed and updates the map if so 
          // call it after you've changed the map size dynamically, also animating
          // pan by default.
          invalidateSize: function(options) {
            if (!this._loaded) {
              return this;
            }
            options = extend({
              animate: false,
              pan: true
            }, options === true ? { animate: true } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
              return this;
            }
            if (options.animate && options.pan) {
              this.panBy(offset);
            } else {
              if (options.pan) {
                this._rawPanBy(offset);
              }
              this.fire("move");
              if (options.debounceMoveend) {
                clearTimeout(this._sizeTimer);
                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
              } else {
                this.fire("moveend");
              }
            }
            return this.fire("resize", {
              oldSize,
              newSize
            });
          },
          // @section Methods for modifying map state
          // @method stop(): this
          // Stops the currently running `panTo` or `flyTo` animation, if any.
          stop: function() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
              this.fire("viewreset");
            }
            return this._stop();
          },
          // @section Geolocation methods
          // @method locate(options?: Locate options): this
          // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
          // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
          // and optionally sets the map view to the user's location with respect to
          // detection accuracy (or to the world view if geolocation failed).
          // Note that, if your page doesn't use HTTPS, this method will fail in
          // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
          // See `Locate options` for more details.
          locate: function(options) {
            options = this._locateOptions = extend({
              timeout: 1e4,
              watch: false
              // setView: false
              // maxZoom: <Number>
              // maximumAge: 0
              // enableHighAccuracy: false
            }, options);
            if (!("geolocation" in navigator)) {
              this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
              });
              return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options.watch) {
              this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
              navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
          },
          // @method stopLocate(): this
          // Stops watching location previously initiated by `map.locate({watch: true})`
          // and aborts resetting the map view if map.locate was called with
          // `{setView: true}`.
          stopLocate: function() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) {
              navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
              this._locateOptions.setView = false;
            }
            return this;
          },
          _handleGeolocationError: function(error) {
            if (!this._container._leaflet_id) {
              return;
            }
            var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
              this.fitWorld();
            }
            this.fire("locationerror", {
              code: c,
              message: "Geolocation error: " + message + "."
            });
          },
          _handleGeolocationResponse: function(pos) {
            if (!this._container._leaflet_id) {
              return;
            }
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
            if (options.setView) {
              var zoom2 = this.getBoundsZoom(bounds);
              this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
            }
            var data = {
              latlng,
              bounds,
              timestamp: pos.timestamp
            };
            for (var i in pos.coords) {
              if (typeof pos.coords[i] === "number") {
                data[i] = pos.coords[i];
              }
            }
            this.fire("locationfound", data);
          },
          // TODO Appropriate docs section?
          // @section Other Methods
          // @method addHandler(name: String, HandlerClass: Function): this
          // Adds a new `Handler` to the map, given its name and constructor function.
          addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
              return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
              handler.enable();
            }
            return this;
          },
          // @method remove(): this
          // Destroys the map and clears all related event listeners.
          remove: function() {
            this._initEvents(true);
            if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (this._containerId !== this._container._leaflet_id) {
              throw new Error("Map container is being reused by another instance");
            }
            try {
              delete this._container._leaflet_id;
              delete this._containerId;
            } catch (e) {
              this._container._leaflet_id = void 0;
              this._containerId = void 0;
            }
            if (this._locationWatchId !== void 0) {
              this.stopLocate();
            }
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) {
              this._clearControlPos();
            }
            if (this._resizeRequest) {
              cancelAnimFrame(this._resizeRequest);
              this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) {
              this.fire("unload");
            }
            var i;
            for (i in this._layers) {
              this._layers[i].remove();
            }
            for (i in this._panes) {
              remove(this._panes[i]);
            }
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
          },
          // @section Other Methods
          // @method createPane(name: String, container?: HTMLElement): HTMLElement
          // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
          // then returns it. The pane is created as a child of `container`, or
          // as a child of the main map pane if not set.
          createPane: function(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) {
              this._panes[name] = pane;
            }
            return pane;
          },
          // @section Methods for Getting Map State
          // @method getCenter(): LatLng
          // Returns the geographical center of the map view
          getCenter: function() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) {
              return this._lastCenter.clone();
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          // @method getZoom(): Number
          // Returns the current zoom level of the map view
          getZoom: function() {
            return this._zoom;
          },
          // @method getBounds(): LatLngBounds
          // Returns the geographical bounds visible in the current map view
          getBounds: function() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
            return new LatLngBounds(sw, ne);
          },
          // @method getMinZoom(): Number
          // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
          getMinZoom: function() {
            return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          // @method getMaxZoom(): Number
          // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
          getMaxZoom: function() {
            return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
          },
          // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
          // Returns the maximum zoom level on which the given bounds fit to the map
          // view in its entirety. If `inside` (optional) is set to `true`, the method
          // instead returns the minimum zoom level on which the map view fits into
          // the given bounds in its entirety.
          getBoundsZoom: function(bounds, inside, padding) {
            bounds = toLatLngBounds(bounds);
            padding = toPoint(padding || [0, 0]);
            var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom2 = this.getScaleZoom(scale2, zoom2);
            if (snap) {
              zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
              zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          // @method getSize(): Point
          // Returns the current size of the map container (in pixels).
          getSize: function() {
            if (!this._size || this._sizeChanged) {
              this._size = new Point(
                this._container.clientWidth || 0,
                this._container.clientHeight || 0
              );
              this._sizeChanged = false;
            }
            return this._size.clone();
          },
          // @method getPixelBounds(): Bounds
          // Returns the bounds of the current map view in projected pixel
          // coordinates (sometimes useful in layer and overlay implementations).
          getPixelBounds: function(center, zoom2) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom2);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
          },
          // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
          // the map pane? "left point of the map layer" can be confusing, specially
          // since there can be negative offsets.
          // @method getPixelOrigin(): Point
          // Returns the projected pixel coordinates of the top left point of
          // the map layer (useful in custom layer and overlay implementations).
          getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._pixelOrigin;
          },
          // @method getPixelWorldBounds(zoom?: Number): Bounds
          // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
          // If `zoom` is omitted, the map's current zoom level is used.
          getPixelWorldBounds: function(zoom2) {
            return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
          },
          // @section Other Methods
          // @method getPane(pane: String|HTMLElement): HTMLElement
          // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
          getPane: function(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
          },
          // @method getPanes(): Object
          // Returns a plain object containing the names of all [panes](#map-pane) as keys and
          // the panes as values.
          getPanes: function() {
            return this._panes;
          },
          // @method getContainer: HTMLElement
          // Returns the HTML element that contains the map.
          getContainer: function() {
            return this._container;
          },
          // @section Conversion Methods
          // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
          // Returns the scale factor to be applied to a map transition from zoom level
          // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
          getZoomScale: function(toZoom, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
          },
          // @method getScaleZoom(scale: Number, fromZoom: Number): Number
          // Returns the zoom level that the map would end up at, if it is at `fromZoom`
          // level and everything is scaled by a factor of `scale`. Inverse of
          // [`getZoomScale`](#map-getZoomScale).
          getScaleZoom: function(scale2, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
            return isNaN(zoom2) ? Infinity : zoom2;
          },
          // @method project(latlng: LatLng, zoom: Number): Point
          // Projects a geographical coordinate `LatLng` according to the projection
          // of the map's CRS, then scales it according to `zoom` and the CRS's
          // `Transformation`. The result is pixel coordinate relative to
          // the CRS origin.
          project: function(latlng, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
          },
          // @method unproject(point: Point, zoom: Number): LatLng
          // Inverse of [`project`](#map-project).
          unproject: function(point, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.pointToLatLng(toPoint(point), zoom2);
          },
          // @method layerPointToLatLng(point: Point): LatLng
          // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
          // returns the corresponding geographical coordinate (for the current zoom level).
          layerPointToLatLng: function(point) {
            var projectedPoint = toPoint(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
          },
          // @method latLngToLayerPoint(latlng: LatLng): Point
          // Given a geographical coordinate, returns the corresponding pixel coordinate
          // relative to the [origin pixel](#map-getpixelorigin).
          latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
          },
          // @method wrapLatLng(latlng: LatLng): LatLng
          // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
          // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
          // CRS's bounds.
          // By default this means longitude is wrapped around the dateline so its
          // value is between -180 and +180 degrees.
          wrapLatLng: function(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
          },
          // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
          // Returns a `LatLngBounds` with the same size as the given one, ensuring that
          // its center is within the CRS's bounds.
          // By default this means the center longitude is wrapped around the dateline so its
          // value is between -180 and +180 degrees, and the majority of the bounds
          // overlaps the CRS's bounds.
          wrapLatLngBounds: function(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
          },
          // @method distance(latlng1: LatLng, latlng2: LatLng): Number
          // Returns the distance between two geographical coordinates according to
          // the map's CRS. By default this measures distance in meters.
          distance: function(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
          },
          // @method containerPointToLayerPoint(point: Point): Point
          // Given a pixel coordinate relative to the map container, returns the corresponding
          // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
          containerPointToLayerPoint: function(point) {
            return toPoint(point).subtract(this._getMapPanePos());
          },
          // @method layerPointToContainerPoint(point: Point): Point
          // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
          // returns the corresponding pixel coordinate relative to the map container.
          layerPointToContainerPoint: function(point) {
            return toPoint(point).add(this._getMapPanePos());
          },
          // @method containerPointToLatLng(point: Point): LatLng
          // Given a pixel coordinate relative to the map container, returns
          // the corresponding geographical coordinate (for the current zoom level).
          containerPointToLatLng: function(point) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point));
            return this.layerPointToLatLng(layerPoint);
          },
          // @method latLngToContainerPoint(latlng: LatLng): Point
          // Given a geographical coordinate, returns the corresponding pixel coordinate
          // relative to the map container.
          latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
          },
          // @method mouseEventToContainerPoint(ev: MouseEvent): Point
          // Given a MouseEvent object, returns the pixel coordinate relative to the
          // map container where the event took place.
          mouseEventToContainerPoint: function(e) {
            return getMousePosition(e, this._container);
          },
          // @method mouseEventToLayerPoint(ev: MouseEvent): Point
          // Given a MouseEvent object, returns the pixel coordinate relative to
          // the [origin pixel](#map-getpixelorigin) where the event took place.
          mouseEventToLayerPoint: function(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
          },
          // @method mouseEventToLatLng(ev: MouseEvent): LatLng
          // Given a MouseEvent object, returns geographical coordinate where the
          // event took place.
          mouseEventToLatLng: function(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
          },
          // map initialization methods
          _initContainer: function(id) {
            var container = this._container = get(id);
            if (!container) {
              throw new Error("Map container not found.");
            } else if (container._leaflet_id) {
              throw new Error("Map container is already initialized.");
            }
            on(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
          },
          _initLayout: function() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
            addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
              container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
              this._initControlPos();
            }
          },
          _initPanes: function() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point(0, 0));
            this.createPane("tilePane");
            this.createPane("overlayPane");
            this.createPane("shadowPane");
            this.createPane("markerPane");
            this.createPane("tooltipPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
              addClass(panes.markerPane, "leaflet-zoom-hide");
              addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
          },
          // private methods that modify map state
          // @section Map state change events
          _resetView: function(center, zoom2, noMoveStart) {
            setPosition(this._mapPane, new Point(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom2 = this._limitZoom(zoom2);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom2;
            this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
            this.fire("viewreset");
            if (loading) {
              this.fire("load");
            }
          },
          _moveStart: function(zoomChanged, noMoveStart) {
            if (zoomChanged) {
              this.fire("zoomstart");
            }
            if (!noMoveStart) {
              this.fire("movestart");
            }
            return this;
          },
          _move: function(center, zoom2, data, supressEvent) {
            if (zoom2 === void 0) {
              zoom2 = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom2;
            this._zoom = zoom2;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);
            if (!supressEvent) {
              if (zoomChanged || data && data.pinch) {
                this.fire("zoom", data);
              }
              this.fire("move", data);
            } else if (data && data.pinch) {
              this.fire("zoom", data);
            }
            return this;
          },
          _moveEnd: function(zoomChanged) {
            if (zoomChanged) {
              this.fire("zoomend");
            }
            return this.fire("moveend");
          },
          _stop: function() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
              this._panAnim.stop();
            }
            return this;
          },
          _rawPanBy: function(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            if (!this._enforcingBounds) {
              this.panInsideBounds(this.options.maxBounds);
            }
          },
          _checkIfLoaded: function() {
            if (!this._loaded) {
              throw new Error("Set map center and zoom first.");
            }
          },
          // DOM event handling
          // @section Interaction events
          _initEvents: function(remove2) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove2 ? off : on;
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) {
              onOff(window, "resize", this._onResize, this);
            }
            if (Browser.any3d && this.options.transform3DLimit) {
              (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
            }
          },
          _onResize: function() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame(
              function() {
                this.invalidateSize({ debounceMoveend: true });
              },
              this
            );
          },
          _onScroll: function() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
              this._resetView(this.getCenter(), this.getZoom());
            }
          },
          _findEventTargets: function(e, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
            while (src) {
              target = this._targets[stamp(src)];
              if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                dragging = true;
                break;
              }
              if (target && target.listens(type, true)) {
                if (isHover && !isExternalTarget(src, e)) {
                  break;
                }
                targets.push(target);
                if (isHover) {
                  break;
                }
              }
              if (src === this._container) {
                break;
              }
              src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
              targets = [this];
            }
            return targets;
          },
          _isClickDisabled: function(el) {
            while (el && el !== this._container) {
              if (el["_leaflet_disable_click"]) {
                return true;
              }
              el = el.parentNode;
            }
          },
          _handleDOMEvent: function(e) {
            var el = e.target || e.srcElement;
            if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
              return;
            }
            var type = e.type;
            if (type === "mousedown") {
              preventOutline(el);
            }
            this._fireDOMEvent(e, type);
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(e, type, canvasTargets) {
            if (e.type === "click") {
              var synth = extend({}, e);
              synth.type = "preclick";
              this._fireDOMEvent(synth, synth.type, canvasTargets);
            }
            var targets = this._findEventTargets(e, type);
            if (canvasTargets) {
              var filtered = [];
              for (var i = 0; i < canvasTargets.length; i++) {
                if (canvasTargets[i].listens(type, true)) {
                  filtered.push(canvasTargets[i]);
                }
              }
              targets = filtered.concat(targets);
            }
            if (!targets.length) {
              return;
            }
            if (type === "contextmenu") {
              preventDefault(e);
            }
            var target = targets[0];
            var data = {
              originalEvent: e
            };
            if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
              var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
              data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
              data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
              data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for (i = 0; i < targets.length; i++) {
              targets[i].fire(type, data, true);
              if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
                return;
              }
            }
          },
          _draggableMoved: function(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
              this._handlers[i].disable();
            }
          },
          // @section Other Methods
          // @method whenReady(fn: Function, context?: Object): this
          // Runs the given function `fn` when the map gets initialized with
          // a view (center and zoom) and at least one layer, or immediately
          // if it's already initialized, optionally passing a function context.
          whenReady: function(callback, context) {
            if (this._loaded) {
              callback.call(context || this, { target: this });
            } else {
              this.on("load", callback, context);
            }
            return this;
          },
          // private methods for getting map state
          _getMapPanePos: function() {
            return getPosition(this._mapPane) || new Point(0, 0);
          },
          _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
          },
          _getTopLeftPoint: function(center, zoom2) {
            var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
          },
          _getNewPixelOrigin: function(center, zoom2) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(latlng, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return this.project(latlng, zoom2)._subtract(topLeft);
          },
          _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return toBounds([
              this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
            ]);
          },
          // layer point of the current center
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          // offset of the specified place to the current center in pixels
          _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
          },
          // adjust center for view to get inside bounds
          _limitCenter: function(center, zoom2, bounds) {
            if (!bounds) {
              return center;
            }
            var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
              return center;
            }
            return this.unproject(centerPoint.add(offset), zoom2);
          },
          // adjust offset for view to get inside bounds
          _limitOffset: function(offset, bounds) {
            if (!bounds) {
              return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
          },
          // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
          _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
            var projectedMaxBounds = toBounds(
              this.project(maxBounds.getNorthEast(), zoom2),
              this.project(maxBounds.getSouthWest(), zoom2)
            ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point(dx, dy);
          },
          _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
          },
          _limitZoom: function(zoom2) {
            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
            if (snap) {
              zoom2 = Math.round(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
          },
          _tryAnimatedPan: function(center, options) {
            var offset = this._getCenterOffset(center)._trunc();
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
              return false;
            }
            this.panBy(offset, options);
            return true;
          },
          _createAnimProxy: function() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e) {
              var prop = TRANSFORM, transform = this._proxy.style[prop];
              setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
              if (transform === this._proxy.style[prop] && this._animatingZoom) {
                this._onZoomTransitionEnd();
              }
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
          },
          _animMoveEnd: function() {
            var c = this.getCenter(), z = this.getZoom();
            setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
          },
          _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
              this._onZoomTransitionEnd();
            }
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(center, zoom2, options) {
            if (this._animatingZoom) {
              return true;
            }
            options = options || {};
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
              return false;
            }
            var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
            if (options.animate !== true && !this.getSize().contains(offset)) {
              return false;
            }
            requestAnimFrame(function() {
              this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
            }, this);
            return true;
          },
          _animateZoom: function(center, zoom2, startAnim, noUpdate) {
            if (!this._mapPane) {
              return;
            }
            if (startAnim) {
              this._animatingZoom = true;
              this._animateToCenter = center;
              this._animateToZoom = zoom2;
              addClass(this._mapPane, "leaflet-zoom-anim");
            }
            this.fire("zoomanim", {
              center,
              zoom: zoom2,
              noUpdate
            });
            if (!this._tempFireZoomEvent) {
              this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
            }
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
          },
          _onZoomTransitionEnd: function() {
            if (!this._animatingZoom) {
              return;
            }
            if (this._mapPane) {
              removeClass(this._mapPane, "leaflet-zoom-anim");
            }
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            if (this._tempFireZoomEvent) {
              this.fire("zoom");
            }
            delete this._tempFireZoomEvent;
            this.fire("move");
            this._moveEnd(true);
          }
        });
        function createMap(id, options) {
          return new Map(id, options);
        }
        var Control = Class.extend({
          // @section
          // @aka Control Options
          options: {
            // @option position: String = 'topright'
            // The position of the control (one of the map corners). Possible values are `'topleft'`,
            // `'topright'`, `'bottomleft'` or `'bottomright'`
            position: "topright"
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          /* @section
           * Classes extending L.Control will inherit the following methods:
           *
           * @method getPosition: string
           * Returns the position of the control.
           */
          getPosition: function() {
            return this.options.position;
          },
          // @method setPosition(position: string): this
          // Sets the position of the control.
          setPosition: function(position) {
            var map2 = this._map;
            if (map2) {
              map2.removeControl(this);
            }
            this.options.position = position;
            if (map2) {
              map2.addControl(this);
            }
            return this;
          },
          // @method getContainer: HTMLElement
          // Returns the HTMLElement that contains the control.
          getContainer: function() {
            return this._container;
          },
          // @method addTo(map: Map): this
          // Adds the control to the given map.
          addTo: function(map2) {
            this.remove();
            this._map = map2;
            var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
              corner.insertBefore(container, corner.firstChild);
            } else {
              corner.appendChild(container);
            }
            this._map.on("unload", this.remove, this);
            return this;
          },
          // @method remove: this
          // Removes the control from the map it is currently active on.
          remove: function() {
            if (!this._map) {
              return this;
            }
            remove(this._container);
            if (this.onRemove) {
              this.onRemove(this._map);
            }
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
          },
          _refocusOnMap: function(e) {
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
              this._map.getContainer().focus();
            }
          }
        });
        var control = function(options) {
          return new Control(options);
        };
        Map.include({
          // @method addControl(control: Control): this
          // Adds the given control to the map
          addControl: function(control2) {
            control2.addTo(this);
            return this;
          },
          // @method removeControl(control: Control): this
          // Removes the given control from the map
          removeControl: function(control2) {
            control2.remove();
            return this;
          },
          _initControlPos: function() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
              var className = l + vSide + " " + l + hSide;
              corners[vSide + hSide] = create$1("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
          },
          _clearControlPos: function() {
            for (var i in this._controlCorners) {
              remove(this._controlCorners[i]);
            }
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
          }
        });
        var Layers = Control.extend({
          // @section
          // @aka Control.Layers options
          options: {
            // @option collapsed: Boolean = true
            // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
            collapsed: true,
            position: "topright",
            // @option autoZIndex: Boolean = true
            // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
            autoZIndex: true,
            // @option hideSingleBase: Boolean = false
            // If `true`, the base layers in the control will be hidden when there is only one.
            hideSingleBase: false,
            // @option sortLayers: Boolean = false
            // Whether to sort the layers. When `false`, layers will keep the order
            // in which they were added to the control.
            sortLayers: false,
            // @option sortFunction: Function = *
            // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
            // that will be used for sorting the layers, when `sortLayers` is `true`.
            // The function receives both the `L.Layer` instances and their names, as in
            // `sortFunction(layerA, layerB, nameA, nameB)`.
            // By default, it sorts layers alphabetically by their name.
            sortFunction: function(layerA, layerB, nameA, nameB) {
              return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
          },
          initialize: function(baseLayers, overlays, options) {
            setOptions(this, options);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            this._preventClick = false;
            for (var i in baseLayers) {
              this._addLayer(baseLayers[i], i);
            }
            for (i in overlays) {
              this._addLayer(overlays[i], i, true);
            }
          },
          onAdd: function(map2) {
            this._initLayout();
            this._update();
            this._map = map2;
            map2.on("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.on("add remove", this._onLayerChange, this);
            }
            return this._container;
          },
          addTo: function(map2) {
            Control.prototype.addTo.call(this, map2);
            return this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.off("add remove", this._onLayerChange, this);
            }
          },
          // @method addBaseLayer(layer: Layer, name: String): this
          // Adds a base layer (radio button entry) with the given name to the control.
          addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
          },
          // @method addOverlay(layer: Layer, name: String): this
          // Adds an overlay (checkbox entry) with the given name to the control.
          addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
          },
          // @method removeLayer(layer: Layer): this
          // Remove the given layer from the control.
          removeLayer: function(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) {
              this._layers.splice(this._layers.indexOf(obj), 1);
            }
            return this._map ? this._update() : this;
          },
          // @method expand(): this
          // Expand the control container if collapsed.
          expand: function() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
              addClass(this._section, "leaflet-control-layers-scrollbar");
              this._section.style.height = acceptableHeight + "px";
            } else {
              removeClass(this._section, "leaflet-control-layers-scrollbar");
            }
            this._checkDisabledLayers();
            return this;
          },
          // @method collapse(): this
          // Collapse the control container if expanded.
          collapse: function() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
          },
          _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
              this._map.on("click", this.collapse, this);
              on(container, {
                mouseenter: this._expandSafely,
                mouseleave: this.collapse
              }, this);
            }
            var link = this._layersLink = create$1("a", className + "-toggle", container);
            link.href = "#";
            link.title = "Layers";
            link.setAttribute("role", "button");
            on(link, {
              keydown: function(e) {
                if (e.keyCode === 13) {
                  this._expandSafely();
                }
              },
              // Certain screen readers intercept the key event and instead send a click event
              click: function(e) {
                preventDefault(e);
                this._expandSafely();
              }
            }, this);
            if (!collapsed) {
              this.expand();
            }
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
          },
          _getLayer: function(id) {
            for (var i = 0; i < this._layers.length; i++) {
              if (this._layers[i] && stamp(this._layers[i].layer) === id) {
                return this._layers[i];
              }
            }
          },
          _addLayer: function(layer, name, overlay) {
            if (this._map) {
              layer.on("add remove", this._onLayerChange, this);
            }
            this._layers.push({
              layer,
              name,
              overlay
            });
            if (this.options.sortLayers) {
              this._layers.sort(bind(function(a, b) {
                return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
              }, this));
            }
            if (this.options.autoZIndex && layer.setZIndex) {
              this._lastZIndex++;
              layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
          },
          _update: function() {
            if (!this._container) {
              return this;
            }
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
            for (i = 0; i < this._layers.length; i++) {
              obj = this._layers[i];
              this._addItem(obj);
              overlaysPresent = overlaysPresent || obj.overlay;
              baseLayersPresent = baseLayersPresent || !obj.overlay;
              baseLayersCount += !obj.overlay ? 1 : 0;
            }
            if (this.options.hideSingleBase) {
              baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
              this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
          },
          _onLayerChange: function(e) {
            if (!this._handlingClick) {
              this._update();
            }
            var obj = this._getLayer(stamp(e.target));
            var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
            if (type) {
              this._map.fire(type, obj);
            }
          },
          // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
          _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
          },
          _addItem: function(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
              input = document.createElement("input");
              input.type = "checkbox";
              input.className = "leaflet-control-layers-selector";
              input.defaultChecked = checked;
            } else {
              input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            }
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            var holder = document.createElement("span");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
          },
          _onInputClick: function() {
            if (this._preventClick) {
              return;
            }
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              if (input.checked) {
                addedLayers.push(layer);
              } else if (!input.checked) {
                removedLayers.push(layer);
              }
            }
            for (i = 0; i < removedLayers.length; i++) {
              if (this._map.hasLayer(removedLayers[i])) {
                this._map.removeLayer(removedLayers[i]);
              }
            }
            for (i = 0; i < addedLayers.length; i++) {
              if (!this._map.hasLayer(addedLayers[i])) {
                this._map.addLayer(addedLayers[i]);
              }
            }
            this._handlingClick = false;
            this._refocusOnMap();
          },
          _checkDisabledLayers: function() {
            var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
            }
          },
          _expandIfNotCollapsed: function() {
            if (this._map && !this.options.collapsed) {
              this.expand();
            }
            return this;
          },
          _expandSafely: function() {
            var section = this._section;
            this._preventClick = true;
            on(section, "click", preventDefault);
            this.expand();
            var that = this;
            setTimeout(function() {
              off(section, "click", preventDefault);
              that._preventClick = false;
            });
          }
        });
        var layers = function(baseLayers, overlays, options) {
          return new Layers(baseLayers, overlays, options);
        };
        var Zoom = Control.extend({
          // @section
          // @aka Control.Zoom options
          options: {
            position: "topleft",
            // @option zoomInText: String = '<span aria-hidden="true">+</span>'
            // The text set on the 'zoom in' button.
            zoomInText: '<span aria-hidden="true">+</span>',
            // @option zoomInTitle: String = 'Zoom in'
            // The title set on the 'zoom in' button.
            zoomInTitle: "Zoom in",
            // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
            // The text set on the 'zoom out' button.
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            // @option zoomOutTitle: String = 'Zoom out'
            // The title set on the 'zoom out' button.
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(map2) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
            this._zoomInButton = this._createButton(
              options.zoomInText,
              options.zoomInTitle,
              zoomName + "-in",
              container,
              this._zoomIn
            );
            this._zoomOutButton = this._createButton(
              options.zoomOutText,
              options.zoomOutTitle,
              zoomName + "-out",
              container,
              this._zoomOut
            );
            this._updateDisabled();
            map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            this._disabled = true;
            this._updateDisabled();
            return this;
          },
          enable: function() {
            this._disabled = false;
            this._updateDisabled();
            return this;
          },
          _zoomIn: function(e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
              this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _zoomOut: function(e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
              this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _createButton: function(html, title, className, container, fn) {
            var link = create$1("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title;
            link.setAttribute("role", "button");
            link.setAttribute("aria-label", title);
            disableClickPropagation(link);
            on(link, "click", stop);
            on(link, "click", fn, this);
            on(link, "click", this._refocusOnMap, this);
            return link;
          },
          _updateDisabled: function() {
            var map2 = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "false");
            this._zoomOutButton.setAttribute("aria-disabled", "false");
            if (this._disabled || map2._zoom === map2.getMinZoom()) {
              addClass(this._zoomOutButton, className);
              this._zoomOutButton.setAttribute("aria-disabled", "true");
            }
            if (this._disabled || map2._zoom === map2.getMaxZoom()) {
              addClass(this._zoomInButton, className);
              this._zoomInButton.setAttribute("aria-disabled", "true");
            }
          }
        });
        Map.mergeOptions({
          zoomControl: true
        });
        Map.addInitHook(function() {
          if (this.options.zoomControl) {
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
          }
        });
        var zoom = function(options) {
          return new Zoom(options);
        };
        var Scale = Control.extend({
          // @section
          // @aka Control.Scale options
          options: {
            position: "bottomleft",
            // @option maxWidth: Number = 100
            // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
            maxWidth: 100,
            // @option metric: Boolean = True
            // Whether to show the metric scale line (m/km).
            metric: true,
            // @option imperial: Boolean = True
            // Whether to show the imperial scale line (mi/ft).
            imperial: true
            // @option updateWhenIdle: Boolean = false
            // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
          },
          onAdd: function(map2) {
            var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
            this._addScales(options, className + "-line", container);
            map2.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map2.whenReady(this._update, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(options, className, container) {
            if (options.metric) {
              this._mScale = create$1("div", className, container);
            }
            if (options.imperial) {
              this._iScale = create$1("div", className, container);
            }
          },
          _update: function() {
            var map2 = this._map, y = map2.getSize().y / 2;
            var maxMeters = map2.distance(
              map2.containerPointToLatLng([0, y]),
              map2.containerPointToLatLng([this.options.maxWidth, y])
            );
            this._updateScales(maxMeters);
          },
          _updateScales: function(maxMeters) {
            if (this.options.metric && maxMeters) {
              this._updateMetric(maxMeters);
            }
            if (this.options.imperial && maxMeters) {
              this._updateImperial(maxMeters);
            }
          },
          _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
          },
          _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
          },
          _updateScale: function(scale2, text, ratio) {
            scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale2.innerHTML = text;
          },
          _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
            return pow10 * d;
          }
        });
        var scale = function(options) {
          return new Scale(options);
        };
        var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
        var Attribution = Control.extend({
          // @section
          // @aka Control.Attribution options
          options: {
            position: "bottomright",
            // @option prefix: String|false = 'Leaflet'
            // The HTML text shown before the attributions. Pass `false` to disable.
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
          },
          initialize: function(options) {
            setOptions(this, options);
            this._attributions = {};
          },
          onAdd: function(map2) {
            map2.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            for (var i in map2._layers) {
              if (map2._layers[i].getAttribution) {
                this.addAttribution(map2._layers[i].getAttribution());
              }
            }
            this._update();
            map2.on("layeradd", this._addAttribution, this);
            return this._container;
          },
          onRemove: function(map2) {
            map2.off("layeradd", this._addAttribution, this);
          },
          _addAttribution: function(ev) {
            if (ev.layer.getAttribution) {
              this.addAttribution(ev.layer.getAttribution());
              ev.layer.once("remove", function() {
                this.removeAttribution(ev.layer.getAttribution());
              }, this);
            }
          },
          // @method setPrefix(prefix: String|false): this
          // The HTML text shown before the attributions. Pass `false` to disable.
          setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
          },
          // @method addAttribution(text: String): this
          // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
          addAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (!this._attributions[text]) {
              this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
          },
          // @method removeAttribution(text: String): this
          // Removes an attribution text.
          removeAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (this._attributions[text]) {
              this._attributions[text]--;
              this._update();
            }
            return this;
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            var attribs = [];
            for (var i in this._attributions) {
              if (this._attributions[i]) {
                attribs.push(i);
              }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
              prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
              prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
          }
        });
        Map.mergeOptions({
          attributionControl: true
        });
        Map.addInitHook(function() {
          if (this.options.attributionControl) {
            new Attribution().addTo(this);
          }
        });
        var attribution = function(options) {
          return new Attribution(options);
        };
        Control.Layers = Layers;
        Control.Zoom = Zoom;
        Control.Scale = Scale;
        Control.Attribution = Attribution;
        control.layers = layers;
        control.zoom = zoom;
        control.scale = scale;
        control.attribution = attribution;
        var Handler = Class.extend({
          initialize: function(map2) {
            this._map = map2;
          },
          // @method enable(): this
          // Enables the handler
          enable: function() {
            if (this._enabled) {
              return this;
            }
            this._enabled = true;
            this.addHooks();
            return this;
          },
          // @method disable(): this
          // Disables the handler
          disable: function() {
            if (!this._enabled) {
              return this;
            }
            this._enabled = false;
            this.removeHooks();
            return this;
          },
          // @method enabled(): Boolean
          // Returns `true` if the handler is enabled
          enabled: function() {
            return !!this._enabled;
          }
          // @section Extension methods
          // Classes inheriting from `Handler` must implement the two following methods:
          // @method addHooks()
          // Called when the handler is enabled, should add event hooks.
          // @method removeHooks()
          // Called when the handler is disabled, should remove the event hooks added previously.
        });
        Handler.addTo = function(map2, name) {
          map2.addHandler(name, this);
          return this;
        };
        var Mixin = { Events };
        var START = Browser.touch ? "touchstart mousedown" : "mousedown";
        var Draggable = Evented.extend({
          options: {
            // @section
            // @aka Draggable options
            // @option clickTolerance: Number = 3
            // The max number of pixels a user can shift the mouse pointer during a click
            // for it to be considered a valid click (as opposed to a mouse drag).
            clickTolerance: 3
          },
          // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
          // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
          initialize: function(element, dragStartTarget, preventOutline2, options) {
            setOptions(this, options);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline2;
          },
          // @method enable()
          // Enables the dragging ability
          enable: function() {
            if (this._enabled) {
              return;
            }
            on(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
          },
          // @method disable()
          // Disables the dragging ability
          disable: function() {
            if (!this._enabled) {
              return;
            }
            if (Draggable._dragging === this) {
              this.finishDrag(true);
            }
            off(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
          },
          _onDown: function(e) {
            if (!this._enabled) {
              return;
            }
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) {
              return;
            }
            if (e.touches && e.touches.length !== 1) {
              if (Draggable._dragging === this) {
                this.finishDrag();
              }
              return;
            }
            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
              return;
            }
            Draggable._dragging = this;
            if (this._preventOutline) {
              preventOutline(this._element);
            }
            disableImageDrag();
            disableTextSelection();
            if (this._moving) {
              return;
            }
            this.fire("down");
            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first.clientX, first.clientY);
            this._startPos = getPosition(this._element);
            this._parentScale = getScale(sizedParent);
            var mouseevent = e.type === "mousedown";
            on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
            on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
          },
          _onMove: function(e) {
            if (!this._enabled) {
              return;
            }
            if (e.touches && e.touches.length > 1) {
              this._moved = true;
              return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) {
              return;
            }
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
              return;
            }
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e);
            if (!this._moved) {
              this.fire("dragstart");
              this._moved = true;
              addClass(document.body, "leaflet-dragging");
              this._lastTarget = e.target || e.srcElement;
              if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
                this._lastTarget = this._lastTarget.correspondingUseElement;
              }
              addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            this._lastEvent = e;
            this._updatePosition();
          },
          _updatePosition: function() {
            var e = { originalEvent: this._lastEvent };
            this.fire("predrag", e);
            setPosition(this._element, this._newPos);
            this.fire("drag", e);
          },
          _onUp: function() {
            if (!this._enabled) {
              return;
            }
            this.finishDrag();
          },
          finishDrag: function(noInertia) {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
              removeClass(this._lastTarget, "leaflet-drag-target");
              this._lastTarget = null;
            }
            off(document, "mousemove touchmove", this._onMove, this);
            off(document, "mouseup touchend touchcancel", this._onUp, this);
            enableImageDrag();
            enableTextSelection();
            var fireDragend = this._moved && this._moving;
            this._moving = false;
            Draggable._dragging = false;
            if (fireDragend) {
              this.fire("dragend", {
                noInertia,
                distance: this._newPos.distanceTo(this._startPos)
              });
            }
          }
        });
        function clipPolygon(points2, bounds, round) {
          var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
          for (i = 0, len = points2.length; i < len; i++) {
            points2[i]._code = _getBitCode(points2[i], bounds);
          }
          for (k = 0; k < 4; k++) {
            edge2 = edges[k];
            clippedPoints = [];
            for (i = 0, len = points2.length, j = len - 1; i < len; j = i++) {
              a = points2[i];
              b = points2[j];
              if (!(a._code & edge2)) {
                if (b._code & edge2) {
                  p = _getEdgeIntersection(b, a, edge2, bounds, round);
                  p._code = _getBitCode(p, bounds);
                  clippedPoints.push(p);
                }
                clippedPoints.push(a);
              } else if (!(b._code & edge2)) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
            }
            points2 = clippedPoints;
          }
          return points2;
        }
        function polygonCenter(latlngs, crs) {
          var i, j, p1, p2, f, area, x, y, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds = toLatLngBounds(latlngs);
          var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points2 = [];
          for (i = 0; i < len; i++) {
            var latlng = toLatLng(latlngs[i]);
            points2.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          area = x = y = 0;
          for (i = 0, j = len - 1; i < len; j = i++) {
            p1 = points2[i];
            p2 = points2[j];
            f = p1.y * p2.x - p2.y * p1.x;
            x += (p1.x + p2.x) * f;
            y += (p1.y + p2.y) * f;
            area += f * 3;
          }
          if (area === 0) {
            center = points2[0];
          } else {
            center = [x / area, y / area];
          }
          var latlngCenter = crs.unproject(toPoint(center));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        function centroid(coords) {
          var latSum = 0;
          var lngSum = 0;
          var len = 0;
          for (var i = 0; i < coords.length; i++) {
            var latlng = toLatLng(coords[i]);
            latSum += latlng.lat;
            lngSum += latlng.lng;
            len++;
          }
          return toLatLng([latSum / len, lngSum / len]);
        }
        var PolyUtil = {
          __proto__: null,
          clipPolygon,
          polygonCenter,
          centroid
        };
        function simplify(points2, tolerance) {
          if (!tolerance || !points2.length) {
            return points2.slice();
          }
          var sqTolerance = tolerance * tolerance;
          points2 = _reducePoints(points2, sqTolerance);
          points2 = _simplifyDP(points2, sqTolerance);
          return points2;
        }
        function pointToSegmentDistance(p, p1, p2) {
          return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
        }
        function closestPointOnSegment(p, p1, p2) {
          return _sqClosestPointOnSegment(p, p1, p2);
        }
        function _simplifyDP(points2, sqTolerance) {
          var len = points2.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers2 = new ArrayConstructor(len);
          markers2[0] = markers2[len - 1] = 1;
          _simplifyDPStep(points2, markers2, sqTolerance, 0, len - 1);
          var i, newPoints = [];
          for (i = 0; i < len; i++) {
            if (markers2[i]) {
              newPoints.push(points2[i]);
            }
          }
          return newPoints;
        }
        function _simplifyDPStep(points2, markers2, sqTolerance, first, last) {
          var maxSqDist = 0, index2, i, sqDist;
          for (i = first + 1; i <= last - 1; i++) {
            sqDist = _sqClosestPointOnSegment(points2[i], points2[first], points2[last], true);
            if (sqDist > maxSqDist) {
              index2 = i;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            markers2[index2] = 1;
            _simplifyDPStep(points2, markers2, sqTolerance, first, index2);
            _simplifyDPStep(points2, markers2, sqTolerance, index2, last);
          }
        }
        function _reducePoints(points2, sqTolerance) {
          var reducedPoints = [points2[0]];
          for (var i = 1, prev = 0, len = points2.length; i < len; i++) {
            if (_sqDist(points2[i], points2[prev]) > sqTolerance) {
              reducedPoints.push(points2[i]);
              prev = i;
            }
          }
          if (prev < len - 1) {
            reducedPoints.push(points2[len - 1]);
          }
          return reducedPoints;
        }
        var _lastCode;
        function clipSegment(a, b, bounds, useLastCode, round) {
          var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
          _lastCode = codeB;
          while (true) {
            if (!(codeA | codeB)) {
              return [a, b];
            }
            if (codeA & codeB) {
              return false;
            }
            codeOut = codeA || codeB;
            p = _getEdgeIntersection(a, b, codeOut, bounds, round);
            newCode = _getBitCode(p, bounds);
            if (codeOut === codeA) {
              a = p;
              codeA = newCode;
            } else {
              b = p;
              codeB = newCode;
            }
          }
        }
        function _getEdgeIntersection(a, b, code, bounds, round) {
          var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
          if (code & 8) {
            x = a.x + dx * (max.y - a.y) / dy;
            y = max.y;
          } else if (code & 4) {
            x = a.x + dx * (min.y - a.y) / dy;
            y = min.y;
          } else if (code & 2) {
            x = max.x;
            y = a.y + dy * (max.x - a.x) / dx;
          } else if (code & 1) {
            x = min.x;
            y = a.y + dy * (min.x - a.x) / dx;
          }
          return new Point(x, y, round);
        }
        function _getBitCode(p, bounds) {
          var code = 0;
          if (p.x < bounds.min.x) {
            code |= 1;
          } else if (p.x > bounds.max.x) {
            code |= 2;
          }
          if (p.y < bounds.min.y) {
            code |= 4;
          } else if (p.y > bounds.max.y) {
            code |= 8;
          }
          return code;
        }
        function _sqDist(p1, p2) {
          var dx = p2.x - p1.x, dy = p2.y - p1.y;
          return dx * dx + dy * dy;
        }
        function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
          var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
          if (dot > 0) {
            t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
            if (t > 1) {
              x = p2.x;
              y = p2.y;
            } else if (t > 0) {
              x += dx * t;
              y += dy * t;
            }
          }
          dx = p.x - x;
          dy = p.y - y;
          return sqDist ? dx * dx + dy * dy : new Point(x, y);
        }
        function isFlat(latlngs) {
          return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
        }
        function _flat(latlngs) {
          console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
          return isFlat(latlngs);
        }
        function polylineCenter(latlngs, crs) {
          var i, halfDist, segDist, dist, p1, p2, ratio, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds = toLatLngBounds(latlngs);
          var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points2 = [];
          for (i = 0; i < len; i++) {
            var latlng = toLatLng(latlngs[i]);
            points2.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          for (i = 0, halfDist = 0; i < len - 1; i++) {
            halfDist += points2[i].distanceTo(points2[i + 1]) / 2;
          }
          if (halfDist === 0) {
            center = points2[0];
          } else {
            for (i = 0, dist = 0; i < len - 1; i++) {
              p1 = points2[i];
              p2 = points2[i + 1];
              segDist = p1.distanceTo(p2);
              dist += segDist;
              if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                center = [
                  p2.x - ratio * (p2.x - p1.x),
                  p2.y - ratio * (p2.y - p1.y)
                ];
                break;
              }
            }
          }
          var latlngCenter = crs.unproject(toPoint(center));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        var LineUtil = {
          __proto__: null,
          simplify,
          pointToSegmentDistance,
          closestPointOnSegment,
          clipSegment,
          _getEdgeIntersection,
          _getBitCode,
          _sqClosestPointOnSegment,
          isFlat,
          _flat,
          polylineCenter
        };
        var LonLat = {
          project: function(latlng) {
            return new Point(latlng.lng, latlng.lat);
          },
          unproject: function(point) {
            return new LatLng(point.y, point.x);
          },
          bounds: new Bounds([-180, -90], [180, 90])
        };
        var Mercator = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(latlng) {
            var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y = -r * Math.log(Math.max(ts, 1e-10));
            return new Point(latlng.lng * d * r, y);
          },
          unproject: function(point) {
            var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
              con = e * Math.sin(phi);
              con = Math.pow((1 - con) / (1 + con), e / 2);
              dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
              phi += dphi;
            }
            return new LatLng(phi * d, point.x * d / r);
          }
        };
        var index = {
          __proto__: null,
          LonLat,
          Mercator,
          SphericalMercator
        };
        var EPSG3395 = extend({}, Earth, {
          code: "EPSG:3395",
          projection: Mercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG4326 = extend({}, Earth, {
          code: "EPSG:4326",
          projection: LonLat,
          transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
        });
        var Simple = extend({}, CRS, {
          projection: LonLat,
          transformation: toTransformation(1, 0, -1, 0),
          scale: function(zoom2) {
            return Math.pow(2, zoom2);
          },
          zoom: function(scale2) {
            return Math.log(scale2) / Math.LN2;
          },
          distance: function(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
          },
          infinite: true
        });
        CRS.Earth = Earth;
        CRS.EPSG3395 = EPSG3395;
        CRS.EPSG3857 = EPSG3857;
        CRS.EPSG900913 = EPSG900913;
        CRS.EPSG4326 = EPSG4326;
        CRS.Simple = Simple;
        var Layer = Evented.extend({
          // Classes extending `L.Layer` will inherit the following options:
          options: {
            // @option pane: String = 'overlayPane'
            // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
            pane: "overlayPane",
            // @option attribution: String = null
            // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
            attribution: null,
            bubblingMouseEvents: true
          },
          /* @section
           * Classes extending `L.Layer` will inherit the following methods:
           *
           * @method addTo(map: Map|LayerGroup): this
           * Adds the layer to the given map or layer group.
           */
          addTo: function(map2) {
            map2.addLayer(this);
            return this;
          },
          // @method remove: this
          // Removes the layer from the map it is currently active on.
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          // @method removeFrom(map: Map): this
          // Removes the layer from the given map
          //
          // @alternative
          // @method removeFrom(group: LayerGroup): this
          // Removes the layer from the given `LayerGroup`
          removeFrom: function(obj) {
            if (obj) {
              obj.removeLayer(this);
            }
            return this;
          },
          // @method getPane(name? : String): HTMLElement
          // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
          getPane: function(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
          },
          addInteractiveTarget: function(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
          },
          removeInteractiveTarget: function(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
          },
          // @method getAttribution: String
          // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(e) {
            var map2 = e.target;
            if (!map2.hasLayer(this)) {
              return;
            }
            this._map = map2;
            this._zoomAnimated = map2._zoomAnimated;
            if (this.getEvents) {
              var events = this.getEvents();
              map2.on(events, this);
              this.once("remove", function() {
                map2.off(events, this);
              }, this);
            }
            this.onAdd(map2);
            this.fire("add");
            map2.fire("layeradd", { layer: this });
          }
        });
        Map.include({
          // @method addLayer(layer: Layer): this
          // Adds the given layer to the map
          addLayer: function(layer) {
            if (!layer._layerAdd) {
              throw new Error("The provided object is not a Layer.");
            }
            var id = stamp(layer);
            if (this._layers[id]) {
              return this;
            }
            this._layers[id] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) {
              layer.beforeAdd(this);
            }
            this.whenReady(layer._layerAdd, layer);
            return this;
          },
          // @method removeLayer(layer: Layer): this
          // Removes the given layer from the map.
          removeLayer: function(layer) {
            var id = stamp(layer);
            if (!this._layers[id]) {
              return this;
            }
            if (this._loaded) {
              layer.onRemove(this);
            }
            delete this._layers[id];
            if (this._loaded) {
              this.fire("layerremove", { layer });
              layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
          },
          // @method hasLayer(layer: Layer): Boolean
          // Returns `true` if the given layer is currently added to the map
          hasLayer: function(layer) {
            return stamp(layer) in this._layers;
          },
          /* @method eachLayer(fn: Function, context?: Object): this
           * Iterates over the layers of the map, optionally specifying context of the iterator function.
           * ```
           * map.eachLayer(function(layer){
           *     layer.bindPopup('Hello');
           * });
           * ```
           */
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          _addLayers: function(layers2) {
            layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
            for (var i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          },
          _addZoomLimit: function(layer) {
            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
              this._zoomBoundLayers[stamp(layer)] = layer;
              this._updateZoomLevels();
            }
          },
          _removeZoomLimit: function(layer) {
            var id = stamp(layer);
            if (this._zoomBoundLayers[id]) {
              delete this._zoomBoundLayers[id];
              this._updateZoomLevels();
            }
          },
          _updateZoomLevels: function() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (var i in this._zoomBoundLayers) {
              var options = this._zoomBoundLayers[i].options;
              minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
              maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
            if (oldZoomSpan !== this._getZoomSpan()) {
              this.fire("zoomlevelschange");
            }
            if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
              this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
              this.setZoom(this._layersMinZoom);
            }
          }
        });
        var LayerGroup = Layer.extend({
          initialize: function(layers2, options) {
            setOptions(this, options);
            this._layers = {};
            var i, len;
            if (layers2) {
              for (i = 0, len = layers2.length; i < len; i++) {
                this.addLayer(layers2[i]);
              }
            }
          },
          // @method addLayer(layer: Layer): this
          // Adds the given layer to the group.
          addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
              this._map.addLayer(layer);
            }
            return this;
          },
          // @method removeLayer(layer: Layer): this
          // Removes the given layer from the group.
          // @alternative
          // @method removeLayer(id: Number): this
          // Removes the layer with the given internal ID from the group.
          removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
              this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
          },
          // @method hasLayer(layer: Layer): Boolean
          // Returns `true` if the given layer is currently added to the group.
          // @alternative
          // @method hasLayer(id: Number): Boolean
          // Returns `true` if the given internal ID is currently added to the group.
          hasLayer: function(layer) {
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
          },
          // @method clearLayers(): this
          // Removes all the layers from the group.
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          // @method invoke(methodName: String, ): this
          // Calls `methodName` on every layer contained in this group, passing any
          // additional parameters. Has no effect if the layers contained do not
          // implement `methodName`.
          invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i, layer;
            for (i in this._layers) {
              layer = this._layers[i];
              if (layer[methodName]) {
                layer[methodName].apply(layer, args);
              }
            }
            return this;
          },
          onAdd: function(map2) {
            this.eachLayer(map2.addLayer, map2);
          },
          onRemove: function(map2) {
            this.eachLayer(map2.removeLayer, map2);
          },
          // @method eachLayer(fn: Function, context?: Object): this
          // Iterates over the layers of the group, optionally specifying context of the iterator function.
          // ```js
          // group.eachLayer(function (layer) {
          // 	layer.bindPopup('Hello');
          // });
          // ```
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          // @method getLayer(id: Number): Layer
          // Returns the layer with the given internal ID.
          getLayer: function(id) {
            return this._layers[id];
          },
          // @method getLayers(): Layer[]
          // Returns an array of all the layers added to the group.
          getLayers: function() {
            var layers2 = [];
            this.eachLayer(layers2.push, layers2);
            return layers2;
          },
          // @method setZIndex(zIndex: Number): this
          // Calls `setZIndex` on every layer contained in this group, passing the z-index.
          setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
          },
          // @method getLayerId(layer: Layer): Number
          // Returns the internal ID for a layer
          getLayerId: function(layer) {
            return stamp(layer);
          }
        });
        var layerGroup = function(layers2, options) {
          return new LayerGroup(layers2, options);
        };
        var FeatureGroup = LayerGroup.extend({
          addLayer: function(layer) {
            if (this.hasLayer(layer)) {
              return this;
            }
            layer.addEventParent(this);
            LayerGroup.prototype.addLayer.call(this, layer);
            return this.fire("layeradd", { layer });
          },
          removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
              return this;
            }
            if (layer in this._layers) {
              layer = this._layers[layer];
            }
            layer.removeEventParent(this);
            LayerGroup.prototype.removeLayer.call(this, layer);
            return this.fire("layerremove", { layer });
          },
          // @method setStyle(style: Path options): this
          // Sets the given path options to each layer of the group that has a `setStyle` method.
          setStyle: function(style2) {
            return this.invoke("setStyle", style2);
          },
          // @method bringToFront(): this
          // Brings the layer group to the top of all other layers
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          // @method bringToBack(): this
          // Brings the layer group to the back of all other layers
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          // @method getBounds(): LatLngBounds
          // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
          getBounds: function() {
            var bounds = new LatLngBounds();
            for (var id in this._layers) {
              var layer = this._layers[id];
              bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds;
          }
        });
        var featureGroup2 = function(layers2, options) {
          return new FeatureGroup(layers2, options);
        };
        var Icon = Class.extend({
          /* @section
           * @aka Icon options
           *
           * @option iconUrl: String = null
           * **(required)** The URL to the icon image (absolute or relative to your script path).
           *
           * @option iconRetinaUrl: String = null
           * The URL to a retina sized version of the icon image (absolute or relative to your
           * script path). Used for Retina screen devices.
           *
           * @option iconSize: Point = null
           * Size of the icon image in pixels.
           *
           * @option iconAnchor: Point = null
           * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
           * will be aligned so that this point is at the marker's geographical location. Centered
           * by default if size is specified, also can be set in CSS with negative margins.
           *
           * @option popupAnchor: Point = [0, 0]
           * The coordinates of the point from which popups will "open", relative to the icon anchor.
           *
           * @option tooltipAnchor: Point = [0, 0]
           * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
           *
           * @option shadowUrl: String = null
           * The URL to the icon shadow image. If not specified, no shadow image will be created.
           *
           * @option shadowRetinaUrl: String = null
           *
           * @option shadowSize: Point = null
           * Size of the shadow image in pixels.
           *
           * @option shadowAnchor: Point = null
           * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
           * as iconAnchor if not specified).
           *
           * @option className: String = ''
           * A custom class name to assign to both icon and shadow images. Empty by default.
           */
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0],
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          // @method createIcon(oldIcon?: HTMLElement): HTMLElement
          // Called internally when the icon has to be shown, returns a `<img>` HTML element
          // styled according to the options.
          createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
          },
          // @method createShadow(oldIcon?: HTMLElement): HTMLElement
          // As `createIcon`, but for the shadow beneath it.
          createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
          },
          _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
              if (name === "icon") {
                throw new Error("iconUrl not set in Icon options (see the docs).");
              }
              return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            return img;
          },
          _setIconStyles: function(img, name) {
            var options = this.options;
            var sizeOption = options[name + "Size"];
            if (typeof sizeOption === "number") {
              sizeOption = [sizeOption, sizeOption];
            }
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options.className || "");
            if (anchor) {
              img.style.marginLeft = -anchor.x + "px";
              img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
              img.style.width = size.x + "px";
              img.style.height = size.y + "px";
            }
          },
          _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
          },
          _getIconUrl: function(name) {
            return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
          }
        });
        function icon(options) {
          return new Icon(options);
        }
        var IconDefault = Icon.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(name) {
            if (typeof IconDefault.imagePath !== "string") {
              IconDefault.imagePath = this._detectIconPath();
            }
            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
          },
          _stripUrl: function(path) {
            var strip = function(str, re, idx) {
              var match = re.exec(str);
              return match && match[idx];
            };
            path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
            return path && strip(path, /^(.*)marker-icon\.png$/, 1);
          },
          _detectIconPath: function() {
            var el = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
            document.body.removeChild(el);
            path = this._stripUrl(path);
            if (path) {
              return path;
            }
            var link = document.querySelector('link[href$="leaflet.css"]');
            if (!link) {
              return "";
            }
            return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
          }
        });
        var MarkerDrag = Handler.extend({
          initialize: function(marker2) {
            this._marker = marker2;
          },
          addHooks: function() {
            var icon2 = this._marker._icon;
            if (!this._draggable) {
              this._draggable = new Draggable(icon2, icon2, true);
            }
            this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable();
            addClass(icon2, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) {
              removeClass(this._marker._icon, "leaflet-marker-draggable");
            }
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(e) {
            var marker2 = this._marker, map2 = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map2.getPixelBounds(), origin = map2.getPixelOrigin();
            var panBounds = toBounds(
              bounds.min._subtract(origin).add(padding),
              bounds.max._subtract(origin).subtract(padding)
            );
            if (!panBounds.contains(iconPos)) {
              var movement = toPoint(
                (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
                (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
              ).multiplyBy(speed);
              map2.panBy(movement, { animate: false });
              this._draggable._newPos._add(movement);
              this._draggable._startPos._add(movement);
              setPosition(marker2._icon, this._draggable._newPos);
              this._onDrag(e);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng();
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(e) {
            if (this._marker.options.autoPan) {
              cancelAnimFrame(this._panRequest);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDrag: function(e) {
            var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
            if (shadow) {
              setPosition(shadow, iconPos);
            }
            marker2._latlng = latlng;
            e.latlng = latlng;
            e.oldLatLng = this._oldLatLng;
            marker2.fire("move", e).fire("drag", e);
          },
          _onDragEnd: function(e) {
            cancelAnimFrame(this._panRequest);
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e);
          }
        });
        var Marker = Layer.extend({
          // @section
          // @aka Marker options
          options: {
            // @option icon: Icon = *
            // Icon instance to use for rendering the marker.
            // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
            // If not specified, a common instance of `L.Icon.Default` is used.
            icon: new IconDefault(),
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option keyboard: Boolean = true
            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
            keyboard: true,
            // @option title: String = ''
            // Text for the browser tooltip that appear on marker hover (no tooltip by default).
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            title: "",
            // @option alt: String = 'Marker'
            // Text for the `alt` attribute of the icon image.
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            alt: "Marker",
            // @option zIndexOffset: Number = 0
            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
            zIndexOffset: 0,
            // @option opacity: Number = 1.0
            // The opacity of the marker.
            opacity: 1,
            // @option riseOnHover: Boolean = false
            // If `true`, the marker will get on top of others when you hover the mouse over it.
            riseOnHover: false,
            // @option riseOffset: Number = 250
            // The z-index offset used for the `riseOnHover` feature.
            riseOffset: 250,
            // @option pane: String = 'markerPane'
            // `Map pane` where the markers icon will be added.
            pane: "markerPane",
            // @option shadowPane: String = 'shadowPane'
            // `Map pane` where the markers shadow will be added.
            shadowPane: "shadowPane",
            // @option bubblingMouseEvents: Boolean = false
            // When `true`, a mouse event on this marker will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: false,
            // @option autoPanOnFocus: Boolean = true
            // When `true`, the map will pan whenever the marker is focused (via
            // e.g. pressing `tab` on the keyboard) to ensure the marker is
            // visible within the map's bounds
            autoPanOnFocus: true,
            // @section Draggable marker options
            // @option draggable: Boolean = false
            // Whether the marker is draggable with mouse/touch or not.
            draggable: false,
            // @option autoPan: Boolean = false
            // Whether to pan the map when dragging this marker near its edge or not.
            autoPan: false,
            // @option autoPanPadding: Point = Point(50, 50)
            // Distance (in pixels to the left/right and to the top/bottom) of the
            // map edge to start panning the map.
            autoPanPadding: [50, 50],
            // @option autoPanSpeed: Number = 10
            // Number of pixels the map should pan by.
            autoPanSpeed: 10
          },
          /* @section
           *
           * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
           */
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
          },
          onAdd: function(map2) {
            this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
            if (this._zoomAnimated) {
              map2.on("zoomanim", this._animateZoom, this);
            }
            this._initIcon();
            this.update();
          },
          onRemove: function(map2) {
            if (this.dragging && this.dragging.enabled()) {
              this.options.draggable = true;
              this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) {
              map2.off("zoomanim", this._animateZoom, this);
            }
            this._removeIcon();
            this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          // @method getLatLng: LatLng
          // Returns the current geographical position of the marker.
          getLatLng: function() {
            return this._latlng;
          },
          // @method setLatLng(latlng: LatLng): this
          // Changes the marker position to the given point.
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          // @method setZIndexOffset(offset: Number): this
          // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
          setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
          },
          // @method getIcon: Icon
          // Returns the current icon used by the marker
          getIcon: function() {
            return this.options.icon;
          },
          // @method setIcon(icon: Icon): this
          // Changes the marker icon.
          setIcon: function(icon2) {
            this.options.icon = icon2;
            if (this._map) {
              this._initIcon();
              this.update();
            }
            if (this._popup) {
              this.bindPopup(this._popup, this._popup.options);
            }
            return this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            if (this._icon && this._map) {
              var pos = this._map.latLngToLayerPoint(this._latlng).round();
              this._setPos(pos);
            }
            return this;
          },
          _initIcon: function() {
            var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var icon2 = options.icon.createIcon(this._icon), addIcon = false;
            if (icon2 !== this._icon) {
              if (this._icon) {
                this._removeIcon();
              }
              addIcon = true;
              if (options.title) {
                icon2.title = options.title;
              }
              if (icon2.tagName === "IMG") {
                icon2.alt = options.alt || "";
              }
            }
            addClass(icon2, classToAdd);
            if (options.keyboard) {
              icon2.tabIndex = "0";
              icon2.setAttribute("role", "button");
            }
            this._icon = icon2;
            if (options.riseOnHover) {
              this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              on(icon2, "focus", this._panOnFocus, this);
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
              this._removeShadow();
              addShadow = true;
            }
            if (newShadow) {
              addClass(newShadow, classToAdd);
              newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
              this._updateOpacity();
            }
            if (addIcon) {
              this.getPane().appendChild(this._icon);
            }
            this._initInteraction();
            if (newShadow && addShadow) {
              this.getPane(options.shadowPane).appendChild(this._shadow);
            }
          },
          _removeIcon: function() {
            if (this.options.riseOnHover) {
              this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              off(this._icon, "focus", this._panOnFocus, this);
            }
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
          },
          _removeShadow: function() {
            if (this._shadow) {
              remove(this._shadow);
            }
            this._shadow = null;
          },
          _setPos: function(pos) {
            if (this._icon) {
              setPosition(this._icon, pos);
            }
            if (this._shadow) {
              setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
          },
          _updateZIndex: function(offset) {
            if (this._icon) {
              this._icon.style.zIndex = this._zIndex + offset;
            }
          },
          _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
          },
          _initInteraction: function() {
            if (!this.options.interactive) {
              return;
            }
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
              var draggable = this.options.draggable;
              if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
              }
              this.dragging = new MarkerDrag(this);
              if (draggable) {
                this.dragging.enable();
              }
            }
          },
          // @method setOpacity(opacity: Number): this
          // Changes the opacity of the marker.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
              this._updateOpacity();
            }
            return this;
          },
          _updateOpacity: function() {
            var opacity = this.options.opacity;
            if (this._icon) {
              setOpacity(this._icon, opacity);
            }
            if (this._shadow) {
              setOpacity(this._shadow, opacity);
            }
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _panOnFocus: function() {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var iconOpts = this.options.icon.options;
            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
            map2.panInside(this._latlng, {
              paddingTopLeft: anchor,
              paddingBottomRight: size.subtract(anchor)
            });
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        function marker(latlng, options) {
          return new Marker(latlng, options);
        }
        var Path = Layer.extend({
          // @section
          // @aka Path options
          options: {
            // @option stroke: Boolean = true
            // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
            stroke: true,
            // @option color: String = '#3388ff'
            // Stroke color
            color: "#3388ff",
            // @option weight: Number = 3
            // Stroke width in pixels
            weight: 3,
            // @option opacity: Number = 1.0
            // Stroke opacity
            opacity: 1,
            // @option lineCap: String= 'round'
            // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
            lineCap: "round",
            // @option lineJoin: String = 'round'
            // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
            lineJoin: "round",
            // @option dashArray: String = null
            // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashArray: null,
            // @option dashOffset: String = null
            // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashOffset: null,
            // @option fill: Boolean = depends
            // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
            fill: false,
            // @option fillColor: String = *
            // Fill color. Defaults to the value of the [`color`](#path-color) option
            fillColor: null,
            // @option fillOpacity: Number = 0.2
            // Fill opacity.
            fillOpacity: 0.2,
            // @option fillRule: String = 'evenodd'
            // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
            fillRule: "evenodd",
            // className: '',
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option bubblingMouseEvents: Boolean = true
            // When `true`, a mouse event on this path will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: true
          },
          beforeAdd: function(map2) {
            this._renderer = map2.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          // @method redraw(): this
          // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
          redraw: function() {
            if (this._map) {
              this._renderer._updatePath(this);
            }
            return this;
          },
          // @method setStyle(style: Path options): this
          // Changes the appearance of a Path based on the options in the `Path options` object.
          setStyle: function(style2) {
            setOptions(this, style2);
            if (this._renderer) {
              this._renderer._updateStyle(this);
              if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
                this._updateBounds();
              }
            }
            return this;
          },
          // @method bringToFront(): this
          // Brings the layer to the top of all path layers.
          bringToFront: function() {
            if (this._renderer) {
              this._renderer._bringToFront(this);
            }
            return this;
          },
          // @method bringToBack(): this
          // Brings the layer to the bottom of all path layers.
          bringToBack: function() {
            if (this._renderer) {
              this._renderer._bringToBack(this);
            }
            return this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project();
            this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
          }
        });
        var CircleMarker = Path.extend({
          // @section
          // @aka CircleMarker options
          options: {
            fill: true,
            // @option radius: Number = 10
            // Radius of the circle marker, in pixels
            radius: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
          },
          // @method setLatLng(latLng: LatLng): this
          // Sets the position of a circle marker to a new location.
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          // @method getLatLng(): LatLng
          // Returns the current geographical position of the circle marker
          getLatLng: function() {
            return this._latlng;
          },
          // @method setRadius(radius: Number): this
          // Sets the radius of a circle marker. Units are in pixels.
          setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
          },
          // @method getRadius(): Number
          // Returns the current radius of the circle
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(options) {
            var radius = options && options.radius || this._radius;
            Path.prototype.setStyle.call(this, options);
            this.setRadius(radius);
            return this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
          },
          _updateBounds: function() {
            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
          },
          _update: function() {
            if (this._map) {
              this._updatePath();
            }
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p) {
            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        function circleMarker(latlng, options) {
          return new CircleMarker(latlng, options);
        }
        var Circle = CircleMarker.extend({
          initialize: function(latlng, options, legacyOptions) {
            if (typeof options === "number") {
              options = extend({}, legacyOptions, { radius: options });
            }
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) {
              throw new Error("Circle radius cannot be NaN");
            }
            this._mRadius = this.options.radius;
          },
          // @method setRadius(radius: Number): this
          // Sets the radius of a circle. Units are in meters.
          setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
          },
          // @method getRadius(): Number
          // Returns the current radius of a circle. Units are in meters.
          getRadius: function() {
            return this._mRadius;
          },
          // @method getBounds(): LatLngBounds
          // Returns the `LatLngBounds` of the path.
          getBounds: function() {
            var half = [this._radius, this._radiusY || this._radius];
            return new LatLngBounds(
              this._map.layerPointToLatLng(this._point.subtract(half)),
              this._map.layerPointToLatLng(this._point.add(half))
            );
          },
          setStyle: Path.prototype.setStyle,
          _project: function() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
            if (crs.distance === Earth.distance) {
              var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map2.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
              if (isNaN(lngR) || lngR === 0) {
                lngR = latR / Math.cos(Math.PI / 180 * lat);
              }
              this._point = p.subtract(map2.getPixelOrigin());
              this._radius = isNaN(lngR) ? 0 : p.x - map2.project([lat2, lng - lngR]).x;
              this._radiusY = p.y - top.y;
            } else {
              var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
              this._point = map2.latLngToLayerPoint(this._latlng);
              this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
          }
        });
        function circle(latlng, options, legacyOptions) {
          return new Circle(latlng, options, legacyOptions);
        }
        var Polyline = Path.extend({
          // @section
          // @aka Polyline options
          options: {
            // @option smoothFactor: Number = 1.0
            // How much to simplify the polyline on each zoom level. More means
            // better performance and smoother look, and less means more accurate representation.
            smoothFactor: 1,
            // @option noClip: Boolean = false
            // Disable polyline clipping.
            noClip: false
          },
          initialize: function(latlngs, options) {
            setOptions(this, options);
            this._setLatLngs(latlngs);
          },
          // @method getLatLngs(): LatLng[]
          // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
          getLatLngs: function() {
            return this._latlngs;
          },
          // @method setLatLngs(latlngs: LatLng[]): this
          // Replaces all the points in the polyline with the given array of geographical points.
          setLatLngs: function(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
          },
          // @method isEmpty(): Boolean
          // Returns `true` if the Polyline has no LatLngs.
          isEmpty: function() {
            return !this._latlngs.length;
          },
          // @method closestLayerPoint(p: Point): Point
          // Returns the point closest to `p` on the Polyline.
          closestLayerPoint: function(p) {
            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
              var points2 = this._parts[j];
              for (var i = 1, len = points2.length; i < len; i++) {
                p1 = points2[i - 1];
                p2 = points2[i];
                var sqDist = closest(p, p1, p2, true);
                if (sqDist < minDistance) {
                  minDistance = sqDist;
                  minPoint = closest(p, p1, p2);
                }
              }
            }
            if (minPoint) {
              minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
          },
          // @method getCenter(): LatLng
          // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polylineCenter(this._defaultShape(), this._map.options.crs);
          },
          // @method getBounds(): LatLngBounds
          // Returns the `LatLngBounds` of the path.
          getBounds: function() {
            return this._bounds;
          },
          // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
          // Adds a given point to the polyline. By default, adds to the first ring of
          // the polyline in case of a multi-polyline, but can be overridden by passing
          // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
          addLatLng: function(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
          },
          _setLatLngs: function(latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
          },
          _defaultShape: function() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
          _convertLatLngs: function(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for (var i = 0, len = latlngs.length; i < len; i++) {
              if (flat) {
                result[i] = toLatLng(latlngs[i]);
                this._bounds.extend(result[i]);
              } else {
                result[i] = this._convertLatLngs(latlngs[i]);
              }
            }
            return result;
          },
          _project: function() {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
              this._rawPxBounds = pxBounds;
              this._updateBounds();
            }
          },
          _updateBounds: function() {
            var w = this._clickTolerance(), p = new Point(w, w);
            if (!this._rawPxBounds) {
              return;
            }
            this._pxBounds = new Bounds([
              this._rawPxBounds.min.subtract(p),
              this._rawPxBounds.max.add(p)
            ]);
          },
          // recursively turns latlngs into a set of rings with projected coordinates
          _projectLatlngs: function(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
            if (flat) {
              ring = [];
              for (i = 0; i < len; i++) {
                ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                projectedBounds.extend(ring[i]);
              }
              result.push(ring);
            } else {
              for (i = 0; i < len; i++) {
                this._projectLatlngs(latlngs[i], result, projectedBounds);
              }
            }
          },
          // clip polyline by renderer bounds so that we have less to render for performance
          _clipPoints: function() {
            var bounds = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var parts = this._parts, i, j, k, len, len2, segment, points2;
            for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
              points2 = this._rings[i];
              for (j = 0, len2 = points2.length; j < len2 - 1; j++) {
                segment = clipSegment(points2[j], points2[j + 1], bounds, j, true);
                if (!segment) {
                  continue;
                }
                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);
                if (segment[1] !== points2[j + 1] || j === len2 - 2) {
                  parts[k].push(segment[1]);
                  k++;
                }
              }
            }
          },
          // simplify each clipped part of the polyline for performance
          _simplifyPoints: function() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for (var i = 0, len = parts.length; i < len; i++) {
              parts[i] = simplify(parts[i], tolerance);
            }
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p, closed) {
            var i, j, k, len, len2, part, w = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                if (!closed && j === 0) {
                  continue;
                }
                if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                  return true;
                }
              }
            }
            return false;
          }
        });
        function polyline(latlngs, options) {
          return new Polyline(latlngs, options);
        }
        Polyline._flat = _flat;
        var Polygon = Polyline.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          // @method getCenter(): LatLng
          // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polygonCenter(this._defaultShape(), this._map.options.crs);
          },
          _convertLatLngs: function(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
              result.pop();
            }
            return result;
          },
          _setLatLngs: function(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) {
              this._latlngs = [this._latlngs];
            }
          },
          _defaultShape: function() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
          },
          _clipPoints: function() {
            var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
              clipped = clipPolygon(this._rings[i], bounds, true);
              if (clipped.length) {
                this._parts.push(clipped);
              }
            }
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p) {
            var inside = false, part, p1, p2, i, j, k, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                p1 = part[j];
                p2 = part[k];
                if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                  inside = !inside;
                }
              }
            }
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
          }
        });
        function polygon(latlngs, options) {
          return new Polygon(latlngs, options);
        }
        var GeoJSON = FeatureGroup.extend({
          /* @section
           * @aka GeoJSON options
           *
           * @option pointToLayer: Function = *
           * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
           * called when data is added, passing the GeoJSON point feature and its `LatLng`.
           * The default is to spawn a default `Marker`:
           * ```js
           * function(geoJsonPoint, latlng) {
           * 	return L.marker(latlng);
           * }
           * ```
           *
           * @option style: Function = *
           * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
           * called internally when data is added.
           * The default value is to not override any defaults:
           * ```js
           * function (geoJsonFeature) {
           * 	return {}
           * }
           * ```
           *
           * @option onEachFeature: Function = *
           * A `Function` that will be called once for each created `Feature`, after it has
           * been created and styled. Useful for attaching events and popups to features.
           * The default is to do nothing with the newly created layers:
           * ```js
           * function (feature, layer) {}
           * ```
           *
           * @option filter: Function = *
           * A `Function` that will be used to decide whether to include a feature or not.
           * The default is to include all features:
           * ```js
           * function (geoJsonFeature) {
           * 	return true;
           * }
           * ```
           * Note: dynamically changing the `filter` option will have effect only on newly
           * added data. It will _not_ re-evaluate already included features.
           *
           * @option coordsToLatLng: Function = *
           * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
           * The default is the `coordsToLatLng` static method.
           *
           * @option markersInheritOptions: Boolean = false
           * Whether default Markers for "Point" type Features inherit from group options.
           */
          initialize: function(geojson, options) {
            setOptions(this, options);
            this._layers = {};
            if (geojson) {
              this.addData(geojson);
            }
          },
          // @method addData( <GeoJSON> data ): this
          // Adds a GeoJSON object to the layer.
          addData: function(geojson) {
            var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;
            if (features) {
              for (i = 0, len = features.length; i < len; i++) {
                feature = features[i];
                if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                  this.addData(feature);
                }
              }
              return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
              return this;
            }
            var layer = geometryToLayer(geojson, options);
            if (!layer) {
              return this;
            }
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
              options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
          },
          // @method resetStyle( <Path> layer? ): this
          // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
          // If `layer` is omitted, the style of all features in the current layer is reset.
          resetStyle: function(layer) {
            if (layer === void 0) {
              return this.eachLayer(this.resetStyle, this);
            }
            layer.options = extend({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
          },
          // @method setStyle( <Function> style ): this
          // Changes styles of GeoJSON vector layers with the given style function.
          setStyle: function(style2) {
            return this.eachLayer(function(layer) {
              this._setLayerStyle(layer, style2);
            }, this);
          },
          _setLayerStyle: function(layer, style2) {
            if (layer.setStyle) {
              if (typeof style2 === "function") {
                style2 = style2(layer.feature);
              }
              layer.setStyle(style2);
            }
          }
        });
        function geometryToLayer(geojson, options) {
          var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
          if (!coords && !geometry) {
            return null;
          }
          switch (geometry.type) {
            case "Point":
              latlng = _coordsToLatLng(coords);
              return _pointToLayer(pointToLayer, geojson, latlng, options);
            case "MultiPoint":
              for (i = 0, len = coords.length; i < len; i++) {
                latlng = _coordsToLatLng(coords[i]);
                layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
              }
              return new FeatureGroup(layers2);
            case "LineString":
            case "MultiLineString":
              latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
              return new Polyline(latlngs, options);
            case "Polygon":
            case "MultiPolygon":
              latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
              return new Polygon(latlngs, options);
            case "GeometryCollection":
              for (i = 0, len = geometry.geometries.length; i < len; i++) {
                var geoLayer = geometryToLayer({
                  geometry: geometry.geometries[i],
                  type: "Feature",
                  properties: geojson.properties
                }, options);
                if (geoLayer) {
                  layers2.push(geoLayer);
                }
              }
              return new FeatureGroup(layers2);
            case "FeatureCollection":
              for (i = 0, len = geometry.features.length; i < len; i++) {
                var featureLayer = geometryToLayer(geometry.features[i], options);
                if (featureLayer) {
                  layers2.push(featureLayer);
                }
              }
              return new FeatureGroup(layers2);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
          return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
        }
        function coordsToLatLng(coords) {
          return new LatLng(coords[1], coords[0], coords[2]);
        }
        function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
          var latlngs = [];
          for (var i = 0, len = coords.length, latlng; i < len; i++) {
            latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
            latlngs.push(latlng);
          }
          return latlngs;
        }
        function latLngToCoords(latlng, precision) {
          latlng = toLatLng(latlng);
          return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
        }
        function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
          var coords = [];
          for (var i = 0, len = latlngs.length; i < len; i++) {
            coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
          }
          if (!levelsDeep && closed && coords.length > 0) {
            coords.push(coords[0].slice());
          }
          return coords;
        }
        function getFeature(layer, newGeometry) {
          return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
        }
        function asFeature(geojson) {
          if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
            return geojson;
          }
          return {
            type: "Feature",
            properties: {},
            geometry: geojson
          };
        }
        var PointToGeoJSON = {
          toGeoJSON: function(precision) {
            return getFeature(this, {
              type: "Point",
              coordinates: latLngToCoords(this.getLatLng(), precision)
            });
          }
        };
        Marker.include(PointToGeoJSON);
        Circle.include(PointToGeoJSON);
        CircleMarker.include(PointToGeoJSON);
        Polyline.include({
          toGeoJSON: function(precision) {
            var multi = !isFlat(this._latlngs);
            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "LineString",
              coordinates: coords
            });
          }
        });
        Polygon.include({
          toGeoJSON: function(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) {
              coords = [coords];
            }
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "Polygon",
              coordinates: coords
            });
          }
        });
        LayerGroup.include({
          toMultiPoint: function(precision) {
            var coords = [];
            this.eachLayer(function(layer) {
              coords.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
              type: "MultiPoint",
              coordinates: coords
            });
          },
          // @method toGeoJSON(precision?: Number|false): Object
          // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
          // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
          toGeoJSON: function(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") {
              return this.toMultiPoint(precision);
            }
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
              if (layer.toGeoJSON) {
                var json = layer.toGeoJSON(precision);
                if (isGeometryCollection) {
                  jsons.push(json.geometry);
                } else {
                  var feature = asFeature(json);
                  if (feature.type === "FeatureCollection") {
                    jsons.push.apply(jsons, feature.features);
                  } else {
                    jsons.push(feature);
                  }
                }
              }
            });
            if (isGeometryCollection) {
              return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
              });
            }
            return {
              type: "FeatureCollection",
              features: jsons
            };
          }
        });
        function geoJSON(geojson, options) {
          return new GeoJSON(geojson, options);
        }
        var geoJson = geoJSON;
        var ImageOverlay = Layer.extend({
          // @section
          // @aka ImageOverlay options
          options: {
            // @option opacity: Number = 1.0
            // The opacity of the image overlay.
            opacity: 1,
            // @option alt: String = ''
            // Text for the `alt` attribute of the image (useful for accessibility).
            alt: "",
            // @option interactive: Boolean = false
            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
            interactive: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the image.
            // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option errorOverlayUrl: String = ''
            // URL to the overlay image to show in place of the overlay that failed to load.
            errorOverlayUrl: "",
            // @option zIndex: Number = 1
            // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
            zIndex: 1,
            // @option className: String = ''
            // A custom class name to assign to the image. Empty by default.
            className: ""
          },
          initialize: function(url, bounds, options) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds);
            setOptions(this, options);
          },
          onAdd: function() {
            if (!this._image) {
              this._initImage();
              if (this.options.opacity < 1) {
                this._updateOpacity();
              }
            }
            if (this.options.interactive) {
              addClass(this._image, "leaflet-interactive");
              this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
          },
          onRemove: function() {
            remove(this._image);
            if (this.options.interactive) {
              this.removeInteractiveTarget(this._image);
            }
          },
          // @method setOpacity(opacity: Number): this
          // Sets the opacity of the overlay.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._image) {
              this._updateOpacity();
            }
            return this;
          },
          setStyle: function(styleOpts) {
            if (styleOpts.opacity) {
              this.setOpacity(styleOpts.opacity);
            }
            return this;
          },
          // @method bringToFront(): this
          // Brings the layer to the top of all overlays.
          bringToFront: function() {
            if (this._map) {
              toFront(this._image);
            }
            return this;
          },
          // @method bringToBack(): this
          // Brings the layer to the bottom of all overlays.
          bringToBack: function() {
            if (this._map) {
              toBack(this._image);
            }
            return this;
          },
          // @method setUrl(url: String): this
          // Changes the URL of the image.
          setUrl: function(url) {
            this._url = url;
            if (this._image) {
              this._image.src = url;
            }
            return this;
          },
          // @method setBounds(bounds: LatLngBounds): this
          // Update the bounds that this ImageOverlay covers
          setBounds: function(bounds) {
            this._bounds = toLatLngBounds(bounds);
            if (this._map) {
              this._reset();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              zoom: this._reset,
              viewreset: this._reset
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @method setZIndex(value: Number): this
          // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
          setZIndex: function(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
          },
          // @method getBounds(): LatLngBounds
          // Get the bounds that this ImageOverlay covers
          getBounds: function() {
            return this._bounds;
          },
          // @method getElement(): HTMLElement
          // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
          // used by this overlay.
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(img, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(img, this.options.className);
            }
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (this.options.zIndex) {
              this._updateZIndex();
            }
            if (wasElementSupplied) {
              this._url = img.src;
              return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
          },
          _animateZoom: function(e) {
            var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
            setTransform(this._image, offset, scale2);
          },
          _reset: function() {
            var image = this._image, bounds = new Bounds(
              this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
              this._map.latLngToLayerPoint(this._bounds.getSouthEast())
            ), size = bounds.getSize();
            setPosition(image, bounds.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
          },
          _updateOpacity: function() {
            setOpacity(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._image.style.zIndex = this.options.zIndex;
            }
          },
          _overlayOnError: function() {
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
              this._url = errorUrl;
              this._image.src = errorUrl;
            }
          },
          // @method getCenter(): LatLng
          // Returns the center of the ImageOverlay.
          getCenter: function() {
            return this._bounds.getCenter();
          }
        });
        var imageOverlay = function(url, bounds, options) {
          return new ImageOverlay(url, bounds, options);
        };
        var VideoOverlay = ImageOverlay.extend({
          // @section
          // @aka VideoOverlay options
          options: {
            // @option autoplay: Boolean = true
            // Whether the video starts playing automatically when loaded.
            // On some browsers autoplay will only work with `muted: true`
            autoplay: true,
            // @option loop: Boolean = true
            // Whether the video will loop back to the beginning when played.
            loop: true,
            // @option keepAspectRatio: Boolean = true
            // Whether the video will save aspect ratio after the projection.
            // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
            keepAspectRatio: true,
            // @option muted: Boolean = false
            // Whether the video starts on mute when loaded.
            muted: false,
            // @option playsInline: Boolean = true
            // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
            playsInline: true
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(vid, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(vid, this.options.className);
            }
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
              var sourceElements = vid.getElementsByTagName("source");
              var sources = [];
              for (var j = 0; j < sourceElements.length; j++) {
                sources.push(sourceElements[j].src);
              }
              this._url = sourceElements.length > 0 ? sources : [vid.src];
              return;
            }
            if (!isArray(this._url)) {
              this._url = [this._url];
            }
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
              vid.style["objectFit"] = "fill";
            }
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            vid.playsInline = !!this.options.playsInline;
            for (var i = 0; i < this._url.length; i++) {
              var source = create$1("source");
              source.src = this._url[i];
              vid.appendChild(source);
            }
          }
          // @method getElement(): HTMLVideoElement
          // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
          // used by this overlay.
        });
        function videoOverlay(video, bounds, options) {
          return new VideoOverlay(video, bounds, options);
        }
        var SVGOverlay = ImageOverlay.extend({
          _initImage: function() {
            var el = this._image = this._url;
            addClass(el, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(el, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(el, this.options.className);
            }
            el.onselectstart = falseFn;
            el.onmousemove = falseFn;
          }
          // @method getElement(): SVGElement
          // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
          // used by this overlay.
        });
        function svgOverlay(el, bounds, options) {
          return new SVGOverlay(el, bounds, options);
        }
        var DivOverlay = Layer.extend({
          // @section
          // @aka DivOverlay options
          options: {
            // @option interactive: Boolean = false
            // If true, the popup/tooltip will listen to the mouse events.
            interactive: false,
            // @option offset: Point = Point(0, 0)
            // The offset of the overlay position.
            offset: [0, 0],
            // @option className: String = ''
            // A custom CSS class name to assign to the overlay.
            className: "",
            // @option pane: String = undefined
            // `Map pane` where the overlay will be added.
            pane: void 0,
            // @option content: String|HTMLElement|Function = ''
            // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
            // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
            content: ""
          },
          initialize: function(options, source) {
            if (options && (options instanceof LatLng || isArray(options))) {
              this._latlng = toLatLng(options);
              setOptions(this, source);
            } else {
              setOptions(this, options);
              this._source = source;
            }
            if (this.options.content) {
              this._content = this.options.content;
            }
          },
          // @method openOn(map: Map): this
          // Adds the overlay to the map.
          // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
          openOn: function(map2) {
            map2 = arguments.length ? map2 : this._source._map;
            if (!map2.hasLayer(this)) {
              map2.addLayer(this);
            }
            return this;
          },
          // @method close(): this
          // Closes the overlay.
          // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
          // and `layer.closePopup()`/`.closeTooltip()`.
          close: function() {
            if (this._map) {
              this._map.removeLayer(this);
            }
            return this;
          },
          // @method toggle(layer?: Layer): this
          // Opens or closes the overlay bound to layer depending on its current state.
          // Argument may be omitted only for overlay bound to layer.
          // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
          toggle: function(layer) {
            if (this._map) {
              this.close();
            } else {
              if (arguments.length) {
                this._source = layer;
              } else {
                layer = this._source;
              }
              this._prepareOpen();
              this.openOn(layer._map);
            }
            return this;
          },
          onAdd: function(map2) {
            this._zoomAnimated = map2._zoomAnimated;
            if (!this._container) {
              this._initLayout();
            }
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map2._fadeAnimated) {
              setOpacity(this._container, 1);
            }
            this.bringToFront();
            if (this.options.interactive) {
              addClass(this._container, "leaflet-interactive");
              this.addInteractiveTarget(this._container);
            }
          },
          onRemove: function(map2) {
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
              this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
            } else {
              remove(this._container);
            }
            if (this.options.interactive) {
              removeClass(this._container, "leaflet-interactive");
              this.removeInteractiveTarget(this._container);
            }
          },
          // @namespace DivOverlay
          // @method getLatLng: LatLng
          // Returns the geographical point of the overlay.
          getLatLng: function() {
            return this._latlng;
          },
          // @method setLatLng(latlng: LatLng): this
          // Sets the geographical point where the overlay will open.
          setLatLng: function(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
              this._updatePosition();
              this._adjustPan();
            }
            return this;
          },
          // @method getContent: String|HTMLElement
          // Returns the content of the overlay.
          getContent: function() {
            return this._content;
          },
          // @method setContent(htmlContent: String|HTMLElement|Function): this
          // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
          // The function should return a `String` or `HTMLElement` to be used in the overlay.
          setContent: function(content) {
            this._content = content;
            this.update();
            return this;
          },
          // @method getElement: String|HTMLElement
          // Returns the HTML container of the overlay.
          getElement: function() {
            return this._container;
          },
          // @method update: null
          // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
          update: function() {
            if (!this._map) {
              return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
          },
          getEvents: function() {
            var events = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @method isOpen: Boolean
          // Returns `true` when the overlay is visible on the map.
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          // @method bringToFront: this
          // Brings this overlay in front of other overlays (in the same map pane).
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
            }
            return this;
          },
          // @method bringToBack: this
          // Brings this overlay to the back of other overlays (in the same map pane).
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
            }
            return this;
          },
          // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
          _prepareOpen: function(latlng) {
            var source = this._source;
            if (!source._map) {
              return false;
            }
            if (source instanceof FeatureGroup) {
              source = null;
              var layers2 = this._source._layers;
              for (var id in layers2) {
                if (layers2[id]._map) {
                  source = layers2[id];
                  break;
                }
              }
              if (!source) {
                return false;
              }
              this._source = source;
            }
            if (!latlng) {
              if (source.getCenter) {
                latlng = source.getCenter();
              } else if (source.getLatLng) {
                latlng = source.getLatLng();
              } else if (source.getBounds) {
                latlng = source.getBounds().getCenter();
              } else {
                throw new Error("Unable to get source layer LatLng.");
              }
            }
            this.setLatLng(latlng);
            if (this._map) {
              this.update();
            }
            return true;
          },
          _updateContent: function() {
            if (!this._content) {
              return;
            }
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") {
              node.innerHTML = content;
            } else {
              while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
              }
              node.appendChild(content);
            }
            this.fire("contentupdate");
          },
          _updatePosition: function() {
            if (!this._map) {
              return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) {
              setPosition(this._container, pos.add(anchor));
            } else {
              offset = offset.add(pos).add(anchor);
            }
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
          },
          _getAnchor: function() {
            return [0, 0];
          }
        });
        Map.include({
          _initOverlay: function(OverlayClass, content, latlng, options) {
            var overlay = content;
            if (!(overlay instanceof OverlayClass)) {
              overlay = new OverlayClass(options).setContent(content);
            }
            if (latlng) {
              overlay.setLatLng(latlng);
            }
            return overlay;
          }
        });
        Layer.include({
          _initOverlay: function(OverlayClass, old, content, options) {
            var overlay = content;
            if (overlay instanceof OverlayClass) {
              setOptions(overlay, options);
              overlay._source = this;
            } else {
              overlay = old && !options ? old : new OverlayClass(options, this);
              overlay.setContent(content);
            }
            return overlay;
          }
        });
        var Popup = DivOverlay.extend({
          // @section
          // @aka Popup options
          options: {
            // @option pane: String = 'popupPane'
            // `Map pane` where the popup will be added.
            pane: "popupPane",
            // @option offset: Point = Point(0, 7)
            // The offset of the popup position.
            offset: [0, 7],
            // @option maxWidth: Number = 300
            // Max width of the popup, in pixels.
            maxWidth: 300,
            // @option minWidth: Number = 50
            // Min width of the popup, in pixels.
            minWidth: 50,
            // @option maxHeight: Number = null
            // If set, creates a scrollable container of the given height
            // inside a popup if its content exceeds it.
            // The scrollable container can be styled using the
            // `leaflet-popup-scrolled` CSS class selector.
            maxHeight: null,
            // @option autoPan: Boolean = true
            // Set it to `false` if you don't want the map to do panning animation
            // to fit the opened popup.
            autoPan: true,
            // @option autoPanPaddingTopLeft: Point = null
            // The margin between the popup and the top left corner of the map
            // view after autopanning was performed.
            autoPanPaddingTopLeft: null,
            // @option autoPanPaddingBottomRight: Point = null
            // The margin between the popup and the bottom right corner of the map
            // view after autopanning was performed.
            autoPanPaddingBottomRight: null,
            // @option autoPanPadding: Point = Point(5, 5)
            // Equivalent of setting both top left and bottom right autopan padding to the same value.
            autoPanPadding: [5, 5],
            // @option keepInView: Boolean = false
            // Set it to `true` if you want to prevent users from panning the popup
            // off of the screen while it is open.
            keepInView: false,
            // @option closeButton: Boolean = true
            // Controls the presence of a close button in the popup.
            closeButton: true,
            // @option autoClose: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the popup closing when another popup is opened.
            autoClose: true,
            // @option closeOnEscapeKey: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the ESC key for closing of the popup.
            closeOnEscapeKey: true,
            // @option closeOnClick: Boolean = *
            // Set it if you want to override the default behavior of the popup closing when user clicks
            // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
            // @option className: String = ''
            // A custom CSS class name to assign to the popup.
            className: ""
          },
          // @namespace Popup
          // @method openOn(map: Map): this
          // Alternative to `map.openPopup(popup)`.
          // Adds the popup to the map and closes the previous one.
          openOn: function(map2) {
            map2 = arguments.length ? map2 : this._source._map;
            if (!map2.hasLayer(this) && map2._popup && map2._popup.options.autoClose) {
              map2.removeLayer(map2._popup);
            }
            map2._popup = this;
            return DivOverlay.prototype.openOn.call(this, map2);
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            map2.fire("popupopen", { popup: this });
            if (this._source) {
              this._source.fire("popupopen", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.on("preclick", stopPropagation);
              }
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("popupclose", { popup: this });
            if (this._source) {
              this._source.fire("popupclose", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.off("preclick", stopPropagation);
              }
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
              events.preclick = this.close;
            }
            if (this.options.keepInView) {
              events.moveend = this._adjustPan;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-popup", container = this._container = create$1(
              "div",
              prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
            );
            var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix + "-tip-container", container);
            this._tip = create$1("div", prefix + "-tip", this._tipContainer);
            if (this.options.closeButton) {
              var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
              closeButton.setAttribute("role", "button");
              closeButton.setAttribute("aria-label", "Close popup");
              closeButton.href = "#close";
              closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
              on(closeButton, "click", function(ev) {
                preventDefault(ev);
                this.close();
              }, this);
            }
          },
          _updateLayout: function() {
            var container = this._contentNode, style2 = container.style;
            style2.width = "";
            style2.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style2.width = width + 1 + "px";
            style2.whiteSpace = "";
            style2.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
              style2.height = maxHeight + "px";
              addClass(container, scrolledClass);
            } else {
              removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
          },
          _adjustPan: function() {
            if (!this.options.autoPan) {
              return;
            }
            if (this._map._panAnim) {
              this._map._panAnim.stop();
            }
            if (this._autopanning) {
              this._autopanning = false;
              return;
            }
            var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map2.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
              dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
              dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
              dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
              dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
              if (this.options.keepInView) {
                this._autopanning = true;
              }
              map2.fire("autopanstart").panBy([dx, dy]);
            }
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        });
        var popup = function(options, source) {
          return new Popup(options, source);
        };
        Map.mergeOptions({
          closePopupOnClick: true
        });
        Map.include({
          // @method openPopup(popup: Popup): this
          // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
          // @alternative
          // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
          // Creates a popup with the specified content and options and opens it in the given point on a map.
          openPopup: function(popup2, latlng, options) {
            this._initOverlay(Popup, popup2, latlng, options).openOn(this);
            return this;
          },
          // @method closePopup(popup?: Popup): this
          // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
          closePopup: function(popup2) {
            popup2 = arguments.length ? popup2 : this._popup;
            if (popup2) {
              popup2.close();
            }
            return this;
          }
        });
        Layer.include({
          // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
          // Binds a popup to the layer with the passed `content` and sets up the
          // necessary event listeners. If a `Function` is passed it will receive
          // the layer as the first argument and should return a `String` or `HTMLElement`.
          bindPopup: function(content, options) {
            this._popup = this._initOverlay(Popup, this._popup, content, options);
            if (!this._popupHandlersAdded) {
              this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = true;
            }
            return this;
          },
          // @method unbindPopup(): this
          // Removes the popup previously bound with `bindPopup`.
          unbindPopup: function() {
            if (this._popup) {
              this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = false;
              this._popup = null;
            }
            return this;
          },
          // @method openPopup(latlng?: LatLng): this
          // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
          openPopup: function(latlng) {
            if (this._popup) {
              if (!(this instanceof FeatureGroup)) {
                this._popup._source = this;
              }
              if (this._popup._prepareOpen(latlng || this._latlng)) {
                this._popup.openOn(this._map);
              }
            }
            return this;
          },
          // @method closePopup(): this
          // Closes the popup bound to this layer if it is open.
          closePopup: function() {
            if (this._popup) {
              this._popup.close();
            }
            return this;
          },
          // @method togglePopup(): this
          // Opens or closes the popup bound to this layer depending on its current state.
          togglePopup: function() {
            if (this._popup) {
              this._popup.toggle(this);
            }
            return this;
          },
          // @method isPopupOpen(): boolean
          // Returns `true` if the popup bound to this layer is currently open.
          isPopupOpen: function() {
            return this._popup ? this._popup.isOpen() : false;
          },
          // @method setPopupContent(content: String|HTMLElement|Popup): this
          // Sets the content of the popup bound to this layer.
          setPopupContent: function(content) {
            if (this._popup) {
              this._popup.setContent(content);
            }
            return this;
          },
          // @method getPopup(): Popup
          // Returns the popup bound to this layer.
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(e) {
            if (!this._popup || !this._map) {
              return;
            }
            stop(e);
            var target = e.layer || e.target;
            if (this._popup._source === target && !(target instanceof Path)) {
              if (this._map.hasLayer(this._popup)) {
                this.closePopup();
              } else {
                this.openPopup(e.latlng);
              }
              return;
            }
            this._popup._source = target;
            this.openPopup(e.latlng);
          },
          _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
          },
          _onKeyPress: function(e) {
            if (e.originalEvent.keyCode === 13) {
              this._openPopup(e);
            }
          }
        });
        var Tooltip = DivOverlay.extend({
          // @section
          // @aka Tooltip options
          options: {
            // @option pane: String = 'tooltipPane'
            // `Map pane` where the tooltip will be added.
            pane: "tooltipPane",
            // @option offset: Point = Point(0, 0)
            // Optional offset of the tooltip position.
            offset: [0, 0],
            // @option direction: String = 'auto'
            // Direction where to open the tooltip. Possible values are: `right`, `left`,
            // `top`, `bottom`, `center`, `auto`.
            // `auto` will dynamically switch between `right` and `left` according to the tooltip
            // position on the map.
            direction: "auto",
            // @option permanent: Boolean = false
            // Whether to open the tooltip permanently or only on mouseover.
            permanent: false,
            // @option sticky: Boolean = false
            // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
            sticky: false,
            // @option opacity: Number = 0.9
            // Tooltip container opacity.
            opacity: 0.9
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            this.setOpacity(this.options.opacity);
            map2.fire("tooltipopen", { tooltip: this });
            if (this._source) {
              this.addEventParent(this._source);
              this._source.fire("tooltipopen", { tooltip: this }, true);
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("tooltipclose", { tooltip: this });
            if (this._source) {
              this.removeEventParent(this._source);
              this._source.fire("tooltipclose", { tooltip: this }, true);
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (!this.options.permanent) {
              events.preclick = this.close;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
            this._container.setAttribute("role", "tooltip");
            this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(pos) {
            var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight;
            } else if (direction === "bottom") {
              subX = tooltipWidth / 2;
              subY = 0;
            } else if (direction === "center") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight / 2;
            } else if (direction === "right") {
              subX = 0;
              subY = tooltipHeight / 2;
            } else if (direction === "left") {
              subX = tooltipWidth;
              subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
              direction = "right";
              subX = 0;
              subY = tooltipHeight / 2;
            } else {
              direction = "left";
              subX = tooltipWidth + (offset.x + anchor.x) * 2;
              subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
          },
          _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
              setOpacity(this._container, opacity);
            }
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
            this._setPosition(pos);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        });
        var tooltip = function(options, source) {
          return new Tooltip(options, source);
        };
        Map.include({
          // @method openTooltip(tooltip: Tooltip): this
          // Opens the specified tooltip.
          // @alternative
          // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
          // Creates a tooltip with the specified content and options and open it.
          openTooltip: function(tooltip2, latlng, options) {
            this._initOverlay(Tooltip, tooltip2, latlng, options).openOn(this);
            return this;
          },
          // @method closeTooltip(tooltip: Tooltip): this
          // Closes the tooltip given as parameter.
          closeTooltip: function(tooltip2) {
            tooltip2.close();
            return this;
          }
        });
        Layer.include({
          // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
          // Binds a tooltip to the layer with the passed `content` and sets up the
          // necessary event listeners. If a `Function` is passed it will receive
          // the layer as the first argument and should return a `String` or `HTMLElement`.
          bindTooltip: function(content, options) {
            if (this._tooltip && this.isTooltipOpen()) {
              this.unbindTooltip();
            }
            this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
              this.openTooltip();
            }
            return this;
          },
          // @method unbindTooltip(): this
          // Removes the tooltip previously bound with `bindTooltip`.
          unbindTooltip: function() {
            if (this._tooltip) {
              this._initTooltipInteractions(true);
              this.closeTooltip();
              this._tooltip = null;
            }
            return this;
          },
          _initTooltipInteractions: function(remove2) {
            if (!remove2 && this._tooltipHandlersAdded) {
              return;
            }
            var onOff = remove2 ? "off" : "on", events = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
              events.mouseover = this._openTooltip;
              events.mouseout = this.closeTooltip;
              events.click = this._openTooltip;
              if (this._map) {
                this._addFocusListeners();
              } else {
                events.add = this._addFocusListeners;
              }
            } else {
              events.add = this._openTooltip;
            }
            if (this._tooltip.options.sticky) {
              events.mousemove = this._moveTooltip;
            }
            this[onOff](events);
            this._tooltipHandlersAdded = !remove2;
          },
          // @method openTooltip(latlng?: LatLng): this
          // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
          openTooltip: function(latlng) {
            if (this._tooltip) {
              if (!(this instanceof FeatureGroup)) {
                this._tooltip._source = this;
              }
              if (this._tooltip._prepareOpen(latlng)) {
                this._tooltip.openOn(this._map);
                if (this.getElement) {
                  this._setAriaDescribedByOnLayer(this);
                } else if (this.eachLayer) {
                  this.eachLayer(this._setAriaDescribedByOnLayer, this);
                }
              }
            }
            return this;
          },
          // @method closeTooltip(): this
          // Closes the tooltip bound to this layer if it is open.
          closeTooltip: function() {
            if (this._tooltip) {
              return this._tooltip.close();
            }
          },
          // @method toggleTooltip(): this
          // Opens or closes the tooltip bound to this layer depending on its current state.
          toggleTooltip: function() {
            if (this._tooltip) {
              this._tooltip.toggle(this);
            }
            return this;
          },
          // @method isTooltipOpen(): boolean
          // Returns `true` if the tooltip bound to this layer is currently open.
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
          // Sets the content of the tooltip bound to this layer.
          setTooltipContent: function(content) {
            if (this._tooltip) {
              this._tooltip.setContent(content);
            }
            return this;
          },
          // @method getTooltip(): Tooltip
          // Returns the tooltip bound to this layer.
          getTooltip: function() {
            return this._tooltip;
          },
          _addFocusListeners: function() {
            if (this.getElement) {
              this._addFocusListenersOnLayer(this);
            } else if (this.eachLayer) {
              this.eachLayer(this._addFocusListenersOnLayer, this);
            }
          },
          _addFocusListenersOnLayer: function(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
              on(el, "focus", function() {
                this._tooltip._source = layer;
                this.openTooltip();
              }, this);
              on(el, "blur", this.closeTooltip, this);
            }
          },
          _setAriaDescribedByOnLayer: function(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
              el.setAttribute("aria-describedby", this._tooltip._container.id);
            }
          },
          _openTooltip: function(e) {
            if (!this._tooltip || !this._map) {
              return;
            }
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = true;
              var that = this;
              this._map.once("moveend", function() {
                that._openOnceFlag = false;
                that._openTooltip(e);
              });
              return;
            }
            this._tooltip._source = e.layer || e.target;
            this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
          },
          _moveTooltip: function(e) {
            var latlng = e.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e.originalEvent) {
              containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
              layerPoint = this._map.containerPointToLayerPoint(containerPoint);
              latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
          }
        });
        var DivIcon = Icon.extend({
          options: {
            // @section
            // @aka DivIcon options
            iconSize: [12, 12],
            // also can be set through CSS
            // iconAnchor: (Point),
            // popupAnchor: (Point),
            // @option html: String|HTMLElement = ''
            // Custom HTML code to put inside the div element, empty by default. Alternatively,
            // an instance of `HTMLElement`.
            html: false,
            // @option bgPos: Point = [0, 0]
            // Optional relative position of the background, in pixels
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html instanceof Element) {
              empty(div);
              div.appendChild(options.html);
            } else {
              div.innerHTML = options.html !== false ? options.html : "";
            }
            if (options.bgPos) {
              var bgPos = toPoint(options.bgPos);
              div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
          },
          createShadow: function() {
            return null;
          }
        });
        function divIcon(options) {
          return new DivIcon(options);
        }
        Icon.Default = IconDefault;
        var GridLayer = Layer.extend({
          // @section
          // @aka GridLayer options
          options: {
            // @option tileSize: Number|Point = 256
            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
            tileSize: 256,
            // @option opacity: Number = 1.0
            // Opacity of the tiles. Can be used in the `createTile()` function.
            opacity: 1,
            // @option updateWhenIdle: Boolean = (depends)
            // Load new tiles only when panning ends.
            // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
            // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
            // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
            updateWhenIdle: Browser.mobile,
            // @option updateWhenZooming: Boolean = true
            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
            updateWhenZooming: true,
            // @option updateInterval: Number = 200
            // Tiles will not update more than once every `updateInterval` milliseconds when panning.
            updateInterval: 200,
            // @option zIndex: Number = 1
            // The explicit zIndex of the tile layer.
            zIndex: 1,
            // @option bounds: LatLngBounds = undefined
            // If set, tiles will only be loaded inside the set `LatLngBounds`.
            bounds: null,
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = undefined
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: void 0,
            // @option maxNativeZoom: Number = undefined
            // Maximum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
            // from `maxNativeZoom` level and auto-scaled.
            maxNativeZoom: void 0,
            // @option minNativeZoom: Number = undefined
            // Minimum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
            // from `minNativeZoom` level and auto-scaled.
            minNativeZoom: void 0,
            // @option noWrap: Boolean = false
            // Whether the layer is wrapped around the antimeridian. If `true`, the
            // GridLayer will only be displayed once at low zoom levels. Has no
            // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
            // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
            // tiles outside the CRS limits.
            noWrap: false,
            // @option pane: String = 'tilePane'
            // `Map pane` where the grid layer will be added.
            pane: "tilePane",
            // @option className: String = ''
            // A custom class name to assign to the tile layer. Empty by default.
            className: "",
            // @option keepBuffer: Number = 2
            // When panning the map, keep this many rows and columns of tiles before unloading them.
            keepBuffer: 2
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          onAdd: function() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView();
          },
          beforeAdd: function(map2) {
            map2._addZoomLimit(this);
          },
          onRemove: function(map2) {
            this._removeAllTiles();
            remove(this._container);
            map2._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = void 0;
          },
          // @method bringToFront: this
          // Brings the tile layer to the top of all tile layers.
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
              this._setAutoZIndex(Math.max);
            }
            return this;
          },
          // @method bringToBack: this
          // Brings the tile layer to the bottom of all tile layers.
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
              this._setAutoZIndex(Math.min);
            }
            return this;
          },
          // @method getContainer: HTMLElement
          // Returns the HTML element that contains the tiles for this layer.
          getContainer: function() {
            return this._container;
          },
          // @method setOpacity(opacity: Number): this
          // Changes the [opacity](#gridlayer-opacity) of the grid layer.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
          },
          // @method setZIndex(zIndex: Number): this
          // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
          setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
          },
          // @method isLoading: Boolean
          // Returns `true` if any tile in the grid layer has not finished loading.
          isLoading: function() {
            return this._loading;
          },
          // @method redraw: this
          // Causes the layer to clear all the tiles and request them again.
          redraw: function() {
            if (this._map) {
              this._removeAllTiles();
              var tileZoom = this._clampZoom(this._map.getZoom());
              if (tileZoom !== this._tileZoom) {
                this._tileZoom = tileZoom;
                this._updateLevels();
              }
              this._update();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
              if (!this._onMove) {
                this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
              }
              events.move = this._onMove;
            }
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @section Extension methods
          // Layers extending `GridLayer` shall reimplement the following method.
          // @method createTile(coords: Object, done?: Function): HTMLElement
          // Called only internally, must be overridden by classes extending `GridLayer`.
          // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
          // is specified, it must be called when the tile has finished loading and drawing.
          createTile: function() {
            return document.createElement("div");
          },
          // @section
          // @method getTileSize: Point
          // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
          getTileSize: function() {
            var s = this.options.tileSize;
            return s instanceof Point ? s : new Point(s, s);
          },
          _updateZIndex: function() {
            if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._container.style.zIndex = this.options.zIndex;
            }
          },
          _setAutoZIndex: function(compare) {
            var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
            for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
              zIndex = layers2[i].style.zIndex;
              if (layers2[i] !== this._container && zIndex) {
                edgeZIndex = compare(edgeZIndex, +zIndex);
              }
            }
            if (isFinite(edgeZIndex)) {
              this.options.zIndex = edgeZIndex + compare(-1, 1);
              this._updateZIndex();
            }
          },
          _updateOpacity: function() {
            if (!this._map) {
              return;
            }
            if (Browser.ielt9) {
              return;
            }
            setOpacity(this._container, this.options.opacity);
            var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
            for (var key in this._tiles) {
              var tile = this._tiles[key];
              if (!tile.current || !tile.loaded) {
                continue;
              }
              var fade = Math.min(1, (now - tile.loaded) / 200);
              setOpacity(tile.el, fade);
              if (fade < 1) {
                nextFrame = true;
              } else {
                if (tile.active) {
                  willPrune = true;
                } else {
                  this._onOpaqueTile(tile);
                }
                tile.active = true;
              }
            }
            if (willPrune && !this._noPrune) {
              this._pruneTiles();
            }
            if (nextFrame) {
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            }
          },
          _onOpaqueTile: falseFn,
          _initContainer: function() {
            if (this._container) {
              return;
            }
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
            this.getPane().appendChild(this._container);
          },
          _updateLevels: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom2 === void 0) {
              return void 0;
            }
            for (var z in this._levels) {
              z = Number(z);
              if (this._levels[z].el.children.length || z === zoom2) {
                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
                this._onUpdateLevel(z);
              } else {
                remove(this._levels[z].el);
                this._removeTilesAtZoom(z);
                this._onRemoveLevel(z);
                delete this._levels[z];
              }
            }
            var level = this._levels[zoom2], map2 = this._map;
            if (!level) {
              level = this._levels[zoom2] = {};
              level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
              level.el.style.zIndex = maxZoom;
              level.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
              level.zoom = zoom2;
              this._setZoomTransform(level, map2.getCenter(), map2.getZoom());
              falseFn(level.el.offsetWidth);
              this._onCreateLevel(level);
            }
            this._level = level;
            return level;
          },
          _onUpdateLevel: falseFn,
          _onRemoveLevel: falseFn,
          _onCreateLevel: falseFn,
          _pruneTiles: function() {
            if (!this._map) {
              return;
            }
            var key, tile;
            var zoom2 = this._map.getZoom();
            if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              tile.retain = tile.current;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              if (tile.current && !tile.active) {
                var coords = tile.coords;
                if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                  this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                }
              }
            }
            for (key in this._tiles) {
              if (!this._tiles[key].retain) {
                this._removeTile(key);
              }
            }
          },
          _removeTilesAtZoom: function(zoom2) {
            for (var key in this._tiles) {
              if (this._tiles[key].coords.z !== zoom2) {
                continue;
              }
              this._removeTile(key);
            }
          },
          _removeAllTiles: function() {
            for (var key in this._tiles) {
              this._removeTile(key);
            }
          },
          _invalidateAll: function() {
            for (var z in this._levels) {
              remove(this._levels[z].el);
              this._onRemoveLevel(Number(z));
              delete this._levels[z];
            }
            this._removeAllTiles();
            this._tileZoom = void 0;
          },
          _retainParent: function(x, y, z, minZoom) {
            var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
            coords2.z = +z2;
            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              return true;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z2 > minZoom) {
              return this._retainParent(x2, y2, z2, minZoom);
            }
            return false;
          },
          _retainChildren: function(x, y, z, maxZoom) {
            for (var i = 2 * x; i < 2 * x + 2; i++) {
              for (var j = 2 * y; j < 2 * y + 2; j++) {
                var coords = new Point(i, j);
                coords.z = z + 1;
                var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                if (tile && tile.active) {
                  tile.retain = true;
                  continue;
                } else if (tile && tile.loaded) {
                  tile.retain = true;
                }
                if (z + 1 < maxZoom) {
                  this._retainChildren(i, j, z + 1, maxZoom);
                }
              }
            }
          },
          _resetView: function(e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
          },
          _animateZoom: function(e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
          },
          _clampZoom: function(zoom2) {
            var options = this.options;
            if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
              return options.minNativeZoom;
            }
            if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
              return options.maxNativeZoom;
            }
            return zoom2;
          },
          _setView: function(center, zoom2, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom2);
            if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
              tileZoom = void 0;
            } else {
              tileZoom = this._clampZoom(tileZoom);
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
              this._tileZoom = tileZoom;
              if (this._abortLoading) {
                this._abortLoading();
              }
              this._updateLevels();
              this._resetGrid();
              if (tileZoom !== void 0) {
                this._update(center);
              }
              if (!noPrune) {
                this._pruneTiles();
              }
              this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center, zoom2);
          },
          _setZoomTransforms: function(center, zoom2) {
            for (var i in this._levels) {
              this._setZoomTransform(this._levels[i], center, zoom2);
            }
          },
          _setZoomTransform: function(level, center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
            if (Browser.any3d) {
              setTransform(level.el, translate, scale2);
            } else {
              setPosition(level.el, translate);
            }
          },
          _resetGrid: function() {
            var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) {
              this._globalTileRange = this._pxBoundsToTileRange(bounds);
            }
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
              Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
              Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
              Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
              Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
            ];
          },
          _onMoveEnd: function() {
            if (!this._map || this._map._animatingZoom) {
              return;
            }
            this._update();
          },
          _getTiledPixelBounds: function(center) {
            var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale2 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale2 * 2);
            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
          },
          // Private method to load tiles in the grid's active zoom level according to map bounds
          _update: function(center) {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var zoom2 = this._clampZoom(map2.getZoom());
            if (center === void 0) {
              center = map2.getCenter();
            }
            if (this._tileZoom === void 0) {
              return;
            }
            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
              tileRange.getBottomLeft().subtract([margin, -margin]),
              tileRange.getTopRight().add([margin, -margin])
            );
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
              throw new Error("Attempted to load an infinite number of tiles");
            }
            for (var key in this._tiles) {
              var c = this._tiles[key].coords;
              if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
                this._tiles[key].current = false;
              }
            }
            if (Math.abs(zoom2 - this._tileZoom) > 1) {
              this._setView(center, zoom2);
              return;
            }
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
              for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                var coords = new Point(i, j);
                coords.z = this._tileZoom;
                if (!this._isValidTile(coords)) {
                  continue;
                }
                var tile = this._tiles[this._tileCoordsToKey(coords)];
                if (tile) {
                  tile.current = true;
                } else {
                  queue.push(coords);
                }
              }
            }
            queue.sort(function(a, b) {
              return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
              if (!this._loading) {
                this._loading = true;
                this.fire("loading");
              }
              var fragment = document.createDocumentFragment();
              for (i = 0; i < queue.length; i++) {
                this._addTile(queue[i], fragment);
              }
              this._level.el.appendChild(fragment);
            }
          },
          _isValidTile: function(coords) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
              var bounds = this._globalTileRange;
              if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
                return false;
              }
            }
            if (!this.options.bounds) {
              return true;
            }
            var tileBounds = this._tileCoordsToBounds(coords);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
          },
          _keyToBounds: function(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
          },
          _tileCoordsToNwSe: function(coords) {
            var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords.z), se = map2.unproject(sePoint, coords.z);
            return [nw, se];
          },
          // converts tile coordinates to its geographical bounds
          _tileCoordsToBounds: function(coords) {
            var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
            if (!this.options.noWrap) {
              bounds = this._map.wrapLatLngBounds(bounds);
            }
            return bounds;
          },
          // converts tile coordinates to key for the tile cache
          _tileCoordsToKey: function(coords) {
            return coords.x + ":" + coords.y + ":" + coords.z;
          },
          // converts tile cache key to coordinates
          _keyToTileCoords: function(key) {
            var k = key.split(":"), coords = new Point(+k[0], +k[1]);
            coords.z = +k[2];
            return coords;
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            remove(tile.el);
            delete this._tiles[key];
            this.fire("tileunload", {
              tile: tile.el,
              coords: this._keyToTileCoords(key)
            });
          },
          _initTile: function(tile) {
            addClass(tile, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + "px";
            tile.style.height = tileSize.y + "px";
            tile.onselectstart = falseFn;
            tile.onmousemove = falseFn;
            if (Browser.ielt9 && this.options.opacity < 1) {
              setOpacity(tile, this.options.opacity);
            }
          },
          _addTile: function(coords, container) {
            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
            this._initTile(tile);
            if (this.createTile.length < 2) {
              requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
            }
            setPosition(tile, tilePos);
            this._tiles[key] = {
              el: tile,
              coords,
              current: true
            };
            container.appendChild(tile);
            this.fire("tileloadstart", {
              tile,
              coords
            });
          },
          _tileReady: function(coords, err, tile) {
            if (err) {
              this.fire("tileerror", {
                error: err,
                tile,
                coords
              });
            }
            var key = this._tileCoordsToKey(coords);
            tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.loaded = +/* @__PURE__ */ new Date();
            if (this._map._fadeAnimated) {
              setOpacity(tile.el, 0);
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            } else {
              tile.active = true;
              this._pruneTiles();
            }
            if (!err) {
              addClass(tile.el, "leaflet-tile-loaded");
              this.fire("tileload", {
                tile: tile.el,
                coords
              });
            }
            if (this._noTilesToLoad()) {
              this._loading = false;
              this.fire("load");
              if (Browser.ielt9 || !this._map._fadeAnimated) {
                requestAnimFrame(this._pruneTiles, this);
              } else {
                setTimeout(bind(this._pruneTiles, this), 250);
              }
            }
          },
          _getTilePos: function(coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(coords) {
            var newCoords = new Point(
              this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
              this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
            );
            newCoords.z = coords.z;
            return newCoords;
          },
          _pxBoundsToTileRange: function(bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(
              bounds.min.unscaleBy(tileSize).floor(),
              bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
            );
          },
          _noTilesToLoad: function() {
            for (var key in this._tiles) {
              if (!this._tiles[key].loaded) {
                return false;
              }
            }
            return true;
          }
        });
        function gridLayer(options) {
          return new GridLayer(options);
        }
        var TileLayer = GridLayer.extend({
          // @section
          // @aka TileLayer options
          options: {
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = 18
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: 18,
            // @option subdomains: String|String[] = 'abc'
            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
            subdomains: "abc",
            // @option errorTileUrl: String = ''
            // URL to the tile image to show in place of the tile that failed to load.
            errorTileUrl: "",
            // @option zoomOffset: Number = 0
            // The zoom number used in tile URLs will be offset with this value.
            zoomOffset: 0,
            // @option tms: Boolean = false
            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
            tms: false,
            // @option zoomReverse: Boolean = false
            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
            zoomReverse: false,
            // @option detectRetina: Boolean = false
            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
            detectRetina: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option referrerPolicy: Boolean|String = false
            // Whether the referrerPolicy attribute will be added to the tiles.
            // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
            // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
            // (e.g. to validate an API token).
            // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
            referrerPolicy: false
          },
          initialize: function(url, options) {
            this._url = url;
            options = setOptions(this, options);
            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
              options.tileSize = Math.floor(options.tileSize / 2);
              if (!options.zoomReverse) {
                options.zoomOffset++;
                options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
              } else {
                options.zoomOffset--;
                options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
              }
              options.minZoom = Math.max(0, options.minZoom);
            } else if (!options.zoomReverse) {
              options.maxZoom = Math.max(options.minZoom, options.maxZoom);
            } else {
              options.minZoom = Math.min(options.maxZoom, options.minZoom);
            }
            if (typeof options.subdomains === "string") {
              options.subdomains = options.subdomains.split("");
            }
            this.on("tileunload", this._onTileRemove);
          },
          // @method setUrl(url: String, noRedraw?: Boolean): this
          // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
          // If the URL does not change, the layer will not be redrawn unless
          // the noRedraw parameter is set to false.
          setUrl: function(url, noRedraw) {
            if (this._url === url && noRedraw === void 0) {
              noRedraw = true;
            }
            this._url = url;
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          },
          // @method createTile(coords: Object, done?: Function): HTMLElement
          // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
          // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
          // callback is called when the tile has been loaded.
          createTile: function(coords, done) {
            var tile = document.createElement("img");
            on(tile, "load", bind(this._tileOnLoad, this, done, tile));
            on(tile, "error", bind(this._tileOnError, this, done, tile));
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (typeof this.options.referrerPolicy === "string") {
              tile.referrerPolicy = this.options.referrerPolicy;
            }
            tile.alt = "";
            tile.src = this.getTileUrl(coords);
            return tile;
          },
          // @section Extension methods
          // @uninheritable
          // Layers extending `TileLayer` might reimplement the following method.
          // @method getTileUrl(coords: Object): String
          // Called only internally, returns the URL for a tile given its coordinates.
          // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
          getTileUrl: function(coords) {
            var data = {
              r: Browser.retina ? "@2x" : "",
              s: this._getSubdomain(coords),
              x: coords.x,
              y: coords.y,
              z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
              var invertedY = this._globalTileRange.max.y - coords.y;
              if (this.options.tms) {
                data["y"] = invertedY;
              }
              data["-y"] = invertedY;
            }
            return template(this._url, extend(data, this.options));
          },
          _tileOnLoad: function(done, tile) {
            if (Browser.ielt9) {
              setTimeout(bind(done, this, null, tile), 0);
            } else {
              done(null, tile);
            }
          },
          _tileOnError: function(done, tile, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile.getAttribute("src") !== errorUrl) {
              tile.src = errorUrl;
            }
            done(e, tile);
          },
          _onTileRemove: function(e) {
            e.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) {
              zoom2 = maxZoom - zoom2;
            }
            return zoom2 + zoomOffset;
          },
          _getSubdomain: function(tilePoint) {
            var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index2];
          },
          // stops loading all tiles in the background layer
          _abortLoading: function() {
            var i, tile;
            for (i in this._tiles) {
              if (this._tiles[i].coords.z !== this._tileZoom) {
                tile = this._tiles[i].el;
                tile.onload = falseFn;
                tile.onerror = falseFn;
                if (!tile.complete) {
                  tile.src = emptyImageUrl;
                  var coords = this._tiles[i].coords;
                  remove(tile);
                  delete this._tiles[i];
                  this.fire("tileabort", {
                    tile,
                    coords
                  });
                }
              }
            }
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.el.setAttribute("src", emptyImageUrl);
            return GridLayer.prototype._removeTile.call(this, key);
          },
          _tileReady: function(coords, err, tile) {
            if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
              return;
            }
            return GridLayer.prototype._tileReady.call(this, coords, err, tile);
          }
        });
        function tileLayer(url, options) {
          return new TileLayer(url, options);
        }
        var TileLayerWMS = TileLayer.extend({
          // @section
          // @aka TileLayer.WMS options
          // If any custom options not documented here are used, they will be sent to the
          // WMS server as extra parameters in each request URL. This can be useful for
          // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            // @option layers: String = ''
            // **(required)** Comma-separated list of WMS layers to show.
            layers: "",
            // @option styles: String = ''
            // Comma-separated list of WMS styles.
            styles: "",
            // @option format: String = 'image/jpeg'
            // WMS image format (use `'image/png'` for layers with transparency).
            format: "image/jpeg",
            // @option transparent: Boolean = false
            // If `true`, the WMS service will return images with transparency.
            transparent: false,
            // @option version: String = '1.1.1'
            // Version of the WMS service to use
            version: "1.1.1"
          },
          options: {
            // @option crs: CRS = null
            // Coordinate Reference System to use for the WMS requests, defaults to
            // map CRS. Don't change this if you're not sure what it means.
            crs: null,
            // @option uppercase: Boolean = false
            // If `true`, WMS request parameter keys will be uppercase.
            uppercase: false
          },
          initialize: function(url, options) {
            this._url = url;
            var wmsParams = extend({}, this.defaultWmsParams);
            for (var i in options) {
              if (!(i in this.options)) {
                wmsParams[i] = options[i];
              }
            }
            options = setOptions(this, options);
            var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
          },
          onAdd: function(map2) {
            this._crs = this.options.crs || map2.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer.prototype.onAdd.call(this, map2);
          },
          getTileUrl: function(coords) {
            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
          },
          // @method setParams(params: Object, noRedraw?: Boolean): this
          // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
          setParams: function(params, noRedraw) {
            extend(this.wmsParams, params);
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          }
        });
        function tileLayerWMS(url, options) {
          return new TileLayerWMS(url, options);
        }
        TileLayer.WMS = TileLayerWMS;
        tileLayer.wms = tileLayerWMS;
        var Renderer = Layer.extend({
          // @section
          // @aka Renderer options
          options: {
            // @option padding: Number = 0.1
            // How much to extend the clip area around the map view (relative to its size)
            // e.g. 0.1 would be 10% of map view in each direction
            padding: 0.1
          },
          initialize: function(options) {
            setOptions(this, options);
            stamp(this);
            this._layers = this._layers || {};
          },
          onAdd: function() {
            if (!this._container) {
              this._initContainer();
              addClass(this._container, "leaflet-zoom-animated");
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
          },
          getEvents: function() {
            var events = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._onAnimZoom;
            }
            return events;
          },
          _onAnimZoom: function(ev) {
            this._updateTransform(ev.center, ev.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
            if (Browser.any3d) {
              setTransform(this._container, topLeftOffset, scale2);
            } else {
              setPosition(this._container, topLeftOffset);
            }
          },
          _reset: function() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for (var id in this._layers) {
              this._layers[id]._reset();
            }
          },
          _onZoomEnd: function() {
            for (var id in this._layers) {
              this._layers[id]._project();
            }
          },
          _updatePaths: function() {
            for (var id in this._layers) {
              this._layers[id]._update();
            }
          },
          _update: function() {
            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
            this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
          }
        });
        var Canvas = Renderer.extend({
          // @section
          // @aka Canvas options
          options: {
            // @option tolerance: Number = 0
            // How much to extend the click tolerance around a path/object on the map.
            tolerance: 0
          },
          getEvents: function() {
            var events = Renderer.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Renderer.prototype.onAdd.call(this);
            this._draw();
          },
          _initContainer: function() {
            var container = this._container = document.createElement("canvas");
            on(container, "mousemove", this._onMouseMove, this);
            on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on(container, "mouseout", this._handleMouseOut, this);
            container["_leaflet_disable_events"] = true;
            this._ctx = container.getContext("2d");
          },
          _destroyContainer: function() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off(this._container);
            delete this._container;
          },
          _updatePaths: function() {
            if (this._postponeUpdatePaths) {
              return;
            }
            var layer;
            this._redrawBounds = null;
            for (var id in this._layers) {
              layer = this._layers[id];
              layer._update();
            }
            this._redraw();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
            setPosition(container, b.min);
            container.width = m * size.x;
            container.height = m * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (Browser.retina) {
              this._ctx.scale(2, 2);
            }
            this._ctx.translate(-b.min.x, -b.min.y);
            this.fire("update");
          },
          _reset: function() {
            Renderer.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
              this._postponeUpdatePaths = false;
              this._updatePaths();
            }
          },
          _initPath: function(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
              layer,
              prev: this._drawLast,
              next: null
            };
            if (this._drawLast) {
              this._drawLast.next = order;
            }
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(layer) {
            this._requestRedraw(layer);
          },
          _removePath: function(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              this._drawLast = prev;
            }
            if (prev) {
              prev.next = next;
            } else {
              this._drawFirst = next;
            }
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
          },
          _updatePath: function(layer) {
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            this._requestRedraw(layer);
          },
          _updateStyle: function(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
          },
          _updateDashArray: function(layer) {
            if (typeof layer.options.dashArray === "string") {
              var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
              for (i = 0; i < parts.length; i++) {
                dashValue = Number(parts[i]);
                if (isNaN(dashValue)) {
                  return;
                }
                dashArray.push(dashValue);
              }
              layer.options._dashArray = dashArray;
            } else {
              layer.options._dashArray = layer.options.dashArray;
            }
          },
          _requestRedraw: function(layer) {
            if (!this._map) {
              return;
            }
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
          },
          _extendRedrawBounds: function(layer) {
            if (layer._pxBounds) {
              var padding = (layer.options.weight || 0) + 1;
              this._redrawBounds = this._redrawBounds || new Bounds();
              this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
              this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
            }
          },
          _redraw: function() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
              this._redrawBounds.min._floor();
              this._redrawBounds.max._ceil();
            }
            this._clear();
            this._draw();
            this._redrawBounds = null;
          },
          _clear: function() {
            var bounds = this._redrawBounds;
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
            } else {
              this._ctx.save();
              this._ctx.setTransform(1, 0, 0, 1, 0, 0);
              this._ctx.clearRect(0, 0, this._container.width, this._container.height);
              this._ctx.restore();
            }
          },
          _draw: function() {
            var layer, bounds = this._redrawBounds;
            this._ctx.save();
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.beginPath();
              this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
              this._ctx.clip();
            }
            this._drawing = true;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
                layer._updatePath();
              }
            }
            this._drawing = false;
            this._ctx.restore();
          },
          _updatePoly: function(layer, closed) {
            if (!this._drawing) {
              return;
            }
            var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) {
              return;
            }
            ctx.beginPath();
            for (i = 0; i < len; i++) {
              for (j = 0, len2 = parts[i].length; j < len2; j++) {
                p = parts[i][j];
                ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
              }
              if (closed) {
                ctx.closePath();
              }
            }
            this._fillStroke(ctx, layer);
          },
          _updateCircle: function(layer) {
            if (!this._drawing || layer._empty()) {
              return;
            }
            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
            if (s !== 1) {
              ctx.save();
              ctx.scale(1, s);
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
            if (s !== 1) {
              ctx.restore();
            }
            this._fillStroke(ctx, layer);
          },
          _fillStroke: function(ctx, layer) {
            var options = layer.options;
            if (options.fill) {
              ctx.globalAlpha = options.fillOpacity;
              ctx.fillStyle = options.fillColor || options.color;
              ctx.fill(options.fillRule || "evenodd");
            }
            if (options.stroke && options.weight !== 0) {
              if (ctx.setLineDash) {
                ctx.setLineDash(layer.options && layer.options._dashArray || []);
              }
              ctx.globalAlpha = options.opacity;
              ctx.lineWidth = options.weight;
              ctx.strokeStyle = options.color;
              ctx.lineCap = options.lineCap;
              ctx.lineJoin = options.lineJoin;
              ctx.stroke();
            }
          },
          // Canvas obviously doesn't have mouse events for individual drawn objects,
          // so we emulate that by calculating what's under the mouse on mousemove/click manually
          _onClick: function(e) {
            var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point)) {
                if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                  clickedLayer = layer;
                }
              }
            }
            this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
          },
          _onMouseMove: function(e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
              return;
            }
            var point = this._map.mouseEventToLayerPoint(e);
            this._handleMouseHover(e, point);
          },
          _handleMouseOut: function(e) {
            var layer = this._hoveredLayer;
            if (layer) {
              removeClass(this._container, "leaflet-interactive");
              this._fireEvent([layer], e, "mouseout");
              this._hoveredLayer = null;
              this._mouseHoverThrottled = false;
            }
          },
          _handleMouseHover: function(e, point) {
            if (this._mouseHoverThrottled) {
              return;
            }
            var layer, candidateHoveredLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point)) {
                candidateHoveredLayer = layer;
              }
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
              this._handleMouseOut(e);
              if (candidateHoveredLayer) {
                addClass(this._container, "leaflet-interactive");
                this._fireEvent([candidateHoveredLayer], e, "mouseover");
                this._hoveredLayer = candidateHoveredLayer;
              }
            }
            this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
              this._mouseHoverThrottled = false;
            }, this), 32);
          },
          _fireEvent: function(layers2, e, type) {
            this._map._fireDOMEvent(e, type || e.type, layers2);
          },
          _bringToFront: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              return;
            }
            if (prev) {
              prev.next = next;
            } else if (next) {
              this._drawFirst = next;
            }
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
          },
          _bringToBack: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (prev) {
              prev.next = next;
            } else {
              return;
            }
            if (next) {
              next.prev = prev;
            } else if (prev) {
              this._drawLast = prev;
            }
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
          }
        });
        function canvas(options) {
          return Browser.canvas ? new Canvas(options) : null;
        }
        var vmlCreate = function() {
          try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
              return document.createElement("<lvml:" + name + ' class="lvml">');
            };
          } catch (e) {
          }
          return function(name) {
            return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
          };
        }();
        var vmlMixin = {
          _initContainer: function() {
            this._container = create$1("div", "leaflet-vml-container");
          },
          _update: function() {
            if (this._map._animatingZoom) {
              return;
            }
            Renderer.prototype._update.call(this);
            this.fire("update");
          },
          _initPath: function(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) {
              layer.addInteractiveTarget(container);
            }
          },
          _removePath: function(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
          },
          _updateStyle: function(layer) {
            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
            container.stroked = !!options.stroke;
            container.filled = !!options.fill;
            if (options.stroke) {
              if (!stroke) {
                stroke = layer._stroke = vmlCreate("stroke");
              }
              container.appendChild(stroke);
              stroke.weight = options.weight + "px";
              stroke.color = options.color;
              stroke.opacity = options.opacity;
              if (options.dashArray) {
                stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
              } else {
                stroke.dashStyle = "";
              }
              stroke.endcap = options.lineCap.replace("butt", "flat");
              stroke.joinstyle = options.lineJoin;
            } else if (stroke) {
              container.removeChild(stroke);
              layer._stroke = null;
            }
            if (options.fill) {
              if (!fill) {
                fill = layer._fill = vmlCreate("fill");
              }
              container.appendChild(fill);
              fill.color = options.fillColor || options.color;
              fill.opacity = options.fillOpacity;
            } else if (fill) {
              container.removeChild(fill);
              layer._fill = null;
            }
          },
          _updateCircle: function(layer) {
            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
          },
          _setPath: function(layer, path) {
            layer._path.v = path;
          },
          _bringToFront: function(layer) {
            toFront(layer._container);
          },
          _bringToBack: function(layer) {
            toBack(layer._container);
          }
        };
        var create = Browser.vml ? vmlCreate : svgCreate;
        var SVG = Renderer.extend({
          _initContainer: function() {
            this._container = create("svg");
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create("g");
            this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            remove(this._container);
            off(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, size = b.getSize(), container = this._container;
            if (!this._svgSize || !this._svgSize.equals(size)) {
              this._svgSize = size;
              container.setAttribute("width", size.x);
              container.setAttribute("height", size.y);
            }
            setPosition(container, b.min);
            container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
            this.fire("update");
          },
          // methods below are called by vector layers implementations
          _initPath: function(layer) {
            var path = layer._path = create("path");
            if (layer.options.className) {
              addClass(path, layer.options.className);
            }
            if (layer.options.interactive) {
              addClass(path, "leaflet-interactive");
            }
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            if (!this._rootGroup) {
              this._initContainer();
            }
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
          },
          _removePath: function(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
          },
          _updatePath: function(layer) {
            layer._project();
            layer._update();
          },
          _updateStyle: function(layer) {
            var path = layer._path, options = layer.options;
            if (!path) {
              return;
            }
            if (options.stroke) {
              path.setAttribute("stroke", options.color);
              path.setAttribute("stroke-opacity", options.opacity);
              path.setAttribute("stroke-width", options.weight);
              path.setAttribute("stroke-linecap", options.lineCap);
              path.setAttribute("stroke-linejoin", options.lineJoin);
              if (options.dashArray) {
                path.setAttribute("stroke-dasharray", options.dashArray);
              } else {
                path.removeAttribute("stroke-dasharray");
              }
              if (options.dashOffset) {
                path.setAttribute("stroke-dashoffset", options.dashOffset);
              } else {
                path.removeAttribute("stroke-dashoffset");
              }
            } else {
              path.setAttribute("stroke", "none");
            }
            if (options.fill) {
              path.setAttribute("fill", options.fillColor || options.color);
              path.setAttribute("fill-opacity", options.fillOpacity);
              path.setAttribute("fill-rule", options.fillRule || "evenodd");
            } else {
              path.setAttribute("fill", "none");
            }
          },
          _updatePoly: function(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
          },
          _updateCircle: function(layer) {
            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
            var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
            this._setPath(layer, d);
          },
          _setPath: function(layer, path) {
            layer._path.setAttribute("d", path);
          },
          // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
          _bringToFront: function(layer) {
            toFront(layer._path);
          },
          _bringToBack: function(layer) {
            toBack(layer._path);
          }
        });
        if (Browser.vml) {
          SVG.include(vmlMixin);
        }
        function svg(options) {
          return Browser.svg || Browser.vml ? new SVG(options) : null;
        }
        Map.include({
          // @namespace Map; @method getRenderer(layer: Path): Renderer
          // Returns the instance of `Renderer` that should be used to render the given
          // `Path`. It will ensure that the `renderer` options of the map and paths
          // are respected, and that the renderers do exist on the map.
          getRenderer: function(layer) {
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) {
              renderer = this._renderer = this._createRenderer();
            }
            if (!this.hasLayer(renderer)) {
              this.addLayer(renderer);
            }
            return renderer;
          },
          _getPaneRenderer: function(name) {
            if (name === "overlayPane" || name === void 0) {
              return false;
            }
            var renderer = this._paneRenderers[name];
            if (renderer === void 0) {
              renderer = this._createRenderer({ pane: name });
              this._paneRenderers[name] = renderer;
            }
            return renderer;
          },
          _createRenderer: function(options) {
            return this.options.preferCanvas && canvas(options) || svg(options);
          }
        });
        var Rectangle = Polygon.extend({
          initialize: function(latLngBounds, options) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
          },
          // @method setBounds(latLngBounds: LatLngBounds): this
          // Redraws the rectangle with the passed bounds.
          setBounds: function(latLngBounds) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
          },
          _boundsToLatLngs: function(latLngBounds) {
            latLngBounds = toLatLngBounds(latLngBounds);
            return [
              latLngBounds.getSouthWest(),
              latLngBounds.getNorthWest(),
              latLngBounds.getNorthEast(),
              latLngBounds.getSouthEast()
            ];
          }
        });
        function rectangle(latLngBounds, options) {
          return new Rectangle(latLngBounds, options);
        }
        SVG.create = create;
        SVG.pointsToPath = pointsToPath;
        GeoJSON.geometryToLayer = geometryToLayer;
        GeoJSON.coordsToLatLng = coordsToLatLng;
        GeoJSON.coordsToLatLngs = coordsToLatLngs;
        GeoJSON.latLngToCoords = latLngToCoords;
        GeoJSON.latLngsToCoords = latLngsToCoords;
        GeoJSON.getFeature = getFeature;
        GeoJSON.asFeature = asFeature;
        Map.mergeOptions({
          // @option boxZoom: Boolean = true
          // Whether the map can be zoomed to a rectangular area specified by
          // dragging the mouse while pressing the shift key.
          boxZoom: true
        });
        var BoxZoom = Handler.extend({
          initialize: function(map2) {
            this._map = map2;
            this._container = map2._container;
            this._pane = map2._panes.overlayPane;
            this._resetStateTimeout = 0;
            map2.on("unload", this._destroy, this);
          },
          addHooks: function() {
            on(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            off(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            remove(this._pane);
            delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0;
            this._moved = false;
          },
          _clearDeferredResetState: function() {
            if (this._resetStateTimeout !== 0) {
              clearTimeout(this._resetStateTimeout);
              this._resetStateTimeout = 0;
            }
          },
          _onMouseDown: function(e) {
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
              return false;
            }
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e);
            on(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(e) {
            if (!this._moved) {
              this._moved = true;
              this._box = create$1("div", "leaflet-zoom-box", this._container);
              addClass(this._container, "leaflet-crosshair");
              this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e);
            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
            setPosition(this._box, bounds.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
          },
          _finish: function() {
            if (this._moved) {
              remove(this._box);
              removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseUp: function(e) {
            if (e.which !== 1 && e.button !== 1) {
              return;
            }
            this._finish();
            if (!this._moved) {
              return;
            }
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds = new LatLngBounds(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
          },
          _onKeyDown: function(e) {
            if (e.keyCode === 27) {
              this._finish();
              this._clearDeferredResetState();
              this._resetState();
            }
          }
        });
        Map.addInitHook("addHandler", "boxZoom", BoxZoom);
        Map.mergeOptions({
          // @option doubleClickZoom: Boolean|String = true
          // Whether the map can be zoomed in by double clicking on it and
          // zoomed out by double clicking while holding shift. If passed
          // `'center'`, double-click zoom will zoom to the center of the
          //  view regardless of where the mouse was.
          doubleClickZoom: true
        });
        var DoubleClickZoom = Handler.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(e) {
            var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map2.options.doubleClickZoom === "center") {
              map2.setZoom(zoom2);
            } else {
              map2.setZoomAround(e.containerPoint, zoom2);
            }
          }
        });
        Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
        Map.mergeOptions({
          // @option dragging: Boolean = true
          // Whether the map is draggable with mouse/touch or not.
          dragging: true,
          // @section Panning Inertia Options
          // @option inertia: Boolean = *
          // If enabled, panning of the map will have an inertia effect where
          // the map builds momentum while dragging and continues moving in
          // the same direction for some time. Feels especially nice on touch
          // devices. Enabled by default.
          inertia: true,
          // @option inertiaDeceleration: Number = 3000
          // The rate with which the inertial movement slows down, in pixels/second.
          inertiaDeceleration: 3400,
          // px/s^2
          // @option inertiaMaxSpeed: Number = Infinity
          // Max speed of the inertial movement, in pixels/second.
          inertiaMaxSpeed: Infinity,
          // px/s
          // @option easeLinearity: Number = 0.2
          easeLinearity: 0.2,
          // TODO refactor, move to CRS
          // @option worldCopyJump: Boolean = false
          // With this option enabled, the map tracks when you pan to another "copy"
          // of the world and seamlessly jumps to the original one so that all overlays
          // like markers and vector layers are still visible.
          worldCopyJump: false,
          // @option maxBoundsViscosity: Number = 0.0
          // If `maxBounds` is set, this option will control how solid the bounds
          // are when dragging the map around. The default value of `0.0` allows the
          // user to drag outside the bounds at normal speed, higher values will
          // slow down map dragging outside bounds, and `1.0` makes the bounds fully
          // solid, preventing the user from dragging outside the bounds.
          maxBoundsViscosity: 0
        });
        var Drag = Handler.extend({
          addHooks: function() {
            if (!this._draggable) {
              var map2 = this._map;
              this._draggable = new Draggable(map2._mapPane, map2._container);
              this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
              }, this);
              this._draggable.on("predrag", this._onPreDragLimit, this);
              if (map2.options.worldCopyJump) {
                this._draggable.on("predrag", this._onPreDragWrap, this);
                map2.on("zoomend", this._onZoomEnd, this);
                map2.whenReady(this._onZoomEnd, this);
              }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var map2 = this._map;
            map2._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
              var bounds = toLatLngBounds(this._map.options.maxBounds);
              this._offsetLimit = toBounds(
                this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
                this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
              );
              this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
            } else {
              this._offsetLimit = null;
            }
            map2.fire("movestart").fire("dragstart");
            if (map2.options.inertia) {
              this._positions = [];
              this._times = [];
            }
          },
          _onDrag: function(e) {
            if (this._map.options.inertia) {
              var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
              this._positions.push(pos);
              this._times.push(time);
              this._prunePositions(time);
            }
            this._map.fire("move", e).fire("drag", e);
          },
          _prunePositions: function(time) {
            while (this._positions.length > 1 && time - this._times[0] > 50) {
              this._positions.shift();
              this._times.shift();
            }
          },
          _onZoomEnd: function() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(value, threshold) {
            return value - (value - threshold) * this._viscosity;
          },
          _onPreDragLimit: function() {
            if (!this._viscosity || !this._offsetLimit) {
              return;
            }
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) {
              offset.x = this._viscousLimit(offset.x, limit.min.x);
            }
            if (offset.y < limit.min.y) {
              offset.y = this._viscousLimit(offset.y, limit.min.y);
            }
            if (offset.x > limit.max.x) {
              offset.x = this._viscousLimit(offset.x, limit.max.x);
            }
            if (offset.y > limit.max.y) {
              offset.y = this._viscousLimit(offset.y, limit.max.y);
            }
            this._draggable._newPos = this._draggable._startPos.add(offset);
          },
          _onPreDragWrap: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
          },
          _onDragEnd: function(e) {
            var map2 = this._map, options = map2.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
            map2.fire("dragend", e);
            if (noInertia) {
              map2.fire("moveend");
            } else {
              this._prunePositions(+/* @__PURE__ */ new Date());
              var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
              if (!offset.x && !offset.y) {
                map2.fire("moveend");
              } else {
                offset = map2._limitOffset(offset, map2.options.maxBounds);
                requestAnimFrame(function() {
                  map2.panBy(offset, {
                    duration: decelerationDuration,
                    easeLinearity: ease,
                    noMoveStart: true,
                    animate: true
                  });
                });
              }
            }
          }
        });
        Map.addInitHook("addHandler", "dragging", Drag);
        Map.mergeOptions({
          // @option keyboard: Boolean = true
          // Makes the map focusable and allows users to navigate the map with keyboard
          // arrows and `+`/`-` keys.
          keyboard: true,
          // @option keyboardPanDelta: Number = 80
          // Amount of pixels to pan when pressing an arrow key.
          keyboardPanDelta: 80
        });
        var Keyboard = Handler.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(map2) {
            this._map = map2;
            this._setPanDelta(map2.options.keyboardPanDelta);
            this._setZoomDelta(map2.options.zoomDelta);
          },
          addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex <= 0) {
              container.tabIndex = "0";
            }
            on(container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks();
            off(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            if (this._focused) {
              return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
          },
          _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
          },
          _setPanDelta: function(panDelta) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.left.length; i < len; i++) {
              keys[codes.left[i]] = [-1 * panDelta, 0];
            }
            for (i = 0, len = codes.right.length; i < len; i++) {
              keys[codes.right[i]] = [panDelta, 0];
            }
            for (i = 0, len = codes.down.length; i < len; i++) {
              keys[codes.down[i]] = [0, panDelta];
            }
            for (i = 0, len = codes.up.length; i < len; i++) {
              keys[codes.up[i]] = [0, -1 * panDelta];
            }
          },
          _setZoomDelta: function(zoomDelta) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.zoomIn.length; i < len; i++) {
              keys[codes.zoomIn[i]] = zoomDelta;
            }
            for (i = 0, len = codes.zoomOut.length; i < len; i++) {
              keys[codes.zoomOut[i]] = -zoomDelta;
            }
          },
          _addHooks: function() {
            on(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            off(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            var key = e.keyCode, map2 = this._map, offset;
            if (key in this._panKeys) {
              if (!map2._panAnim || !map2._panAnim._inProgress) {
                offset = this._panKeys[key];
                if (e.shiftKey) {
                  offset = toPoint(offset).multiplyBy(3);
                }
                if (map2.options.maxBounds) {
                  offset = map2._limitOffset(toPoint(offset), map2.options.maxBounds);
                }
                if (map2.options.worldCopyJump) {
                  var newLatLng = map2.wrapLatLng(map2.unproject(map2.project(map2.getCenter()).add(offset)));
                  map2.panTo(newLatLng);
                } else {
                  map2.panBy(offset);
                }
              }
            } else if (key in this._zoomKeys) {
              map2.setZoom(map2.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
              map2.closePopup();
            } else {
              return;
            }
            stop(e);
          }
        });
        Map.addInitHook("addHandler", "keyboard", Keyboard);
        Map.mergeOptions({
          // @section Mouse wheel options
          // @option scrollWheelZoom: Boolean|String = true
          // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
          // it will zoom to the center of the view regardless of where the mouse was.
          scrollWheelZoom: true,
          // @option wheelDebounceTime: Number = 40
          // Limits the rate at which a wheel can fire (in milliseconds). By default
          // user can't zoom via wheel more often than once per 40 ms.
          wheelDebounceTime: 40,
          // @option wheelPxPerZoomLevel: Number = 60
          // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
          // mean a change of one full zoom level. Smaller values will make wheel-zooming
          // faster (and vice versa).
          wheelPxPerZoomLevel: 60
        });
        var ScrollWheelZoom = Handler.extend({
          addHooks: function() {
            on(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
          },
          removeHooks: function() {
            off(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(e) {
            var delta = getWheelDelta(e);
            var debounce = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
              this._startTime = +/* @__PURE__ */ new Date();
            }
            var left = Math.max(debounce - (+/* @__PURE__ */ new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e);
          },
          _performZoom: function() {
            var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
            map2._stop();
            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
              return;
            }
            if (map2.options.scrollWheelZoom === "center") {
              map2.setZoom(zoom2 + delta);
            } else {
              map2.setZoomAround(this._lastMousePos, zoom2 + delta);
            }
          }
        });
        Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
        var tapHoldDelay = 600;
        Map.mergeOptions({
          // @section Touch interaction options
          // @option tapHold: Boolean
          // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
          tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
          // @option tapTolerance: Number = 15
          // The max number of pixels a user can shift his finger during touch
          // for it to be considered a valid tap.
          tapTolerance: 15
        });
        var TapHold = Handler.extend({
          addHooks: function() {
            on(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            off(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(e) {
            clearTimeout(this._holdTimeout);
            if (e.touches.length !== 1) {
              return;
            }
            var first = e.touches[0];
            this._startPos = this._newPos = new Point(first.clientX, first.clientY);
            this._holdTimeout = setTimeout(bind(function() {
              this._cancel();
              if (!this._isTapValid()) {
                return;
              }
              on(document, "touchend", preventDefault);
              on(document, "touchend touchcancel", this._cancelClickPrevent);
              this._simulateEvent("contextmenu", first);
            }, this), tapHoldDelay);
            on(document, "touchend touchcancel contextmenu", this._cancel, this);
            on(document, "touchmove", this._onMove, this);
          },
          _cancelClickPrevent: function cancelClickPrevent() {
            off(document, "touchend", preventDefault);
            off(document, "touchend touchcancel", cancelClickPrevent);
          },
          _cancel: function() {
            clearTimeout(this._holdTimeout);
            off(document, "touchend touchcancel contextmenu", this._cancel, this);
            off(document, "touchmove", this._onMove, this);
          },
          _onMove: function(e) {
            var first = e.touches[0];
            this._newPos = new Point(first.clientX, first.clientY);
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _simulateEvent: function(type, e) {
            var simulatedEvent = new MouseEvent(type, {
              bubbles: true,
              cancelable: true,
              view: window,
              // detail: 1,
              screenX: e.screenX,
              screenY: e.screenY,
              clientX: e.clientX,
              clientY: e.clientY
              // button: 2,
              // buttons: 2
            });
            simulatedEvent._simulated = true;
            e.target.dispatchEvent(simulatedEvent);
          }
        });
        Map.addInitHook("addHandler", "tapHold", TapHold);
        Map.mergeOptions({
          // @section Touch interaction options
          // @option touchZoom: Boolean|String = *
          // Whether the map can be zoomed by touch-dragging with two fingers. If
          // passed `'center'`, it will zoom to the center of the view regardless of
          // where the touch events (fingers) were. Enabled for touch-capable web
          // browsers.
          touchZoom: Browser.touch,
          // @option bounceAtZoomLimits: Boolean = true
          // Set it to false if you don't want the map to zoom beyond min/max zoom
          // and then bounce back when pinch-zooming.
          bounceAtZoomLimits: true
        });
        var TouchZoom = Handler.extend({
          addHooks: function() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on(this._map._container, "touchstart", this._onTouchStart, this);
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off(this._map._container, "touchstart", this._onTouchStart, this);
          },
          _onTouchStart: function(e) {
            var map2 = this._map;
            if (!e.touches || e.touches.length !== 2 || map2._animatingZoom || this._zooming) {
              return;
            }
            var p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]);
            this._centerPoint = map2.getSize()._divideBy(2);
            this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
            if (map2.options.touchZoom !== "center") {
              this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p2)._divideBy(2));
            }
            this._startDist = p1.distanceTo(p2);
            this._startZoom = map2.getZoom();
            this._moved = false;
            this._zooming = true;
            map2._stop();
            on(document, "touchmove", this._onTouchMove, this);
            on(document, "touchend touchcancel", this._onTouchEnd, this);
            preventDefault(e);
          },
          _onTouchMove: function(e) {
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
              return;
            }
            var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
            this._zoom = map2.getScaleZoom(scale2, this._startZoom);
            if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale2 < 1 || this._zoom > map2.getMaxZoom() && scale2 > 1)) {
              this._zoom = map2._limitZoom(this._zoom);
            }
            if (map2.options.touchZoom === "center") {
              this._center = this._startLatLng;
              if (scale2 === 1) {
                return;
              }
            } else {
              var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
              if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
                return;
              }
              this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
              map2._moveStart(true, false);
              this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false }, void 0);
            this._animRequest = requestAnimFrame(moveFn, this, true);
            preventDefault(e);
          },
          _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
              this._zooming = false;
              return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off(document, "touchmove", this._onTouchMove, this);
            off(document, "touchend touchcancel", this._onTouchEnd, this);
            if (this._map.options.zoomAnimation) {
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            } else {
              this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            }
          }
        });
        Map.addInitHook("addHandler", "touchZoom", TouchZoom);
        Map.BoxZoom = BoxZoom;
        Map.DoubleClickZoom = DoubleClickZoom;
        Map.Drag = Drag;
        Map.Keyboard = Keyboard;
        Map.ScrollWheelZoom = ScrollWheelZoom;
        Map.TapHold = TapHold;
        Map.TouchZoom = TouchZoom;
        exports2.Bounds = Bounds;
        exports2.Browser = Browser;
        exports2.CRS = CRS;
        exports2.Canvas = Canvas;
        exports2.Circle = Circle;
        exports2.CircleMarker = CircleMarker;
        exports2.Class = Class;
        exports2.Control = Control;
        exports2.DivIcon = DivIcon;
        exports2.DivOverlay = DivOverlay;
        exports2.DomEvent = DomEvent;
        exports2.DomUtil = DomUtil;
        exports2.Draggable = Draggable;
        exports2.Evented = Evented;
        exports2.FeatureGroup = FeatureGroup;
        exports2.GeoJSON = GeoJSON;
        exports2.GridLayer = GridLayer;
        exports2.Handler = Handler;
        exports2.Icon = Icon;
        exports2.ImageOverlay = ImageOverlay;
        exports2.LatLng = LatLng;
        exports2.LatLngBounds = LatLngBounds;
        exports2.Layer = Layer;
        exports2.LayerGroup = LayerGroup;
        exports2.LineUtil = LineUtil;
        exports2.Map = Map;
        exports2.Marker = Marker;
        exports2.Mixin = Mixin;
        exports2.Path = Path;
        exports2.Point = Point;
        exports2.PolyUtil = PolyUtil;
        exports2.Polygon = Polygon;
        exports2.Polyline = Polyline;
        exports2.Popup = Popup;
        exports2.PosAnimation = PosAnimation;
        exports2.Projection = index;
        exports2.Rectangle = Rectangle;
        exports2.Renderer = Renderer;
        exports2.SVG = SVG;
        exports2.SVGOverlay = SVGOverlay;
        exports2.TileLayer = TileLayer;
        exports2.Tooltip = Tooltip;
        exports2.Transformation = Transformation;
        exports2.Util = Util;
        exports2.VideoOverlay = VideoOverlay;
        exports2.bind = bind;
        exports2.bounds = toBounds;
        exports2.canvas = canvas;
        exports2.circle = circle;
        exports2.circleMarker = circleMarker;
        exports2.control = control;
        exports2.divIcon = divIcon;
        exports2.extend = extend;
        exports2.featureGroup = featureGroup2;
        exports2.geoJSON = geoJSON;
        exports2.geoJson = geoJson;
        exports2.gridLayer = gridLayer;
        exports2.icon = icon;
        exports2.imageOverlay = imageOverlay;
        exports2.latLng = toLatLng;
        exports2.latLngBounds = toLatLngBounds;
        exports2.layerGroup = layerGroup;
        exports2.map = createMap;
        exports2.marker = marker;
        exports2.point = toPoint;
        exports2.polygon = polygon;
        exports2.polyline = polyline;
        exports2.popup = popup;
        exports2.rectangle = rectangle;
        exports2.setOptions = setOptions;
        exports2.stamp = stamp;
        exports2.svg = svg;
        exports2.svgOverlay = svgOverlay;
        exports2.tileLayer = tileLayer;
        exports2.tooltip = tooltip;
        exports2.transformation = toTransformation;
        exports2.version = version;
        exports2.videoOverlay = videoOverlay;
        var oldL = window.L;
        exports2.noConflict = function() {
          window.L = oldL;
          return this;
        };
        window.L = exports2;
      });
    }
  });

  // C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/node_modules/proj4/dist/proj4-src.js
  var require_proj4_src = __commonJS({
    "C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/node_modules/proj4/dist/proj4-src.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.proj4 = factory();
      })(exports, function() {
        "use strict";
        var globals = function(defs2) {
          defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
          defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
          defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
          for (var i = 0; i <= 60; ++i) {
            defs2("EPSG:" + (32600 + i), "+proj=utm +zone=" + i + " +datum=WGS84 +units=m");
            defs2("EPSG:" + (32700 + i), "+proj=utm +zone=" + i + " +south +datum=WGS84 +units=m");
          }
          defs2.WGS84 = defs2["EPSG:4326"];
          defs2["EPSG:3785"] = defs2["EPSG:3857"];
          defs2.GOOGLE = defs2["EPSG:3857"];
          defs2["EPSG:900913"] = defs2["EPSG:3857"];
          defs2["EPSG:102113"] = defs2["EPSG:3857"];
        };
        var PJD_3PARAM = 1;
        var PJD_7PARAM = 2;
        var PJD_GRIDSHIFT = 3;
        var PJD_WGS84 = 4;
        var PJD_NODATUM = 5;
        var SRS_WGS84_SEMIMAJOR = 6378137;
        var SRS_WGS84_SEMIMINOR = 6356752314e-3;
        var SRS_WGS84_ESQUARED = 0.0066943799901413165;
        var SEC_TO_RAD = 484813681109536e-20;
        var HALF_PI = Math.PI / 2;
        var SIXTH = 0.16666666666666666;
        var RA4 = 0.04722222222222222;
        var RA6 = 0.022156084656084655;
        var EPSLN = 1e-10;
        var D2R = 0.017453292519943295;
        var R2D = 57.29577951308232;
        var FORTPI = Math.PI / 4;
        var TWO_PI = Math.PI * 2;
        var SPI = 3.14159265359;
        var exports$1 = {};
        exports$1.greenwich = 0;
        exports$1.lisbon = -9.131906111111;
        exports$1.paris = 2.337229166667;
        exports$1.bogota = -74.080916666667;
        exports$1.madrid = -3.687938888889;
        exports$1.rome = 12.452333333333;
        exports$1.bern = 7.439583333333;
        exports$1.jakarta = 106.807719444444;
        exports$1.ferro = -17.666666666667;
        exports$1.brussels = 4.367975;
        exports$1.stockholm = 18.058277777778;
        exports$1.athens = 23.7163375;
        exports$1.oslo = 10.722916666667;
        var units = {
          "mm": { to_meter: 1e-3 },
          "cm": { to_meter: 0.01 },
          "ft": { to_meter: 0.3048 },
          "us-ft": { to_meter: 1200 / 3937 },
          "fath": { to_meter: 1.8288 },
          "kmi": { to_meter: 1852 },
          "us-ch": { to_meter: 20.1168402336805 },
          "us-mi": { to_meter: 1609.34721869444 },
          "km": { to_meter: 1e3 },
          "ind-ft": { to_meter: 0.30479841 },
          "ind-yd": { to_meter: 0.91439523 },
          "mi": { to_meter: 1609.344 },
          "yd": { to_meter: 0.9144 },
          "ch": { to_meter: 20.1168 },
          "link": { to_meter: 0.201168 },
          "dm": { to_meter: 0.01 },
          "in": { to_meter: 0.0254 },
          "ind-ch": { to_meter: 20.11669506 },
          "us-in": { to_meter: 0.025400050800101 },
          "us-yd": { to_meter: 0.914401828803658 }
        };
        var ignoredChar = /[\s_\-\/\(\)]/g;
        function match(obj, key2) {
          if (obj[key2]) {
            return obj[key2];
          }
          var keys = Object.keys(obj);
          var lkey = key2.toLowerCase().replace(ignoredChar, "");
          var i = -1;
          var testkey, processedKey;
          while (++i < keys.length) {
            testkey = keys[i];
            processedKey = testkey.toLowerCase().replace(ignoredChar, "");
            if (processedKey === lkey) {
              return obj[testkey];
            }
          }
        }
        var parseProj = function(defData) {
          var self2 = {};
          var paramObj = defData.split("+").map(function(v) {
            return v.trim();
          }).filter(function(a) {
            return a;
          }).reduce(function(p, a) {
            var split = a.split("=");
            split.push(true);
            p[split[0].toLowerCase()] = split[1];
            return p;
          }, {});
          var paramName, paramVal, paramOutname;
          var params2 = {
            proj: "projName",
            datum: "datumCode",
            rf: function(v) {
              self2.rf = parseFloat(v);
            },
            lat_0: function(v) {
              self2.lat0 = v * D2R;
            },
            lat_1: function(v) {
              self2.lat1 = v * D2R;
            },
            lat_2: function(v) {
              self2.lat2 = v * D2R;
            },
            lat_ts: function(v) {
              self2.lat_ts = v * D2R;
            },
            lon_0: function(v) {
              self2.long0 = v * D2R;
            },
            lon_1: function(v) {
              self2.long1 = v * D2R;
            },
            lon_2: function(v) {
              self2.long2 = v * D2R;
            },
            alpha: function(v) {
              self2.alpha = parseFloat(v) * D2R;
            },
            gamma: function(v) {
              self2.rectified_grid_angle = parseFloat(v);
            },
            lonc: function(v) {
              self2.longc = v * D2R;
            },
            x_0: function(v) {
              self2.x0 = parseFloat(v);
            },
            y_0: function(v) {
              self2.y0 = parseFloat(v);
            },
            k_0: function(v) {
              self2.k0 = parseFloat(v);
            },
            k: function(v) {
              self2.k0 = parseFloat(v);
            },
            a: function(v) {
              self2.a = parseFloat(v);
            },
            b: function(v) {
              self2.b = parseFloat(v);
            },
            r: function(v) {
              self2.a = self2.b = parseFloat(v);
            },
            r_a: function() {
              self2.R_A = true;
            },
            zone: function(v) {
              self2.zone = parseInt(v, 10);
            },
            south: function() {
              self2.utmSouth = true;
            },
            towgs84: function(v) {
              self2.datum_params = v.split(",").map(function(a) {
                return parseFloat(a);
              });
            },
            to_meter: function(v) {
              self2.to_meter = parseFloat(v);
            },
            units: function(v) {
              self2.units = v;
              var unit = match(units, v);
              if (unit) {
                self2.to_meter = unit.to_meter;
              }
            },
            from_greenwich: function(v) {
              self2.from_greenwich = v * D2R;
            },
            pm: function(v) {
              var pm = match(exports$1, v);
              self2.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
            },
            nadgrids: function(v) {
              if (v === "@null") {
                self2.datumCode = "none";
              } else {
                self2.nadgrids = v;
              }
            },
            axis: function(v) {
              var legalAxis = "ewnsud";
              if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
                self2.axis = v;
              }
            },
            approx: function() {
              self2.approx = true;
            }
          };
          for (paramName in paramObj) {
            paramVal = paramObj[paramName];
            if (paramName in params2) {
              paramOutname = params2[paramName];
              if (typeof paramOutname === "function") {
                paramOutname(paramVal);
              } else {
                self2[paramOutname] = paramVal;
              }
            } else {
              self2[paramName] = paramVal;
            }
          }
          if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
            self2.datumCode = self2.datumCode.toLowerCase();
          }
          return self2;
        };
        var NEUTRAL = 1;
        var KEYWORD = 2;
        var NUMBER = 3;
        var QUOTED = 4;
        var AFTERQUOTE = 5;
        var ENDED = -1;
        var whitespace = /\s/;
        var latin = /[A-Za-z]/;
        var keyword = /[A-Za-z84_]/;
        var endThings = /[,\]]/;
        var digets = /[\d\.E\-\+]/;
        function Parser(text) {
          if (typeof text !== "string") {
            throw new Error("not a string");
          }
          this.text = text.trim();
          this.level = 0;
          this.place = 0;
          this.root = null;
          this.stack = [];
          this.currentObject = null;
          this.state = NEUTRAL;
        }
        Parser.prototype.readCharicter = function() {
          var char = this.text[this.place++];
          if (this.state !== QUOTED) {
            while (whitespace.test(char)) {
              if (this.place >= this.text.length) {
                return;
              }
              char = this.text[this.place++];
            }
          }
          switch (this.state) {
            case NEUTRAL:
              return this.neutral(char);
            case KEYWORD:
              return this.keyword(char);
            case QUOTED:
              return this.quoted(char);
            case AFTERQUOTE:
              return this.afterquote(char);
            case NUMBER:
              return this.number(char);
            case ENDED:
              return;
          }
        };
        Parser.prototype.afterquote = function(char) {
          if (char === '"') {
            this.word += '"';
            this.state = QUOTED;
            return;
          }
          if (endThings.test(char)) {
            this.word = this.word.trim();
            this.afterItem(char);
            return;
          }
          throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
        };
        Parser.prototype.afterItem = function(char) {
          if (char === ",") {
            if (this.word !== null) {
              this.currentObject.push(this.word);
            }
            this.word = null;
            this.state = NEUTRAL;
            return;
          }
          if (char === "]") {
            this.level--;
            if (this.word !== null) {
              this.currentObject.push(this.word);
              this.word = null;
            }
            this.state = NEUTRAL;
            this.currentObject = this.stack.pop();
            if (!this.currentObject) {
              this.state = ENDED;
            }
            return;
          }
        };
        Parser.prototype.number = function(char) {
          if (digets.test(char)) {
            this.word += char;
            return;
          }
          if (endThings.test(char)) {
            this.word = parseFloat(this.word);
            this.afterItem(char);
            return;
          }
          throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
        };
        Parser.prototype.quoted = function(char) {
          if (char === '"') {
            this.state = AFTERQUOTE;
            return;
          }
          this.word += char;
          return;
        };
        Parser.prototype.keyword = function(char) {
          if (keyword.test(char)) {
            this.word += char;
            return;
          }
          if (char === "[") {
            var newObjects = [];
            newObjects.push(this.word);
            this.level++;
            if (this.root === null) {
              this.root = newObjects;
            } else {
              this.currentObject.push(newObjects);
            }
            this.stack.push(this.currentObject);
            this.currentObject = newObjects;
            this.state = NEUTRAL;
            return;
          }
          if (endThings.test(char)) {
            this.afterItem(char);
            return;
          }
          throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
        };
        Parser.prototype.neutral = function(char) {
          if (latin.test(char)) {
            this.word = char;
            this.state = KEYWORD;
            return;
          }
          if (char === '"') {
            this.word = "";
            this.state = QUOTED;
            return;
          }
          if (digets.test(char)) {
            this.word = char;
            this.state = NUMBER;
            return;
          }
          if (endThings.test(char)) {
            this.afterItem(char);
            return;
          }
          throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
        };
        Parser.prototype.output = function() {
          while (this.place < this.text.length) {
            this.readCharicter();
          }
          if (this.state === ENDED) {
            return this.root;
          }
          throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
        };
        function parseString(txt) {
          var parser = new Parser(txt);
          return parser.output();
        }
        function mapit(obj, key2, value) {
          if (Array.isArray(key2)) {
            value.unshift(key2);
            key2 = null;
          }
          var thing = key2 ? {} : obj;
          var out = value.reduce(function(newObj, item) {
            sExpr(item, newObj);
            return newObj;
          }, thing);
          if (key2) {
            obj[key2] = out;
          }
        }
        function sExpr(v, obj) {
          if (!Array.isArray(v)) {
            obj[v] = true;
            return;
          }
          var key2 = v.shift();
          if (key2 === "PARAMETER") {
            key2 = v.shift();
          }
          if (v.length === 1) {
            if (Array.isArray(v[0])) {
              obj[key2] = {};
              sExpr(v[0], obj[key2]);
              return;
            }
            obj[key2] = v[0];
            return;
          }
          if (!v.length) {
            obj[key2] = true;
            return;
          }
          if (key2 === "TOWGS84") {
            obj[key2] = v;
            return;
          }
          if (key2 === "AXIS") {
            if (!(key2 in obj)) {
              obj[key2] = [];
            }
            obj[key2].push(v);
            return;
          }
          if (!Array.isArray(key2)) {
            obj[key2] = {};
          }
          var i;
          switch (key2) {
            case "UNIT":
            case "PRIMEM":
            case "VERT_DATUM":
              obj[key2] = {
                name: v[0].toLowerCase(),
                convert: v[1]
              };
              if (v.length === 3) {
                sExpr(v[2], obj[key2]);
              }
              return;
            case "SPHEROID":
            case "ELLIPSOID":
              obj[key2] = {
                name: v[0],
                a: v[1],
                rf: v[2]
              };
              if (v.length === 4) {
                sExpr(v[3], obj[key2]);
              }
              return;
            case "PROJECTEDCRS":
            case "PROJCRS":
            case "GEOGCS":
            case "GEOCCS":
            case "PROJCS":
            case "LOCAL_CS":
            case "GEODCRS":
            case "GEODETICCRS":
            case "GEODETICDATUM":
            case "EDATUM":
            case "ENGINEERINGDATUM":
            case "VERT_CS":
            case "VERTCRS":
            case "VERTICALCRS":
            case "COMPD_CS":
            case "COMPOUNDCRS":
            case "ENGINEERINGCRS":
            case "ENGCRS":
            case "FITTED_CS":
            case "LOCAL_DATUM":
            case "DATUM":
              v[0] = ["name", v[0]];
              mapit(obj, key2, v);
              return;
            default:
              i = -1;
              while (++i < v.length) {
                if (!Array.isArray(v[i])) {
                  return sExpr(v, obj[key2]);
                }
              }
              return mapit(obj, key2, v);
          }
        }
        var D2R$1 = 0.017453292519943295;
        function rename(obj, params2) {
          var outName = params2[0];
          var inName = params2[1];
          if (!(outName in obj) && inName in obj) {
            obj[outName] = obj[inName];
            if (params2.length === 3) {
              obj[outName] = params2[2](obj[outName]);
            }
          }
        }
        function d2r(input) {
          return input * D2R$1;
        }
        function cleanWKT(wkt2) {
          if (wkt2.type === "GEOGCS") {
            wkt2.projName = "longlat";
          } else if (wkt2.type === "LOCAL_CS") {
            wkt2.projName = "identity";
            wkt2.local = true;
          } else {
            if (typeof wkt2.PROJECTION === "object") {
              wkt2.projName = Object.keys(wkt2.PROJECTION)[0];
            } else {
              wkt2.projName = wkt2.PROJECTION;
            }
          }
          if (wkt2.AXIS) {
            var axisOrder = "";
            for (var i = 0, ii = wkt2.AXIS.length; i < ii; ++i) {
              var axis = [wkt2.AXIS[i][0].toLowerCase(), wkt2.AXIS[i][1].toLowerCase()];
              if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
                axisOrder += "n";
              } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
                axisOrder += "s";
              } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
                axisOrder += "e";
              } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
                axisOrder += "w";
              }
            }
            if (axisOrder.length === 2) {
              axisOrder += "u";
            }
            if (axisOrder.length === 3) {
              wkt2.axis = axisOrder;
            }
          }
          if (wkt2.UNIT) {
            wkt2.units = wkt2.UNIT.name.toLowerCase();
            if (wkt2.units === "metre") {
              wkt2.units = "meter";
            }
            if (wkt2.UNIT.convert) {
              if (wkt2.type === "GEOGCS") {
                if (wkt2.DATUM && wkt2.DATUM.SPHEROID) {
                  wkt2.to_meter = wkt2.UNIT.convert * wkt2.DATUM.SPHEROID.a;
                }
              } else {
                wkt2.to_meter = wkt2.UNIT.convert;
              }
            }
          }
          var geogcs = wkt2.GEOGCS;
          if (wkt2.type === "GEOGCS") {
            geogcs = wkt2;
          }
          if (geogcs) {
            if (geogcs.DATUM) {
              wkt2.datumCode = geogcs.DATUM.name.toLowerCase();
            } else {
              wkt2.datumCode = geogcs.name.toLowerCase();
            }
            if (wkt2.datumCode.slice(0, 2) === "d_") {
              wkt2.datumCode = wkt2.datumCode.slice(2);
            }
            if (wkt2.datumCode === "new_zealand_geodetic_datum_1949" || wkt2.datumCode === "new_zealand_1949") {
              wkt2.datumCode = "nzgd49";
            }
            if (wkt2.datumCode === "wgs_1984" || wkt2.datumCode === "world_geodetic_system_1984") {
              if (wkt2.PROJECTION === "Mercator_Auxiliary_Sphere") {
                wkt2.sphere = true;
              }
              wkt2.datumCode = "wgs84";
            }
            if (wkt2.datumCode.slice(-6) === "_ferro") {
              wkt2.datumCode = wkt2.datumCode.slice(0, -6);
            }
            if (wkt2.datumCode.slice(-8) === "_jakarta") {
              wkt2.datumCode = wkt2.datumCode.slice(0, -8);
            }
            if (~wkt2.datumCode.indexOf("belge")) {
              wkt2.datumCode = "rnb72";
            }
            if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
              wkt2.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
              if (wkt2.ellps.toLowerCase().slice(0, 13) === "international") {
                wkt2.ellps = "intl";
              }
              wkt2.a = geogcs.DATUM.SPHEROID.a;
              wkt2.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
            }
            if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
              wkt2.datum_params = geogcs.DATUM.TOWGS84;
            }
            if (~wkt2.datumCode.indexOf("osgb_1936")) {
              wkt2.datumCode = "osgb36";
            }
            if (~wkt2.datumCode.indexOf("osni_1952")) {
              wkt2.datumCode = "osni52";
            }
            if (~wkt2.datumCode.indexOf("tm65") || ~wkt2.datumCode.indexOf("geodetic_datum_of_1965")) {
              wkt2.datumCode = "ire65";
            }
            if (wkt2.datumCode === "ch1903+") {
              wkt2.datumCode = "ch1903";
            }
            if (~wkt2.datumCode.indexOf("israel")) {
              wkt2.datumCode = "isr93";
            }
          }
          if (wkt2.b && !isFinite(wkt2.b)) {
            wkt2.b = wkt2.a;
          }
          function toMeter(input) {
            var ratio = wkt2.to_meter || 1;
            return input * ratio;
          }
          var renamer = function(a) {
            return rename(wkt2, a);
          };
          var list = [
            ["standard_parallel_1", "Standard_Parallel_1"],
            ["standard_parallel_1", "Latitude of 1st standard parallel"],
            ["standard_parallel_2", "Standard_Parallel_2"],
            ["standard_parallel_2", "Latitude of 2nd standard parallel"],
            ["false_easting", "False_Easting"],
            ["false_easting", "False easting"],
            ["false-easting", "Easting at false origin"],
            ["false_northing", "False_Northing"],
            ["false_northing", "False northing"],
            ["false_northing", "Northing at false origin"],
            ["central_meridian", "Central_Meridian"],
            ["central_meridian", "Longitude of natural origin"],
            ["central_meridian", "Longitude of false origin"],
            ["latitude_of_origin", "Latitude_Of_Origin"],
            ["latitude_of_origin", "Central_Parallel"],
            ["latitude_of_origin", "Latitude of natural origin"],
            ["latitude_of_origin", "Latitude of false origin"],
            ["scale_factor", "Scale_Factor"],
            ["k0", "scale_factor"],
            ["latitude_of_center", "Latitude_Of_Center"],
            ["latitude_of_center", "Latitude_of_center"],
            ["lat0", "latitude_of_center", d2r],
            ["longitude_of_center", "Longitude_Of_Center"],
            ["longitude_of_center", "Longitude_of_center"],
            ["longc", "longitude_of_center", d2r],
            ["x0", "false_easting", toMeter],
            ["y0", "false_northing", toMeter],
            ["long0", "central_meridian", d2r],
            ["lat0", "latitude_of_origin", d2r],
            ["lat0", "standard_parallel_1", d2r],
            ["lat1", "standard_parallel_1", d2r],
            ["lat2", "standard_parallel_2", d2r],
            ["azimuth", "Azimuth"],
            ["alpha", "azimuth", d2r],
            ["srsCode", "name"]
          ];
          list.forEach(renamer);
          if (!wkt2.long0 && wkt2.longc && (wkt2.projName === "Albers_Conic_Equal_Area" || wkt2.projName === "Lambert_Azimuthal_Equal_Area")) {
            wkt2.long0 = wkt2.longc;
          }
          if (!wkt2.lat_ts && wkt2.lat1 && (wkt2.projName === "Stereographic_South_Pole" || wkt2.projName === "Polar Stereographic (variant B)")) {
            wkt2.lat0 = d2r(wkt2.lat1 > 0 ? 90 : -90);
            wkt2.lat_ts = wkt2.lat1;
          } else if (!wkt2.lat_ts && wkt2.lat0 && wkt2.projName === "Polar_Stereographic") {
            wkt2.lat_ts = wkt2.lat0;
            wkt2.lat0 = d2r(wkt2.lat0 > 0 ? 90 : -90);
          }
        }
        var wkt = function(wkt2) {
          var lisp = parseString(wkt2);
          var type = lisp.shift();
          var name = lisp.shift();
          lisp.unshift(["name", name]);
          lisp.unshift(["type", type]);
          var obj = {};
          sExpr(lisp, obj);
          cleanWKT(obj);
          return obj;
        };
        function defs(name) {
          var that = this;
          if (arguments.length === 2) {
            var def = arguments[1];
            if (typeof def === "string") {
              if (def.charAt(0) === "+") {
                defs[name] = parseProj(arguments[1]);
              } else {
                defs[name] = wkt(arguments[1]);
              }
            } else {
              defs[name] = def;
            }
          } else if (arguments.length === 1) {
            if (Array.isArray(name)) {
              return name.map(function(v) {
                if (Array.isArray(v)) {
                  defs.apply(that, v);
                } else {
                  defs(v);
                }
              });
            } else if (typeof name === "string") {
              if (name in defs) {
                return defs[name];
              }
            } else if ("EPSG" in name) {
              defs["EPSG:" + name.EPSG] = name;
            } else if ("ESRI" in name) {
              defs["ESRI:" + name.ESRI] = name;
            } else if ("IAU2000" in name) {
              defs["IAU2000:" + name.IAU2000] = name;
            } else {
              console.log(name);
            }
            return;
          }
        }
        globals(defs);
        function testObj(code) {
          return typeof code === "string";
        }
        function testDef(code) {
          return code in defs;
        }
        var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
        function testWKT(code) {
          return codeWords.some(function(word) {
            return code.indexOf(word) > -1;
          });
        }
        var codes = ["3857", "900913", "3785", "102113"];
        function checkMercator(item) {
          var auth = match(item, "authority");
          if (!auth) {
            return;
          }
          var code = match(auth, "epsg");
          return code && codes.indexOf(code) > -1;
        }
        function checkProjStr(item) {
          var ext = match(item, "extension");
          if (!ext) {
            return;
          }
          return match(ext, "proj4");
        }
        function testProj(code) {
          return code[0] === "+";
        }
        function parse(code) {
          if (testObj(code)) {
            if (testDef(code)) {
              return defs[code];
            }
            if (testWKT(code)) {
              var out = wkt(code);
              if (checkMercator(out)) {
                return defs["EPSG:3857"];
              }
              var maybeProjStr = checkProjStr(out);
              if (maybeProjStr) {
                return parseProj(maybeProjStr);
              }
              return out;
            }
            if (testProj(code)) {
              return parseProj(code);
            }
          } else {
            return code;
          }
        }
        var extend = function(destination, source) {
          destination = destination || {};
          var value, property;
          if (!source) {
            return destination;
          }
          for (property in source) {
            value = source[property];
            if (value !== void 0) {
              destination[property] = value;
            }
          }
          return destination;
        };
        var msfnz = function(eccent, sinphi, cosphi) {
          var con = eccent * sinphi;
          return cosphi / Math.sqrt(1 - con * con);
        };
        var sign = function(x) {
          return x < 0 ? -1 : 1;
        };
        var adjust_lon = function(x) {
          return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
        };
        var tsfnz = function(eccent, phi, sinphi) {
          var con = eccent * sinphi;
          var com = 0.5 * eccent;
          con = Math.pow((1 - con) / (1 + con), com);
          return Math.tan(0.5 * (HALF_PI - phi)) / con;
        };
        var phi2z = function(eccent, ts) {
          var eccnth = 0.5 * eccent;
          var con, dphi;
          var phi = HALF_PI - 2 * Math.atan(ts);
          for (var i = 0; i <= 15; i++) {
            con = eccent * Math.sin(phi);
            dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return -9999;
        };
        function init() {
          var con = this.b / this.a;
          this.es = 1 - con * con;
          if (!("x0" in this)) {
            this.x0 = 0;
          }
          if (!("y0" in this)) {
            this.y0 = 0;
          }
          this.e = Math.sqrt(this.es);
          if (this.lat_ts) {
            if (this.sphere) {
              this.k0 = Math.cos(this.lat_ts);
            } else {
              this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
            }
          } else {
            if (!this.k0) {
              if (this.k) {
                this.k0 = this.k;
              } else {
                this.k0 = 1;
              }
            }
          }
        }
        function forward(p) {
          var lon = p.x;
          var lat = p.y;
          if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
            return null;
          }
          var x, y;
          if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
            return null;
          } else {
            if (this.sphere) {
              x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
              y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
            } else {
              var sinphi = Math.sin(lat);
              var ts = tsfnz(this.e, lat, sinphi);
              x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
              y = this.y0 - this.a * this.k0 * Math.log(ts);
            }
            p.x = x;
            p.y = y;
            return p;
          }
        }
        function inverse(p) {
          var x = p.x - this.x0;
          var y = p.y - this.y0;
          var lon, lat;
          if (this.sphere) {
            lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
          } else {
            var ts = Math.exp(-y / (this.a * this.k0));
            lat = phi2z(this.e, ts);
            if (lat === -9999) {
              return null;
            }
          }
          lon = adjust_lon(this.long0 + x / (this.a * this.k0));
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
        var merc = {
          init,
          forward,
          inverse,
          names: names$1
        };
        function init$1() {
        }
        function identity(pt) {
          return pt;
        }
        var names$2 = ["longlat", "identity"];
        var longlat = {
          init: init$1,
          forward: identity,
          inverse: identity,
          names: names$2
        };
        var projs = [merc, longlat];
        var names = {};
        var projStore = [];
        function add(proj, i) {
          var len = projStore.length;
          if (!proj.names) {
            console.log(i);
            return true;
          }
          projStore[len] = proj;
          proj.names.forEach(function(n) {
            names[n.toLowerCase()] = len;
          });
          return this;
        }
        function get(name) {
          if (!name) {
            return false;
          }
          var n = name.toLowerCase();
          if (typeof names[n] !== "undefined" && projStore[names[n]]) {
            return projStore[names[n]];
          }
        }
        function start() {
          projs.forEach(add);
        }
        var projections = {
          start,
          add,
          get
        };
        var exports$2 = {};
        exports$2.MERIT = {
          a: 6378137,
          rf: 298.257,
          ellipseName: "MERIT 1983"
        };
        exports$2.SGS85 = {
          a: 6378136,
          rf: 298.257,
          ellipseName: "Soviet Geodetic System 85"
        };
        exports$2.GRS80 = {
          a: 6378137,
          rf: 298.257222101,
          ellipseName: "GRS 1980(IUGG, 1980)"
        };
        exports$2.IAU76 = {
          a: 6378140,
          rf: 298.257,
          ellipseName: "IAU 1976"
        };
        exports$2.airy = {
          a: 6377563396e-3,
          b: 635625691e-2,
          ellipseName: "Airy 1830"
        };
        exports$2.APL4 = {
          a: 6378137,
          rf: 298.25,
          ellipseName: "Appl. Physics. 1965"
        };
        exports$2.NWL9D = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "Naval Weapons Lab., 1965"
        };
        exports$2.mod_airy = {
          a: 6377340189e-3,
          b: 6356034446e-3,
          ellipseName: "Modified Airy"
        };
        exports$2.andrae = {
          a: 637710443e-2,
          rf: 300,
          ellipseName: "Andrae 1876 (Den., Iclnd.)"
        };
        exports$2.aust_SA = {
          a: 6378160,
          rf: 298.25,
          ellipseName: "Australian Natl & S. Amer. 1969"
        };
        exports$2.GRS67 = {
          a: 6378160,
          rf: 298.247167427,
          ellipseName: "GRS 67(IUGG 1967)"
        };
        exports$2.bessel = {
          a: 6377397155e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841"
        };
        exports$2.bess_nam = {
          a: 6377483865e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841 (Namibia)"
        };
        exports$2.clrk66 = {
          a: 63782064e-1,
          b: 63565838e-1,
          ellipseName: "Clarke 1866"
        };
        exports$2.clrk80 = {
          a: 6378249145e-3,
          rf: 293.4663,
          ellipseName: "Clarke 1880 mod."
        };
        exports$2.clrk80ign = {
          a: 63782492e-1,
          b: 6356515,
          rf: 293.4660213,
          ellipseName: "Clarke 1880 (IGN)"
        };
        exports$2.clrk58 = {
          a: 6378293645208759e-9,
          rf: 294.2606763692654,
          ellipseName: "Clarke 1858"
        };
        exports$2.CPM = {
          a: 63757387e-1,
          rf: 334.29,
          ellipseName: "Comm. des Poids et Mesures 1799"
        };
        exports$2.delmbr = {
          a: 6376428,
          rf: 311.5,
          ellipseName: "Delambre 1810 (Belgium)"
        };
        exports$2.engelis = {
          a: 637813605e-2,
          rf: 298.2566,
          ellipseName: "Engelis 1985"
        };
        exports$2.evrst30 = {
          a: 6377276345e-3,
          rf: 300.8017,
          ellipseName: "Everest 1830"
        };
        exports$2.evrst48 = {
          a: 6377304063e-3,
          rf: 300.8017,
          ellipseName: "Everest 1948"
        };
        exports$2.evrst56 = {
          a: 6377301243e-3,
          rf: 300.8017,
          ellipseName: "Everest 1956"
        };
        exports$2.evrst69 = {
          a: 6377295664e-3,
          rf: 300.8017,
          ellipseName: "Everest 1969"
        };
        exports$2.evrstSS = {
          a: 6377298556e-3,
          rf: 300.8017,
          ellipseName: "Everest (Sabah & Sarawak)"
        };
        exports$2.fschr60 = {
          a: 6378166,
          rf: 298.3,
          ellipseName: "Fischer (Mercury Datum) 1960"
        };
        exports$2.fschr60m = {
          a: 6378155,
          rf: 298.3,
          ellipseName: "Fischer 1960"
        };
        exports$2.fschr68 = {
          a: 6378150,
          rf: 298.3,
          ellipseName: "Fischer 1968"
        };
        exports$2.helmert = {
          a: 6378200,
          rf: 298.3,
          ellipseName: "Helmert 1906"
        };
        exports$2.hough = {
          a: 6378270,
          rf: 297,
          ellipseName: "Hough"
        };
        exports$2.intl = {
          a: 6378388,
          rf: 297,
          ellipseName: "International 1909 (Hayford)"
        };
        exports$2.kaula = {
          a: 6378163,
          rf: 298.24,
          ellipseName: "Kaula 1961"
        };
        exports$2.lerch = {
          a: 6378139,
          rf: 298.257,
          ellipseName: "Lerch 1979"
        };
        exports$2.mprts = {
          a: 6397300,
          rf: 191,
          ellipseName: "Maupertius 1738"
        };
        exports$2.new_intl = {
          a: 63781575e-1,
          b: 63567722e-1,
          ellipseName: "New International 1967"
        };
        exports$2.plessis = {
          a: 6376523,
          rf: 6355863,
          ellipseName: "Plessis 1817 (France)"
        };
        exports$2.krass = {
          a: 6378245,
          rf: 298.3,
          ellipseName: "Krassovsky, 1942"
        };
        exports$2.SEasia = {
          a: 6378155,
          b: 63567733205e-4,
          ellipseName: "Southeast Asia"
        };
        exports$2.walbeck = {
          a: 6376896,
          b: 63558348467e-4,
          ellipseName: "Walbeck"
        };
        exports$2.WGS60 = {
          a: 6378165,
          rf: 298.3,
          ellipseName: "WGS 60"
        };
        exports$2.WGS66 = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "WGS 66"
        };
        exports$2.WGS7 = {
          a: 6378135,
          rf: 298.26,
          ellipseName: "WGS 72"
        };
        var WGS84 = exports$2.WGS84 = {
          a: 6378137,
          rf: 298.257223563,
          ellipseName: "WGS 84"
        };
        exports$2.sphere = {
          a: 6370997,
          b: 6370997,
          ellipseName: "Normal Sphere (r=6370997)"
        };
        function eccentricity(a, b, rf, R_A) {
          var a2 = a * a;
          var b2 = b * b;
          var es = (a2 - b2) / a2;
          var e = 0;
          if (R_A) {
            a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
            a2 = a * a;
            es = 0;
          } else {
            e = Math.sqrt(es);
          }
          var ep2 = (a2 - b2) / b2;
          return {
            es,
            e,
            ep2
          };
        }
        function sphere(a, b, rf, ellps, sphere2) {
          if (!a) {
            var ellipse = match(exports$2, ellps);
            if (!ellipse) {
              ellipse = WGS84;
            }
            a = ellipse.a;
            b = ellipse.b;
            rf = ellipse.rf;
          }
          if (rf && !b) {
            b = (1 - 1 / rf) * a;
          }
          if (rf === 0 || Math.abs(a - b) < EPSLN) {
            sphere2 = true;
            b = a;
          }
          return {
            a,
            b,
            rf,
            sphere: sphere2
          };
        }
        var datums = {
          wgs84: {
            towgs84: "0,0,0",
            ellipse: "WGS84",
            datumName: "WGS84"
          },
          ch1903: {
            towgs84: "674.374,15.056,405.346",
            ellipse: "bessel",
            datumName: "swiss"
          },
          ggrs87: {
            towgs84: "-199.87,74.79,246.62",
            ellipse: "GRS80",
            datumName: "Greek_Geodetic_Reference_System_1987"
          },
          nad83: {
            towgs84: "0,0,0",
            ellipse: "GRS80",
            datumName: "North_American_Datum_1983"
          },
          nad27: {
            nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
            ellipse: "clrk66",
            datumName: "North_American_Datum_1927"
          },
          potsdam: {
            towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
            ellipse: "bessel",
            datumName: "Potsdam Rauenberg 1950 DHDN"
          },
          carthage: {
            towgs84: "-263.0,6.0,431.0",
            ellipse: "clark80",
            datumName: "Carthage 1934 Tunisia"
          },
          hermannskogel: {
            towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
            ellipse: "bessel",
            datumName: "Hermannskogel"
          },
          militargeographische_institut: {
            towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
            ellipse: "bessel",
            datumName: "Militar-Geographische Institut"
          },
          osni52: {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "airy",
            datumName: "Irish National"
          },
          ire65: {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "mod_airy",
            datumName: "Ireland 1965"
          },
          rassadiran: {
            towgs84: "-133.63,-157.5,-158.62",
            ellipse: "intl",
            datumName: "Rassadiran"
          },
          nzgd49: {
            towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
            ellipse: "intl",
            datumName: "New Zealand Geodetic Datum 1949"
          },
          osgb36: {
            towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
            ellipse: "airy",
            datumName: "Ordnance Survey of Great Britain 1936"
          },
          s_jtsk: {
            towgs84: "589,76,480",
            ellipse: "bessel",
            datumName: "S-JTSK (Ferro)"
          },
          beduaram: {
            towgs84: "-106,-87,188",
            ellipse: "clrk80",
            datumName: "Beduaram"
          },
          gunung_segara: {
            towgs84: "-403,684,41",
            ellipse: "bessel",
            datumName: "Gunung Segara Jakarta"
          },
          rnb72: {
            towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
            ellipse: "intl",
            datumName: "Reseau National Belge 1972"
          }
        };
        for (var key in datums) {
          var datum = datums[key];
          datums[datum.datumName] = datum;
        }
        function datum$1(datumCode, datum_params, a, b, es, ep2, nadgrids) {
          var out = {};
          if (datumCode === void 0 || datumCode === "none") {
            out.datum_type = PJD_NODATUM;
          } else {
            out.datum_type = PJD_WGS84;
          }
          if (datum_params) {
            out.datum_params = datum_params.map(parseFloat);
            if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
              out.datum_type = PJD_3PARAM;
            }
            if (out.datum_params.length > 3) {
              if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
                out.datum_type = PJD_7PARAM;
                out.datum_params[3] *= SEC_TO_RAD;
                out.datum_params[4] *= SEC_TO_RAD;
                out.datum_params[5] *= SEC_TO_RAD;
                out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
              }
            }
          }
          if (nadgrids) {
            out.datum_type = PJD_GRIDSHIFT;
            out.grids = nadgrids;
          }
          out.a = a;
          out.b = b;
          out.es = es;
          out.ep2 = ep2;
          return out;
        }
        var loadedNadgrids = {};
        function nadgrid(key2, data) {
          var view = new DataView(data);
          var isLittleEndian = detectLittleEndian(view);
          var header = readHeader(view, isLittleEndian);
          var subgrids = readSubgrids(view, header, isLittleEndian);
          var nadgrid2 = { header, subgrids };
          loadedNadgrids[key2] = nadgrid2;
          return nadgrid2;
        }
        function getNadgrids(nadgrids) {
          if (nadgrids === void 0) {
            return null;
          }
          var grids = nadgrids.split(",");
          return grids.map(parseNadgridString);
        }
        function parseNadgridString(value) {
          if (value.length === 0) {
            return null;
          }
          var optional = value[0] === "@";
          if (optional) {
            value = value.slice(1);
          }
          if (value === "null") {
            return { name: "null", mandatory: !optional, grid: null, isNull: true };
          }
          return {
            name: value,
            mandatory: !optional,
            grid: loadedNadgrids[value] || null,
            isNull: false
          };
        }
        function secondsToRadians(seconds) {
          return seconds / 3600 * Math.PI / 180;
        }
        function detectLittleEndian(view) {
          var nFields = view.getInt32(8, false);
          if (nFields === 11) {
            return false;
          }
          nFields = view.getInt32(8, true);
          if (nFields !== 11) {
            console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
          }
          return true;
        }
        function readHeader(view, isLittleEndian) {
          return {
            nFields: view.getInt32(8, isLittleEndian),
            nSubgridFields: view.getInt32(24, isLittleEndian),
            nSubgrids: view.getInt32(40, isLittleEndian),
            shiftType: decodeString(view, 56, 56 + 8).trim(),
            fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
            fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
            toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
            toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
          };
        }
        function decodeString(view, start2, end) {
          return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
        }
        function readSubgrids(view, header, isLittleEndian) {
          var gridOffset = 176;
          var grids = [];
          for (var i = 0; i < header.nSubgrids; i++) {
            var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
            var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
            var lngColumnCount = Math.round(
              1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
            );
            var latColumnCount = Math.round(
              1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
            );
            grids.push({
              ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
              del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
              lim: [lngColumnCount, latColumnCount],
              count: subHeader.gridNodeCount,
              cvs: mapNodes(nodes)
            });
            gridOffset += 176 + subHeader.gridNodeCount * 16;
          }
          return grids;
        }
        function mapNodes(nodes) {
          return nodes.map(function(r) {
            return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
          });
        }
        function readGridHeader(view, offset, isLittleEndian) {
          return {
            name: decodeString(view, offset + 8, offset + 16).trim(),
            parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
            lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
            upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
            lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
            upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
            latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
            longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
            gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
          };
        }
        function readGridNodes(view, offset, gridHeader, isLittleEndian) {
          var nodesOffset = offset + 176;
          var gridRecordLength = 16;
          var gridShiftRecords = [];
          for (var i = 0; i < gridHeader.gridNodeCount; i++) {
            var record = {
              latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
              longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
              latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
              longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
            };
            gridShiftRecords.push(record);
          }
          return gridShiftRecords;
        }
        function Projection(srsCode, callback) {
          if (!(this instanceof Projection)) {
            return new Projection(srsCode);
          }
          callback = callback || function(error) {
            if (error) {
              throw error;
            }
          };
          var json = parse(srsCode);
          if (typeof json !== "object") {
            callback("Could not parse to valid json: " + srsCode);
            return;
          }
          var ourProj = Projection.projections.get(json.projName);
          if (!ourProj) {
            callback("Could not get projection name from: " + srsCode);
            return;
          }
          if (json.datumCode && json.datumCode !== "none") {
            var datumDef = match(datums, json.datumCode);
            if (datumDef) {
              json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
              json.ellps = datumDef.ellipse;
              json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
            }
          }
          json.k0 = json.k0 || 1;
          json.axis = json.axis || "enu";
          json.ellps = json.ellps || "wgs84";
          json.lat1 = json.lat1 || json.lat0;
          var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
          var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
          var nadgrids = getNadgrids(json.nadgrids);
          var datumObj = json.datum || datum$1(
            json.datumCode,
            json.datum_params,
            sphere_.a,
            sphere_.b,
            ecc.es,
            ecc.ep2,
            nadgrids
          );
          extend(this, json);
          extend(this, ourProj);
          this.a = sphere_.a;
          this.b = sphere_.b;
          this.rf = sphere_.rf;
          this.sphere = sphere_.sphere;
          this.es = ecc.es;
          this.e = ecc.e;
          this.ep2 = ecc.ep2;
          this.datum = datumObj;
          this.init();
          callback(null, this);
        }
        Projection.projections = projections;
        Projection.projections.start();
        "use strict";
        function compareDatums(source, dest) {
          if (source.datum_type !== dest.datum_type) {
            return false;
          } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
            return false;
          } else if (source.datum_type === PJD_3PARAM) {
            return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
          } else if (source.datum_type === PJD_7PARAM) {
            return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
          } else {
            return true;
          }
        }
        function geodeticToGeocentric(p, es, a) {
          var Longitude = p.x;
          var Latitude = p.y;
          var Height = p.z ? p.z : 0;
          var Rn;
          var Sin_Lat;
          var Sin2_Lat;
          var Cos_Lat;
          if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
            Latitude = -HALF_PI;
          } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
            Latitude = HALF_PI;
          } else if (Latitude < -HALF_PI) {
            return { x: -Infinity, y: -Infinity, z: p.z };
          } else if (Latitude > HALF_PI) {
            return { x: Infinity, y: Infinity, z: p.z };
          }
          if (Longitude > Math.PI) {
            Longitude -= 2 * Math.PI;
          }
          Sin_Lat = Math.sin(Latitude);
          Cos_Lat = Math.cos(Latitude);
          Sin2_Lat = Sin_Lat * Sin_Lat;
          Rn = a / Math.sqrt(1 - es * Sin2_Lat);
          return {
            x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
            y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
            z: (Rn * (1 - es) + Height) * Sin_Lat
          };
        }
        function geocentricToGeodetic(p, es, a, b) {
          var genau = 1e-12;
          var genau2 = genau * genau;
          var maxiter = 30;
          var P;
          var RR;
          var CT;
          var ST;
          var RX;
          var RK;
          var RN;
          var CPHI0;
          var SPHI0;
          var CPHI;
          var SPHI;
          var SDPHI;
          var iter;
          var X = p.x;
          var Y = p.y;
          var Z2 = p.z ? p.z : 0;
          var Longitude;
          var Latitude;
          var Height;
          P = Math.sqrt(X * X + Y * Y);
          RR = Math.sqrt(X * X + Y * Y + Z2 * Z2);
          if (P / a < genau) {
            Longitude = 0;
            if (RR / a < genau) {
              Latitude = HALF_PI;
              Height = -b;
              return {
                x: p.x,
                y: p.y,
                z: p.z
              };
            }
          } else {
            Longitude = Math.atan2(Y, X);
          }
          CT = Z2 / RR;
          ST = P / RR;
          RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
          CPHI0 = ST * (1 - es) * RX;
          SPHI0 = CT * RX;
          iter = 0;
          do {
            iter++;
            RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
            Height = P * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
            RK = es * RN / (RN + Height);
            RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
            CPHI = ST * (1 - RK) * RX;
            SPHI = CT * RX;
            SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
            CPHI0 = CPHI;
            SPHI0 = SPHI;
          } while (SDPHI * SDPHI > genau2 && iter < maxiter);
          Latitude = Math.atan(SPHI / Math.abs(CPHI));
          return {
            x: Longitude,
            y: Latitude,
            z: Height
          };
        }
        function geocentricToWgs84(p, datum_type, datum_params) {
          if (datum_type === PJD_3PARAM) {
            return {
              x: p.x + datum_params[0],
              y: p.y + datum_params[1],
              z: p.z + datum_params[2]
            };
          } else if (datum_type === PJD_7PARAM) {
            var Dx_BF = datum_params[0];
            var Dy_BF = datum_params[1];
            var Dz_BF = datum_params[2];
            var Rx_BF = datum_params[3];
            var Ry_BF = datum_params[4];
            var Rz_BF = datum_params[5];
            var M_BF = datum_params[6];
            return {
              x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
              y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
              z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
            };
          }
        }
        function geocentricFromWgs84(p, datum_type, datum_params) {
          if (datum_type === PJD_3PARAM) {
            return {
              x: p.x - datum_params[0],
              y: p.y - datum_params[1],
              z: p.z - datum_params[2]
            };
          } else if (datum_type === PJD_7PARAM) {
            var Dx_BF = datum_params[0];
            var Dy_BF = datum_params[1];
            var Dz_BF = datum_params[2];
            var Rx_BF = datum_params[3];
            var Ry_BF = datum_params[4];
            var Rz_BF = datum_params[5];
            var M_BF = datum_params[6];
            var x_tmp = (p.x - Dx_BF) / M_BF;
            var y_tmp = (p.y - Dy_BF) / M_BF;
            var z_tmp = (p.z - Dz_BF) / M_BF;
            return {
              x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
              y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
              z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
            };
          }
        }
        function checkParams(type) {
          return type === PJD_3PARAM || type === PJD_7PARAM;
        }
        var datum_transform = function(source, dest, point) {
          if (compareDatums(source, dest)) {
            return point;
          }
          if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
            return point;
          }
          var source_a = source.a;
          var source_es = source.es;
          if (source.datum_type === PJD_GRIDSHIFT) {
            var gridShiftCode = applyGridShift(source, false, point);
            if (gridShiftCode !== 0) {
              return void 0;
            }
            source_a = SRS_WGS84_SEMIMAJOR;
            source_es = SRS_WGS84_ESQUARED;
          }
          var dest_a = dest.a;
          var dest_b = dest.b;
          var dest_es = dest.es;
          if (dest.datum_type === PJD_GRIDSHIFT) {
            dest_a = SRS_WGS84_SEMIMAJOR;
            dest_b = SRS_WGS84_SEMIMINOR;
            dest_es = SRS_WGS84_ESQUARED;
          }
          if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
            return point;
          }
          point = geodeticToGeocentric(point, source_es, source_a);
          if (checkParams(source.datum_type)) {
            point = geocentricToWgs84(point, source.datum_type, source.datum_params);
          }
          if (checkParams(dest.datum_type)) {
            point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
          }
          point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
          if (dest.datum_type === PJD_GRIDSHIFT) {
            var destGridShiftResult = applyGridShift(dest, true, point);
            if (destGridShiftResult !== 0) {
              return void 0;
            }
          }
          return point;
        };
        function applyGridShift(source, inverse2, point) {
          if (source.grids === null || source.grids.length === 0) {
            console.log("Grid shift grids not found");
            return -1;
          }
          var input = { x: -point.x, y: point.y };
          var output = { x: Number.NaN, y: Number.NaN };
          var attemptedGrids = [];
          outer:
            for (var i = 0; i < source.grids.length; i++) {
              var grid = source.grids[i];
              attemptedGrids.push(grid.name);
              if (grid.isNull) {
                output = input;
                break;
              }
              if (grid.grid === null) {
                if (grid.mandatory) {
                  console.log("Unable to find mandatory grid '" + grid.name + "'");
                  return -1;
                }
                continue;
              }
              var subgrids = grid.grid.subgrids;
              for (var j = 0, jj = subgrids.length; j < jj; j++) {
                var subgrid = subgrids[j];
                var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
                var minX = subgrid.ll[0] - epsilon;
                var minY = subgrid.ll[1] - epsilon;
                var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
                var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
                if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
                  continue;
                }
                output = applySubgridShift(input, inverse2, subgrid);
                if (!isNaN(output.x)) {
                  break outer;
                }
              }
            }
          if (isNaN(output.x)) {
            console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
            return -1;
          }
          point.x = -output.x;
          point.y = output.y;
          return 0;
        }
        function applySubgridShift(pin, inverse2, ct) {
          var val = { x: Number.NaN, y: Number.NaN };
          if (isNaN(pin.x)) {
            return val;
          }
          var tb = { x: pin.x, y: pin.y };
          tb.x -= ct.ll[0];
          tb.y -= ct.ll[1];
          tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
          var t = nadInterpolate(tb, ct);
          if (inverse2) {
            if (isNaN(t.x)) {
              return val;
            }
            t.x = tb.x - t.x;
            t.y = tb.y - t.y;
            var i = 9, tol = 1e-12;
            var dif, del;
            do {
              del = nadInterpolate(t, ct);
              if (isNaN(del.x)) {
                console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
                break;
              }
              dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
              t.x += dif.x;
              t.y += dif.y;
            } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
            if (i < 0) {
              console.log("Inverse grid shift iterator failed to converge.");
              return val;
            }
            val.x = adjust_lon(t.x + ct.ll[0]);
            val.y = t.y + ct.ll[1];
          } else {
            if (!isNaN(t.x)) {
              val.x = pin.x + t.x;
              val.y = pin.y + t.y;
            }
          }
          return val;
        }
        function nadInterpolate(pin, ct) {
          var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
          var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
          var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
          var val = { x: Number.NaN, y: Number.NaN };
          var inx;
          if (indx.x < 0 || indx.x >= ct.lim[0]) {
            return val;
          }
          if (indx.y < 0 || indx.y >= ct.lim[1]) {
            return val;
          }
          inx = indx.y * ct.lim[0] + indx.x;
          var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
          inx++;
          var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
          inx += ct.lim[0];
          var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
          inx--;
          var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
          var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
          val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
          val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
          return val;
        }
        var adjust_axis = function(crs, denorm, point) {
          var xin = point.x, yin = point.y, zin = point.z || 0;
          var v, t, i;
          var out = {};
          for (i = 0; i < 3; i++) {
            if (denorm && i === 2 && point.z === void 0) {
              continue;
            }
            if (i === 0) {
              v = xin;
              if ("ew".indexOf(crs.axis[i]) !== -1) {
                t = "x";
              } else {
                t = "y";
              }
            } else if (i === 1) {
              v = yin;
              if ("ns".indexOf(crs.axis[i]) !== -1) {
                t = "y";
              } else {
                t = "x";
              }
            } else {
              v = zin;
              t = "z";
            }
            switch (crs.axis[i]) {
              case "e":
                out[t] = v;
                break;
              case "w":
                out[t] = -v;
                break;
              case "n":
                out[t] = v;
                break;
              case "s":
                out[t] = -v;
                break;
              case "u":
                if (point[t] !== void 0) {
                  out.z = v;
                }
                break;
              case "d":
                if (point[t] !== void 0) {
                  out.z = -v;
                }
                break;
              default:
                return null;
            }
          }
          return out;
        };
        var toPoint = function(array) {
          var out = {
            x: array[0],
            y: array[1]
          };
          if (array.length > 2) {
            out.z = array[2];
          }
          if (array.length > 3) {
            out.m = array[3];
          }
          return out;
        };
        var checkSanity = function(point) {
          checkCoord(point.x);
          checkCoord(point.y);
        };
        function checkCoord(num) {
          if (typeof Number.isFinite === "function") {
            if (Number.isFinite(num)) {
              return;
            }
            throw new TypeError("coordinates must be finite numbers");
          }
          if (typeof num !== "number" || num !== num || !isFinite(num)) {
            throw new TypeError("coordinates must be finite numbers");
          }
        }
        function checkNotWGS(source, dest) {
          return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== "WGS84";
        }
        function transform(source, dest, point, enforceAxis) {
          var wgs842;
          if (Array.isArray(point)) {
            point = toPoint(point);
          } else {
            point = {
              x: point.x,
              y: point.y,
              z: point.z,
              m: point.m
            };
          }
          var hasZ = point.z !== void 0;
          checkSanity(point);
          if (source.datum && dest.datum && checkNotWGS(source, dest)) {
            wgs842 = new Projection("WGS84");
            point = transform(source, wgs842, point, enforceAxis);
            source = wgs842;
          }
          if (enforceAxis && source.axis !== "enu") {
            point = adjust_axis(source, false, point);
          }
          if (source.projName === "longlat") {
            point = {
              x: point.x * D2R,
              y: point.y * D2R,
              z: point.z || 0
            };
          } else {
            if (source.to_meter) {
              point = {
                x: point.x * source.to_meter,
                y: point.y * source.to_meter,
                z: point.z || 0
              };
            }
            point = source.inverse(point);
            if (!point) {
              return;
            }
          }
          if (source.from_greenwich) {
            point.x += source.from_greenwich;
          }
          point = datum_transform(source.datum, dest.datum, point);
          if (!point) {
            return;
          }
          if (dest.from_greenwich) {
            point = {
              x: point.x - dest.from_greenwich,
              y: point.y,
              z: point.z || 0
            };
          }
          if (dest.projName === "longlat") {
            point = {
              x: point.x * R2D,
              y: point.y * R2D,
              z: point.z || 0
            };
          } else {
            point = dest.forward(point);
            if (dest.to_meter) {
              point = {
                x: point.x / dest.to_meter,
                y: point.y / dest.to_meter,
                z: point.z || 0
              };
            }
          }
          if (enforceAxis && dest.axis !== "enu") {
            return adjust_axis(dest, true, point);
          }
          if (point && !hasZ) {
            delete point.z;
          }
          return point;
        }
        var wgs84 = Projection("WGS84");
        function transformer(from, to, coords, enforceAxis) {
          var transformedArray, out, keys;
          if (Array.isArray(coords)) {
            transformedArray = transform(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
            if (coords.length > 2) {
              if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
                if (typeof transformedArray.z === "number") {
                  return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.slice(3));
                } else {
                  return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.slice(3));
                }
              } else {
                return [transformedArray.x, transformedArray.y].concat(coords.slice(2));
              }
            } else {
              return [transformedArray.x, transformedArray.y];
            }
          } else {
            out = transform(from, to, coords, enforceAxis);
            keys = Object.keys(coords);
            if (keys.length === 2) {
              return out;
            }
            keys.forEach(function(key2) {
              if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
                if (key2 === "x" || key2 === "y" || key2 === "z") {
                  return;
                }
              } else {
                if (key2 === "x" || key2 === "y") {
                  return;
                }
              }
              out[key2] = coords[key2];
            });
            return out;
          }
        }
        function checkProj(item) {
          if (item instanceof Projection) {
            return item;
          }
          if (item.oProj) {
            return item.oProj;
          }
          return Projection(item);
        }
        function proj4$1(fromProj, toProj, coord) {
          fromProj = checkProj(fromProj);
          var single = false;
          var obj;
          if (typeof toProj === "undefined") {
            toProj = fromProj;
            fromProj = wgs84;
            single = true;
          } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
            coord = toProj;
            toProj = fromProj;
            fromProj = wgs84;
            single = true;
          }
          toProj = checkProj(toProj);
          if (coord) {
            return transformer(fromProj, toProj, coord);
          } else {
            obj = {
              forward: function(coords, enforceAxis) {
                return transformer(fromProj, toProj, coords, enforceAxis);
              },
              inverse: function(coords, enforceAxis) {
                return transformer(toProj, fromProj, coords, enforceAxis);
              }
            };
            if (single) {
              obj.oProj = toProj;
            }
            return obj;
          }
        }
        var NUM_100K_SETS = 6;
        var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
        var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
        var A = 65;
        var I = 73;
        var O = 79;
        var V = 86;
        var Z = 90;
        var mgrs = {
          forward: forward$1,
          inverse: inverse$1,
          toPoint: toPoint$1
        };
        function forward$1(ll, accuracy) {
          accuracy = accuracy || 5;
          return encode(LLtoUTM({
            lat: ll[1],
            lon: ll[0]
          }), accuracy);
        }
        function inverse$1(mgrs2) {
          var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
          if (bbox.lat && bbox.lon) {
            return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
          }
          return [bbox.left, bbox.bottom, bbox.right, bbox.top];
        }
        function toPoint$1(mgrs2) {
          var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
          if (bbox.lat && bbox.lon) {
            return [bbox.lon, bbox.lat];
          }
          return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
        }
        function degToRad(deg) {
          return deg * (Math.PI / 180);
        }
        function radToDeg(rad) {
          return 180 * (rad / Math.PI);
        }
        function LLtoUTM(ll) {
          var Lat = ll.lat;
          var Long = ll.lon;
          var a = 6378137;
          var eccSquared = 669438e-8;
          var k0 = 0.9996;
          var LongOrigin;
          var eccPrimeSquared;
          var N, T, C, A5, M2;
          var LatRad = degToRad(Lat);
          var LongRad = degToRad(Long);
          var LongOriginRad;
          var ZoneNumber;
          ZoneNumber = Math.floor((Long + 180) / 6) + 1;
          if (Long === 180) {
            ZoneNumber = 60;
          }
          if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
            ZoneNumber = 32;
          }
          if (Lat >= 72 && Lat < 84) {
            if (Long >= 0 && Long < 9) {
              ZoneNumber = 31;
            } else if (Long >= 9 && Long < 21) {
              ZoneNumber = 33;
            } else if (Long >= 21 && Long < 33) {
              ZoneNumber = 35;
            } else if (Long >= 33 && Long < 42) {
              ZoneNumber = 37;
            }
          }
          LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
          LongOriginRad = degToRad(LongOrigin);
          eccPrimeSquared = eccSquared / (1 - eccSquared);
          N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
          T = Math.tan(LatRad) * Math.tan(LatRad);
          C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
          A5 = Math.cos(LatRad) * (LongRad - LongOriginRad);
          M2 = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
          var UTMEasting = k0 * N * (A5 + (1 - T + C) * A5 * A5 * A5 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 / 120) + 5e5;
          var UTMNorthing = k0 * (M2 + N * Math.tan(LatRad) * (A5 * A5 / 2 + (5 - T + 9 * C + 4 * C * C) * A5 * A5 * A5 * A5 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 * A5 / 720));
          if (Lat < 0) {
            UTMNorthing += 1e7;
          }
          return {
            northing: Math.round(UTMNorthing),
            easting: Math.round(UTMEasting),
            zoneNumber: ZoneNumber,
            zoneLetter: getLetterDesignator(Lat)
          };
        }
        function UTMtoLL(utm2) {
          var UTMNorthing = utm2.northing;
          var UTMEasting = utm2.easting;
          var zoneLetter = utm2.zoneLetter;
          var zoneNumber = utm2.zoneNumber;
          if (zoneNumber < 0 || zoneNumber > 60) {
            return null;
          }
          var k0 = 0.9996;
          var a = 6378137;
          var eccSquared = 669438e-8;
          var eccPrimeSquared;
          var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
          var N1, T1, C12, R1, D, M2;
          var LongOrigin;
          var mu, phi1Rad;
          var x = UTMEasting - 5e5;
          var y = UTMNorthing;
          if (zoneLetter < "N") {
            y -= 1e7;
          }
          LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
          eccPrimeSquared = eccSquared / (1 - eccSquared);
          M2 = y / k0;
          mu = M2 / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
          phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
          N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
          T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
          C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
          R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
          D = x / (N1 * k0);
          var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D * D * D * D * D * D / 720);
          lat = radToDeg(lat);
          var lon = (D - (1 + 2 * T1 + C12) * D * D * D / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
          lon = LongOrigin + radToDeg(lon);
          var result;
          if (utm2.accuracy) {
            var topRight = UTMtoLL({
              northing: utm2.northing + utm2.accuracy,
              easting: utm2.easting + utm2.accuracy,
              zoneLetter: utm2.zoneLetter,
              zoneNumber: utm2.zoneNumber
            });
            result = {
              top: topRight.lat,
              right: topRight.lon,
              bottom: lat,
              left: lon
            };
          } else {
            result = {
              lat,
              lon
            };
          }
          return result;
        }
        function getLetterDesignator(lat) {
          var LetterDesignator = "Z";
          if (84 >= lat && lat >= 72) {
            LetterDesignator = "X";
          } else if (72 > lat && lat >= 64) {
            LetterDesignator = "W";
          } else if (64 > lat && lat >= 56) {
            LetterDesignator = "V";
          } else if (56 > lat && lat >= 48) {
            LetterDesignator = "U";
          } else if (48 > lat && lat >= 40) {
            LetterDesignator = "T";
          } else if (40 > lat && lat >= 32) {
            LetterDesignator = "S";
          } else if (32 > lat && lat >= 24) {
            LetterDesignator = "R";
          } else if (24 > lat && lat >= 16) {
            LetterDesignator = "Q";
          } else if (16 > lat && lat >= 8) {
            LetterDesignator = "P";
          } else if (8 > lat && lat >= 0) {
            LetterDesignator = "N";
          } else if (0 > lat && lat >= -8) {
            LetterDesignator = "M";
          } else if (-8 > lat && lat >= -16) {
            LetterDesignator = "L";
          } else if (-16 > lat && lat >= -24) {
            LetterDesignator = "K";
          } else if (-24 > lat && lat >= -32) {
            LetterDesignator = "J";
          } else if (-32 > lat && lat >= -40) {
            LetterDesignator = "H";
          } else if (-40 > lat && lat >= -48) {
            LetterDesignator = "G";
          } else if (-48 > lat && lat >= -56) {
            LetterDesignator = "F";
          } else if (-56 > lat && lat >= -64) {
            LetterDesignator = "E";
          } else if (-64 > lat && lat >= -72) {
            LetterDesignator = "D";
          } else if (-72 > lat && lat >= -80) {
            LetterDesignator = "C";
          }
          return LetterDesignator;
        }
        function encode(utm2, accuracy) {
          var seasting = "00000" + utm2.easting, snorthing = "00000" + utm2.northing;
          return utm2.zoneNumber + utm2.zoneLetter + get100kID(utm2.easting, utm2.northing, utm2.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
        }
        function get100kID(easting, northing, zoneNumber) {
          var setParm = get100kSetForZone(zoneNumber);
          var setColumn = Math.floor(easting / 1e5);
          var setRow = Math.floor(northing / 1e5) % 20;
          return getLetter100kID(setColumn, setRow, setParm);
        }
        function get100kSetForZone(i) {
          var setParm = i % NUM_100K_SETS;
          if (setParm === 0) {
            setParm = NUM_100K_SETS;
          }
          return setParm;
        }
        function getLetter100kID(column, row, parm) {
          var index = parm - 1;
          var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
          var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
          var colInt = colOrigin + column - 1;
          var rowInt = rowOrigin + row;
          var rollover = false;
          if (colInt > Z) {
            colInt = colInt - Z + A - 1;
            rollover = true;
          }
          if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
            colInt++;
          }
          if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
            colInt++;
            if (colInt === I) {
              colInt++;
            }
          }
          if (colInt > Z) {
            colInt = colInt - Z + A - 1;
          }
          if (rowInt > V) {
            rowInt = rowInt - V + A - 1;
            rollover = true;
          } else {
            rollover = false;
          }
          if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
            rowInt++;
          }
          if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
            rowInt++;
            if (rowInt === I) {
              rowInt++;
            }
          }
          if (rowInt > V) {
            rowInt = rowInt - V + A - 1;
          }
          var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
          return twoLetter;
        }
        function decode(mgrsString) {
          if (mgrsString && mgrsString.length === 0) {
            throw "MGRSPoint coverting from nothing";
          }
          var length = mgrsString.length;
          var hunK = null;
          var sb = "";
          var testChar;
          var i = 0;
          while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
            if (i >= 2) {
              throw "MGRSPoint bad conversion from: " + mgrsString;
            }
            sb += testChar;
            i++;
          }
          var zoneNumber = parseInt(sb, 10);
          if (i === 0 || i + 3 > length) {
            throw "MGRSPoint bad conversion from: " + mgrsString;
          }
          var zoneLetter = mgrsString.charAt(i++);
          if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
            throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
          }
          hunK = mgrsString.substring(i, i += 2);
          var set = get100kSetForZone(zoneNumber);
          var east100k = getEastingFromChar(hunK.charAt(0), set);
          var north100k = getNorthingFromChar(hunK.charAt(1), set);
          while (north100k < getMinNorthing(zoneLetter)) {
            north100k += 2e6;
          }
          var remainder = length - i;
          if (remainder % 2 !== 0) {
            throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
          }
          var sep = remainder / 2;
          var sepEasting = 0;
          var sepNorthing = 0;
          var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
          if (sep > 0) {
            accuracyBonus = 1e5 / Math.pow(10, sep);
            sepEastingString = mgrsString.substring(i, i + sep);
            sepEasting = parseFloat(sepEastingString) * accuracyBonus;
            sepNorthingString = mgrsString.substring(i + sep);
            sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
          }
          easting = sepEasting + east100k;
          northing = sepNorthing + north100k;
          return {
            easting,
            northing,
            zoneLetter,
            zoneNumber,
            accuracy: accuracyBonus
          };
        }
        function getEastingFromChar(e, set) {
          var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
          var eastingValue = 1e5;
          var rewindMarker = false;
          while (curCol !== e.charCodeAt(0)) {
            curCol++;
            if (curCol === I) {
              curCol++;
            }
            if (curCol === O) {
              curCol++;
            }
            if (curCol > Z) {
              if (rewindMarker) {
                throw "Bad character: " + e;
              }
              curCol = A;
              rewindMarker = true;
            }
            eastingValue += 1e5;
          }
          return eastingValue;
        }
        function getNorthingFromChar(n, set) {
          if (n > "V") {
            throw "MGRSPoint given invalid Northing " + n;
          }
          var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
          var northingValue = 0;
          var rewindMarker = false;
          while (curRow !== n.charCodeAt(0)) {
            curRow++;
            if (curRow === I) {
              curRow++;
            }
            if (curRow === O) {
              curRow++;
            }
            if (curRow > V) {
              if (rewindMarker) {
                throw "Bad character: " + n;
              }
              curRow = A;
              rewindMarker = true;
            }
            northingValue += 1e5;
          }
          return northingValue;
        }
        function getMinNorthing(zoneLetter) {
          var northing;
          switch (zoneLetter) {
            case "C":
              northing = 11e5;
              break;
            case "D":
              northing = 2e6;
              break;
            case "E":
              northing = 28e5;
              break;
            case "F":
              northing = 37e5;
              break;
            case "G":
              northing = 46e5;
              break;
            case "H":
              northing = 55e5;
              break;
            case "J":
              northing = 64e5;
              break;
            case "K":
              northing = 73e5;
              break;
            case "L":
              northing = 82e5;
              break;
            case "M":
              northing = 91e5;
              break;
            case "N":
              northing = 0;
              break;
            case "P":
              northing = 8e5;
              break;
            case "Q":
              northing = 17e5;
              break;
            case "R":
              northing = 26e5;
              break;
            case "S":
              northing = 35e5;
              break;
            case "T":
              northing = 44e5;
              break;
            case "U":
              northing = 53e5;
              break;
            case "V":
              northing = 62e5;
              break;
            case "W":
              northing = 7e6;
              break;
            case "X":
              northing = 79e5;
              break;
            default:
              northing = -1;
          }
          if (northing >= 0) {
            return northing;
          } else {
            throw "Invalid zone letter: " + zoneLetter;
          }
        }
        function Point(x, y, z) {
          if (!(this instanceof Point)) {
            return new Point(x, y, z);
          }
          if (Array.isArray(x)) {
            this.x = x[0];
            this.y = x[1];
            this.z = x[2] || 0;
          } else if (typeof x === "object") {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z || 0;
          } else if (typeof x === "string" && typeof y === "undefined") {
            var coords = x.split(",");
            this.x = parseFloat(coords[0], 10);
            this.y = parseFloat(coords[1], 10);
            this.z = parseFloat(coords[2], 10) || 0;
          } else {
            this.x = x;
            this.y = y;
            this.z = z || 0;
          }
          console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
        }
        Point.fromMGRS = function(mgrsStr) {
          return new Point(toPoint$1(mgrsStr));
        };
        Point.prototype.toMGRS = function(accuracy) {
          return forward$1([this.x, this.y], accuracy);
        };
        var C00 = 1;
        var C02 = 0.25;
        var C04 = 0.046875;
        var C06 = 0.01953125;
        var C08 = 0.01068115234375;
        var C22 = 0.75;
        var C44 = 0.46875;
        var C46 = 0.013020833333333334;
        var C48 = 0.007120768229166667;
        var C66 = 0.3645833333333333;
        var C68 = 0.005696614583333333;
        var C88 = 0.3076171875;
        var pj_enfn = function(es) {
          var en = [];
          en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
          en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
          var t = es * es;
          en[2] = t * (C44 - es * (C46 + es * C48));
          t *= es;
          en[3] = t * (C66 - es * C68);
          en[4] = t * es * C88;
          return en;
        };
        var pj_mlfn = function(phi, sphi, cphi, en) {
          cphi *= sphi;
          sphi *= sphi;
          return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
        };
        var MAX_ITER = 20;
        var pj_inv_mlfn = function(arg, es, en) {
          var k = 1 / (1 - es);
          var phi = arg;
          for (var i = MAX_ITER; i; --i) {
            var s = Math.sin(phi);
            var t = 1 - es * s * s;
            t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
            phi -= t;
            if (Math.abs(t) < EPSLN) {
              return phi;
            }
          }
          return phi;
        };
        function init$2() {
          this.x0 = this.x0 !== void 0 ? this.x0 : 0;
          this.y0 = this.y0 !== void 0 ? this.y0 : 0;
          this.long0 = this.long0 !== void 0 ? this.long0 : 0;
          this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
          if (this.es) {
            this.en = pj_enfn(this.es);
            this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
          }
        }
        function forward$2(p) {
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          var con;
          var x, y;
          var sin_phi = Math.sin(lat);
          var cos_phi = Math.cos(lat);
          if (!this.es) {
            var b = cos_phi * Math.sin(delta_lon);
            if (Math.abs(Math.abs(b) - 1) < EPSLN) {
              return 93;
            } else {
              x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
              y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
              b = Math.abs(y);
              if (b >= 1) {
                if (b - 1 > EPSLN) {
                  return 93;
                } else {
                  y = 0;
                }
              } else {
                y = Math.acos(y);
              }
              if (lat < 0) {
                y = -y;
              }
              y = this.a * this.k0 * (y - this.lat0) + this.y0;
            }
          } else {
            var al = cos_phi * delta_lon;
            var als = Math.pow(al, 2);
            var c = this.ep2 * Math.pow(cos_phi, 2);
            var cs = Math.pow(c, 2);
            var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
            var t = Math.pow(tq, 2);
            var ts = Math.pow(t, 2);
            con = 1 - this.es * Math.pow(sin_phi, 2);
            al = al / Math.sqrt(con);
            var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
            x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
            y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$2(p) {
          var con, phi;
          var lat, lon;
          var x = (p.x - this.x0) * (1 / this.a);
          var y = (p.y - this.y0) * (1 / this.a);
          if (!this.es) {
            var f = Math.exp(x / this.k0);
            var g = 0.5 * (f - 1 / f);
            var temp = this.lat0 + y / this.k0;
            var h = Math.cos(temp);
            con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
            lat = Math.asin(con);
            if (y < 0) {
              lat = -lat;
            }
            if (g === 0 && h === 0) {
              lon = 0;
            } else {
              lon = adjust_lon(Math.atan2(g, h) + this.long0);
            }
          } else {
            con = this.ml0 + y / this.k0;
            phi = pj_inv_mlfn(con, this.es, this.en);
            if (Math.abs(phi) < HALF_PI) {
              var sin_phi = Math.sin(phi);
              var cos_phi = Math.cos(phi);
              var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
              var c = this.ep2 * Math.pow(cos_phi, 2);
              var cs = Math.pow(c, 2);
              var t = Math.pow(tan_phi, 2);
              var ts = Math.pow(t, 2);
              con = 1 - this.es * Math.pow(sin_phi, 2);
              var d = x * Math.sqrt(con) / this.k0;
              var ds = Math.pow(d, 2);
              con = con * tan_phi;
              lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
              lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
            } else {
              lat = HALF_PI * sign(y);
              lon = 0;
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$3 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
        var tmerc = {
          init: init$2,
          forward: forward$2,
          inverse: inverse$2,
          names: names$3
        };
        var sinh = function(x) {
          var r = Math.exp(x);
          r = (r - 1 / r) / 2;
          return r;
        };
        var hypot = function(x, y) {
          x = Math.abs(x);
          y = Math.abs(y);
          var a = Math.max(x, y);
          var b = Math.min(x, y) / (a ? a : 1);
          return a * Math.sqrt(1 + Math.pow(b, 2));
        };
        var log1py = function(x) {
          var y = 1 + x;
          var z = y - 1;
          return z === 0 ? x : x * Math.log(y) / z;
        };
        var asinhy = function(x) {
          var y = Math.abs(x);
          y = log1py(y * (1 + y / (hypot(1, y) + 1)));
          return x < 0 ? -y : y;
        };
        var gatg = function(pp, B) {
          var cos_2B = 2 * Math.cos(2 * B);
          var i = pp.length - 1;
          var h1 = pp[i];
          var h2 = 0;
          var h;
          while (--i >= 0) {
            h = -h2 + cos_2B * h1 + pp[i];
            h2 = h1;
            h1 = h;
          }
          return B + h * Math.sin(2 * B);
        };
        var clens = function(pp, arg_r) {
          var r = 2 * Math.cos(arg_r);
          var i = pp.length - 1;
          var hr1 = pp[i];
          var hr2 = 0;
          var hr;
          while (--i >= 0) {
            hr = -hr2 + r * hr1 + pp[i];
            hr2 = hr1;
            hr1 = hr;
          }
          return Math.sin(arg_r) * hr;
        };
        var cosh = function(x) {
          var r = Math.exp(x);
          r = (r + 1 / r) / 2;
          return r;
        };
        var clens_cmplx = function(pp, arg_r, arg_i) {
          var sin_arg_r = Math.sin(arg_r);
          var cos_arg_r = Math.cos(arg_r);
          var sinh_arg_i = sinh(arg_i);
          var cosh_arg_i = cosh(arg_i);
          var r = 2 * cos_arg_r * cosh_arg_i;
          var i = -2 * sin_arg_r * sinh_arg_i;
          var j = pp.length - 1;
          var hr = pp[j];
          var hi1 = 0;
          var hr1 = 0;
          var hi = 0;
          var hr2;
          var hi2;
          while (--j >= 0) {
            hr2 = hr1;
            hi2 = hi1;
            hr1 = hr;
            hi1 = hi;
            hr = -hr2 + r * hr1 - i * hi1 + pp[j];
            hi = -hi2 + i * hr1 + r * hi1;
          }
          r = sin_arg_r * cosh_arg_i;
          i = cos_arg_r * sinh_arg_i;
          return [r * hr - i * hi, r * hi + i * hr];
        };
        function init$3() {
          if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
            throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
          }
          if (this.approx) {
            tmerc.init.apply(this);
            this.forward = tmerc.forward;
            this.inverse = tmerc.inverse;
          }
          this.x0 = this.x0 !== void 0 ? this.x0 : 0;
          this.y0 = this.y0 !== void 0 ? this.y0 : 0;
          this.long0 = this.long0 !== void 0 ? this.long0 : 0;
          this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
          this.cgb = [];
          this.cbg = [];
          this.utg = [];
          this.gtu = [];
          var f = this.es / (1 + Math.sqrt(1 - this.es));
          var n = f / (2 - f);
          var np = n;
          this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
          this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
          np = np * n;
          this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
          this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
          np = np * n;
          this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
          this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
          np = np * n;
          this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
          this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
          np = np * n;
          this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
          this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
          np = np * n;
          this.cgb[5] = np * (601676 / 22275);
          this.cbg[5] = np * (444337 / 155925);
          np = Math.pow(n, 2);
          this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
          this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
          this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
          this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
          this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
          np = np * n;
          this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
          this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
          np = np * n;
          this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
          this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
          np = np * n;
          this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
          this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
          np = np * n;
          this.utg[5] = np * (-20648693 / 638668800);
          this.gtu[5] = np * (212378941 / 319334400);
          var Z2 = gatg(this.cbg, this.lat0);
          this.Zb = -this.Qn * (Z2 + clens(this.gtu, 2 * Z2));
        }
        function forward$3(p) {
          var Ce = adjust_lon(p.x - this.long0);
          var Cn = p.y;
          Cn = gatg(this.cbg, Cn);
          var sin_Cn = Math.sin(Cn);
          var cos_Cn = Math.cos(Cn);
          var sin_Ce = Math.sin(Ce);
          var cos_Ce = Math.cos(Ce);
          Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
          Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
          Ce = asinhy(Math.tan(Ce));
          var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
          Cn = Cn + tmp[0];
          Ce = Ce + tmp[1];
          var x;
          var y;
          if (Math.abs(Ce) <= 2.623395162778) {
            x = this.a * (this.Qn * Ce) + this.x0;
            y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
          } else {
            x = Infinity;
            y = Infinity;
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$3(p) {
          var Ce = (p.x - this.x0) * (1 / this.a);
          var Cn = (p.y - this.y0) * (1 / this.a);
          Cn = (Cn - this.Zb) / this.Qn;
          Ce = Ce / this.Qn;
          var lon;
          var lat;
          if (Math.abs(Ce) <= 2.623395162778) {
            var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
            Cn = Cn + tmp[0];
            Ce = Ce + tmp[1];
            Ce = Math.atan(sinh(Ce));
            var sin_Cn = Math.sin(Cn);
            var cos_Cn = Math.cos(Cn);
            var sin_Ce = Math.sin(Ce);
            var cos_Ce = Math.cos(Ce);
            Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
            Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
            lon = adjust_lon(Ce + this.long0);
            lat = gatg(this.cgb, Cn);
          } else {
            lon = Infinity;
            lat = Infinity;
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
        var etmerc = {
          init: init$3,
          forward: forward$3,
          inverse: inverse$3,
          names: names$4
        };
        var adjust_zone = function(zone, lon) {
          if (zone === void 0) {
            zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
            if (zone < 0) {
              return 0;
            } else if (zone > 60) {
              return 60;
            }
          }
          return zone;
        };
        var dependsOn = "etmerc";
        function init$4() {
          var zone = adjust_zone(this.zone, this.long0);
          if (zone === void 0) {
            throw new Error("unknown utm zone");
          }
          this.lat0 = 0;
          this.long0 = (6 * Math.abs(zone) - 183) * D2R;
          this.x0 = 5e5;
          this.y0 = this.utmSouth ? 1e7 : 0;
          this.k0 = 0.9996;
          etmerc.init.apply(this);
          this.forward = etmerc.forward;
          this.inverse = etmerc.inverse;
        }
        var names$5 = ["Universal Transverse Mercator System", "utm"];
        var utm = {
          init: init$4,
          names: names$5,
          dependsOn
        };
        var srat = function(esinp, exp) {
          return Math.pow((1 - esinp) / (1 + esinp), exp);
        };
        var MAX_ITER$1 = 20;
        function init$6() {
          var sphi = Math.sin(this.lat0);
          var cphi = Math.cos(this.lat0);
          cphi *= cphi;
          this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
          this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
          this.phic0 = Math.asin(sphi / this.C);
          this.ratexp = 0.5 * this.C * this.e;
          this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
        }
        function forward$5(p) {
          var lon = p.x;
          var lat = p.y;
          p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
          p.x = this.C * lon;
          return p;
        }
        function inverse$5(p) {
          var DEL_TOL = 1e-14;
          var lon = p.x / this.C;
          var lat = p.y;
          var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
          for (var i = MAX_ITER$1; i > 0; --i) {
            lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
            if (Math.abs(lat - p.y) < DEL_TOL) {
              break;
            }
            p.y = lat;
          }
          if (!i) {
            return null;
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$7 = ["gauss"];
        var gauss = {
          init: init$6,
          forward: forward$5,
          inverse: inverse$5,
          names: names$7
        };
        function init$5() {
          gauss.init.apply(this);
          if (!this.rc) {
            return;
          }
          this.sinc0 = Math.sin(this.phic0);
          this.cosc0 = Math.cos(this.phic0);
          this.R2 = 2 * this.rc;
          if (!this.title) {
            this.title = "Oblique Stereographic Alternative";
          }
        }
        function forward$4(p) {
          var sinc, cosc, cosl, k;
          p.x = adjust_lon(p.x - this.long0);
          gauss.forward.apply(this, [p]);
          sinc = Math.sin(p.y);
          cosc = Math.cos(p.y);
          cosl = Math.cos(p.x);
          k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
          p.x = k * cosc * Math.sin(p.x);
          p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
          p.x = this.a * p.x + this.x0;
          p.y = this.a * p.y + this.y0;
          return p;
        }
        function inverse$4(p) {
          var sinc, cosc, lon, lat, rho;
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          p.x /= this.k0;
          p.y /= this.k0;
          if (rho = hypot(p.x, p.y)) {
            var c = 2 * Math.atan2(rho, this.R2);
            sinc = Math.sin(c);
            cosc = Math.cos(c);
            lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
            lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
          } else {
            lat = this.phic0;
            lon = 0;
          }
          p.x = lon;
          p.y = lat;
          gauss.inverse.apply(this, [p]);
          p.x = adjust_lon(p.x + this.long0);
          return p;
        }
        var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
        var sterea = {
          init: init$5,
          forward: forward$4,
          inverse: inverse$4,
          names: names$6
        };
        function ssfn_(phit, sinphi, eccen) {
          sinphi *= eccen;
          return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
        }
        function init$7() {
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          this.lat0 = this.lat0 || 0;
          this.long0 = this.long0 || 0;
          this.coslat0 = Math.cos(this.lat0);
          this.sinlat0 = Math.sin(this.lat0);
          if (this.sphere) {
            if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
              this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
            }
          } else {
            if (Math.abs(this.coslat0) <= EPSLN) {
              if (this.lat0 > 0) {
                this.con = 1;
              } else {
                this.con = -1;
              }
            }
            this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
            if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN) {
              this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
            }
            this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
            this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
            this.cosX0 = Math.cos(this.X0);
            this.sinX0 = Math.sin(this.X0);
          }
        }
        function forward$6(p) {
          var lon = p.x;
          var lat = p.y;
          var sinlat = Math.sin(lat);
          var coslat = Math.cos(lat);
          var A5, X, sinX, cosX, ts, rh;
          var dlon = adjust_lon(lon - this.long0);
          if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
            p.x = NaN;
            p.y = NaN;
            return p;
          }
          if (this.sphere) {
            A5 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
            p.x = this.a * A5 * coslat * Math.sin(dlon) + this.x0;
            p.y = this.a * A5 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
            return p;
          } else {
            X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
            cosX = Math.cos(X);
            sinX = Math.sin(X);
            if (Math.abs(this.coslat0) <= EPSLN) {
              ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
              rh = 2 * this.a * this.k0 * ts / this.cons;
              p.x = this.x0 + rh * Math.sin(lon - this.long0);
              p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
              return p;
            } else if (Math.abs(this.sinlat0) < EPSLN) {
              A5 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
              p.y = A5 * sinX;
            } else {
              A5 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
              p.y = A5 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
            }
            p.x = A5 * cosX * Math.sin(dlon) + this.x0;
          }
          return p;
        }
        function inverse$6(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon, lat, ts, ce, Chi;
          var rh = Math.sqrt(p.x * p.x + p.y * p.y);
          if (this.sphere) {
            var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
            lon = this.long0;
            lat = this.lat0;
            if (rh <= EPSLN) {
              p.x = lon;
              p.y = lat;
              return p;
            }
            lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
            if (Math.abs(this.coslat0) < EPSLN) {
              if (this.lat0 > 0) {
                lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
              } else {
                lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
              }
            } else {
              lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
            }
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            if (Math.abs(this.coslat0) <= EPSLN) {
              if (rh <= EPSLN) {
                lat = this.lat0;
                lon = this.long0;
                p.x = lon;
                p.y = lat;
                return p;
              }
              p.x *= this.con;
              p.y *= this.con;
              ts = rh * this.cons / (2 * this.a * this.k0);
              lat = this.con * phi2z(this.e, ts);
              lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
            } else {
              ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
              lon = this.long0;
              if (rh <= EPSLN) {
                Chi = this.X0;
              } else {
                Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
                lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
              }
              lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
        var stere = {
          init: init$7,
          forward: forward$6,
          inverse: inverse$6,
          names: names$8,
          ssfn_
        };
        function init$8() {
          var phy0 = this.lat0;
          this.lambda0 = this.long0;
          var sinPhy0 = Math.sin(phy0);
          var semiMajorAxis = this.a;
          var invF = this.rf;
          var flattening = 1 / invF;
          var e2 = 2 * flattening - Math.pow(flattening, 2);
          var e = this.e = Math.sqrt(e2);
          this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
          this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
          this.b0 = Math.asin(sinPhy0 / this.alpha);
          var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
          var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
          var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
          this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
        }
        function forward$7(p) {
          var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
          var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
          var S = -this.alpha * (Sa1 + Sa2) + this.K;
          var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
          var I2 = this.alpha * (p.x - this.lambda0);
          var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
          var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
          p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
          p.x = this.R * rotI + this.x0;
          return p;
        }
        function inverse$7(p) {
          var Y = p.x - this.x0;
          var X = p.y - this.y0;
          var rotI = Y / this.R;
          var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
          var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
          var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
          var lambda = this.lambda0 + I2 / this.alpha;
          var S = 0;
          var phy = b;
          var prevPhy = -1e3;
          var iteration = 0;
          while (Math.abs(phy - prevPhy) > 1e-7) {
            if (++iteration > 20) {
              return;
            }
            S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
            prevPhy = phy;
            phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
          }
          p.x = lambda;
          p.y = phy;
          return p;
        }
        var names$9 = ["somerc"];
        var somerc = {
          init: init$8,
          forward: forward$7,
          inverse: inverse$7,
          names: names$9
        };
        var TOL = 1e-7;
        function isTypeA(P) {
          var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
          var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
          return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1;
        }
        function init$9() {
          var con, com, cosph0, D, F, H, L2, sinph0, p, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
          this.no_off = isTypeA(this);
          this.no_rot = "no_rot" in this;
          var alp = false;
          if ("alpha" in this) {
            alp = true;
          }
          var gam = false;
          if ("rectified_grid_angle" in this) {
            gam = true;
          }
          if (alp) {
            alpha_c = this.alpha;
          }
          if (gam) {
            gamma = this.rectified_grid_angle * D2R;
          }
          if (alp || gam) {
            lamc = this.longc;
          } else {
            lam1 = this.long1;
            phi1 = this.lat1;
            lam2 = this.long2;
            phi2 = this.lat2;
            if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
              throw new Error();
            }
          }
          var one_es = 1 - this.es;
          com = Math.sqrt(one_es);
          if (Math.abs(this.lat0) > EPSLN) {
            sinph0 = Math.sin(this.lat0);
            cosph0 = Math.cos(this.lat0);
            con = 1 - this.es * sinph0 * sinph0;
            this.B = cosph0 * cosph0;
            this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
            this.A = this.B * this.k0 * com / con;
            D = this.B * com / (cosph0 * Math.sqrt(con));
            F = D * D - 1;
            if (F <= 0) {
              F = 0;
            } else {
              F = Math.sqrt(F);
              if (this.lat0 < 0) {
                F = -F;
              }
            }
            this.E = F += D;
            this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
          } else {
            this.B = 1 / com;
            this.A = this.k0;
            this.E = D = F = 1;
          }
          if (alp || gam) {
            if (alp) {
              gamma0 = Math.asin(Math.sin(alpha_c) / D);
              if (!gam) {
                gamma = alpha_c;
              }
            } else {
              gamma0 = gamma;
              alpha_c = Math.asin(D * Math.sin(gamma0));
            }
            this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
          } else {
            H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
            L2 = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
            F = this.E / H;
            p = (L2 - H) / (L2 + H);
            J = this.E * this.E;
            J = (J - L2 * H) / (J + L2 * H);
            con = lam1 - lam2;
            if (con < -Math.pi) {
              lam2 -= TWO_PI;
            } else if (con > Math.pi) {
              lam2 += TWO_PI;
            }
            this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
            gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
            gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
          }
          this.singam = Math.sin(gamma0);
          this.cosgam = Math.cos(gamma0);
          this.sinrot = Math.sin(gamma);
          this.cosrot = Math.cos(gamma);
          this.rB = 1 / this.B;
          this.ArB = this.A * this.rB;
          this.BrA = 1 / this.ArB;
          if (this.no_off) {
            this.u_0 = 0;
          } else {
            this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
            if (this.lat0 < 0) {
              this.u_0 = -this.u_0;
            }
          }
          F = 0.5 * gamma0;
          this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
          this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
        }
        function forward$8(p) {
          var coords = {};
          var S, T, U, V2, W, temp, u, v;
          p.x = p.x - this.lam0;
          if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
            W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
            temp = 1 / W;
            S = 0.5 * (W - temp);
            T = 0.5 * (W + temp);
            V2 = Math.sin(this.B * p.x);
            U = (S * this.singam - V2 * this.cosgam) / T;
            if (Math.abs(Math.abs(U) - 1) < EPSLN) {
              throw new Error();
            }
            v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
            temp = Math.cos(this.B * p.x);
            if (Math.abs(temp) < TOL) {
              u = this.A * p.x;
            } else {
              u = this.ArB * Math.atan2(S * this.cosgam + V2 * this.singam, temp);
            }
          } else {
            v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
            u = this.ArB * p.y;
          }
          if (this.no_rot) {
            coords.x = u;
            coords.y = v;
          } else {
            u -= this.u_0;
            coords.x = v * this.cosrot + u * this.sinrot;
            coords.y = u * this.cosrot - v * this.sinrot;
          }
          coords.x = this.a * coords.x + this.x0;
          coords.y = this.a * coords.y + this.y0;
          return coords;
        }
        function inverse$8(p) {
          var u, v, Qp, Sp, Tp, Vp, Up;
          var coords = {};
          p.x = (p.x - this.x0) * (1 / this.a);
          p.y = (p.y - this.y0) * (1 / this.a);
          if (this.no_rot) {
            v = p.y;
            u = p.x;
          } else {
            v = p.x * this.cosrot - p.y * this.sinrot;
            u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
          }
          Qp = Math.exp(-this.BrA * v);
          Sp = 0.5 * (Qp - 1 / Qp);
          Tp = 0.5 * (Qp + 1 / Qp);
          Vp = Math.sin(this.BrA * u);
          Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
          if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
            coords.x = 0;
            coords.y = Up < 0 ? -HALF_PI : HALF_PI;
          } else {
            coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
            coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
            if (coords.y === Infinity) {
              throw new Error();
            }
            coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
          }
          coords.x += this.lam0;
          return coords;
        }
        var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
        var omerc = {
          init: init$9,
          forward: forward$8,
          inverse: inverse$8,
          names: names$10
        };
        function init$10() {
          if (!this.lat2) {
            this.lat2 = this.lat1;
          }
          if (!this.k0) {
            this.k0 = 1;
          }
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          var temp = this.b / this.a;
          this.e = Math.sqrt(1 - temp * temp);
          var sin1 = Math.sin(this.lat1);
          var cos1 = Math.cos(this.lat1);
          var ms1 = msfnz(this.e, sin1, cos1);
          var ts1 = tsfnz(this.e, this.lat1, sin1);
          var sin2 = Math.sin(this.lat2);
          var cos2 = Math.cos(this.lat2);
          var ms2 = msfnz(this.e, sin2, cos2);
          var ts2 = tsfnz(this.e, this.lat2, sin2);
          var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
          if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
            this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
          } else {
            this.ns = sin1;
          }
          if (isNaN(this.ns)) {
            this.ns = sin1;
          }
          this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
          this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
          if (!this.title) {
            this.title = "Lambert Conformal Conic";
          }
        }
        function forward$9(p) {
          var lon = p.x;
          var lat = p.y;
          if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
            lat = sign(lat) * (HALF_PI - 2 * EPSLN);
          }
          var con = Math.abs(Math.abs(lat) - HALF_PI);
          var ts, rh1;
          if (con > EPSLN) {
            ts = tsfnz(this.e, lat, Math.sin(lat));
            rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
          } else {
            con = lat * this.ns;
            if (con <= 0) {
              return null;
            }
            rh1 = 0;
          }
          var theta = this.ns * adjust_lon(lon - this.long0);
          p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
          p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
          return p;
        }
        function inverse$9(p) {
          var rh1, con, ts;
          var lat, lon;
          var x = (p.x - this.x0) / this.k0;
          var y = this.rh - (p.y - this.y0) / this.k0;
          if (this.ns > 0) {
            rh1 = Math.sqrt(x * x + y * y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(x * x + y * y);
            con = -1;
          }
          var theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * x, con * y);
          }
          if (rh1 !== 0 || this.ns > 0) {
            con = 1 / this.ns;
            ts = Math.pow(rh1 / (this.a * this.f0), con);
            lat = phi2z(this.e, ts);
            if (lat === -9999) {
              return null;
            }
          } else {
            lat = -HALF_PI;
          }
          lon = adjust_lon(theta / this.ns + this.long0);
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$11 = [
          "Lambert Tangential Conformal Conic Projection",
          "Lambert_Conformal_Conic",
          "Lambert_Conformal_Conic_1SP",
          "Lambert_Conformal_Conic_2SP",
          "lcc",
          "Lambert Conic Conformal (1SP)",
          "Lambert Conic Conformal (2SP)"
        ];
        var lcc = {
          init: init$10,
          forward: forward$9,
          inverse: inverse$9,
          names: names$11
        };
        function init$11() {
          this.a = 6377397155e-3;
          this.es = 0.006674372230614;
          this.e = Math.sqrt(this.es);
          if (!this.lat0) {
            this.lat0 = 0.863937979737193;
          }
          if (!this.long0) {
            this.long0 = 0.7417649320975901 - 0.308341501185665;
          }
          if (!this.k0) {
            this.k0 = 0.9999;
          }
          this.s45 = 0.785398163397448;
          this.s90 = 2 * this.s45;
          this.fi0 = this.lat0;
          this.e2 = this.es;
          this.e = Math.sqrt(this.e2);
          this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
          this.uq = 1.04216856380474;
          this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
          this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
          this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
          this.k1 = this.k0;
          this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
          this.s0 = 1.37008346281555;
          this.n = Math.sin(this.s0);
          this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
          this.ad = this.s90 - this.uq;
        }
        function forward$10(p) {
          var gfi, u, deltav, s, d, eps, ro;
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
          u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
          deltav = -delta_lon * this.alfa;
          s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
          d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
          eps = this.n * d;
          ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
          p.y = ro * Math.cos(eps) / 1;
          p.x = ro * Math.sin(eps) / 1;
          if (!this.czech) {
            p.y *= -1;
            p.x *= -1;
          }
          return p;
        }
        function inverse$10(p) {
          var u, deltav, s, d, eps, ro, fi1;
          var ok;
          var tmp = p.x;
          p.x = p.y;
          p.y = tmp;
          if (!this.czech) {
            p.y *= -1;
            p.x *= -1;
          }
          ro = Math.sqrt(p.x * p.x + p.y * p.y);
          eps = Math.atan2(p.y, p.x);
          d = eps / Math.sin(this.s0);
          s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
          u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
          deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
          p.x = this.long0 - deltav / this.alfa;
          fi1 = u;
          ok = 0;
          var iter = 0;
          do {
            p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
            if (Math.abs(fi1 - p.y) < 1e-10) {
              ok = 1;
            }
            fi1 = p.y;
            iter += 1;
          } while (ok === 0 && iter < 15);
          if (iter >= 15) {
            return null;
          }
          return p;
        }
        var names$12 = ["Krovak", "krovak"];
        var krovak = {
          init: init$11,
          forward: forward$10,
          inverse: inverse$10,
          names: names$12
        };
        var mlfn = function(e0, e1, e2, e3, phi) {
          return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
        };
        var e0fn = function(x) {
          return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
        };
        var e1fn = function(x) {
          return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
        };
        var e2fn = function(x) {
          return 0.05859375 * x * x * (1 + 0.75 * x);
        };
        var e3fn = function(x) {
          return x * x * x * (35 / 3072);
        };
        var gN = function(a, e, sinphi) {
          var temp = e * sinphi;
          return a / Math.sqrt(1 - temp * temp);
        };
        var adjust_lat = function(x) {
          return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
        };
        var imlfn = function(ml, e0, e1, e2, e3) {
          var phi;
          var dphi;
          phi = ml / e0;
          for (var i = 0; i < 15; i++) {
            dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return NaN;
        };
        function init$12() {
          if (!this.sphere) {
            this.e0 = e0fn(this.es);
            this.e1 = e1fn(this.es);
            this.e2 = e2fn(this.es);
            this.e3 = e3fn(this.es);
            this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
          }
        }
        function forward$11(p) {
          var x, y;
          var lam = p.x;
          var phi = p.y;
          lam = adjust_lon(lam - this.long0);
          if (this.sphere) {
            x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
            y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
          } else {
            var sinphi = Math.sin(phi);
            var cosphi = Math.cos(phi);
            var nl = gN(this.a, this.e, sinphi);
            var tl = Math.tan(phi) * Math.tan(phi);
            var al = lam * Math.cos(phi);
            var asq = al * al;
            var cl = this.es * cosphi * cosphi / (1 - this.es);
            var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
            x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
            y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
          }
          p.x = x + this.x0;
          p.y = y + this.y0;
          return p;
        }
        function inverse$11(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var x = p.x / this.a;
          var y = p.y / this.a;
          var phi, lam;
          if (this.sphere) {
            var dd = y + this.lat0;
            phi = Math.asin(Math.sin(dd) * Math.cos(x));
            lam = Math.atan2(Math.tan(x), Math.cos(dd));
          } else {
            var ml1 = this.ml0 / this.a + y;
            var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
            if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
              p.x = this.long0;
              p.y = HALF_PI;
              if (y < 0) {
                p.y *= -1;
              }
              return p;
            }
            var nl1 = gN(this.a, this.e, Math.sin(phi1));
            var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
            var tl1 = Math.pow(Math.tan(phi1), 2);
            var dl = x * this.a / nl1;
            var dsq = dl * dl;
            phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
            lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
          }
          p.x = adjust_lon(lam + this.long0);
          p.y = adjust_lat(phi);
          return p;
        }
        var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
        var cass = {
          init: init$12,
          forward: forward$11,
          inverse: inverse$11,
          names: names$13
        };
        var qsfnz = function(eccent, sinphi) {
          var con;
          if (eccent > 1e-7) {
            con = eccent * sinphi;
            return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
          } else {
            return 2 * sinphi;
          }
        };
        var S_POLE = 1;
        var N_POLE = 2;
        var EQUIT = 3;
        var OBLIQ = 4;
        function init$13() {
          var t = Math.abs(this.lat0);
          if (Math.abs(t - HALF_PI) < EPSLN) {
            this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
          } else if (Math.abs(t) < EPSLN) {
            this.mode = this.EQUIT;
          } else {
            this.mode = this.OBLIQ;
          }
          if (this.es > 0) {
            var sinphi;
            this.qp = qsfnz(this.e, 1);
            this.mmf = 0.5 / (1 - this.es);
            this.apa = authset(this.es);
            switch (this.mode) {
              case this.N_POLE:
                this.dd = 1;
                break;
              case this.S_POLE:
                this.dd = 1;
                break;
              case this.EQUIT:
                this.rq = Math.sqrt(0.5 * this.qp);
                this.dd = 1 / this.rq;
                this.xmf = 1;
                this.ymf = 0.5 * this.qp;
                break;
              case this.OBLIQ:
                this.rq = Math.sqrt(0.5 * this.qp);
                sinphi = Math.sin(this.lat0);
                this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
                this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
                this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
                this.ymf = (this.xmf = this.rq) / this.dd;
                this.xmf *= this.dd;
                break;
            }
          } else {
            if (this.mode === this.OBLIQ) {
              this.sinph0 = Math.sin(this.lat0);
              this.cosph0 = Math.cos(this.lat0);
            }
          }
        }
        function forward$12(p) {
          var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
          var lam = p.x;
          var phi = p.y;
          lam = adjust_lon(lam - this.long0);
          if (this.sphere) {
            sinphi = Math.sin(phi);
            cosphi = Math.cos(phi);
            coslam = Math.cos(lam);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
              if (y <= EPSLN) {
                return null;
              }
              y = Math.sqrt(2 / y);
              x = y * cosphi * Math.sin(lam);
              y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
              if (this.mode === this.N_POLE) {
                coslam = -coslam;
              }
              if (Math.abs(phi + this.lat0) < EPSLN) {
                return null;
              }
              y = FORTPI - phi * 0.5;
              y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
              x = y * Math.sin(lam);
              y *= coslam;
            }
          } else {
            sinb = 0;
            cosb = 0;
            b = 0;
            coslam = Math.cos(lam);
            sinlam = Math.sin(lam);
            sinphi = Math.sin(phi);
            q = qsfnz(this.e, sinphi);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              sinb = q / this.qp;
              cosb = Math.sqrt(1 - sinb * sinb);
            }
            switch (this.mode) {
              case this.OBLIQ:
                b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
                break;
              case this.EQUIT:
                b = 1 + cosb * coslam;
                break;
              case this.N_POLE:
                b = HALF_PI + phi;
                q = this.qp - q;
                break;
              case this.S_POLE:
                b = phi - HALF_PI;
                q = this.qp + q;
                break;
            }
            if (Math.abs(b) < EPSLN) {
              return null;
            }
            switch (this.mode) {
              case this.OBLIQ:
              case this.EQUIT:
                b = Math.sqrt(2 / b);
                if (this.mode === this.OBLIQ) {
                  y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
                } else {
                  y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
                }
                x = this.xmf * b * cosb * sinlam;
                break;
              case this.N_POLE:
              case this.S_POLE:
                if (q >= 0) {
                  x = (b = Math.sqrt(q)) * sinlam;
                  y = coslam * (this.mode === this.S_POLE ? b : -b);
                } else {
                  x = y = 0;
                }
                break;
            }
          }
          p.x = this.a * x + this.x0;
          p.y = this.a * y + this.y0;
          return p;
        }
        function inverse$12(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var x = p.x / this.a;
          var y = p.y / this.a;
          var lam, phi, cCe, sCe, q, rho, ab;
          if (this.sphere) {
            var cosz = 0, rh, sinz = 0;
            rh = Math.sqrt(x * x + y * y);
            phi = rh * 0.5;
            if (phi > 1) {
              return null;
            }
            phi = 2 * Math.asin(phi);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              sinz = Math.sin(phi);
              cosz = Math.cos(phi);
            }
            switch (this.mode) {
              case this.EQUIT:
                phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
                x *= sinz;
                y = cosz * rh;
                break;
              case this.OBLIQ:
                phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
                x *= sinz * this.cosph0;
                y = (cosz - Math.sin(phi) * this.sinph0) * rh;
                break;
              case this.N_POLE:
                y = -y;
                phi = HALF_PI - phi;
                break;
              case this.S_POLE:
                phi -= HALF_PI;
                break;
            }
            lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
          } else {
            ab = 0;
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              x /= this.dd;
              y *= this.dd;
              rho = Math.sqrt(x * x + y * y);
              if (rho < EPSLN) {
                p.x = this.long0;
                p.y = this.lat0;
                return p;
              }
              sCe = 2 * Math.asin(0.5 * rho / this.rq);
              cCe = Math.cos(sCe);
              x *= sCe = Math.sin(sCe);
              if (this.mode === this.OBLIQ) {
                ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
                q = this.qp * ab;
                y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
              } else {
                ab = y * sCe / rho;
                q = this.qp * ab;
                y = rho * cCe;
              }
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
              if (this.mode === this.N_POLE) {
                y = -y;
              }
              q = x * x + y * y;
              if (!q) {
                p.x = this.long0;
                p.y = this.lat0;
                return p;
              }
              ab = 1 - q / this.qp;
              if (this.mode === this.S_POLE) {
                ab = -ab;
              }
            }
            lam = Math.atan2(x, y);
            phi = authlat(Math.asin(ab), this.apa);
          }
          p.x = adjust_lon(this.long0 + lam);
          p.y = phi;
          return p;
        }
        var P00 = 0.3333333333333333;
        var P01 = 0.17222222222222222;
        var P02 = 0.10257936507936508;
        var P10 = 0.06388888888888888;
        var P11 = 0.0664021164021164;
        var P20 = 0.016415012942191543;
        function authset(es) {
          var t;
          var APA = [];
          APA[0] = es * P00;
          t = es * es;
          APA[0] += t * P01;
          APA[1] = t * P10;
          t *= es;
          APA[0] += t * P02;
          APA[1] += t * P11;
          APA[2] = t * P20;
          return APA;
        }
        function authlat(beta, APA) {
          var t = beta + beta;
          return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
        }
        var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
        var laea = {
          init: init$13,
          forward: forward$12,
          inverse: inverse$12,
          names: names$14,
          S_POLE,
          N_POLE,
          EQUIT,
          OBLIQ
        };
        var asinz = function(x) {
          if (Math.abs(x) > 1) {
            x = x > 1 ? 1 : -1;
          }
          return Math.asin(x);
        };
        function init$14() {
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e3 = Math.sqrt(this.es);
          this.sin_po = Math.sin(this.lat1);
          this.cos_po = Math.cos(this.lat1);
          this.t1 = this.sin_po;
          this.con = this.sin_po;
          this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
          this.qs1 = qsfnz(this.e3, this.sin_po);
          this.sin_po = Math.sin(this.lat2);
          this.cos_po = Math.cos(this.lat2);
          this.t2 = this.sin_po;
          this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
          this.qs2 = qsfnz(this.e3, this.sin_po);
          this.sin_po = Math.sin(this.lat0);
          this.cos_po = Math.cos(this.lat0);
          this.t3 = this.sin_po;
          this.qs0 = qsfnz(this.e3, this.sin_po);
          if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
            this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
          } else {
            this.ns0 = this.con;
          }
          this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
          this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
        }
        function forward$13(p) {
          var lon = p.x;
          var lat = p.y;
          this.sin_phi = Math.sin(lat);
          this.cos_phi = Math.cos(lat);
          var qs = qsfnz(this.e3, this.sin_phi);
          var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
          var theta = this.ns0 * adjust_lon(lon - this.long0);
          var x = rh1 * Math.sin(theta) + this.x0;
          var y = this.rh - rh1 * Math.cos(theta) + this.y0;
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$13(p) {
          var rh1, qs, con, theta, lon, lat;
          p.x -= this.x0;
          p.y = this.rh - p.y + this.y0;
          if (this.ns0 >= 0) {
            rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
            con = -1;
          }
          theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * p.x, con * p.y);
          }
          con = rh1 * this.ns0 / this.a;
          if (this.sphere) {
            lat = Math.asin((this.c - con * con) / (2 * this.ns0));
          } else {
            qs = (this.c - con * con) / this.ns0;
            lat = this.phi1z(this.e3, qs);
          }
          lon = adjust_lon(theta / this.ns0 + this.long0);
          p.x = lon;
          p.y = lat;
          return p;
        }
        function phi1z(eccent, qs) {
          var sinphi, cosphi, con, com, dphi;
          var phi = asinz(0.5 * qs);
          if (eccent < EPSLN) {
            return phi;
          }
          var eccnts = eccent * eccent;
          for (var i = 1; i <= 25; i++) {
            sinphi = Math.sin(phi);
            cosphi = Math.cos(phi);
            con = eccent * sinphi;
            com = 1 - con * con;
            dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
            phi = phi + dphi;
            if (Math.abs(dphi) <= 1e-7) {
              return phi;
            }
          }
          return null;
        }
        var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
        var aea = {
          init: init$14,
          forward: forward$13,
          inverse: inverse$13,
          names: names$15,
          phi1z
        };
        function init$15() {
          this.sin_p14 = Math.sin(this.lat0);
          this.cos_p14 = Math.cos(this.lat0);
          this.infinity_dist = 1e3 * this.a;
          this.rc = 1;
        }
        function forward$14(p) {
          var sinphi, cosphi;
          var dlon;
          var coslon;
          var ksp;
          var g;
          var x, y;
          var lon = p.x;
          var lat = p.y;
          dlon = adjust_lon(lon - this.long0);
          sinphi = Math.sin(lat);
          cosphi = Math.cos(lat);
          coslon = Math.cos(dlon);
          g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
          ksp = 1;
          if (g > 0 || Math.abs(g) <= EPSLN) {
            x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
            y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
          } else {
            x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
            y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$14(p) {
          var rh;
          var sinc, cosc;
          var c;
          var lon, lat;
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          p.x /= this.k0;
          p.y /= this.k0;
          if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
            c = Math.atan2(rh, this.rc);
            sinc = Math.sin(c);
            cosc = Math.cos(c);
            lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
            lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
            lon = adjust_lon(this.long0 + lon);
          } else {
            lat = this.phic0;
            lon = 0;
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$16 = ["gnom"];
        var gnom = {
          init: init$15,
          forward: forward$14,
          inverse: inverse$14,
          names: names$16
        };
        var iqsfnz = function(eccent, q) {
          var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
          if (Math.abs(Math.abs(q) - temp) < 1e-6) {
            if (q < 0) {
              return -1 * HALF_PI;
            } else {
              return HALF_PI;
            }
          }
          var phi = Math.asin(0.5 * q);
          var dphi;
          var sin_phi;
          var cos_phi;
          var con;
          for (var i = 0; i < 30; i++) {
            sin_phi = Math.sin(phi);
            cos_phi = Math.cos(phi);
            con = eccent * sin_phi;
            dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return NaN;
        };
        function init$16() {
          if (!this.sphere) {
            this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
          }
        }
        function forward$15(p) {
          var lon = p.x;
          var lat = p.y;
          var x, y;
          var dlon = adjust_lon(lon - this.long0);
          if (this.sphere) {
            x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
            y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
          } else {
            var qs = qsfnz(this.e, Math.sin(lat));
            x = this.x0 + this.a * this.k0 * dlon;
            y = this.y0 + this.a * qs * 0.5 / this.k0;
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$15(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon, lat;
          if (this.sphere) {
            lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
            lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
          } else {
            lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
            lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$17 = ["cea"];
        var cea = {
          init: init$16,
          forward: forward$15,
          inverse: inverse$15,
          names: names$17
        };
        function init$17() {
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          this.lat0 = this.lat0 || 0;
          this.long0 = this.long0 || 0;
          this.lat_ts = this.lat_ts || 0;
          this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
          this.rc = Math.cos(this.lat_ts);
        }
        function forward$16(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var dlat = adjust_lat(lat - this.lat0);
          p.x = this.x0 + this.a * dlon * this.rc;
          p.y = this.y0 + this.a * dlat;
          return p;
        }
        function inverse$16(p) {
          var x = p.x;
          var y = p.y;
          p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
          p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
          return p;
        }
        var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
        var eqc = {
          init: init$17,
          forward: forward$16,
          inverse: inverse$16,
          names: names$18
        };
        var MAX_ITER$2 = 20;
        function init$18() {
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e = Math.sqrt(this.es);
          this.e0 = e0fn(this.es);
          this.e1 = e1fn(this.es);
          this.e2 = e2fn(this.es);
          this.e3 = e3fn(this.es);
          this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
        }
        function forward$17(p) {
          var lon = p.x;
          var lat = p.y;
          var x, y, el;
          var dlon = adjust_lon(lon - this.long0);
          el = dlon * Math.sin(lat);
          if (this.sphere) {
            if (Math.abs(lat) <= EPSLN) {
              x = this.a * dlon;
              y = -1 * this.a * this.lat0;
            } else {
              x = this.a * Math.sin(el) / Math.tan(lat);
              y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
            }
          } else {
            if (Math.abs(lat) <= EPSLN) {
              x = this.a * dlon;
              y = -1 * this.ml0;
            } else {
              var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
              x = nl * Math.sin(el);
              y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
            }
          }
          p.x = x + this.x0;
          p.y = y + this.y0;
          return p;
        }
        function inverse$17(p) {
          var lon, lat, x, y, i;
          var al, bl;
          var phi, dphi;
          x = p.x - this.x0;
          y = p.y - this.y0;
          if (this.sphere) {
            if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
              lon = adjust_lon(x / this.a + this.long0);
              lat = 0;
            } else {
              al = this.lat0 + y / this.a;
              bl = x * x / this.a / this.a + al * al;
              phi = al;
              var tanphi;
              for (i = MAX_ITER$2; i; --i) {
                tanphi = Math.tan(phi);
                dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
                phi += dphi;
                if (Math.abs(dphi) <= EPSLN) {
                  lat = phi;
                  break;
                }
              }
              lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
            }
          } else {
            if (Math.abs(y + this.ml0) <= EPSLN) {
              lat = 0;
              lon = adjust_lon(this.long0 + x / this.a);
            } else {
              al = (this.ml0 + y) / this.a;
              bl = x * x / this.a / this.a + al * al;
              phi = al;
              var cl, mln, mlnp, ma;
              var con;
              for (i = MAX_ITER$2; i; --i) {
                con = this.e * Math.sin(phi);
                cl = Math.sqrt(1 - con * con) * Math.tan(phi);
                mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
                mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
                ma = mln / this.a;
                dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
                phi -= dphi;
                if (Math.abs(dphi) <= EPSLN) {
                  lat = phi;
                  break;
                }
              }
              cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
              lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$19 = ["Polyconic", "poly"];
        var poly = {
          init: init$18,
          forward: forward$17,
          inverse: inverse$17,
          names: names$19
        };
        function init$19() {
          this.A = [];
          this.A[1] = 0.6399175073;
          this.A[2] = -0.1358797613;
          this.A[3] = 0.063294409;
          this.A[4] = -0.02526853;
          this.A[5] = 0.0117879;
          this.A[6] = -55161e-7;
          this.A[7] = 26906e-7;
          this.A[8] = -1333e-6;
          this.A[9] = 67e-5;
          this.A[10] = -34e-5;
          this.B_re = [];
          this.B_im = [];
          this.B_re[1] = 0.7557853228;
          this.B_im[1] = 0;
          this.B_re[2] = 0.249204646;
          this.B_im[2] = 3371507e-9;
          this.B_re[3] = -1541739e-9;
          this.B_im[3] = 0.04105856;
          this.B_re[4] = -0.10162907;
          this.B_im[4] = 0.01727609;
          this.B_re[5] = -0.26623489;
          this.B_im[5] = -0.36249218;
          this.B_re[6] = -0.6870983;
          this.B_im[6] = -1.1651967;
          this.C_re = [];
          this.C_im = [];
          this.C_re[1] = 1.3231270439;
          this.C_im[1] = 0;
          this.C_re[2] = -0.577245789;
          this.C_im[2] = -7809598e-9;
          this.C_re[3] = 0.508307513;
          this.C_im[3] = -0.112208952;
          this.C_re[4] = -0.15094762;
          this.C_im[4] = 0.18200602;
          this.C_re[5] = 1.01418179;
          this.C_im[5] = 1.64497696;
          this.C_re[6] = 1.9660549;
          this.C_im[6] = 2.5127645;
          this.D = [];
          this.D[1] = 1.5627014243;
          this.D[2] = 0.5185406398;
          this.D[3] = -0.03333098;
          this.D[4] = -0.1052906;
          this.D[5] = -0.0368594;
          this.D[6] = 7317e-6;
          this.D[7] = 0.0122;
          this.D[8] = 394e-5;
          this.D[9] = -13e-4;
        }
        function forward$18(p) {
          var n;
          var lon = p.x;
          var lat = p.y;
          var delta_lat = lat - this.lat0;
          var delta_lon = lon - this.long0;
          var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
          var d_lambda = delta_lon;
          var d_phi_n = 1;
          var d_psi = 0;
          for (n = 1; n <= 10; n++) {
            d_phi_n = d_phi_n * d_phi;
            d_psi = d_psi + this.A[n] * d_phi_n;
          }
          var th_re = d_psi;
          var th_im = d_lambda;
          var th_n_re = 1;
          var th_n_im = 0;
          var th_n_re1;
          var th_n_im1;
          var z_re = 0;
          var z_im = 0;
          for (n = 1; n <= 6; n++) {
            th_n_re1 = th_n_re * th_re - th_n_im * th_im;
            th_n_im1 = th_n_im * th_re + th_n_re * th_im;
            th_n_re = th_n_re1;
            th_n_im = th_n_im1;
            z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
            z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
          }
          p.x = z_im * this.a + this.x0;
          p.y = z_re * this.a + this.y0;
          return p;
        }
        function inverse$18(p) {
          var n;
          var x = p.x;
          var y = p.y;
          var delta_x = x - this.x0;
          var delta_y = y - this.y0;
          var z_re = delta_y / this.a;
          var z_im = delta_x / this.a;
          var z_n_re = 1;
          var z_n_im = 0;
          var z_n_re1;
          var z_n_im1;
          var th_re = 0;
          var th_im = 0;
          for (n = 1; n <= 6; n++) {
            z_n_re1 = z_n_re * z_re - z_n_im * z_im;
            z_n_im1 = z_n_im * z_re + z_n_re * z_im;
            z_n_re = z_n_re1;
            z_n_im = z_n_im1;
            th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
            th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
          }
          for (var i = 0; i < this.iterations; i++) {
            var th_n_re = th_re;
            var th_n_im = th_im;
            var th_n_re1;
            var th_n_im1;
            var num_re = z_re;
            var num_im = z_im;
            for (n = 2; n <= 6; n++) {
              th_n_re1 = th_n_re * th_re - th_n_im * th_im;
              th_n_im1 = th_n_im * th_re + th_n_re * th_im;
              th_n_re = th_n_re1;
              th_n_im = th_n_im1;
              num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
              num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
            }
            th_n_re = 1;
            th_n_im = 0;
            var den_re = this.B_re[1];
            var den_im = this.B_im[1];
            for (n = 2; n <= 6; n++) {
              th_n_re1 = th_n_re * th_re - th_n_im * th_im;
              th_n_im1 = th_n_im * th_re + th_n_re * th_im;
              th_n_re = th_n_re1;
              th_n_im = th_n_im1;
              den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
              den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
            }
            var den2 = den_re * den_re + den_im * den_im;
            th_re = (num_re * den_re + num_im * den_im) / den2;
            th_im = (num_im * den_re - num_re * den_im) / den2;
          }
          var d_psi = th_re;
          var d_lambda = th_im;
          var d_psi_n = 1;
          var d_phi = 0;
          for (n = 1; n <= 9; n++) {
            d_psi_n = d_psi_n * d_psi;
            d_phi = d_phi + this.D[n] * d_psi_n;
          }
          var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
          var lon = this.long0 + d_lambda;
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
        var nzmg = {
          init: init$19,
          forward: forward$18,
          inverse: inverse$18,
          names: names$20
        };
        function init$20() {
        }
        function forward$19(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var x = this.x0 + this.a * dlon;
          var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$19(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon = adjust_lon(this.long0 + p.x / this.a);
          var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$21 = ["Miller_Cylindrical", "mill"];
        var mill = {
          init: init$20,
          forward: forward$19,
          inverse: inverse$19,
          names: names$21
        };
        var MAX_ITER$3 = 20;
        function init$21() {
          if (!this.sphere) {
            this.en = pj_enfn(this.es);
          } else {
            this.n = 1;
            this.m = 0;
            this.es = 0;
            this.C_y = Math.sqrt((this.m + 1) / this.n);
            this.C_x = this.C_y / (this.m + 1);
          }
        }
        function forward$20(p) {
          var x, y;
          var lon = p.x;
          var lat = p.y;
          lon = adjust_lon(lon - this.long0);
          if (this.sphere) {
            if (!this.m) {
              lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
            } else {
              var k = this.n * Math.sin(lat);
              for (var i = MAX_ITER$3; i; --i) {
                var V2 = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
                lat -= V2;
                if (Math.abs(V2) < EPSLN) {
                  break;
                }
              }
            }
            x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
            y = this.a * this.C_y * lat;
          } else {
            var s = Math.sin(lat);
            var c = Math.cos(lat);
            y = this.a * pj_mlfn(lat, s, c, this.en);
            x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$20(p) {
          var lat, temp, lon, s;
          p.x -= this.x0;
          lon = p.x / this.a;
          p.y -= this.y0;
          lat = p.y / this.a;
          if (this.sphere) {
            lat /= this.C_y;
            lon = lon / (this.C_x * (this.m + Math.cos(lat)));
            if (this.m) {
              lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
            } else if (this.n !== 1) {
              lat = asinz(Math.sin(lat) / this.n);
            }
            lon = adjust_lon(lon + this.long0);
            lat = adjust_lat(lat);
          } else {
            lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
            s = Math.abs(lat);
            if (s < HALF_PI) {
              s = Math.sin(lat);
              temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
              lon = adjust_lon(temp);
            } else if (s - EPSLN < HALF_PI) {
              lon = this.long0;
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$22 = ["Sinusoidal", "sinu"];
        var sinu = {
          init: init$21,
          forward: forward$20,
          inverse: inverse$20,
          names: names$22
        };
        function init$22() {
        }
        function forward$21(p) {
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          var theta = lat;
          var con = Math.PI * Math.sin(lat);
          while (true) {
            var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
            theta += delta_theta;
            if (Math.abs(delta_theta) < EPSLN) {
              break;
            }
          }
          theta /= 2;
          if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
            delta_lon = 0;
          }
          var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
          var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$21(p) {
          var theta;
          var arg;
          p.x -= this.x0;
          p.y -= this.y0;
          arg = p.y / (1.4142135623731 * this.a);
          if (Math.abs(arg) > 0.999999999999) {
            arg = 0.999999999999;
          }
          theta = Math.asin(arg);
          var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
          if (lon < -Math.PI) {
            lon = -Math.PI;
          }
          if (lon > Math.PI) {
            lon = Math.PI;
          }
          arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
          if (Math.abs(arg) > 1) {
            arg = 1;
          }
          var lat = Math.asin(arg);
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$23 = ["Mollweide", "moll"];
        var moll = {
          init: init$22,
          forward: forward$21,
          inverse: inverse$21,
          names: names$23
        };
        function init$23() {
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          this.lat2 = this.lat2 || this.lat1;
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e = Math.sqrt(this.es);
          this.e0 = e0fn(this.es);
          this.e1 = e1fn(this.es);
          this.e2 = e2fn(this.es);
          this.e3 = e3fn(this.es);
          this.sinphi = Math.sin(this.lat1);
          this.cosphi = Math.cos(this.lat1);
          this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
          this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
          if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
            this.ns = this.sinphi;
          } else {
            this.sinphi = Math.sin(this.lat2);
            this.cosphi = Math.cos(this.lat2);
            this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
            this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
            this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
          }
          this.g = this.ml1 + this.ms1 / this.ns;
          this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
          this.rh = this.a * (this.g - this.ml0);
        }
        function forward$22(p) {
          var lon = p.x;
          var lat = p.y;
          var rh1;
          if (this.sphere) {
            rh1 = this.a * (this.g - lat);
          } else {
            var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
            rh1 = this.a * (this.g - ml);
          }
          var theta = this.ns * adjust_lon(lon - this.long0);
          var x = this.x0 + rh1 * Math.sin(theta);
          var y = this.y0 + this.rh - rh1 * Math.cos(theta);
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$22(p) {
          p.x -= this.x0;
          p.y = this.rh - p.y + this.y0;
          var con, rh1, lat, lon;
          if (this.ns >= 0) {
            rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
            con = -1;
          }
          var theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * p.x, con * p.y);
          }
          if (this.sphere) {
            lon = adjust_lon(this.long0 + theta / this.ns);
            lat = adjust_lat(this.g - rh1 / this.a);
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            var ml = this.g - rh1 / this.a;
            lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
            lon = adjust_lon(this.long0 + theta / this.ns);
            p.x = lon;
            p.y = lat;
            return p;
          }
        }
        var names$24 = ["Equidistant_Conic", "eqdc"];
        var eqdc = {
          init: init$23,
          forward: forward$22,
          inverse: inverse$22,
          names: names$24
        };
        function init$24() {
          this.R = this.a;
        }
        function forward$23(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var x, y;
          if (Math.abs(lat) <= EPSLN) {
            x = this.x0 + this.R * dlon;
            y = this.y0;
          }
          var theta = asinz(2 * Math.abs(lat / Math.PI));
          if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
            x = this.x0;
            if (lat >= 0) {
              y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
            } else {
              y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
            }
          }
          var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
          var asq = al * al;
          var sinth = Math.sin(theta);
          var costh = Math.cos(theta);
          var g = costh / (sinth + costh - 1);
          var gsq = g * g;
          var m = g * (2 / sinth - 1);
          var msq = m * m;
          var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
          if (dlon < 0) {
            con = -con;
          }
          x = this.x0 + con;
          var q = asq + g;
          con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
          if (lat >= 0) {
            y = this.y0 + con;
          } else {
            y = this.y0 - con;
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$23(p) {
          var lon, lat;
          var xx, yy, xys, c1, c2, c3;
          var a1;
          var m1;
          var con;
          var th1;
          var d;
          p.x -= this.x0;
          p.y -= this.y0;
          con = Math.PI * this.R;
          xx = p.x / con;
          yy = p.y / con;
          xys = xx * xx + yy * yy;
          c1 = -Math.abs(yy) * (1 + xys);
          c2 = c1 - 2 * yy * yy + xx * xx;
          c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
          d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
          a1 = (c1 - c2 * c2 / 3 / c3) / c3;
          m1 = 2 * Math.sqrt(-a1 / 3);
          con = 3 * d / a1 / m1;
          if (Math.abs(con) > 1) {
            if (con >= 0) {
              con = 1;
            } else {
              con = -1;
            }
          }
          th1 = Math.acos(con) / 3;
          if (p.y >= 0) {
            lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
          } else {
            lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
          }
          if (Math.abs(xx) < EPSLN) {
            lon = this.long0;
          } else {
            lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
        var vandg = {
          init: init$24,
          forward: forward$23,
          inverse: inverse$23,
          names: names$25
        };
        function init$25() {
          this.sin_p12 = Math.sin(this.lat0);
          this.cos_p12 = Math.cos(this.lat0);
        }
        function forward$24(p) {
          var lon = p.x;
          var lat = p.y;
          var sinphi = Math.sin(p.y);
          var cosphi = Math.cos(p.y);
          var dlon = adjust_lon(lon - this.long0);
          var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
          if (this.sphere) {
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
              p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
              p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
              return p;
            } else {
              cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
              c = Math.acos(cos_c);
              kp = c ? c / Math.sin(c) : 1;
              p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
              p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
              return p;
            }
          } else {
            e0 = e0fn(this.es);
            e1 = e1fn(this.es);
            e2 = e2fn(this.es);
            e3 = e3fn(this.es);
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              Ml = this.a * mlfn(e0, e1, e2, e3, lat);
              p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
              p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              Ml = this.a * mlfn(e0, e1, e2, e3, lat);
              p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
              p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
              return p;
            } else {
              tanphi = sinphi / cosphi;
              Nl1 = gN(this.a, this.e, this.sin_p12);
              Nl = gN(this.a, this.e, sinphi);
              psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
              Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
              if (Az === 0) {
                s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
              } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
                s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
              } else {
                s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
              }
              G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
              H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
              GH = G * H;
              Hs = H * H;
              s2 = s * s;
              s3 = s2 * s;
              s4 = s3 * s;
              s5 = s4 * s;
              c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
              p.x = this.x0 + c * Math.sin(Az);
              p.y = this.y0 + c * Math.cos(Az);
              return p;
            }
          }
        }
        function inverse$24(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M2, N1, psi, Az, cosAz, tmp, A5, B, D, Ee, F, sinpsi;
          if (this.sphere) {
            rh = Math.sqrt(p.x * p.x + p.y * p.y);
            if (rh > 2 * HALF_PI * this.a) {
              return;
            }
            z = rh / this.a;
            sinz = Math.sin(z);
            cosz = Math.cos(z);
            lon = this.long0;
            if (Math.abs(rh) <= EPSLN) {
              lat = this.lat0;
            } else {
              lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
              con = Math.abs(this.lat0) - HALF_PI;
              if (Math.abs(con) <= EPSLN) {
                if (this.lat0 >= 0) {
                  lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
                } else {
                  lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
                }
              } else {
                lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
              }
            }
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            e0 = e0fn(this.es);
            e1 = e1fn(this.es);
            e2 = e2fn(this.es);
            e3 = e3fn(this.es);
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              M2 = Mlp - rh;
              lat = imlfn(M2 / this.a, e0, e1, e2, e3);
              lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
              p.x = lon;
              p.y = lat;
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              M2 = rh - Mlp;
              lat = imlfn(M2 / this.a, e0, e1, e2, e3);
              lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
              p.x = lon;
              p.y = lat;
              return p;
            } else {
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              Az = Math.atan2(p.x, p.y);
              N1 = gN(this.a, this.e, this.sin_p12);
              cosAz = Math.cos(Az);
              tmp = this.e * this.cos_p12 * cosAz;
              A5 = -tmp * tmp / (1 - this.es);
              B = 3 * this.es * (1 - A5) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
              D = rh / N1;
              Ee = D - A5 * (1 + A5) * Math.pow(D, 3) / 6 - B * (1 + 3 * A5) * Math.pow(D, 4) / 24;
              F = 1 - A5 * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
              psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
              lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
              sinpsi = Math.sin(psi);
              lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
              p.x = lon;
              p.y = lat;
              return p;
            }
          }
        }
        var names$26 = ["Azimuthal_Equidistant", "aeqd"];
        var aeqd = {
          init: init$25,
          forward: forward$24,
          inverse: inverse$24,
          names: names$26
        };
        function init$26() {
          this.sin_p14 = Math.sin(this.lat0);
          this.cos_p14 = Math.cos(this.lat0);
        }
        function forward$25(p) {
          var sinphi, cosphi;
          var dlon;
          var coslon;
          var ksp;
          var g, x, y;
          var lon = p.x;
          var lat = p.y;
          dlon = adjust_lon(lon - this.long0);
          sinphi = Math.sin(lat);
          cosphi = Math.cos(lat);
          coslon = Math.cos(dlon);
          g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
          ksp = 1;
          if (g > 0 || Math.abs(g) <= EPSLN) {
            x = this.a * ksp * cosphi * Math.sin(dlon);
            y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function inverse$25(p) {
          var rh;
          var z;
          var sinz, cosz;
          var con;
          var lon, lat;
          p.x -= this.x0;
          p.y -= this.y0;
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          z = asinz(rh / this.a);
          sinz = Math.sin(z);
          cosz = Math.cos(z);
          lon = this.long0;
          if (Math.abs(rh) <= EPSLN) {
            lat = this.lat0;
            p.x = lon;
            p.y = lat;
            return p;
          }
          lat = asinz(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
          con = Math.abs(this.lat0) - HALF_PI;
          if (Math.abs(con) <= EPSLN) {
            if (this.lat0 >= 0) {
              lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
            } else {
              lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
          p.x = lon;
          p.y = lat;
          return p;
        }
        var names$27 = ["ortho"];
        var ortho = {
          init: init$26,
          forward: forward$25,
          inverse: inverse$25,
          names: names$27
        };
        var FACE_ENUM = {
          FRONT: 1,
          RIGHT: 2,
          BACK: 3,
          LEFT: 4,
          TOP: 5,
          BOTTOM: 6
        };
        var AREA_ENUM = {
          AREA_0: 1,
          AREA_1: 2,
          AREA_2: 3,
          AREA_3: 4
        };
        function init$27() {
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          this.lat0 = this.lat0 || 0;
          this.long0 = this.long0 || 0;
          this.lat_ts = this.lat_ts || 0;
          this.title = this.title || "Quadrilateralized Spherical Cube";
          if (this.lat0 >= HALF_PI - FORTPI / 2) {
            this.face = FACE_ENUM.TOP;
          } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
            this.face = FACE_ENUM.BOTTOM;
          } else if (Math.abs(this.long0) <= FORTPI) {
            this.face = FACE_ENUM.FRONT;
          } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
            this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
          } else {
            this.face = FACE_ENUM.BACK;
          }
          if (this.es !== 0) {
            this.one_minus_f = 1 - (this.a - this.b) / this.a;
            this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
          }
        }
        function forward$26(p) {
          var xy = { x: 0, y: 0 };
          var lat, lon;
          var theta, phi;
          var t, mu;
          var area = { value: 0 };
          p.x -= this.long0;
          if (this.es !== 0) {
            lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
          } else {
            lat = p.y;
          }
          lon = p.x;
          if (this.face === FACE_ENUM.TOP) {
            phi = HALF_PI - lat;
            if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
              area.value = AREA_ENUM.AREA_0;
              theta = lon - HALF_PI;
            } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
              area.value = AREA_ENUM.AREA_1;
              theta = lon > 0 ? lon - SPI : lon + SPI;
            } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
              area.value = AREA_ENUM.AREA_2;
              theta = lon + HALF_PI;
            } else {
              area.value = AREA_ENUM.AREA_3;
              theta = lon;
            }
          } else if (this.face === FACE_ENUM.BOTTOM) {
            phi = HALF_PI + lat;
            if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
              area.value = AREA_ENUM.AREA_0;
              theta = -lon + HALF_PI;
            } else if (lon < FORTPI && lon >= -FORTPI) {
              area.value = AREA_ENUM.AREA_1;
              theta = -lon;
            } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
              area.value = AREA_ENUM.AREA_2;
              theta = -lon - HALF_PI;
            } else {
              area.value = AREA_ENUM.AREA_3;
              theta = lon > 0 ? -lon + SPI : -lon - SPI;
            }
          } else {
            var q, r, s;
            var sinlat, coslat;
            var sinlon, coslon;
            if (this.face === FACE_ENUM.RIGHT) {
              lon = qsc_shift_lon_origin(lon, +HALF_PI);
            } else if (this.face === FACE_ENUM.BACK) {
              lon = qsc_shift_lon_origin(lon, +SPI);
            } else if (this.face === FACE_ENUM.LEFT) {
              lon = qsc_shift_lon_origin(lon, -HALF_PI);
            }
            sinlat = Math.sin(lat);
            coslat = Math.cos(lat);
            sinlon = Math.sin(lon);
            coslon = Math.cos(lon);
            q = coslat * coslon;
            r = coslat * sinlon;
            s = sinlat;
            if (this.face === FACE_ENUM.FRONT) {
              phi = Math.acos(q);
              theta = qsc_fwd_equat_face_theta(phi, s, r, area);
            } else if (this.face === FACE_ENUM.RIGHT) {
              phi = Math.acos(r);
              theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
            } else if (this.face === FACE_ENUM.BACK) {
              phi = Math.acos(-q);
              theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
            } else if (this.face === FACE_ENUM.LEFT) {
              phi = Math.acos(-r);
              theta = qsc_fwd_equat_face_theta(phi, s, q, area);
            } else {
              phi = theta = 0;
              area.value = AREA_ENUM.AREA_0;
            }
          }
          mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
          t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
          if (area.value === AREA_ENUM.AREA_1) {
            mu += HALF_PI;
          } else if (area.value === AREA_ENUM.AREA_2) {
            mu += SPI;
          } else if (area.value === AREA_ENUM.AREA_3) {
            mu += 1.5 * SPI;
          }
          xy.x = t * Math.cos(mu);
          xy.y = t * Math.sin(mu);
          xy.x = xy.x * this.a + this.x0;
          xy.y = xy.y * this.a + this.y0;
          p.x = xy.x;
          p.y = xy.y;
          return p;
        }
        function inverse$26(p) {
          var lp = { lam: 0, phi: 0 };
          var mu, nu, cosmu, tannu;
          var tantheta, theta, cosphi, phi;
          var t;
          var area = { value: 0 };
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
          mu = Math.atan2(p.y, p.x);
          if (p.x >= 0 && p.x >= Math.abs(p.y)) {
            area.value = AREA_ENUM.AREA_0;
          } else if (p.y >= 0 && p.y >= Math.abs(p.x)) {
            area.value = AREA_ENUM.AREA_1;
            mu -= HALF_PI;
          } else if (p.x < 0 && -p.x >= Math.abs(p.y)) {
            area.value = AREA_ENUM.AREA_2;
            mu = mu < 0 ? mu + SPI : mu - SPI;
          } else {
            area.value = AREA_ENUM.AREA_3;
            mu += HALF_PI;
          }
          t = SPI / 12 * Math.tan(mu);
          tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
          theta = Math.atan(tantheta);
          cosmu = Math.cos(mu);
          tannu = Math.tan(nu);
          cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
          if (cosphi < -1) {
            cosphi = -1;
          } else if (cosphi > 1) {
            cosphi = 1;
          }
          if (this.face === FACE_ENUM.TOP) {
            phi = Math.acos(cosphi);
            lp.phi = HALF_PI - phi;
            if (area.value === AREA_ENUM.AREA_0) {
              lp.lam = theta + HALF_PI;
            } else if (area.value === AREA_ENUM.AREA_1) {
              lp.lam = theta < 0 ? theta + SPI : theta - SPI;
            } else if (area.value === AREA_ENUM.AREA_2) {
              lp.lam = theta - HALF_PI;
            } else {
              lp.lam = theta;
            }
          } else if (this.face === FACE_ENUM.BOTTOM) {
            phi = Math.acos(cosphi);
            lp.phi = phi - HALF_PI;
            if (area.value === AREA_ENUM.AREA_0) {
              lp.lam = -theta + HALF_PI;
            } else if (area.value === AREA_ENUM.AREA_1) {
              lp.lam = -theta;
            } else if (area.value === AREA_ENUM.AREA_2) {
              lp.lam = -theta - HALF_PI;
            } else {
              lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
            }
          } else {
            var q, r, s;
            q = cosphi;
            t = q * q;
            if (t >= 1) {
              s = 0;
            } else {
              s = Math.sqrt(1 - t) * Math.sin(theta);
            }
            t += s * s;
            if (t >= 1) {
              r = 0;
            } else {
              r = Math.sqrt(1 - t);
            }
            if (area.value === AREA_ENUM.AREA_1) {
              t = r;
              r = -s;
              s = t;
            } else if (area.value === AREA_ENUM.AREA_2) {
              r = -r;
              s = -s;
            } else if (area.value === AREA_ENUM.AREA_3) {
              t = r;
              r = s;
              s = -t;
            }
            if (this.face === FACE_ENUM.RIGHT) {
              t = q;
              q = -r;
              r = t;
            } else if (this.face === FACE_ENUM.BACK) {
              q = -q;
              r = -r;
            } else if (this.face === FACE_ENUM.LEFT) {
              t = q;
              q = r;
              r = -t;
            }
            lp.phi = Math.acos(-s) - HALF_PI;
            lp.lam = Math.atan2(r, q);
            if (this.face === FACE_ENUM.RIGHT) {
              lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
            } else if (this.face === FACE_ENUM.BACK) {
              lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
            } else if (this.face === FACE_ENUM.LEFT) {
              lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
            }
          }
          if (this.es !== 0) {
            var invert_sign;
            var tanphi, xa;
            invert_sign = lp.phi < 0 ? 1 : 0;
            tanphi = Math.tan(lp.phi);
            xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
            lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
            if (invert_sign) {
              lp.phi = -lp.phi;
            }
          }
          lp.lam += this.long0;
          p.x = lp.lam;
          p.y = lp.phi;
          return p;
        }
        function qsc_fwd_equat_face_theta(phi, y, x, area) {
          var theta;
          if (phi < EPSLN) {
            area.value = AREA_ENUM.AREA_0;
            theta = 0;
          } else {
            theta = Math.atan2(y, x);
            if (Math.abs(theta) <= FORTPI) {
              area.value = AREA_ENUM.AREA_0;
            } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
              area.value = AREA_ENUM.AREA_1;
              theta -= HALF_PI;
            } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
              area.value = AREA_ENUM.AREA_2;
              theta = theta >= 0 ? theta - SPI : theta + SPI;
            } else {
              area.value = AREA_ENUM.AREA_3;
              theta += HALF_PI;
            }
          }
          return theta;
        }
        function qsc_shift_lon_origin(lon, offset) {
          var slon = lon + offset;
          if (slon < -SPI) {
            slon += TWO_PI;
          } else if (slon > +SPI) {
            slon -= TWO_PI;
          }
          return slon;
        }
        var names$28 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
        var qsc = {
          init: init$27,
          forward: forward$26,
          inverse: inverse$26,
          names: names$28
        };
        var COEFS_X = [
          [1, 22199e-21, -715515e-10, 31103e-10],
          [0.9986, -482243e-9, -24897e-9, -13309e-10],
          [0.9954, -83103e-8, -448605e-10, -986701e-12],
          [0.99, -135364e-8, -59661e-9, 36777e-10],
          [0.9822, -167442e-8, -449547e-11, -572411e-11],
          [0.973, -214868e-8, -903571e-10, 18736e-12],
          [0.96, -305085e-8, -900761e-10, 164917e-11],
          [0.9427, -382792e-8, -653386e-10, -26154e-10],
          [0.9216, -467746e-8, -10457e-8, 481243e-11],
          [0.8962, -536223e-8, -323831e-10, -543432e-11],
          [0.8679, -609363e-8, -113898e-9, 332484e-11],
          [0.835, -698325e-8, -640253e-10, 934959e-12],
          [0.7986, -755338e-8, -500009e-10, 935324e-12],
          [0.7597, -798324e-8, -35971e-9, -227626e-11],
          [0.7186, -851367e-8, -701149e-10, -86303e-10],
          [0.6732, -986209e-8, -199569e-9, 191974e-10],
          [0.6213, -0.010418, 883923e-10, 624051e-11],
          [0.5722, -906601e-8, 182e-6, 624051e-11],
          [0.5322, -677797e-8, 275608e-9, 624051e-11]
        ];
        var COEFS_Y = [
          [-520417e-23, 0.0124, 121431e-23, -845284e-16],
          [0.062, 0.0124, -126793e-14, 422642e-15],
          [0.124, 0.0124, 507171e-14, -160604e-14],
          [0.186, 0.0123999, -190189e-13, 600152e-14],
          [0.248, 0.0124002, 710039e-13, -224e-10],
          [0.31, 0.0123992, -264997e-12, 835986e-13],
          [0.372, 0.0124029, 988983e-12, -311994e-12],
          [0.434, 0.0123893, -369093e-11, -435621e-12],
          [0.4958, 0.0123198, -102252e-10, -345523e-12],
          [0.5571, 0.0121916, -154081e-10, -582288e-12],
          [0.6176, 0.0119938, -241424e-10, -525327e-12],
          [0.6769, 0.011713, -320223e-10, -516405e-12],
          [0.7346, 0.0113541, -397684e-10, -609052e-12],
          [0.7903, 0.0109107, -489042e-10, -104739e-11],
          [0.8435, 0.0103431, -64615e-9, -140374e-14],
          [0.8936, 969686e-8, -64636e-9, -8547e-9],
          [0.9394, 840947e-8, -192841e-9, -42106e-10],
          [0.9761, 616527e-8, -256e-6, -42106e-10],
          [1, 328947e-8, -319159e-9, -42106e-10]
        ];
        var FXC = 0.8487;
        var FYC = 1.3523;
        var C1 = R2D / 5;
        var RC1 = 1 / C1;
        var NODES = 18;
        var poly3_val = function(coefs, x) {
          return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
        };
        var poly3_der = function(coefs, x) {
          return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
        };
        function newton_rapshon(f_df, start2, max_err, iters) {
          var x = start2;
          for (; iters; --iters) {
            var upd = f_df(x);
            x -= upd;
            if (Math.abs(upd) < max_err) {
              break;
            }
          }
          return x;
        }
        function init$28() {
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          this.long0 = this.long0 || 0;
          this.es = 0;
          this.title = this.title || "Robinson";
        }
        function forward$27(ll) {
          var lon = adjust_lon(ll.x - this.long0);
          var dphi = Math.abs(ll.y);
          var i = Math.floor(dphi * C1);
          if (i < 0) {
            i = 0;
          } else if (i >= NODES) {
            i = NODES - 1;
          }
          dphi = R2D * (dphi - RC1 * i);
          var xy = {
            x: poly3_val(COEFS_X[i], dphi) * lon,
            y: poly3_val(COEFS_Y[i], dphi)
          };
          if (ll.y < 0) {
            xy.y = -xy.y;
          }
          xy.x = xy.x * this.a * FXC + this.x0;
          xy.y = xy.y * this.a * FYC + this.y0;
          return xy;
        }
        function inverse$27(xy) {
          var ll = {
            x: (xy.x - this.x0) / (this.a * FXC),
            y: Math.abs(xy.y - this.y0) / (this.a * FYC)
          };
          if (ll.y >= 1) {
            ll.x /= COEFS_X[NODES][0];
            ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
          } else {
            var i = Math.floor(ll.y * NODES);
            if (i < 0) {
              i = 0;
            } else if (i >= NODES) {
              i = NODES - 1;
            }
            for (; ; ) {
              if (COEFS_Y[i][0] > ll.y) {
                --i;
              } else if (COEFS_Y[i + 1][0] <= ll.y) {
                ++i;
              } else {
                break;
              }
            }
            var coefs = COEFS_Y[i];
            var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
            t = newton_rapshon(function(x) {
              return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
            }, t, EPSLN, 100);
            ll.x /= poly3_val(COEFS_X[i], t);
            ll.y = (5 * i + t) * D2R;
            if (xy.y < 0) {
              ll.y = -ll.y;
            }
          }
          ll.x = adjust_lon(ll.x + this.long0);
          return ll;
        }
        var names$29 = ["Robinson", "robin"];
        var robin = {
          init: init$28,
          forward: forward$27,
          inverse: inverse$27,
          names: names$29
        };
        function init$29() {
          this.name = "geocent";
        }
        function forward$28(p) {
          var point = geodeticToGeocentric(p, this.es, this.a);
          return point;
        }
        function inverse$28(p) {
          var point = geocentricToGeodetic(p, this.es, this.a, this.b);
          return point;
        }
        var names$30 = ["Geocentric", "geocentric", "geocent", "Geocent"];
        var geocent = {
          init: init$29,
          forward: forward$28,
          inverse: inverse$28,
          names: names$30
        };
        var mode = {
          N_POLE: 0,
          S_POLE: 1,
          EQUIT: 2,
          OBLIQ: 3
        };
        var params = {
          h: { def: 1e5, num: true },
          // default is Karman line, no default in PROJ.7
          azi: { def: 0, num: true, degrees: true },
          // default is North
          tilt: { def: 0, num: true, degrees: true },
          // default is Nadir
          long0: { def: 0, num: true },
          // default is Greenwich, conversion to rad is automatic
          lat0: { def: 0, num: true }
          // default is Equator, conversion to rad is automatic
        };
        function init$30() {
          Object.keys(params).forEach(function(p) {
            if (typeof this[p] === "undefined") {
              this[p] = params[p].def;
            } else if (params[p].num && isNaN(this[p])) {
              throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
            } else if (params[p].num) {
              this[p] = parseFloat(this[p]);
            }
            if (params[p].degrees) {
              this[p] = this[p] * D2R;
            }
          }.bind(this));
          if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
            this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
          } else if (Math.abs(this.lat0) < EPSLN) {
            this.mode = mode.EQUIT;
          } else {
            this.mode = mode.OBLIQ;
            this.sinph0 = Math.sin(this.lat0);
            this.cosph0 = Math.cos(this.lat0);
          }
          this.pn1 = this.h / this.a;
          if (this.pn1 <= 0 || this.pn1 > 1e10) {
            throw new Error("Invalid height");
          }
          this.p = 1 + this.pn1;
          this.rp = 1 / this.p;
          this.h1 = 1 / this.pn1;
          this.pfact = (this.p + 1) * this.h1;
          this.es = 0;
          var omega = this.tilt;
          var gamma = this.azi;
          this.cg = Math.cos(gamma);
          this.sg = Math.sin(gamma);
          this.cw = Math.cos(omega);
          this.sw = Math.sin(omega);
        }
        function forward$29(p) {
          p.x -= this.long0;
          var sinphi = Math.sin(p.y);
          var cosphi = Math.cos(p.y);
          var coslam = Math.cos(p.x);
          var x, y;
          switch (this.mode) {
            case mode.OBLIQ:
              y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
              break;
            case mode.EQUIT:
              y = cosphi * coslam;
              break;
            case mode.S_POLE:
              y = -sinphi;
              break;
            case mode.N_POLE:
              y = sinphi;
              break;
          }
          y = this.pn1 / (this.p - y);
          x = y * cosphi * Math.sin(p.x);
          switch (this.mode) {
            case mode.OBLIQ:
              y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
              break;
            case mode.EQUIT:
              y *= sinphi;
              break;
            case mode.N_POLE:
              y *= -(cosphi * coslam);
              break;
            case mode.S_POLE:
              y *= cosphi * coslam;
              break;
          }
          var yt, ba;
          yt = y * this.cg + x * this.sg;
          ba = 1 / (yt * this.sw * this.h1 + this.cw);
          x = (x * this.cg - y * this.sg) * this.cw * ba;
          y = yt * ba;
          p.x = x * this.a;
          p.y = y * this.a;
          return p;
        }
        function inverse$29(p) {
          p.x /= this.a;
          p.y /= this.a;
          var r = { x: p.x, y: p.y };
          var bm, bq, yt;
          yt = 1 / (this.pn1 - p.y * this.sw);
          bm = this.pn1 * p.x * yt;
          bq = this.pn1 * p.y * this.cw * yt;
          p.x = bm * this.cg + bq * this.sg;
          p.y = bq * this.cg - bm * this.sg;
          var rh = hypot(p.x, p.y);
          if (Math.abs(rh) < EPSLN) {
            r.x = 0;
            r.y = p.y;
          } else {
            var cosz, sinz;
            sinz = 1 - rh * rh * this.pfact;
            sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
            cosz = Math.sqrt(1 - sinz * sinz);
            switch (this.mode) {
              case mode.OBLIQ:
                r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
                p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
                p.x *= sinz * this.cosph0;
                break;
              case mode.EQUIT:
                r.y = Math.asin(p.y * sinz / rh);
                p.y = cosz * rh;
                p.x *= sinz;
                break;
              case mode.N_POLE:
                r.y = Math.asin(cosz);
                p.y = -p.y;
                break;
              case mode.S_POLE:
                r.y = -Math.asin(cosz);
                break;
            }
            r.x = Math.atan2(p.x, p.y);
          }
          p.x = r.x + this.long0;
          p.y = r.y;
          return p;
        }
        var names$31 = ["Tilted_Perspective", "tpers"];
        var tpers = {
          init: init$30,
          forward: forward$29,
          inverse: inverse$29,
          names: names$31
        };
        function init$31() {
          this.flip_axis = this.sweep === "x" ? 1 : 0;
          this.h = Number(this.h);
          this.radius_g_1 = this.h / this.a;
          if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
            throw new Error();
          }
          this.radius_g = 1 + this.radius_g_1;
          this.C = this.radius_g * this.radius_g - 1;
          if (this.es !== 0) {
            var one_es = 1 - this.es;
            var rone_es = 1 / one_es;
            this.radius_p = Math.sqrt(one_es);
            this.radius_p2 = one_es;
            this.radius_p_inv2 = rone_es;
            this.shape = "ellipse";
          } else {
            this.radius_p = 1;
            this.radius_p2 = 1;
            this.radius_p_inv2 = 1;
            this.shape = "sphere";
          }
          if (!this.title) {
            this.title = "Geostationary Satellite View";
          }
        }
        function forward$30(p) {
          var lon = p.x;
          var lat = p.y;
          var tmp, v_x, v_y, v_z;
          lon = lon - this.long0;
          if (this.shape === "ellipse") {
            lat = Math.atan(this.radius_p2 * Math.tan(lat));
            var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));
            v_x = r * Math.cos(lon) * Math.cos(lat);
            v_y = r * Math.sin(lon) * Math.cos(lat);
            v_z = r * Math.sin(lat);
            if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
              p.x = Number.NaN;
              p.y = Number.NaN;
              return p;
            }
            tmp = this.radius_g - v_x;
            if (this.flip_axis) {
              p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
              p.y = this.radius_g_1 * Math.atan(v_z / tmp);
            } else {
              p.x = this.radius_g_1 * Math.atan(v_y / tmp);
              p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
            }
          } else if (this.shape === "sphere") {
            tmp = Math.cos(lat);
            v_x = Math.cos(lon) * tmp;
            v_y = Math.sin(lon) * tmp;
            v_z = Math.sin(lat);
            tmp = this.radius_g - v_x;
            if (this.flip_axis) {
              p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
              p.y = this.radius_g_1 * Math.atan(v_z / tmp);
            } else {
              p.x = this.radius_g_1 * Math.atan(v_y / tmp);
              p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
            }
          }
          p.x = p.x * this.a;
          p.y = p.y * this.a;
          return p;
        }
        function inverse$30(p) {
          var v_x = -1;
          var v_y = 0;
          var v_z = 0;
          var a, b, det, k;
          p.x = p.x / this.a;
          p.y = p.y / this.a;
          if (this.shape === "ellipse") {
            if (this.flip_axis) {
              v_z = Math.tan(p.y / this.radius_g_1);
              v_y = Math.tan(p.x / this.radius_g_1) * hypot(1, v_z);
            } else {
              v_y = Math.tan(p.x / this.radius_g_1);
              v_z = Math.tan(p.y / this.radius_g_1) * hypot(1, v_y);
            }
            var v_zp = v_z / this.radius_p;
            a = v_y * v_y + v_zp * v_zp + v_x * v_x;
            b = 2 * this.radius_g * v_x;
            det = b * b - 4 * a * this.C;
            if (det < 0) {
              p.x = Number.NaN;
              p.y = Number.NaN;
              return p;
            }
            k = (-b - Math.sqrt(det)) / (2 * a);
            v_x = this.radius_g + k * v_x;
            v_y *= k;
            v_z *= k;
            p.x = Math.atan2(v_y, v_x);
            p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
            p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
          } else if (this.shape === "sphere") {
            if (this.flip_axis) {
              v_z = Math.tan(p.y / this.radius_g_1);
              v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
            } else {
              v_y = Math.tan(p.x / this.radius_g_1);
              v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
            }
            a = v_y * v_y + v_z * v_z + v_x * v_x;
            b = 2 * this.radius_g * v_x;
            det = b * b - 4 * a * this.C;
            if (det < 0) {
              p.x = Number.NaN;
              p.y = Number.NaN;
              return p;
            }
            k = (-b - Math.sqrt(det)) / (2 * a);
            v_x = this.radius_g + k * v_x;
            v_y *= k;
            v_z *= k;
            p.x = Math.atan2(v_y, v_x);
            p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
          }
          p.x = p.x + this.long0;
          return p;
        }
        var names$32 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
        var geos = {
          init: init$31,
          forward: forward$30,
          inverse: inverse$30,
          names: names$32
        };
        var A1 = 1.340264;
        var A2 = -0.081106;
        var A3 = 893e-6;
        var A4 = 3796e-6;
        var M = Math.sqrt(3) / 2;
        function init$32() {
          this.es = 0;
          this.long0 = this.long0 !== void 0 ? this.long0 : 0;
        }
        function forward$31(p) {
          var lam = adjust_lon(p.x - this.long0);
          var phi = p.y;
          var paramLat = Math.asin(M * Math.sin(phi)), paramLatSq = paramLat * paramLat, paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
          p.x = lam * Math.cos(paramLat) / (M * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)));
          p.y = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq));
          p.x = this.a * p.x + this.x0;
          p.y = this.a * p.y + this.y0;
          return p;
        }
        function inverse$31(p) {
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          var EPS = 1e-9, NITER = 12, paramLat = p.y, paramLatSq, paramLatPow6, fy, fpy, dlat, i;
          for (i = 0; i < NITER; ++i) {
            paramLatSq = paramLat * paramLat;
            paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
            fy = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq)) - p.y;
            fpy = A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq);
            paramLat -= dlat = fy / fpy;
            if (Math.abs(dlat) < EPS) {
              break;
            }
          }
          paramLatSq = paramLat * paramLat;
          paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
          p.x = M * p.x * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)) / Math.cos(paramLat);
          p.y = Math.asin(Math.sin(paramLat) / M);
          p.x = adjust_lon(p.x + this.long0);
          return p;
        }
        var names$33 = ["eqearth", "Equal Earth", "Equal_Earth"];
        var eqearth = {
          init: init$32,
          forward: forward$31,
          inverse: inverse$31,
          names: names$33
        };
        var EPS10 = 1e-10;
        function init$33() {
          var c;
          this.phi1 = this.lat1;
          if (Math.abs(this.phi1) < EPS10) {
            throw new Error();
          }
          if (this.es) {
            this.en = pj_enfn(this.es);
            this.m1 = pj_mlfn(
              this.phi1,
              this.am1 = Math.sin(this.phi1),
              c = Math.cos(this.phi1),
              this.en
            );
            this.am1 = c / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1);
            this.inverse = e_inv;
            this.forward = e_fwd;
          } else {
            if (Math.abs(this.phi1) + EPS10 >= HALF_PI) {
              this.cphi1 = 0;
            } else {
              this.cphi1 = 1 / Math.tan(this.phi1);
            }
            this.inverse = s_inv;
            this.forward = s_fwd;
          }
        }
        function e_fwd(p) {
          var lam = adjust_lon(p.x - (this.long0 || 0));
          var phi = p.y;
          var rh, E, c;
          rh = this.am1 + this.m1 - pj_mlfn(phi, E = Math.sin(phi), c = Math.cos(phi), this.en);
          E = c * lam / (rh * Math.sqrt(1 - this.es * E * E));
          p.x = rh * Math.sin(E);
          p.y = this.am1 - rh * Math.cos(E);
          p.x = this.a * p.x + (this.x0 || 0);
          p.y = this.a * p.y + (this.y0 || 0);
          return p;
        }
        function e_inv(p) {
          p.x = (p.x - (this.x0 || 0)) / this.a;
          p.y = (p.y - (this.y0 || 0)) / this.a;
          var s, rh, lam, phi;
          rh = hypot(p.x, p.y = this.am1 - p.y);
          phi = pj_inv_mlfn(this.am1 + this.m1 - rh, this.es, this.en);
          if ((s = Math.abs(phi)) < HALF_PI) {
            s = Math.sin(phi);
            lam = rh * Math.atan2(p.x, p.y) * Math.sqrt(1 - this.es * s * s) / Math.cos(phi);
          } else if (Math.abs(s - HALF_PI) <= EPS10) {
            lam = 0;
          } else {
            throw new Error();
          }
          p.x = adjust_lon(lam + (this.long0 || 0));
          p.y = adjust_lat(phi);
          return p;
        }
        function s_fwd(p) {
          var lam = adjust_lon(p.x - (this.long0 || 0));
          var phi = p.y;
          var E, rh;
          rh = this.cphi1 + this.phi1 - phi;
          if (Math.abs(rh) > EPS10) {
            p.x = rh * Math.sin(E = lam * Math.cos(phi) / rh);
            p.y = this.cphi1 - rh * Math.cos(E);
          } else {
            p.x = p.y = 0;
          }
          p.x = this.a * p.x + (this.x0 || 0);
          p.y = this.a * p.y + (this.y0 || 0);
          return p;
        }
        function s_inv(p) {
          p.x = (p.x - (this.x0 || 0)) / this.a;
          p.y = (p.y - (this.y0 || 0)) / this.a;
          var lam, phi;
          var rh = hypot(p.x, p.y = this.cphi1 - p.y);
          phi = this.cphi1 + this.phi1 - rh;
          if (Math.abs(phi) > HALF_PI) {
            throw new Error();
          }
          if (Math.abs(Math.abs(phi) - HALF_PI) <= EPS10) {
            lam = 0;
          } else {
            lam = rh * Math.atan2(p.x, p.y) / Math.cos(phi);
          }
          p.x = adjust_lon(lam + (this.long0 || 0));
          p.y = adjust_lat(phi);
          return p;
        }
        var names$34 = ["bonne", "Bonne (Werner lat_1=90)"];
        var bonne = {
          init: init$33,
          names: names$34
        };
        var includedProjections = function(proj4) {
          proj4.Proj.projections.add(tmerc);
          proj4.Proj.projections.add(etmerc);
          proj4.Proj.projections.add(utm);
          proj4.Proj.projections.add(sterea);
          proj4.Proj.projections.add(stere);
          proj4.Proj.projections.add(somerc);
          proj4.Proj.projections.add(omerc);
          proj4.Proj.projections.add(lcc);
          proj4.Proj.projections.add(krovak);
          proj4.Proj.projections.add(cass);
          proj4.Proj.projections.add(laea);
          proj4.Proj.projections.add(aea);
          proj4.Proj.projections.add(gnom);
          proj4.Proj.projections.add(cea);
          proj4.Proj.projections.add(eqc);
          proj4.Proj.projections.add(poly);
          proj4.Proj.projections.add(nzmg);
          proj4.Proj.projections.add(mill);
          proj4.Proj.projections.add(sinu);
          proj4.Proj.projections.add(moll);
          proj4.Proj.projections.add(eqdc);
          proj4.Proj.projections.add(vandg);
          proj4.Proj.projections.add(aeqd);
          proj4.Proj.projections.add(ortho);
          proj4.Proj.projections.add(qsc);
          proj4.Proj.projections.add(robin);
          proj4.Proj.projections.add(geocent);
          proj4.Proj.projections.add(tpers);
          proj4.Proj.projections.add(geos);
          proj4.Proj.projections.add(eqearth);
          proj4.Proj.projections.add(bonne);
        };
        proj4$1.defaultDatum = "WGS84";
        proj4$1.Proj = Projection;
        proj4$1.WGS84 = new proj4$1.Proj("WGS84");
        proj4$1.Point = Point;
        proj4$1.toPoint = toPoint;
        proj4$1.defs = defs;
        proj4$1.nadgrid = nadgrid;
        proj4$1.transform = transform;
        proj4$1.mgrs = mgrs;
        proj4$1.version = "2.14.0";
        includedProjections(proj4$1);
        return proj4$1;
      });
    }
  });

  // C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/static/leaflet/proj4leaflet.js
  var require_proj4leaflet = __commonJS({
    "C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/static/leaflet/proj4leaflet.js"(exports, module) {
      (function(factory) {
        var L2, proj4;
        if (typeof define === "function" && define.amd) {
          define(["leaflet", "proj4"], factory);
        } else if (typeof module === "object" && typeof module.exports === "object") {
          L2 = require_leaflet_src();
          proj4 = require_proj4_src();
          module.exports = factory(L2, proj4);
        } else {
          if (typeof window.L === "undefined" || typeof window.proj4 === "undefined")
            throw "Leaflet and proj4 must be loaded first";
          factory(window.L, window.proj4);
        }
      })(function(L2, proj4) {
        if (proj4.__esModule && proj4.default) {
          proj4 = proj4.default;
        }
        L2.Proj = {};
        L2.Proj._isProj4Obj = function(a) {
          return typeof a.inverse !== "undefined" && typeof a.forward !== "undefined";
        };
        L2.Proj.Projection = L2.Class.extend({
          initialize: function(code, def, bounds) {
            var isP4 = L2.Proj._isProj4Obj(code);
            this._proj = isP4 ? code : this._projFromCodeDef(code, def);
            this.bounds = isP4 ? def : bounds;
          },
          project: function(latlng) {
            var point = this._proj.forward([latlng.lng, latlng.lat]);
            return new L2.Point(point[0], point[1]);
          },
          unproject: function(point, unbounded) {
            var point2 = this._proj.inverse([point.x, point.y]);
            return new L2.LatLng(point2[1], point2[0], unbounded);
          },
          _projFromCodeDef: function(code, def) {
            if (def) {
              proj4.defs(code, def);
            } else if (proj4.defs[code] === void 0) {
              var urn = code.split(":");
              if (urn.length > 3) {
                code = urn[urn.length - 3] + ":" + urn[urn.length - 1];
              }
              if (proj4.defs[code] === void 0) {
                throw "No projection definition for code " + code;
              }
            }
            return proj4(code);
          }
        });
        L2.Proj.CRS = L2.Class.extend({
          includes: L2.CRS,
          options: {
            transformation: new L2.Transformation(1, 0, -1, 0)
          },
          initialize: function(a, b, c) {
            var code, proj, def, options;
            if (L2.Proj._isProj4Obj(a)) {
              proj = a;
              code = proj.srsCode;
              options = b || {};
              this.projection = new L2.Proj.Projection(proj, options.bounds);
            } else {
              code = a;
              def = b;
              options = c || {};
              this.projection = new L2.Proj.Projection(code, def, options.bounds);
            }
            L2.Util.setOptions(this, options);
            this.code = code;
            this.transformation = this.options.transformation;
            if (this.options.origin) {
              this.transformation = new L2.Transformation(
                1,
                -this.options.origin[0],
                -1,
                this.options.origin[1]
              );
            }
            if (this.options.scales) {
              this._scales = this.options.scales;
            } else if (this.options.resolutions) {
              this._scales = [];
              for (var i = this.options.resolutions.length - 1; i >= 0; i--) {
                if (this.options.resolutions[i]) {
                  this._scales[i] = 1 / this.options.resolutions[i];
                }
              }
            }
            this.infinite = !this.options.bounds;
          },
          scale: function(zoom) {
            var iZoom = Math.floor(zoom), baseScale, nextScale, scaleDiff, zDiff;
            if (zoom === iZoom) {
              return this._scales[zoom];
            } else {
              baseScale = this._scales[iZoom];
              nextScale = this._scales[iZoom + 1];
              scaleDiff = nextScale - baseScale;
              zDiff = zoom - iZoom;
              return baseScale + scaleDiff * zDiff;
            }
          },
          zoom: function(scale) {
            var downScale = this._closestElement(this._scales, scale), downZoom = this._scales.indexOf(downScale), nextScale, nextZoom, scaleDiff;
            if (scale === downScale) {
              return downZoom;
            }
            if (downScale === void 0) {
              return -Infinity;
            }
            nextZoom = downZoom + 1;
            nextScale = this._scales[nextZoom];
            if (nextScale === void 0) {
              return Infinity;
            }
            scaleDiff = nextScale - downScale;
            return (scale - downScale) / scaleDiff + downZoom;
          },
          distance: L2.CRS.Earth.distance,
          R: L2.CRS.Earth.R,
          /* Get the closest lowest element in an array */
          _closestElement: function(array, element) {
            var low;
            for (var i = array.length; i--; ) {
              if (array[i] <= element && (low === void 0 || low < array[i])) {
                low = array[i];
              }
            }
            return low;
          }
        });
        L2.Proj.GeoJSON = L2.GeoJSON.extend({
          initialize: function(geojson, options) {
            this._callLevel = 0;
            L2.GeoJSON.prototype.initialize.call(this, geojson, options);
          },
          addData: function(geojson) {
            var crs;
            if (geojson) {
              if (geojson.crs && geojson.crs.type === "name") {
                crs = new L2.Proj.CRS(geojson.crs.properties.name);
              } else if (geojson.crs && geojson.crs.type) {
                crs = new L2.Proj.CRS(geojson.crs.type + ":" + geojson.crs.properties.code);
              }
              if (crs !== void 0) {
                this.options.coordsToLatLng = function(coords) {
                  var point = L2.point(coords[0], coords[1]);
                  return crs.projection.unproject(point);
                };
              }
            }
            this._callLevel++;
            try {
              L2.GeoJSON.prototype.addData.call(this, geojson);
            } finally {
              this._callLevel--;
              if (this._callLevel === 0) {
                delete this.options.coordsToLatLng;
              }
            }
          }
        });
        L2.Proj.geoJson = function(geojson, options) {
          return new L2.Proj.GeoJSON(geojson, options);
        };
        L2.Proj.ImageOverlay = L2.ImageOverlay.extend({
          initialize: function(url, bounds, options) {
            L2.ImageOverlay.prototype.initialize.call(this, url, null, options);
            this._projectedBounds = bounds;
          },
          // Danger ahead: Overriding internal methods in Leaflet.
          // Decided to do this rather than making a copy of L.ImageOverlay
          // and doing very tiny modifications to it.
          // Future will tell if this was wise or not.
          _animateZoom: function(event) {
            var scale = this._map.getZoomScale(event.zoom);
            var northWest = L2.point(this._projectedBounds.min.x, this._projectedBounds.max.y);
            var offset = this._projectedToNewLayerPoint(northWest, event.zoom, event.center);
            L2.DomUtil.setTransform(this._image, offset, scale);
          },
          _reset: function() {
            var zoom = this._map.getZoom();
            var pixelOrigin = this._map.getPixelOrigin();
            var bounds = L2.bounds(
              this._transform(this._projectedBounds.min, zoom)._subtract(pixelOrigin),
              this._transform(this._projectedBounds.max, zoom)._subtract(pixelOrigin)
            );
            var size = bounds.getSize();
            L2.DomUtil.setPosition(this._image, bounds.min);
            this._image.style.width = size.x + "px";
            this._image.style.height = size.y + "px";
          },
          _projectedToNewLayerPoint: function(point, zoom, center) {
            var viewHalf = this._map.getSize()._divideBy(2);
            var newTopLeft = this._map.project(center, zoom)._subtract(viewHalf)._round();
            var topLeft = newTopLeft.add(this._map._getMapPanePos());
            return this._transform(point, zoom)._subtract(topLeft);
          },
          _transform: function(point, zoom) {
            var crs = this._map.options.crs;
            var transformation = crs.transformation;
            var scale = crs.scale(zoom);
            return transformation.transform(point, scale);
          }
        });
        L2.Proj.imageOverlay = function(url, bounds, options) {
          return new L2.Proj.ImageOverlay(url, bounds, options);
        };
        return L2.Proj;
      });
    }
  });

  // <stdin>
  var stdin_exports = {};
  __export(stdin_exports, {
    default: () => stdin_default
  });

  // C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/static/route/points.js
  var points = [
    {
      id: "point-1",
      latitude: "24.182220",
      longitude: "120.686250",
      image: "https://mapapi.qq.com/web/lbs/javascriptGL/demo/img/car.png",
      time: "2024-11-5 16:02:00",
      description: "\u4EFB\u52A1\u5F00\u59CB"
    },
    {
      id: "point-2",
      latitude: "24.120192",
      longitude: "120.667024",
      image: "https://mapapi.qq.com/web/lbs/javascriptGL/demo/img/car.png",
      time: "2024-11-5 16:12:00",
      description: "\u5230\u8FBE\u5730\u70B91"
    },
    {
      id: "point-3",
      latitude: "24.142751",
      longitude: "120.699296",
      image: "https://mapapi.qq.com/web/lbs/javascriptGL/demo/img/car.png",
      time: "2024-11-5 16:22:00",
      description: "\u5230\u8FBE\u5730\u70B92"
    },
    {
      id: "point-4",
      latitude: "24.138365",
      longitude: "120.728135",
      image: "https://mapapi.qq.com/web/lbs/javascriptGL/demo/img/car.png",
      time: "2024-11-5 16:32:00",
      description: "\u5B8C\u6210\u884C\u52A8\u76EE\u6807"
    },
    {
      id: "point-5",
      latitude: "24.133979",
      longitude: "120.69655",
      image: "https://mapapi.qq.com/web/lbs/javascriptGL/demo/img/car.png",
      time: "2024-11-5 16:42:00",
      description: "\u4EFB\u52A1\u7ED3\u675F"
    }
  ];

  // C:/Users/qyl23/Documents/HBuilderProjects/zk_uniapp/config.js
  var tileUrls = {
    "google": {
      url: "https://www.google.cn/maps/vt?lyrs=m@189&gl=cn&x={x}&y={y}&z={z}",
      // url: 'https://www.google.cn/maps/vt?lyrs=m@189&gl=cn&x=[x]&y=[y]&z=[z]',
      name: "\u8C37\u6B4C\u5730\u56FE",
      subdomains: []
    },
    "gaode": {
      url: "https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x={x}&y={y}&z={z}",
      // url: 'https://webrd04.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x=[x]&y=[y]&z=[z]',
      name: "\u9AD8\u5FB7\u5730\u56FE",
      subdomains: ["1", "2", "3", "4"]
    },
    //
    "baidu": {
      // url: '//online{s}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles=pl&scaler=1&p=1',
      url: "https://maponline{s}.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=pl&scaler=2&udt=&from=jsapi2_0",
      name: "\u767E\u5EA6\u5730\u56FE",
      subdomains: ["0", "1", "2"]
    },
    "local": {
      url: "static/tiles/map/{z}/{x}/{y}.png",
      // url: 'static/tiles/map/[z]/[x]/[y].png',
      name: "\u79BB\u7EBF\u5730\u56FE",
      subdomains: []
    }
  };

  // <stdin>
  var import_leaflet = __toESM(require_leaflet());
  var import_proj4 = __toESM(require_proj4());
  var import_proj4leaflet = __toESM(require_proj4leaflet());
  var map = null;
  var baseTileLayer = null;
  var markers = [];
  var featureGroup = L.featureGroup();
  L.CRS.Baidu = new L.Proj.CRS(
    "EPSG:900913",
    "+proj=merc +a=6378206 +b=6356584.314245179 +lat_ts=0.0 +lon_0=0.0 +x_0=0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs",
    {
      resolutions: function() {
        var level = 21;
        var res = [];
        res[0] = Math.pow(2, 18);
        for (var i = 1; i < level; i++) {
          res[i] = Math.pow(2, 18 - i);
        }
        return res;
      }(),
      origin: [0, 0],
      bounds: L.bounds([20037508342789244e-9, 0], [0, 20037508342789244e-9])
    }
  );
  var stdin_default = {
    data() {
      return {
        position: {
          longitude: 120.68625,
          latitude: 24.18222
        },
        mapType: "gaode",
        geoJson: null
      };
    },
    created() {
    },
    mounted() {
      this.$ownerInstance.callMethod("setPoint");
      this.$ownerInstance.callMethod("setGeoJson");
      this.$nextTick(() => {
        this.initMap();
        this.getLine();
        this.addGeoJsonLayer(this.geoJson, "red", featureGroup);
      });
    },
    methods: {
      /** position
       * @param {Object} position
       */
      getPosition(position) {
        this.position = position;
        if (map != null) {
          map.setView(L.latLng(this.position.latitude, this.position.longitude), 12);
        }
      },
      /** 
       * mathType
       * @param {Object} position
       */
      setMapType(value) {
        if (this.mapType == "baidu" || value == "baidu") {
          this.mapType = value;
          this.initMap();
          this.getLine();
          this.addGeoJsonLayer(this.geoJson, "red", featureGroup);
        } else {
          this.mapType = value;
          this.changeMap(this.mapType);
        }
      },
      /**
       * GeoJson
       * @param {Object} geoJson
       */
      setGeoJson(value) {
        this.geoJson = value;
        this.addGeoJsonLayer(this.geoJson, "red", featureGroup);
      },
      /** 
       */
      initMap() {
        var container = L.DomUtil.get("map_container");
        if (container != null) {
          container._leaflet_id = null;
          L.DomUtil.empty(container);
        }
        if (this.mapType == "baidu") {
          map = L.map("map_container", {
            crs: L.CRS.Baidu,
            zoom: 12,
            center: [this.position.latitude, this.position.longitude],
            zoomControl: false,
            // + - 
            attributionControl: false
            // leaflet
          });
          baseTileLayer = L.tileLayer(tileUrls[this.mapType].url, {
            tms: true,
            subdomains: tileUrls[this.mapType].subdomains,
            attribution: `&copy;${tileUrls[this.mapType].name}`
          });
          baseTileLayer.addTo(map);
        } else {
          map = L.map("map_container", {
            zoom: 12,
            center: [this.position.latitude, this.position.longitude],
            zoomControl: false,
            // + - 
            attributionControl: false
            // leaflet
          });
          baseTileLayer = L.tileLayer(tileUrls[this.mapType].url, {
            subdomains: tileUrls[this.mapType].subdomains,
            attribution: `&copy;${tileUrls[this.mapType].name}`
          });
          baseTileLayer.addTo(map);
        }
        L.control.attribution({
          prefix: ""
        }).addTo(map);
        setTimeout(() => {
          map.invalidateSize();
        }, 500);
      },
      /**  
       * @param {String} mapType 
       */
      changeMap(mapType) {
        if (baseTileLayer != null) {
          baseTileLayer.remove();
          const attributions = map.attributionControl._attributions;
          for (const attr in attributions) {
            if (attributions.hasOwnProperty(attr)) {
              map.attributionControl.removeAttribution(attr);
            }
          }
        }
        baseTileLayer = L.tileLayer(
          tileUrls[mapType].url,
          {
            attribution: `&copy;${tileUrls[mapType].name}`,
            subdomains: tileUrls[this.mapType].subdomains
          }
        );
        baseTileLayer.addTo(map);
        setTimeout(() => {
          map.invalidateSize();
        }, 500);
      },
      /** 
       * @param {Boolean} replay
       */
      getReplay(replay) {
        this.replay = replay;
        if (replay) {
          this.replayMission();
        }
      },
      replayMission() {
        let index = 1;
        map.flyTo([points[0].latitude, points[0].longitude], 15);
        markers[0].openPopup();
        const interval = setInterval(() => {
          if (index >= points.length || !this.replay) {
            clearInterval(interval);
            this.$ownerInstance.callMethod("setReplay", false);
            return;
          }
          const point = points[index];
          map.flyTo([point.latitude, point.longitude], 15);
          markers[index].openPopup();
          index++;
        }, 4e3);
      },
      /** 
       * @param {Array} points 
       */
      addLine(points2) {
        let latlngs = points2.map((point) => [point.latitude, point.longitude]);
        var polyline = L.polyline(latlngs, {
          color: "red"
        }).addTo(map).bringToFront();
      },
      /** 
       * @param {Object} point
       */
      addMarker(point) {
        var marker = L.marker([point.latitude, point.longitude]).addTo(map);
        marker.bindPopup(`<view style="display:flex;flex-direction:column"><text>${point.description}</text>
							<image src='${point.image}' style="max-width: 300px; max-height: 300px;"/></view>`);
        markers.push(marker);
      },
      addGeoJsonLayer(geoJson, color, featureGroup2) {
        if (!geoJson) {
          return;
        }
        if (featureGroup2) {
          featureGroup2.eachLayer((layer) => {
            map.removeLayer(layer);
          });
          featureGroup2 = L.featureGroup();
        }
        L.geoJSON(geoJson, {
          style: {
            color
          },
          onEachFeature: (_feature, layer) => {
            featureGroup2.addLayer(layer);
          }
        }).addTo(map);
      },
      getLine() {
        let prev = null;
        let index = 0;
        markers = [];
        for (let index2 = 0; index2 < points.length; index2++) {
          let curr = points[index2];
          this.addMarker(curr);
        }
        ;
        this.addLine(points);
      }
    }
  };
  return __toCommonJS(stdin_exports);
})();
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
/*! Bundled license information:

leaflet/dist/leaflet-src.js:
  (* @preserve
   * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
   * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   *)
*/
