if (typeof Promise !== "undefined" && !Promise.prototype.finally) {
  Promise.prototype.finally = function(callback) {
    const promise = this.constructor;
    return this.then(
      (value) => promise.resolve(callback()).then(() => value),
      (reason) => promise.resolve(callback()).then(() => {
        throw reason;
      })
    );
  };
}
;
if (typeof uni !== "undefined" && uni && uni.requireGlobal) {
  const global2 = uni.requireGlobal();
  ArrayBuffer = global2.ArrayBuffer;
  Int8Array = global2.Int8Array;
  Uint8Array = global2.Uint8Array;
  Uint8ClampedArray = global2.Uint8ClampedArray;
  Int16Array = global2.Int16Array;
  Uint16Array = global2.Uint16Array;
  Int32Array = global2.Int32Array;
  Uint32Array = global2.Uint32Array;
  Float32Array = global2.Float32Array;
  Float64Array = global2.Float64Array;
  BigInt64Array = global2.BigInt64Array;
  BigUint64Array = global2.BigUint64Array;
}
;
if (uni.restoreGlobal) {
  uni.restoreGlobal(Vue, weex, plus, setTimeout, clearTimeout, setInterval, clearInterval);
}
(function(vue) {
  "use strict";
  const _imports_1$6 = "/static/icon/X.png";
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$1a = {
    data() {
      return {
        statusBarHeight: 0
      };
    },
    onLoad: function() {
      const systemInfo = uni.getSystemInfoSync();
      this.statusBarHeight = systemInfo.statusBarHeight;
    },
    methods: {
      goToLogin() {
        uni.navigateTo({
          url: "/pages/login/camouflageLogin/inputAccount/inputAccount"
        });
      },
      goToFingerLogin() {
        uni.navigateTo({
          url: "/pages/fingerLogin/fingerLogin"
        });
      },
      goToRegister() {
        uni.navigateTo({
          url: "/pages/register/register"
        });
      }
    }
  };
  function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "camouflagePage" }, [
      vue.createElementVNode("view", { class: "statusBar" }),
      vue.createElementVNode("view", { class: "camouflageLayout" }, [
        vue.createCommentVNode(" 推特logo "),
        vue.createElementVNode("view", { style: { "text-align": "center", "margin-top": "10px" } }, [
          vue.createElementVNode("image", {
            src: _imports_1$6,
            style: { "width": "25px", "height": "25px" }
          })
        ]),
        vue.createElementVNode("view", { style: { "margin-top": "250px", "text-align": "left" } }, [
          vue.createElementVNode("text", { style: { "letter-spacing": "3px", "font-size": "65rpx", "font-family": "fantasy", "font-weight": "550", "width": "75%" } }, "查看世界各地的新鲜事。")
        ]),
        vue.createElementVNode("view", { class: "createAccount" }, [
          vue.createElementVNode("button", {
            onClick: _cache[0] || (_cache[0] = (...args) => $options.goToRegister && $options.goToRegister(...args)),
            type: "primary",
            style: { "border-radius": "20px", "background": "#1d9bf0" }
          }, "创建账号")
        ])
      ]),
      vue.createElementVNode("view", { class: "camouflageFooter" }, [
        vue.createElementVNode("view", null, [
          vue.createElementVNode("text", null, "已经有账号了？"),
          vue.createElementVNode("text", {
            onClick: _cache[1] || (_cache[1] = (...args) => $options.goToLogin && $options.goToLogin(...args)),
            style: { "color": "#1d9bf0" }
          }, "登录")
        ]),
        vue.createElementVNode("view", null, [
          vue.createElementVNode("text", {
            onClick: _cache[2] || (_cache[2] = (...args) => $options.goToFingerLogin && $options.goToFingerLogin(...args)),
            style: { "color": "#1d9bf0" }
          }, "指纹登录")
        ])
      ])
    ]);
  }
  const PagesLoginCamouflageLoginCamouflageLogin = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$19], ["__file", "E:/代码/new/zk_uniapp/pages/login/camouflageLogin/camouflageLogin.vue"]]);
  const ON_SHOW = "onShow";
  function requireNativePlugin(name) {
    return weex.requireModule(name);
  }
  function formatAppLog(type, filename, ...args) {
    if (uni.__log__) {
      uni.__log__(type, filename, ...args);
    } else {
      console[type].apply(console, [...args, filename]);
    }
  }
  function resolveEasycom(component, easycom) {
    return typeof component === "string" ? easycom : component;
  }
  const createHook = (lifecycle) => (hook, target = vue.getCurrentInstance()) => {
    !vue.isInSSRComponentSetup && vue.injectHook(lifecycle, hook, target);
  };
  const onShow = /* @__PURE__ */ createHook(ON_SHOW);
  const backendHost = "http://139.196.11.210:8500/communicate";
  const LIVEKITURL = "ws://192.168.37.163:7880";
  const BASE_URL = backendHost;
  const timeout = 5e3;
  const request = (params) => {
    let url = params.url;
    let method = params.method || "get";
    let data = params.data || {};
    let header = {
      "Content-Type": "application/json;charset=UTF-8",
      "Authorization": "Bearer " + uni.getStorageSync("token"),
      ...params.header
    };
    return new Promise((resolve, reject) => {
      uni.request({
        url: BASE_URL + url,
        method,
        header,
        data,
        timeout,
        success(response) {
          const res = response;
          if (res.statusCode == 200) {
            resolve(res.data);
          } else {
            switch (res.statusCode) {
              case 404:
                uni.showToast({
                  title: "请求地址不存在...",
                  duration: 2e3
                });
                break;
              default:
                uni.showToast({
                  title: "请重试...",
                  duration: 2e3
                });
                break;
            }
          }
        },
        fail(err) {
          formatAppLog("log", "at utils/request.js:57", err);
          if (err.errMsg.indexOf("request:fail") !== -1) {
            uni.showToast({
              title: "网络异常",
              icon: "error",
              duration: 2e3
            });
          } else {
            uni.showToast({
              title: "未知异常",
              duration: 2e3
            });
          }
          reject(err);
        },
        complete() {
          uni.hideLoading();
          uni.hideToast();
        }
      });
    }).catch(() => {
    });
  };
  const login = (params) => {
    const data = {
      account: params.account,
      password: params.password
    };
    return request({
      // url: `/user/login?account=${params.account}&password=${params.password}`,
      url: `/user/login`,
      method: "post",
      header: {
        "Authorization": ""
      },
      data
    });
  };
  const register = (params) => {
    return request({
      url: "/user/register",
      method: "post",
      data: params
    });
  };
  const logout = (params) => {
    return request({
      url: "/user/logout",
      method: "post"
    });
  };
  var isVue2 = false;
  function set$1(target, key, val) {
    if (Array.isArray(target)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    target[key] = val;
    return val;
  }
  function del(target, key) {
    if (Array.isArray(target)) {
      target.splice(key, 1);
      return;
    }
    delete target[key];
  }
  function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  }
  const isProxyAvailable = typeof Proxy === "function";
  const HOOK_SETUP = "devtools-plugin:setup";
  const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
  let supported;
  let perf;
  function isPerformanceSupported() {
    var _a;
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
      supported = true;
      perf = global.perf_hooks.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
  }
  class ApiProxy {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = Object.assign({}, defaultSettings);
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e2) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e2) {
          }
          currentSettings = value;
        },
        now() {
          return now();
        }
      };
      if (hook) {
        hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
          if (pluginId === this.plugin.id) {
            this.fallbacks.setSettings(value);
          }
        });
      }
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  }
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = getTarget();
    const hook = getDevtoolsGlobalHook();
    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor: descriptor,
        setupFn,
        proxy
      });
      if (proxy)
        setupFn(proxy.proxiedTarget);
    }
  }
  /*!
   * pinia v2.1.7
   * (c) 2023 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia) => activePinia = pinia;
  const piniaSymbol = Symbol("pinia");
  function isPlainObject(o2) {
    return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  const IS_CLIENT = typeof window !== "undefined";
  const USE_DEVTOOLS = IS_CLIENT;
  const _global = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
  function bom(blob, { autoBom = false } = {}) {
    if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
      return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
    }
    return blob;
  }
  function download(url, name, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.onload = function() {
      saveAs(xhr.response, name, opts);
    };
    xhr.onerror = function() {
      console.error("could not download file");
    };
    xhr.send();
  }
  function corsEnabled(url) {
    const xhr = new XMLHttpRequest();
    xhr.open("HEAD", url, false);
    try {
      xhr.send();
    } catch (e2) {
    }
    return xhr.status >= 200 && xhr.status <= 299;
  }
  function click(node) {
    try {
      node.dispatchEvent(new MouseEvent("click"));
    } catch (e2) {
      const evt = document.createEvent("MouseEvents");
      evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      node.dispatchEvent(evt);
    }
  }
  const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
  const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
  const saveAs = !IS_CLIENT ? () => {
  } : (
    // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
    typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
      // Use msSaveOrOpenBlob as a second approach
      "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
        // Fallback to using FileReader and a popup
        fileSaverSaveAs
      )
    )
  );
  function downloadSaveAs(blob, name = "download", opts) {
    const a2 = document.createElement("a");
    a2.download = name;
    a2.rel = "noopener";
    if (typeof blob === "string") {
      a2.href = blob;
      if (a2.origin !== location.origin) {
        if (corsEnabled(a2.href)) {
          download(blob, name, opts);
        } else {
          a2.target = "_blank";
          click(a2);
        }
      } else {
        click(a2);
      }
    } else {
      a2.href = URL.createObjectURL(blob);
      setTimeout(function() {
        URL.revokeObjectURL(a2.href);
      }, 4e4);
      setTimeout(function() {
        click(a2);
      }, 0);
    }
  }
  function msSaveAs(blob, name = "download", opts) {
    if (typeof blob === "string") {
      if (corsEnabled(blob)) {
        download(blob, name, opts);
      } else {
        const a2 = document.createElement("a");
        a2.href = blob;
        a2.target = "_blank";
        setTimeout(function() {
          click(a2);
        });
      }
    } else {
      navigator.msSaveOrOpenBlob(bom(blob, opts), name);
    }
  }
  function fileSaverSaveAs(blob, name, opts, popup2) {
    popup2 = popup2 || open("", "_blank");
    if (popup2) {
      popup2.document.title = popup2.document.body.innerText = "downloading...";
    }
    if (typeof blob === "string")
      return download(blob, name, opts);
    const force = blob.type === "application/octet-stream";
    const isSafari2 = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || force && isSafari2 || isMacOSWebView) && typeof FileReader !== "undefined") {
      const reader = new FileReader();
      reader.onloadend = function() {
        let url = reader.result;
        if (typeof url !== "string") {
          popup2 = null;
          throw new Error("Wrong reader.result type");
        }
        url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
        if (popup2) {
          popup2.location.href = url;
        } else {
          location.assign(url);
        }
        popup2 = null;
      };
      reader.readAsDataURL(blob);
    } else {
      const url = URL.createObjectURL(blob);
      if (popup2)
        popup2.location.assign(url);
      else
        location.href = url;
      popup2 = null;
      setTimeout(function() {
        URL.revokeObjectURL(url);
      }, 4e4);
    }
  }
  function toastMessage(message, type) {
    const piniaMessage = "🍍 " + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
      __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    } else if (type === "error") {
      console.error(piniaMessage);
    } else if (type === "warn") {
      console.warn(piniaMessage);
    } else {
      console.log(piniaMessage);
    }
  }
  function isPinia(o2) {
    return "_a" in o2 && "install" in o2;
  }
  function checkClipboardAccess() {
    if (!("clipboard" in navigator)) {
      toastMessage(`Your browser doesn't support the Clipboard API`, "error");
      return true;
    }
  }
  function checkNotFocusedError(error) {
    if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
      toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
      return true;
    }
    return false;
  }
  async function actionGlobalCopyState(pinia) {
    if (checkClipboardAccess())
      return;
    try {
      await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
      toastMessage("Global state copied to clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  async function actionGlobalPasteState(pinia) {
    if (checkClipboardAccess())
      return;
    try {
      loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));
      toastMessage("Global state pasted from clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  async function actionGlobalSaveState(pinia) {
    try {
      saveAs(new Blob([JSON.stringify(pinia.state.value)], {
        type: "text/plain;charset=utf-8"
      }), "pinia-state.json");
    } catch (error) {
      toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  let fileInput;
  function getFileOpener() {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".json";
    }
    function openFile() {
      return new Promise((resolve, reject) => {
        fileInput.onchange = async () => {
          const files = fileInput.files;
          if (!files)
            return resolve(null);
          const file = files.item(0);
          if (!file)
            return resolve(null);
          return resolve({ text: await file.text(), file });
        };
        fileInput.oncancel = () => resolve(null);
        fileInput.onerror = reject;
        fileInput.click();
      });
    }
    return openFile;
  }
  async function actionGlobalOpenStateFile(pinia) {
    try {
      const open2 = getFileOpener();
      const result = await open2();
      if (!result)
        return;
      const { text, file } = result;
      loadStoresState(pinia, JSON.parse(text));
      toastMessage(`Global state imported from "${file.name}".`);
    } catch (error) {
      toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  function loadStoresState(pinia, state) {
    for (const key in state) {
      const storeState = pinia.state.value[key];
      if (storeState) {
        Object.assign(storeState, state[key]);
      } else {
        pinia.state.value[key] = state[key];
      }
    }
  }
  function formatDisplay(display) {
    return {
      _custom: {
        display
      }
    };
  }
  const PINIA_ROOT_LABEL = "🍍 Pinia (root)";
  const PINIA_ROOT_ID = "_root";
  function formatStoreForInspectorTree(store2) {
    return isPinia(store2) ? {
      id: PINIA_ROOT_ID,
      label: PINIA_ROOT_LABEL
    } : {
      id: store2.$id,
      label: store2.$id
    };
  }
  function formatStoreForInspectorState(store2) {
    if (isPinia(store2)) {
      const storeNames = Array.from(store2._s.keys());
      const storeMap = store2._s;
      const state2 = {
        state: storeNames.map((storeId) => ({
          editable: true,
          key: storeId,
          value: store2.state.value[storeId]
        })),
        getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
          const store22 = storeMap.get(id);
          return {
            editable: false,
            key: id,
            value: store22._getters.reduce((getters, key) => {
              getters[key] = store22[key];
              return getters;
            }, {})
          };
        })
      };
      return state2;
    }
    const state = {
      state: Object.keys(store2.$state).map((key) => ({
        editable: true,
        key,
        value: store2.$state[key]
      }))
    };
    if (store2._getters && store2._getters.length) {
      state.getters = store2._getters.map((getterName) => ({
        editable: false,
        key: getterName,
        value: store2[getterName]
      }));
    }
    if (store2._customProperties.size) {
      state.customProperties = Array.from(store2._customProperties).map((key) => ({
        editable: true,
        key,
        value: store2[key]
      }));
    }
    return state;
  }
  function formatEventData(events2) {
    if (!events2)
      return {};
    if (Array.isArray(events2)) {
      return events2.reduce((data, event) => {
        data.keys.push(event.key);
        data.operations.push(event.type);
        data.oldValue[event.key] = event.oldValue;
        data.newValue[event.key] = event.newValue;
        return data;
      }, {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
      });
    } else {
      return {
        operation: formatDisplay(events2.type),
        key: formatDisplay(events2.key),
        oldValue: events2.oldValue,
        newValue: events2.newValue
      };
    }
  }
  function formatMutationType(type) {
    switch (type) {
      case MutationType.direct:
        return "mutation";
      case MutationType.patchFunction:
        return "$patch";
      case MutationType.patchObject:
        return "$patch";
      default:
        return "unknown";
    }
  }
  let isTimelineActive = true;
  const componentStateTypes = [];
  const MUTATIONS_LAYER_ID = "pinia:mutations";
  const INSPECTOR_ID = "pinia";
  const { assign: assign$1 } = Object;
  const getStoreType = (id) => "🍍 " + id;
  function registerPiniaDevtools(app, pinia) {
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia 🍍",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app
    }, (api) => {
      if (typeof api.now !== "function") {
        toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
      }
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: `Pinia 🍍`,
        color: 15064968
      });
      api.addInspector({
        id: INSPECTOR_ID,
        label: "Pinia 🍍",
        icon: "storage",
        treeFilterPlaceholder: "Search stores",
        actions: [
          {
            icon: "content_copy",
            action: () => {
              actionGlobalCopyState(pinia);
            },
            tooltip: "Serialize and copy the state"
          },
          {
            icon: "content_paste",
            action: async () => {
              await actionGlobalPasteState(pinia);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Replace the state with the content of your clipboard"
          },
          {
            icon: "save",
            action: () => {
              actionGlobalSaveState(pinia);
            },
            tooltip: "Save the state as a JSON file"
          },
          {
            icon: "folder_open",
            action: async () => {
              await actionGlobalOpenStateFile(pinia);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Import the state from a JSON file"
          }
        ],
        nodeActions: [
          {
            icon: "restore",
            tooltip: 'Reset the state (with "$reset")',
            action: (nodeId) => {
              const store2 = pinia._s.get(nodeId);
              if (!store2) {
                toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
              } else if (typeof store2.$reset !== "function") {
                toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
              } else {
                store2.$reset();
                toastMessage(`Store "${nodeId}" reset.`);
              }
            }
          }
        ]
      });
      api.on.inspectComponent((payload, ctx) => {
        const proxy = payload.componentInstance && payload.componentInstance.proxy;
        if (proxy && proxy._pStores) {
          const piniaStores = payload.componentInstance.proxy._pStores;
          Object.values(piniaStores).forEach((store2) => {
            payload.instanceData.state.push({
              type: getStoreType(store2.$id),
              key: "state",
              editable: true,
              value: store2._isOptionsAPI ? {
                _custom: {
                  value: vue.toRaw(store2.$state),
                  actions: [
                    {
                      icon: "restore",
                      tooltip: "Reset the state of this store",
                      action: () => store2.$reset()
                    }
                  ]
                }
              } : (
                // NOTE: workaround to unwrap transferred refs
                Object.keys(store2.$state).reduce((state, key) => {
                  state[key] = store2.$state[key];
                  return state;
                }, {})
              )
            });
            if (store2._getters && store2._getters.length) {
              payload.instanceData.state.push({
                type: getStoreType(store2.$id),
                key: "getters",
                editable: false,
                value: store2._getters.reduce((getters, key) => {
                  try {
                    getters[key] = store2[key];
                  } catch (error) {
                    getters[key] = error;
                  }
                  return getters;
                }, {})
              });
            }
          });
        }
      });
      api.on.getInspectorTree((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          let stores = [pinia];
          stores = stores.concat(Array.from(pinia._s.values()));
          payload.rootNodes = (payload.filter ? stores.filter((store2) => "$id" in store2 ? store2.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
        }
      });
      api.on.getInspectorState((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
          if (!inspectedStore) {
            return;
          }
          if (inspectedStore) {
            payload.state = formatStoreForInspectorState(inspectedStore);
          }
        }
      });
      api.on.editInspectorState((payload, ctx) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
          if (!inspectedStore) {
            return toastMessage(`store "${payload.nodeId}" not found`, "error");
          }
          const { path } = payload;
          if (!isPinia(inspectedStore)) {
            if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
              path.unshift("$state");
            }
          } else {
            path.unshift("state");
          }
          isTimelineActive = false;
          payload.set(inspectedStore, path, payload.state.value);
          isTimelineActive = true;
        }
      });
      api.on.editComponentState((payload) => {
        if (payload.type.startsWith("🍍")) {
          const storeId = payload.type.replace(/^🍍\s*/, "");
          const store2 = pinia._s.get(storeId);
          if (!store2) {
            return toastMessage(`store "${storeId}" not found`, "error");
          }
          const { path } = payload;
          if (path[0] !== "state") {
            return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
          }
          path[0] = "$state";
          isTimelineActive = false;
          payload.set(store2, path, payload.state.value);
          isTimelineActive = true;
        }
      });
    });
  }
  function addStoreToDevtools(app, store2) {
    if (!componentStateTypes.includes(getStoreType(store2.$id))) {
      componentStateTypes.push(getStoreType(store2.$id));
    }
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia 🍍",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app,
      settings: {
        logStoreChanges: {
          label: "Notify about new/deleted stores",
          type: "boolean",
          defaultValue: true
        }
        // useEmojis: {
        //   label: 'Use emojis in messages ⚡️',
        //   type: 'boolean',
        //   defaultValue: true,
        // },
      }
    }, (api) => {
      const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
      store2.$onAction(({ after, onError, name, args }) => {
        const groupId = runningActionId++;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "🛫 " + name,
            subtitle: "start",
            data: {
              store: formatDisplay(store2.$id),
              action: formatDisplay(name),
              args
            },
            groupId
          }
        });
        after((result) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "🛬 " + name,
              subtitle: "end",
              data: {
                store: formatDisplay(store2.$id),
                action: formatDisplay(name),
                args,
                result
              },
              groupId
            }
          });
        });
        onError((error) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              logType: "error",
              title: "💥 " + name,
              subtitle: "end",
              data: {
                store: formatDisplay(store2.$id),
                action: formatDisplay(name),
                args,
                error
              },
              groupId
            }
          });
        });
      }, true);
      store2._customProperties.forEach((name) => {
        vue.watch(() => vue.unref(store2[name]), (newValue, oldValue) => {
          api.notifyComponentUpdate();
          api.sendInspectorState(INSPECTOR_ID);
          if (isTimelineActive) {
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: "Change",
                subtitle: name,
                data: {
                  newValue,
                  oldValue
                },
                groupId: activeAction
              }
            });
          }
        }, { deep: true });
      });
      store2.$subscribe(({ events: events2, type }, state) => {
        api.notifyComponentUpdate();
        api.sendInspectorState(INSPECTOR_ID);
        if (!isTimelineActive)
          return;
        const eventData = {
          time: now2(),
          title: formatMutationType(type),
          data: assign$1({ store: formatDisplay(store2.$id) }, formatEventData(events2)),
          groupId: activeAction
        };
        if (type === MutationType.patchFunction) {
          eventData.subtitle = "⤵️";
        } else if (type === MutationType.patchObject) {
          eventData.subtitle = "🧩";
        } else if (events2 && !Array.isArray(events2)) {
          eventData.subtitle = events2.type;
        }
        if (events2) {
          eventData.data["rawEvent(s)"] = {
            _custom: {
              display: "DebuggerEvent",
              type: "object",
              tooltip: "raw DebuggerEvent[]",
              value: events2
            }
          };
        }
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: eventData
        });
      }, { detached: true, flush: "sync" });
      const hotUpdate = store2._hotUpdate;
      store2._hotUpdate = vue.markRaw((newStore) => {
        hotUpdate(newStore);
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "🔥 " + store2.$id,
            subtitle: "HMR update",
            data: {
              store: formatDisplay(store2.$id),
              info: formatDisplay(`HMR update`)
            }
          }
        });
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
      });
      const { $dispose } = store2;
      store2.$dispose = () => {
        $dispose();
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges && toastMessage(`Disposed "${store2.$id}" store 🗑`);
      };
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.getSettings().logStoreChanges && toastMessage(`"${store2.$id}" store installed 🆕`);
    });
  }
  let runningActionId = 0;
  let activeAction;
  function patchActionForGrouping(store2, actionNames, wrapWithProxy) {
    const actions = actionNames.reduce((storeActions, actionName) => {
      storeActions[actionName] = vue.toRaw(store2)[actionName];
      return storeActions;
    }, {});
    for (const actionName in actions) {
      store2[actionName] = function() {
        const _actionId = runningActionId;
        const trackedStore = wrapWithProxy ? new Proxy(store2, {
          get(...args) {
            activeAction = _actionId;
            return Reflect.get(...args);
          },
          set(...args) {
            activeAction = _actionId;
            return Reflect.set(...args);
          }
        }) : store2;
        activeAction = _actionId;
        const retValue = actions[actionName].apply(trackedStore, arguments);
        activeAction = void 0;
        return retValue;
      };
    }
  }
  function devtoolsPlugin({ app, store: store2, options }) {
    if (store2.$id.startsWith("__hot:")) {
      return;
    }
    store2._isOptionsAPI = !!options.state;
    patchActionForGrouping(store2, Object.keys(options.actions), store2._isOptionsAPI);
    const originalHotUpdate = store2._hotUpdate;
    vue.toRaw(store2)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store2, Object.keys(newStore._hmrPayload.actions), !!store2._isOptionsAPI);
    };
    addStoreToDevtools(
      app,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      store2
    );
  }
  function createPinia() {
    const scope = vue.effectScope(true);
    const state = scope.run(() => vue.ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = vue.markRaw({
      install(app) {
        setActivePinia(pinia);
        {
          pinia._a = app;
          app.provide(piniaSymbol, pinia);
          app.config.globalProperties.$pinia = pinia;
          if (USE_DEVTOOLS) {
            registerPiniaDevtools(app, pinia);
          }
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
      pinia.use(devtoolsPlugin);
    }
    return pinia;
  }
  function patchObject(newState, oldState) {
    for (const key in oldState) {
      const subPatch = oldState[key];
      if (!(key in newState)) {
        continue;
      }
      const targetValue = newState[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
        newState[key] = patchObject(targetValue, subPatch);
      } else {
        {
          newState[key] = subPatch;
        }
      }
    }
    return newState;
  }
  const noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && vue.getCurrentScope()) {
      vue.onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    }
    if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = Symbol("pinia:skipHydration");
  function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o2) {
    return !!(vue.isRef(o2) && o2.effect);
  }
  function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store2;
    function setup() {
      if (!initialState && !hot) {
        {
          pinia.state.value[id] = state ? state() : {};
        }
      }
      const localState = hot ? (
        // use ref() to unwrap refs inside state TODO: check if this is still necessary
        vue.toRefs(vue.ref(state ? state() : {}).value)
      ) : vue.toRefs(pinia.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        if (name in localState) {
          console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
        }
        computedGetters[name] = vue.markRaw(vue.computed(() => {
          setActivePinia(pinia);
          const store22 = pinia._s.get(id);
          return getters[name].call(store22, store22);
        }));
        return computedGetters;
      }, {}));
    }
    store2 = createSetupStore(id, setup, options, pinia, hot, true);
    return store2;
  }
  function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    if (!pinia._e.active) {
      throw new Error("Pinia destroyed");
    }
    const $subscribeOptions = {
      deep: true
      // flush: 'post',
    };
    {
      $subscribeOptions.onTrigger = (event) => {
        if (isListening) {
          debuggerEvents = event;
        } else if (isListening == false && !store2._hotUpdating) {
          if (Array.isArray(debuggerEvents)) {
            debuggerEvents.push(event);
          } else {
            console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.");
          }
        }
      };
    }
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && !hot) {
      {
        pinia.state.value[$id] = {};
      }
    }
    const hotState = vue.ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      {
        debuggerEvents = [];
      }
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      vue.nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      () => {
        throw new Error(`🍍: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
      }
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia._s.delete($id);
    }
    function wrapAction(name, action) {
      return function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name,
          store: store2,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store2, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const _hmrPayload = /* @__PURE__ */ vue.markRaw({
      actions: {},
      getters: {},
      state: [],
      hotState
    });
    const partialStore = {
      _p: pinia,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => vue.watch(() => pinia.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store2 = vue.reactive(assign(
      {
        _hmrPayload,
        _customProperties: vue.markRaw(/* @__PURE__ */ new Set())
        // devtools custom properties
      },
      partialStore
      // must be added later
      // setupStore
    ));
    pinia._s.set($id, store2);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = vue.effectScope()).run(setup)));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (vue.isRef(prop) && !isComputed(prop) || vue.isReactive(prop)) {
        if (hot) {
          set$1(hotState.value, key, vue.toRef(setupStore, key));
        } else if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (vue.isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia.state.value[$id][key] = prop;
          }
        }
        {
          _hmrPayload.state.push(key);
        }
      } else if (typeof prop === "function") {
        const actionValue = hot ? prop : wrapAction(key, prop);
        {
          setupStore[key] = actionValue;
        }
        {
          _hmrPayload.actions[key] = prop;
        }
        optionsForPlugin.actions[key] = prop;
      } else {
        if (isComputed(prop)) {
          _hmrPayload.getters[key] = isOptionsStore ? (
            // @ts-expect-error
            options.getters[key]
          ) : prop;
          if (IS_CLIENT) {
            const getters = setupStore._getters || // @ts-expect-error: same
            (setupStore._getters = vue.markRaw([]));
            getters.push(key);
          }
        }
      }
    }
    {
      assign(store2, setupStore);
      assign(vue.toRaw(store2), setupStore);
    }
    Object.defineProperty(store2, "$state", {
      get: () => hot ? hotState.value : pinia.state.value[$id],
      set: (state) => {
        if (hot) {
          throw new Error("cannot set hotState");
        }
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    {
      store2._hotUpdate = vue.markRaw((newStore) => {
        store2._hotUpdating = true;
        newStore._hmrPayload.state.forEach((stateKey) => {
          if (stateKey in store2.$state) {
            const newStateTarget = newStore.$state[stateKey];
            const oldStateSource = store2.$state[stateKey];
            if (typeof newStateTarget === "object" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {
              patchObject(newStateTarget, oldStateSource);
            } else {
              newStore.$state[stateKey] = oldStateSource;
            }
          }
          set$1(store2, stateKey, vue.toRef(newStore.$state, stateKey));
        });
        Object.keys(store2.$state).forEach((stateKey) => {
          if (!(stateKey in newStore.$state)) {
            del(store2, stateKey);
          }
        });
        isListening = false;
        isSyncListening = false;
        pinia.state.value[$id] = vue.toRef(newStore._hmrPayload, "hotState");
        isSyncListening = true;
        vue.nextTick().then(() => {
          isListening = true;
        });
        for (const actionName in newStore._hmrPayload.actions) {
          const action = newStore[actionName];
          set$1(store2, actionName, wrapAction(actionName, action));
        }
        for (const getterName in newStore._hmrPayload.getters) {
          const getter = newStore._hmrPayload.getters[getterName];
          const getterValue = isOptionsStore ? (
            // special handling of options api
            vue.computed(() => {
              setActivePinia(pinia);
              return getter.call(store2, store2);
            })
          ) : getter;
          set$1(store2, getterName, getterValue);
        }
        Object.keys(store2._hmrPayload.getters).forEach((key) => {
          if (!(key in newStore._hmrPayload.getters)) {
            del(store2, key);
          }
        });
        Object.keys(store2._hmrPayload.actions).forEach((key) => {
          if (!(key in newStore._hmrPayload.actions)) {
            del(store2, key);
          }
        });
        store2._hmrPayload = newStore._hmrPayload;
        store2._getters = newStore._getters;
        store2._hotUpdating = false;
      });
    }
    if (USE_DEVTOOLS) {
      const nonEnumerable = {
        writable: true,
        configurable: true,
        // avoid warning on devtools trying to display this property
        enumerable: false
      };
      ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
        Object.defineProperty(store2, p2, assign({ value: store2[p2] }, nonEnumerable));
      });
    }
    pinia._p.forEach((extender) => {
      if (USE_DEVTOOLS) {
        const extensions = scope.run(() => extender({
          store: store2,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        }));
        Object.keys(extensions || {}).forEach((key) => store2._customProperties.add(key));
        assign(store2, extensions);
      } else {
        assign(store2, scope.run(() => extender({
          store: store2,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (store2.$state && typeof store2.$state === "object" && typeof store2.$state.constructor === "function" && !store2.$state.constructor.toString().includes("[native code]")) {
      console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store2.$id}".`);
    }
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store2.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store2;
  }
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
      if (typeof id !== "string") {
        throw new Error(`[🍍]: "defineStore()" must be passed a store id as its first argument.`);
      }
    }
    function useStore(pinia, hot) {
      const hasContext = vue.hasInjectionContext();
      pinia = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia || (hasContext ? vue.inject(piniaSymbol, null) : null);
      if (pinia)
        setActivePinia(pinia);
      if (!activePinia) {
        throw new Error(`[🍍]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
      }
      pinia = activePinia;
      if (!pinia._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia);
        } else {
          createOptionsStore(id, options, pinia);
        }
        {
          useStore._pinia = pinia;
        }
      }
      const store2 = pinia._s.get(id);
      if (hot) {
        const hotId = "__hot:" + id;
        const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);
        hot._hotUpdate(newStore);
        delete pinia.state.value[hotId];
        pinia._s.delete(hotId);
      }
      if (IS_CLIENT) {
        const currentInstance = vue.getCurrentInstance();
        if (currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement
        !hot) {
          const vm = currentInstance.proxy;
          const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
          cache[id] = store2;
        }
      }
      return store2;
    }
    useStore.$id = id;
    return useStore;
  }
  const useUserStore = defineStore("user", () => {
    const state = vue.reactive({
      id: "",
      account: "",
      name: "",
      department: "",
      role: "",
      phone: "",
      created: "",
      avatar: null,
      avatarUrl: "",
      token: "",
      status: "",
      missionId: ""
    });
    function setUserData(data) {
      formatAppLog("log", "at store/userStore.js:22", "设置用户数据:", data);
      Object.keys(data).forEach((key) => {
        if (key in state) {
          state[key] = data[key];
        }
      });
      formatAppLog("log", "at store/userStore.js:28", "更新后的状态:", state);
    }
    function clearUserData() {
      Object.keys(state).forEach((key) => {
        state[key] = state[key] instanceof Object ? null : "";
      });
    }
    function getUserData() {
      return { ...state };
    }
    return { state, setUserData, clearUserData, getUserData };
  });
  var lookup = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    62,
    0,
    62,
    0,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    0,
    0,
    0,
    0,
    63,
    0,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
  ];
  function base64Decode(source, target) {
    var sourceLength = source.length;
    var paddingLength = source[sourceLength - 2] === "=" ? 2 : source[sourceLength - 1] === "=" ? 1 : 0;
    var tmp;
    var byteIndex = 0;
    var baseLength = sourceLength - paddingLength & 4294967292;
    for (var i2 = 0; i2 < baseLength; i2 += 4) {
      tmp = lookup[source.charCodeAt(i2)] << 18 | lookup[source.charCodeAt(i2 + 1)] << 12 | lookup[source.charCodeAt(i2 + 2)] << 6 | lookup[source.charCodeAt(i2 + 3)];
      target[byteIndex++] = tmp >> 16 & 255;
      target[byteIndex++] = tmp >> 8 & 255;
      target[byteIndex++] = tmp & 255;
    }
    if (paddingLength === 1) {
      tmp = lookup[source.charCodeAt(i2)] << 10 | lookup[source.charCodeAt(i2 + 1)] << 4 | lookup[source.charCodeAt(i2 + 2)] >> 2;
      target[byteIndex++] = tmp >> 8 & 255;
      target[byteIndex++] = tmp & 255;
    }
    if (paddingLength === 2) {
      tmp = lookup[source.charCodeAt(i2)] << 2 | lookup[source.charCodeAt(i2 + 1)] >> 4;
      target[byteIndex++] = tmp & 255;
    }
  }
  const $inject_window_crypto = {
    getRandomValues(arr) {
      if (!(arr instanceof Int8Array || arr instanceof Uint8Array || arr instanceof Int16Array || arr instanceof Uint16Array || arr instanceof Int32Array || arr instanceof Uint32Array || arr instanceof Uint8ClampedArray)) {
        throw new Error("Expected an integer array");
      }
      if (arr.byteLength > 65536) {
        throw new Error("Can only request a maximum of 65536 bytes");
      }
      var crypto = requireNativePlugin("DCloud-Crypto");
      base64Decode(crypto.getRandomValues(arr.byteLength), new Uint8Array(
        arr.buffer,
        arr.byteOffset,
        arr.byteLength
      ));
      return arr;
    }
  };
  function getToken(roomName, userId) {
    return request({
      method: "post",
      url: "/livekit/token",
      data: { roomName, participantName: userId }
    });
  }
  var define_process_env_default = {};
  function _mergeNamespaces$1(n2, m2) {
    m2.forEach(function(e2) {
      e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k) {
        if (k !== "default" && !(k in n2)) {
          var d2 = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n2, k, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return e2[k];
            }
          });
        }
      });
    });
    return Object.freeze(n2);
  }
  var e$1 = Object.defineProperty;
  var h$1 = (i2, s2, t2) => s2 in i2 ? e$1(i2, s2, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: t2
  }) : i2[s2] = t2;
  var o$1 = (i2, s2, t2) => h$1(i2, typeof s2 != "symbol" ? s2 + "" : s2, t2);
  let _$1 = class _ {
    constructor() {
      o$1(this, "_locking");
      o$1(this, "_locks");
      this._locking = Promise.resolve(), this._locks = 0;
    }
    isLocked() {
      return this._locks > 0;
    }
    lock() {
      this._locks += 1;
      let s2;
      const t2 = new Promise((l2) => s2 = () => {
        this._locks -= 1, l2();
      }), c2 = this._locking.then(() => s2);
      return this._locking = this._locking.then(() => t2), c2;
    }
  };
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
  function getEnumType(enumObject) {
    const t2 = enumObject[enumTypeSymbol];
    assert(t2, "missing enum type on enum object");
    return t2;
  }
  function setEnumType(enumObject, typeName, values, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v2) => ({
      no: v2.no,
      name: v2.name,
      localName: enumObject[v2.no]
    })));
  }
  function makeEnumType(typeName, values, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values) {
      const n2 = normalizeEnumValue(value);
      normalValues.push(n2);
      names[value.name] = n2;
      numbers[value.no] = n2;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers[no];
      }
    };
  }
  function makeEnum(typeName, values, opt) {
    const enumObject = {};
    for (const value of values) {
      const n2 = normalizeEnumValue(value);
      enumObject[n2.localName] = n2.no;
      enumObject[n2.no] = n2.localName;
    }
    setEnumType(enumObject, typeName, values);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), {
      localName: value.name
    });
  }
  let Message$2 = class Message {
    /**
     * Compare with a message of the same type.
     * Note that this function disregards extensions and unknown fields.
     */
    equals(other) {
      return this.getType().runtime.util.equals(this.getType(), this, other);
    }
    /**
     * Create a deep copy.
     */
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes, options) {
      const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
      format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue, options) {
      const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
      format.readMessage(type, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString, options) {
      let json;
      try {
        json = JSON.parse(jsonString);
      } catch (e2) {
        throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(e2 instanceof Error ? e2.message : String(e2)));
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
    toBinary(options) {
      const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer2 = opt.writerFactory();
      bin.writeMessage(this, writer2, opt);
      return writer2.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options) {
      const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options) {
      var _a;
      const value = this.toJson(options);
      return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
    toJSON() {
      return this.toJson({
        emitDefaultValues: true
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  };
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a;
    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type = {
      [localName]: function(data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      }
    }[localName];
    Object.setPrototypeOf(type.prototype, new Message$2());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a2, b2) {
        return runtime.util.equals(type, a2, b2);
      }
    });
    return type;
  }
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b2 = this.buf[this.pos++];
      lowBits |= (b2 & 127) << shift;
      if ((b2 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b2 = this.buf[this.pos++];
      highBits |= (b2 & 127) << shift;
      if ((b2 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo, hi, bytes) {
    for (let i2 = 0; i2 < 28; i2 = i2 + 7) {
      const shift = lo >>> i2;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i2 = 3; i2 < 31; i2 = i2 + 7) {
      const shift = hi >>> i2;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  const TWO_PWR_32_DBL = 4294967296;
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
  }
  function uInt64ToString(lo, hi) {
    ({
      lo,
      hi
    } = toUnsigned(lo, hi));
    if (hi <= 2097151) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 16777215;
    const mid = (lo >>> 24 | hi << 8) & 16777215;
    const high = hi >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo, hi) {
    return {
      lo: lo >>> 0,
      hi: hi >>> 0
    };
  }
  function newBits(lo, hi) {
    return {
      lo: lo | 0,
      hi: hi | 0
    };
  }
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  const decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
  };
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i2 = 0; i2 < 9; i2++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b2 = this.buf[this.pos++];
    let result = b2 & 127;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 7;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 14;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 21;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 15) << 28;
    for (let readBytes = 5; (b2 & 128) !== 0 && readBytes < 10; readBytes++)
      b2 = this.buf[this.pos++];
    if ((b2 & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof define_process_env_default != "object" || define_process_env_default.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error("int64 invalid: ".concat(value));
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error("uint64 invalid: ".concat(value));
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), "int64 invalid: ".concat(value));
    const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), "uint64 invalid: ".concat(value));
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      }
    };
  }
  const protoInt64 = makeInt64Support();
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
  })(LongType || (LongType = {}));
  function scalarEquals(type, a2, b2) {
    if (a2 === b2) {
      return true;
    }
    if (type == ScalarType.BYTES) {
      if (!(a2 instanceof Uint8Array) || !(b2 instanceof Uint8Array)) {
        return false;
      }
      if (a2.length !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    }
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a2 == b2;
    }
    return false;
  }
  function scalarZeroValue(type, longType) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return longType == 0 ? protoInt64.zero : "0";
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function isScalarZeroValue(type, value) {
    switch (type) {
      case ScalarType.BOOL:
        return value === false;
      case ScalarType.STRING:
        return value === "";
      case ScalarType.BYTES:
        return value instanceof Uint8Array && !value.byteLength;
      default:
        return value == 0;
    }
  }
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));
  class BinaryWriter {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
      this.chunks = [];
      this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i2 = 0; i2 < this.chunks.length; i2++)
        len += this.chunks[i2].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i2 = 0; i2 < this.chunks.length; i2++) {
        bytes.set(this.chunks[i2], offset);
        offset += this.chunks[i2].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
      this.stack.push({
        chunks: this.chunks,
        buf: this.buf
      });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
      assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
      assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
      assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
      assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
      assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
      let tc = protoInt64.enc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
      let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
      varint64write(lo, hi, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
      let tc = protoInt64.uEnc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
  }
  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = varint64read;
      this.uint32 = varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
      let start = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        case WireType.Bit64:
          this.pos += 4;
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (; ; ) {
            const [fn, wt2] = this.tag();
            if (wt2 === WireType.EndGroup) {
              if (fieldNo !== void 0 && fn !== fieldNo) {
                throw new Error("invalid end group tag");
              }
              break;
            }
            this.skip(wt2, fn);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
      let [lo, hi] = this.varint64();
      let s2 = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s2;
      hi = hi >>> 1 ^ s2;
      return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
      let len = this.uint32(), start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  function makeExtension(runtime, typeName, extendee, field) {
    let fi;
    return {
      typeName,
      extendee,
      get field() {
        if (!fi) {
          const i2 = typeof field == "function" ? field() : field;
          i2.name = typeName.split(".").pop();
          i2.jsonName = "[".concat(typeName, "]");
          fi = runtime.util.newFieldList([i2]).list()[0];
        }
        return fi;
      },
      runtime
    };
  }
  function createExtensionContainer(extension) {
    const localName = extension.field.localName;
    const container = /* @__PURE__ */ Object.create(null);
    container[localName] = initExtensionField(extension);
    return [container, () => container[localName]];
  }
  function initExtensionField(ext) {
    const field = ext.field;
    if (field.repeated) {
      return [];
    }
    if (field.default !== void 0) {
      return field.default;
    }
    switch (field.kind) {
      case "enum":
        return field.T.values[0].no;
      case "scalar":
        return scalarZeroValue(field.T, field.L);
      case "message":
        const T2 = field.T, value = new T2();
        return T2.fieldWrapper ? T2.fieldWrapper.unwrapField(value) : value;
      case "map":
        throw "map fields are not allowed to be extensions";
    }
  }
  function filterUnknownFields(unknownFields, field) {
    if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
      for (let i2 = unknownFields.length - 1; i2 >= 0; --i2) {
        if (unknownFields[i2].no == field.no) {
          return [unknownFields[i2]];
        }
      }
      return [];
    }
    return unknownFields.filter((uf) => uf.no === field.no);
  }
  let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  let decTable = [];
  for (let i2 = 0; i2 < encTable.length; i2++)
    decTable[encTable[i2].charCodeAt(0)] = i2;
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  const protoBase64 = {
    /**
     * Decodes a base64 string to a byte array.
     *
     * - ignores white-space, including line breaks and tabs
     * - allows inner padding (can decode concatenated base64 strings)
     * - does not require padding
     * - understands base64url encoding:
     *   "-" instead of "+",
     *   "_" instead of "/",
     *   no padding
     */
    dec(base64Str) {
      let es2 = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es2 -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es2 -= 1;
      let bytes = new Uint8Array(es2), bytePos = 0, groupPos = 0, b2, p2 = 0;
      for (let i2 = 0; i2 < base64Str.length; i2++) {
        b2 = decTable[base64Str.charCodeAt(i2)];
        if (b2 === void 0) {
          switch (base64Str[i2]) {
            case "=":
              groupPos = 0;
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            default:
              throw Error("invalid base64 string.");
          }
        }
        switch (groupPos) {
          case 0:
            p2 = b2;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p2 << 2 | (b2 & 48) >> 4;
            p2 = b2;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p2 & 15) << 4 | (b2 & 60) >> 2;
            p2 = b2;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p2 & 3) << 6 | b2;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error("invalid base64 string.");
      return bytes.subarray(0, bytePos);
    },
    /**
     * Encode a byte array to a base64 string.
     */
    enc(bytes) {
      let base64 = "", groupPos = 0, b2, p2 = 0;
      for (let i2 = 0; i2 < bytes.length; i2++) {
        b2 = bytes[i2];
        switch (groupPos) {
          case 0:
            base64 += encTable[b2 >> 2];
            p2 = (b2 & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p2 | b2 >> 4];
            p2 = (b2 & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p2 | b2 >> 6];
            base64 += encTable[b2 & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += encTable[p2];
        base64 += "=";
        if (groupPos == 1)
          base64 += "=";
      }
      return base64;
    }
  };
  function getExtension(message, extension, options) {
    assertExtendee(extension, message);
    const opt = extension.runtime.bin.makeReadOptions(options);
    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
    const [container, get2] = createExtensionContainer(extension);
    for (const uf of ufs) {
      extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
    }
    return get2();
  }
  function setExtension(message, extension, value, options) {
    assertExtendee(extension, message);
    const readOpt = extension.runtime.bin.makeReadOptions(options);
    const writeOpt = extension.runtime.bin.makeWriteOptions(options);
    if (hasExtension(message, extension)) {
      const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
      message.getType().runtime.bin.discardUnknownFields(message);
      for (const uf of ufs) {
        message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
      }
    }
    const writer2 = writeOpt.writerFactory();
    let f2 = extension.field;
    if (!f2.opt && !f2.repeated && (f2.kind == "enum" || f2.kind == "scalar")) {
      f2 = Object.assign(Object.assign({}, extension.field), {
        opt: true
      });
    }
    extension.runtime.bin.writeField(f2, value, writer2, writeOpt);
    const reader = readOpt.readerFactory(writer2.finish());
    while (reader.pos < reader.len) {
      const [no, wireType] = reader.tag();
      const data = reader.skip(wireType, no);
      message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
    }
  }
  function hasExtension(message, extension) {
    const messageType = message.getType();
    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
  }
  function assertExtendee(extension, message) {
    assert(extension.extendee.typeName == message.getType().typeName, "extension ".concat(extension.typeName, " can only be applied to message ").concat(extension.extendee.typeName));
  }
  function isFieldSet(field, target) {
    const localName = field.localName;
    if (field.repeated) {
      return target[localName].length > 0;
    }
    if (field.oneof) {
      return target[field.oneof.localName].case === localName;
    }
    switch (field.kind) {
      case "enum":
      case "scalar":
        if (field.opt || field.req) {
          return target[localName] !== void 0;
        }
        if (field.kind == "enum") {
          return target[localName] !== field.T.values[0].no;
        }
        return !isScalarZeroValue(field.T, target[localName]);
      case "message":
        return target[localName] !== void 0;
      case "map":
        return Object.keys(target[localName]).length > 0;
    }
  }
  function clearField(field, target) {
    const localName = field.localName;
    const implicitPresence = !field.opt && !field.req;
    if (field.repeated) {
      target[localName] = [];
    } else if (field.oneof) {
      target[field.oneof.localName] = {
        case: void 0
      };
    } else {
      switch (field.kind) {
        case "map":
          target[localName] = {};
          break;
        case "enum":
          target[localName] = implicitPresence ? field.T.values[0].no : void 0;
          break;
        case "scalar":
          target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
          break;
        case "message":
          target[localName] = void 0;
          break;
      }
    }
  }
  function isMessage(arg, type) {
    if (arg === null || typeof arg != "object") {
      return false;
    }
    if (!Object.getOwnPropertyNames(Message$2.prototype).every((m2) => m2 in arg && typeof arg[m2] == "function")) {
      return false;
    }
    const actualType = arg.getType();
    if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
      return false;
    }
    return type === void 0 ? true : actualType.typeName == type.typeName;
  }
  function wrapField(type, value) {
    if (isMessage(value) || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  ({
    "google.protobuf.DoubleValue": ScalarType.DOUBLE,
    "google.protobuf.FloatValue": ScalarType.FLOAT,
    "google.protobuf.Int64Value": ScalarType.INT64,
    "google.protobuf.UInt64Value": ScalarType.UINT64,
    "google.protobuf.Int32Value": ScalarType.INT32,
    "google.protobuf.UInt32Value": ScalarType.UINT32,
    "google.protobuf.BoolValue": ScalarType.BOOL,
    "google.protobuf.StringValue": ScalarType.STRING,
    "google.protobuf.BytesValue": ScalarType.BYTES
  });
  const jsonReadDefaults = {
    ignoreUnknownFields: false
  };
  const jsonWriteDefaults = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  function makeReadOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  const tokenNull = Symbol();
  const tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions: makeReadOptions$1,
      makeWriteOptions: makeWriteOptions$1,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error("cannot decode message ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = /* @__PURE__ */ new Map();
        const registry = options.typeRegistry;
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (field) {
            if (field.oneof) {
              if (jsonValue === null && field.kind == "scalar") {
                continue;
              }
              const seen = oneofSeen.get(field.oneof);
              if (seen !== void 0) {
                throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: multiple keys for oneof "').concat(field.oneof.name, '" present: "').concat(seen, '", "').concat(jsonKey, '"'));
              }
              oneofSeen.set(field.oneof, jsonKey);
            }
            readField$1(message, jsonValue, field, options, type);
          } else {
            let found = false;
            if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
              const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
              if (ext && ext.extendee.typeName == type.typeName) {
                found = true;
                const [container, get2] = createExtensionContainer(ext);
                readField$1(container, jsonValue, ext.field, options, ext);
                setExtension(message, ext, get2(), options);
              }
            }
            if (!found && !options.ignoreUnknownFields) {
              throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: key "').concat(jsonKey, '" is unknown'));
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (field of type.fields.byNumber()) {
            if (!isFieldSet(field, message)) {
              if (field.req) {
                throw "required field not set";
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
            const jsonValue = writeField$1(field, value, options);
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
          const registry = options.typeRegistry;
          if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
            for (const uf of type.runtime.bin.listUnknownFields(message)) {
              const ext = registry.findExtensionFor(type.typeName, uf.no);
              if (ext && hasExtension(message, ext)) {
                const value = getExtension(message, ext, options);
                const jsonValue = writeField$1(ext.field, value, options);
                if (jsonValue !== void 0) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          }
        } catch (e2) {
          const m2 = field ? "cannot encode field ".concat(type.typeName, ".").concat(field.name, " to JSON") : "cannot encode message ".concat(type.typeName, " to JSON");
          const r2 = e2 instanceof Error ? e2.message : String(e2);
          throw new Error(m2 + (r2.length > 0 ? ": ".concat(r2) : ""));
        }
        return json;
      },
      readScalar(type, json, longType) {
        return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
      },
      writeScalar(type, value, emitDefaultValues) {
        if (value === void 0) {
          return void 0;
        }
        if (emitDefaultValues || isScalarZeroValue(type, value)) {
          return writeScalar$1(type, value);
        }
        return void 0;
      },
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : '"'.concat(json.split('"').join('\\"'), '"');
      default:
        return String(json);
    }
  }
  function readField$1(target, jsonValue, field, options, parentType) {
    let localName = field.localName;
    if (field.repeated) {
      assert(field.kind != "map");
      if (jsonValue === null) {
        return;
      }
      if (!Array.isArray(jsonValue)) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
      }
      const targetArray = target[localName];
      for (const jsonItem of jsonValue) {
        if (jsonItem === null) {
          throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem)));
        }
        switch (field.kind) {
          case "message":
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case "enum":
            const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case "scalar":
            try {
              targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));
            } catch (e2) {
              let m2 = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem));
              if (e2 instanceof Error && e2.message.length > 0) {
                m2 += ": ".concat(e2.message);
              }
              throw new Error(m2);
            }
            break;
        }
      }
    } else if (field.kind == "map") {
      if (jsonValue === null) {
        return;
      }
      if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
      }
      const targetMap = target[localName];
      for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
        if (jsonMapValue === null) {
          throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: map value null"));
        }
        let key;
        try {
          key = readMapKey(field.K, jsonMapKey);
        } catch (e2) {
          let m2 = "cannot decode map key for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
          if (e2 instanceof Error && e2.message.length > 0) {
            m2 += ": ".concat(e2.message);
          }
          throw new Error(m2);
        }
        switch (field.V.kind) {
          case "message":
            targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
            break;
          case "enum":
            const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetMap[key] = enumValue;
            }
            break;
          case "scalar":
            try {
              targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);
            } catch (e2) {
              let m2 = "cannot decode map value for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
              if (e2 instanceof Error && e2.message.length > 0) {
                m2 += ": ".concat(e2.message);
              }
              throw new Error(m2);
            }
            break;
        }
      }
    } else {
      if (field.oneof) {
        target = target[field.oneof.localName] = {
          case: localName
        };
        localName = "value";
      }
      switch (field.kind) {
        case "message":
          const messageType = field.T;
          if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
            return;
          }
          let currentValue = target[localName];
          if (isMessage(currentValue)) {
            currentValue.fromJson(jsonValue, options);
          } else {
            target[localName] = currentValue = messageType.fromJson(jsonValue, options);
            if (messageType.fieldWrapper && !field.oneof) {
              target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
            }
          }
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
          switch (enumValue) {
            case tokenNull:
              clearField(field, target);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              target[localName] = enumValue;
              break;
          }
          break;
        case "scalar":
          try {
            const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);
            switch (scalarValue) {
              case tokenNull:
                clearField(field, target);
                break;
              default:
                target[localName] = scalarValue;
                break;
            }
          } catch (e2) {
            let m2 = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
            if (e2 instanceof Error && e2.message.length > 0) {
              m2 += ": ".concat(e2.message);
            }
            throw new Error(m2);
          }
          break;
      }
    }
  }
  function readMapKey(type, json) {
    if (type === ScalarType.BOOL) {
      switch (json) {
        case "true":
          json = true;
          break;
        case "false":
          json = false;
          break;
      }
    }
    return readScalar$1(type, json, LongType.BIGINT, true).toString();
  }
  function readScalar$1(type, json, longType, nullAsZeroValue) {
    if (json === null) {
      if (nullAsZeroValue) {
        return scalarZeroValue(type, longType);
      }
      return tokenNull;
    }
    switch (type) {
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === "NaN")
          return Number.NaN;
        if (json === "Infinity")
          return Number.POSITIVE_INFINITY;
        if (json === "-Infinity")
          return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type == ScalarType.FLOAT)
          assertFloat32(float);
        return float;
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let int32;
        if (typeof json == "number")
          int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length)
            int32 = Number(json);
        }
        if (int32 === void 0)
          break;
        if (type == ScalarType.UINT32 || type == ScalarType.FIXED32)
          assertUInt32(int32);
        else
          assertInt32(int32);
        return int32;
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const long = protoInt64.parse(json);
        return longType ? long.toString() : long;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const uLong = protoInt64.uParse(json);
        return longType ? uLong.toString() : uLong;
      case ScalarType.BOOL:
        if (typeof json !== "boolean")
          break;
        return json;
      case ScalarType.STRING:
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e2) {
          throw new Error("invalid UTF8");
        }
        return json;
      case ScalarType.BYTES:
        if (json === "")
          return new Uint8Array(0);
        if (typeof json !== "string")
          break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
      if (type.typeName == "google.protobuf.NullValue") {
        return 0;
      }
      return nullAsZeroValue ? type.values[0].no : tokenNull;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type.findName(json);
        if (value !== void 0) {
          return value.no;
        }
        if (ignoreUnknownFields) {
          return tokenIgnoredUnknownEnum;
        }
        break;
    }
    throw new Error("cannot decode enum ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
  }
  function canEmitFieldDefaultValue(field) {
    if (field.repeated || field.kind == "map") {
      return true;
    }
    if (field.oneof) {
      return false;
    }
    if (field.kind == "message") {
      return false;
    }
    if (field.opt || field.req) {
      return false;
    }
    return true;
  }
  function writeField$1(field, value, options) {
    if (field.kind == "map") {
      assert(typeof value == "object" && value != null);
      const jsonObj = {};
      const entries = Object.entries(value);
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue);
          }
          break;
        case "message":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = entryValue.toJson(options);
          }
          break;
        case "enum":
          const enumType = field.V.T;
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
          }
          break;
      }
      return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
    }
    if (field.repeated) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(writeScalar$1(field.T, value[i2]));
          }
          break;
        case "enum":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(writeEnum(field.T, value[i2], options.enumAsInteger));
          }
          break;
        case "message":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(value[i2].toJson(options));
          }
          break;
      }
      return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
    }
    switch (field.kind) {
      case "scalar":
        return writeScalar$1(field.T, value);
      case "enum":
        return writeEnum(field.T, value, options.enumAsInteger);
      case "message":
        return wrapField(field.T, value).toJson(options);
    }
  }
  function writeEnum(type, value, enumAsInteger) {
    var _a;
    assert(typeof value == "number");
    if (type.typeName == "google.protobuf.NullValue") {
      return null;
    }
    if (enumAsInteger) {
      return value;
    }
    const val = type.findNumber(value);
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
  }
  function writeScalar$1(type, value) {
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert(typeof value == "number");
        return value;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      case ScalarType.STRING:
        assert(typeof value == "string");
        return value;
      case ScalarType.BOOL:
        assert(typeof value == "boolean");
        return value;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return value.toString();
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        return protoBase64.enc(value);
    }
  }
  const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
  const readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  const writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter()
  };
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(message) {
        var _a;
        return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer2) {
        const m2 = message;
        const c2 = m2[unknownFieldsSymbol];
        if (c2) {
          for (const f2 of c2) {
            writer2.tag(f2.no, f2.wireType).raw(f2.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data) {
        const m2 = message;
        if (!Array.isArray(m2[unknownFieldsSymbol])) {
          m2[unknownFieldsSymbol] = [];
        }
        m2[unknownFieldsSymbol].push({
          no,
          wireType,
          data
        });
      },
      readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
        const type = message.getType();
        const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
        let fieldNo, wireType;
        while (reader.pos < end) {
          [fieldNo, wireType] = reader.tag();
          if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
            break;
          }
          const field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType, fieldNo);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          readField(message, reader, field, wireType, options);
        }
        if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
        (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
          throw new Error("invalid end group tag");
        }
      },
      readField,
      writeMessage(message, writer2, options) {
        const type = message.getType();
        for (const field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error("cannot encode field ".concat(type.typeName, ".").concat(field.name, " to binary: required field not set"));
            }
            continue;
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          writeField(field, value, writer2, options);
        }
        if (options.writeUnknownFields) {
          this.writeUnknownFields(message, writer2);
        }
        return writer2;
      },
      writeField(field, value, writer2, options) {
        if (value === void 0) {
          return void 0;
        }
        writeField(field, value, writer2, options);
      }
    };
  }
  function readField(target, reader, field, wireType, options) {
    let {
      repeated,
      localName
    } = field;
    if (field.oneof) {
      target = target[field.oneof.localName];
      if (target.case != localName) {
        delete target.value;
      }
      target.case = localName;
      localName = "value";
    }
    switch (field.kind) {
      case "scalar":
      case "enum":
        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        let read = readScalar;
        if (field.kind == "scalar" && field.L > 0) {
          read = readScalarLTString;
        }
        if (repeated) {
          let arr = target[localName];
          const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
          if (isPacked) {
            let e2 = reader.uint32() + reader.pos;
            while (reader.pos < e2) {
              arr.push(read(reader, scalarType));
            }
          } else {
            arr.push(read(reader, scalarType));
          }
        } else {
          target[localName] = read(reader, scalarType);
        }
        break;
      case "message":
        const messageType = field.T;
        if (repeated) {
          target[localName].push(readMessageField(reader, new messageType(), options, field));
        } else {
          if (isMessage(target[localName])) {
            readMessageField(reader, target[localName], options, field);
          } else {
            target[localName] = readMessageField(reader, new messageType(), options, field);
            if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
              target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
            }
          }
        }
        break;
      case "map":
        let [mapKey, mapVal] = readMapEntry(field, reader, options);
        target[localName][mapKey] = mapVal;
        break;
    }
  }
  function readMessageField(reader, message, options, field) {
    const format = message.getType().runtime.bin;
    const delimited = field === null || field === void 0 ? void 0 : field.delimited;
    format.readMessage(
      message,
      reader,
      delimited ? field.no : reader.uint32(),
      // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      options,
      delimited
    );
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      const [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options, void 0);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      key = scalarZeroValue(field.K, LongType.BIGINT);
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarZeroValue(field.V.T, LongType.BIGINT);
          break;
        case "enum":
          val = field.V.T.values[0].no;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalarLTString(reader, type) {
    const v2 = readScalar(reader, type);
    return typeof v2 == "bigint" ? v2.toString() : v2;
  }
  function readScalar(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeField(field, value, writer2, options) {
    assert(value !== void 0);
    const repeated = field.repeated;
    switch (field.kind) {
      case "scalar":
      case "enum":
        let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (repeated) {
          assert(Array.isArray(value));
          if (field.packed) {
            writePacked(writer2, scalarType, field.no, value);
          } else {
            for (const item of value) {
              writeScalar(writer2, scalarType, field.no, item);
            }
          }
        } else {
          writeScalar(writer2, scalarType, field.no, value);
        }
        break;
      case "message":
        if (repeated) {
          assert(Array.isArray(value));
          for (const item of value) {
            writeMessageField(writer2, options, field, item);
          }
        } else {
          writeMessageField(writer2, options, field, value);
        }
        break;
      case "map":
        assert(typeof value == "object" && value != null);
        for (const [key, val] of Object.entries(value)) {
          writeMapEntry(writer2, options, field, key, val);
        }
        break;
    }
  }
  function writeMapEntry(writer2, options, field, key, value) {
    writer2.tag(field.no, WireType.LengthDelimited);
    writer2.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar(writer2, field.K, 1, keyValue);
    switch (field.V.kind) {
      case "scalar":
        writeScalar(writer2, field.V.T, 2, value);
        break;
      case "enum":
        writeScalar(writer2, ScalarType.INT32, 2, value);
        break;
      case "message":
        assert(value !== void 0);
        writer2.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
        break;
    }
    writer2.join();
  }
  function writeMessageField(writer2, options, field, value) {
    const message = wrapField(field.T, value);
    if (field.delimited)
      writer2.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
    else
      writer2.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
  }
  function writeScalar(writer2, type, fieldNo, value) {
    assert(value !== void 0);
    let [wireType, method] = scalarTypeInfo(type);
    writer2.tag(fieldNo, wireType)[method](value);
  }
  function writePacked(writer2, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer2.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i2 = 0; i2 < value.length; i2++) {
      writer2[method](value[i2]);
    }
    writer2.join();
  }
  function scalarTypeInfo(type) {
    let wireType = WireType.Varint;
    switch (type) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method];
  }
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === void 0) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName = member.localName, t2 = target, s2 = source;
          if (s2[localName] == null) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk = s2[localName].case;
              if (sk === void 0) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s2[localName].value;
              if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t2[localName] = {
                case: sk,
                value: val
              };
              break;
            case "scalar":
            case "enum":
              let copy = s2[localName];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t2[localName] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k, v2] of Object.entries(s2[localName])) {
                      t2[localName][k] = toU8Arr(v2);
                    }
                  } else {
                    Object.assign(t2[localName], s2[localName]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k of Object.keys(s2[localName])) {
                    let val2 = s2[localName][k];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t2[localName][k] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt2 = member.T;
              if (member.repeated) {
                t2[localName] = s2[localName].map((val2) => isMessage(val2, mt2) ? val2 : new mt2(val2));
              } else {
                const val2 = s2[localName];
                if (mt2.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt2.typeName === "google.protobuf.BytesValue"
                  ) {
                    t2[localName] = toU8Arr(val2);
                  } else {
                    t2[localName] = val2;
                  }
                } else {
                  t2[localName] = isMessage(val2, mt2) ? val2 : new mt2(val2);
                }
              }
              break;
          }
        }
      },
      // TODO use isFieldSet() here to support future field presence
      equals(type, a2, b2) {
        if (a2 === b2) {
          return true;
        }
        if (!a2 || !b2) {
          return false;
        }
        return type.fields.byMember().every((m2) => {
          const va = a2[m2.localName];
          const vb = b2[m2.localName];
          if (m2.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            switch (m2.kind) {
              case "message":
                return va.every((a22, i2) => m2.T.equals(a22, vb[i2]));
              case "scalar":
                return va.every((a22, i2) => scalarEquals(m2.T, a22, vb[i2]));
              case "enum":
                return va.every((a22, i2) => scalarEquals(ScalarType.INT32, a22, vb[i2]));
            }
            throw new Error("repeated cannot contain ".concat(m2.kind));
          }
          switch (m2.kind) {
            case "message":
              return m2.T.equals(va, vb);
            case "enum":
              return scalarEquals(ScalarType.INT32, va, vb);
            case "scalar":
              return scalarEquals(m2.T, va, vb);
            case "oneof":
              if (va.case !== vb.case) {
                return false;
              }
              const s2 = m2.findField(va.case);
              if (s2 === void 0) {
                return true;
              }
              switch (s2.kind) {
                case "message":
                  return s2.T.equals(va.value, vb.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case "scalar":
                  return scalarEquals(s2.T, va.value, vb.value);
              }
              throw new Error("oneof cannot contain ".concat(s2.kind));
            case "map":
              const keys = Object.keys(va).concat(Object.keys(vb));
              switch (m2.V.kind) {
                case "message":
                  const messageType = m2.V.T;
                  return keys.every((k) => messageType.equals(va[k], vb[k]));
                case "enum":
                  return keys.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
                case "scalar":
                  const scalarType = m2.V.T;
                  return keys.every((k) => scalarEquals(scalarType, va[k], vb[k]));
              }
              break;
          }
        });
      },
      // TODO use isFieldSet() here to support future field presence
      clone(message) {
        const type = message.getType(), target = new type(), any = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any[member.localName];
            for (const [key, v2] of Object.entries(source)) {
              copy[key] = cloneSingularField(v2);
            }
          } else if (member.kind == "oneof") {
            const f2 = member.findField(source.case);
            copy = f2 ? {
              case: source.case,
              value: cloneSingularField(source.value)
            } : {
              case: void 0
            };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
        for (const uf of type.runtime.bin.listUnknownFields(message)) {
          type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (isMessage(value)) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c2 = new Uint8Array(value.byteLength);
      c2.set(value);
      return c2;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }
  function makeProtoRuntime(syntax, newFieldList, initFields) {
    return {
      syntax,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList,
        initFields
      }),
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(typeName, extendee, field) {
        return makeExtension(this, typeName, extendee, field);
      }
    };
  }
  class InternalFieldList {
    constructor(fields, normalizer) {
      this._fields = fields;
      this._normalizer = normalizer;
    }
    findJsonName(jsonName) {
      if (!this.jsonNames) {
        const t2 = {};
        for (const f2 of this.list()) {
          t2[f2.jsonName] = t2[f2.name] = f2;
        }
        this.jsonNames = t2;
      }
      return this.jsonNames[jsonName];
    }
    find(fieldNo) {
      if (!this.numbers) {
        const t2 = {};
        for (const f2 of this.list()) {
          t2[f2.no] = f2;
        }
        this.numbers = t2;
      }
      return this.numbers[fieldNo];
    }
    list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
    byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list().concat().sort((a2, b2) => a2.no - b2.no);
      }
      return this.numbersAsc;
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const a2 = this.members;
        let o2;
        for (const f2 of this.list()) {
          if (f2.oneof) {
            if (f2.oneof !== o2) {
              o2 = f2.oneof;
              a2.push(o2);
            }
          } else {
            a2.push(f2);
          }
        }
      }
      return this.members;
    }
  }
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  const fieldJsonName = protoCamelCase;
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b2 = [];
    for (let i2 = 0; i2 < snakeCase.length; i2++) {
      let c2 = snakeCase.charAt(i2);
      switch (c2) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b2.push(c2);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c2 = c2.toUpperCase();
          }
          b2.push(c2);
          break;
      }
    }
    return b2.join("");
  }
  const reservedObjectProperties = /* @__PURE__ */ new Set([
    // names reserved by JavaScript
    "constructor",
    "toString",
    "toJSON",
    "valueOf"
  ]);
  const reservedMessageProperties = /* @__PURE__ */ new Set([
    // names reserved by the runtime
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    // names reserved by the runtime for the future
    "toObject"
  ]);
  const fallback = (name) => "".concat(name, "$");
  const safeMessageProperty = (name) => {
    if (reservedMessageProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  const safeObjectProperty = (name) => {
    if (reservedObjectProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  class InternalOneofInfo {
    constructor(name) {
      this.kind = "oneof";
      this.repeated = false;
      this.packed = false;
      this.opt = false;
      this.req = false;
      this.default = void 0;
      this.fields = [];
      this.name = name;
      this.localName = localOneofName(name);
    }
    addField(field) {
      assert(field.oneof === this, "field ".concat(field.name, " not one of ").concat(this.name));
      this.fields.push(field);
    }
    findField(localName) {
      if (!this._lookup) {
        this._lookup = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < this.fields.length; i2++) {
          this._lookup[this.fields[i2].localName] = this.fields[i2];
        }
      }
      return this._lookup[localName];
    }
  }
  function normalizeFieldInfos(fieldInfos, packedByDefault) {
    var _a, _b, _c, _d, _e2, _f;
    const r2 = [];
    let o2;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f2 = field;
      f2.localName = localFieldName(field.name, field.oneof !== void 0);
      f2.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f2.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      if (field.kind == "scalar") {
        f2.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
      }
      f2.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
      f2.req = (_e2 = field.req) !== null && _e2 !== void 0 ? _e2 : false;
      f2.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
      if (field.packed === void 0) {
        {
          f2.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
        }
      }
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o2 || o2.name != ooname) {
          o2 = new InternalOneofInfo(ooname);
        }
        f2.oneof = o2;
        o2.addField(f2);
      }
      r2.push(f2);
    }
    return r2;
  }
  const proto3 = makeProtoRuntime(
    "proto3",
    (fields) => {
      return new InternalFieldList(fields, (source) => normalizeFieldInfos(source));
    },
    // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        if (member.opt) {
          continue;
        }
        const name = member.localName, t2 = target;
        if (member.repeated) {
          t2[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t2[name] = {
              case: void 0
            };
            break;
          case "enum":
            t2[name] = 0;
            break;
          case "map":
            t2[name] = {};
            break;
          case "scalar":
            t2[name] = scalarZeroValue(member.T, member.L);
            break;
        }
      }
    }
  );
  class Timestamp extends Message$2 {
    constructor(data) {
      super();
      this.seconds = protoInt64.zero;
      this.nanos = 0;
      proto3.util.initPartial(data, this);
    }
    fromJson(json, options) {
      if (typeof json !== "string") {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(json)));
      }
      const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches) {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
      }
      const ms2 = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
      if (Number.isNaN(ms2)) {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
      }
      if (ms2 < Date.parse("0001-01-01T00:00:00Z") || ms2 > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
      }
      this.seconds = protoInt64.parse(ms2 / 1e3);
      this.nanos = 0;
      if (matches[7]) {
        this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
      }
      return this;
    }
    toJson(options) {
      const ms2 = Number(this.seconds) * 1e3;
      if (ms2 < Date.parse("0001-01-01T00:00:00Z") || ms2 > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
      }
      if (this.nanos < 0) {
        throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
      }
      let z2 = "Z";
      if (this.nanos > 0) {
        const nanosStr = (this.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000") {
          z2 = "." + nanosStr.substring(0, 3) + "Z";
        } else if (nanosStr.substring(6) === "000") {
          z2 = "." + nanosStr.substring(0, 6) + "Z";
        } else {
          z2 = "." + nanosStr + "Z";
        }
      }
      return new Date(ms2).toISOString().replace(".000Z", z2);
    }
    toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
    }
    static now() {
      return Timestamp.fromDate(/* @__PURE__ */ new Date());
    }
    static fromDate(date) {
      const ms2 = date.getTime();
      return new Timestamp({
        seconds: protoInt64.parse(Math.floor(ms2 / 1e3)),
        nanos: ms2 % 1e3 * 1e6
      });
    }
    static fromBinary(bytes, options) {
      return new Timestamp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Timestamp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Timestamp().fromJsonString(jsonString, options);
    }
    static equals(a2, b2) {
      return proto3.util.equals(Timestamp, a2, b2);
    }
  }
  Timestamp.runtime = proto3;
  Timestamp.typeName = "google.protobuf.Timestamp";
  Timestamp.fields = proto3.util.newFieldList(() => [{
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  const MetricsBatch = /* @__PURE__ */ proto3.makeMessageType("livekit.MetricsBatch", () => [{
    no: 1,
    name: "timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "normalized_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "str_data",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "time_series",
    kind: "message",
    T: TimeSeriesMetric,
    repeated: true
  }, {
    no: 5,
    name: "events",
    kind: "message",
    T: EventMetric,
    repeated: true
  }]);
  const TimeSeriesMetric = /* @__PURE__ */ proto3.makeMessageType("livekit.TimeSeriesMetric", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "participant_identity",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "track_sid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "samples",
    kind: "message",
    T: MetricSample,
    repeated: true
  }, {
    no: 5,
    name: "rid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const MetricSample = /* @__PURE__ */ proto3.makeMessageType("livekit.MetricSample", () => [{
    no: 1,
    name: "timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "normalized_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "value",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }]);
  const EventMetric = /* @__PURE__ */ proto3.makeMessageType("livekit.EventMetric", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "participant_identity",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "track_sid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "start_timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 5,
    name: "end_timestamp_ms",
    kind: "scalar",
    T: 3,
    opt: true
  }, {
    no: 6,
    name: "normalized_start_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 7,
    name: "normalized_end_timestamp",
    kind: "message",
    T: Timestamp,
    opt: true
  }, {
    no: 8,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "rid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const BackupCodecPolicy$1 = /* @__PURE__ */ proto3.makeEnum("livekit.BackupCodecPolicy", [{
    no: 0,
    name: "REGRESSION"
  }, {
    no: 1,
    name: "SIMULCAST"
  }]);
  const TrackType = /* @__PURE__ */ proto3.makeEnum("livekit.TrackType", [{
    no: 0,
    name: "AUDIO"
  }, {
    no: 1,
    name: "VIDEO"
  }, {
    no: 2,
    name: "DATA"
  }]);
  const TrackSource = /* @__PURE__ */ proto3.makeEnum("livekit.TrackSource", [{
    no: 0,
    name: "UNKNOWN"
  }, {
    no: 1,
    name: "CAMERA"
  }, {
    no: 2,
    name: "MICROPHONE"
  }, {
    no: 3,
    name: "SCREEN_SHARE"
  }, {
    no: 4,
    name: "SCREEN_SHARE_AUDIO"
  }]);
  const VideoQuality$1 = /* @__PURE__ */ proto3.makeEnum("livekit.VideoQuality", [{
    no: 0,
    name: "LOW"
  }, {
    no: 1,
    name: "MEDIUM"
  }, {
    no: 2,
    name: "HIGH"
  }, {
    no: 3,
    name: "OFF"
  }]);
  const ConnectionQuality$1 = /* @__PURE__ */ proto3.makeEnum("livekit.ConnectionQuality", [{
    no: 0,
    name: "POOR"
  }, {
    no: 1,
    name: "GOOD"
  }, {
    no: 2,
    name: "EXCELLENT"
  }, {
    no: 3,
    name: "LOST"
  }]);
  const ClientConfigSetting = /* @__PURE__ */ proto3.makeEnum("livekit.ClientConfigSetting", [{
    no: 0,
    name: "UNSET"
  }, {
    no: 1,
    name: "DISABLED"
  }, {
    no: 2,
    name: "ENABLED"
  }]);
  const DisconnectReason = /* @__PURE__ */ proto3.makeEnum("livekit.DisconnectReason", [{
    no: 0,
    name: "UNKNOWN_REASON"
  }, {
    no: 1,
    name: "CLIENT_INITIATED"
  }, {
    no: 2,
    name: "DUPLICATE_IDENTITY"
  }, {
    no: 3,
    name: "SERVER_SHUTDOWN"
  }, {
    no: 4,
    name: "PARTICIPANT_REMOVED"
  }, {
    no: 5,
    name: "ROOM_DELETED"
  }, {
    no: 6,
    name: "STATE_MISMATCH"
  }, {
    no: 7,
    name: "JOIN_FAILURE"
  }, {
    no: 8,
    name: "MIGRATION"
  }, {
    no: 9,
    name: "SIGNAL_CLOSE"
  }, {
    no: 10,
    name: "ROOM_CLOSED"
  }, {
    no: 11,
    name: "USER_UNAVAILABLE"
  }, {
    no: 12,
    name: "USER_REJECTED"
  }, {
    no: 13,
    name: "SIP_TRUNK_FAILURE"
  }]);
  const ReconnectReason = /* @__PURE__ */ proto3.makeEnum("livekit.ReconnectReason", [{
    no: 0,
    name: "RR_UNKNOWN"
  }, {
    no: 1,
    name: "RR_SIGNAL_DISCONNECTED"
  }, {
    no: 2,
    name: "RR_PUBLISHER_FAILED"
  }, {
    no: 3,
    name: "RR_SUBSCRIBER_FAILED"
  }, {
    no: 4,
    name: "RR_SWITCH_CANDIDATE"
  }]);
  const SubscriptionError = /* @__PURE__ */ proto3.makeEnum("livekit.SubscriptionError", [{
    no: 0,
    name: "SE_UNKNOWN"
  }, {
    no: 1,
    name: "SE_CODEC_UNSUPPORTED"
  }, {
    no: 2,
    name: "SE_TRACK_NOTFOUND"
  }]);
  const AudioTrackFeature = /* @__PURE__ */ proto3.makeEnum("livekit.AudioTrackFeature", [{
    no: 0,
    name: "TF_STEREO"
  }, {
    no: 1,
    name: "TF_NO_DTX"
  }, {
    no: 2,
    name: "TF_AUTO_GAIN_CONTROL"
  }, {
    no: 3,
    name: "TF_ECHO_CANCELLATION"
  }, {
    no: 4,
    name: "TF_NOISE_SUPPRESSION"
  }, {
    no: 5,
    name: "TF_ENHANCED_NOISE_CANCELLATION"
  }]);
  const Room$1 = /* @__PURE__ */ proto3.makeMessageType("livekit.Room", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "empty_timeout",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 14,
    name: "departure_timeout",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "max_participants",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "creation_time",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 15,
    name: "creation_time_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 6,
    name: "turn_password",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "enabled_codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 8,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "num_participants",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 11,
    name: "num_publishers",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 10,
    name: "active_recording",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 13,
    name: "version",
    kind: "message",
    T: TimedVersion
  }]);
  const Codec = /* @__PURE__ */ proto3.makeMessageType("livekit.Codec", () => [{
    no: 1,
    name: "mime",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "fmtp_line",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ParticipantPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantPermission", () => [{
    no: 1,
    name: "can_subscribe",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "can_publish",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "can_publish_data",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 9,
    name: "can_publish_sources",
    kind: "enum",
    T: proto3.getEnumType(TrackSource),
    repeated: true
  }, {
    no: 7,
    name: "hidden",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "recorder",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 10,
    name: "can_update_metadata",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 11,
    name: "agent",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 12,
    name: "can_subscribe_metrics",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const ParticipantInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "state",
    kind: "enum",
    T: proto3.getEnumType(ParticipantInfo_State)
  }, {
    no: 4,
    name: "tracks",
    kind: "message",
    T: TrackInfo,
    repeated: true
  }, {
    no: 5,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "joined_at",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 17,
    name: "joined_at_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 9,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "version",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 11,
    name: "permission",
    kind: "message",
    T: ParticipantPermission
  }, {
    no: 12,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 13,
    name: "is_publisher",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 14,
    name: "kind",
    kind: "enum",
    T: proto3.getEnumType(ParticipantInfo_Kind)
  }, {
    no: 15,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 16,
    name: "disconnect_reason",
    kind: "enum",
    T: proto3.getEnumType(DisconnectReason)
  }]);
  const ParticipantInfo_State = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.State", [{
    no: 0,
    name: "JOINING"
  }, {
    no: 1,
    name: "JOINED"
  }, {
    no: 2,
    name: "ACTIVE"
  }, {
    no: 3,
    name: "DISCONNECTED"
  }]);
  const ParticipantInfo_Kind = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.Kind", [{
    no: 0,
    name: "STANDARD"
  }, {
    no: 1,
    name: "INGRESS"
  }, {
    no: 2,
    name: "EGRESS"
  }, {
    no: 3,
    name: "SIP"
  }, {
    no: 4,
    name: "AGENT"
  }]);
  const Encryption_Type = /* @__PURE__ */ proto3.makeEnum("livekit.Encryption.Type", [{
    no: 0,
    name: "NONE"
  }, {
    no: 1,
    name: "GCM"
  }, {
    no: 2,
    name: "CUSTOM"
  }]);
  const SimulcastCodecInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulcastCodecInfo", () => [{
    no: 1,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "mid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }]);
  const TrackInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "type",
    kind: "enum",
    T: proto3.getEnumType(TrackType)
  }, {
    no: 3,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 5,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "simulcast",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "disable_dtx",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 9,
    name: "source",
    kind: "enum",
    T: proto3.getEnumType(TrackSource)
  }, {
    no: 10,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }, {
    no: 11,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 12,
    name: "mid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 13,
    name: "codecs",
    kind: "message",
    T: SimulcastCodecInfo,
    repeated: true
  }, {
    no: 14,
    name: "stereo",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 15,
    name: "disable_red",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 16,
    name: "encryption",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 17,
    name: "stream",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 18,
    name: "version",
    kind: "message",
    T: TimedVersion
  }, {
    no: 19,
    name: "audio_features",
    kind: "enum",
    T: proto3.getEnumType(AudioTrackFeature),
    repeated: true
  }, {
    no: 20,
    name: "backup_codec_policy",
    kind: "enum",
    T: proto3.getEnumType(BackupCodecPolicy$1)
  }]);
  const VideoLayer = /* @__PURE__ */ proto3.makeMessageType("livekit.VideoLayer", () => [{
    no: 1,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 2,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "bitrate",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "ssrc",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const DataPacket = /* @__PURE__ */ proto3.makeMessageType("livekit.DataPacket", () => [{
    no: 1,
    name: "kind",
    kind: "enum",
    T: proto3.getEnumType(DataPacket_Kind)
  }, {
    no: 4,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "destination_identities",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "user",
    kind: "message",
    T: UserPacket,
    oneof: "value"
  }, {
    no: 3,
    name: "speaker",
    kind: "message",
    T: ActiveSpeakerUpdate,
    oneof: "value"
  }, {
    no: 6,
    name: "sip_dtmf",
    kind: "message",
    T: SipDTMF,
    oneof: "value"
  }, {
    no: 7,
    name: "transcription",
    kind: "message",
    T: Transcription,
    oneof: "value"
  }, {
    no: 8,
    name: "metrics",
    kind: "message",
    T: MetricsBatch,
    oneof: "value"
  }, {
    no: 9,
    name: "chat_message",
    kind: "message",
    T: ChatMessage,
    oneof: "value"
  }, {
    no: 10,
    name: "rpc_request",
    kind: "message",
    T: RpcRequest,
    oneof: "value"
  }, {
    no: 11,
    name: "rpc_ack",
    kind: "message",
    T: RpcAck,
    oneof: "value"
  }, {
    no: 12,
    name: "rpc_response",
    kind: "message",
    T: RpcResponse,
    oneof: "value"
  }, {
    no: 13,
    name: "stream_header",
    kind: "message",
    T: DataStream_Header,
    oneof: "value"
  }, {
    no: 14,
    name: "stream_chunk",
    kind: "message",
    T: DataStream_Chunk,
    oneof: "value"
  }, {
    no: 15,
    name: "stream_trailer",
    kind: "message",
    T: DataStream_Trailer,
    oneof: "value"
  }]);
  const DataPacket_Kind = /* @__PURE__ */ proto3.makeEnum("livekit.DataPacket.Kind", [{
    no: 0,
    name: "RELIABLE"
  }, {
    no: 1,
    name: "LOSSY"
  }]);
  const ActiveSpeakerUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ActiveSpeakerUpdate", () => [{
    no: 1,
    name: "speakers",
    kind: "message",
    T: SpeakerInfo,
    repeated: true
  }]);
  const SpeakerInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.SpeakerInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "level",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }, {
    no: 3,
    name: "active",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const UserPacket = /* @__PURE__ */ proto3.makeMessageType("livekit.UserPacket", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "payload",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 3,
    name: "destination_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 6,
    name: "destination_identities",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "topic",
    kind: "scalar",
    T: 9,
    opt: true
  }, {
    no: 8,
    name: "id",
    kind: "scalar",
    T: 9,
    opt: true
  }, {
    no: 9,
    name: "start_time",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 10,
    name: "end_time",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 11,
    name: "nonce",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }]);
  const SipDTMF = /* @__PURE__ */ proto3.makeMessageType("livekit.SipDTMF", () => [{
    no: 3,
    name: "code",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "digit",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const Transcription = /* @__PURE__ */ proto3.makeMessageType("livekit.Transcription", () => [{
    no: 2,
    name: "transcribed_participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "track_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "segments",
    kind: "message",
    T: TranscriptionSegment,
    repeated: true
  }]);
  const TranscriptionSegment = /* @__PURE__ */ proto3.makeMessageType("livekit.TranscriptionSegment", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "text",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "start_time",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 4,
    name: "end_time",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 5,
    name: "final",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "language",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ChatMessage = /* @__PURE__ */ proto3.makeMessageType("livekit.ChatMessage", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 3,
    name: "edit_timestamp",
    kind: "scalar",
    T: 3,
    opt: true
  }, {
    no: 4,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "deleted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "generated",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const RpcRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcRequest", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "method",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "payload",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "response_timeout_ms",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "version",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const RpcAck = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcAck", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const RpcResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcResponse", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "payload",
    kind: "scalar",
    T: 9,
    oneof: "value"
  }, {
    no: 3,
    name: "error",
    kind: "message",
    T: RpcError$1,
    oneof: "value"
  }]);
  const RpcError$1 = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcError", () => [{
    no: 1,
    name: "code",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "data",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ParticipantTracks = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantTracks", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }]);
  const ServerInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ServerInfo", () => [{
    no: 1,
    name: "edition",
    kind: "enum",
    T: proto3.getEnumType(ServerInfo_Edition)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 4,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "node_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "debug_info",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "agent_protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  const ServerInfo_Edition = /* @__PURE__ */ proto3.makeEnum("livekit.ServerInfo.Edition", [{
    no: 0,
    name: "Standard"
  }, {
    no: 1,
    name: "Cloud"
  }]);
  const ClientInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ClientInfo", () => [{
    no: 1,
    name: "sdk",
    kind: "enum",
    T: proto3.getEnumType(ClientInfo_SDK)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 4,
    name: "os",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "os_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "device_model",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "browser",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "browser_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "address",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "network",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 11,
    name: "other_sdks",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ClientInfo_SDK = /* @__PURE__ */ proto3.makeEnum("livekit.ClientInfo.SDK", [{
    no: 0,
    name: "UNKNOWN"
  }, {
    no: 1,
    name: "JS"
  }, {
    no: 2,
    name: "SWIFT"
  }, {
    no: 3,
    name: "ANDROID"
  }, {
    no: 4,
    name: "FLUTTER"
  }, {
    no: 5,
    name: "GO"
  }, {
    no: 6,
    name: "UNITY"
  }, {
    no: 7,
    name: "REACT_NATIVE"
  }, {
    no: 8,
    name: "RUST"
  }, {
    no: 9,
    name: "PYTHON"
  }, {
    no: 10,
    name: "CPP"
  }, {
    no: 11,
    name: "UNITY_WEB"
  }, {
    no: 12,
    name: "NODE"
  }]);
  const ClientConfiguration = /* @__PURE__ */ proto3.makeMessageType("livekit.ClientConfiguration", () => [{
    no: 1,
    name: "video",
    kind: "message",
    T: VideoConfiguration
  }, {
    no: 2,
    name: "screen",
    kind: "message",
    T: VideoConfiguration
  }, {
    no: 3,
    name: "resume_connection",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }, {
    no: 4,
    name: "disabled_codecs",
    kind: "message",
    T: DisabledCodecs
  }, {
    no: 5,
    name: "force_relay",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }]);
  const VideoConfiguration = /* @__PURE__ */ proto3.makeMessageType("livekit.VideoConfiguration", () => [{
    no: 1,
    name: "hardware_encoder",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }]);
  const DisabledCodecs = /* @__PURE__ */ proto3.makeMessageType("livekit.DisabledCodecs", () => [{
    no: 1,
    name: "codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 2,
    name: "publish",
    kind: "message",
    T: Codec,
    repeated: true
  }]);
  const TimedVersion = /* @__PURE__ */ proto3.makeMessageType("livekit.TimedVersion", () => [{
    no: 1,
    name: "unix_micro",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "ticks",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  const DataStream_OperationType = /* @__PURE__ */ proto3.makeEnum("livekit.DataStream.OperationType", [{
    no: 0,
    name: "CREATE"
  }, {
    no: 1,
    name: "UPDATE"
  }, {
    no: 2,
    name: "DELETE"
  }, {
    no: 3,
    name: "REACTION"
  }]);
  const DataStream_TextHeader = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.TextHeader", () => [{
    no: 1,
    name: "operation_type",
    kind: "enum",
    T: proto3.getEnumType(DataStream_OperationType)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 3,
    name: "reply_to_stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "attached_stream_ids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 5,
    name: "generated",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }], {
    localName: "DataStream_TextHeader"
  });
  const DataStream_ByteHeader = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.ByteHeader", () => [{
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }], {
    localName: "DataStream_ByteHeader"
  });
  const DataStream_Header = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Header", () => [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 3,
    name: "topic",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "total_length",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 7,
    name: "encryption_type",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 8,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 9,
    name: "text_header",
    kind: "message",
    T: DataStream_TextHeader,
    oneof: "content_header"
  }, {
    no: 10,
    name: "byte_header",
    kind: "message",
    T: DataStream_ByteHeader,
    oneof: "content_header"
  }], {
    localName: "DataStream_Header"
  });
  const DataStream_Chunk = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Chunk", () => [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "chunk_index",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 3,
    name: "content",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 4,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 5,
    name: "iv",
    kind: "scalar",
    T: 12,
    opt: true
  }], {
    localName: "DataStream_Chunk"
  });
  const DataStream_Trailer = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Trailer", () => [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "reason",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }], {
    localName: "DataStream_Trailer"
  });
  const SignalTarget = /* @__PURE__ */ proto3.makeEnum("livekit.SignalTarget", [{
    no: 0,
    name: "PUBLISHER"
  }, {
    no: 1,
    name: "SUBSCRIBER"
  }]);
  const StreamState = /* @__PURE__ */ proto3.makeEnum("livekit.StreamState", [{
    no: 0,
    name: "ACTIVE"
  }, {
    no: 1,
    name: "PAUSED"
  }]);
  const CandidateProtocol = /* @__PURE__ */ proto3.makeEnum("livekit.CandidateProtocol", [{
    no: 0,
    name: "UDP"
  }, {
    no: 1,
    name: "TCP"
  }, {
    no: 2,
    name: "TLS"
  }]);
  const SignalRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.SignalRequest", () => [{
    no: 1,
    name: "offer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 2,
    name: "answer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 3,
    name: "trickle",
    kind: "message",
    T: TrickleRequest,
    oneof: "message"
  }, {
    no: 4,
    name: "add_track",
    kind: "message",
    T: AddTrackRequest,
    oneof: "message"
  }, {
    no: 5,
    name: "mute",
    kind: "message",
    T: MuteTrackRequest,
    oneof: "message"
  }, {
    no: 6,
    name: "subscription",
    kind: "message",
    T: UpdateSubscription,
    oneof: "message"
  }, {
    no: 7,
    name: "track_setting",
    kind: "message",
    T: UpdateTrackSettings,
    oneof: "message"
  }, {
    no: 8,
    name: "leave",
    kind: "message",
    T: LeaveRequest,
    oneof: "message"
  }, {
    no: 10,
    name: "update_layers",
    kind: "message",
    T: UpdateVideoLayers,
    oneof: "message"
  }, {
    no: 11,
    name: "subscription_permission",
    kind: "message",
    T: SubscriptionPermission,
    oneof: "message"
  }, {
    no: 12,
    name: "sync_state",
    kind: "message",
    T: SyncState,
    oneof: "message"
  }, {
    no: 13,
    name: "simulate",
    kind: "message",
    T: SimulateScenario,
    oneof: "message"
  }, {
    no: 14,
    name: "ping",
    kind: "scalar",
    T: 3,
    oneof: "message"
  }, {
    no: 15,
    name: "update_metadata",
    kind: "message",
    T: UpdateParticipantMetadata,
    oneof: "message"
  }, {
    no: 16,
    name: "ping_req",
    kind: "message",
    T: Ping,
    oneof: "message"
  }, {
    no: 17,
    name: "update_audio_track",
    kind: "message",
    T: UpdateLocalAudioTrack,
    oneof: "message"
  }, {
    no: 18,
    name: "update_video_track",
    kind: "message",
    T: UpdateLocalVideoTrack,
    oneof: "message"
  }]);
  const SignalResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.SignalResponse", () => [{
    no: 1,
    name: "join",
    kind: "message",
    T: JoinResponse,
    oneof: "message"
  }, {
    no: 2,
    name: "answer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 3,
    name: "offer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 4,
    name: "trickle",
    kind: "message",
    T: TrickleRequest,
    oneof: "message"
  }, {
    no: 5,
    name: "update",
    kind: "message",
    T: ParticipantUpdate,
    oneof: "message"
  }, {
    no: 6,
    name: "track_published",
    kind: "message",
    T: TrackPublishedResponse,
    oneof: "message"
  }, {
    no: 8,
    name: "leave",
    kind: "message",
    T: LeaveRequest,
    oneof: "message"
  }, {
    no: 9,
    name: "mute",
    kind: "message",
    T: MuteTrackRequest,
    oneof: "message"
  }, {
    no: 10,
    name: "speakers_changed",
    kind: "message",
    T: SpeakersChanged,
    oneof: "message"
  }, {
    no: 11,
    name: "room_update",
    kind: "message",
    T: RoomUpdate,
    oneof: "message"
  }, {
    no: 12,
    name: "connection_quality",
    kind: "message",
    T: ConnectionQualityUpdate,
    oneof: "message"
  }, {
    no: 13,
    name: "stream_state_update",
    kind: "message",
    T: StreamStateUpdate,
    oneof: "message"
  }, {
    no: 14,
    name: "subscribed_quality_update",
    kind: "message",
    T: SubscribedQualityUpdate,
    oneof: "message"
  }, {
    no: 15,
    name: "subscription_permission_update",
    kind: "message",
    T: SubscriptionPermissionUpdate,
    oneof: "message"
  }, {
    no: 16,
    name: "refresh_token",
    kind: "scalar",
    T: 9,
    oneof: "message"
  }, {
    no: 17,
    name: "track_unpublished",
    kind: "message",
    T: TrackUnpublishedResponse,
    oneof: "message"
  }, {
    no: 18,
    name: "pong",
    kind: "scalar",
    T: 3,
    oneof: "message"
  }, {
    no: 19,
    name: "reconnect",
    kind: "message",
    T: ReconnectResponse,
    oneof: "message"
  }, {
    no: 20,
    name: "pong_resp",
    kind: "message",
    T: Pong,
    oneof: "message"
  }, {
    no: 21,
    name: "subscription_response",
    kind: "message",
    T: SubscriptionResponse,
    oneof: "message"
  }, {
    no: 22,
    name: "request_response",
    kind: "message",
    T: RequestResponse,
    oneof: "message"
  }, {
    no: 23,
    name: "track_subscribed",
    kind: "message",
    T: TrackSubscribed,
    oneof: "message"
  }]);
  const SimulcastCodec = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulcastCodec", () => [{
    no: 1,
    name: "codec",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const AddTrackRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.AddTrackRequest", () => [{
    no: 1,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "type",
    kind: "enum",
    T: proto3.getEnumType(TrackType)
  }, {
    no: 4,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 7,
    name: "disable_dtx",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "source",
    kind: "enum",
    T: proto3.getEnumType(TrackSource)
  }, {
    no: 9,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }, {
    no: 10,
    name: "simulcast_codecs",
    kind: "message",
    T: SimulcastCodec,
    repeated: true
  }, {
    no: 11,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 12,
    name: "stereo",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 13,
    name: "disable_red",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 14,
    name: "encryption",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 15,
    name: "stream",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 16,
    name: "backup_codec_policy",
    kind: "enum",
    T: proto3.getEnumType(BackupCodecPolicy$1)
  }]);
  const TrickleRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.TrickleRequest", () => [{
    no: 1,
    name: "candidateInit",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "target",
    kind: "enum",
    T: proto3.getEnumType(SignalTarget)
  }, {
    no: 3,
    name: "final",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const MuteTrackRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.MuteTrackRequest", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const JoinResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.JoinResponse", () => [{
    no: 1,
    name: "room",
    kind: "message",
    T: Room$1
  }, {
    no: 2,
    name: "participant",
    kind: "message",
    T: ParticipantInfo
  }, {
    no: 3,
    name: "other_participants",
    kind: "message",
    T: ParticipantInfo,
    repeated: true
  }, {
    no: 4,
    name: "server_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "ice_servers",
    kind: "message",
    T: ICEServer,
    repeated: true
  }, {
    no: 6,
    name: "subscriber_primary",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 7,
    name: "alternative_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "client_configuration",
    kind: "message",
    T: ClientConfiguration
  }, {
    no: 9,
    name: "server_region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "ping_timeout",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 11,
    name: "ping_interval",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 12,
    name: "server_info",
    kind: "message",
    T: ServerInfo
  }, {
    no: 13,
    name: "sif_trailer",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 14,
    name: "enabled_publish_codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 15,
    name: "fast_publish",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const ReconnectResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.ReconnectResponse", () => [{
    no: 1,
    name: "ice_servers",
    kind: "message",
    T: ICEServer,
    repeated: true
  }, {
    no: 2,
    name: "client_configuration",
    kind: "message",
    T: ClientConfiguration
  }]);
  const TrackPublishedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackPublishedResponse", () => [{
    no: 1,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track",
    kind: "message",
    T: TrackInfo
  }]);
  const TrackUnpublishedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackUnpublishedResponse", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const SessionDescription = /* @__PURE__ */ proto3.makeMessageType("livekit.SessionDescription", () => [{
    no: 1,
    name: "type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "sdp",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ParticipantUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantUpdate", () => [{
    no: 1,
    name: "participants",
    kind: "message",
    T: ParticipantInfo,
    repeated: true
  }]);
  const UpdateSubscription = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateSubscription", () => [{
    no: 1,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "subscribe",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "participant_tracks",
    kind: "message",
    T: ParticipantTracks,
    repeated: true
  }]);
  const UpdateTrackSettings = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateTrackSettings", () => [{
    no: 1,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 3,
    name: "disabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 4,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 5,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "fps",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 8,
    name: "priority",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const UpdateLocalAudioTrack = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateLocalAudioTrack", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "features",
    kind: "enum",
    T: proto3.getEnumType(AudioTrackFeature),
    repeated: true
  }]);
  const UpdateLocalVideoTrack = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateLocalVideoTrack", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const LeaveRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.LeaveRequest", () => [{
    no: 1,
    name: "can_reconnect",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "reason",
    kind: "enum",
    T: proto3.getEnumType(DisconnectReason)
  }, {
    no: 3,
    name: "action",
    kind: "enum",
    T: proto3.getEnumType(LeaveRequest_Action)
  }, {
    no: 4,
    name: "regions",
    kind: "message",
    T: RegionSettings
  }]);
  const LeaveRequest_Action = /* @__PURE__ */ proto3.makeEnum("livekit.LeaveRequest.Action", [{
    no: 0,
    name: "DISCONNECT"
  }, {
    no: 1,
    name: "RESUME"
  }, {
    no: 2,
    name: "RECONNECT"
  }]);
  const UpdateVideoLayers = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateVideoLayers", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }]);
  const UpdateParticipantMetadata = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateParticipantMetadata", () => [{
    no: 1,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 4,
    name: "request_id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const ICEServer = /* @__PURE__ */ proto3.makeMessageType("livekit.ICEServer", () => [{
    no: 1,
    name: "urls",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "username",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "credential",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const SpeakersChanged = /* @__PURE__ */ proto3.makeMessageType("livekit.SpeakersChanged", () => [{
    no: 1,
    name: "speakers",
    kind: "message",
    T: SpeakerInfo,
    repeated: true
  }]);
  const RoomUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.RoomUpdate", () => [{
    no: 1,
    name: "room",
    kind: "message",
    T: Room$1
  }]);
  const ConnectionQualityInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ConnectionQualityInfo", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(ConnectionQuality$1)
  }, {
    no: 3,
    name: "score",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }]);
  const ConnectionQualityUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ConnectionQualityUpdate", () => [{
    no: 1,
    name: "updates",
    kind: "message",
    T: ConnectionQualityInfo,
    repeated: true
  }]);
  const StreamStateInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.StreamStateInfo", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "state",
    kind: "enum",
    T: proto3.getEnumType(StreamState)
  }]);
  const StreamStateUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.StreamStateUpdate", () => [{
    no: 1,
    name: "stream_states",
    kind: "message",
    T: StreamStateInfo,
    repeated: true
  }]);
  const SubscribedQuality = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedQuality", () => [{
    no: 1,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 2,
    name: "enabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const SubscribedCodec = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedCodec", () => [{
    no: 1,
    name: "codec",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "qualities",
    kind: "message",
    T: SubscribedQuality,
    repeated: true
  }]);
  const SubscribedQualityUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedQualityUpdate", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "subscribed_qualities",
    kind: "message",
    T: SubscribedQuality,
    repeated: true
  }, {
    no: 3,
    name: "subscribed_codecs",
    kind: "message",
    T: SubscribedCodec,
    repeated: true
  }]);
  const TrackPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackPermission", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "all_tracks",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const SubscriptionPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionPermission", () => [{
    no: 1,
    name: "all_participants",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "track_permissions",
    kind: "message",
    T: TrackPermission,
    repeated: true
  }]);
  const SubscriptionPermissionUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionPermissionUpdate", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "allowed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const SyncState = /* @__PURE__ */ proto3.makeMessageType("livekit.SyncState", () => [{
    no: 1,
    name: "answer",
    kind: "message",
    T: SessionDescription
  }, {
    no: 2,
    name: "subscription",
    kind: "message",
    T: UpdateSubscription
  }, {
    no: 3,
    name: "publish_tracks",
    kind: "message",
    T: TrackPublishedResponse,
    repeated: true
  }, {
    no: 4,
    name: "data_channels",
    kind: "message",
    T: DataChannelInfo,
    repeated: true
  }, {
    no: 5,
    name: "offer",
    kind: "message",
    T: SessionDescription
  }, {
    no: 6,
    name: "track_sids_disabled",
    kind: "scalar",
    T: 9,
    repeated: true
  }]);
  const DataChannelInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.DataChannelInfo", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "target",
    kind: "enum",
    T: proto3.getEnumType(SignalTarget)
  }]);
  const SimulateScenario = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulateScenario", () => [{
    no: 1,
    name: "speaker_update",
    kind: "scalar",
    T: 5,
    oneof: "scenario"
  }, {
    no: 2,
    name: "node_failure",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 3,
    name: "migration",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 4,
    name: "server_leave",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 5,
    name: "switch_candidate_protocol",
    kind: "enum",
    T: proto3.getEnumType(CandidateProtocol),
    oneof: "scenario"
  }, {
    no: 6,
    name: "subscriber_bandwidth",
    kind: "scalar",
    T: 3,
    oneof: "scenario"
  }, {
    no: 7,
    name: "disconnect_signal_on_resume",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 8,
    name: "disconnect_signal_on_resume_no_messages",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 9,
    name: "leave_request_full_reconnect",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }]);
  const Ping = /* @__PURE__ */ proto3.makeMessageType("livekit.Ping", () => [{
    no: 1,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "rtt",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  const Pong = /* @__PURE__ */ proto3.makeMessageType("livekit.Pong", () => [{
    no: 1,
    name: "last_ping_timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  const RegionSettings = /* @__PURE__ */ proto3.makeMessageType("livekit.RegionSettings", () => [{
    no: 1,
    name: "regions",
    kind: "message",
    T: RegionInfo,
    repeated: true
  }]);
  const RegionInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.RegionInfo", () => [{
    no: 1,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "distance",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  const SubscriptionResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionResponse", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "err",
    kind: "enum",
    T: proto3.getEnumType(SubscriptionError)
  }]);
  const RequestResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RequestResponse", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "reason",
    kind: "enum",
    T: proto3.getEnumType(RequestResponse_Reason)
  }, {
    no: 3,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const RequestResponse_Reason = /* @__PURE__ */ proto3.makeEnum("livekit.RequestResponse.Reason", [{
    no: 0,
    name: "OK"
  }, {
    no: 1,
    name: "NOT_FOUND"
  }, {
    no: 2,
    name: "NOT_ALLOWED"
  }, {
    no: 3,
    name: "LIMIT_EXCEEDED"
  }]);
  const TrackSubscribed = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackSubscribed", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  function getDefaultExportFromCjs$1(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var loglevel$1 = { exports: {} };
  var loglevel = loglevel$1.exports;
  var hasRequiredLoglevel;
  function requireLoglevel() {
    if (hasRequiredLoglevel)
      return loglevel$1.exports;
    hasRequiredLoglevel = 1;
    (function(module) {
      (function(root, definition) {
        if (module.exports) {
          module.exports = definition();
        } else {
          root.log = definition();
        }
      })(loglevel, function() {
        var noop2 = function() {
        };
        var undefinedType = "undefined";
        var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
        var logMethods = ["trace", "debug", "info", "warn", "error"];
        var _loggersByName = {};
        var defaultLogger = null;
        function bindMethod(obj, methodName) {
          var method = obj[methodName];
          if (typeof method.bind === "function") {
            return method.bind(obj);
          } else {
            try {
              return Function.prototype.bind.call(method, obj);
            } catch (e2) {
              return function() {
                return Function.prototype.apply.apply(method, [obj, arguments]);
              };
            }
          }
        }
        function traceForIE() {
          if (console.log) {
            if (console.log.apply) {
              console.log.apply(console, arguments);
            } else {
              Function.prototype.apply.apply(console.log, [console, arguments]);
            }
          }
          if (console.trace)
            console.trace();
        }
        function realMethod(methodName) {
          if (methodName === "debug") {
            methodName = "log";
          }
          if (typeof console === undefinedType) {
            return false;
          } else if (methodName === "trace" && isIE) {
            return traceForIE;
          } else if (console[methodName] !== void 0) {
            return bindMethod(console, methodName);
          } else if (console.log !== void 0) {
            return bindMethod(console, "log");
          } else {
            return noop2;
          }
        }
        function replaceLoggingMethods() {
          var level = this.getLevel();
          for (var i2 = 0; i2 < logMethods.length; i2++) {
            var methodName = logMethods[i2];
            this[methodName] = i2 < level ? noop2 : this.methodFactory(methodName, level, this.name);
          }
          this.log = this.debug;
          if (typeof console === undefinedType && level < this.levels.SILENT) {
            return "No console available for logging";
          }
        }
        function enableLoggingWhenConsoleArrives(methodName) {
          return function() {
            if (typeof console !== undefinedType) {
              replaceLoggingMethods.call(this);
              this[methodName].apply(this, arguments);
            }
          };
        }
        function defaultMethodFactory(methodName, _level, _loggerName) {
          return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
        }
        function Logger(name, factory) {
          var self2 = this;
          var inheritedLevel;
          var defaultLevel;
          var userLevel;
          var storageKey = "loglevel";
          if (typeof name === "string") {
            storageKey += ":" + name;
          } else if (typeof name === "symbol") {
            storageKey = void 0;
          }
          function persistLevelIfPossible(levelNum) {
            var levelName = (logMethods[levelNum] || "silent").toUpperCase();
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              window.localStorage[storageKey] = levelName;
              return;
            } catch (ignore) {
            }
            try {
              window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
            } catch (ignore) {
            }
          }
          function getPersistedLevel() {
            var storedLevel;
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              storedLevel = window.localStorage[storageKey];
            } catch (ignore) {
            }
            if (typeof storedLevel === undefinedType) {
              try {
                var cookie = window.document.cookie;
                var cookieName = encodeURIComponent(storageKey);
                var location2 = cookie.indexOf(cookieName + "=");
                if (location2 !== -1) {
                  storedLevel = /^([^;]+)/.exec(cookie.slice(location2 + cookieName.length + 1))[1];
                }
              } catch (ignore) {
              }
            }
            if (self2.levels[storedLevel] === void 0) {
              storedLevel = void 0;
            }
            return storedLevel;
          }
          function clearPersistedLevel() {
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              window.localStorage.removeItem(storageKey);
            } catch (ignore) {
            }
            try {
              window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch (ignore) {
            }
          }
          function normalizeLevel(input) {
            var level = input;
            if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
              level = self2.levels[level.toUpperCase()];
            }
            if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
              return level;
            } else {
              throw new TypeError("log.setLevel() called with invalid level: " + input);
            }
          }
          self2.name = name;
          self2.levels = {
            "TRACE": 0,
            "DEBUG": 1,
            "INFO": 2,
            "WARN": 3,
            "ERROR": 4,
            "SILENT": 5
          };
          self2.methodFactory = factory || defaultMethodFactory;
          self2.getLevel = function() {
            if (userLevel != null) {
              return userLevel;
            } else if (defaultLevel != null) {
              return defaultLevel;
            } else {
              return inheritedLevel;
            }
          };
          self2.setLevel = function(level, persist) {
            userLevel = normalizeLevel(level);
            if (persist !== false) {
              persistLevelIfPossible(userLevel);
            }
            return replaceLoggingMethods.call(self2);
          };
          self2.setDefaultLevel = function(level) {
            defaultLevel = normalizeLevel(level);
            if (!getPersistedLevel()) {
              self2.setLevel(level, false);
            }
          };
          self2.resetLevel = function() {
            userLevel = null;
            clearPersistedLevel();
            replaceLoggingMethods.call(self2);
          };
          self2.enableAll = function(persist) {
            self2.setLevel(self2.levels.TRACE, persist);
          };
          self2.disableAll = function(persist) {
            self2.setLevel(self2.levels.SILENT, persist);
          };
          self2.rebuild = function() {
            if (defaultLogger !== self2) {
              inheritedLevel = normalizeLevel(defaultLogger.getLevel());
            }
            replaceLoggingMethods.call(self2);
            if (defaultLogger === self2) {
              for (var childName in _loggersByName) {
                _loggersByName[childName].rebuild();
              }
            }
          };
          inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : "WARN");
          var initialLevel = getPersistedLevel();
          if (initialLevel != null) {
            userLevel = normalizeLevel(initialLevel);
          }
          replaceLoggingMethods.call(self2);
        }
        defaultLogger = new Logger();
        defaultLogger.getLogger = function getLogger2(name) {
          if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
            throw new TypeError("You must supply a name when creating a logger.");
          }
          var logger = _loggersByName[name];
          if (!logger) {
            logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);
          }
          return logger;
        };
        var _log = typeof window !== undefinedType ? window.log : void 0;
        defaultLogger.noConflict = function() {
          if (typeof window !== undefinedType && window.log === defaultLogger) {
            window.log = _log;
          }
          return defaultLogger;
        };
        defaultLogger.getLoggers = function getLoggers() {
          return _loggersByName;
        };
        defaultLogger["default"] = defaultLogger;
        return defaultLogger;
      });
    })(loglevel$1);
    return loglevel$1.exports;
  }
  var loglevelExports = requireLoglevel();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["trace"] = 0] = "trace";
    LogLevel2[LogLevel2["debug"] = 1] = "debug";
    LogLevel2[LogLevel2["info"] = 2] = "info";
    LogLevel2[LogLevel2["warn"] = 3] = "warn";
    LogLevel2[LogLevel2["error"] = 4] = "error";
    LogLevel2[LogLevel2["silent"] = 5] = "silent";
  })(LogLevel || (LogLevel = {}));
  var LoggerNames;
  (function(LoggerNames2) {
    LoggerNames2["Default"] = "livekit";
    LoggerNames2["Room"] = "livekit-room";
    LoggerNames2["Participant"] = "livekit-participant";
    LoggerNames2["Track"] = "livekit-track";
    LoggerNames2["Publication"] = "livekit-track-publication";
    LoggerNames2["Engine"] = "livekit-engine";
    LoggerNames2["Signal"] = "livekit-signal";
    LoggerNames2["PCManager"] = "livekit-pc-manager";
    LoggerNames2["PCTransport"] = "livekit-pc-transport";
    LoggerNames2["E2EE"] = "lk-e2ee";
  })(LoggerNames || (LoggerNames = {}));
  let livekitLogger = loglevelExports.getLogger("livekit");
  Object.values(LoggerNames).map((name) => loglevelExports.getLogger(name));
  livekitLogger.setDefaultLevel(LogLevel.info);
  function getLogger(name) {
    const logger = loglevelExports.getLogger(name);
    logger.setDefaultLevel(livekitLogger.getLevel());
    return logger;
  }
  const workerLogger = loglevelExports.getLogger("lk-e2ee");
  const maxRetryDelay = 7e3;
  const DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
  class DefaultReconnectPolicy {
    constructor(retryDelays) {
      this._retryDelays = retryDelays !== void 0 ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;
    }
    nextRetryDelayInMs(context) {
      if (context.retryCount >= this._retryDelays.length)
        return null;
      const retryDelay = this._retryDelays[context.retryCount];
      if (context.retryCount <= 1)
        return retryDelay;
      return retryDelay + Math.random() * 1e3;
    }
  }
  function __awaiter(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2)
      return m2.call(o2);
    if (o2 && typeof o2.length === "number")
      return {
        next: function() {
          if (o2 && i2 >= o2.length)
            o2 = void 0;
          return { value: o2 && o2[i2++], done: !o2 };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __asyncValues(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d2, v2) {
      Promise.resolve(v2).then(function(v22) {
        resolve({ value: v22, done: d2 });
      }, reject);
    }
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e2 = new Error(message);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  };
  var events = { exports: {} };
  var hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents)
      return events.exports;
    hasRequiredEvents = 1;
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:6727", warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    events.exports = EventEmitter;
    events.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++)
        args.push(arguments[i2]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit("newListener", type, listener.listener ? listener.listener : listener);
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = {
        fired: false,
        wrapFn: void 0,
        target,
        type,
        listener
      };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i2, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i2;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
          once: true
        });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
          });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    return events.exports;
  }
  var eventsExports = requireEvents();
  let logDisabled_ = true;
  let deprecationWarnings_ = true;
  function extractVersion(uastring, expr, pos) {
    const match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  }
  function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const proto = window2.RTCPeerConnection.prototype;
    const nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      const wrappedCallback = (e2) => {
        const modifiedEvent = wrapper(e2);
        if (modifiedEvent) {
          if (cb.handleEvent) {
            cb.handleEvent(modifiedEvent);
          } else {
            cb(modifiedEvent);
          }
        }
      };
      this._eventMap = this._eventMap || {};
      if (!this._eventMap[eventNameToWrap]) {
        this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
      }
      this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
      return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
    };
    const nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      if (!this._eventMap[eventNameToWrap].has(cb)) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
      this._eventMap[eventNameToWrap].delete(cb);
      if (this._eventMap[eventNameToWrap].size === 0) {
        delete this._eventMap[eventNameToWrap];
      }
      if (Object.keys(this._eventMap).length === 0) {
        delete this._eventMap;
      }
      return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
    };
    Object.defineProperty(proto, "on" + eventNameToWrap, {
      get() {
        return this["_on" + eventNameToWrap];
      },
      set(cb) {
        if (this["_on" + eventNameToWrap]) {
          this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
          delete this["_on" + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
  }
  function disableLog(bool) {
    if (typeof bool !== "boolean") {
      return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
    }
    logDisabled_ = bool;
    return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
  }
  function disableWarnings(bool) {
    if (typeof bool !== "boolean") {
      return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
    }
    deprecationWarnings_ = !bool;
    return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
  }
  function log() {
    if (typeof window === "object") {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== "undefined" && typeof console.log === "function") {
        console.log.apply(console, arguments);
      }
    }
  }
  function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:7218", oldMethod + " is deprecated, please use " + newMethod + " instead.");
  }
  function detectBrowser(window2) {
    const result = {
      browser: null,
      version: null
    };
    if (typeof window2 === "undefined" || !window2.navigator || !window2.navigator.userAgent) {
      result.browser = "Not a browser.";
      return result;
    }
    const {
      navigator: navigator2
    } = window2;
    if (navigator2.userAgentData && navigator2.userAgentData.brands) {
      const chromium = navigator2.userAgentData.brands.find((brand) => {
        return brand.brand === "Chromium";
      });
      if (chromium) {
        return {
          browser: "chrome",
          version: parseInt(chromium.version, 10)
        };
      }
    }
    if (navigator2.mozGetUserMedia) {
      result.browser = "firefox";
      result.version = extractVersion(navigator2.userAgent, /Firefox\/(\d+)\./, 1);
    } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {
      result.browser = "chrome";
      result.version = extractVersion(navigator2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
      result.browser = "safari";
      result.version = extractVersion(navigator2.userAgent, /AppleWebKit\/(\d+)\./, 1);
      result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
    } else {
      result.browser = "Not a supported browser.";
      return result;
    }
    return result;
  }
  function isObject$1(val) {
    return Object.prototype.toString.call(val) === "[object Object]";
  }
  function compactObject(data) {
    if (!isObject$1(data)) {
      return data;
    }
    return Object.keys(data).reduce(function(accumulator, key) {
      const isObj = isObject$1(data[key]);
      const value = isObj ? compactObject(data[key]) : data[key];
      const isEmptyObject = isObj && !Object.keys(value).length;
      if (value === void 0 || isEmptyObject) {
        return accumulator;
      }
      return Object.assign(accumulator, {
        [key]: value
      });
    }, {});
  }
  function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach((name) => {
      if (name.endsWith("Id")) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith("Ids")) {
        base[name].forEach((id) => {
          walkStats(stats, stats.get(id), resultSet);
        });
      }
    });
  }
  function filterStats(result, track, outbound) {
    const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
    const filteredResult = /* @__PURE__ */ new Map();
    if (track === null) {
      return filteredResult;
    }
    const trackStats = [];
    result.forEach((value) => {
      if (value.type === "track" && value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach((trackStat) => {
      result.forEach((stats) => {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }
  const logging = log;
  function shimGetUserMedia$2(window2, browserDetails2) {
    const navigator2 = window2 && window2.navigator;
    if (!navigator2.mediaDevices) {
      return;
    }
    const constraintsToChrome_ = function(c2) {
      if (typeof c2 !== "object" || c2.mandatory || c2.optional) {
        return c2;
      }
      const cc = {};
      Object.keys(c2).forEach((key) => {
        if (key === "require" || key === "advanced" || key === "mediaSource") {
          return;
        }
        const r2 = typeof c2[key] === "object" ? c2[key] : {
          ideal: c2[key]
        };
        if (r2.exact !== void 0 && typeof r2.exact === "number") {
          r2.min = r2.max = r2.exact;
        }
        const oldname_ = function(prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return name === "deviceId" ? "sourceId" : name;
        };
        if (r2.ideal !== void 0) {
          cc.optional = cc.optional || [];
          let oc = {};
          if (typeof r2.ideal === "number") {
            oc[oldname_("min", key)] = r2.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_("max", key)] = r2.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_("", key)] = r2.ideal;
            cc.optional.push(oc);
          }
        }
        if (r2.exact !== void 0 && typeof r2.exact !== "number") {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_("", key)] = r2.exact;
        } else {
          ["min", "max"].forEach((mix) => {
            if (r2[mix] !== void 0) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r2[mix];
            }
          });
        }
      });
      if (c2.advanced) {
        cc.optional = (cc.optional || []).concat(c2.advanced);
      }
      return cc;
    };
    const shimConstraints_ = function(constraints, func) {
      if (browserDetails2.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && typeof constraints.audio === "object") {
        const remap = function(obj, a2, b2) {
          if (a2 in obj && !(b2 in obj)) {
            obj[b2] = obj[a2];
            delete obj[a2];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, "autoGainControl", "googAutoGainControl");
        remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && typeof constraints.video === "object") {
        let face = constraints.video.facingMode;
        face = face && (typeof face === "object" ? face : {
          ideal: face
        });
        const getSupportedFacingModeLies = browserDetails2.version < 66;
        if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
          delete constraints.video.facingMode;
          let matches;
          if (face.exact === "environment" || face.ideal === "environment") {
            matches = ["back", "rear"];
          } else if (face.exact === "user" || face.ideal === "user") {
            matches = ["front"];
          }
          if (matches) {
            return navigator2.mediaDevices.enumerateDevices().then((devices) => {
              devices = devices.filter((d2) => d2.kind === "videoinput");
              let dev = devices.find((d2) => matches.some((match) => d2.label.toLowerCase().includes(match)));
              if (!dev && devices.length && matches.includes("back")) {
                dev = devices[devices.length - 1];
              }
              if (dev) {
                constraints.video.deviceId = face.exact ? {
                  exact: dev.deviceId
                } : {
                  ideal: dev.deviceId
                };
              }
              constraints.video = constraintsToChrome_(constraints.video);
              logging("chrome: " + JSON.stringify(constraints));
              return func(constraints);
            });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging("chrome: " + JSON.stringify(constraints));
      return func(constraints);
    };
    const shimError_ = function(e2) {
      if (browserDetails2.version >= 64) {
        return e2;
      }
      return {
        name: {
          PermissionDeniedError: "NotAllowedError",
          PermissionDismissedError: "NotAllowedError",
          InvalidStateError: "NotAllowedError",
          DevicesNotFoundError: "NotFoundError",
          ConstraintNotSatisfiedError: "OverconstrainedError",
          TrackStartError: "NotReadableError",
          MediaDeviceFailedDueToShutdown: "NotAllowedError",
          MediaDeviceKillSwitchOn: "NotAllowedError",
          TabCaptureError: "AbortError",
          ScreenCaptureError: "AbortError",
          DeviceCaptureError: "AbortError"
        }[e2.name] || e2.name,
        message: e2.message,
        constraint: e2.constraint || e2.constraintName,
        toString() {
          return this.name + (this.message && ": ") + this.message;
        }
      };
    };
    const getUserMedia_ = function(constraints, onSuccess, onError) {
      shimConstraints_(constraints, (c2) => {
        navigator2.webkitGetUserMedia(c2, onSuccess, (e2) => {
          if (onError) {
            onError(shimError_(e2));
          }
        });
      });
    };
    navigator2.getUserMedia = getUserMedia_.bind(navigator2);
    if (navigator2.mediaDevices.getUserMedia) {
      const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
      navigator2.mediaDevices.getUserMedia = function(cs2) {
        return shimConstraints_(cs2, (c2) => origGetUserMedia(c2).then((stream) => {
          if (c2.audio && !stream.getAudioTracks().length || c2.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach((track) => {
              track.stop();
            });
            throw new DOMException("", "NotFoundError");
          }
          return stream;
        }, (e2) => Promise.reject(shimError_(e2))));
      };
    }
  }
  function shimMediaStream(window2) {
    window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
  }
  function shimOnTrack$1(window2) {
    if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
        get() {
          return this._ontrack;
        },
        set(f2) {
          if (this._ontrack) {
            this.removeEventListener("track", this._ontrack);
          }
          this.addEventListener("track", this._ontrack = f2);
        },
        enumerable: true,
        configurable: true
      });
      const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
      window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        if (!this._ontrackpoly) {
          this._ontrackpoly = (e2) => {
            e2.stream.addEventListener("addtrack", (te2) => {
              let receiver;
              if (window2.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te2.track.id);
              } else {
                receiver = {
                  track: te2.track
                };
              }
              const event = new Event("track");
              event.track = te2.track;
              event.receiver = receiver;
              event.transceiver = {
                receiver
              };
              event.streams = [e2.stream];
              this.dispatchEvent(event);
            });
            e2.stream.getTracks().forEach((track) => {
              let receiver;
              if (window2.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);
              } else {
                receiver = {
                  track
                };
              }
              const event = new Event("track");
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {
                receiver
              };
              event.streams = [e2.stream];
              this.dispatchEvent(event);
            });
          };
          this.addEventListener("addstream", this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
    } else {
      wrapPeerConnectionEvent(window2, "track", (e2) => {
        if (!e2.transceiver) {
          Object.defineProperty(e2, "transceiver", {
            value: {
              receiver: e2.receiver
            }
          });
        }
        return e2;
      });
    }
  }
  function shimGetSendersWithDtmf(window2) {
    if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
      const shimSenderWithDtmf = function(pc, track) {
        return {
          track,
          get dtmf() {
            if (this._dtmf === void 0) {
              if (track.kind === "audio") {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };
      if (!window2.RTCPeerConnection.prototype.getSenders) {
        window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
          this._senders = this._senders || [];
          return this._senders.slice();
        };
        const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
        window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          let sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };
        const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
        window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          origRemoveTrack.apply(this, arguments);
          const idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
      }
      const origAddStream = window2.RTCPeerConnection.prototype.addStream;
      window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        this._senders = this._senders || [];
        origAddStream.apply(this, [stream]);
        stream.getTracks().forEach((track) => {
          this._senders.push(shimSenderWithDtmf(this, track));
        });
      };
      const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
      window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream]);
        stream.getTracks().forEach((track) => {
          const sender = this._senders.find((s2) => s2.track === track);
          if (sender) {
            this._senders.splice(this._senders.indexOf(sender), 1);
          }
        });
      };
    } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
      const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
      Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
        get() {
          if (this._dtmf === void 0) {
            if (this.track.kind === "audio") {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  }
  function shimSenderReceiverGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
      return;
    }
    if (!("getStats" in window2.RTCRtpSender.prototype)) {
      const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
          const senders = origGetSenders.apply(this, []);
          senders.forEach((sender) => sender._pc = this);
          return senders;
        };
      }
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
          const sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window2.RTCRtpSender.prototype.getStats = function getStats() {
        const sender = this;
        return this._pc.getStats().then((result) => (
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          filterStats(result, sender.track, true)
        ));
      };
    }
    if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
      const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
          const receivers = origGetReceivers.apply(this, []);
          receivers.forEach((receiver) => receiver._pc = this);
          return receivers;
        };
      }
      wrapPeerConnectionEvent(window2, "track", (e2) => {
        e2.receiver._pc = e2.srcElement;
        return e2;
      });
      window2.RTCRtpReceiver.prototype.getStats = function getStats() {
        const receiver = this;
        return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
      };
    }
    if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
      return;
    }
    const origGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
        const track = arguments[0];
        let sender;
        let receiver;
        let err;
        this.getSenders().forEach((s2) => {
          if (s2.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s2;
            }
          }
        });
        this.getReceivers().forEach((r2) => {
          if (r2.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r2;
            }
          }
          return r2.track === track;
        });
        if (err || sender && receiver) {
          return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
      }
      return origGetStats.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrackWithNative(window2) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
    };
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      const sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      stream.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s2) => s2.track === track);
        if (alreadyExists) {
          throw new DOMException("Track already exists.", "InvalidAccessError");
        }
      });
      const existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };
    const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
    window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            this._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (this._shimmedLocalStreams[streamId].length === 1) {
            delete this._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrack(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (window2.RTCPeerConnection.prototype.addTrack && browserDetails2.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window2);
    }
    const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      const nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
    };
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      stream.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s2) => s2.track === track);
        if (alreadyExists) {
          throw new DOMException("Track already exists.", "InvalidAccessError");
        }
      });
      if (!this._reverseStreams[stream.id]) {
        const newStream = new window2.MediaStream(stream.getTracks());
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(this, [stream]);
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
      delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
      delete this._streams[stream.id];
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
      if (this.signalingState === "closed") {
        throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
      }
      const streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 || !streams[0].getTracks().find((t2) => t2 === track)) {
        throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
      }
      const alreadyExists = this.getSenders().find((s2) => s2.track === track);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      const oldStream = this._streams[stream.id];
      if (oldStream) {
        oldStream.addTrack(track);
        Promise.resolve().then(() => {
          this.dispatchEvent(new Event("negotiationneeded"));
        });
      } else {
        const newStream = new window2.MediaStream([track]);
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        this.addStream(newStream);
      }
      return this.getSenders().find((s2) => s2.track === track);
    };
    function replaceInternalStreamId(pc, description) {
      let sdp2 = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp2 = sdp2.replace(new RegExp(internalStream.id, "g"), externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp2
      });
    }
    function replaceExternalStreamId(pc, description) {
      let sdp2 = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp2 = sdp2.replace(new RegExp(externalStream.id, "g"), internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp2
      });
    }
    ["createOffer", "createAnswer"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = {
        [method]() {
          const args = arguments;
          const isLegacyCall = arguments.length && typeof arguments[0] === "function";
          if (isLegacyCall) {
            return nativeMethod.apply(this, [(description) => {
              const desc = replaceInternalStreamId(this, description);
              args[0].apply(null, [desc]);
            }, (err) => {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]]);
          }
          return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
        }
      };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
    const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
    window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };
    const origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, "localDescription");
    Object.defineProperty(window2.RTCPeerConnection.prototype, "localDescription", {
      get() {
        const description = origLocalDescription.get.apply(this);
        if (description.type === "") {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    });
    window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      if (this.signalingState === "closed") {
        throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
      }
      if (!sender._pc) {
        throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
      }
      const isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
      }
      this._streams = this._streams || {};
      let stream;
      Object.keys(this._streams).forEach((streamid) => {
        const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
        if (hasTrack) {
          stream = this._streams[streamid];
        }
      });
      if (stream) {
        if (stream.getTracks().length === 1) {
          this.removeStream(this._reverseStreams[stream.id]);
        } else {
          stream.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event("negotiationneeded"));
      }
    };
  }
  function shimPeerConnection$1(window2, browserDetails2) {
    if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
      window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
    }
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (browserDetails2.version < 53) {
      ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
        const nativeMethod = window2.RTCPeerConnection.prototype[method];
        const methodObj = {
          [method]() {
            arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }
        };
        window2.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
  }
  function fixNegotiationNeeded(window2, browserDetails2) {
    wrapPeerConnectionEvent(window2, "negotiationneeded", (e2) => {
      const pc = e2.target;
      if (browserDetails2.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
        if (pc.signalingState !== "stable") {
          return;
        }
      }
      return e2;
    });
  }
  var chromeShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fixNegotiationNeeded,
    shimAddTrackRemoveTrack,
    shimAddTrackRemoveTrackWithNative,
    shimGetSendersWithDtmf,
    shimGetUserMedia: shimGetUserMedia$2,
    shimMediaStream,
    shimOnTrack: shimOnTrack$1,
    shimPeerConnection: shimPeerConnection$1,
    shimSenderReceiverGetStats
  });
  function shimGetUserMedia$1(window2, browserDetails2) {
    const navigator2 = window2 && window2.navigator;
    const MediaStreamTrack2 = window2 && window2.MediaStreamTrack;
    navigator2.getUserMedia = function(constraints, onSuccess, onError) {
      deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
      navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };
    if (!(browserDetails2.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
      const remap = function(obj, a2, b2) {
        if (a2 in obj && !(b2 in obj)) {
          obj[b2] = obj[a2];
          delete obj[a2];
        }
      };
      const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
      navigator2.mediaDevices.getUserMedia = function(c2) {
        if (typeof c2 === "object" && typeof c2.audio === "object") {
          c2 = JSON.parse(JSON.stringify(c2));
          remap(c2.audio, "autoGainControl", "mozAutoGainControl");
          remap(c2.audio, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeGetUserMedia(c2);
      };
      if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {
        const nativeGetSettings = MediaStreamTrack2.prototype.getSettings;
        MediaStreamTrack2.prototype.getSettings = function() {
          const obj = nativeGetSettings.apply(this, arguments);
          remap(obj, "mozAutoGainControl", "autoGainControl");
          remap(obj, "mozNoiseSuppression", "noiseSuppression");
          return obj;
        };
      }
      if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {
        const nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;
        MediaStreamTrack2.prototype.applyConstraints = function(c2) {
          if (this.kind === "audio" && typeof c2 === "object") {
            c2 = JSON.parse(JSON.stringify(c2));
            remap(c2, "autoGainControl", "mozAutoGainControl");
            remap(c2, "noiseSuppression", "mozNoiseSuppression");
          }
          return nativeApplyConstraints.apply(this, [c2]);
        };
      }
    }
  }
  function shimGetDisplayMedia(window2, preferredMediaSource) {
    if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
      return;
    }
    if (!window2.navigator.mediaDevices) {
      return;
    }
    window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
      if (!(constraints && constraints.video)) {
        const err = new DOMException("getDisplayMedia without video constraints is undefined");
        err.name = "NotFoundError";
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {
          mediaSource: preferredMediaSource
        };
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    };
  }
  function shimOnTrack(window2) {
    if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
      Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return {
            receiver: this.receiver
          };
        }
      });
    }
  }
  function shimPeerConnection(window2, browserDetails2) {
    if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
      return;
    }
    if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
      window2.RTCPeerConnection = window2.mozRTCPeerConnection;
    }
    if (browserDetails2.version < 53) {
      ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
        const nativeMethod = window2.RTCPeerConnection.prototype[method];
        const methodObj = {
          [method]() {
            arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }
        };
        window2.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
    const modernStatsTypes = {
      inboundrtp: "inbound-rtp",
      outboundrtp: "outbound-rtp",
      candidatepair: "candidate-pair",
      localcandidate: "local-candidate",
      remotecandidate: "remote-candidate"
    };
    const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
      return nativeGetStats.apply(this, [selector || null]).then((stats) => {
        if (browserDetails2.version < 53 && !onSucc) {
          try {
            stats.forEach((stat) => {
              stat.type = modernStatsTypes[stat.type] || stat.type;
            });
          } catch (e2) {
            if (e2.name !== "TypeError") {
              throw e2;
            }
            stats.forEach((stat, i2) => {
              stats.set(i2, Object.assign({}, stat, {
                type: modernStatsTypes[stat.type] || stat.type
              }));
            });
          }
        }
        return stats;
      }).then(onSucc, onErr);
    };
  }
  function shimSenderGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
      return;
    }
    if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
      return;
    }
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
    };
  }
  function shimReceiverGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
      return;
    }
    if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
      return;
    }
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", (e2) => {
      e2.receiver._pc = e2.srcElement;
      return e2;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      return this._pc.getStats(this.track);
    };
  }
  function shimRemoveStream(window2) {
    if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
      return;
    }
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      deprecated("removeStream", "removeTrack");
      this.getSenders().forEach((sender) => {
        if (sender.track && stream.getTracks().includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
  function shimRTCDataChannel(window2) {
    if (window2.DataChannel && !window2.RTCDataChannel) {
      window2.RTCDataChannel = window2.DataChannel;
    }
  }
  function shimAddTransceiver(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
    if (origAddTransceiver) {
      window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
        this.setParametersPromises = [];
        let sendEncodings = arguments[1] && arguments[1].sendEncodings;
        if (sendEncodings === void 0) {
          sendEncodings = [];
        }
        sendEncodings = [...sendEncodings];
        const shouldPerformCheck = sendEncodings.length > 0;
        if (shouldPerformCheck) {
          sendEncodings.forEach((encodingParam) => {
            if ("rid" in encodingParam) {
              const ridRegex = /^[a-z0-9]{0,16}$/i;
              if (!ridRegex.test(encodingParam.rid)) {
                throw new TypeError("Invalid RID value provided.");
              }
            }
            if ("scaleResolutionDownBy" in encodingParam) {
              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
                throw new RangeError("scale_resolution_down_by must be >= 1.0");
              }
            }
            if ("maxFramerate" in encodingParam) {
              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                throw new RangeError("max_framerate must be >= 0.0");
              }
            }
          });
        }
        const transceiver = origAddTransceiver.apply(this, arguments);
        if (shouldPerformCheck) {
          const {
            sender
          } = transceiver;
          const params = sender.getParameters();
          if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
          params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
            params.encodings = sendEncodings;
            sender.sendEncodings = sendEncodings;
            this.setParametersPromises.push(sender.setParameters(params).then(() => {
              delete sender.sendEncodings;
            }).catch(() => {
              delete sender.sendEncodings;
            }));
          }
        }
        return transceiver;
      };
    }
  }
  function shimGetParameters(window2) {
    if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
      return;
    }
    const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
    if (origGetParameters) {
      window2.RTCRtpSender.prototype.getParameters = function getParameters() {
        const params = origGetParameters.apply(this, arguments);
        if (!("encodings" in params)) {
          params.encodings = [].concat(this.sendEncodings || [{}]);
        }
        return params;
      };
    }
  }
  function shimCreateOffer(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
    window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises).then(() => {
          return origCreateOffer.apply(this, arguments);
        }).finally(() => {
          this.setParametersPromises = [];
        });
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimCreateAnswer(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
    window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises).then(() => {
          return origCreateAnswer.apply(this, arguments);
        }).finally(() => {
          this.setParametersPromises = [];
        });
      }
      return origCreateAnswer.apply(this, arguments);
    };
  }
  var firefoxShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    shimAddTransceiver,
    shimCreateAnswer,
    shimCreateOffer,
    shimGetDisplayMedia,
    shimGetParameters,
    shimGetUserMedia: shimGetUserMedia$1,
    shimOnTrack,
    shimPeerConnection,
    shimRTCDataChannel,
    shimReceiverGetStats,
    shimRemoveStream,
    shimSenderGetStats
  });
  function shimLocalStreamsAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!("addStream" in window2.RTCPeerConnection.prototype)) {
      const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
        stream.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream));
        stream.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream));
      };
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
        for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          streams[_key - 1] = arguments[_key];
        }
        if (streams) {
          streams.forEach((stream) => {
            if (!this._localStreams) {
              this._localStreams = [stream];
            } else if (!this._localStreams.includes(stream)) {
              this._localStreams.push(stream);
            }
          });
        }
        return _addTrack.apply(this, arguments);
      };
    }
    if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        const index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        const tracks = stream.getTracks();
        this.getSenders().forEach((sender) => {
          if (tracks.includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
    }
  }
  function shimRemoteStreamsAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
        get() {
          return this._onaddstream;
        },
        set(f2) {
          if (this._onaddstream) {
            this.removeEventListener("addstream", this._onaddstream);
            this.removeEventListener("track", this._onaddstreampoly);
          }
          this.addEventListener("addstream", this._onaddstream = f2);
          this.addEventListener("track", this._onaddstreampoly = (e2) => {
            e2.streams.forEach((stream) => {
              if (!this._remoteStreams) {
                this._remoteStreams = [];
              }
              if (this._remoteStreams.includes(stream)) {
                return;
              }
              this._remoteStreams.push(stream);
              const event = new Event("addstream");
              event.stream = stream;
              this.dispatchEvent(event);
            });
          });
        }
      });
      const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
      window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        const pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener("track", this._onaddstreampoly = function(e2) {
            e2.streams.forEach((stream) => {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              const event = new Event("addstream");
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  }
  function shimCallbacksAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    const prototype = window2.RTCPeerConnection.prototype;
    const origCreateOffer = prototype.createOffer;
    const origCreateAnswer = prototype.createAnswer;
    const setLocalDescription = prototype.setLocalDescription;
    const setRemoteDescription = prototype.setRemoteDescription;
    const addIceCandidate = prototype.addIceCandidate;
    prototype.createOffer = function createOffer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    let withCallback = function(description, successCallback, failureCallback) {
      const promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;
    withCallback = function(description, successCallback, failureCallback) {
      const promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;
    withCallback = function(candidate, successCallback, failureCallback) {
      const promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  }
  function shimGetUserMedia(window2) {
    const navigator2 = window2 && window2.navigator;
    if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
      const mediaDevices = navigator2.mediaDevices;
      const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator2.mediaDevices.getUserMedia = (constraints) => {
        return _getUserMedia(shimConstraints(constraints));
      };
    }
    if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
      navigator2.getUserMedia = (function getUserMedia(constraints, cb, errcb) {
        navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
      }).bind(navigator2);
    }
  }
  function shimConstraints(constraints) {
    if (constraints && constraints.video !== void 0) {
      return Object.assign({}, constraints, {
        video: compactObject(constraints.video)
      });
    }
    return constraints;
  }
  function shimRTCIceServerUrls(window2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const OrigPeerConnection = window2.RTCPeerConnection;
    window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        const newIceServers = [];
        for (let i2 = 0; i2 < pcConfig.iceServers.length; i2++) {
          let server = pcConfig.iceServers[i2];
          if (server.urls === void 0 && server.url) {
            deprecated("RTCIceServer.url", "RTCIceServer.urls");
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i2]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    if ("generateCertificate" in OrigPeerConnection) {
      Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
        get() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  }
  function shimTrackEventTransceiver(window2) {
    if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
      Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return {
            receiver: this.receiver
          };
        }
      });
    }
  }
  function shimCreateOfferLegacy(window2) {
    const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
    window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === "sendrecv") {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection("sendonly");
            } else {
              audioTransceiver.direction = "sendonly";
            }
          } else if (audioTransceiver.direction === "recvonly") {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection("inactive");
            } else {
              audioTransceiver.direction = "inactive";
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
          this.addTransceiver("audio", {
            direction: "recvonly"
          });
        }
        if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === "sendrecv") {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection("sendonly");
            } else {
              videoTransceiver.direction = "sendonly";
            }
          } else if (videoTransceiver.direction === "recvonly") {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection("inactive");
            } else {
              videoTransceiver.direction = "inactive";
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
          this.addTransceiver("video", {
            direction: "recvonly"
          });
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimAudioContext(window2) {
    if (typeof window2 !== "object" || window2.AudioContext) {
      return;
    }
    window2.AudioContext = window2.webkitAudioContext;
  }
  var safariShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    shimAudioContext,
    shimCallbacksAPI,
    shimConstraints,
    shimCreateOfferLegacy,
    shimGetUserMedia,
    shimLocalStreamsAPI,
    shimRTCIceServerUrls,
    shimRemoteStreamsAPI,
    shimTrackEventTransceiver
  });
  var sdp$1 = { exports: {} };
  var hasRequiredSdp;
  function requireSdp() {
    if (hasRequiredSdp)
      return sdp$1.exports;
    hasRequiredSdp = 1;
    (function(module) {
      const SDPUtils2 = {};
      SDPUtils2.generateIdentifier = function() {
        return Math.random().toString(36).substring(2, 12);
      };
      SDPUtils2.localCName = SDPUtils2.generateIdentifier();
      SDPUtils2.splitLines = function(blob) {
        return blob.trim().split("\n").map((line) => line.trim());
      };
      SDPUtils2.splitSections = function(blob) {
        const parts = blob.split("\nm=");
        return parts.map((part, index) => (index > 0 ? "m=" + part : part).trim() + "\r\n");
      };
      SDPUtils2.getDescription = function(blob) {
        const sections = SDPUtils2.splitSections(blob);
        return sections && sections[0];
      };
      SDPUtils2.getMediaSections = function(blob) {
        const sections = SDPUtils2.splitSections(blob);
        sections.shift();
        return sections;
      };
      SDPUtils2.matchPrefix = function(blob, prefix) {
        return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
      };
      SDPUtils2.parseCandidate = function(line) {
        let parts;
        if (line.indexOf("a=candidate:") === 0) {
          parts = line.substring(12).split(" ");
        } else {
          parts = line.substring(10).split(" ");
        }
        const candidate = {
          foundation: parts[0],
          component: {
            1: "rtp",
            2: "rtcp"
          }[parts[1]] || parts[1],
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          address: parts[4],
          // address is an alias for ip.
          port: parseInt(parts[5], 10),
          // skip parts[6] == 'typ'
          type: parts[7]
        };
        for (let i2 = 8; i2 < parts.length; i2 += 2) {
          switch (parts[i2]) {
            case "raddr":
              candidate.relatedAddress = parts[i2 + 1];
              break;
            case "rport":
              candidate.relatedPort = parseInt(parts[i2 + 1], 10);
              break;
            case "tcptype":
              candidate.tcpType = parts[i2 + 1];
              break;
            case "ufrag":
              candidate.ufrag = parts[i2 + 1];
              candidate.usernameFragment = parts[i2 + 1];
              break;
            default:
              if (candidate[parts[i2]] === void 0) {
                candidate[parts[i2]] = parts[i2 + 1];
              }
              break;
          }
        }
        return candidate;
      };
      SDPUtils2.writeCandidate = function(candidate) {
        const sdp2 = [];
        sdp2.push(candidate.foundation);
        const component = candidate.component;
        if (component === "rtp") {
          sdp2.push(1);
        } else if (component === "rtcp") {
          sdp2.push(2);
        } else {
          sdp2.push(component);
        }
        sdp2.push(candidate.protocol.toUpperCase());
        sdp2.push(candidate.priority);
        sdp2.push(candidate.address || candidate.ip);
        sdp2.push(candidate.port);
        const type = candidate.type;
        sdp2.push("typ");
        sdp2.push(type);
        if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
          sdp2.push("raddr");
          sdp2.push(candidate.relatedAddress);
          sdp2.push("rport");
          sdp2.push(candidate.relatedPort);
        }
        if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
          sdp2.push("tcptype");
          sdp2.push(candidate.tcpType);
        }
        if (candidate.usernameFragment || candidate.ufrag) {
          sdp2.push("ufrag");
          sdp2.push(candidate.usernameFragment || candidate.ufrag);
        }
        return "candidate:" + sdp2.join(" ");
      };
      SDPUtils2.parseIceOptions = function(line) {
        return line.substring(14).split(" ");
      };
      SDPUtils2.parseRtpMap = function(line) {
        let parts = line.substring(9).split(" ");
        const parsed = {
          payloadType: parseInt(parts.shift(), 10)
          // was: id
        };
        parts = parts[0].split("/");
        parsed.name = parts[0];
        parsed.clockRate = parseInt(parts[1], 10);
        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
        parsed.numChannels = parsed.channels;
        return parsed;
      };
      SDPUtils2.writeRtpMap = function(codec) {
        let pt2 = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt2 = codec.preferredPayloadType;
        }
        const channels = codec.channels || codec.numChannels || 1;
        return "a=rtpmap:" + pt2 + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
      };
      SDPUtils2.parseExtmap = function(line) {
        const parts = line.substring(9).split(" ");
        return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
          uri: parts[1],
          attributes: parts.slice(2).join(" ")
        };
      };
      SDPUtils2.writeExtmap = function(headerExtension) {
        return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
      };
      SDPUtils2.parseFmtp = function(line) {
        const parsed = {};
        let kv;
        const parts = line.substring(line.indexOf(" ") + 1).split(";");
        for (let j2 = 0; j2 < parts.length; j2++) {
          kv = parts[j2].trim().split("=");
          parsed[kv[0].trim()] = kv[1];
        }
        return parsed;
      };
      SDPUtils2.writeFmtp = function(codec) {
        let line = "";
        let pt2 = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt2 = codec.preferredPayloadType;
        }
        if (codec.parameters && Object.keys(codec.parameters).length) {
          const params = [];
          Object.keys(codec.parameters).forEach((param) => {
            if (codec.parameters[param] !== void 0) {
              params.push(param + "=" + codec.parameters[param]);
            } else {
              params.push(param);
            }
          });
          line += "a=fmtp:" + pt2 + " " + params.join(";") + "\r\n";
        }
        return line;
      };
      SDPUtils2.parseRtcpFb = function(line) {
        const parts = line.substring(line.indexOf(" ") + 1).split(" ");
        return {
          type: parts.shift(),
          parameter: parts.join(" ")
        };
      };
      SDPUtils2.writeRtcpFb = function(codec) {
        let lines = "";
        let pt2 = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt2 = codec.preferredPayloadType;
        }
        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
          codec.rtcpFeedback.forEach((fb) => {
            lines += "a=rtcp-fb:" + pt2 + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
          });
        }
        return lines;
      };
      SDPUtils2.parseSsrcMedia = function(line) {
        const sp = line.indexOf(" ");
        const parts = {
          ssrc: parseInt(line.substring(7, sp), 10)
        };
        const colon = line.indexOf(":", sp);
        if (colon > -1) {
          parts.attribute = line.substring(sp + 1, colon);
          parts.value = line.substring(colon + 1);
        } else {
          parts.attribute = line.substring(sp + 1);
        }
        return parts;
      };
      SDPUtils2.parseSsrcGroup = function(line) {
        const parts = line.substring(13).split(" ");
        return {
          semantics: parts.shift(),
          ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
        };
      };
      SDPUtils2.getMid = function(mediaSection) {
        const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
        if (mid) {
          return mid.substring(6);
        }
      };
      SDPUtils2.parseFingerprint = function(line) {
        const parts = line.substring(14).split(" ");
        return {
          algorithm: parts[0].toLowerCase(),
          // algorithm is case-sensitive in Edge.
          value: parts[1].toUpperCase()
          // the definition is upper-case in RFC 4572.
        };
      };
      SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
        return {
          role: "auto",
          fingerprints: lines.map(SDPUtils2.parseFingerprint)
        };
      };
      SDPUtils2.writeDtlsParameters = function(params, setupType) {
        let sdp2 = "a=setup:" + setupType + "\r\n";
        params.fingerprints.forEach((fp) => {
          sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
        });
        return sdp2;
      };
      SDPUtils2.parseCryptoLine = function(line) {
        const parts = line.substring(9).split(" ");
        return {
          tag: parseInt(parts[0], 10),
          cryptoSuite: parts[1],
          keyParams: parts[2],
          sessionParams: parts.slice(3)
        };
      };
      SDPUtils2.writeCryptoLine = function(parameters) {
        return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
      };
      SDPUtils2.parseCryptoKeyParams = function(keyParams) {
        if (keyParams.indexOf("inline:") !== 0) {
          return null;
        }
        const parts = keyParams.substring(7).split("|");
        return {
          keyMethod: "inline",
          keySalt: parts[0],
          lifeTime: parts[1],
          mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
          mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
        };
      };
      SDPUtils2.writeCryptoKeyParams = function(keyParams) {
        return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
      };
      SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=crypto:");
        return lines.map(SDPUtils2.parseCryptoLine);
      };
      SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
        const ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
        const pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
        if (!(ufrag && pwd)) {
          return null;
        }
        return {
          usernameFragment: ufrag.substring(12),
          password: pwd.substring(10)
        };
      };
      SDPUtils2.writeIceParameters = function(params) {
        let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
        if (params.iceLite) {
          sdp2 += "a=ice-lite\r\n";
        }
        return sdp2;
      };
      SDPUtils2.parseRtpParameters = function(mediaSection) {
        const description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: []
        };
        const lines = SDPUtils2.splitLines(mediaSection);
        const mline = lines[0].split(" ");
        description.profile = mline[2];
        for (let i2 = 3; i2 < mline.length; i2++) {
          const pt2 = mline[i2];
          const rtpmapline = SDPUtils2.matchPrefix(mediaSection, "a=rtpmap:" + pt2 + " ")[0];
          if (rtpmapline) {
            const codec = SDPUtils2.parseRtpMap(rtpmapline);
            const fmtps = SDPUtils2.matchPrefix(mediaSection, "a=fmtp:" + pt2 + " ");
            codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:" + pt2 + " ").map(SDPUtils2.parseRtcpFb);
            description.codecs.push(codec);
            switch (codec.name.toUpperCase()) {
              case "RED":
              case "ULPFEC":
                description.fecMechanisms.push(codec.name.toUpperCase());
                break;
            }
          }
        }
        SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
          description.headerExtensions.push(SDPUtils2.parseExtmap(line));
        });
        const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils2.parseRtcpFb);
        description.codecs.forEach((codec) => {
          wildcardRtcpFb.forEach((fb) => {
            const duplicate = codec.rtcpFeedback.find((existingFeedback) => {
              return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
            });
            if (!duplicate) {
              codec.rtcpFeedback.push(fb);
            }
          });
        });
        return description;
      };
      SDPUtils2.writeRtpDescription = function(kind, caps) {
        let sdp2 = "";
        sdp2 += "m=" + kind + " ";
        sdp2 += caps.codecs.length > 0 ? "9" : "0";
        sdp2 += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
        sdp2 += caps.codecs.map((codec) => {
          if (codec.preferredPayloadType !== void 0) {
            return codec.preferredPayloadType;
          }
          return codec.payloadType;
        }).join(" ") + "\r\n";
        sdp2 += "c=IN IP4 0.0.0.0\r\n";
        sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
        caps.codecs.forEach((codec) => {
          sdp2 += SDPUtils2.writeRtpMap(codec);
          sdp2 += SDPUtils2.writeFmtp(codec);
          sdp2 += SDPUtils2.writeRtcpFb(codec);
        });
        let maxptime = 0;
        caps.codecs.forEach((codec) => {
          if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
          }
        });
        if (maxptime > 0) {
          sdp2 += "a=maxptime:" + maxptime + "\r\n";
        }
        if (caps.headerExtensions) {
          caps.headerExtensions.forEach((extension) => {
            sdp2 += SDPUtils2.writeExtmap(extension);
          });
        }
        return sdp2;
      };
      SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
        const encodingParameters = [];
        const description = SDPUtils2.parseRtpParameters(mediaSection);
        const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
        const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
        const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
        let secondarySsrc;
        const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
          const parts = line.substring(17).split(" ");
          return parts.map((part) => parseInt(part, 10));
        });
        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
          secondarySsrc = flows[0][1];
        }
        description.codecs.forEach((codec) => {
          if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
            let encParam = {
              ssrc: primarySsrc,
              codecPayloadType: parseInt(codec.parameters.apt, 10)
            };
            if (primarySsrc && secondarySsrc) {
              encParam.rtx = {
                ssrc: secondarySsrc
              };
            }
            encodingParameters.push(encParam);
            if (hasRed) {
              encParam = JSON.parse(JSON.stringify(encParam));
              encParam.fec = {
                ssrc: primarySsrc,
                mechanism: hasUlpfec ? "red+ulpfec" : "red"
              };
              encodingParameters.push(encParam);
            }
          }
        });
        if (encodingParameters.length === 0 && primarySsrc) {
          encodingParameters.push({
            ssrc: primarySsrc
          });
        }
        let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
        if (bandwidth.length) {
          if (bandwidth[0].indexOf("b=TIAS:") === 0) {
            bandwidth = parseInt(bandwidth[0].substring(7), 10);
          } else if (bandwidth[0].indexOf("b=AS:") === 0) {
            bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
          } else {
            bandwidth = void 0;
          }
          encodingParameters.forEach((params) => {
            params.maxBitrate = bandwidth;
          });
        }
        return encodingParameters;
      };
      SDPUtils2.parseRtcpParameters = function(mediaSection) {
        const rtcpParameters = {};
        const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
        if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
        }
        const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
        rtcpParameters.reducedSize = rsize.length > 0;
        rtcpParameters.compound = rsize.length === 0;
        const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
        rtcpParameters.mux = mux.length > 0;
        return rtcpParameters;
      };
      SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
        let sdp2 = "";
        if (rtcpParameters.reducedSize) {
          sdp2 += "a=rtcp-rsize\r\n";
        }
        if (rtcpParameters.mux) {
          sdp2 += "a=rtcp-mux\r\n";
        }
        if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
          sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
        }
        return sdp2;
      };
      SDPUtils2.parseMsid = function(mediaSection) {
        let parts;
        const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
        if (spec.length === 1) {
          parts = spec[0].substring(7).split(" ");
          return {
            stream: parts[0],
            track: parts[1]
          };
        }
        const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
        if (planB.length > 0) {
          parts = planB[0].value.split(" ");
          return {
            stream: parts[0],
            track: parts[1]
          };
        }
      };
      SDPUtils2.parseSctpDescription = function(mediaSection) {
        const mline = SDPUtils2.parseMLine(mediaSection);
        const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
        let maxMessageSize;
        if (maxSizeLine.length > 0) {
          maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
        }
        if (isNaN(maxMessageSize)) {
          maxMessageSize = 65536;
        }
        const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
        if (sctpPort.length > 0) {
          return {
            port: parseInt(sctpPort[0].substring(12), 10),
            protocol: mline.fmt,
            maxMessageSize
          };
        }
        const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
        if (sctpMapLines.length > 0) {
          const parts = sctpMapLines[0].substring(10).split(" ");
          return {
            port: parseInt(parts[0], 10),
            protocol: parts[1],
            maxMessageSize
          };
        }
      };
      SDPUtils2.writeSctpDescription = function(media, sctp) {
        let output = [];
        if (media.protocol !== "DTLS/SCTP") {
          output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + sctp.port + "\r\n"];
        } else {
          output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"];
        }
        if (sctp.maxMessageSize !== void 0) {
          output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
        }
        return output.join("");
      };
      SDPUtils2.generateSessionId = function() {
        return Math.random().toString().substr(2, 22);
      };
      SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
        let sessionId;
        const version2 = sessVer !== void 0 ? sessVer : 2;
        if (sessId) {
          sessionId = sessId;
        } else {
          sessionId = SDPUtils2.generateSessionId();
        }
        const user = sessUser || "thisisadapterortc";
        return "v=0\r\no=" + user + " " + sessionId + " " + version2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
      };
      SDPUtils2.getDirection = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.splitLines(mediaSection);
        for (let i2 = 0; i2 < lines.length; i2++) {
          switch (lines[i2]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return lines[i2].substring(2);
          }
        }
        if (sessionpart) {
          return SDPUtils2.getDirection(sessionpart);
        }
        return "sendrecv";
      };
      SDPUtils2.getKind = function(mediaSection) {
        const lines = SDPUtils2.splitLines(mediaSection);
        const mline = lines[0].split(" ");
        return mline[0].substring(2);
      };
      SDPUtils2.isRejected = function(mediaSection) {
        return mediaSection.split(" ", 2)[1] === "0";
      };
      SDPUtils2.parseMLine = function(mediaSection) {
        const lines = SDPUtils2.splitLines(mediaSection);
        const parts = lines[0].substring(2).split(" ");
        return {
          kind: parts[0],
          port: parseInt(parts[1], 10),
          protocol: parts[2],
          fmt: parts.slice(3).join(" ")
        };
      };
      SDPUtils2.parseOLine = function(mediaSection) {
        const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
        const parts = line.substring(2).split(" ");
        return {
          username: parts[0],
          sessionId: parts[1],
          sessionVersion: parseInt(parts[2], 10),
          netType: parts[3],
          addressType: parts[4],
          address: parts[5]
        };
      };
      SDPUtils2.isValidSDP = function(blob) {
        if (typeof blob !== "string" || blob.length === 0) {
          return false;
        }
        const lines = SDPUtils2.splitLines(blob);
        for (let i2 = 0; i2 < lines.length; i2++) {
          if (lines[i2].length < 2 || lines[i2].charAt(1) !== "=") {
            return false;
          }
        }
        return true;
      };
      {
        module.exports = SDPUtils2;
      }
    })(sdp$1);
    return sdp$1.exports;
  }
  var sdpExports = requireSdp();
  var SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs$1(sdpExports);
  var sdp = /* @__PURE__ */ _mergeNamespaces$1({
    __proto__: null,
    default: SDPUtils
  }, [sdpExports]);
  function shimRTCIceCandidate(window2) {
    if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
      return;
    }
    const NativeRTCIceCandidate = window2.RTCIceCandidate;
    window2.RTCIceCandidate = function RTCIceCandidate2(args) {
      if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substring(2);
      }
      if (args.candidate && args.candidate.length) {
        const nativeCandidate = new NativeRTCIceCandidate(args);
        const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        for (const key in parsedCandidate) {
          if (!(key in nativeCandidate)) {
            Object.defineProperty(nativeCandidate, key, {
              value: parsedCandidate[key]
            });
          }
        }
        nativeCandidate.toJSON = function toJSON() {
          return {
            candidate: nativeCandidate.candidate,
            sdpMid: nativeCandidate.sdpMid,
            sdpMLineIndex: nativeCandidate.sdpMLineIndex,
            usernameFragment: nativeCandidate.usernameFragment
          };
        };
        return nativeCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
    wrapPeerConnectionEvent(window2, "icecandidate", (e2) => {
      if (e2.candidate) {
        Object.defineProperty(e2, "candidate", {
          value: new window2.RTCIceCandidate(e2.candidate),
          writable: "false"
        });
      }
      return e2;
    });
  }
  function shimRTCIceCandidateRelayProtocol(window2) {
    if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "relayProtocol" in window2.RTCIceCandidate.prototype) {
      return;
    }
    wrapPeerConnectionEvent(window2, "icecandidate", (e2) => {
      if (e2.candidate) {
        const parsedCandidate = SDPUtils.parseCandidate(e2.candidate.candidate);
        if (parsedCandidate.type === "relay") {
          e2.candidate.relayProtocol = {
            0: "tls",
            1: "tcp",
            2: "udp"
          }[parsedCandidate.priority >> 24];
        }
      }
      return e2;
    });
  }
  function shimMaxMessageSize(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (!("sctp" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
        get() {
          return typeof this._sctp === "undefined" ? null : this._sctp;
        }
      });
    }
    const sctpInDescription = function(description) {
      if (!description || !description.sdp) {
        return false;
      }
      const sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some((mediaSection) => {
        const mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
      });
    };
    const getRemoteFirefoxVersion = function(description) {
      const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      const version2 = parseInt(match[1], 10);
      return version2 !== version2 ? -1 : version2;
    };
    const getCanSendMaxMessageSize = function(remoteIsFirefox) {
      let canSendMaxMessageSize = 65536;
      if (browserDetails2.browser === "firefox") {
        if (browserDetails2.version < 57) {
          if (remoteIsFirefox === -1) {
            canSendMaxMessageSize = 16384;
          } else {
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails2.version < 60) {
          canSendMaxMessageSize = browserDetails2.version === 57 ? 65535 : 65536;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };
    const getMaxMessageSize = function(description, remoteIsFirefox) {
      let maxMessageSize = 65536;
      if (browserDetails2.browser === "firefox" && browserDetails2.version === 57) {
        maxMessageSize = 65535;
      }
      const match = SDPUtils.matchPrefix(description.sdp, "a=max-message-size:");
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substring(19), 10);
      } else if (browserDetails2.browser === "firefox" && remoteIsFirefox !== -1) {
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      this._sctp = null;
      if (browserDetails2.browser === "chrome" && browserDetails2.version >= 76) {
        const {
          sdpSemantics
        } = this.getConfiguration();
        if (sdpSemantics === "plan-b") {
          Object.defineProperty(this, "sctp", {
            get() {
              return typeof this._sctp === "undefined" ? null : this._sctp;
            },
            enumerable: true,
            configurable: true
          });
        }
      }
      if (sctpInDescription(arguments[0])) {
        const isFirefox = getRemoteFirefoxVersion(arguments[0]);
        const canSendMMS = getCanSendMaxMessageSize(isFirefox);
        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
        let maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }
        const sctp = {};
        Object.defineProperty(sctp, "maxMessageSize", {
          get() {
            return maxMessageSize;
          }
        });
        this._sctp = sctp;
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  }
  function shimSendThrowTypeError(window2) {
    if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
      return;
    }
    function wrapDcSend(dc, pc) {
      const origDataChannelSend = dc.send;
      dc.send = function send() {
        const data = arguments[0];
        const length = data.length || data.size || data.byteLength;
        if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
    window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
      const dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
    wrapPeerConnectionEvent(window2, "datachannel", (e2) => {
      wrapDcSend(e2.channel, e2.target);
      return e2;
    });
  }
  function shimConnectionState(window2) {
    if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
      return;
    }
    const proto = window2.RTCPeerConnection.prototype;
    Object.defineProperty(proto, "connectionState", {
      get() {
        return {
          completed: "connected",
          checking: "connecting"
        }[this.iceConnectionState] || this.iceConnectionState;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(proto, "onconnectionstatechange", {
      get() {
        return this._onconnectionstatechange || null;
      },
      set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
    ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
      const origMethod = proto[method];
      proto[method] = function() {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = (e2) => {
            const pc = e2.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              const newEvent = new Event("connectionstatechange", e2);
              pc.dispatchEvent(newEvent);
            }
            return e2;
          };
          this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
        }
        return origMethod.apply(this, arguments);
      };
    });
  }
  function removeExtmapAllowMixed(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (browserDetails2.browser === "chrome" && browserDetails2.version >= 71) {
      return;
    }
    if (browserDetails2.browser === "safari" && browserDetails2.version >= 605) {
      return;
    }
    const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
      if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
        const sdp2 = desc.sdp.split("\n").filter((line) => {
          return line.trim() !== "a=extmap-allow-mixed";
        }).join("\n");
        if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
          arguments[0] = new window2.RTCSessionDescription({
            type: desc.type,
            sdp: sdp2
          });
        } else {
          desc.sdp = sdp2;
        }
      }
      return nativeSRD.apply(this, arguments);
    };
  }
  function shimAddIceCandidateNullOrEmpty(window2, browserDetails2) {
    if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
      return;
    }
    window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      if ((browserDetails2.browser === "chrome" && browserDetails2.version < 78 || browserDetails2.browser === "firefox" && browserDetails2.version < 68 || browserDetails2.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
  function shimParameterlessSetLocalDescription(window2, browserDetails2) {
    if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
      return;
    }
    window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      let desc = arguments[0] || {};
      if (typeof desc !== "object" || desc.type && desc.sdp) {
        return nativeSetLocalDescription.apply(this, arguments);
      }
      desc = {
        type: desc.type,
        sdp: desc.sdp
      };
      if (!desc.type) {
        switch (this.signalingState) {
          case "stable":
          case "have-local-offer":
          case "have-remote-pranswer":
            desc.type = "offer";
            break;
          default:
            desc.type = "answer";
            break;
        }
      }
      if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
        return nativeSetLocalDescription.apply(this, [desc]);
      }
      const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
      return func.apply(this).then((d2) => nativeSetLocalDescription.apply(this, [d2]));
    };
  }
  var commonShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    removeExtmapAllowMixed,
    shimAddIceCandidateNullOrEmpty,
    shimConnectionState,
    shimMaxMessageSize,
    shimParameterlessSetLocalDescription,
    shimRTCIceCandidate,
    shimRTCIceCandidateRelayProtocol,
    shimSendThrowTypeError
  });
  function adapterFactory() {
    let {
      window: window2
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      shimChrome: true,
      shimFirefox: true,
      shimSafari: true
    };
    const logging2 = log;
    const browserDetails2 = detectBrowser(window2);
    const adapter = {
      browserDetails: browserDetails2,
      commonShim,
      extractVersion,
      disableLog,
      disableWarnings,
      // Expose sdp as a convenience. For production apps include directly.
      sdp
    };
    switch (browserDetails2.browser) {
      case "chrome":
        if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {
          logging2("Chrome shim is not included in this adapter release.");
          return adapter;
        }
        if (browserDetails2.version === null) {
          logging2("Chrome shim can not determine version, not shimming.");
          return adapter;
        }
        logging2("adapter.js shimming chrome.");
        adapter.browserShim = chromeShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimGetUserMedia$2(window2, browserDetails2);
        shimMediaStream(window2);
        shimPeerConnection$1(window2, browserDetails2);
        shimOnTrack$1(window2);
        shimAddTrackRemoveTrack(window2, browserDetails2);
        shimGetSendersWithDtmf(window2);
        shimSenderReceiverGetStats(window2);
        fixNegotiationNeeded(window2, browserDetails2);
        shimRTCIceCandidate(window2);
        shimRTCIceCandidateRelayProtocol(window2);
        shimConnectionState(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        removeExtmapAllowMixed(window2, browserDetails2);
        break;
      case "firefox":
        if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {
          logging2("Firefox shim is not included in this adapter release.");
          return adapter;
        }
        logging2("adapter.js shimming firefox.");
        adapter.browserShim = firefoxShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimGetUserMedia$1(window2, browserDetails2);
        shimPeerConnection(window2, browserDetails2);
        shimOnTrack(window2);
        shimRemoveStream(window2);
        shimSenderGetStats(window2);
        shimReceiverGetStats(window2);
        shimRTCDataChannel(window2);
        shimAddTransceiver(window2);
        shimGetParameters(window2);
        shimCreateOffer(window2);
        shimCreateAnswer(window2);
        shimRTCIceCandidate(window2);
        shimConnectionState(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        break;
      case "safari":
        if (!safariShim || !options.shimSafari) {
          logging2("Safari shim is not included in this adapter release.");
          return adapter;
        }
        logging2("adapter.js shimming safari.");
        adapter.browserShim = safariShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimRTCIceServerUrls(window2);
        shimCreateOfferLegacy(window2);
        shimCallbacksAPI(window2);
        shimLocalStreamsAPI(window2);
        shimRemoteStreamsAPI(window2);
        shimTrackEventTransceiver(window2);
        shimGetUserMedia(window2);
        shimAudioContext(window2);
        shimRTCIceCandidate(window2);
        shimRTCIceCandidateRelayProtocol(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        removeExtmapAllowMixed(window2, browserDetails2);
        break;
      default:
        logging2("Unsupported browser!");
        break;
    }
    return adapter;
  }
  adapterFactory({
    window: typeof window === "undefined" ? void 0 : window
  });
  const DECRYPTION_FAILURE_TOLERANCE = 10;
  const E2EE_FLAG = "lk_e2ee";
  const SALT = "LKFrameEncryptionKey";
  const KEY_PROVIDER_DEFAULTS = {
    sharedKey: false,
    ratchetSalt: SALT,
    ratchetWindowSize: 8,
    failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
    keyringSize: 16
  };
  var KeyProviderEvent;
  (function(KeyProviderEvent2) {
    KeyProviderEvent2["SetKey"] = "setKey";
    KeyProviderEvent2["RatchetRequest"] = "ratchetRequest";
    KeyProviderEvent2["KeyRatcheted"] = "keyRatcheted";
  })(KeyProviderEvent || (KeyProviderEvent = {}));
  var KeyHandlerEvent;
  (function(KeyHandlerEvent2) {
    KeyHandlerEvent2["KeyRatcheted"] = "keyRatcheted";
  })(KeyHandlerEvent || (KeyHandlerEvent = {}));
  var EncryptionEvent;
  (function(EncryptionEvent2) {
    EncryptionEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
    EncryptionEvent2["EncryptionError"] = "encryptionError";
  })(EncryptionEvent || (EncryptionEvent = {}));
  var CryptorEvent;
  (function(CryptorEvent2) {
    CryptorEvent2["Error"] = "cryptorError";
  })(CryptorEvent || (CryptorEvent = {}));
  function isE2EESupported() {
    return isInsertableStreamSupported() || isScriptTransformSupported();
  }
  function isScriptTransformSupported() {
    return typeof window.RTCRtpScriptTransform !== "undefined";
  }
  function isInsertableStreamSupported() {
    return typeof window.RTCRtpSender !== "undefined" && // @ts-ignore
    typeof window.RTCRtpSender.prototype.createEncodedStreams !== "undefined";
  }
  class BaseKeyProvider extends eventsExports.EventEmitter {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      super();
      this.onKeyRatcheted = (material, keyIndex) => {
        livekitLogger.debug("key ratcheted event received", {
          material,
          keyIndex
        });
      };
      this.keyInfoMap = /* @__PURE__ */ new Map();
      this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);
      this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
    }
    /**
     * callback to invoke once a key has been set for a participant
     * @param key
     * @param participantIdentity
     * @param keyIndex
     */
    onSetEncryptionKey(key, participantIdentity, keyIndex) {
      const keyInfo = {
        key,
        participantIdentity,
        keyIndex
      };
      if (!this.options.sharedKey && !participantIdentity) {
        throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
      }
      this.keyInfoMap.set("".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : "shared", "-").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);
      this.emit(KeyProviderEvent.SetKey, keyInfo);
    }
    getKeys() {
      return Array.from(this.keyInfoMap.values());
    }
    getOptions() {
      return this.options;
    }
    ratchetKey(participantIdentity, keyIndex) {
      this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);
    }
  }
  class LivekitError extends Error {
    constructor(code, message) {
      super(message || "an error has occured");
      this.name = "LiveKitError";
      this.code = code;
    }
  }
  var ConnectionErrorReason;
  (function(ConnectionErrorReason2) {
    ConnectionErrorReason2[ConnectionErrorReason2["NotAllowed"] = 0] = "NotAllowed";
    ConnectionErrorReason2[ConnectionErrorReason2["ServerUnreachable"] = 1] = "ServerUnreachable";
    ConnectionErrorReason2[ConnectionErrorReason2["InternalError"] = 2] = "InternalError";
    ConnectionErrorReason2[ConnectionErrorReason2["Cancelled"] = 3] = "Cancelled";
    ConnectionErrorReason2[ConnectionErrorReason2["LeaveRequest"] = 4] = "LeaveRequest";
  })(ConnectionErrorReason || (ConnectionErrorReason = {}));
  class ConnectionError extends LivekitError {
    constructor(message, reason, status, context) {
      super(1, message);
      this.name = "ConnectionError";
      this.status = status;
      this.reason = reason;
      this.context = context;
      this.reasonName = ConnectionErrorReason[reason];
    }
  }
  class DeviceUnsupportedError extends LivekitError {
    constructor(message) {
      super(21, message !== null && message !== void 0 ? message : "device is unsupported");
      this.name = "DeviceUnsupportedError";
    }
  }
  class TrackInvalidError extends LivekitError {
    constructor(message) {
      super(20, message !== null && message !== void 0 ? message : "track is invalid");
      this.name = "TrackInvalidError";
    }
  }
  class UnsupportedServer extends LivekitError {
    constructor(message) {
      super(10, message !== null && message !== void 0 ? message : "unsupported server");
      this.name = "UnsupportedServer";
    }
  }
  class UnexpectedConnectionState extends LivekitError {
    constructor(message) {
      super(12, message !== null && message !== void 0 ? message : "unexpected connection state");
      this.name = "UnexpectedConnectionState";
    }
  }
  class NegotiationError extends LivekitError {
    constructor(message) {
      super(13, message !== null && message !== void 0 ? message : "unable to negotiate");
      this.name = "NegotiationError";
    }
  }
  class SignalRequestError extends LivekitError {
    constructor(message, reason) {
      super(15, message);
      this.reason = reason;
      this.reasonName = typeof reason === "string" ? reason : RequestResponse_Reason[reason];
    }
  }
  var MediaDeviceFailure;
  (function(MediaDeviceFailure2) {
    MediaDeviceFailure2["PermissionDenied"] = "PermissionDenied";
    MediaDeviceFailure2["NotFound"] = "NotFound";
    MediaDeviceFailure2["DeviceInUse"] = "DeviceInUse";
    MediaDeviceFailure2["Other"] = "Other";
  })(MediaDeviceFailure || (MediaDeviceFailure = {}));
  (function(MediaDeviceFailure2) {
    function getFailure(error) {
      if (error && "name" in error) {
        if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          return MediaDeviceFailure2.NotFound;
        }
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
          return MediaDeviceFailure2.PermissionDenied;
        }
        if (error.name === "NotReadableError" || error.name === "TrackStartError") {
          return MediaDeviceFailure2.DeviceInUse;
        }
        return MediaDeviceFailure2.Other;
      }
    }
    MediaDeviceFailure2.getFailure = getFailure;
  })(MediaDeviceFailure || (MediaDeviceFailure = {}));
  var CryptorErrorReason;
  (function(CryptorErrorReason2) {
    CryptorErrorReason2[CryptorErrorReason2["InvalidKey"] = 0] = "InvalidKey";
    CryptorErrorReason2[CryptorErrorReason2["MissingKey"] = 1] = "MissingKey";
    CryptorErrorReason2[CryptorErrorReason2["InternalError"] = 2] = "InternalError";
  })(CryptorErrorReason || (CryptorErrorReason = {}));
  var RoomEvent;
  (function(RoomEvent2) {
    RoomEvent2["Connected"] = "connected";
    RoomEvent2["Reconnecting"] = "reconnecting";
    RoomEvent2["SignalReconnecting"] = "signalReconnecting";
    RoomEvent2["Reconnected"] = "reconnected";
    RoomEvent2["Disconnected"] = "disconnected";
    RoomEvent2["ConnectionStateChanged"] = "connectionStateChanged";
    RoomEvent2["MediaDevicesChanged"] = "mediaDevicesChanged";
    RoomEvent2["ParticipantConnected"] = "participantConnected";
    RoomEvent2["ParticipantDisconnected"] = "participantDisconnected";
    RoomEvent2["TrackPublished"] = "trackPublished";
    RoomEvent2["TrackSubscribed"] = "trackSubscribed";
    RoomEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    RoomEvent2["TrackUnpublished"] = "trackUnpublished";
    RoomEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
    RoomEvent2["TrackMuted"] = "trackMuted";
    RoomEvent2["TrackUnmuted"] = "trackUnmuted";
    RoomEvent2["LocalTrackPublished"] = "localTrackPublished";
    RoomEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    RoomEvent2["LocalAudioSilenceDetected"] = "localAudioSilenceDetected";
    RoomEvent2["ActiveSpeakersChanged"] = "activeSpeakersChanged";
    RoomEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
    RoomEvent2["ParticipantNameChanged"] = "participantNameChanged";
    RoomEvent2["ParticipantAttributesChanged"] = "participantAttributesChanged";
    RoomEvent2["RoomMetadataChanged"] = "roomMetadataChanged";
    RoomEvent2["DataReceived"] = "dataReceived";
    RoomEvent2["SipDTMFReceived"] = "sipDTMFReceived";
    RoomEvent2["TranscriptionReceived"] = "transcriptionReceived";
    RoomEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
    RoomEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
    RoomEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    RoomEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
    RoomEvent2["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";
    RoomEvent2["VideoPlaybackStatusChanged"] = "videoPlaybackChanged";
    RoomEvent2["MediaDevicesError"] = "mediaDevicesError";
    RoomEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
    RoomEvent2["SignalConnected"] = "signalConnected";
    RoomEvent2["RecordingStatusChanged"] = "recordingStatusChanged";
    RoomEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
    RoomEvent2["EncryptionError"] = "encryptionError";
    RoomEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
    RoomEvent2["ActiveDeviceChanged"] = "activeDeviceChanged";
    RoomEvent2["ChatMessage"] = "chatMessage";
    RoomEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    RoomEvent2["MetricsReceived"] = "metricsReceived";
  })(RoomEvent || (RoomEvent = {}));
  var ParticipantEvent;
  (function(ParticipantEvent2) {
    ParticipantEvent2["TrackPublished"] = "trackPublished";
    ParticipantEvent2["TrackSubscribed"] = "trackSubscribed";
    ParticipantEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    ParticipantEvent2["TrackUnpublished"] = "trackUnpublished";
    ParticipantEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
    ParticipantEvent2["TrackMuted"] = "trackMuted";
    ParticipantEvent2["TrackUnmuted"] = "trackUnmuted";
    ParticipantEvent2["LocalTrackPublished"] = "localTrackPublished";
    ParticipantEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    ParticipantEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
    ParticipantEvent2["ParticipantNameChanged"] = "participantNameChanged";
    ParticipantEvent2["DataReceived"] = "dataReceived";
    ParticipantEvent2["SipDTMFReceived"] = "sipDTMFReceived";
    ParticipantEvent2["TranscriptionReceived"] = "transcriptionReceived";
    ParticipantEvent2["IsSpeakingChanged"] = "isSpeakingChanged";
    ParticipantEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
    ParticipantEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
    ParticipantEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    ParticipantEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
    ParticipantEvent2["MediaDevicesError"] = "mediaDevicesError";
    ParticipantEvent2["AudioStreamAcquired"] = "audioStreamAcquired";
    ParticipantEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
    ParticipantEvent2["PCTrackAdded"] = "pcTrackAdded";
    ParticipantEvent2["AttributesChanged"] = "attributesChanged";
    ParticipantEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    ParticipantEvent2["ChatMessage"] = "chatMessage";
  })(ParticipantEvent || (ParticipantEvent = {}));
  var EngineEvent;
  (function(EngineEvent2) {
    EngineEvent2["TransportsCreated"] = "transportsCreated";
    EngineEvent2["Connected"] = "connected";
    EngineEvent2["Disconnected"] = "disconnected";
    EngineEvent2["Resuming"] = "resuming";
    EngineEvent2["Resumed"] = "resumed";
    EngineEvent2["Restarting"] = "restarting";
    EngineEvent2["Restarted"] = "restarted";
    EngineEvent2["SignalResumed"] = "signalResumed";
    EngineEvent2["SignalRestarted"] = "signalRestarted";
    EngineEvent2["Closing"] = "closing";
    EngineEvent2["MediaTrackAdded"] = "mediaTrackAdded";
    EngineEvent2["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";
    EngineEvent2["DataPacketReceived"] = "dataPacketReceived";
    EngineEvent2["RTPVideoMapUpdate"] = "rtpVideoMapUpdate";
    EngineEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
    EngineEvent2["ParticipantUpdate"] = "participantUpdate";
    EngineEvent2["RoomUpdate"] = "roomUpdate";
    EngineEvent2["SpeakersChanged"] = "speakersChanged";
    EngineEvent2["StreamStateChanged"] = "streamStateChanged";
    EngineEvent2["ConnectionQualityUpdate"] = "connectionQualityUpdate";
    EngineEvent2["SubscriptionError"] = "subscriptionError";
    EngineEvent2["SubscriptionPermissionUpdate"] = "subscriptionPermissionUpdate";
    EngineEvent2["RemoteMute"] = "remoteMute";
    EngineEvent2["SubscribedQualityUpdate"] = "subscribedQualityUpdate";
    EngineEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    EngineEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    EngineEvent2["Offline"] = "offline";
    EngineEvent2["SignalRequestResponse"] = "signalRequestResponse";
  })(EngineEvent || (EngineEvent = {}));
  var TrackEvent;
  (function(TrackEvent2) {
    TrackEvent2["Message"] = "message";
    TrackEvent2["Muted"] = "muted";
    TrackEvent2["Unmuted"] = "unmuted";
    TrackEvent2["Restarted"] = "restarted";
    TrackEvent2["Ended"] = "ended";
    TrackEvent2["Subscribed"] = "subscribed";
    TrackEvent2["Unsubscribed"] = "unsubscribed";
    TrackEvent2["UpdateSettings"] = "updateSettings";
    TrackEvent2["UpdateSubscription"] = "updateSubscription";
    TrackEvent2["AudioPlaybackStarted"] = "audioPlaybackStarted";
    TrackEvent2["AudioPlaybackFailed"] = "audioPlaybackFailed";
    TrackEvent2["AudioSilenceDetected"] = "audioSilenceDetected";
    TrackEvent2["VisibilityChanged"] = "visibilityChanged";
    TrackEvent2["VideoDimensionsChanged"] = "videoDimensionsChanged";
    TrackEvent2["VideoPlaybackStarted"] = "videoPlaybackStarted";
    TrackEvent2["VideoPlaybackFailed"] = "videoPlaybackFailed";
    TrackEvent2["ElementAttached"] = "elementAttached";
    TrackEvent2["ElementDetached"] = "elementDetached";
    TrackEvent2["UpstreamPaused"] = "upstreamPaused";
    TrackEvent2["UpstreamResumed"] = "upstreamResumed";
    TrackEvent2["SubscriptionPermissionChanged"] = "subscriptionPermissionChanged";
    TrackEvent2["SubscriptionStatusChanged"] = "subscriptionStatusChanged";
    TrackEvent2["SubscriptionFailed"] = "subscriptionFailed";
    TrackEvent2["TrackProcessorUpdate"] = "trackProcessorUpdate";
    TrackEvent2["AudioTrackFeatureUpdate"] = "audioTrackFeatureUpdate";
    TrackEvent2["TranscriptionReceived"] = "transcriptionReceived";
    TrackEvent2["TimeSyncUpdate"] = "timeSyncUpdate";
  })(TrackEvent || (TrackEvent = {}));
  function cloneDeep(value) {
    if (typeof value === "undefined") {
      return;
    }
    if (typeof structuredClone === "function") {
      return structuredClone(value);
    } else {
      return JSON.parse(JSON.stringify(value));
    }
  }
  const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
  let browserDetails;
  function getBrowser(userAgent) {
    let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (typeof userAgent === "undefined" && typeof navigator === "undefined") {
      return;
    }
    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();
    if (browserDetails === void 0 || force) {
      const browser = browsersList.find((_ref) => {
        let {
          test
        } = _ref;
        return test.test(ua);
      });
      browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);
    }
    return browserDetails;
  }
  const browsersList = [
    {
      test: /firefox|iceweasel|fxios/i,
      describe(ua) {
        const browser = {
          name: "Firefox",
          version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua),
          os: ua.toLowerCase().includes("fxios") ? "iOS" : void 0,
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    },
    {
      test: /chrom|crios|crmo/i,
      describe(ua) {
        const browser = {
          name: "Chrome",
          version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua),
          os: ua.toLowerCase().includes("crios") ? "iOS" : void 0,
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    },
    /* Safari */
    {
      test: /safari|applewebkit/i,
      describe(ua) {
        const browser = {
          name: "Safari",
          version: getMatch(commonVersionIdentifier, ua),
          os: ua.includes("mobile/") ? "iOS" : "macOS",
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    }
  ];
  function getMatch(exp, ua) {
    let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const match = ua.match(exp);
    return match && match.length >= id && match[id] || "";
  }
  function getOSVersion(ua) {
    return ua.includes("mac os") ? getMatch(/\(.+?(\d+_\d+(:?_\d+)?)/, ua, 1).replace(/_/g, ".") : void 0;
  }
  var version$1 = "2.9.1";
  const version = version$1;
  const protocolVersion = 15;
  class CriticalTimers {
  }
  CriticalTimers.setTimeout = function() {
    return setTimeout(...arguments);
  };
  CriticalTimers.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval
  function() {
    return setInterval(...arguments);
  };
  CriticalTimers.clearTimeout = function() {
    return clearTimeout(...arguments);
  };
  CriticalTimers.clearInterval = function() {
    return clearInterval(...arguments);
  };
  const BACKGROUND_REACTION_DELAY = 5e3;
  const recycledElements = [];
  var VideoQuality;
  (function(VideoQuality2) {
    VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
    VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
    VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
  })(VideoQuality || (VideoQuality = {}));
  class Track extends eventsExports.EventEmitter {
    constructor(mediaTrack, kind) {
      let loggerOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _a;
      super();
      this.attachedElements = [];
      this.isMuted = false;
      this.streamState = Track.StreamState.Active;
      this.isInBackground = false;
      this._currentBitrate = 0;
      this.log = livekitLogger;
      this.appVisibilityChangedListener = () => {
        if (this.backgroundTimeout) {
          clearTimeout(this.backgroundTimeout);
        }
        if (document.visibilityState === "hidden") {
          this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);
        } else {
          this.handleAppVisibilityChanged();
        }
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);
      this.loggerContextCb = loggerOptions.loggerContextCb;
      this.setMaxListeners(100);
      this.kind = kind;
      this._mediaStreamTrack = mediaTrack;
      this._mediaStreamID = mediaTrack.id;
      this.source = Track.Source.Unknown;
    }
    get logContext() {
      var _a;
      return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));
    }
    /** current receive bits per second */
    get currentBitrate() {
      return this._currentBitrate;
    }
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    /**
     * @internal
     * used for keep mediaStream's first id, since it's id might change
     * if we disable/enable a track
     */
    get mediaStreamID() {
      return this._mediaStreamID;
    }
    attach(element) {
      let elementType = "audio";
      if (this.kind === Track.Kind.Video) {
        elementType = "video";
      }
      if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {
        this.addAppVisibilityListener();
      }
      if (!element) {
        if (elementType === "audio") {
          recycledElements.forEach((e2) => {
            if (e2.parentElement === null && !element) {
              element = e2;
            }
          });
          if (element) {
            recycledElements.splice(recycledElements.indexOf(element), 1);
          }
        }
        if (!element) {
          element = document.createElement(elementType);
        }
      }
      if (!this.attachedElements.includes(element)) {
        this.attachedElements.push(element);
      }
      attachToElement(this.mediaStreamTrack, element);
      const allMediaStreamTracks = element.srcObject.getTracks();
      const hasAudio = allMediaStreamTracks.some((tr) => tr.kind === "audio");
      element.play().then(() => {
        this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
      }).catch((e2) => {
        if (e2.name === "NotAllowedError") {
          this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e2);
        } else if (e2.name === "AbortError") {
          livekitLogger.debug("".concat(hasAudio ? "audio" : "video", " playback aborted, likely due to new play request"));
        } else {
          livekitLogger.warn("could not playback ".concat(hasAudio ? "audio" : "video"), e2);
        }
        if (hasAudio && element && allMediaStreamTracks.some((tr) => tr.kind === "video") && e2.name === "NotAllowedError") {
          element.muted = true;
          element.play().catch(() => {
          });
        }
      });
      this.emit(TrackEvent.ElementAttached, element);
      return element;
    }
    detach(element) {
      try {
        if (element) {
          detachTrack(this.mediaStreamTrack, element);
          const idx = this.attachedElements.indexOf(element);
          if (idx >= 0) {
            this.attachedElements.splice(idx, 1);
            this.recycleElement(element);
            this.emit(TrackEvent.ElementDetached, element);
          }
          return element;
        }
        const detached = [];
        this.attachedElements.forEach((elm) => {
          detachTrack(this.mediaStreamTrack, elm);
          detached.push(elm);
          this.recycleElement(elm);
          this.emit(TrackEvent.ElementDetached, elm);
        });
        this.attachedElements = [];
        return detached;
      } finally {
        if (this.attachedElements.length === 0) {
          this.removeAppVisibilityListener();
        }
      }
    }
    stop() {
      this.stopMonitor();
      this._mediaStreamTrack.stop();
    }
    enable() {
      this._mediaStreamTrack.enabled = true;
    }
    disable() {
      this._mediaStreamTrack.enabled = false;
    }
    /* @internal */
    stopMonitor() {
      if (this.monitorInterval) {
        clearInterval(this.monitorInterval);
      }
      if (this.timeSyncHandle) {
        cancelAnimationFrame(this.timeSyncHandle);
      }
    }
    /** @internal */
    updateLoggerOptions(loggerOptions) {
      if (loggerOptions.loggerName) {
        this.log = getLogger(loggerOptions.loggerName);
      }
      if (loggerOptions.loggerContextCb) {
        this.loggerContextCb = loggerOptions.loggerContextCb;
      }
    }
    recycleElement(element) {
      if (element instanceof HTMLAudioElement) {
        let shouldCache = true;
        element.pause();
        recycledElements.forEach((e2) => {
          if (!e2.parentElement) {
            shouldCache = false;
          }
        });
        if (shouldCache) {
          recycledElements.push(element);
        }
      }
    }
    handleAppVisibilityChanged() {
      return __awaiter(this, void 0, void 0, function* () {
        this.isInBackground = document.visibilityState === "hidden";
        if (!this.isInBackground && this.kind === Track.Kind.Video) {
          setTimeout(() => this.attachedElements.forEach((el) => el.play().catch(() => {
          })), 0);
        }
      });
    }
    addAppVisibilityListener() {
      if (isWeb()) {
        this.isInBackground = document.visibilityState === "hidden";
        document.addEventListener("visibilitychange", this.appVisibilityChangedListener);
      } else {
        this.isInBackground = false;
      }
    }
    removeAppVisibilityListener() {
      if (isWeb()) {
        document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
      }
    }
  }
  function attachToElement(track, element) {
    let mediaStream;
    if (element.srcObject instanceof MediaStream) {
      mediaStream = element.srcObject;
    } else {
      mediaStream = new MediaStream();
    }
    let existingTracks;
    if (track.kind === "audio") {
      existingTracks = mediaStream.getAudioTracks();
    } else {
      existingTracks = mediaStream.getVideoTracks();
    }
    if (!existingTracks.includes(track)) {
      existingTracks.forEach((et2) => {
        mediaStream.removeTrack(et2);
      });
      mediaStream.addTrack(track);
    }
    if (!isSafari() || !(element instanceof HTMLVideoElement)) {
      element.autoplay = true;
    }
    element.muted = mediaStream.getAudioTracks().length === 0;
    if (element instanceof HTMLVideoElement) {
      element.playsInline = true;
    }
    if (element.srcObject !== mediaStream) {
      element.srcObject = mediaStream;
      if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {
        setTimeout(() => {
          element.srcObject = mediaStream;
          element.play().catch(() => {
          });
        }, 0);
      }
    }
  }
  function detachTrack(track, element) {
    if (element.srcObject instanceof MediaStream) {
      const mediaStream = element.srcObject;
      mediaStream.removeTrack(track);
      if (mediaStream.getTracks().length > 0) {
        element.srcObject = mediaStream;
      } else {
        element.srcObject = null;
      }
    }
  }
  (function(Track2) {
    let Kind;
    (function(Kind2) {
      Kind2["Audio"] = "audio";
      Kind2["Video"] = "video";
      Kind2["Unknown"] = "unknown";
    })(Kind = Track2.Kind || (Track2.Kind = {}));
    let Source;
    (function(Source2) {
      Source2["Camera"] = "camera";
      Source2["Microphone"] = "microphone";
      Source2["ScreenShare"] = "screen_share";
      Source2["ScreenShareAudio"] = "screen_share_audio";
      Source2["Unknown"] = "unknown";
    })(Source = Track2.Source || (Track2.Source = {}));
    let StreamState$1;
    (function(StreamState2) {
      StreamState2["Active"] = "active";
      StreamState2["Paused"] = "paused";
      StreamState2["Unknown"] = "unknown";
    })(StreamState$1 = Track2.StreamState || (Track2.StreamState = {}));
    function kindToProto(k) {
      switch (k) {
        case Kind.Audio:
          return TrackType.AUDIO;
        case Kind.Video:
          return TrackType.VIDEO;
        default:
          return TrackType.DATA;
      }
    }
    Track2.kindToProto = kindToProto;
    function kindFromProto(t2) {
      switch (t2) {
        case TrackType.AUDIO:
          return Kind.Audio;
        case TrackType.VIDEO:
          return Kind.Video;
        default:
          return Kind.Unknown;
      }
    }
    Track2.kindFromProto = kindFromProto;
    function sourceToProto(s2) {
      switch (s2) {
        case Source.Camera:
          return TrackSource.CAMERA;
        case Source.Microphone:
          return TrackSource.MICROPHONE;
        case Source.ScreenShare:
          return TrackSource.SCREEN_SHARE;
        case Source.ScreenShareAudio:
          return TrackSource.SCREEN_SHARE_AUDIO;
        default:
          return TrackSource.UNKNOWN;
      }
    }
    Track2.sourceToProto = sourceToProto;
    function sourceFromProto(s2) {
      switch (s2) {
        case TrackSource.CAMERA:
          return Source.Camera;
        case TrackSource.MICROPHONE:
          return Source.Microphone;
        case TrackSource.SCREEN_SHARE:
          return Source.ScreenShare;
        case TrackSource.SCREEN_SHARE_AUDIO:
          return Source.ScreenShareAudio;
        default:
          return Source.Unknown;
      }
    }
    Track2.sourceFromProto = sourceFromProto;
    function streamStateFromProto(s2) {
      switch (s2) {
        case StreamState.ACTIVE:
          return StreamState$1.Active;
        case StreamState.PAUSED:
          return StreamState$1.Paused;
        default:
          return StreamState$1.Unknown;
      }
    }
    Track2.streamStateFromProto = streamStateFromProto;
  })(Track);
  class VideoPreset {
    constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {
      if (typeof widthOrOptions === "object") {
        this.width = widthOrOptions.width;
        this.height = widthOrOptions.height;
        this.aspectRatio = widthOrOptions.aspectRatio;
        this.encoding = {
          maxBitrate: widthOrOptions.maxBitrate,
          maxFramerate: widthOrOptions.maxFramerate,
          priority: widthOrOptions.priority
        };
      } else if (height !== void 0 && maxBitrate !== void 0) {
        this.width = widthOrOptions;
        this.height = height;
        this.aspectRatio = widthOrOptions / height;
        this.encoding = {
          maxBitrate,
          maxFramerate,
          priority
        };
      } else {
        throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
      }
    }
    get resolution() {
      return {
        width: this.width,
        height: this.height,
        frameRate: this.encoding.maxFramerate,
        aspectRatio: this.aspectRatio
      };
    }
  }
  const backupCodecs = ["vp8", "h264"];
  const videoCodecs = ["vp8", "h264", "vp9", "av1"];
  function isBackupCodec(codec) {
    return !!backupCodecs.find((backup) => backup === codec);
  }
  var BackupCodecPolicy;
  (function(BackupCodecPolicy2) {
    BackupCodecPolicy2[BackupCodecPolicy2["REGRESSION"] = 0] = "REGRESSION";
    BackupCodecPolicy2[BackupCodecPolicy2["SIMULCAST"] = 1] = "SIMULCAST";
  })(BackupCodecPolicy || (BackupCodecPolicy = {}));
  var AudioPresets;
  (function(AudioPresets2) {
    AudioPresets2.telephone = {
      maxBitrate: 12e3
    };
    AudioPresets2.speech = {
      maxBitrate: 24e3
    };
    AudioPresets2.music = {
      maxBitrate: 48e3
    };
    AudioPresets2.musicStereo = {
      maxBitrate: 64e3
    };
    AudioPresets2.musicHighQuality = {
      maxBitrate: 96e3
    };
    AudioPresets2.musicHighQualityStereo = {
      maxBitrate: 128e3
    };
  })(AudioPresets || (AudioPresets = {}));
  const VideoPresets = {
    h90: new VideoPreset(160, 90, 9e4, 20),
    h180: new VideoPreset(320, 180, 16e4, 20),
    h216: new VideoPreset(384, 216, 18e4, 20),
    h360: new VideoPreset(640, 360, 45e4, 20),
    h540: new VideoPreset(960, 540, 8e5, 25),
    h720: new VideoPreset(1280, 720, 17e5, 30),
    h1080: new VideoPreset(1920, 1080, 3e6, 30),
    h1440: new VideoPreset(2560, 1440, 5e6, 30),
    h2160: new VideoPreset(3840, 2160, 8e6, 30)
  };
  const VideoPresets43 = {
    h120: new VideoPreset(160, 120, 7e4, 20),
    h180: new VideoPreset(240, 180, 125e3, 20),
    h240: new VideoPreset(320, 240, 14e4, 20),
    h360: new VideoPreset(480, 360, 33e4, 20),
    h480: new VideoPreset(640, 480, 5e5, 20),
    h540: new VideoPreset(720, 540, 6e5, 25),
    h720: new VideoPreset(960, 720, 13e5, 30),
    h1080: new VideoPreset(1440, 1080, 23e5, 30),
    h1440: new VideoPreset(1920, 1440, 38e5, 30)
  };
  const ScreenSharePresets = {
    h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
    h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
    h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
    h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
    h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
    h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
    h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
    // original resolution, without resizing
    original: new VideoPreset(0, 0, 7e6, 30, "medium")
  };
  const separator = "|";
  const ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
  function unpackStreamId(packed) {
    const parts = packed.split(separator);
    if (parts.length > 1) {
      return [parts[0], packed.substr(parts[0].length + 1)];
    }
    return [packed, ""];
  }
  function sleep(duration) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve) => CriticalTimers.setTimeout(resolve, duration));
    });
  }
  function supportsTransceiver() {
    return "addTransceiver" in RTCPeerConnection.prototype;
  }
  function supportsAddTrack() {
    return "addTrack" in RTCPeerConnection.prototype;
  }
  function supportsAV1() {
    if (!("getCapabilities" in RTCRtpSender)) {
      return false;
    }
    if (isSafari()) {
      return false;
    }
    const capabilities = RTCRtpSender.getCapabilities("video");
    let hasAV1 = false;
    if (capabilities) {
      for (const codec of capabilities.codecs) {
        if (codec.mimeType === "video/AV1") {
          hasAV1 = true;
          break;
        }
      }
    }
    return hasAV1;
  }
  function supportsVP9() {
    if (!("getCapabilities" in RTCRtpSender)) {
      return false;
    }
    if (isFireFox()) {
      return false;
    }
    if (isSafari()) {
      const browser = getBrowser();
      if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, "16") < 0) {
        return false;
      }
    }
    const capabilities = RTCRtpSender.getCapabilities("video");
    let hasVP9 = false;
    if (capabilities) {
      for (const codec of capabilities.codecs) {
        if (codec.mimeType === "video/VP9") {
          hasVP9 = true;
          break;
        }
      }
    }
    return hasVP9;
  }
  function isSVCCodec(codec) {
    return codec === "av1" || codec === "vp9";
  }
  function supportsSetSinkId(elm) {
    if (!document) {
      return false;
    }
    if (!elm) {
      elm = document.createElement("audio");
    }
    return "setSinkId" in elm;
  }
  function isBrowserSupported() {
    if (typeof RTCPeerConnection === "undefined") {
      return false;
    }
    return supportsTransceiver() || supportsAddTrack();
  }
  function isFireFox() {
    var _a;
    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Firefox";
  }
  function isSafari() {
    var _a;
    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Safari";
  }
  function isSafari17() {
    const b2 = getBrowser();
    return (b2 === null || b2 === void 0 ? void 0 : b2.name) === "Safari" && b2.version.startsWith("17.");
  }
  function isMobile() {
    var _a, _b;
    if (!isWeb())
      return false;
    return (
      // @ts-expect-error `userAgentData` is not yet part of typescript
      (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
    );
  }
  function isE2EESimulcastSupported() {
    const browser = getBrowser();
    const supportedSafariVersion = "17.2";
    if (browser) {
      if (browser.name !== "Safari" && browser.os !== "iOS") {
        return true;
      } else if (browser.os === "iOS" && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {
        return true;
      } else if (browser.name === "Safari" && compareVersions(supportedSafariVersion, browser.version) >= 0) {
        return true;
      } else {
        return false;
      }
    }
  }
  function isWeb() {
    return typeof document !== "undefined";
  }
  function isReactNative() {
    return navigator.product == "ReactNative";
  }
  function isCloud(serverUrl) {
    return serverUrl.hostname.endsWith(".livekit.cloud") || serverUrl.hostname.endsWith(".livekit.run");
  }
  function getLKReactNativeInfo() {
    if (global && global.LiveKitReactNativeGlobal) {
      return global.LiveKitReactNativeGlobal;
    }
    return void 0;
  }
  function getReactNativeOs() {
    if (!isReactNative()) {
      return void 0;
    }
    let info = getLKReactNativeInfo();
    if (info) {
      return info.platform;
    }
    return void 0;
  }
  function getDevicePixelRatio() {
    if (isWeb()) {
      return window.devicePixelRatio;
    }
    if (isReactNative()) {
      let info = getLKReactNativeInfo();
      if (info) {
        return info.devicePixelRatio;
      }
    }
    return 1;
  }
  function compareVersions(v1, v2) {
    const parts1 = v1.split(".");
    const parts2 = v2.split(".");
    const k = Math.min(parts1.length, parts2.length);
    for (let i2 = 0; i2 < k; ++i2) {
      const p1 = parseInt(parts1[i2], 10);
      const p2 = parseInt(parts2[i2], 10);
      if (p1 > p2)
        return 1;
      if (p1 < p2)
        return -1;
      if (i2 === k - 1 && p1 === p2)
        return 0;
    }
    if (v1 === "" && v2 !== "") {
      return -1;
    } else if (v2 === "") {
      return 1;
    }
    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;
  }
  function roDispatchCallback(entries) {
    for (const entry of entries) {
      entry.target.handleResize(entry);
    }
  }
  function ioDispatchCallback(entries) {
    for (const entry of entries) {
      entry.target.handleVisibilityChanged(entry);
    }
  }
  let resizeObserver = null;
  const getResizeObserver = () => {
    if (!resizeObserver)
      resizeObserver = new ResizeObserver(roDispatchCallback);
    return resizeObserver;
  };
  let intersectionObserver = null;
  const getIntersectionObserver = () => {
    if (!intersectionObserver) {
      intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
        root: null,
        rootMargin: "0px"
      });
    }
    return intersectionObserver;
  };
  function getClientInfo() {
    var _a;
    const info = new ClientInfo({
      sdk: ClientInfo_SDK.JS,
      protocol: protocolVersion,
      version
    });
    if (isReactNative()) {
      info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : "";
    }
    return info;
  }
  function createDummyVideoStreamTrack() {
    let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
    let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;
    let enabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let paintContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (paintContent && ctx) {
      ctx.beginPath();
      ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fillStyle = "grey";
      ctx.fill();
    }
    const dummyStream = canvas.captureStream();
    const [dummyTrack] = dummyStream.getTracks();
    if (!dummyTrack) {
      throw Error("Could not get empty media stream video track");
    }
    dummyTrack.enabled = enabled;
    return dummyTrack;
  }
  let emptyAudioStreamTrack;
  function getEmptyAudioStreamTrack() {
    if (!emptyAudioStreamTrack) {
      const ctx = new AudioContext();
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, 0);
      const dst = ctx.createMediaStreamDestination();
      oscillator.connect(gain);
      gain.connect(dst);
      oscillator.start();
      [emptyAudioStreamTrack] = dst.stream.getAudioTracks();
      if (!emptyAudioStreamTrack) {
        throw Error("Could not get empty media stream audio track");
      }
      emptyAudioStreamTrack.enabled = false;
    }
    return emptyAudioStreamTrack.clone();
  }
  class Future {
    constructor(futureBase, onFinally) {
      this.onFinally = onFinally;
      this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        this.resolve = resolve;
        this.reject = reject;
        if (futureBase) {
          yield futureBase(resolve, reject);
        }
      })).finally(() => {
        var _a;
        return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
  }
  function isVideoCodec(maybeCodec) {
    return videoCodecs.includes(maybeCodec);
  }
  function unwrapConstraint(constraint) {
    if (typeof constraint === "string" || typeof constraint === "number") {
      return constraint;
    }
    if (Array.isArray(constraint)) {
      return constraint[0];
    }
    if (constraint.exact) {
      if (Array.isArray(constraint.exact)) {
        return constraint.exact[0];
      }
      return constraint.exact;
    }
    if (constraint.ideal) {
      if (Array.isArray(constraint.ideal)) {
        return constraint.ideal[0];
      }
      return constraint.ideal;
    }
    throw Error("could not unwrap constraint");
  }
  function toWebsocketUrl(url) {
    if (url.startsWith("http")) {
      return url.replace(/^(http)/, "ws");
    }
    return url;
  }
  function toHttpUrl(url) {
    if (url.startsWith("ws")) {
      return url.replace(/^(ws)/, "http");
    }
    return url;
  }
  function extractTranscriptionSegments(transcription, firstReceivedTimesMap) {
    return transcription.segments.map((_ref) => {
      let {
        id,
        text,
        language,
        startTime,
        endTime,
        final
      } = _ref;
      var _a;
      const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();
      const lastReceivedTime = Date.now();
      if (final) {
        firstReceivedTimesMap.delete(id);
      } else {
        firstReceivedTimesMap.set(id, firstReceivedTime);
      }
      return {
        id,
        text,
        startTime: Number.parseInt(startTime.toString()),
        endTime: Number.parseInt(endTime.toString()),
        final,
        language,
        firstReceivedTime,
        lastReceivedTime
      };
    });
  }
  function extractChatMessage(msg) {
    const {
      id,
      timestamp,
      message,
      editTimestamp
    } = msg;
    return {
      id,
      timestamp: Number.parseInt(timestamp.toString()),
      editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : void 0,
      message
    };
  }
  function getDisconnectReasonFromConnectionError(e2) {
    switch (e2.reason) {
      case ConnectionErrorReason.LeaveRequest:
        return e2.context;
      case ConnectionErrorReason.Cancelled:
        return DisconnectReason.CLIENT_INITIATED;
      case ConnectionErrorReason.NotAllowed:
        return DisconnectReason.USER_REJECTED;
      case ConnectionErrorReason.ServerUnreachable:
        return DisconnectReason.JOIN_FAILURE;
      default:
        return DisconnectReason.UNKNOWN_REASON;
    }
  }
  function bigIntToNumber(value) {
    return value !== void 0 ? Number(value) : void 0;
  }
  function numberToBigInt(value) {
    return value !== void 0 ? BigInt(value) : void 0;
  }
  function isLocalTrack(track) {
    return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;
  }
  function isAudioTrack(track) {
    return !!track && track.kind == Track.Kind.Audio;
  }
  function isVideoTrack(track) {
    return !!track && track.kind == Track.Kind.Video;
  }
  function isLocalVideoTrack(track) {
    return isLocalTrack(track) && isVideoTrack(track);
  }
  function isLocalAudioTrack(track) {
    return isLocalTrack(track) && isAudioTrack(track);
  }
  function isRemoteTrack(track) {
    return !!track && !track.isLocal;
  }
  function isRemotePub(pub) {
    return !!pub && !pub.isLocal;
  }
  function isRemoteVideoTrack(track) {
    return isRemoteTrack(track) && isVideoTrack(track);
  }
  function isLocalParticipant(p2) {
    return p2.isLocal;
  }
  function mergeDefaultOptions(options, audioDefaults2, videoDefaults2) {
    var _a, _b, _c;
    var _d, _e2;
    const {
      optionsWithoutProcessor,
      audioProcessor,
      videoProcessor
    } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});
    const clonedOptions = (_a = cloneDeep(optionsWithoutProcessor)) !== null && _a !== void 0 ? _a : {};
    if (clonedOptions.audio === true)
      clonedOptions.audio = {};
    if (clonedOptions.video === true)
      clonedOptions.video = {};
    if (clonedOptions.audio) {
      mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults2);
      (_b = (_d = clonedOptions.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = "default";
      if (audioProcessor) {
        clonedOptions.audio.processor = audioProcessor;
      }
    }
    if (clonedOptions.video) {
      mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults2);
      (_c = (_e2 = clonedOptions.video).deviceId) !== null && _c !== void 0 ? _c : _e2.deviceId = "default";
      if (videoProcessor) {
        clonedOptions.video.processor = videoProcessor;
      }
    }
    return clonedOptions;
  }
  function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
    Object.keys(objectToMerge).forEach((key) => {
      if (mainObject[key] === void 0)
        mainObject[key] = objectToMerge[key];
    });
    return mainObject;
  }
  function constraintsForOptions(options) {
    var _a, _b;
    var _c, _d;
    const constraints = {};
    if (options.video) {
      if (typeof options.video === "object") {
        const videoOptions = {};
        const target = videoOptions;
        const source = options.video;
        Object.keys(source).forEach((key) => {
          switch (key) {
            case "resolution":
              mergeObjectWithoutOverwriting(target, source.resolution);
              break;
            default:
              target[key] = source[key];
          }
        });
        constraints.video = videoOptions;
        (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = "default";
      } else {
        constraints.video = options.video ? {
          deviceId: "default"
        } : false;
      }
    } else {
      constraints.video = false;
    }
    if (options.audio) {
      if (typeof options.audio === "object") {
        constraints.audio = options.audio;
        (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = "default";
      } else {
        constraints.audio = {
          deviceId: "default"
        };
      }
    } else {
      constraints.audio = false;
    }
    return constraints;
  }
  function detectSilence(track_1) {
    return __awaiter(this, arguments, void 0, function(track) {
      let timeOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
      return function* () {
        const ctx = getNewAudioContext();
        if (ctx) {
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 2048;
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));
          source.connect(analyser);
          yield sleep(timeOffset);
          analyser.getByteTimeDomainData(dataArray);
          const someNoise = dataArray.some((sample) => sample !== 128 && sample !== 0);
          ctx.close();
          return !someNoise;
        }
        return false;
      }();
    });
  }
  function getNewAudioContext() {
    const AudioContext2 = (
      // @ts-ignore
      typeof window !== "undefined" && (window.AudioContext || window.webkitAudioContext)
    );
    if (AudioContext2) {
      return new AudioContext2({
        latencyHint: "interactive"
      });
    }
  }
  function sourceToKind(source) {
    if (source === Track.Source.Microphone) {
      return "audioinput";
    } else if (source === Track.Source.Camera) {
      return "videoinput";
    } else {
      return void 0;
    }
  }
  function screenCaptureToDisplayMediaStreamOptions(options) {
    var _a, _b;
    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;
    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {
      videoConstraints = typeof videoConstraints === "boolean" ? {} : videoConstraints;
      if (isSafari()) {
        videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
          width: {
            max: options.resolution.width
          },
          height: {
            max: options.resolution.height
          },
          frameRate: options.resolution.frameRate
        });
      } else {
        videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
          width: {
            ideal: options.resolution.width
          },
          height: {
            ideal: options.resolution.height
          },
          frameRate: options.resolution.frameRate
        });
      }
    }
    return {
      audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,
      video: videoConstraints,
      // @ts-expect-error support for experimental display media features
      controller: options.controller,
      selfBrowserSurface: options.selfBrowserSurface,
      surfaceSwitching: options.surfaceSwitching,
      systemAudio: options.systemAudio,
      preferCurrentTab: options.preferCurrentTab
    };
  }
  function mimeTypeToVideoCodecString(mimeType) {
    return mimeType.split("/")[1].toLowerCase();
  }
  function getTrackPublicationInfo(tracks) {
    const infos = [];
    tracks.forEach((track) => {
      if (track.track !== void 0) {
        infos.push(new TrackPublishedResponse({
          cid: track.track.mediaStreamID,
          track: track.trackInfo
        }));
      }
    });
    return infos;
  }
  function getLogContextFromTrack(track) {
    if ("mediaStreamTrack" in track) {
      return {
        trackID: track.sid,
        source: track.source,
        muted: track.isMuted,
        enabled: track.mediaStreamTrack.enabled,
        kind: track.kind,
        streamID: track.mediaStreamID,
        streamTrackID: track.mediaStreamTrack.id
      };
    } else {
      return {
        trackID: track.trackSid,
        enabled: track.isEnabled,
        muted: track.isMuted,
        trackInfo: Object.assign({
          mimeType: track.mimeType,
          name: track.trackName,
          encrypted: track.isEncrypted,
          kind: track.kind,
          source: track.source
        }, track.track ? getLogContextFromTrack(track.track) : {})
      };
    }
  }
  function supportsSynchronizationSources() {
    return typeof RTCRtpReceiver !== "undefined" && "getSynchronizationSources" in RTCRtpReceiver;
  }
  function diffAttributes(oldValues, newValues) {
    var _a;
    if (oldValues === void 0) {
      oldValues = {};
    }
    if (newValues === void 0) {
      newValues = {};
    }
    const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];
    const diff = {};
    for (const key of allKeys) {
      if (oldValues[key] !== newValues[key]) {
        diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : "";
      }
    }
    return diff;
  }
  function extractProcessorsFromOptions(options) {
    const newOptions = Object.assign({}, options);
    let audioProcessor;
    let videoProcessor;
    if (typeof newOptions.audio === "object" && newOptions.audio.processor) {
      audioProcessor = newOptions.audio.processor;
      newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {
        processor: void 0
      });
    }
    if (typeof newOptions.video === "object" && newOptions.video.processor) {
      videoProcessor = newOptions.video.processor;
      newOptions.video = Object.assign(Object.assign({}, newOptions.video), {
        processor: void 0
      });
    }
    return {
      audioProcessor,
      videoProcessor,
      optionsWithoutProcessor: newOptions
    };
  }
  class E2EEManager extends eventsExports.EventEmitter {
    constructor(options) {
      super();
      this.onWorkerMessage = (ev) => {
        var _a, _b;
        const {
          kind,
          data
        } = ev.data;
        switch (kind) {
          case "error":
            livekitLogger.error(data.error.message);
            this.emit(EncryptionEvent.EncryptionError, data.error);
            break;
          case "initAck":
            if (data.enabled) {
              this.keyProvider.getKeys().forEach((keyInfo) => {
                this.postKey(keyInfo);
              });
            }
            break;
          case "enable":
            if (data.enabled) {
              this.keyProvider.getKeys().forEach((keyInfo) => {
                this.postKey(keyInfo);
              });
            }
            if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
              this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);
              this.encryptionEnabled = data.enabled;
            } else if (data.participantIdentity) {
              const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);
              if (!participant) {
                throw TypeError("couldn't set encryption status, participant not found".concat(data.participantIdentity));
              }
              this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);
            }
            break;
          case "ratchetKey":
            this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);
            break;
        }
      };
      this.onWorkerError = (ev) => {
        livekitLogger.error("e2ee worker encountered an error:", {
          error: ev.error
        });
        this.emit(EncryptionEvent.EncryptionError, ev.error);
      };
      this.keyProvider = options.keyProvider;
      this.worker = options.worker;
      this.encryptionEnabled = false;
    }
    /**
     * @internal
     */
    setup(room) {
      if (!isE2EESupported()) {
        throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
      }
      livekitLogger.info("setting up e2ee");
      if (room !== this.room) {
        this.room = room;
        this.setupEventListeners(room, this.keyProvider);
        const msg = {
          kind: "init",
          data: {
            keyProviderOptions: this.keyProvider.getOptions(),
            loglevel: workerLogger.getLevel()
          }
        };
        if (this.worker) {
          livekitLogger.info("initializing worker", {
            worker: this.worker
          });
          this.worker.onmessage = this.onWorkerMessage;
          this.worker.onerror = this.onWorkerError;
          this.worker.postMessage(msg);
        }
      }
    }
    /**
     * @internal
     */
    setParticipantCryptorEnabled(enabled, participantIdentity) {
      livekitLogger.debug("set e2ee to ".concat(enabled, " for participant ").concat(participantIdentity));
      this.postEnable(enabled, participantIdentity);
    }
    /**
     * @internal
     */
    setSifTrailer(trailer) {
      if (!trailer || trailer.length === 0) {
        livekitLogger.warn("ignoring server sent trailer as it's empty");
      } else {
        this.postSifTrailer(trailer);
      }
    }
    setupEngine(engine) {
      engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap) => {
        this.postRTPMap(rtpMap);
      });
    }
    setupEventListeners(room, keyProvider) {
      room.on(RoomEvent.TrackPublished, (pub, participant) => this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));
      room.on(RoomEvent.ConnectionStateChanged, (state) => {
        if (state === ConnectionState.Connected) {
          room.remoteParticipants.forEach((participant) => {
            participant.trackPublications.forEach((pub) => {
              this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);
            });
          });
        }
      }).on(RoomEvent.TrackUnsubscribed, (track, _2, participant) => {
        var _a;
        const msg = {
          kind: "removeTransform",
          data: {
            participantIdentity: participant.identity,
            trackId: track.mediaStreamID
          }
        };
        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);
      }).on(RoomEvent.TrackSubscribed, (track, pub, participant) => {
        this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);
      }).on(RoomEvent.SignalConnected, () => {
        if (!this.room) {
          throw new TypeError("expected room to be present on signal connect");
        }
        keyProvider.getKeys().forEach((keyInfo) => {
          this.postKey(keyInfo);
        });
        this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);
      });
      room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication) => __awaiter(this, void 0, void 0, function* () {
        this.setupE2EESender(publication.track, publication.track.sender);
      }));
      keyProvider.on(KeyProviderEvent.SetKey, (keyInfo) => this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) => this.postRatchetRequest(participantId, keyIndex));
    }
    postRatchetRequest(participantIdentity, keyIndex) {
      if (!this.worker) {
        throw Error("could not ratchet key, worker is missing");
      }
      const msg = {
        kind: "ratchetRequest",
        data: {
          participantIdentity,
          keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
    postKey(_ref) {
      let {
        key,
        participantIdentity,
        keyIndex
      } = _ref;
      var _a;
      if (!this.worker) {
        throw Error("could not set key, worker is missing");
      }
      const msg = {
        kind: "setKey",
        data: {
          participantIdentity,
          isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),
          key,
          keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
    postEnable(enabled, participantIdentity) {
      if (this.worker) {
        const enableMsg = {
          kind: "enable",
          data: {
            enabled,
            participantIdentity
          }
        };
        this.worker.postMessage(enableMsg);
      } else {
        throw new ReferenceError("failed to enable e2ee, worker is not ready");
      }
    }
    postRTPMap(map2) {
      var _a;
      if (!this.worker) {
        throw TypeError("could not post rtp map, worker is missing");
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
        throw TypeError("could not post rtp map, local participant identity is missing");
      }
      const msg = {
        kind: "setRTPMap",
        data: {
          map: map2,
          participantIdentity: this.room.localParticipant.identity
        }
      };
      this.worker.postMessage(msg);
    }
    postSifTrailer(trailer) {
      if (!this.worker) {
        throw Error("could not post SIF trailer, worker is missing");
      }
      const msg = {
        kind: "setSifTrailer",
        data: {
          trailer
        }
      };
      this.worker.postMessage(msg);
    }
    setupE2EEReceiver(track, remoteId, trackInfo) {
      if (!track.receiver) {
        return;
      }
      if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === "") {
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      }
      this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === "video" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : void 0);
    }
    setupE2EESender(track, sender) {
      if (!isLocalTrack(track) || !sender) {
        if (!sender)
          livekitLogger.warn("early return because sender is not ready");
        return;
      }
      this.handleSender(sender, track.mediaStreamID, void 0);
    }
    /**
     * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
     * a frame decoder.
     *
     */
    handleReceiver(receiver, trackId, participantIdentity, codec) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.worker) {
          return;
        }
        if (isScriptTransformSupported()) {
          const options = {
            kind: "decode",
            participantIdentity,
            trackId,
            codec
          };
          receiver.transform = new RTCRtpScriptTransform(this.worker, options);
        } else {
          if (E2EE_FLAG in receiver && codec) {
            const msg2 = {
              kind: "updateCodec",
              data: {
                trackId,
                codec,
                participantIdentity
              }
            };
            this.worker.postMessage(msg2);
            return;
          }
          let writable = receiver.writableStream;
          let readable = receiver.readableStream;
          if (!writable || !readable) {
            const receiverStreams = receiver.createEncodedStreams();
            receiver.writableStream = receiverStreams.writable;
            writable = receiverStreams.writable;
            receiver.readableStream = receiverStreams.readable;
            readable = receiverStreams.readable;
          }
          const msg = {
            kind: "decode",
            data: {
              readableStream: readable,
              writableStream: writable,
              trackId,
              codec,
              participantIdentity
            }
          };
          this.worker.postMessage(msg, [readable, writable]);
        }
        receiver[E2EE_FLAG] = true;
      });
    }
    /**
     * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
     * a frame encoder.
     *
     */
    handleSender(sender, trackId, codec) {
      var _a;
      if (E2EE_FLAG in sender || !this.worker) {
        return;
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === "") {
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      }
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const options = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId,
          codec
        };
        sender.transform = new RTCRtpScriptTransform(this.worker, options);
      } else {
        livekitLogger.info("initialize encoded streams");
        const senderStreams = sender.createEncodedStreams();
        const msg = {
          kind: "encode",
          data: {
            readableStream: senderStreams.readable,
            writableStream: senderStreams.writable,
            codec,
            trackId,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);
      }
      sender[E2EE_FLAG] = true;
    }
  }
  const defaultId = "default";
  class DeviceManager {
    constructor() {
      this._previousDevices = [];
    }
    static getInstance() {
      if (this.instance === void 0) {
        this.instance = new DeviceManager();
      }
      return this.instance;
    }
    get previousDevices() {
      return this._previousDevices;
    }
    getDevices(kind_1) {
      return __awaiter(this, arguments, void 0, function(kind) {
        var _this = this;
        let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a;
          if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {
            livekitLogger.debug("awaiting getUserMedia promise");
            try {
              if (kind) {
                yield DeviceManager.userMediaPromiseMap.get(kind);
              } else {
                yield Promise.all(DeviceManager.userMediaPromiseMap.values());
              }
            } catch (e2) {
              livekitLogger.warn("error waiting for media permissons");
            }
          }
          let devices = yield navigator.mediaDevices.enumerateDevices();
          if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
          !(isSafari() && _this.hasDeviceInUse(kind))) {
            const isDummyDeviceOrEmpty = devices.filter((d2) => d2.kind === kind).length === 0 || devices.some((device) => {
              const noLabel = device.label === "";
              const isRelevant = kind ? device.kind === kind : true;
              return noLabel && isRelevant;
            });
            if (isDummyDeviceOrEmpty) {
              const permissionsToAcquire = {
                video: kind !== "audioinput" && kind !== "audiooutput",
                audio: kind !== "videoinput" && {
                  deviceId: "default"
                }
              };
              const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);
              devices = yield navigator.mediaDevices.enumerateDevices();
              stream.getTracks().forEach((track) => {
                track.stop();
              });
            }
          }
          _this._previousDevices = devices;
          if (kind) {
            devices = devices.filter((device) => device.kind === kind);
          }
          return devices;
        }();
      });
    }
    normalizeDeviceId(kind, deviceId, groupId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (deviceId !== defaultId) {
          return deviceId;
        }
        const devices = yield this.getDevices(kind);
        const defaultDevice = devices.find((d2) => d2.deviceId === defaultId);
        if (!defaultDevice) {
          livekitLogger.warn("could not reliably determine default device");
          return void 0;
        }
        const device = devices.find((d2) => d2.deviceId !== defaultId && d2.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));
        if (!device) {
          livekitLogger.warn("could not reliably determine default device");
          return void 0;
        }
        return device === null || device === void 0 ? void 0 : device.deviceId;
      });
    }
    hasDeviceInUse(kind) {
      return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;
    }
  }
  DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
  DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
  var QueueTaskStatus;
  (function(QueueTaskStatus2) {
    QueueTaskStatus2[QueueTaskStatus2["WAITING"] = 0] = "WAITING";
    QueueTaskStatus2[QueueTaskStatus2["RUNNING"] = 1] = "RUNNING";
    QueueTaskStatus2[QueueTaskStatus2["COMPLETED"] = 2] = "COMPLETED";
  })(QueueTaskStatus || (QueueTaskStatus = {}));
  class AsyncQueue {
    constructor() {
      this.pendingTasks = /* @__PURE__ */ new Map();
      this.taskMutex = new _$1();
      this.nextTaskIndex = 0;
    }
    run(task) {
      return __awaiter(this, void 0, void 0, function* () {
        const taskInfo = {
          id: this.nextTaskIndex++,
          enqueuedAt: Date.now(),
          status: QueueTaskStatus.WAITING
        };
        this.pendingTasks.set(taskInfo.id, taskInfo);
        const unlock = yield this.taskMutex.lock();
        try {
          taskInfo.executedAt = Date.now();
          taskInfo.status = QueueTaskStatus.RUNNING;
          return yield task();
        } finally {
          taskInfo.status = QueueTaskStatus.COMPLETED;
          this.pendingTasks.delete(taskInfo.id);
          unlock();
        }
      });
    }
    flush() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.run(() => __awaiter(this, void 0, void 0, function* () {
        }));
      });
    }
    snapshot() {
      return Array.from(this.pendingTasks.values());
    }
  }
  const passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
  function canPassThroughQueue(req) {
    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;
    livekitLogger.trace("request allowed to bypass queue:", {
      canPass,
      req
    });
    return canPass;
  }
  var SignalConnectionState;
  (function(SignalConnectionState2) {
    SignalConnectionState2[SignalConnectionState2["CONNECTING"] = 0] = "CONNECTING";
    SignalConnectionState2[SignalConnectionState2["CONNECTED"] = 1] = "CONNECTED";
    SignalConnectionState2[SignalConnectionState2["RECONNECTING"] = 2] = "RECONNECTING";
    SignalConnectionState2[SignalConnectionState2["DISCONNECTING"] = 3] = "DISCONNECTING";
    SignalConnectionState2[SignalConnectionState2["DISCONNECTED"] = 4] = "DISCONNECTED";
  })(SignalConnectionState || (SignalConnectionState = {}));
  class SignalClient {
    get currentState() {
      return this.state;
    }
    get isDisconnected() {
      return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
    }
    get isEstablishingConnection() {
      return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
    }
    getNextRequestId() {
      this._requestId += 1;
      return this._requestId;
    }
    constructor() {
      let useJSON = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      let loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _a;
      this.rtt = 0;
      this.state = SignalConnectionState.DISCONNECTED;
      this.log = livekitLogger;
      this._requestId = 0;
      this.resetCallbacks = () => {
        this.onAnswer = void 0;
        this.onLeave = void 0;
        this.onLocalTrackPublished = void 0;
        this.onLocalTrackUnpublished = void 0;
        this.onNegotiateRequested = void 0;
        this.onOffer = void 0;
        this.onRemoteMuteChanged = void 0;
        this.onSubscribedQualityUpdate = void 0;
        this.onTokenRefresh = void 0;
        this.onTrickle = void 0;
        this.onClose = void 0;
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);
      this.loggerContextCb = loggerOptions.loggerContextCb;
      this.useJSON = useJSON;
      this.requestQueue = new AsyncQueue();
      this.queuedRequests = [];
      this.closingLock = new _$1();
      this.connectionLock = new _$1();
      this.state = SignalConnectionState.DISCONNECTED;
    }
    get logContext() {
      var _a, _b;
      return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};
    }
    join(url, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        this.state = SignalConnectionState.CONNECTING;
        this.options = opts;
        const res = yield this.connect(url, token, opts, abortSignal);
        return res;
      });
    }
    reconnect(url, token, sid, reason) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.options) {
          this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
          return;
        }
        this.state = SignalConnectionState.RECONNECTING;
        this.clearPingInterval();
        const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {
          reconnect: true,
          sid,
          reconnectReason: reason
        }));
        return res;
      });
    }
    connect(url, token, opts, abortSignal) {
      this.connectOptions = opts;
      url = toWebsocketUrl(url);
      url = url.replace(/\/$/, "");
      url += "/rtc";
      const clientInfo = getClientInfo();
      const params = createConnectionParams(token, clientInfo, opts);
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.connectionLock.lock();
        try {
          const abortHandler = () => __awaiter(this, void 0, void 0, function* () {
            this.close();
            clearTimeout(wsTimeout);
            reject(new ConnectionError("room connection has been cancelled (signal)", ConnectionErrorReason.Cancelled));
          });
          const wsTimeout = setTimeout(() => {
            this.close();
            reject(new ConnectionError("room connection has timed out (signal)", ConnectionErrorReason.ServerUnreachable));
          }, opts.websocketTimeout);
          if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
            abortHandler();
          }
          abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", abortHandler);
          this.log.debug("connecting to ".concat(url + params.replace(/access_token=([^&#$]*)/, "access_token=<redacted>")), this.logContext);
          if (this.ws) {
            yield this.close(false);
          }
          this.ws = new WebSocket(url + params);
          this.ws.binaryType = "arraybuffer";
          this.ws.onopen = () => {
            clearTimeout(wsTimeout);
          };
          this.ws.onerror = (ev) => __awaiter(this, void 0, void 0, function* () {
            if (this.state !== SignalConnectionState.CONNECTED) {
              this.state = SignalConnectionState.DISCONNECTED;
              clearTimeout(wsTimeout);
              try {
                const resp = yield fetch("http".concat(url.substring(2), "/validate").concat(params));
                if (resp.status.toFixed(0).startsWith("4")) {
                  const msg = yield resp.text();
                  reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));
                } else {
                  reject(new ConnectionError("Internal error", ConnectionErrorReason.InternalError, resp.status));
                }
              } catch (e2) {
                reject(new ConnectionError(e2 instanceof Error ? e2.message : "server was not reachable", ConnectionErrorReason.ServerUnreachable));
              }
              return;
            }
            this.handleWSError(ev);
          });
          this.ws.onmessage = (ev) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let resp;
            if (typeof ev.data === "string") {
              const json = JSON.parse(ev.data);
              resp = SignalResponse.fromJson(json, {
                ignoreUnknownFields: true
              });
            } else if (ev.data instanceof ArrayBuffer) {
              resp = SignalResponse.fromBinary(new Uint8Array(ev.data));
            } else {
              this.log.error("could not decode websocket message: ".concat(typeof ev.data), this.logContext);
              return;
            }
            if (this.state !== SignalConnectionState.CONNECTED) {
              let shouldProcessMessage = false;
              if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === "join") {
                this.state = SignalConnectionState.CONNECTED;
                abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
                this.pingTimeoutDuration = resp.message.value.pingTimeout;
                this.pingIntervalDuration = resp.message.value.pingInterval;
                if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {
                  this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
                    timeout: this.pingTimeoutDuration,
                    interval: this.pingIntervalDuration
                  }));
                  this.startPingInterval();
                }
                resolve(resp.message.value);
              } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== "leave") {
                this.state = SignalConnectionState.CONNECTED;
                abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
                this.startPingInterval();
                if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === "reconnect") {
                  resolve(resp.message.value);
                } else {
                  this.log.debug("declaring signal reconnected without reconnect response received", this.logContext);
                  resolve(void 0);
                  shouldProcessMessage = true;
                }
              } else if (this.isEstablishingConnection && resp.message.case === "leave") {
                reject(new ConnectionError("Received leave request while trying to (re)connect", ConnectionErrorReason.LeaveRequest, void 0, resp.message.value.reason));
              } else if (!opts.reconnect) {
                reject(new ConnectionError("did not receive join response, got ".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c.case, " instead"), ConnectionErrorReason.InternalError));
              }
              if (!shouldProcessMessage) {
                return;
              }
            }
            if (this.signalLatency) {
              yield sleep(this.signalLatency);
            }
            this.handleSignalResponse(resp);
          });
          this.ws.onclose = (ev) => {
            if (this.isEstablishingConnection) {
              reject(new ConnectionError("Websocket got closed during a (re)connection attempt", ConnectionErrorReason.InternalError));
            }
            this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
              reason: ev.reason,
              code: ev.code,
              wasClean: ev.wasClean,
              state: this.state
            }));
            this.handleOnClose(ev.reason);
          };
        } finally {
          unlock();
        }
      }));
    }
    close() {
      return __awaiter(this, arguments, void 0, function() {
        var _this = this;
        let updateState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          const unlock = yield _this.closingLock.lock();
          try {
            _this.clearPingInterval();
            if (updateState) {
              _this.state = SignalConnectionState.DISCONNECTING;
            }
            if (_this.ws) {
              _this.ws.onmessage = null;
              _this.ws.onopen = null;
              _this.ws.onclose = null;
              const closePromise = new Promise((resolve) => {
                if (_this.ws) {
                  _this.ws.onclose = () => {
                    resolve();
                  };
                } else {
                  resolve();
                }
              });
              if (_this.ws.readyState < _this.ws.CLOSING) {
                _this.ws.close();
                yield Promise.race([closePromise, sleep(250)]);
              }
              _this.ws = void 0;
            }
          } finally {
            if (updateState) {
              _this.state = SignalConnectionState.DISCONNECTED;
            }
            unlock();
          }
        }();
      });
    }
    // initial offer after joining
    sendOffer(offer) {
      this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
        offerSdp: offer.sdp
      }));
      this.sendRequest({
        case: "offer",
        value: toProtoSessionDescription(offer)
      });
    }
    // answer a server-initiated offer
    sendAnswer(answer) {
      this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
        answerSdp: answer.sdp
      }));
      return this.sendRequest({
        case: "answer",
        value: toProtoSessionDescription(answer)
      });
    }
    sendIceCandidate(candidate, target) {
      this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
        candidate
      }));
      return this.sendRequest({
        case: "trickle",
        value: new TrickleRequest({
          candidateInit: JSON.stringify(candidate),
          target
        })
      });
    }
    sendMuteTrack(trackSid, muted) {
      return this.sendRequest({
        case: "mute",
        value: new MuteTrackRequest({
          sid: trackSid,
          muted
        })
      });
    }
    sendAddTrack(req) {
      return this.sendRequest({
        case: "addTrack",
        value: req
      });
    }
    sendUpdateLocalMetadata(metadata_1, name_1) {
      return __awaiter(this, arguments, void 0, function(metadata, name) {
        var _this2 = this;
        let attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function* () {
          const requestId = _this2.getNextRequestId();
          yield _this2.sendRequest({
            case: "updateMetadata",
            value: new UpdateParticipantMetadata({
              requestId,
              metadata,
              name,
              attributes
            })
          });
          return requestId;
        }();
      });
    }
    sendUpdateTrackSettings(settings) {
      this.sendRequest({
        case: "trackSetting",
        value: settings
      });
    }
    sendUpdateSubscription(sub) {
      return this.sendRequest({
        case: "subscription",
        value: sub
      });
    }
    sendSyncState(sync) {
      return this.sendRequest({
        case: "syncState",
        value: sync
      });
    }
    sendUpdateVideoLayers(trackSid, layers) {
      return this.sendRequest({
        case: "updateLayers",
        value: new UpdateVideoLayers({
          trackSid,
          layers
        })
      });
    }
    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
      return this.sendRequest({
        case: "subscriptionPermission",
        value: new SubscriptionPermission({
          allParticipants,
          trackPermissions
        })
      });
    }
    sendSimulateScenario(scenario) {
      return this.sendRequest({
        case: "simulate",
        value: scenario
      });
    }
    sendPing() {
      return Promise.all([this.sendRequest({
        case: "ping",
        value: protoInt64.parse(Date.now())
      }), this.sendRequest({
        case: "pingReq",
        value: new Ping({
          timestamp: protoInt64.parse(Date.now()),
          rtt: protoInt64.parse(this.rtt)
        })
      })]);
    }
    sendUpdateLocalAudioTrack(trackSid, features) {
      return this.sendRequest({
        case: "updateAudioTrack",
        value: new UpdateLocalAudioTrack({
          trackSid,
          features
        })
      });
    }
    sendLeave() {
      return this.sendRequest({
        case: "leave",
        value: new LeaveRequest({
          reason: DisconnectReason.CLIENT_INITIATED,
          // server doesn't process this field, keeping it here to indicate the intent of a full disconnect
          action: LeaveRequest_Action.DISCONNECT
        })
      });
    }
    sendRequest(message_1) {
      return __awaiter(this, arguments, void 0, function(message) {
        var _this3 = this;
        let fromQueue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return function* () {
          const canQueue = !fromQueue && !canPassThroughQueue(message);
          if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {
            _this3.queuedRequests.push(() => __awaiter(_this3, void 0, void 0, function* () {
              yield this.sendRequest(message, true);
            }));
            return;
          }
          if (!fromQueue) {
            yield _this3.requestQueue.flush();
          }
          if (_this3.signalLatency) {
            yield sleep(_this3.signalLatency);
          }
          if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {
            _this3.log.error("cannot send signal request before connected, type: ".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);
            return;
          }
          const req = new SignalRequest({
            message
          });
          try {
            if (_this3.useJSON) {
              _this3.ws.send(req.toJsonString());
            } else {
              _this3.ws.send(req.toBinary());
            }
          } catch (e2) {
            _this3.log.error("error sending signal message", Object.assign(Object.assign({}, _this3.logContext), {
              error: e2
            }));
          }
        }();
      });
    }
    handleSignalResponse(res) {
      var _a, _b;
      const msg = res.message;
      if (msg == void 0) {
        this.log.debug("received unsupported message", this.logContext);
        return;
      }
      let pingHandled = false;
      if (msg.case === "answer") {
        const sd = fromProtoSessionDescription(msg.value);
        if (this.onAnswer) {
          this.onAnswer(sd);
        }
      } else if (msg.case === "offer") {
        const sd = fromProtoSessionDescription(msg.value);
        if (this.onOffer) {
          this.onOffer(sd);
        }
      } else if (msg.case === "trickle") {
        const candidate = JSON.parse(msg.value.candidateInit);
        if (this.onTrickle) {
          this.onTrickle(candidate, msg.value.target);
        }
      } else if (msg.case === "update") {
        if (this.onParticipantUpdate) {
          this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);
        }
      } else if (msg.case === "trackPublished") {
        if (this.onLocalTrackPublished) {
          this.onLocalTrackPublished(msg.value);
        }
      } else if (msg.case === "speakersChanged") {
        if (this.onSpeakersChanged) {
          this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);
        }
      } else if (msg.case === "leave") {
        if (this.onLeave) {
          this.onLeave(msg.value);
        }
      } else if (msg.case === "mute") {
        if (this.onRemoteMuteChanged) {
          this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);
        }
      } else if (msg.case === "roomUpdate") {
        if (this.onRoomUpdate && msg.value.room) {
          this.onRoomUpdate(msg.value.room);
        }
      } else if (msg.case === "connectionQuality") {
        if (this.onConnectionQuality) {
          this.onConnectionQuality(msg.value);
        }
      } else if (msg.case === "streamStateUpdate") {
        if (this.onStreamStateUpdate) {
          this.onStreamStateUpdate(msg.value);
        }
      } else if (msg.case === "subscribedQualityUpdate") {
        if (this.onSubscribedQualityUpdate) {
          this.onSubscribedQualityUpdate(msg.value);
        }
      } else if (msg.case === "subscriptionPermissionUpdate") {
        if (this.onSubscriptionPermissionUpdate) {
          this.onSubscriptionPermissionUpdate(msg.value);
        }
      } else if (msg.case === "refreshToken") {
        if (this.onTokenRefresh) {
          this.onTokenRefresh(msg.value);
        }
      } else if (msg.case === "trackUnpublished") {
        if (this.onLocalTrackUnpublished) {
          this.onLocalTrackUnpublished(msg.value);
        }
      } else if (msg.case === "subscriptionResponse") {
        if (this.onSubscriptionError) {
          this.onSubscriptionError(msg.value);
        }
      } else if (msg.case === "pong")
        ;
      else if (msg.case === "pongResp") {
        this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());
        this.resetPingTimeout();
        pingHandled = true;
      } else if (msg.case === "requestResponse") {
        if (this.onRequestResponse) {
          this.onRequestResponse(msg.value);
        }
      } else if (msg.case === "trackSubscribed") {
        if (this.onLocalTrackSubscribed) {
          this.onLocalTrackSubscribed(msg.value.trackSid);
        }
      } else {
        this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
          msgCase: msg.case
        }));
      }
      if (!pingHandled) {
        this.resetPingTimeout();
      }
    }
    setReconnected() {
      while (this.queuedRequests.length > 0) {
        const req = this.queuedRequests.shift();
        if (req) {
          this.requestQueue.run(req);
        }
      }
    }
    handleOnClose(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state === SignalConnectionState.DISCONNECTED)
          return;
        const onCloseCallback = this.onClose;
        yield this.close();
        this.log.debug("websocket connection closed: ".concat(reason), Object.assign(Object.assign({}, this.logContext), {
          reason
        }));
        if (onCloseCallback) {
          onCloseCallback(reason);
        }
      });
    }
    handleWSError(ev) {
      this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
        error: ev
      }));
    }
    /**
     * Resets the ping timeout and starts a new timeout.
     * Call this after receiving a pong message
     */
    resetPingTimeout() {
      this.clearPingTimeout();
      if (!this.pingTimeoutDuration) {
        this.log.warn("ping timeout duration not set", this.logContext);
        return;
      }
      this.pingTimeout = CriticalTimers.setTimeout(() => {
        this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext);
        this.handleOnClose("ping timeout");
      }, this.pingTimeoutDuration * 1e3);
    }
    /**
     * Clears ping timeout (does not start a new timeout)
     */
    clearPingTimeout() {
      if (this.pingTimeout) {
        CriticalTimers.clearTimeout(this.pingTimeout);
      }
    }
    startPingInterval() {
      this.clearPingInterval();
      this.resetPingTimeout();
      if (!this.pingIntervalDuration) {
        this.log.warn("ping interval duration not set", this.logContext);
        return;
      }
      this.log.debug("start ping interval", this.logContext);
      this.pingInterval = CriticalTimers.setInterval(() => {
        this.sendPing();
      }, this.pingIntervalDuration * 1e3);
    }
    clearPingInterval() {
      this.log.debug("clearing ping interval", this.logContext);
      this.clearPingTimeout();
      if (this.pingInterval) {
        CriticalTimers.clearInterval(this.pingInterval);
      }
    }
  }
  function fromProtoSessionDescription(sd) {
    const rsd = {
      type: "offer",
      sdp: sd.sdp
    };
    switch (sd.type) {
      case "answer":
      case "offer":
      case "pranswer":
      case "rollback":
        rsd.type = sd.type;
        break;
    }
    return rsd;
  }
  function toProtoSessionDescription(rsd) {
    const sd = new SessionDescription({
      sdp: rsd.sdp,
      type: rsd.type
    });
    return sd;
  }
  function createConnectionParams(token, info, opts) {
    var _a;
    const params = new URLSearchParams();
    params.set("access_token", token);
    if (opts.reconnect) {
      params.set("reconnect", "1");
      if (opts.sid) {
        params.set("sid", opts.sid);
      }
    }
    params.set("auto_subscribe", opts.autoSubscribe ? "1" : "0");
    params.set("sdk", isReactNative() ? "reactnative" : "js");
    params.set("version", info.version);
    params.set("protocol", info.protocol.toString());
    if (info.deviceModel) {
      params.set("device_model", info.deviceModel);
    }
    if (info.os) {
      params.set("os", info.os);
    }
    if (info.osVersion) {
      params.set("os_version", info.osVersion);
    }
    if (info.browser) {
      params.set("browser", info.browser);
    }
    if (info.browserVersion) {
      params.set("browser_version", info.browserVersion);
    }
    if (opts.adaptiveStream) {
      params.set("adaptive_stream", "1");
    }
    if (opts.reconnectReason) {
      params.set("reconnect_reason", opts.reconnectReason.toString());
    }
    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {
      params.set("network", navigator.connection.type);
    }
    return "?".concat(params.toString());
  }
  var lib = {};
  var parser = {};
  var grammar = { exports: {} };
  var hasRequiredGrammar;
  function requireGrammar() {
    if (hasRequiredGrammar)
      return grammar.exports;
    hasRequiredGrammar = 1;
    var grammar$1 = grammar.exports = {
      v: [{
        name: "version",
        reg: /^(\d*)$/
      }],
      o: [{
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
        format: "%s %s %d %s IP%d %s"
      }],
      // default parsing of these only (though some of these feel outdated)
      s: [{
        name: "name"
      }],
      i: [{
        name: "description"
      }],
      u: [{
        name: "uri"
      }],
      e: [{
        name: "email"
      }],
      p: [{
        name: "phone"
      }],
      z: [{
        name: "timezones"
      }],
      // TODO: this one can actually be parsed properly...
      r: [{
        name: "repeats"
      }],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [{
        // t=0 0
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d"
      }],
      c: [{
        // c=IN IP4 10.47.197.26
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s"
      }],
      b: [{
        // b=AS:4000
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s"
      }],
      m: [{
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s"
      }],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function(o2) {
            return o2.encoding ? "rtpmap:%d %s/%s/%s" : o2.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
          }
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s"
        },
        {
          // a=control:streamid=0
          name: "control",
          reg: /^control:(.*)/,
          format: "control:%s"
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function(o2) {
            return o2.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          }
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d"
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function(o2) {
            return o2.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          }
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function(o2) {
            return "extmap:%d" + (o2.direction ? "/%s" : "%v") + (o2["encrypt-uri"] ? " %s" : "%v") + " %s" + (o2.config ? " %s" : "");
          }
        },
        {
          // a=extmap-allow-mixed
          name: "extmapAllowMixed",
          reg: /^(extmap-allow-mixed)/
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function(o2) {
            return o2.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
          }
        },
        {
          // a=setup:actpass
          name: "setup",
          reg: /^setup:(\w*)/,
          format: "setup:%s"
        },
        {
          // a=connection:new
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s"
        },
        {
          // a=mid:1
          name: "mid",
          reg: /^mid:([^\s]*)/,
          format: "mid:%s"
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          name: "msid",
          reg: /^msid:(.*)/,
          format: "msid:%s"
        },
        {
          // a=ptime:20
          name: "ptime",
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: "ptime:%d"
        },
        {
          // a=maxptime:60
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d"
        },
        {
          // a=sendrecv
          name: "direction",
          reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
          // a=ice-lite
          name: "icelite",
          reg: /^(ice-lite)/
        },
        {
          // a=ice-ufrag:F7gI
          name: "iceUfrag",
          reg: /^ice-ufrag:(\S*)/,
          format: "ice-ufrag:%s"
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: "icePwd",
          reg: /^ice-pwd:(\S*)/,
          format: "ice-pwd:%s"
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s"
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
          format: function(o2) {
            var str = "candidate:%s %d %s %d %s %d typ %s";
            str += o2.raddr != null ? " raddr %s rport %d" : "%v%v";
            str += o2.tcptype != null ? " tcptype %s" : "%v";
            if (o2.generation != null) {
              str += " generation %d";
            }
            str += o2["network-id"] != null ? " network-id %d" : "%v";
            str += o2["network-cost"] != null ? " network-cost %d" : "%v";
            return str;
          }
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: "endOfCandidates",
          reg: /^(end-of-candidates)/
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s"
        },
        {
          // a=ice-options:google-ice
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s"
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function(o2) {
            var str = "ssrc:%d";
            if (o2.attribute != null) {
              str += " %s";
              if (o2.value != null) {
                str += ":%s";
              }
            }
            return str;
          }
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: "ssrcGroups",
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s"
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s"
          // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s"
        },
        {
          // a=rtcp-mux
          name: "rtcpMux",
          reg: /^(rtcp-mux)/
        },
        {
          // a=rtcp-rsize
          name: "rtcpRsize",
          reg: /^(rtcp-rsize)/
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function(o2) {
            return o2.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
          }
        },
        {
          // a=x-google-flag:conference
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s"
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function(o2) {
            return o2.params ? "rid:%s %s %s" : "rid:%s %s";
          }
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: "imageattrs",
          reg: new RegExp(
            // a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function(o2) {
            return "imageattr:%s %s %s" + (o2.dir2 ? " %s %s" : "");
          }
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: "simulcast",
          reg: new RegExp(
            // a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function(o2) {
            return "simulcast:%s %s" + (o2.dir2 ? " %s %s" : "");
          }
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s"
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s"
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
          format: "source-filter: %s %s %s %s %s"
        },
        {
          // a=bundle-only
          name: "bundleOnly",
          reg: /^(bundle-only)/
        },
        {
          // a=label:1
          name: "label",
          reg: /^label:(.+)/,
          format: "label:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: "sctpPort",
          reg: /^sctp-port:(\d+)$/,
          format: "sctp-port:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s"
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function(o2) {
            return "ts-refclk:%s" + (o2.clksrcExt != null ? "=%s" : "");
          }
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
          format: function(o2) {
            var str = "mediaclk:";
            str += o2.id != null ? "id=%s %s" : "%v%s";
            str += o2.mediaClockValue != null ? "=%s" : "";
            str += o2.rateNumerator != null ? " rate=%s" : "";
            str += o2.rateDenominator != null ? "/%s" : "";
            return str;
          }
        },
        {
          // a=keywds:keywords
          name: "keywords",
          reg: /^keywds:(.+)$/,
          format: "keywds:%s"
        },
        {
          // a=content:main
          name: "content",
          reg: /^content:(.+)/,
          format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s"
        },
        {
          // a=confid:1
          name: "bfcpConfId",
          reg: /^confid:(\d+)/,
          format: "confid:%s"
        },
        {
          // a=userid:1
          name: "bfcpUserId",
          reg: /^userid:(\d+)/,
          format: "userid:%s"
        },
        {
          // a=floorid:1
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s"
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: "invalid",
          names: ["value"]
        }
      ]
    };
    Object.keys(grammar$1).forEach(function(key) {
      var objs = grammar$1[key];
      objs.forEach(function(obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = "%s";
        }
      });
    });
    return grammar.exports;
  }
  var hasRequiredParser;
  function requireParser() {
    if (hasRequiredParser)
      return parser;
    hasRequiredParser = 1;
    (function(exports) {
      var toIntIfInt = function(v2) {
        return String(Number(v2)) === v2 ? Number(v2) : v2;
      };
      var attachProperties = function(match, location2, names, rawName) {
        if (rawName && !names) {
          location2[rawName] = toIntIfInt(match[1]);
        } else {
          for (var i2 = 0; i2 < names.length; i2 += 1) {
            if (match[i2 + 1] != null) {
              location2[names[i2]] = toIntIfInt(match[i2 + 1]);
            }
          }
        }
      };
      var parseReg = function(obj, location2, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location2[obj.push]) {
          location2[obj.push] = [];
        } else if (needsBlank && !location2[obj.name]) {
          location2[obj.name] = {};
        }
        var keyLocation = obj.push ? {} : (
          // blank object that will be pushed
          needsBlank ? location2[obj.name] : location2
        );
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        if (obj.push) {
          location2[obj.push].push(keyLocation);
        }
      };
      var grammar2 = requireGrammar();
      var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
      exports.parse = function(sdp2) {
        var session = {}, media = [], location2 = session;
        sdp2.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l2) {
          var type = l2[0];
          var content = l2.slice(2);
          if (type === "m") {
            media.push({
              rtp: [],
              fmtp: []
            });
            location2 = media[media.length - 1];
          }
          for (var j2 = 0; j2 < (grammar2[type] || []).length; j2 += 1) {
            var obj = grammar2[type][j2];
            if (obj.reg.test(content)) {
              return parseReg(obj, location2, content);
            }
          }
        });
        session.media = media;
        return session;
      };
      var paramReducer = function(acc, expr) {
        var s2 = expr.split(/=(.+)/, 2);
        if (s2.length === 2) {
          acc[s2[0]] = toIntIfInt(s2[1]);
        } else if (s2.length === 1 && expr.length > 1) {
          acc[s2[0]] = void 0;
        }
        return acc;
      };
      exports.parseParams = function(str) {
        return str.split(/;\s?/).reduce(paramReducer, {});
      };
      exports.parseFmtpConfig = exports.parseParams;
      exports.parsePayloads = function(str) {
        return str.toString().split(" ").map(Number);
      };
      exports.parseRemoteCandidates = function(str) {
        var candidates = [];
        var parts = str.split(" ").map(toIntIfInt);
        for (var i2 = 0; i2 < parts.length; i2 += 3) {
          candidates.push({
            component: parts[i2],
            ip: parts[i2 + 1],
            port: parts[i2 + 2]
          });
        }
        return candidates;
      };
      exports.parseImageAttributes = function(str) {
        return str.split(" ").map(function(item) {
          return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
        });
      };
      exports.parseSimulcastStreamList = function(str) {
        return str.split(";").map(function(stream) {
          return stream.split(",").map(function(format) {
            var scid, paused = false;
            if (format[0] !== "~") {
              scid = toIntIfInt(format);
            } else {
              scid = toIntIfInt(format.substring(1, format.length));
              paused = true;
            }
            return {
              scid,
              paused
            };
          });
        });
      };
    })(parser);
    return parser;
  }
  var writer;
  var hasRequiredWriter;
  function requireWriter() {
    if (hasRequiredWriter)
      return writer;
    hasRequiredWriter = 1;
    var grammar2 = requireGrammar();
    var formatRegExp = /%[sdv%]/g;
    var format = function(formatStr) {
      var i2 = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function(x) {
        if (i2 >= len) {
          return x;
        }
        var arg = args[i2];
        i2 += 1;
        switch (x) {
          case "%%":
            return "%";
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg);
          case "%v":
            return "";
        }
      });
    };
    var makeLine = function(type, obj, location2) {
      var str = obj.format instanceof Function ? obj.format(obj.push ? location2 : location2[obj.name]) : obj.format;
      var args = [type + "=" + str];
      if (obj.names) {
        for (var i2 = 0; i2 < obj.names.length; i2 += 1) {
          var n2 = obj.names[i2];
          if (obj.name) {
            args.push(location2[obj.name][n2]);
          } else {
            args.push(location2[obj.names[i2]]);
          }
        }
      } else {
        args.push(location2[obj.name]);
      }
      return format.apply(null, args);
    };
    var defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"];
    var defaultInnerOrder = ["i", "c", "b", "a"];
    writer = function(session, opts) {
      opts = opts || {};
      if (session.version == null) {
        session.version = 0;
      }
      if (session.name == null) {
        session.name = " ";
      }
      session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = "";
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp2 = [];
      outerOrder.forEach(function(type) {
        grammar2[type].forEach(function(obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp2.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function(el) {
              sdp2.push(makeLine(type, obj, el));
            });
          }
        });
      });
      session.media.forEach(function(mLine) {
        sdp2.push(makeLine("m", grammar2.m[0], mLine));
        innerOrder.forEach(function(type) {
          grammar2[type].forEach(function(obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp2.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function(el) {
                sdp2.push(makeLine(type, obj, el));
              });
            }
          });
        });
      });
      return sdp2.join("\r\n") + "\r\n";
    };
    return writer;
  }
  var hasRequiredLib;
  function requireLib() {
    if (hasRequiredLib)
      return lib;
    hasRequiredLib = 1;
    var parser2 = requireParser();
    var writer2 = requireWriter();
    var grammar2 = requireGrammar();
    lib.grammar = grammar2;
    lib.write = writer2;
    lib.parse = parser2.parse;
    lib.parseParams = parser2.parseParams;
    lib.parseFmtpConfig = parser2.parseFmtpConfig;
    lib.parsePayloads = parser2.parsePayloads;
    lib.parseRemoteCandidates = parser2.parseRemoteCandidates;
    lib.parseImageAttributes = parser2.parseImageAttributes;
    lib.parseSimulcastStreamList = parser2.parseSimulcastStreamList;
    return lib;
  }
  var libExports = requireLib();
  function r$1(r2, e2, n2) {
    var i2, t2, o2;
    void 0 === e2 && (e2 = 50), void 0 === n2 && (n2 = {});
    var a2 = null != (i2 = n2.isImmediate) && i2, u2 = null != (t2 = n2.callback) && t2, c2 = n2.maxWait, v2 = Date.now(), l2 = [];
    function f2() {
      if (void 0 !== c2) {
        var r3 = Date.now() - v2;
        if (r3 + e2 >= c2)
          return c2 - r3;
      }
      return e2;
    }
    var d2 = function() {
      var e3 = [].slice.call(arguments), n22 = this;
      return new Promise(function(i22, t22) {
        var c22 = a2 && void 0 === o2;
        if (void 0 !== o2 && clearTimeout(o2), o2 = setTimeout(function() {
          if (o2 = void 0, v2 = Date.now(), !a2) {
            var i3 = r2.apply(n22, e3);
            u2 && u2(i3), l2.forEach(function(r3) {
              return (0, r3.resolve)(i3);
            }), l2 = [];
          }
        }, f2()), c22) {
          var d22 = r2.apply(n22, e3);
          return u2 && u2(d22), i22(d22);
        }
        l2.push({
          resolve: i22,
          reject: t22
        });
      });
    };
    return d2.cancel = function(r3) {
      void 0 !== o2 && clearTimeout(o2), l2.forEach(function(e3) {
        return (0, e3.reject)(r3);
      }), l2 = [];
    }, d2;
  }
  const startBitrateForSVC = 0.7;
  const debounceInterval = 20;
  const PCEvents = {
    NegotiationStarted: "negotiationStarted",
    NegotiationComplete: "negotiationComplete",
    RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
  };
  class PCTransport extends eventsExports.EventEmitter {
    get pc() {
      if (!this._pc) {
        this._pc = this.createPC();
      }
      return this._pc;
    }
    constructor(config) {
      let loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _a;
      super();
      this.log = livekitLogger;
      this.ddExtID = 0;
      this.pendingCandidates = [];
      this.restartingIce = false;
      this.renegotiate = false;
      this.trackBitrates = [];
      this.remoteStereoMids = [];
      this.remoteNackMids = [];
      this.negotiate = r$1((onError) => __awaiter(this, void 0, void 0, function* () {
        this.emit(PCEvents.NegotiationStarted);
        try {
          yield this.createAndSendOffer();
        } catch (e2) {
          if (onError) {
            onError(e2);
          } else {
            throw e2;
          }
        }
      }), debounceInterval);
      this.close = () => {
        if (!this._pc) {
          return;
        }
        this._pc.close();
        this._pc.onconnectionstatechange = null;
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.ondatachannel = null;
        this._pc.onnegotiationneeded = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ondatachannel = null;
        this._pc.ontrack = null;
        this._pc.onconnectionstatechange = null;
        this._pc.oniceconnectionstatechange = null;
        this._pc = null;
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);
      this.loggerOptions = loggerOptions;
      this.config = config;
      this._pc = this.createPC();
    }
    createPC() {
      const pc = new RTCPeerConnection(this.config);
      pc.onicecandidate = (ev) => {
        var _a;
        if (!ev.candidate)
          return;
        (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);
      };
      pc.onicecandidateerror = (ev) => {
        var _a;
        (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      pc.oniceconnectionstatechange = () => {
        var _a;
        (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);
      };
      pc.onsignalingstatechange = () => {
        var _a;
        (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);
      };
      pc.onconnectionstatechange = () => {
        var _a;
        (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);
      };
      pc.ondatachannel = (ev) => {
        var _a;
        (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      pc.ontrack = (ev) => {
        var _a;
        (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      return pc;
    }
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    get isICEConnected() {
      return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
    }
    addIceCandidate(candidate) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.pc.remoteDescription && !this.restartingIce) {
          return this.pc.addIceCandidate(candidate);
        }
        this.pendingCandidates.push(candidate);
      });
    }
    setRemoteDescription(sd) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        let mungedSDP = void 0;
        if (sd.type === "offer") {
          let {
            stereoMids,
            nackMids
          } = extractStereoAndNackAudioFromOffer(sd);
          this.remoteStereoMids = stereoMids;
          this.remoteNackMids = nackMids;
        } else if (sd.type === "answer") {
          const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : "");
          sdpParsed.media.forEach((media) => {
            if (media.type === "audio") {
              this.trackBitrates.some((trackbr) => {
                if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {
                  return false;
                }
                let codecPayload = 0;
                media.rtp.some((rtp) => {
                  if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                    codecPayload = rtp.payload;
                    return true;
                  }
                  return false;
                });
                if (codecPayload === 0) {
                  return true;
                }
                let fmtpFound = false;
                for (const fmtp of media.fmtp) {
                  if (fmtp.payload === codecPayload) {
                    fmtp.config = fmtp.config.split(";").filter((attr) => !attr.includes("maxaveragebitrate")).join(";");
                    if (trackbr.maxbr > 0) {
                      fmtp.config += ";maxaveragebitrate=".concat(trackbr.maxbr * 1e3);
                    }
                    fmtpFound = true;
                    break;
                  }
                }
                if (!fmtpFound) {
                  if (trackbr.maxbr > 0) {
                    media.fmtp.push({
                      payload: codecPayload,
                      config: "maxaveragebitrate=".concat(trackbr.maxbr * 1e3)
                    });
                  }
                }
                return true;
              });
            }
          });
          mungedSDP = libExports.write(sdpParsed);
        }
        yield this.setMungedSDP(sd, mungedSDP, true);
        this.pendingCandidates.forEach((candidate) => {
          this.pc.addIceCandidate(candidate);
        });
        this.pendingCandidates = [];
        this.restartingIce = false;
        if (this.renegotiate) {
          this.renegotiate = false;
          yield this.createAndSendOffer();
        } else if (sd.type === "answer") {
          this.emit(PCEvents.NegotiationComplete);
          if (sd.sdp) {
            const sdpParsed = libExports.parse(sd.sdp);
            sdpParsed.media.forEach((media) => {
              if (media.type === "video") {
                this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);
              }
            });
          }
        }
      });
    }
    createAndSendOffer(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (this.onOffer === void 0) {
          return;
        }
        if (options === null || options === void 0 ? void 0 : options.iceRestart) {
          this.log.debug("restarting ICE", this.logContext);
          this.restartingIce = true;
        }
        if (this._pc && this._pc.signalingState === "have-local-offer") {
          const currentSD = this._pc.remoteDescription;
          if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {
            yield this._pc.setRemoteDescription(currentSD);
          } else {
            this.renegotiate = true;
            return;
          }
        } else if (!this._pc || this._pc.signalingState === "closed") {
          this.log.warn("could not createOffer with closed peer connection", this.logContext);
          return;
        }
        this.log.debug("starting to negotiate", this.logContext);
        const offer = yield this.pc.createOffer(options);
        this.log.debug("original offer", Object.assign({
          sdp: offer.sdp
        }, this.logContext));
        const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");
        sdpParsed.media.forEach((media) => {
          ensureIPAddrMatchVersion(media);
          if (media.type === "audio") {
            ensureAudioNackAndStereo(media, [], []);
          } else if (media.type === "video") {
            this.trackBitrates.some((trackbr) => {
              if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {
                return false;
              }
              let codecPayload = 0;
              media.rtp.some((rtp) => {
                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                  codecPayload = rtp.payload;
                  return true;
                }
                return false;
              });
              if (codecPayload === 0) {
                return true;
              }
              if (isSVCCodec(trackbr.codec)) {
                this.ensureVideoDDExtensionForSVC(media, sdpParsed);
              }
              if (trackbr.codec !== "av1") {
                return true;
              }
              const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);
              for (const fmtp of media.fmtp) {
                if (fmtp.payload === codecPayload) {
                  if (!fmtp.config.includes("x-google-start-bitrate")) {
                    fmtp.config += ";x-google-start-bitrate=".concat(startBitrate);
                  }
                  break;
                }
              }
              return true;
            });
          }
        });
        yield this.setMungedSDP(offer, libExports.write(sdpParsed));
        this.onOffer(offer);
      });
    }
    createAndSetAnswer() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const answer = yield this.pc.createAnswer();
        const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : "");
        sdpParsed.media.forEach((media) => {
          ensureIPAddrMatchVersion(media);
          if (media.type === "audio") {
            ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);
          }
        });
        yield this.setMungedSDP(answer, libExports.write(sdpParsed));
        return answer;
      });
    }
    createDataChannel(label, dataChannelDict) {
      return this.pc.createDataChannel(label, dataChannelDict);
    }
    addTransceiver(mediaStreamTrack, transceiverInit) {
      return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);
    }
    addTrack(track) {
      if (!this._pc) {
        throw new UnexpectedConnectionState("PC closed, cannot add track");
      }
      return this._pc.addTrack(track);
    }
    setTrackCodecBitrate(info) {
      this.trackBitrates.push(info);
    }
    setConfiguration(rtcConfig) {
      var _a;
      if (!this._pc) {
        throw new UnexpectedConnectionState("PC closed, cannot configure");
      }
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);
    }
    canRemoveTrack() {
      var _a;
      return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);
    }
    removeTrack(sender) {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);
    }
    getConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : "closed";
    }
    getICEConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : "closed";
    }
    getSignallingState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : "closed";
    }
    getTransceivers() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];
    }
    getSenders() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];
    }
    getLocalDescription() {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;
    }
    getRemoteDescription() {
      var _a;
      return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;
    }
    getStats() {
      return this.pc.getStats();
    }
    getConnectedAddress() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!this._pc) {
          return;
        }
        let selectedCandidatePairId = "";
        const candidatePairs = /* @__PURE__ */ new Map();
        const candidates = /* @__PURE__ */ new Map();
        const stats = yield this._pc.getStats();
        stats.forEach((v2) => {
          switch (v2.type) {
            case "transport":
              selectedCandidatePairId = v2.selectedCandidatePairId;
              break;
            case "candidate-pair":
              if (selectedCandidatePairId === "" && v2.selected) {
                selectedCandidatePairId = v2.id;
              }
              candidatePairs.set(v2.id, v2);
              break;
            case "remote-candidate":
              candidates.set(v2.id, "".concat(v2.address, ":").concat(v2.port));
              break;
          }
        });
        if (selectedCandidatePairId === "") {
          return void 0;
        }
        const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;
        if (selectedID === void 0) {
          return void 0;
        }
        return candidates.get(selectedID);
      });
    }
    setMungedSDP(sd, munged, remote) {
      return __awaiter(this, void 0, void 0, function* () {
        if (munged) {
          const originalSdp = sd.sdp;
          sd.sdp = munged;
          try {
            this.log.debug("setting munged ".concat(remote ? "remote" : "local", " description"), this.logContext);
            if (remote) {
              yield this.pc.setRemoteDescription(sd);
            } else {
              yield this.pc.setLocalDescription(sd);
            }
            return;
          } catch (e2) {
            this.log.warn("not able to set ".concat(sd.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
              error: e2,
              sdp: munged
            }));
            sd.sdp = originalSdp;
          }
        }
        try {
          if (remote) {
            yield this.pc.setRemoteDescription(sd);
          } else {
            yield this.pc.setLocalDescription(sd);
          }
        } catch (e2) {
          let msg = "unknown error";
          if (e2 instanceof Error) {
            msg = e2.message;
          } else if (typeof e2 === "string") {
            msg = e2;
          }
          const fields = {
            error: msg,
            sdp: sd.sdp
          };
          if (!remote && this.pc.remoteDescription) {
            fields.remoteSdp = this.pc.remoteDescription;
          }
          this.log.error("unable to set ".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {
            fields
          }));
          throw new NegotiationError(msg);
        }
      });
    }
    ensureVideoDDExtensionForSVC(media, sdp2) {
      var _a, _b;
      const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some((ext) => {
        if (ext.uri === ddExtensionURI) {
          return true;
        }
        return false;
      });
      if (!ddFound) {
        if (this.ddExtID === 0) {
          let maxID = 0;
          sdp2.media.forEach((m2) => {
            var _a2;
            if (m2.type !== "video") {
              return;
            }
            (_a2 = m2.ext) === null || _a2 === void 0 ? void 0 : _a2.forEach((ext) => {
              if (ext.value > maxID) {
                maxID = ext.value;
              }
            });
          });
          this.ddExtID = maxID + 1;
        }
        (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({
          value: this.ddExtID,
          uri: ddExtensionURI
        });
      }
    }
  }
  function ensureAudioNackAndStereo(media, stereoMids, nackMids) {
    let opusPayload = 0;
    media.rtp.some((rtp) => {
      if (rtp.codec === "opus") {
        opusPayload = rtp.payload;
        return true;
      }
      return false;
    });
    if (opusPayload > 0) {
      if (!media.rtcpFb) {
        media.rtcpFb = [];
      }
      if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
        media.rtcpFb.push({
          payload: opusPayload,
          type: "nack"
        });
      }
      if (stereoMids.includes(media.mid)) {
        media.fmtp.some((fmtp) => {
          if (fmtp.payload === opusPayload) {
            if (!fmtp.config.includes("stereo=1")) {
              fmtp.config += ";stereo=1";
            }
            return true;
          }
          return false;
        });
      }
    }
  }
  function extractStereoAndNackAudioFromOffer(offer) {
    var _a;
    const stereoMids = [];
    const nackMids = [];
    const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");
    let opusPayload = 0;
    sdpParsed.media.forEach((media) => {
      var _a2;
      if (media.type === "audio") {
        media.rtp.some((rtp) => {
          if (rtp.codec === "opus") {
            opusPayload = rtp.payload;
            return true;
          }
          return false;
        });
        if ((_a2 = media.rtcpFb) === null || _a2 === void 0 ? void 0 : _a2.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
          nackMids.push(media.mid);
        }
        media.fmtp.some((fmtp) => {
          if (fmtp.payload === opusPayload) {
            if (fmtp.config.includes("sprop-stereo=1")) {
              stereoMids.push(media.mid);
            }
            return true;
          }
          return false;
        });
      }
    });
    return {
      stereoMids,
      nackMids
    };
  }
  function ensureIPAddrMatchVersion(media) {
    if (media.connection) {
      const isV6 = media.connection.ip.indexOf(":") >= 0;
      if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {
        media.connection.ip = "0.0.0.0";
        media.connection.version = 4;
      }
    }
  }
  const defaultVideoCodec = "vp8";
  const publishDefaults = {
    audioPreset: AudioPresets.music,
    dtx: true,
    red: true,
    forceStereo: false,
    simulcast: true,
    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
    stopMicTrackOnMute: false,
    videoCodec: defaultVideoCodec,
    backupCodec: true
  };
  const audioDefaults = {
    deviceId: "default",
    autoGainControl: true,
    echoCancellation: true,
    noiseSuppression: true,
    voiceIsolation: true
  };
  const videoDefaults = {
    deviceId: "default",
    resolution: VideoPresets.h720.resolution
  };
  const roomOptionDefaults = {
    adaptiveStream: false,
    dynacast: false,
    stopLocalTrackOnUnpublish: true,
    reconnectPolicy: new DefaultReconnectPolicy(),
    disconnectOnPageLeave: true,
    webAudioMix: false
  };
  const roomConnectOptionDefaults = {
    autoSubscribe: true,
    maxRetries: 1,
    peerConnectionTimeout: 15e3,
    websocketTimeout: 15e3
  };
  var PCTransportState;
  (function(PCTransportState2) {
    PCTransportState2[PCTransportState2["NEW"] = 0] = "NEW";
    PCTransportState2[PCTransportState2["CONNECTING"] = 1] = "CONNECTING";
    PCTransportState2[PCTransportState2["CONNECTED"] = 2] = "CONNECTED";
    PCTransportState2[PCTransportState2["FAILED"] = 3] = "FAILED";
    PCTransportState2[PCTransportState2["CLOSING"] = 4] = "CLOSING";
    PCTransportState2[PCTransportState2["CLOSED"] = 5] = "CLOSED";
  })(PCTransportState || (PCTransportState = {}));
  class PCTransportManager {
    get needsPublisher() {
      return this.isPublisherConnectionRequired;
    }
    get needsSubscriber() {
      return this.isSubscriberConnectionRequired;
    }
    get currentState() {
      return this.state;
    }
    constructor(rtcConfig, subscriberPrimary, loggerOptions) {
      var _a;
      this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
      this.log = livekitLogger;
      this.updateState = () => {
        var _a2;
        const previousState = this.state;
        const connectionStates = this.requiredTransports.map((tr) => tr.getConnectionState());
        if (connectionStates.every((st2) => st2 === "connected")) {
          this.state = PCTransportState.CONNECTED;
        } else if (connectionStates.some((st2) => st2 === "failed")) {
          this.state = PCTransportState.FAILED;
        } else if (connectionStates.some((st2) => st2 === "connecting")) {
          this.state = PCTransportState.CONNECTING;
        } else if (connectionStates.every((st2) => st2 === "closed")) {
          this.state = PCTransportState.CLOSED;
        } else if (connectionStates.some((st2) => st2 === "closed")) {
          this.state = PCTransportState.CLOSING;
        } else if (connectionStates.every((st2) => st2 === "new")) {
          this.state = PCTransportState.NEW;
        }
        if (previousState !== this.state) {
          this.log.debug("pc state change: from ".concat(PCTransportState[previousState], " to ").concat(PCTransportState[this.state]), this.logContext);
          (_a2 = this.onStateChange) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());
        }
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);
      this.loggerOptions = loggerOptions;
      this.isPublisherConnectionRequired = !subscriberPrimary;
      this.isSubscriberConnectionRequired = subscriberPrimary;
      this.publisher = new PCTransport(rtcConfig, loggerOptions);
      this.subscriber = new PCTransport(rtcConfig, loggerOptions);
      this.publisher.onConnectionStateChange = this.updateState;
      this.subscriber.onConnectionStateChange = this.updateState;
      this.publisher.onIceConnectionStateChange = this.updateState;
      this.subscriber.onIceConnectionStateChange = this.updateState;
      this.publisher.onSignalingStatechange = this.updateState;
      this.subscriber.onSignalingStatechange = this.updateState;
      this.publisher.onIceCandidate = (candidate) => {
        var _a2;
        (_a2 = this.onIceCandidate) === null || _a2 === void 0 ? void 0 : _a2.call(this, candidate, SignalTarget.PUBLISHER);
      };
      this.subscriber.onIceCandidate = (candidate) => {
        var _a2;
        (_a2 = this.onIceCandidate) === null || _a2 === void 0 ? void 0 : _a2.call(this, candidate, SignalTarget.SUBSCRIBER);
      };
      this.subscriber.onDataChannel = (ev) => {
        var _a2;
        (_a2 = this.onDataChannel) === null || _a2 === void 0 ? void 0 : _a2.call(this, ev);
      };
      this.subscriber.onTrack = (ev) => {
        var _a2;
        (_a2 = this.onTrack) === null || _a2 === void 0 ? void 0 : _a2.call(this, ev);
      };
      this.publisher.onOffer = (offer) => {
        var _a2;
        (_a2 = this.onPublisherOffer) === null || _a2 === void 0 ? void 0 : _a2.call(this, offer);
      };
      this.state = PCTransportState.NEW;
      this.connectionLock = new _$1();
      this.remoteOfferLock = new _$1();
    }
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    requirePublisher() {
      let require = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.isPublisherConnectionRequired = require;
      this.updateState();
    }
    requireSubscriber() {
      let require = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.isSubscriberConnectionRequired = require;
      this.updateState();
    }
    createAndSendPublisherOffer(options) {
      return this.publisher.createAndSendOffer(options);
    }
    setPublisherAnswer(sd) {
      return this.publisher.setRemoteDescription(sd);
    }
    removeTrack(sender) {
      return this.publisher.removeTrack(sender);
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.publisher && this.publisher.getSignallingState() !== "closed") {
          const publisher = this.publisher;
          for (const sender of publisher.getSenders()) {
            try {
              if (publisher.canRemoveTrack()) {
                publisher.removeTrack(sender);
              }
            } catch (e2) {
              this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
                error: e2
              }));
            }
          }
        }
        yield Promise.all([this.publisher.close(), this.subscriber.close()]);
        this.updateState();
      });
    }
    triggerIceRestart() {
      return __awaiter(this, void 0, void 0, function* () {
        this.subscriber.restartingIce = true;
        if (this.needsPublisher) {
          yield this.createAndSendPublisherOffer({
            iceRestart: true
          });
        }
      });
    }
    addIceCandidate(candidate, target) {
      return __awaiter(this, void 0, void 0, function* () {
        if (target === SignalTarget.PUBLISHER) {
          yield this.publisher.addIceCandidate(candidate);
        } else {
          yield this.subscriber.addIceCandidate(candidate);
        }
      });
    }
    createSubscriberAnswerFromOffer(sd) {
      return __awaiter(this, void 0, void 0, function* () {
        this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
          RTCSdpType: sd.type,
          sdp: sd.sdp,
          signalingState: this.subscriber.getSignallingState().toString()
        }));
        const unlock = yield this.remoteOfferLock.lock();
        try {
          yield this.subscriber.setRemoteDescription(sd);
          const answer = yield this.subscriber.createAndSetAnswer();
          return answer;
        } finally {
          unlock();
        }
      });
    }
    updateConfiguration(config, iceRestart) {
      this.publisher.setConfiguration(config);
      this.subscriber.setConfiguration(config);
      if (iceRestart) {
        this.triggerIceRestart();
      }
    }
    ensurePCTransportConnection(abortController, timeout2) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.connectionLock.lock();
        try {
          if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting") {
            this.log.debug("negotiation required, start negotiating", this.logContext);
            this.publisher.negotiate();
          }
          yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport) => this.ensureTransportConnected(transport, abortController, timeout2)));
        } finally {
          unlock();
        }
      });
    }
    negotiate(abortController) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          const negotiationTimeout = setTimeout(() => {
            reject("negotiation timed out");
          }, this.peerConnectionTimeout);
          const abortHandler = () => {
            clearTimeout(negotiationTimeout);
            reject("negotiation aborted");
          };
          abortController.signal.addEventListener("abort", abortHandler);
          this.publisher.once(PCEvents.NegotiationStarted, () => {
            if (abortController.signal.aborted) {
              return;
            }
            this.publisher.once(PCEvents.NegotiationComplete, () => {
              clearTimeout(negotiationTimeout);
              resolve();
            });
          });
          yield this.publisher.negotiate((e2) => {
            clearTimeout(negotiationTimeout);
            reject(e2);
          });
        }));
      });
    }
    addPublisherTransceiver(track, transceiverInit) {
      return this.publisher.addTransceiver(track, transceiverInit);
    }
    addPublisherTrack(track) {
      return this.publisher.addTrack(track);
    }
    createPublisherDataChannel(label, dataChannelDict) {
      return this.publisher.createDataChannel(label, dataChannelDict);
    }
    /**
     * Returns the first required transport's address if no explicit target is specified
     */
    getConnectedAddress(target) {
      if (target === SignalTarget.PUBLISHER) {
        return this.publisher.getConnectedAddress();
      } else if (target === SignalTarget.SUBSCRIBER) {
        return this.publisher.getConnectedAddress();
      }
      return this.requiredTransports[0].getConnectedAddress();
    }
    get requiredTransports() {
      const transports = [];
      if (this.isPublisherConnectionRequired) {
        transports.push(this.publisher);
      }
      if (this.isSubscriberConnectionRequired) {
        transports.push(this.subscriber);
      }
      return transports;
    }
    ensureTransportConnected(pcTransport_1, abortController_1) {
      return __awaiter(this, arguments, void 0, function(pcTransport, abortController) {
        var _this = this;
        let timeout2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
        return function* () {
          const connectionState = pcTransport.getConnectionState();
          if (connectionState === "connected") {
            return;
          }
          return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {
            const abortHandler = () => {
              this.log.warn("abort transport connection", this.logContext);
              CriticalTimers.clearTimeout(connectTimeout);
              reject(new ConnectionError("room connection has been cancelled", ConnectionErrorReason.Cancelled));
            };
            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
              abortHandler();
            }
            abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener("abort", abortHandler);
            const connectTimeout = CriticalTimers.setTimeout(() => {
              abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
              reject(new ConnectionError("could not establish pc connection", ConnectionErrorReason.InternalError));
            }, timeout2);
            while (this.state !== PCTransportState.CONNECTED) {
              yield sleep(50);
              if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
                reject(new ConnectionError("room connection has been cancelled", ConnectionErrorReason.Cancelled));
                return;
              }
            }
            CriticalTimers.clearTimeout(connectTimeout);
            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
            resolve();
          }));
        }();
      });
    }
  }
  class RpcError extends Error {
    /**
     * Creates an error object with the given code and message, plus an optional data payload.
     *
     * If thrown in an RPC method handler, the error will be sent back to the caller.
     *
     * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).
     */
    constructor(code, message, data) {
      super(message);
      this.code = code;
      this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);
      this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : void 0;
    }
    /**
     * @internal
     */
    static fromProto(proto) {
      return new RpcError(proto.code, proto.message, proto.data);
    }
    /**
     * @internal
     */
    toProto() {
      return new RpcError$1({
        code: this.code,
        message: this.message,
        data: this.data
      });
    }
    /**
     * Creates an error object from the code, with an auto-populated message.
     *
     * @internal
     */
    static builtIn(key, data) {
      return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);
    }
  }
  RpcError.MAX_MESSAGE_BYTES = 256;
  RpcError.MAX_DATA_BYTES = 15360;
  RpcError.ErrorCode = {
    APPLICATION_ERROR: 1500,
    CONNECTION_TIMEOUT: 1501,
    RESPONSE_TIMEOUT: 1502,
    RECIPIENT_DISCONNECTED: 1503,
    RESPONSE_PAYLOAD_TOO_LARGE: 1504,
    SEND_FAILED: 1505,
    UNSUPPORTED_METHOD: 1400,
    RECIPIENT_NOT_FOUND: 1401,
    REQUEST_PAYLOAD_TOO_LARGE: 1402,
    UNSUPPORTED_SERVER: 1403,
    UNSUPPORTED_VERSION: 1404
  };
  RpcError.ErrorMessage = {
    APPLICATION_ERROR: "Application error in method handler",
    CONNECTION_TIMEOUT: "Connection timeout",
    RESPONSE_TIMEOUT: "Response timeout",
    RECIPIENT_DISCONNECTED: "Recipient disconnected",
    RESPONSE_PAYLOAD_TOO_LARGE: "Response payload too large",
    SEND_FAILED: "Failed to send",
    UNSUPPORTED_METHOD: "Method not supported at destination",
    RECIPIENT_NOT_FOUND: "Recipient not found",
    REQUEST_PAYLOAD_TOO_LARGE: "Request payload too large",
    UNSUPPORTED_SERVER: "RPC not supported by server",
    UNSUPPORTED_VERSION: "Unsupported RPC version"
  };
  const MAX_PAYLOAD_BYTES = 15360;
  function byteLength(str) {
    const encoder = new TextEncoder();
    return encoder.encode(str).length;
  }
  function truncateBytes(str, maxBytes) {
    if (byteLength(str) <= maxBytes) {
      return str;
    }
    let low = 0;
    let high = str.length;
    const encoder = new TextEncoder();
    while (low < high) {
      const mid = Math.floor((low + high + 1) / 2);
      if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {
        low = mid;
      } else {
        high = mid - 1;
      }
    }
    return str.slice(0, low);
  }
  const monitorFrequency = 2e3;
  function computeBitrate(currentStats, prevStats) {
    if (!prevStats) {
      return 0;
    }
    let bytesNow;
    let bytesPrev;
    if ("bytesReceived" in currentStats) {
      bytesNow = currentStats.bytesReceived;
      bytesPrev = prevStats.bytesReceived;
    } else if ("bytesSent" in currentStats) {
      bytesNow = currentStats.bytesSent;
      bytesPrev = prevStats.bytesSent;
    }
    if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {
      return 0;
    }
    return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);
  }
  const defaultDimensionsTimeout = 1e3;
  class LocalTrack extends Track {
    /** @internal */
    get sender() {
      return this._sender;
    }
    /** @internal */
    set sender(sender) {
      this._sender = sender;
    }
    get constraints() {
      return this._constraints;
    }
    /**
     *
     * @param mediaTrack
     * @param kind
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, kind, constraints) {
      let userProvidedTrack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      let loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
      super(mediaTrack, kind, loggerOptions);
      this.manuallyStopped = false;
      this._isUpstreamPaused = false;
      this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext));
      this.debouncedTrackMuteHandler = r$1(() => __awaiter(this, void 0, void 0, function* () {
        yield this.pauseUpstream();
      }), 5e3);
      this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {
        this.debouncedTrackMuteHandler.cancel("unmute");
        yield this.resumeUpstream();
      });
      this.handleEnded = () => {
        if (this.isInBackground) {
          this.reacquireTrack = true;
        }
        this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
        this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
        this.emit(TrackEvent.Ended, this);
      };
      this.reacquireTrack = false;
      this.providedByUser = userProvidedTrack;
      this.muteLock = new _$1();
      this.pauseUpstreamLock = new _$1();
      this.processorLock = new _$1();
      this.restartLock = new _$1();
      this.setMediaStreamTrack(mediaTrack, true);
      this._constraints = mediaTrack.getConstraints();
      if (constraints) {
        this._constraints = constraints;
      }
    }
    get id() {
      return this._mediaStreamTrack.id;
    }
    get dimensions() {
      if (this.kind !== Track.Kind.Video) {
        return void 0;
      }
      const {
        width,
        height
      } = this._mediaStreamTrack.getSettings();
      if (width && height) {
        return {
          width,
          height
        };
      }
      return void 0;
    }
    get isUpstreamPaused() {
      return this._isUpstreamPaused;
    }
    get isUserProvided() {
      return this.providedByUser;
    }
    get mediaStreamTrack() {
      var _a, _b;
      return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;
    }
    get isLocal() {
      return true;
    }
    /**
     * @internal
     * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors
     */
    getSourceTrackSettings() {
      return this._mediaStreamTrack.getSettings();
    }
    setMediaStreamTrack(newTrack, force) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (newTrack === this._mediaStreamTrack && !force) {
          return;
        }
        if (this._mediaStreamTrack) {
          this.attachedElements.forEach((el) => {
            detachTrack(this._mediaStreamTrack, el);
          });
          this.debouncedTrackMuteHandler.cancel("new-track");
          this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
          this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
          this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
        }
        this.mediaStream = new MediaStream([newTrack]);
        if (newTrack) {
          newTrack.addEventListener("ended", this.handleEnded);
          newTrack.addEventListener("mute", this.handleTrackMuteEvent);
          newTrack.addEventListener("unmute", this.handleTrackUnmuteEvent);
          this._constraints = newTrack.getConstraints();
        }
        let processedTrack;
        if (this.processor && newTrack) {
          const unlock = yield this.processorLock.lock();
          try {
            this.log.debug("restarting processor", this.logContext);
            if (this.kind === "unknown") {
              throw TypeError("cannot set processor on track of unknown kind");
            }
            if (this.processorElement) {
              attachToElement(newTrack, this.processorElement);
              this.processorElement.muted = true;
            }
            yield this.processor.restart({
              track: newTrack,
              kind: this.kind,
              element: this.processorElement
            });
            processedTrack = this.processor.processedTrack;
          } finally {
            unlock();
          }
        }
        if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== "closed") {
          yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);
        }
        if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {
          this._mediaStreamTrack.stop();
        }
        this._mediaStreamTrack = newTrack;
        if (newTrack) {
          this._mediaStreamTrack.enabled = !this.isMuted;
          yield this.resumeUpstream();
          this.attachedElements.forEach((el) => {
            attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);
          });
        }
      });
    }
    waitForDimensions() {
      return __awaiter(this, arguments, void 0, function() {
        var _this = this;
        let timeout2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
        return function* () {
          var _a;
          if (_this.kind === Track.Kind.Audio) {
            throw new Error("cannot get dimensions for audio tracks");
          }
          if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === "iOS") {
            yield sleep(10);
          }
          const started = Date.now();
          while (Date.now() - started < timeout2) {
            const dims = _this.dimensions;
            if (dims) {
              return dims;
            }
            yield sleep(50);
          }
          throw new TrackInvalidError("unable to get track dimensions after timeout");
        }();
      });
    }
    setDeviceId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {
          return true;
        }
        this._constraints.deviceId = deviceId;
        if (this.isMuted) {
          return true;
        }
        yield this.restartTrack();
        return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;
      });
    }
    /**
     * @returns DeviceID of the device that is currently being used for this track
     */
    getDeviceId() {
      return __awaiter(this, arguments, void 0, function() {
        var _this2 = this;
        let normalize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          if (_this2.source === Track.Source.ScreenShare) {
            return;
          }
          const {
            deviceId,
            groupId
          } = _this2._mediaStreamTrack.getSettings();
          const kind = _this2.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
          return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;
        }();
      });
    }
    mute() {
      return __awaiter(this, void 0, void 0, function* () {
        this.setTrackMuted(true);
        return this;
      });
    }
    unmute() {
      return __awaiter(this, void 0, void 0, function* () {
        this.setTrackMuted(false);
        return this;
      });
    }
    replaceTrack(track, userProvidedOrOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          throw new TrackInvalidError("unable to replace an unpublished track");
        }
        let userProvidedTrack;
        let stopProcessor;
        if (typeof userProvidedOrOptions === "boolean") {
          userProvidedTrack = userProvidedOrOptions;
        } else if (userProvidedOrOptions !== void 0) {
          userProvidedTrack = userProvidedOrOptions.userProvidedTrack;
          stopProcessor = userProvidedOrOptions.stopProcessor;
        }
        this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;
        this.log.debug("replace MediaStreamTrack", this.logContext);
        yield this.setMediaStreamTrack(track);
        if (stopProcessor && this.processor) {
          yield this.stopProcessor();
        }
        return this;
      });
    }
    restart(constraints) {
      return __awaiter(this, void 0, void 0, function* () {
        this.manuallyStopped = false;
        const unlock = yield this.restartLock.lock();
        try {
          if (!constraints) {
            constraints = this._constraints;
          }
          this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
            constraints
          }));
          const streamConstraints = {
            audio: false,
            video: false
          };
          if (this.kind === Track.Kind.Video) {
            streamConstraints.video = constraints;
          } else {
            streamConstraints.audio = constraints;
          }
          this.attachedElements.forEach((el) => {
            detachTrack(this.mediaStreamTrack, el);
          });
          this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
          this._mediaStreamTrack.stop();
          const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);
          const newTrack = mediaStream.getTracks()[0];
          newTrack.addEventListener("ended", this.handleEnded);
          this.log.debug("re-acquired MediaStreamTrack", this.logContext);
          yield this.setMediaStreamTrack(newTrack);
          this._constraints = constraints;
          this.emit(TrackEvent.Restarted, this);
          if (this.manuallyStopped) {
            this.log.warn("track was stopped during a restart, stopping restarted track", this.logContext);
            this.stop();
          }
          return this;
        } finally {
          unlock();
        }
      });
    }
    setTrackMuted(muted) {
      this.log.debug("setting ".concat(this.kind, " track ").concat(muted ? "muted" : "unmuted"), this.logContext);
      if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {
        return;
      }
      this.isMuted = muted;
      this._mediaStreamTrack.enabled = !muted;
      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
    }
    get needsReAcquisition() {
      return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!isMobile())
          return;
        this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext);
        if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {
          this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext);
          yield this.restart();
          this.reacquireTrack = false;
        }
      });
    }
    stop() {
      var _a;
      this.manuallyStopped = true;
      super.stop();
      this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
      this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
      this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
      (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();
      this.processor = void 0;
    }
    /**
     * pauses publishing to the server without disabling the local MediaStreamTrack
     * this is used to display a user's own video locally while pausing publishing to
     * the server.
     * this API is unsupported on Safari < 12 due to a bug
     **/
    pauseUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === true) {
            return;
          }
          if (!this.sender) {
            this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
            return;
          }
          this._isUpstreamPaused = true;
          this.emit(TrackEvent.UpstreamPaused, this);
          const browser = getBrowser();
          if ((browser === null || browser === void 0 ? void 0 : browser.name) === "Safari" && compareVersions(browser.version, "12.0") < 0) {
            throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
          }
          if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== "closed") {
            yield this.sender.replaceTrack(null);
          }
        } finally {
          unlock();
        }
      });
    }
    resumeUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === false) {
            return;
          }
          if (!this.sender) {
            this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
            return;
          }
          this._isUpstreamPaused = false;
          this.emit(TrackEvent.UpstreamResumed, this);
          if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== "closed") {
            yield this.sender.replaceTrack(this.mediaStreamTrack);
          }
        } finally {
          unlock();
        }
      });
    }
    /**
     * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
    getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return;
        }
        const statsReport = yield this.sender.getStats();
        return statsReport;
      });
    }
    /**
     * Sets a processor on this track.
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     *
     * @param processor
     * @param showProcessedStreamLocally
     * @returns
     */
    setProcessor(processor_1) {
      return __awaiter(this, arguments, void 0, function(processor) {
        var _this3 = this;
        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a;
          const unlock = yield _this3.processorLock.lock();
          try {
            _this3.log.debug("setting up processor", _this3.logContext);
            const processorElement = document.createElement(_this3.kind);
            const processorOptions = {
              kind: _this3.kind,
              track: _this3._mediaStreamTrack,
              element: processorElement,
              audioContext: _this3.audioContext
            };
            yield processor.init(processorOptions);
            _this3.log.debug("processor initialized", _this3.logContext);
            if (_this3.processor) {
              yield _this3.stopProcessor();
            }
            if (_this3.kind === "unknown") {
              throw TypeError("cannot set processor on track of unknown kind");
            }
            attachToElement(_this3._mediaStreamTrack, processorElement);
            processorElement.muted = true;
            processorElement.play().catch((error) => _this3.log.error("failed to play processor element", Object.assign(Object.assign({}, _this3.logContext), {
              error
            })));
            _this3.processor = processor;
            _this3.processorElement = processorElement;
            if (_this3.processor.processedTrack) {
              for (const el of _this3.attachedElements) {
                if (el !== _this3.processorElement && showProcessedStreamLocally) {
                  detachTrack(_this3._mediaStreamTrack, el);
                  attachToElement(_this3.processor.processedTrack, el);
                }
              }
              yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);
            }
            _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);
          } finally {
            unlock();
          }
        }();
      });
    }
    getProcessor() {
      return this.processor;
    }
    /**
     * Stops the track processor
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     * @returns
     */
    stopProcessor() {
      return __awaiter(this, arguments, void 0, function() {
        var _this4 = this;
        let keepElement = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          var _a, _b;
          if (!_this4.processor)
            return;
          _this4.log.debug("stopping processor", _this4.logContext);
          (_a = _this4.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();
          yield _this4.processor.destroy();
          _this4.processor = void 0;
          if (!keepElement) {
            (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();
            _this4.processorElement = void 0;
          }
          yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);
          yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);
          _this4.emit(TrackEvent.TrackProcessorUpdate);
        }();
      });
    }
  }
  class LocalAudioTrack extends LocalTrack {
    /**
     * boolean indicating whether enhanced noise cancellation is currently being used on this track
     */
    get enhancedNoiseCancellation() {
      return this.isKrispNoiseFilterEnabled;
    }
    /**
     *
     * @param mediaTrack
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, constraints) {
      let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      let audioContext = arguments.length > 3 ? arguments[3] : void 0;
      let loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
      super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);
      this.stopOnMute = false;
      this.isKrispNoiseFilterEnabled = false;
      this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          this._currentBitrate = 0;
          return;
        }
        let stats;
        try {
          stats = yield this.getSenderStats();
        } catch (e2) {
          this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
            error: e2
          }));
          return;
        }
        if (stats && this.prevStats) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.handleKrispNoiseFilterEnable = () => {
        this.isKrispNoiseFilterEnabled = true;
        this.log.debug("Krisp noise filter enabled", this.logContext);
        this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);
      };
      this.handleKrispNoiseFilterDisable = () => {
        this.isKrispNoiseFilterEnabled = false;
        this.log.debug("Krisp noise filter disabled", this.logContext);
        this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);
      };
      this.audioContext = audioContext;
      this.checkForSilence();
    }
    mute() {
      const _super = Object.create(null, {
        mute: {
          get: () => super.mute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (this.isMuted) {
            this.log.debug("Track already muted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {
            this.log.debug("stopping mic track", this.logContext);
            this._mediaStreamTrack.stop();
          }
          yield _super.mute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    unmute() {
      const _super = Object.create(null, {
        unmute: {
          get: () => super.unmute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (!this.isMuted) {
            this.log.debug("Track already unmuted", this.logContext);
            return this;
          }
          const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
          if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || deviceHasChanged) && !this.isUserProvided) {
            this.log.debug("reacquiring mic track", this.logContext);
            yield this.restartTrack();
          }
          yield _super.unmute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    restartTrack(options) {
      return __awaiter(this, void 0, void 0, function* () {
        let constraints;
        if (options) {
          const streamConstraints = constraintsForOptions({
            audio: options
          });
          if (typeof streamConstraints.audio !== "boolean") {
            constraints = streamConstraints.audio;
          }
        }
        yield this.restart(constraints);
      });
    }
    restart(constraints) {
      const _super = Object.create(null, {
        restart: {
          get: () => super.restart
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const track = yield _super.restart.call(this, constraints);
        this.checkForSilence();
        return track;
      });
    }
    /* @internal */
    startMonitor() {
      if (!isWeb()) {
        return;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(() => {
        this.monitorSender();
      }, monitorFrequency);
    }
    setProcessor(processor) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.processorLock.lock();
        try {
          if (!isReactNative() && !this.audioContext) {
            throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
          }
          if (this.processor) {
            yield this.stopProcessor();
          }
          const processorOptions = {
            kind: this.kind,
            track: this._mediaStreamTrack,
            // RN won't have or use AudioContext
            audioContext: this.audioContext
          };
          this.log.debug("setting up audio processor ".concat(processor.name), this.logContext);
          yield processor.init(processorOptions);
          this.processor = processor;
          if (this.processor.processedTrack) {
            yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);
            this.processor.processedTrack.addEventListener("enable-lk-krisp-noise-filter", this.handleKrispNoiseFilterEnable);
            this.processor.processedTrack.addEventListener("disable-lk-krisp-noise-filter", this.handleKrispNoiseFilterDisable);
          }
          this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
        } finally {
          unlock();
        }
      });
    }
    /**
     * @internal
     * @experimental
     */
    setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }
    getSenderStats() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return void 0;
        }
        const stats = yield this.sender.getStats();
        let audioStats;
        stats.forEach((v2) => {
          if (v2.type === "outbound-rtp") {
            audioStats = {
              type: "audio",
              streamId: v2.id,
              packetsSent: v2.packetsSent,
              packetsLost: v2.packetsLost,
              bytesSent: v2.bytesSent,
              timestamp: v2.timestamp,
              roundTripTime: v2.roundTripTime,
              jitter: v2.jitter
            };
          }
        });
        return audioStats;
      });
    }
    checkForSilence() {
      return __awaiter(this, void 0, void 0, function* () {
        const trackIsSilent = yield detectSilence(this);
        if (trackIsSilent) {
          if (!this.isMuted) {
            this.log.warn("silence detected on local audio track", this.logContext);
          }
          this.emit(TrackEvent.AudioSilenceDetected);
        }
        return trackIsSilent;
      });
    }
  }
  function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {
    switch (mediaStreamTrack.kind) {
      case "audio":
        return new LocalAudioTrack(mediaStreamTrack, constraints, false, void 0, loggerOptions);
      case "video":
        return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);
      default:
        throw new TrackInvalidError("unsupported track type: ".concat(mediaStreamTrack.kind));
    }
  }
  const presets169 = Object.values(VideoPresets);
  const presets43 = Object.values(VideoPresets43);
  const presetsScreenShare = Object.values(ScreenSharePresets);
  const defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];
  const defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];
  const computeDefaultScreenShareSimulcastPresets = (fromPreset) => {
    const layers = [{
      scaleResolutionDownBy: 2,
      fps: fromPreset.encoding.maxFramerate
    }];
    return layers.map((t2) => {
      var _a, _b;
      return new VideoPreset(Math.floor(fromPreset.width / t2.scaleResolutionDownBy), Math.floor(fromPreset.height / t2.scaleResolutionDownBy), Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t2.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t2.fps) !== null && _b !== void 0 ? _b : 30))))), t2.fps, fromPreset.encoding.priority);
    });
  };
  const videoRids = ["q", "h", "f"];
  function computeVideoEncodings(isScreenShare, width, height, options) {
    var _a, _b;
    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;
    if (isScreenShare) {
      videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;
    }
    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;
    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;
    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;
    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {
      return [{}];
    }
    if (!videoEncoding) {
      videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);
      livekitLogger.debug("using video encoding", videoEncoding);
    }
    const sourceFramerate = videoEncoding.maxFramerate;
    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);
    if (scalabilityMode && isSVCCodec(videoCodec)) {
      const sm = new ScalabilityMode(scalabilityMode);
      const encodings = [];
      if (sm.spatial > 3) {
        throw new Error("unsupported scalabilityMode: ".concat(scalabilityMode));
      }
      const browser = getBrowser();
      if (isSafari() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding
      // is provided. So we'll use the legacy SVC specification for now.
      // TODO: when we upstream libwebrtc, this will need additional verification
      isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, "113") < 0) {
        const bitratesRatio = sm.suffix == "h" ? 2 : 3;
        for (let i2 = 0; i2 < sm.spatial; i2 += 1) {
          encodings.push({
            rid: videoRids[2 - i2],
            maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i2),
            maxFramerate: original.encoding.maxFramerate
          });
        }
        encodings[0].scalabilityMode = scalabilityMode;
      } else {
        encodings.push({
          maxBitrate: videoEncoding.maxBitrate,
          maxFramerate: original.encoding.maxFramerate,
          /* @ts-ignore */
          scalabilityMode
        });
      }
      if (original.encoding.priority) {
        encodings[0].priority = original.encoding.priority;
        encodings[0].networkPriority = original.encoding.priority;
      }
      livekitLogger.debug("using svc encoding", {
        encodings
      });
      return encodings;
    }
    if (!useSimulcast) {
      return [videoEncoding];
    }
    let presets = [];
    if (isScreenShare) {
      presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);
    } else {
      presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);
    }
    let midPreset;
    if (presets.length > 0) {
      const lowPreset = presets[0];
      if (presets.length > 1) {
        [, midPreset] = presets;
      }
      const size = Math.max(width, height);
      if (size >= 960 && midPreset) {
        return encodingsFromPresets(width, height, [lowPreset, midPreset, original], sourceFramerate);
      }
      if (size >= 480) {
        return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);
      }
    }
    return encodingsFromPresets(width, height, [original]);
  }
  function computeTrackBackupEncodings(track, videoCodec, opts) {
    var _a, _b, _c, _d;
    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {
      return;
    }
    if (videoCodec !== opts.backupCodec.codec) {
      livekitLogger.warn("requested a different codec than specified as backup", {
        serverRequested: videoCodec,
        backup: opts.backupCodec.codec
      });
    }
    opts.videoCodec = videoCodec;
    opts.videoEncoding = opts.backupCodec.encoding;
    const settings = track.mediaStreamTrack.getSettings();
    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;
    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;
    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);
    return encodings;
  }
  function determineAppropriateEncoding(isScreenShare, width, height, codec) {
    const presets = presetsForResolution(isScreenShare, width, height);
    let {
      encoding
    } = presets[0];
    const size = Math.max(width, height);
    for (let i2 = 0; i2 < presets.length; i2 += 1) {
      const preset = presets[i2];
      encoding = preset.encoding;
      if (preset.width >= size) {
        break;
      }
    }
    if (codec) {
      switch (codec) {
        case "av1":
          encoding = Object.assign({}, encoding);
          encoding.maxBitrate = encoding.maxBitrate * 0.7;
          break;
        case "vp9":
          encoding = Object.assign({}, encoding);
          encoding.maxBitrate = encoding.maxBitrate * 0.85;
          break;
      }
    }
    return encoding;
  }
  function presetsForResolution(isScreenShare, width, height) {
    if (isScreenShare) {
      return presetsScreenShare;
    }
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
      return presets169;
    }
    return presets43;
  }
  function defaultSimulcastLayers(isScreenShare, original) {
    if (isScreenShare) {
      return computeDefaultScreenShareSimulcastPresets(original);
    }
    const {
      width,
      height
    } = original;
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
      return defaultSimulcastPresets169;
    }
    return defaultSimulcastPresets43;
  }
  function encodingsFromPresets(width, height, presets, sourceFramerate) {
    const encodings = [];
    presets.forEach((preset, idx) => {
      if (idx >= videoRids.length) {
        return;
      }
      const size = Math.min(width, height);
      const rid = videoRids[idx];
      const encoding = {
        rid,
        scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),
        maxBitrate: preset.encoding.maxBitrate
      };
      const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;
      if (maxFramerate) {
        encoding.maxFramerate = maxFramerate;
      }
      const canSetPriority = isFireFox() || idx === 0;
      if (preset.encoding.priority && canSetPriority) {
        encoding.priority = preset.encoding.priority;
        encoding.networkPriority = preset.encoding.priority;
      }
      encodings.push(encoding);
    });
    if (isReactNative() && getReactNativeOs() === "ios") {
      let topFramerate = void 0;
      encodings.forEach((encoding) => {
        if (!topFramerate) {
          topFramerate = encoding.maxFramerate;
        } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {
          topFramerate = encoding.maxFramerate;
        }
      });
      let notifyOnce = true;
      encodings.forEach((encoding) => {
        var _a;
        if (encoding.maxFramerate != topFramerate) {
          if (notifyOnce) {
            notifyOnce = false;
            livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.");
          }
          livekitLogger.info('Setting framerate of encoding "'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : "", '" to ').concat(topFramerate));
          encoding.maxFramerate = topFramerate;
        }
      });
    }
    return encodings;
  }
  function sortPresets(presets) {
    if (!presets)
      return;
    return presets.sort((a2, b2) => {
      const {
        encoding: aEnc
      } = a2;
      const {
        encoding: bEnc
      } = b2;
      if (aEnc.maxBitrate > bEnc.maxBitrate) {
        return 1;
      }
      if (aEnc.maxBitrate < bEnc.maxBitrate)
        return -1;
      if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
        return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
      }
      return 0;
    });
  }
  class ScalabilityMode {
    constructor(scalabilityMode) {
      const results = scalabilityMode.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
      if (!results) {
        throw new Error("invalid scalability mode");
      }
      this.spatial = parseInt(results[1]);
      this.temporal = parseInt(results[2]);
      if (results.length > 3) {
        switch (results[3]) {
          case "h":
          case "_KEY":
          case "_KEY_SHIFT":
            this.suffix = results[3];
        }
      }
    }
    toString() {
      var _a;
      return "L".concat(this.spatial, "T").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : "");
    }
  }
  function getDefaultDegradationPreference(track) {
    if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {
      return "maintain-resolution";
    } else {
      return "balanced";
    }
  }
  const refreshSubscribedCodecAfterNewCodec = 5e3;
  class LocalVideoTrack extends LocalTrack {
    get sender() {
      return this._sender;
    }
    set sender(sender) {
      this._sender = sender;
      if (this.degradationPreference) {
        this.setDegradationPreference(this.degradationPreference);
      }
    }
    /**
     *
     * @param mediaTrack
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, constraints) {
      let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      let loggerOptions = arguments.length > 3 ? arguments[3] : void 0;
      super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);
      this.simulcastCodecs = /* @__PURE__ */ new Map();
      this.degradationPreference = "balanced";
      this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          this._currentBitrate = 0;
          return;
        }
        let stats;
        try {
          stats = yield this.getSenderStats();
        } catch (e2) {
          this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
            error: e2
          }));
          return;
        }
        const statsMap = new Map(stats.map((s2) => [s2.rid, s2]));
        if (this.prevStats) {
          let totalBitrate = 0;
          statsMap.forEach((s2, key) => {
            var _a;
            const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);
            totalBitrate += computeBitrate(s2, prev);
          });
          this._currentBitrate = totalBitrate;
        }
        this.prevStats = statsMap;
      });
      this.senderLock = new _$1();
    }
    get isSimulcast() {
      if (this.sender && this.sender.getParameters().encodings.length > 1) {
        return true;
      }
      return false;
    }
    /* @internal */
    startMonitor(signalClient) {
      var _a;
      this.signalClient = signalClient;
      if (!isWeb()) {
        return;
      }
      const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();
      if (params) {
        this.encodings = params.encodings;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(() => {
        this.monitorSender();
      }, monitorFrequency);
    }
    stop() {
      this._mediaStreamTrack.getConstraints();
      this.simulcastCodecs.forEach((trackInfo) => {
        trackInfo.mediaStreamTrack.stop();
      });
      super.stop();
    }
    pauseUpstream() {
      const _super = Object.create(null, {
        pauseUpstream: {
          get: () => super.pauseUpstream
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        var _d;
        yield _super.pauseUpstream.call(this);
        try {
          for (var _e2 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e2 = true) {
            _c = _g.value;
            _e2 = false;
            const sc = _c;
            yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (!_e2 && !_a && (_b = _f.return))
              yield _b.call(_f);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    resumeUpstream() {
      const _super = Object.create(null, {
        resumeUpstream: {
          get: () => super.resumeUpstream
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_2, _b, _c;
        var _d;
        yield _super.resumeUpstream.call(this);
        try {
          for (var _e2 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e2 = true) {
            _c = _g.value;
            _e2 = false;
            const sc = _c;
            yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (!_e2 && !_a && (_b = _f.return))
              yield _b.call(_f);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    mute() {
      const _super = Object.create(null, {
        mute: {
          get: () => super.mute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (this.isMuted) {
            this.log.debug("Track already muted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Camera && !this.isUserProvided) {
            this.log.debug("stopping camera track", this.logContext);
            this._mediaStreamTrack.stop();
          }
          yield _super.mute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    unmute() {
      const _super = Object.create(null, {
        unmute: {
          get: () => super.unmute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (!this.isMuted) {
            this.log.debug("Track already unmuted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Camera && !this.isUserProvided) {
            this.log.debug("reacquiring camera track", this.logContext);
            yield this.restartTrack();
          }
          yield _super.unmute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    setTrackMuted(muted) {
      super.setTrackMuted(muted);
      for (const sc of this.simulcastCodecs.values()) {
        sc.mediaStreamTrack.enabled = !muted;
      }
    }
    getSenderStats() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return [];
        }
        const items = [];
        const stats = yield this.sender.getStats();
        stats.forEach((v2) => {
          var _a2;
          if (v2.type === "outbound-rtp") {
            const vs2 = {
              type: "video",
              streamId: v2.id,
              frameHeight: v2.frameHeight,
              frameWidth: v2.frameWidth,
              framesPerSecond: v2.framesPerSecond,
              framesSent: v2.framesSent,
              firCount: v2.firCount,
              pliCount: v2.pliCount,
              nackCount: v2.nackCount,
              packetsSent: v2.packetsSent,
              bytesSent: v2.bytesSent,
              qualityLimitationReason: v2.qualityLimitationReason,
              qualityLimitationDurations: v2.qualityLimitationDurations,
              qualityLimitationResolutionChanges: v2.qualityLimitationResolutionChanges,
              rid: (_a2 = v2.rid) !== null && _a2 !== void 0 ? _a2 : v2.id,
              retransmittedPacketsSent: v2.retransmittedPacketsSent,
              targetBitrate: v2.targetBitrate,
              timestamp: v2.timestamp
            };
            const r2 = stats.get(v2.remoteId);
            if (r2) {
              vs2.jitter = r2.jitter;
              vs2.packetsLost = r2.packetsLost;
              vs2.roundTripTime = r2.roundTripTime;
            }
            items.push(vs2);
          }
        });
        items.sort((a2, b2) => {
          var _a2, _b;
          return ((_a2 = b2.frameWidth) !== null && _a2 !== void 0 ? _a2 : 0) - ((_b = a2.frameWidth) !== null && _b !== void 0 ? _b : 0);
        });
        return items;
      });
    }
    setPublishingQuality(maxQuality) {
      const qualities = [];
      for (let q2 = VideoQuality.LOW; q2 <= VideoQuality.HIGH; q2 += 1) {
        qualities.push(new SubscribedQuality({
          quality: q2,
          enabled: q2 <= maxQuality
        }));
      }
      this.log.debug("setting publishing quality. max quality ".concat(maxQuality), this.logContext);
      this.setPublishingLayers(qualities);
    }
    restartTrack(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_3, _b, _c;
        var _d;
        let constraints;
        if (options) {
          const streamConstraints = constraintsForOptions({
            video: options
          });
          if (typeof streamConstraints.video !== "boolean") {
            constraints = streamConstraints.video;
          }
        }
        yield this.restart(constraints);
        try {
          for (var _e2 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e2 = true) {
            _c = _g.value;
            _e2 = false;
            const sc = _c;
            if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== "closed") {
              sc.mediaStreamTrack = this.mediaStreamTrack.clone();
              yield sc.sender.replaceTrack(sc.mediaStreamTrack);
            }
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (!_e2 && !_a && (_b = _f.return))
              yield _b.call(_f);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      });
    }
    setProcessor(processor_1) {
      const _super = Object.create(null, {
        setProcessor: {
          get: () => super.setProcessor
        }
      });
      return __awaiter(this, arguments, void 0, function(processor) {
        var _this = this;
        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a, e_4, _b, _c;
          var _d, _e2;
          yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);
          if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {
            try {
              for (var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true) {
                _c = _h.value;
                _f = false;
                const sc = _c;
                yield (_e2 = sc.sender) === null || _e2 === void 0 ? void 0 : _e2.replaceTrack(_this.processor.processedTrack);
              }
            } catch (e_4_1) {
              e_4 = {
                error: e_4_1
              };
            } finally {
              try {
                if (!_f && !_a && (_b = _g.return))
                  yield _b.call(_g);
              } finally {
                if (e_4)
                  throw e_4.error;
              }
            }
          }
        }();
      });
    }
    setDegradationPreference(preference) {
      return __awaiter(this, void 0, void 0, function* () {
        this.degradationPreference = preference;
        if (this.sender) {
          try {
            this.log.debug("setting degradationPreference to ".concat(preference), this.logContext);
            const params = this.sender.getParameters();
            params.degradationPreference = preference;
            this.sender.setParameters(params);
          } catch (e2) {
            this.log.warn("failed to set degradationPreference", Object.assign({
              error: e2
            }, this.logContext));
          }
        }
      });
    }
    addSimulcastTrack(codec, encodings) {
      if (this.simulcastCodecs.has(codec)) {
        this.log.error("".concat(codec, " already added, skipping adding simulcast codec"), this.logContext);
        return;
      }
      const simulcastCodecInfo = {
        codec,
        mediaStreamTrack: this.mediaStreamTrack.clone(),
        sender: void 0,
        encodings
      };
      this.simulcastCodecs.set(codec, simulcastCodecInfo);
      return simulcastCodecInfo;
    }
    setSimulcastTrackSender(codec, sender) {
      const simulcastCodecInfo = this.simulcastCodecs.get(codec);
      if (!simulcastCodecInfo) {
        return;
      }
      simulcastCodecInfo.sender = sender;
      setTimeout(() => {
        if (this.subscribedCodecs) {
          this.setPublishingCodecs(this.subscribedCodecs);
        }
      }, refreshSubscribedCodecAfterNewCodec);
    }
    /**
     * @internal
     * Sets codecs that should be publishing, returns new codecs that have not yet
     * been published
     */
    setPublishingCodecs(codecs) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, codecs_1, codecs_1_1;
        var _b, e_5, _c, _d;
        this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
          codecs,
          currentCodec: this.codec
        }));
        if (!this.codec && codecs.length > 0) {
          yield this.setPublishingLayers(codecs[0].qualities);
          return [];
        }
        this.subscribedCodecs = codecs;
        const newCodecs = [];
        try {
          for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true) {
            _d = codecs_1_1.value;
            _a = false;
            const codec = _d;
            if (!this.codec || this.codec === codec.codec) {
              yield this.setPublishingLayers(codec.qualities);
            } else {
              const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);
              this.log.debug("try setPublishingCodec for ".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {
                simulcastCodecInfo
              }));
              if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {
                for (const q2 of codec.qualities) {
                  if (q2.enabled) {
                    newCodecs.push(codec.codec);
                    break;
                  }
                }
              } else if (simulcastCodecInfo.encodings) {
                this.log.debug("try setPublishingLayersForSender ".concat(codec.codec), this.logContext);
                yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);
              }
            }
          }
        } catch (e_5_1) {
          e_5 = {
            error: e_5_1
          };
        } finally {
          try {
            if (!_a && !_b && (_c = codecs_1.return))
              yield _c.call(codecs_1);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
        return newCodecs;
      });
    }
    /**
     * @internal
     * Sets layers that should be publishing
     */
    setPublishingLayers(qualities) {
      return __awaiter(this, void 0, void 0, function* () {
        this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
          qualities
        }));
        if (!this.sender || !this.encodings) {
          return;
        }
        yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);
      });
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!isMobile())
          return;
        if (this.isInBackground && this.source === Track.Source.Camera) {
          this._mediaStreamTrack.enabled = false;
        }
      });
    }
  }
  function setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log2, logContext) {
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield senderLock.lock();
      log2.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, logContext), {
        sender,
        qualities,
        senderEncodings
      }));
      try {
        const params = sender.getParameters();
        const {
          encodings
        } = params;
        if (!encodings) {
          return;
        }
        if (encodings.length !== senderEncodings.length) {
          log2.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, logContext), {
            encodings,
            senderEncodings
          }));
          return;
        }
        let hasChanged = false;
        const closableSpatial = false;
        if (closableSpatial && encodings[0].scalabilityMode)
          ;
        else {
          encodings.forEach((encoding, idx) => {
            var _a;
            let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : "";
            if (rid === "") {
              rid = "q";
            }
            const quality = videoQualityForRid(rid);
            const subscribedQuality = qualities.find((q2) => q2.quality === quality);
            if (!subscribedQuality) {
              return;
            }
            if (encoding.active !== subscribedQuality.enabled) {
              hasChanged = true;
              encoding.active = subscribedQuality.enabled;
              log2.debug("setting layer ".concat(subscribedQuality.quality, " to ").concat(encoding.active ? "enabled" : "disabled"), logContext);
              if (isFireFox()) {
                if (subscribedQuality.enabled) {
                  encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;
                  encoding.maxBitrate = senderEncodings[idx].maxBitrate;
                  encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;
                } else {
                  encoding.scaleResolutionDownBy = 4;
                  encoding.maxBitrate = 10;
                  encoding.maxFrameRate = 2;
                }
              }
            }
          });
        }
        if (hasChanged) {
          params.encodings = encodings;
          log2.debug("setting encodings", Object.assign(Object.assign({}, logContext), {
            encodings: params.encodings
          }));
          yield sender.setParameters(params);
        }
      } finally {
        unlock();
      }
    });
  }
  function videoQualityForRid(rid) {
    switch (rid) {
      case "f":
        return VideoQuality.HIGH;
      case "h":
        return VideoQuality.MEDIUM;
      case "q":
        return VideoQuality.LOW;
      default:
        return VideoQuality.HIGH;
    }
  }
  function videoLayersFromEncodings(width, height, encodings, svc) {
    if (!encodings) {
      return [new VideoLayer({
        quality: VideoQuality.HIGH,
        width,
        height,
        bitrate: 0,
        ssrc: 0
      })];
    }
    if (svc) {
      const encodingSM = encodings[0].scalabilityMode;
      const sm = new ScalabilityMode(encodingSM);
      const layers = [];
      const resRatio = sm.suffix == "h" ? 1.5 : 2;
      const bitratesRatio = sm.suffix == "h" ? 2 : 3;
      for (let i2 = 0; i2 < sm.spatial; i2 += 1) {
        layers.push(new VideoLayer({
          quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i2,
          width: Math.ceil(width / Math.pow(resRatio, i2)),
          height: Math.ceil(height / Math.pow(resRatio, i2)),
          bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i2)) : 0,
          ssrc: 0
        }));
      }
      return layers;
    }
    return encodings.map((encoding) => {
      var _a, _b, _c;
      const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;
      let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : "");
      return new VideoLayer({
        quality,
        width: Math.ceil(width / scale),
        height: Math.ceil(height / scale),
        bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,
        ssrc: 0
      });
    });
  }
  const lossyDataChannel = "_lossy";
  const reliableDataChannel = "_reliable";
  const minReconnectWait = 2 * 1e3;
  const leaveReconnect = "leave-reconnect";
  var PCState;
  (function(PCState2) {
    PCState2[PCState2["New"] = 0] = "New";
    PCState2[PCState2["Connected"] = 1] = "Connected";
    PCState2[PCState2["Disconnected"] = 2] = "Disconnected";
    PCState2[PCState2["Reconnecting"] = 3] = "Reconnecting";
    PCState2[PCState2["Closed"] = 4] = "Closed";
  })(PCState || (PCState = {}));
  class RTCEngine extends eventsExports.EventEmitter {
    get isClosed() {
      return this._isClosed;
    }
    get pendingReconnect() {
      return !!this.reconnectTimeout;
    }
    constructor(options) {
      var _a;
      super();
      this.options = options;
      this.rtcConfig = {};
      this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
      this.fullReconnectOnNext = false;
      this.subscriberPrimary = false;
      this.pcState = PCState.New;
      this._isClosed = true;
      this.pendingTrackResolvers = {};
      this.reconnectAttempts = 0;
      this.reconnectStart = 0;
      this.attemptingReconnect = false;
      this.joinAttempts = 0;
      this.maxJoinAttempts = 1;
      this.shouldFailNext = false;
      this.log = livekitLogger;
      this.handleDataChannel = (_a2) => __awaiter(this, [_a2], void 0, function(_ref) {
        var _this = this;
        let {
          channel
        } = _ref;
        return function* () {
          if (!channel) {
            return;
          }
          if (channel.label === reliableDataChannel) {
            _this.reliableDCSub = channel;
          } else if (channel.label === lossyDataChannel) {
            _this.lossyDCSub = channel;
          } else {
            return;
          }
          _this.log.debug("on data channel ".concat(channel.id, ", ").concat(channel.label), _this.logContext);
          channel.onmessage = _this.handleDataMessage;
        }();
      });
      this.handleDataMessage = (message) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b;
        const unlock = yield this.dataProcessLock.lock();
        try {
          let buffer;
          if (message.data instanceof ArrayBuffer) {
            buffer = message.data;
          } else if (message.data instanceof Blob) {
            buffer = yield message.data.arrayBuffer();
          } else {
            this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
              data: message.data
            }));
            return;
          }
          const dp = DataPacket.fromBinary(new Uint8Array(buffer));
          if (((_a2 = dp.value) === null || _a2 === void 0 ? void 0 : _a2.case) === "speaker") {
            this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);
          } else {
            if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === "user") {
              applyUserDataCompat(dp, dp.value.value);
            }
            this.emit(EngineEvent.DataPacketReceived, dp);
          }
        } finally {
          unlock();
        }
      });
      this.handleDataError = (event) => {
        const channel = event.currentTarget;
        const channelKind = channel.maxRetransmits === 0 ? "lossy" : "reliable";
        if (event instanceof ErrorEvent && event.error) {
          const {
            error
          } = event.error;
          this.log.error("DataChannel error on ".concat(channelKind, ": ").concat(event.message), Object.assign(Object.assign({}, this.logContext), {
            error
          }));
        } else {
          this.log.error("Unknown DataChannel error on ".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {
            event
          }));
        }
      };
      this.handleBufferedAmountLow = (event) => {
        const channel = event.currentTarget;
        const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
        this.updateAndEmitDCBufferStatus(channelKind);
      };
      this.handleDisconnect = (connection, disconnectReason) => {
        if (this._isClosed) {
          return;
        }
        this.log.warn("".concat(connection, " disconnected"), this.logContext);
        if (this.reconnectAttempts === 0) {
          this.reconnectStart = Date.now();
        }
        const disconnect = (duration2) => {
          this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(duration2, "ms. giving up"), this.logContext);
          this.emit(EngineEvent.Disconnected);
          this.close();
        };
        const duration = Date.now() - this.reconnectStart;
        let delay = this.getNextRetryDelay({
          elapsedMs: duration,
          retryCount: this.reconnectAttempts
        });
        if (delay === null) {
          disconnect(duration);
          return;
        }
        if (connection === leaveReconnect) {
          delay = 0;
        }
        this.log.debug("reconnecting in ".concat(delay, "ms"), this.logContext);
        this.clearReconnectTimeout();
        if (this.token && this.regionUrlProvider) {
          this.regionUrlProvider.updateToken(this.token);
        }
        this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason).finally(() => this.reconnectTimeout = void 0), delay);
      };
      this.waitForRestarted = () => {
        return new Promise((resolve, reject) => {
          if (this.pcState === PCState.Connected) {
            resolve();
          }
          const onRestarted = () => {
            this.off(EngineEvent.Disconnected, onDisconnected);
            resolve();
          };
          const onDisconnected = () => {
            this.off(EngineEvent.Restarted, onRestarted);
            reject();
          };
          this.once(EngineEvent.Restarted, onRestarted);
          this.once(EngineEvent.Disconnected, onDisconnected);
        });
      };
      this.updateAndEmitDCBufferStatus = (kind) => {
        const status = this.isBufferStatusLow(kind);
        if (typeof status !== "undefined" && status !== this.dcBufferStatus.get(kind)) {
          this.dcBufferStatus.set(kind, status);
          this.emit(EngineEvent.DCBufferStatusChanged, status, kind);
        }
      };
      this.isBufferStatusLow = (kind) => {
        const dc = this.dataChannelForKind(kind);
        if (dc) {
          return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;
        }
      };
      this.handleBrowserOnLine = () => {
        if (this.client.currentState === SignalConnectionState.RECONNECTING) {
          this.clearReconnectTimeout();
          this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);
        }
      };
      this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);
      this.loggerOptions = {
        loggerName: options.loggerName,
        loggerContextCb: () => this.logContext
      };
      this.client = new SignalClient(void 0, this.loggerOptions);
      this.client.signalLatency = this.options.expSignalLatency;
      this.reconnectPolicy = this.options.reconnectPolicy;
      this.registerOnLineListener();
      this.closingLock = new _$1();
      this.dataProcessLock = new _$1();
      this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);
      this.client.onParticipantUpdate = (updates) => this.emit(EngineEvent.ParticipantUpdate, updates);
      this.client.onConnectionQuality = (update) => this.emit(EngineEvent.ConnectionQualityUpdate, update);
      this.client.onRoomUpdate = (update) => this.emit(EngineEvent.RoomUpdate, update);
      this.client.onSubscriptionError = (resp) => this.emit(EngineEvent.SubscriptionError, resp);
      this.client.onSubscriptionPermissionUpdate = (update) => this.emit(EngineEvent.SubscriptionPermissionUpdate, update);
      this.client.onSpeakersChanged = (update) => this.emit(EngineEvent.SpeakersChanged, update);
      this.client.onStreamStateUpdate = (update) => this.emit(EngineEvent.StreamStateChanged, update);
      this.client.onRequestResponse = (response) => this.emit(EngineEvent.SignalRequestResponse, response);
    }
    /** @internal */
    get logContext() {
      var _a, _b, _c, _d, _e2, _f, _g, _h;
      return {
        room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,
        roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,
        participant: (_f = (_e2 = this.latestJoinResponse) === null || _e2 === void 0 ? void 0 : _e2.participant) === null || _f === void 0 ? void 0 : _f.identity,
        pID: (_h = (_g = this.latestJoinResponse) === null || _g === void 0 ? void 0 : _g.participant) === null || _h === void 0 ? void 0 : _h.sid
      };
    }
    join(url, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        this.url = url;
        this.token = token;
        this.signalOpts = opts;
        this.maxJoinAttempts = opts.maxRetries;
        try {
          this.joinAttempts += 1;
          this.setupSignalClientCallbacks();
          const joinResponse = yield this.client.join(url, token, opts, abortSignal);
          this._isClosed = false;
          this.latestJoinResponse = joinResponse;
          this.subscriberPrimary = joinResponse.subscriberPrimary;
          if (!this.pcManager) {
            yield this.configure(joinResponse);
          }
          if (!this.subscriberPrimary || joinResponse.fastPublish) {
            this.negotiate();
          }
          this.clientConfiguration = joinResponse.clientConfiguration;
          return joinResponse;
        } catch (e2) {
          if (e2 instanceof ConnectionError) {
            if (e2.reason === ConnectionErrorReason.ServerUnreachable) {
              this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext);
              if (this.joinAttempts < this.maxJoinAttempts) {
                return this.join(url, token, opts, abortSignal);
              }
            }
          }
          throw e2;
        }
      });
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.closingLock.lock();
        if (this.isClosed) {
          unlock();
          return;
        }
        try {
          this._isClosed = true;
          this.joinAttempts = 0;
          this.emit(EngineEvent.Closing);
          this.removeAllListeners();
          this.deregisterOnLineListener();
          this.clearPendingReconnect();
          yield this.cleanupPeerConnections();
          yield this.cleanupClient();
        } finally {
          unlock();
        }
      });
    }
    cleanupPeerConnections() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();
        this.pcManager = void 0;
        const dcCleanup = (dc) => {
          if (!dc)
            return;
          dc.close();
          dc.onbufferedamountlow = null;
          dc.onclose = null;
          dc.onclosing = null;
          dc.onerror = null;
          dc.onmessage = null;
          dc.onopen = null;
        };
        dcCleanup(this.lossyDC);
        dcCleanup(this.lossyDCSub);
        dcCleanup(this.reliableDC);
        dcCleanup(this.reliableDCSub);
        this.lossyDC = void 0;
        this.lossyDCSub = void 0;
        this.reliableDC = void 0;
        this.reliableDCSub = void 0;
      });
    }
    cleanupClient() {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.client.close();
        this.client.resetCallbacks();
      });
    }
    addTrack(req) {
      if (this.pendingTrackResolvers[req.cid]) {
        throw new TrackInvalidError("a track with the same ID has already been published");
      }
      return new Promise((resolve, reject) => {
        const publicationTimeout = setTimeout(() => {
          delete this.pendingTrackResolvers[req.cid];
          reject(new ConnectionError("publication of local track timed out, no response from server", ConnectionErrorReason.InternalError));
        }, 1e4);
        this.pendingTrackResolvers[req.cid] = {
          resolve: (info) => {
            clearTimeout(publicationTimeout);
            resolve(info);
          },
          reject: () => {
            clearTimeout(publicationTimeout);
            reject(new Error("Cancelled publication by calling unpublish"));
          }
        };
        this.client.sendAddTrack(req);
      });
    }
    /**
     * Removes sender from PeerConnection, returning true if it was removed successfully
     * and a negotiation is necessary
     * @param sender
     * @returns
     */
    removeTrack(sender) {
      if (sender.track && this.pendingTrackResolvers[sender.track.id]) {
        const {
          reject
        } = this.pendingTrackResolvers[sender.track.id];
        if (reject) {
          reject();
        }
        delete this.pendingTrackResolvers[sender.track.id];
      }
      try {
        this.pcManager.removeTrack(sender);
        return true;
      } catch (e2) {
        this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
          error: e2
        }));
      }
      return false;
    }
    updateMuteStatus(trackSid, muted) {
      this.client.sendMuteTrack(trackSid, muted);
    }
    get dataSubscriberReadyState() {
      var _a;
      return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;
    }
    getConnectedServerAddress() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();
      });
    }
    /* @internal */
    setRegionUrlProvider(provider) {
      this.regionUrlProvider = provider;
    }
    configure(joinResponse) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {
          return;
        }
        this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;
        const rtcConfig = this.makeRTCConfiguration(joinResponse);
        this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);
        this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);
        this.pcManager.onIceCandidate = (candidate, target) => {
          this.client.sendIceCandidate(candidate, target);
        };
        this.pcManager.onPublisherOffer = (offer) => {
          this.client.sendOffer(offer);
        };
        this.pcManager.onDataChannel = this.handleDataChannel;
        this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) => __awaiter(this, void 0, void 0, function* () {
          this.log.debug("primary PC state changed ".concat(connectionState), this.logContext);
          if (["closed", "disconnected", "failed"].includes(publisherState)) {
            this.publisherConnectionPromise = void 0;
          }
          if (connectionState === PCTransportState.CONNECTED) {
            const shouldEmit = this.pcState === PCState.New;
            this.pcState = PCState.Connected;
            if (shouldEmit) {
              this.emit(EngineEvent.Connected, joinResponse);
            }
          } else if (connectionState === PCTransportState.FAILED) {
            if (this.pcState === PCState.Connected) {
              this.pcState = PCState.Disconnected;
              this.handleDisconnect("peerconnection failed", subscriberState === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);
            }
          }
          const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;
          const isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);
          if (isSignalSevered && isPCSevered && !this._isClosed) {
            this.emit(EngineEvent.Offline);
          }
        });
        this.pcManager.onTrack = (ev) => {
          this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
        };
        if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {
          this.createDataChannels();
        }
      });
    }
    setupSignalClientCallbacks() {
      this.client.onAnswer = (sd) => __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          return;
        }
        this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
          RTCSdpType: sd.type
        }));
        yield this.pcManager.setPublisherAnswer(sd);
      });
      this.client.onTrickle = (candidate, target) => {
        if (!this.pcManager) {
          return;
        }
        this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
          candidate,
          target
        }));
        this.pcManager.addIceCandidate(candidate, target);
      };
      this.client.onOffer = (sd) => __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          return;
        }
        const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);
        this.client.sendAnswer(answer);
      });
      this.client.onLocalTrackPublished = (res) => {
        var _a;
        this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
          cid: res.cid,
          track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid
        }));
        if (!this.pendingTrackResolvers[res.cid]) {
          this.log.error("missing track resolver for ".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {
            cid: res.cid
          }));
          return;
        }
        const {
          resolve
        } = this.pendingTrackResolvers[res.cid];
        delete this.pendingTrackResolvers[res.cid];
        resolve(res.track);
      };
      this.client.onLocalTrackUnpublished = (response) => {
        this.emit(EngineEvent.LocalTrackUnpublished, response);
      };
      this.client.onLocalTrackSubscribed = (trackSid) => {
        this.emit(EngineEvent.LocalTrackSubscribed, trackSid);
      };
      this.client.onTokenRefresh = (token) => {
        this.token = token;
      };
      this.client.onRemoteMuteChanged = (trackSid, muted) => {
        this.emit(EngineEvent.RemoteMute, trackSid, muted);
      };
      this.client.onSubscribedQualityUpdate = (update) => {
        this.emit(EngineEvent.SubscribedQualityUpdate, update);
      };
      this.client.onClose = () => {
        this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
      };
      this.client.onLeave = (leave) => {
        this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
          reason: leave === null || leave === void 0 ? void 0 : leave.reason
        }));
        if (leave.regions && this.regionUrlProvider) {
          this.log.debug("updating regions", this.logContext);
          this.regionUrlProvider.setServerReportedRegions(leave.regions);
        }
        switch (leave.action) {
          case LeaveRequest_Action.DISCONNECT:
            this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);
            this.close();
            break;
          case LeaveRequest_Action.RECONNECT:
            this.fullReconnectOnNext = true;
            this.handleDisconnect(leaveReconnect);
            break;
          case LeaveRequest_Action.RESUME:
            this.handleDisconnect(leaveReconnect);
        }
      };
    }
    makeRTCConfiguration(serverResponse) {
      var _a;
      const rtcConfig = Object.assign({}, this.rtcConfig);
      if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {
        this.log.debug("E2EE - setting up transports with insertable streams", this.logContext);
        rtcConfig.encodedInsertableStreams = true;
      }
      if (serverResponse.iceServers && !rtcConfig.iceServers) {
        const rtcIceServers = [];
        serverResponse.iceServers.forEach((iceServer) => {
          const rtcIceServer = {
            urls: iceServer.urls
          };
          if (iceServer.username)
            rtcIceServer.username = iceServer.username;
          if (iceServer.credential) {
            rtcIceServer.credential = iceServer.credential;
          }
          rtcIceServers.push(rtcIceServer);
        });
        rtcConfig.iceServers = rtcIceServers;
      }
      if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {
        rtcConfig.iceTransportPolicy = "relay";
      }
      rtcConfig.sdpSemantics = "unified-plan";
      rtcConfig.continualGatheringPolicy = "gather_continually";
      return rtcConfig;
    }
    createDataChannels() {
      if (!this.pcManager) {
        return;
      }
      if (this.lossyDC) {
        this.lossyDC.onmessage = null;
        this.lossyDC.onerror = null;
      }
      if (this.reliableDC) {
        this.reliableDC.onmessage = null;
        this.reliableDC.onerror = null;
      }
      this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
        // will drop older packets that arrive
        ordered: true,
        maxRetransmits: 0
      });
      this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
        ordered: true
      });
      this.lossyDC.onmessage = this.handleDataMessage;
      this.reliableDC.onmessage = this.handleDataMessage;
      this.lossyDC.onerror = this.handleDataError;
      this.reliableDC.onerror = this.handleDataError;
      this.lossyDC.bufferedAmountLowThreshold = 65535;
      this.reliableDC.bufferedAmountLowThreshold = 65535;
      this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;
      this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;
    }
    createSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (supportsTransceiver()) {
          const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);
          return sender;
        }
        if (supportsAddTrack()) {
          this.log.warn("using add-track fallback", this.logContext);
          const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);
          return sender;
        }
        throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
      });
    }
    createSimulcastSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (supportsTransceiver()) {
          return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);
        }
        if (supportsAddTrack()) {
          this.log.debug("using add-track fallback", this.logContext);
          return this.createRTCRtpSender(track.mediaStreamTrack);
        }
        throw new UnexpectedConnectionState("Cannot stream on this device");
      });
    }
    createTransceiverRTCRtpSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        const streams = [];
        if (track.mediaStream) {
          streams.push(track.mediaStream);
        }
        if (isVideoTrack(track)) {
          track.codec = opts.videoCodec;
        }
        const transceiverInit = {
          direction: "sendonly",
          streams
        };
        if (encodings) {
          transceiverInit.sendEncodings = encodings;
        }
        const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);
        return transceiver.sender;
      });
    }
    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        const transceiverInit = {
          direction: "sendonly"
        };
        if (encodings) {
          transceiverInit.sendEncodings = encodings;
        }
        const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);
        if (!opts.videoCodec) {
          return;
        }
        track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);
        return transceiver.sender;
      });
    }
    createRTCRtpSender(track) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        return this.pcManager.addPublisherTrack(track);
      });
    }
    attemptReconnect(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (this._isClosed) {
          return;
        }
        if (this.attemptingReconnect) {
          livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {
          this.fullReconnectOnNext = true;
        }
        try {
          this.attemptingReconnect = true;
          if (this.fullReconnectOnNext) {
            yield this.restartConnection();
          } else {
            yield this.resumeConnection(reason);
          }
          this.clearPendingReconnect();
          this.fullReconnectOnNext = false;
        } catch (e2) {
          this.reconnectAttempts += 1;
          let recoverable = true;
          if (e2 instanceof UnexpectedConnectionState) {
            this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
              error: e2
            }));
            recoverable = false;
          } else if (!(e2 instanceof SignalReconnectError)) {
            this.fullReconnectOnNext = true;
          }
          if (recoverable) {
            this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN);
          } else {
            this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext);
            this.emit(EngineEvent.Disconnected);
            yield this.close();
          }
        } finally {
          this.attemptingReconnect = false;
        }
      });
    }
    getNextRetryDelay(context) {
      try {
        return this.reconnectPolicy.nextRetryDelayInMs(context);
      } catch (e2) {
        this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
          error: e2
        }));
      }
      return null;
    }
    restartConnection(regionUrl) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        try {
          if (!this.url || !this.token) {
            throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
          }
          this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext);
          this.emit(EngineEvent.Restarting);
          if (!this.client.isDisconnected) {
            yield this.client.sendLeave();
          }
          yield this.cleanupPeerConnections();
          yield this.cleanupClient();
          let joinResponse;
          try {
            if (!this.signalOpts) {
              this.log.warn("attempted connection restart, without signal options present", this.logContext);
              throw new SignalReconnectError();
            }
            joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);
          } catch (e2) {
            if (e2 instanceof ConnectionError && e2.reason === ConnectionErrorReason.NotAllowed) {
              throw new UnexpectedConnectionState("could not reconnect, token might be expired");
            }
            throw new SignalReconnectError();
          }
          if (this.shouldFailNext) {
            this.shouldFailNext = false;
            throw new Error("simulated failure");
          }
          this.client.setReconnected();
          this.emit(EngineEvent.SignalRestarted, joinResponse);
          yield this.waitForPCReconnected();
          if (this.client.currentState !== SignalConnectionState.CONNECTED) {
            throw new SignalReconnectError("Signal connection got severed during reconnect");
          }
          (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();
          this.emit(EngineEvent.Restarted);
        } catch (error) {
          const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();
          if (nextRegionUrl) {
            yield this.restartConnection(nextRegionUrl);
            return;
          } else {
            (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();
            throw error;
          }
        }
      });
    }
    resumeConnection(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!this.url || !this.token) {
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        }
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher and subscriber connections unset");
        }
        this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext);
        this.emit(EngineEvent.Resuming);
        let res;
        try {
          this.setupSignalClientCallbacks();
          res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);
        } catch (error) {
          let message = "";
          if (error instanceof Error) {
            message = error.message;
            this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {
              error
            }));
          }
          if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {
            throw new UnexpectedConnectionState("could not reconnect, token might be expired");
          }
          if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {
            throw error;
          }
          throw new SignalReconnectError(message);
        }
        this.emit(EngineEvent.SignalResumed);
        if (res) {
          const rtcConfig = this.makeRTCConfiguration(res);
          this.pcManager.updateConfiguration(rtcConfig);
        } else {
          this.log.warn("Did not receive reconnect response", this.logContext);
        }
        if (this.shouldFailNext) {
          this.shouldFailNext = false;
          throw new Error("simulated failure");
        }
        yield this.pcManager.triggerIceRestart();
        yield this.waitForPCReconnected();
        if (this.client.currentState !== SignalConnectionState.CONNECTED) {
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        }
        this.client.setReconnected();
        if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === "open" && this.reliableDC.id === null) {
          this.createDataChannels();
        }
        this.emit(EngineEvent.Resumed);
      });
    }
    waitForPCInitialConnection(timeout2, abortController) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("PC manager is closed");
        }
        yield this.pcManager.ensurePCTransportConnection(abortController, timeout2);
      });
    }
    waitForPCReconnected() {
      return __awaiter(this, void 0, void 0, function* () {
        this.pcState = PCState.Reconnecting;
        this.log.debug("waiting for peer connection to reconnect", this.logContext);
        try {
          yield sleep(minReconnectWait);
          if (!this.pcManager) {
            throw new UnexpectedConnectionState("PC manager is closed");
          }
          yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout);
          this.pcState = PCState.Connected;
        } catch (e2) {
          this.pcState = PCState.Disconnected;
          throw new ConnectionError("could not establish PC connection, ".concat(e2.message), ConnectionErrorReason.InternalError);
        }
      });
    }
    /** @internal */
    publishRpcResponse(destinationIdentity, requestId, payload, error) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcResponse",
            value: new RpcResponse({
              requestId,
              value: error ? {
                case: "error",
                value: error.toProto()
              } : {
                case: "payload",
                value: payload !== null && payload !== void 0 ? payload : ""
              }
            })
          }
        });
        yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    publishRpcAck(destinationIdentity, requestId) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcAck",
            value: new RpcAck({
              requestId
            })
          }
        });
        yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /* @internal */
    sendDataPacket(packet, kind) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = packet.toBinary();
        yield this.ensurePublisherConnected(kind);
        const dc = this.dataChannelForKind(kind);
        if (dc) {
          dc.send(msg);
        }
        this.updateAndEmitDCBufferStatus(kind);
      });
    }
    waitForBufferStatusLow(kind) {
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        if (this.isBufferStatusLow(kind)) {
          resolve();
        } else {
          const onClosing = () => reject("Engine closed");
          this.once(EngineEvent.Closing, onClosing);
          while (!this.dcBufferStatus.get(kind)) {
            yield sleep(10);
          }
          this.off(EngineEvent.Closing, onClosing);
          resolve();
        }
      }));
    }
    /**
     * @internal
     */
    ensureDataTransportConnected(kind_1) {
      return __awaiter(this, arguments, void 0, function(kind) {
        var _this2 = this;
        let subscriber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
        return function* () {
          var _a;
          if (!_this2.pcManager) {
            throw new UnexpectedConnectionState("PC manager is closed");
          }
          const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;
          const transportName = subscriber ? "Subscriber" : "Publisher";
          if (!transport) {
            throw new ConnectionError("".concat(transportName, " connection not set"), ConnectionErrorReason.InternalError);
          }
          let needNegotiation = false;
          if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {
            _this2.createDataChannels();
            needNegotiation = true;
          }
          if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== "checking") {
            needNegotiation = true;
          }
          if (needNegotiation) {
            _this2.negotiate();
          }
          const targetChannel = _this2.dataChannelForKind(kind, subscriber);
          if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === "open") {
            return;
          }
          const endTime = (/* @__PURE__ */ new Date()).getTime() + _this2.peerConnectionTimeout;
          while ((/* @__PURE__ */ new Date()).getTime() < endTime) {
            if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === "open") {
              return;
            }
            yield sleep(50);
          }
          throw new ConnectionError("could not establish ".concat(transportName, " connection, state: ").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);
        }();
      });
    }
    ensurePublisherConnected(kind) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.publisherConnectionPromise) {
          this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);
        }
        yield this.publisherConnectionPromise;
      });
    }
    /* @internal */
    verifyTransport() {
      if (!this.pcManager) {
        return false;
      }
      if (this.pcManager.currentState !== PCTransportState.CONNECTED) {
        return false;
      }
      if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {
        return false;
      }
      return true;
    }
    /** @internal */
    negotiate() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          if (!this.pcManager) {
            reject(new NegotiationError("PC manager is closed"));
            return;
          }
          this.pcManager.requirePublisher();
          if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {
            this.createDataChannels();
          }
          const abortController = new AbortController();
          const handleClosed = () => {
            abortController.abort();
            this.log.debug("engine disconnected while negotiation was ongoing", this.logContext);
            resolve();
            return;
          };
          if (this.isClosed) {
            reject("cannot negotiate on closed engine");
          }
          this.on(EngineEvent.Closing, handleClosed);
          this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes) => {
            const rtpMap = /* @__PURE__ */ new Map();
            rtpTypes.forEach((rtp) => {
              const codec = rtp.codec.toLowerCase();
              if (isVideoCodec(codec)) {
                rtpMap.set(rtp.payload, codec);
              }
            });
            this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);
          });
          try {
            yield this.pcManager.negotiate(abortController);
            resolve();
          } catch (e2) {
            if (e2 instanceof NegotiationError) {
              this.fullReconnectOnNext = true;
            }
            this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN);
            reject(e2);
          } finally {
            this.off(EngineEvent.Closing, handleClosed);
          }
        }));
      });
    }
    dataChannelForKind(kind, sub) {
      if (!sub) {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDC;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDC;
        }
      } else {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDCSub;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDCSub;
        }
      }
    }
    /** @internal */
    sendSyncState(remoteTracks, localTracks) {
      var _a, _b;
      if (!this.pcManager) {
        this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
        return;
      }
      const previousAnswer = this.pcManager.subscriber.getLocalDescription();
      const previousOffer = this.pcManager.subscriber.getRemoteDescription();
      const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;
      const trackSids = new Array();
      const trackSidsDisabled = new Array();
      remoteTracks.forEach((track) => {
        if (track.isDesired !== autoSubscribe) {
          trackSids.push(track.trackSid);
        }
        if (!track.isEnabled) {
          trackSidsDisabled.push(track.trackSid);
        }
      });
      this.client.sendSyncState(new SyncState({
        answer: previousAnswer ? toProtoSessionDescription({
          sdp: previousAnswer.sdp,
          type: previousAnswer.type
        }) : void 0,
        offer: previousOffer ? toProtoSessionDescription({
          sdp: previousOffer.sdp,
          type: previousOffer.type
        }) : void 0,
        subscription: new UpdateSubscription({
          trackSids,
          subscribe: !autoSubscribe,
          participantTracks: []
        }),
        publishTracks: getTrackPublicationInfo(localTracks),
        dataChannels: this.dataChannelsInfo(),
        trackSidsDisabled
      }));
    }
    /* @internal */
    failNext() {
      this.shouldFailNext = true;
    }
    dataChannelsInfo() {
      const infos = [];
      const getInfo = (dc, target) => {
        if ((dc === null || dc === void 0 ? void 0 : dc.id) !== void 0 && dc.id !== null) {
          infos.push(new DataChannelInfo({
            label: dc.label,
            id: dc.id,
            target
          }));
        }
      };
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);
      return infos;
    }
    clearReconnectTimeout() {
      if (this.reconnectTimeout) {
        CriticalTimers.clearTimeout(this.reconnectTimeout);
      }
    }
    clearPendingReconnect() {
      this.clearReconnectTimeout();
      this.reconnectAttempts = 0;
    }
    registerOnLineListener() {
      if (isWeb()) {
        window.addEventListener("online", this.handleBrowserOnLine);
      }
    }
    deregisterOnLineListener() {
      if (isWeb()) {
        window.removeEventListener("online", this.handleBrowserOnLine);
      }
    }
  }
  class SignalReconnectError extends Error {
  }
  function supportOptionalDatachannel(protocol) {
    return protocol !== void 0 && protocol > 13;
  }
  function applyUserDataCompat(newObj, oldObj) {
    const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;
    newObj.participantIdentity = participantIdentity;
    oldObj.participantIdentity = participantIdentity;
    const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;
    newObj.destinationIdentities = destinationIdentities;
    oldObj.destinationIdentities = destinationIdentities;
  }
  class RegionUrlProvider {
    constructor(url, token) {
      this.lastUpdateAt = 0;
      this.settingsCacheTime = 3e3;
      this.attemptedRegions = [];
      this.serverUrl = new URL(url);
      this.token = token;
    }
    updateToken(token) {
      this.token = token;
    }
    isCloud() {
      return isCloud(this.serverUrl);
    }
    getServerUrl() {
      return this.serverUrl;
    }
    getNextBestRegionUrl(abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.isCloud()) {
          throw Error("region availability is only supported for LiveKit Cloud domains");
        }
        if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {
          this.regionSettings = yield this.fetchRegionSettings(abortSignal);
        }
        const regionsLeft = this.regionSettings.regions.filter((region) => !this.attemptedRegions.find((attempted) => attempted.url === region.url));
        if (regionsLeft.length > 0) {
          const nextRegion = regionsLeft[0];
          this.attemptedRegions.push(nextRegion);
          livekitLogger.debug("next region: ".concat(nextRegion.region));
          return nextRegion.url;
        } else {
          return null;
        }
      });
    }
    resetAttempts() {
      this.attemptedRegions = [];
    }
    /* @internal */
    fetchRegionSettings(signal) {
      return __awaiter(this, void 0, void 0, function* () {
        const regionSettingsResponse = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
          headers: {
            authorization: "Bearer ".concat(this.token)
          },
          signal
        });
        if (regionSettingsResponse.ok) {
          const regionSettings = yield regionSettingsResponse.json();
          this.lastUpdateAt = Date.now();
          return regionSettings;
        } else {
          throw new ConnectionError("Could not fetch region settings: ".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);
        }
      });
    }
    setServerReportedRegions(regions) {
      this.regionSettings = regions;
      this.lastUpdateAt = Date.now();
    }
  }
  function getCloudConfigUrl(serverUrl) {
    return "".concat(serverUrl.protocol.replace("ws", "http"), "//").concat(serverUrl.host, "/settings");
  }
  class BaseStreamReader {
    get info() {
      return this._info;
    }
    constructor(info, stream, totalByteSize) {
      this.reader = stream;
      this.totalByteSize = totalByteSize;
      this._info = info;
      this.bytesReceived = 0;
    }
  }
  class ByteStreamReader extends BaseStreamReader {
    handleChunkReceived(chunk) {
      var _a;
      this.bytesReceived += chunk.content.byteLength;
      const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : void 0;
      (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);
    }
    [Symbol.asyncIterator]() {
      const reader = this.reader.getReader();
      return {
        next: () => __awaiter(this, void 0, void 0, function* () {
          try {
            const {
              done,
              value
            } = yield reader.read();
            if (done) {
              return {
                done: true,
                value: void 0
              };
            } else {
              this.handleChunkReceived(value);
              return {
                done: false,
                value: value.content
              };
            }
          } catch (error) {
            return {
              done: true,
              value: void 0
            };
          }
        }),
        return() {
          return __awaiter(this, void 0, void 0, function* () {
            reader.releaseLock();
            return {
              done: true,
              value: void 0
            };
          });
        }
      };
    }
    readAll() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        let chunks = /* @__PURE__ */ new Set();
        try {
          for (var _d = true, _e2 = __asyncValues(this), _f; _f = yield _e2.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const chunk = _c;
            chunks.add(chunk);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (!_d && !_a && (_b = _e2.return))
              yield _b.call(_e2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return Array.from(chunks);
      });
    }
  }
  class TextStreamReader extends BaseStreamReader {
    /**
     * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string
     * that has been received up to the current point in time.
     */
    constructor(info, stream, totalChunkCount) {
      super(info, stream, totalChunkCount);
      this.receivedChunks = /* @__PURE__ */ new Map();
    }
    handleChunkReceived(chunk) {
      var _a;
      const index = bigIntToNumber(chunk.chunkIndex);
      const previousChunkAtIndex = this.receivedChunks.get(index);
      if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {
        return;
      }
      this.receivedChunks.set(index, chunk);
      this.bytesReceived += chunk.content.byteLength;
      const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : void 0;
      (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);
    }
    /**
     * Async iterator implementation to allow usage of `for await...of` syntax.
     * Yields structured chunks from the stream.
     *
     */
    [Symbol.asyncIterator]() {
      const reader = this.reader.getReader();
      const decoder = new TextDecoder();
      return {
        next: () => __awaiter(this, void 0, void 0, function* () {
          try {
            const {
              done,
              value
            } = yield reader.read();
            if (done) {
              return {
                done: true,
                value: void 0
              };
            } else {
              this.handleChunkReceived(value);
              return {
                done: false,
                value: {
                  index: bigIntToNumber(value.chunkIndex),
                  current: decoder.decode(value.content),
                  collected: Array.from(this.receivedChunks.values()).sort((a2, b2) => bigIntToNumber(a2.chunkIndex) - bigIntToNumber(b2.chunkIndex)).map((chunk) => decoder.decode(chunk.content)).join("")
                }
              };
            }
          } catch (error) {
            return {
              done: true,
              value: void 0
            };
          }
        }),
        return() {
          return __awaiter(this, void 0, void 0, function* () {
            reader.releaseLock();
            return {
              done: true,
              value: void 0
            };
          });
        }
      };
    }
    readAll() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_2, _b, _c;
        let latestString = "";
        try {
          for (var _d = true, _e2 = __asyncValues(this), _f; _f = yield _e2.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const {
              collected
            } = _c;
            latestString = collected;
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (!_d && !_a && (_b = _e2.return))
              yield _b.call(_e2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        return latestString;
      });
    }
  }
  class BaseStreamWriter {
    constructor(writableStream, info, onClose) {
      this.writableStream = writableStream;
      this.defaultWriter = writableStream.getWriter();
      this.onClose = onClose;
      this.info = info;
    }
    write(chunk) {
      return this.defaultWriter.write([chunk]);
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield this.defaultWriter.close();
        this.defaultWriter.releaseLock();
        (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
  }
  class TextStreamWriter extends BaseStreamWriter {
  }
  class RemoteTrack extends Track {
    constructor(mediaTrack, sid, kind, receiver, loggerOptions) {
      super(mediaTrack, kind, loggerOptions);
      this.sid = sid;
      this.receiver = receiver;
    }
    get isLocal() {
      return false;
    }
    /** @internal */
    setMuted(muted) {
      if (this.isMuted !== muted) {
        this.isMuted = muted;
        this._mediaStreamTrack.enabled = !muted;
        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
      }
    }
    /** @internal */
    setMediaStream(stream) {
      this.mediaStream = stream;
      const onRemoveTrack = (event) => {
        if (event.track === this._mediaStreamTrack) {
          stream.removeEventListener("removetrack", onRemoveTrack);
          if (this.receiver && "playoutDelayHint" in this.receiver) {
            this.receiver.playoutDelayHint = void 0;
          }
          this.receiver = void 0;
          this._currentBitrate = 0;
          this.emit(TrackEvent.Ended, this);
        }
      };
      stream.addEventListener("removetrack", onRemoveTrack);
    }
    start() {
      this.startMonitor();
      super.enable();
    }
    stop() {
      this.stopMonitor();
      super.disable();
    }
    /**
     * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
    getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return;
        }
        const statsReport = yield this.receiver.getStats();
        return statsReport;
      });
    }
    /**
     * Allows to set a playout delay (in seconds) for this track.
     * A higher value allows for more buffering of the track in the browser
     * and will result in a delay of media being played back of `delayInSeconds`
     */
    setPlayoutDelay(delayInSeconds) {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver) {
          this.receiver.playoutDelayHint = delayInSeconds;
        } else {
          this.log.warn("Playout delay not supported in this browser");
        }
      } else {
        this.log.warn("Cannot set playout delay, track already ended");
      }
    }
    /**
     * Returns the current playout delay (in seconds) of this track.
     */
    getPlayoutDelay() {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver) {
          return this.receiver.playoutDelayHint;
        } else {
          this.log.warn("Playout delay not supported in this browser");
        }
      } else {
        this.log.warn("Cannot get playout delay, track already ended");
      }
      return 0;
    }
    /* @internal */
    startMonitor() {
      if (!this.monitorInterval) {
        this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);
      }
      if (supportsSynchronizationSources()) {
        this.registerTimeSyncUpdate();
      }
    }
    registerTimeSyncUpdate() {
      const loop = () => {
        var _a;
        this.timeSyncHandle = requestAnimationFrame(() => loop());
        const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];
        if (sources) {
          const {
            timestamp,
            rtpTimestamp
          } = sources;
          if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {
            this.emit(TrackEvent.TimeSyncUpdate, {
              timestamp,
              rtpTimestamp
            });
            this.rtpTimestamp = rtpTimestamp;
          }
        }
      };
      loop();
    }
  }
  class RemoteAudioTrack extends RemoteTrack {
    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {
      super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);
      this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver) {
          this._currentBitrate = 0;
          return;
        }
        const stats = yield this.getReceiverStats();
        if (stats && this.prevStats && this.receiver) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.audioContext = audioContext;
      this.webAudioPluginNodes = [];
      if (audioOutput) {
        this.sinkId = audioOutput.deviceId;
      }
    }
    /**
     * sets the volume for all attached audio elements
     */
    setVolume(volume) {
      var _a;
      for (const el of this.attachedElements) {
        if (this.audioContext) {
          (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);
        } else {
          el.volume = volume;
        }
      }
      if (isReactNative()) {
        this._mediaStreamTrack._setVolume(volume);
      }
      this.elementVolume = volume;
    }
    /**
     * gets the volume of attached audio elements (loudest)
     */
    getVolume() {
      if (this.elementVolume) {
        return this.elementVolume;
      }
      if (isReactNative()) {
        return 1;
      }
      let highestVolume = 0;
      this.attachedElements.forEach((element) => {
        if (element.volume > highestVolume) {
          highestVolume = element.volume;
        }
      });
      return highestVolume;
    }
    /**
     * calls setSinkId on all attached elements, if supported
     * @param deviceId audio output device
     */
    setSinkId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        this.sinkId = deviceId;
        yield Promise.all(this.attachedElements.map((elm) => {
          if (!supportsSetSinkId(elm)) {
            return;
          }
          return elm.setSinkId(deviceId);
        }));
      });
    }
    attach(element) {
      const needsNewWebAudioConnection = this.attachedElements.length === 0;
      if (!element) {
        element = super.attach();
      } else {
        super.attach(element);
      }
      if (this.sinkId && supportsSetSinkId(element)) {
        element.setSinkId(this.sinkId);
      }
      if (this.audioContext && needsNewWebAudioConnection) {
        this.log.debug("using audio context mapping", this.logContext);
        this.connectWebAudio(this.audioContext, element);
        element.volume = 0;
        element.muted = true;
      }
      if (this.elementVolume) {
        this.setVolume(this.elementVolume);
      }
      return element;
    }
    detach(element) {
      let detached;
      if (!element) {
        detached = super.detach();
        this.disconnectWebAudio();
      } else {
        detached = super.detach(element);
        if (this.audioContext) {
          if (this.attachedElements.length > 0) {
            this.connectWebAudio(this.audioContext, this.attachedElements[0]);
          } else {
            this.disconnectWebAudio();
          }
        }
      }
      return detached;
    }
    /**
     * @internal
     * @experimental
     */
    setAudioContext(audioContext) {
      this.audioContext = audioContext;
      if (audioContext && this.attachedElements.length > 0) {
        this.connectWebAudio(audioContext, this.attachedElements[0]);
      } else if (!audioContext) {
        this.disconnectWebAudio();
      }
    }
    /**
     * @internal
     * @experimental
     * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
     */
    setWebAudioPlugins(nodes) {
      this.webAudioPluginNodes = nodes;
      if (this.attachedElements.length > 0 && this.audioContext) {
        this.connectWebAudio(this.audioContext, this.attachedElements[0]);
      }
    }
    connectWebAudio(context, element) {
      this.disconnectWebAudio();
      this.sourceNode = context.createMediaStreamSource(element.srcObject);
      let lastNode = this.sourceNode;
      this.webAudioPluginNodes.forEach((node) => {
        lastNode.connect(node);
        lastNode = node;
      });
      this.gainNode = context.createGain();
      lastNode.connect(this.gainNode);
      this.gainNode.connect(context.destination);
      if (this.elementVolume) {
        this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);
      }
      if (context.state !== "running") {
        context.resume().then(() => {
          if (context.state !== "running") {
            this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
          }
        }).catch((e2) => {
          this.emit(TrackEvent.AudioPlaybackFailed, e2);
        });
      }
    }
    disconnectWebAudio() {
      var _a, _b;
      (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();
      (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();
      this.gainNode = void 0;
      this.sourceNode = void 0;
    }
    getReceiverStats() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) {
          return;
        }
        const stats = yield this.receiver.getStats();
        let receiverStats;
        stats.forEach((v2) => {
          if (v2.type === "inbound-rtp") {
            receiverStats = {
              type: "audio",
              streamId: v2.id,
              timestamp: v2.timestamp,
              jitter: v2.jitter,
              bytesReceived: v2.bytesReceived,
              concealedSamples: v2.concealedSamples,
              concealmentEvents: v2.concealmentEvents,
              silentConcealedSamples: v2.silentConcealedSamples,
              silentConcealmentEvents: v2.silentConcealmentEvents,
              totalAudioEnergy: v2.totalAudioEnergy,
              totalSamplesDuration: v2.totalSamplesDuration
            };
          }
        });
        return receiverStats;
      });
    }
  }
  const REACTION_DELAY = 100;
  class RemoteVideoTrack extends RemoteTrack {
    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {
      super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);
      this.elementInfos = [];
      this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver) {
          this._currentBitrate = 0;
          return;
        }
        const stats = yield this.getReceiverStats();
        if (stats && this.prevStats && this.receiver) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.debouncedHandleResize = r$1(() => {
        this.updateDimensions();
      }, REACTION_DELAY);
      this.adaptiveStreamSettings = adaptiveStreamSettings;
    }
    get isAdaptiveStream() {
      return this.adaptiveStreamSettings !== void 0;
    }
    /**
     * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
     */
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    /** @internal */
    setMuted(muted) {
      super.setMuted(muted);
      this.attachedElements.forEach((element) => {
        if (muted) {
          detachTrack(this._mediaStreamTrack, element);
        } else {
          attachToElement(this._mediaStreamTrack, element);
        }
      });
    }
    attach(element) {
      if (!element) {
        element = super.attach();
      } else {
        super.attach(element);
      }
      if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info.element === element) === void 0) {
        const elementInfo = new HTMLElementInfo(element);
        this.observeElementInfo(elementInfo);
      }
      return element;
    }
    /**
     * Observe an ElementInfo for changes when adaptive streaming.
     * @param elementInfo
     * @internal
     */
    observeElementInfo(elementInfo) {
      if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info === elementInfo) === void 0) {
        elementInfo.handleResize = () => {
          this.debouncedHandleResize();
        };
        elementInfo.handleVisibilityChanged = () => {
          this.updateVisibility();
        };
        this.elementInfos.push(elementInfo);
        elementInfo.observe();
        this.debouncedHandleResize();
        this.updateVisibility();
      } else {
        this.log.warn("visibility resize observer not triggered", this.logContext);
      }
    }
    /**
     * Stop observing an ElementInfo for changes.
     * @param elementInfo
     * @internal
     */
    stopObservingElementInfo(elementInfo) {
      if (!this.isAdaptiveStream) {
        this.log.warn("stopObservingElementInfo ignored", this.logContext);
        return;
      }
      const stopElementInfos = this.elementInfos.filter((info) => info === elementInfo);
      for (const info of stopElementInfos) {
        info.stopObserving();
      }
      this.elementInfos = this.elementInfos.filter((info) => info !== elementInfo);
      this.updateVisibility();
      this.debouncedHandleResize();
    }
    detach(element) {
      let detachedElements = [];
      if (element) {
        this.stopObservingElement(element);
        return super.detach(element);
      }
      detachedElements = super.detach();
      for (const e2 of detachedElements) {
        this.stopObservingElement(e2);
      }
      return detachedElements;
    }
    /** @internal */
    getDecoderImplementation() {
      var _a;
      return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;
    }
    getReceiverStats() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) {
          return;
        }
        const stats = yield this.receiver.getStats();
        let receiverStats;
        let codecID = "";
        let codecs = /* @__PURE__ */ new Map();
        stats.forEach((v2) => {
          if (v2.type === "inbound-rtp") {
            codecID = v2.codecId;
            receiverStats = {
              type: "video",
              streamId: v2.id,
              framesDecoded: v2.framesDecoded,
              framesDropped: v2.framesDropped,
              framesReceived: v2.framesReceived,
              packetsReceived: v2.packetsReceived,
              packetsLost: v2.packetsLost,
              frameWidth: v2.frameWidth,
              frameHeight: v2.frameHeight,
              pliCount: v2.pliCount,
              firCount: v2.firCount,
              nackCount: v2.nackCount,
              jitter: v2.jitter,
              timestamp: v2.timestamp,
              bytesReceived: v2.bytesReceived,
              decoderImplementation: v2.decoderImplementation
            };
          } else if (v2.type === "codec") {
            codecs.set(v2.id, v2);
          }
        });
        if (receiverStats && codecID !== "" && codecs.get(codecID)) {
          receiverStats.mimeType = codecs.get(codecID).mimeType;
        }
        return receiverStats;
      });
    }
    stopObservingElement(element) {
      const stopElementInfos = this.elementInfos.filter((info) => info.element === element);
      for (const info of stopElementInfos) {
        this.stopObservingElementInfo(info);
      }
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!this.isAdaptiveStream)
          return;
        this.updateVisibility();
      });
    }
    updateVisibility() {
      var _a, _b;
      const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);
      const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true) ? this.isInBackground : false;
      const isPiPMode = this.elementInfos.some((info) => info.pictureInPicture);
      const isVisible = this.elementInfos.some((info) => info.visible) && !backgroundPause || isPiPMode;
      if (this.lastVisible === isVisible) {
        return;
      }
      if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = isVisible;
      this.emit(TrackEvent.VisibilityChanged, isVisible, this);
    }
    updateDimensions() {
      var _a, _b;
      let maxWidth = 0;
      let maxHeight = 0;
      const pixelDensity = this.getPixelDensity();
      for (const info of this.elementInfos) {
        const currentElementWidth = info.width() * pixelDensity;
        const currentElementHeight = info.height() * pixelDensity;
        if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {
          maxWidth = currentElementWidth;
          maxHeight = currentElementHeight;
        }
      }
      if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {
        return;
      }
      this.lastDimensions = {
        width: maxWidth,
        height: maxHeight
      };
      this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
    }
    getPixelDensity() {
      var _a;
      const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;
      if (pixelDensity === "screen") {
        return getDevicePixelRatio();
      } else if (!pixelDensity) {
        const devicePixelRatio = getDevicePixelRatio();
        if (devicePixelRatio > 2) {
          return 2;
        } else {
          return 1;
        }
      }
      return pixelDensity;
    }
  }
  class HTMLElementInfo {
    get visible() {
      return this.isPiP || this.isIntersecting;
    }
    get pictureInPicture() {
      return this.isPiP;
    }
    constructor(element, visible) {
      this.onVisibilityChanged = (entry) => {
        var _a;
        const {
          target,
          isIntersecting
        } = entry;
        if (target === this.element) {
          this.isIntersecting = isIntersecting;
          this.isPiP = isElementInPiP(this.element);
          this.visibilityChangedAt = Date.now();
          (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);
        }
      };
      this.onEnterPiP = () => {
        var _a, _b, _c;
        (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener("pagehide", this.onLeavePiP);
        this.isPiP = isElementInPiP(this.element);
        (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);
      };
      this.onLeavePiP = () => {
        var _a;
        this.isPiP = isElementInPiP(this.element);
        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);
      };
      this.element = element;
      this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);
      this.isPiP = isWeb() && isElementInPiP(element);
      this.visibilityChangedAt = 0;
    }
    width() {
      return this.element.clientWidth;
    }
    height() {
      return this.element.clientHeight;
    }
    observe() {
      var _a, _b, _c;
      this.isIntersecting = isElementInViewport(this.element);
      this.isPiP = isElementInPiP(this.element);
      this.element.handleResize = () => {
        var _a2;
        (_a2 = this.handleResize) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      };
      this.element.handleVisibilityChanged = this.onVisibilityChanged;
      getIntersectionObserver().observe(this.element);
      getResizeObserver().observe(this.element);
      this.element.addEventListener("enterpictureinpicture", this.onEnterPiP);
      this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
      (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener("enter", this.onEnterPiP);
      (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener("pagehide", this.onLeavePiP);
    }
    stopObserving() {
      var _a, _b, _c, _d, _e2;
      (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);
      (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);
      this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP);
      this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
      (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener("enter", this.onEnterPiP);
      (_e2 = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e2 === void 0 ? void 0 : _e2.removeEventListener("pagehide", this.onLeavePiP);
    }
  }
  function isElementInPiP(el) {
    var _a, _b;
    if (document.pictureInPictureElement === el)
      return true;
    if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window)
      return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);
    return false;
  }
  function isElementInViewport(el, win) {
    const viewportWindow = win || window;
    let top = el.offsetTop;
    let left = el.offsetLeft;
    const width = el.offsetWidth;
    const height = el.offsetHeight;
    const {
      hidden
    } = el;
    const {
      display
    } = getComputedStyle(el);
    while (el.offsetParent) {
      el = el.offsetParent;
      top += el.offsetTop;
      left += el.offsetLeft;
    }
    return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== "none";
  }
  class TrackPublication extends eventsExports.EventEmitter {
    constructor(kind, id, name, loggerOptions) {
      var _a;
      super();
      this.metadataMuted = false;
      this.encryption = Encryption_Type.NONE;
      this.log = livekitLogger;
      this.handleMuted = () => {
        this.emit(TrackEvent.Muted);
      };
      this.handleUnmuted = () => {
        this.emit(TrackEvent.Unmuted);
      };
      this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);
      this.loggerContextCb = this.loggerContextCb;
      this.setMaxListeners(100);
      this.kind = kind;
      this.trackSid = id;
      this.trackName = name;
      this.source = Track.Source.Unknown;
    }
    /** @internal */
    setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Muted, this.handleMuted);
        this.track.off(TrackEvent.Unmuted, this.handleUnmuted);
      }
      this.track = track;
      if (track) {
        track.on(TrackEvent.Muted, this.handleMuted);
        track.on(TrackEvent.Unmuted, this.handleUnmuted);
      }
    }
    get logContext() {
      var _a;
      return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));
    }
    get isMuted() {
      return this.metadataMuted;
    }
    get isEnabled() {
      return true;
    }
    get isSubscribed() {
      return this.track !== void 0;
    }
    get isEncrypted() {
      return this.encryption !== Encryption_Type.NONE;
    }
    /**
     * an [AudioTrack] if this publication holds an audio track
     */
    get audioTrack() {
      if (isAudioTrack(this.track)) {
        return this.track;
      }
    }
    /**
     * an [VideoTrack] if this publication holds a video track
     */
    get videoTrack() {
      if (isVideoTrack(this.track)) {
        return this.track;
      }
    }
    /** @internal */
    updateInfo(info) {
      this.trackSid = info.sid;
      this.trackName = info.name;
      this.source = Track.sourceFromProto(info.source);
      this.mimeType = info.mimeType;
      if (this.kind === Track.Kind.Video && info.width > 0) {
        this.dimensions = {
          width: info.width,
          height: info.height
        };
        this.simulcasted = info.simulcast;
      }
      this.encryption = info.encryption;
      this.trackInfo = info;
      this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
        info
      }));
    }
  }
  (function(TrackPublication2) {
    (function(SubscriptionStatus) {
      SubscriptionStatus["Desired"] = "desired";
      SubscriptionStatus["Subscribed"] = "subscribed";
      SubscriptionStatus["Unsubscribed"] = "unsubscribed";
    })(TrackPublication2.SubscriptionStatus || (TrackPublication2.SubscriptionStatus = {}));
    (function(PermissionStatus) {
      PermissionStatus["Allowed"] = "allowed";
      PermissionStatus["NotAllowed"] = "not_allowed";
    })(TrackPublication2.PermissionStatus || (TrackPublication2.PermissionStatus = {}));
  })(TrackPublication);
  class LocalTrackPublication extends TrackPublication {
    get isUpstreamPaused() {
      var _a;
      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;
    }
    constructor(kind, ti, track, loggerOptions) {
      super(kind, ti.sid, ti.name, loggerOptions);
      this.track = void 0;
      this.handleTrackEnded = () => {
        this.emit(TrackEvent.Ended);
      };
      this.updateInfo(ti);
      this.setTrack(track);
    }
    setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Ended, this.handleTrackEnded);
      }
      super.setTrack(track);
      if (track) {
        track.on(TrackEvent.Ended, this.handleTrackEnded);
      }
    }
    get isMuted() {
      if (this.track) {
        return this.track.isMuted;
      }
      return super.isMuted;
    }
    get audioTrack() {
      return super.audioTrack;
    }
    get videoTrack() {
      return super.videoTrack;
    }
    get isLocal() {
      return true;
    }
    /**
     * Mute the track associated with this publication
     */
    mute() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();
      });
    }
    /**
     * Unmute track associated with this publication
     */
    unmute() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();
      });
    }
    /**
     * Pauses the media stream track associated with this publication from being sent to the server
     * and signals "muted" event to other participants
     * Useful if you want to pause the stream without pausing the local media stream track
     */
    pauseUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();
      });
    }
    /**
     * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
     * and signals "unmuted" event to other participants (unless the track is explicitly muted)
     */
    resumeUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();
      });
    }
    getTrackFeatures() {
      var _a;
      if (isAudioTrack(this.track)) {
        const settings = this.track.getSourceTrackSettings();
        const features = /* @__PURE__ */ new Set();
        if (settings.autoGainControl) {
          features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);
        }
        if (settings.echoCancellation) {
          features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);
        }
        if (settings.noiseSuppression) {
          features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);
        }
        if (settings.channelCount && settings.channelCount > 1) {
          features.add(AudioTrackFeature.TF_STEREO);
        }
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {
          features.add(AudioTrackFeature.TF_NO_DTX);
        }
        if (this.track.enhancedNoiseCancellation) {
          features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);
        }
        return Array.from(features.values());
      } else
        return [];
    }
  }
  var ConnectionQuality;
  (function(ConnectionQuality2) {
    ConnectionQuality2["Excellent"] = "excellent";
    ConnectionQuality2["Good"] = "good";
    ConnectionQuality2["Poor"] = "poor";
    ConnectionQuality2["Lost"] = "lost";
    ConnectionQuality2["Unknown"] = "unknown";
  })(ConnectionQuality || (ConnectionQuality = {}));
  function qualityFromProto(q2) {
    switch (q2) {
      case ConnectionQuality$1.EXCELLENT:
        return ConnectionQuality.Excellent;
      case ConnectionQuality$1.GOOD:
        return ConnectionQuality.Good;
      case ConnectionQuality$1.POOR:
        return ConnectionQuality.Poor;
      case ConnectionQuality$1.LOST:
        return ConnectionQuality.Lost;
      default:
        return ConnectionQuality.Unknown;
    }
  }
  class Participant extends eventsExports.EventEmitter {
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    get isEncrypted() {
      return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((tr) => tr.isEncrypted);
    }
    get isAgent() {
      var _a;
      return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;
    }
    get kind() {
      return this._kind;
    }
    /** participant attributes, similar to metadata, but as a key/value map */
    get attributes() {
      return Object.freeze(Object.assign({}, this._attributes));
    }
    /** @internal */
    constructor(sid, identity, name, metadata, attributes, loggerOptions) {
      let kind = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : ParticipantInfo_Kind.STANDARD;
      var _a;
      super();
      this.audioLevel = 0;
      this.isSpeaking = false;
      this._connectionQuality = ConnectionQuality.Unknown;
      this.log = livekitLogger;
      this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);
      this.loggerOptions = loggerOptions;
      this.setMaxListeners(100);
      this.sid = sid;
      this.identity = identity;
      this.name = name;
      this.metadata = metadata;
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.trackPublications = /* @__PURE__ */ new Map();
      this._kind = kind;
      this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};
    }
    getTrackPublications() {
      return Array.from(this.trackPublications.values());
    }
    /**
     * Finds the first track that matches the source filter, for example, getting
     * the user's camera track with getTrackBySource(Track.Source.Camera).
     */
    getTrackPublication(source) {
      for (const [, pub] of this.trackPublications) {
        if (pub.source === source) {
          return pub;
        }
      }
    }
    /**
     * Finds the first track that matches the track's name.
     */
    getTrackPublicationByName(name) {
      for (const [, pub] of this.trackPublications) {
        if (pub.trackName === name) {
          return pub;
        }
      }
    }
    get connectionQuality() {
      return this._connectionQuality;
    }
    get isCameraEnabled() {
      var _a;
      const track = this.getTrackPublication(Track.Source.Camera);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
    get isMicrophoneEnabled() {
      var _a;
      const track = this.getTrackPublication(Track.Source.Microphone);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
    get isScreenShareEnabled() {
      const track = this.getTrackPublication(Track.Source.ScreenShare);
      return !!track;
    }
    get isLocal() {
      return false;
    }
    /** when participant joined the room */
    get joinedAt() {
      if (this.participantInfo) {
        return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3);
      }
      return /* @__PURE__ */ new Date();
    }
    /** @internal */
    updateInfo(info) {
      if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {
        return false;
      }
      this.identity = info.identity;
      this.sid = info.sid;
      this._setName(info.name);
      this._setMetadata(info.metadata);
      this._setAttributes(info.attributes);
      if (info.permission) {
        this.setPermissions(info.permission);
      }
      this.participantInfo = info;
      this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
        info
      }));
      return true;
    }
    /**
     * Updates metadata from server
     **/
    _setMetadata(md) {
      const changed = this.metadata !== md;
      const prevMetadata = this.metadata;
      this.metadata = md;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);
      }
    }
    _setName(name) {
      const changed = this.name !== name;
      this.name = name;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantNameChanged, name);
      }
    }
    /**
     * Updates metadata from server
     **/
    _setAttributes(attributes) {
      const diff = diffAttributes(this.attributes, attributes);
      this._attributes = attributes;
      if (Object.keys(diff).length > 0) {
        this.emit(ParticipantEvent.AttributesChanged, diff);
      }
    }
    /** @internal */
    setPermissions(permissions) {
      var _a, _b, _c, _d, _e2, _f;
      const prevPermissions = this.permissions;
      const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e2 = this.permissions) === null || _e2 === void 0 ? void 0 : _e2.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {
        var _a2;
        return value !== ((_a2 = this.permissions) === null || _a2 === void 0 ? void 0 : _a2.canPublishSources[index]);
      }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);
      this.permissions = permissions;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
      }
      return changed;
    }
    /** @internal */
    setIsSpeaking(speaking) {
      if (speaking === this.isSpeaking) {
        return;
      }
      this.isSpeaking = speaking;
      if (speaking) {
        this.lastSpokeAt = /* @__PURE__ */ new Date();
      }
      this.emit(ParticipantEvent.IsSpeakingChanged, speaking);
    }
    /** @internal */
    setConnectionQuality(q2) {
      const prevQuality = this._connectionQuality;
      this._connectionQuality = qualityFromProto(q2);
      if (prevQuality !== this._connectionQuality) {
        this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
      }
    }
    /**
     * @internal
     */
    setAudioContext(ctx) {
      this.audioContext = ctx;
      this.audioTrackPublications.forEach((track) => isAudioTrack(track.track) && track.track.setAudioContext(ctx));
    }
    addTrackPublication(publication) {
      publication.on(TrackEvent.Muted, () => {
        this.emit(ParticipantEvent.TrackMuted, publication);
      });
      publication.on(TrackEvent.Unmuted, () => {
        this.emit(ParticipantEvent.TrackUnmuted, publication);
      });
      const pub = publication;
      if (pub.track) {
        pub.track.sid = publication.trackSid;
      }
      this.trackPublications.set(publication.trackSid, publication);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.set(publication.trackSid, publication);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.set(publication.trackSid, publication);
          break;
      }
    }
  }
  function trackPermissionToProto(perms) {
    var _a, _b, _c;
    if (!perms.participantSid && !perms.participantIdentity) {
      throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
    }
    return new TrackPermission({
      participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : "",
      participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : "",
      allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,
      trackSids: perms.allowedTrackSids || []
    });
  }
  const STREAM_CHUNK_SIZE = 15e3;
  class LocalParticipant extends Participant {
    /** @internal */
    constructor(sid, identity, engine, options, roomRpcHandlers) {
      super(sid, identity, void 0, void 0, void 0, {
        loggerName: options.loggerName,
        loggerContextCb: () => this.engine.logContext
      });
      this.pendingPublishing = /* @__PURE__ */ new Set();
      this.pendingPublishPromises = /* @__PURE__ */ new Map();
      this.participantTrackPermissions = [];
      this.allParticipantsAllowedToSubscribe = true;
      this.encryptionType = Encryption_Type.NONE;
      this.enabledPublishVideoCodecs = [];
      this.pendingAcks = /* @__PURE__ */ new Map();
      this.pendingResponses = /* @__PURE__ */ new Map();
      this.handleReconnecting = () => {
        if (!this.reconnectFuture) {
          this.reconnectFuture = new Future();
        }
      };
      this.handleReconnected = () => {
        var _a, _b;
        (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.reconnectFuture = void 0;
        this.updateTrackSubscriptionPermissions();
      };
      this.handleDisconnected = () => {
        var _a, _b;
        if (this.reconnectFuture) {
          this.reconnectFuture.promise.catch((e2) => this.log.warn(e2.message, this.logContext));
          (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, "Got disconnected during reconnection attempt");
          this.reconnectFuture = void 0;
        }
      };
      this.handleSignalRequestResponse = (response) => {
        const {
          requestId,
          reason,
          message
        } = response;
        const targetRequest = this.pendingSignalRequests.get(requestId);
        if (targetRequest) {
          if (reason !== RequestResponse_Reason.OK) {
            targetRequest.reject(new SignalRequestError(message, reason));
          }
          this.pendingSignalRequests.delete(requestId);
        }
      };
      this.handleDataPacket = (packet) => {
        switch (packet.value.case) {
          case "rpcResponse":
            let rpcResponse = packet.value.value;
            let payload = null;
            let error = null;
            if (rpcResponse.value.case === "payload") {
              payload = rpcResponse.value.value;
            } else if (rpcResponse.value.case === "error") {
              error = RpcError.fromProto(rpcResponse.value.value);
            }
            this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);
            break;
          case "rpcAck":
            let rpcAck = packet.value.value;
            this.handleIncomingRpcAck(rpcAck.requestId);
            break;
        }
      };
      this.updateTrackSubscriptionPermissions = () => {
        this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
          allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
          participantTrackPermissions: this.participantTrackPermissions
        }));
        this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p2) => trackPermissionToProto(p2)));
      };
      this.onTrackUnmuted = (track) => {
        this.onTrackMuted(track, track.isUpstreamPaused);
      };
      this.onTrackMuted = (track, muted) => {
        if (muted === void 0) {
          muted = true;
        }
        if (!track.sid) {
          this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          return;
        }
        this.engine.updateMuteStatus(track.sid, muted);
      };
      this.onTrackUpstreamPaused = (track) => {
        this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        this.onTrackMuted(track, true);
      };
      this.onTrackUpstreamResumed = (track) => {
        this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        this.onTrackMuted(track, track.isMuted);
      };
      this.onTrackFeatureUpdate = (track) => {
        const pub = this.audioTrackPublications.get(track.sid);
        if (!pub) {
          this.log.warn("Could not update local audio track settings, missing publication for track ".concat(track.sid), this.logContext);
          return;
        }
        this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());
      };
      this.handleSubscribedQualityUpdate = (update) => __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        var _d, _e2;
        if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {
          return;
        }
        const pub = this.videoTrackPublications.get(update.trackSid);
        if (!pub) {
          this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: update.trackSid
          }));
          return;
        }
        if (update.subscribedCodecs.length > 0) {
          if (!pub.videoTrack) {
            return;
          }
          const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);
          try {
            for (var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true) {
              _c = newCodecs_1_1.value;
              _f = false;
              const codec = _c;
              if (isBackupCodec(codec)) {
                this.log.debug("publish ".concat(codec, " for ").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));
                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);
              }
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (!_f && !_a && (_b = newCodecs_1.return))
                yield _b.call(newCodecs_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else if (update.subscribedQualities.length > 0) {
          yield (_e2 = pub.videoTrack) === null || _e2 === void 0 ? void 0 : _e2.setPublishingLayers(update.subscribedQualities);
        }
      });
      this.handleLocalTrackUnpublished = (unpublished) => {
        const track = this.trackPublications.get(unpublished.trackSid);
        if (!track) {
          this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: unpublished.trackSid
          }));
          return;
        }
        this.unpublishTrack(track.track);
      };
      this.handleTrackEnded = (track) => __awaiter(this, void 0, void 0, function* () {
        if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {
          this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          this.unpublishTrack(track);
        } else if (track.isUserProvided) {
          yield track.mute();
        } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {
          try {
            if (isWeb()) {
              try {
                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({
                  // the permission query for camera and microphone currently not supported in Safari and Firefox
                  // @ts-ignore
                  name: track.source === Track.Source.Camera ? "camera" : "microphone"
                });
                if (currentPermissions && currentPermissions.state === "denied") {
                  this.log.warn("user has revoked access to ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
                  currentPermissions.onchange = () => {
                    if (currentPermissions.state !== "denied") {
                      if (!track.isMuted) {
                        track.restartTrack();
                      }
                      currentPermissions.onchange = null;
                    }
                  };
                  throw new Error("GetUserMedia Permission denied");
                }
              } catch (e2) {
              }
            }
            if (!track.isMuted) {
              this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              if (isLocalAudioTrack(track)) {
                yield track.restartTrack({
                  deviceId: "default"
                });
              } else {
                yield track.restartTrack();
              }
            }
          } catch (e2) {
            this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
            yield track.mute();
          }
        }
      });
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.trackPublications = /* @__PURE__ */ new Map();
      this.engine = engine;
      this.roomOptions = options;
      this.setupEngine(engine);
      this.activeDeviceMap = /* @__PURE__ */ new Map([["audioinput", "default"], ["videoinput", "default"], ["audiooutput", "default"]]);
      this.pendingSignalRequests = /* @__PURE__ */ new Map();
      this.rpcHandlers = roomRpcHandlers;
    }
    get lastCameraError() {
      return this.cameraError;
    }
    get lastMicrophoneError() {
      return this.microphoneError;
    }
    get isE2EEEnabled() {
      return this.encryptionType !== Encryption_Type.NONE;
    }
    getTrackPublication(source) {
      const track = super.getTrackPublication(source);
      if (track) {
        return track;
      }
    }
    getTrackPublicationByName(name) {
      const track = super.getTrackPublicationByName(name);
      if (track) {
        return track;
      }
    }
    /**
     * @internal
     */
    setupEngine(engine) {
      this.engine = engine;
      this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {
        const pub = this.trackPublications.get(trackSid);
        if (!pub || !pub.track) {
          return;
        }
        if (muted) {
          pub.mute();
        } else {
          pub.unmute();
        }
      });
      this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);
    }
    /**
     * Sets and updates the metadata of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
    setMetadata(metadata) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          metadata
        });
      });
    }
    /**
     * Sets and updates the name of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
    setName(name) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          name
        });
      });
    }
    /**
     * Set or update participant attributes. It will make updates only to keys that
     * are present in `attributes`, and will not override others.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * @param attributes attributes to update
     */
    setAttributes(attributes) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          attributes
        });
      });
    }
    requestMetadataUpdate(_a) {
      return __awaiter(this, arguments, void 0, function(_ref) {
        var _this = this;
        let {
          metadata,
          name,
          attributes
        } = _ref;
        return function* () {
          return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {
            var _a2, _b;
            try {
              let isRejected = false;
              const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a2 = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a2 !== void 0 ? _a2 : "", (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : "", attributes);
              const startTime = performance.now();
              this.pendingSignalRequests.set(requestId, {
                resolve,
                reject: (error) => {
                  reject(error);
                  isRejected = true;
                },
                values: {
                  name,
                  metadata,
                  attributes
                }
              });
              while (performance.now() - startTime < 5e3 && !isRejected) {
                if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every((_ref2) => {
                  let [key, value] = _ref2;
                  return this.attributes[key] === value || value === "" && !this.attributes[key];
                }))) {
                  this.pendingSignalRequests.delete(requestId);
                  resolve();
                  return;
                }
                yield sleep(50);
              }
              reject(new SignalRequestError("Request to update local metadata timed out", "TimeoutError"));
            } catch (e2) {
              if (e2 instanceof Error)
                reject(e2);
            }
          }));
        }();
      });
    }
    /**
     * Enable or disable a participant's camera track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setCameraEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);
    }
    /**
     * Enable or disable a participant's microphone track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setMicrophoneEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);
    }
    /**
     * Start or stop sharing a participant's screen
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setScreenShareEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);
    }
    /** @internal */
    setPermissions(permissions) {
      const prevPermissions = this.permissions;
      const changed = super.setPermissions(permissions);
      if (changed && prevPermissions) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
      }
      return changed;
    }
    /** @internal */
    setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, function* () {
        this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;
        yield this.republishAllTracks(void 0, false);
      });
    }
    setTrackEnabled(source, enabled, options, publishOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
          source,
          enabled
        }));
        if (this.republishPromise) {
          yield this.republishPromise;
        }
        let track = this.getTrackPublication(source);
        if (enabled) {
          if (track) {
            yield track.unmute();
          } else {
            let localTracks;
            if (this.pendingPublishing.has(source)) {
              const pendingTrack = yield this.waitForPendingPublicationOfSource(source);
              if (!pendingTrack) {
                this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                  source
                }));
              }
              yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();
              return pendingTrack;
            }
            this.pendingPublishing.add(source);
            try {
              switch (source) {
                case Track.Source.Camera:
                  localTracks = yield this.createTracks({
                    video: (_a = options) !== null && _a !== void 0 ? _a : true
                  });
                  break;
                case Track.Source.Microphone:
                  localTracks = yield this.createTracks({
                    audio: (_b = options) !== null && _b !== void 0 ? _b : true
                  });
                  break;
                case Track.Source.ScreenShare:
                  localTracks = yield this.createScreenTracks(Object.assign({}, options));
                  break;
                default:
                  throw new TrackInvalidError(source);
              }
            } catch (e2) {
              localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr) => {
                tr.stop();
              });
              if (e2 instanceof Error) {
                this.emit(ParticipantEvent.MediaDevicesError, e2);
              }
              this.pendingPublishing.delete(source);
              throw e2;
            }
            try {
              const publishPromises = [];
              for (const localTrack of localTracks) {
                this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));
                publishPromises.push(this.publishTrack(localTrack, publishOptions));
              }
              const publishedTracks = yield Promise.all(publishPromises);
              [track] = publishedTracks;
            } catch (e2) {
              localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr) => {
                tr.stop();
              });
              throw e2;
            } finally {
              this.pendingPublishing.delete(source);
            }
          }
        } else {
          if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {
            track = yield this.waitForPendingPublicationOfSource(source);
            if (!track) {
              this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                source
              }));
            }
          }
          if (track && track.track) {
            if (source === Track.Source.ScreenShare) {
              track = yield this.unpublishTrack(track.track);
              const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);
              if (screenAudioTrack && screenAudioTrack.track) {
                this.unpublishTrack(screenAudioTrack.track);
              }
            } else {
              yield track.mute();
            }
          }
        }
        return track;
      });
    }
    /**
     * Publish both camera and microphone at the same time. This is useful for
     * displaying a single Permission Dialog box to the end user.
     */
    enableCameraAndMicrophone() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {
          return;
        }
        this.pendingPublishing.add(Track.Source.Camera);
        this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const tracks = yield this.createTracks({
            audio: true,
            video: true
          });
          yield Promise.all(tracks.map((track) => this.publishTrack(track)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera);
          this.pendingPublishing.delete(Track.Source.Microphone);
        }
      });
    }
    /**
     * Create local camera and/or microphone tracks
     * @param options
     * @returns
     */
    createTracks(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        options !== null && options !== void 0 ? options : options = {};
        const {
          audioProcessor,
          videoProcessor,
          optionsWithoutProcessor
        } = extractProcessorsFromOptions(options);
        const mergedOptions = mergeDefaultOptions(optionsWithoutProcessor, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);
        const constraints = constraintsForOptions(mergedOptions);
        let stream;
        try {
          stream = yield navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          if (err instanceof Error) {
            if (constraints.audio) {
              this.microphoneError = err;
            }
            if (constraints.video) {
              this.cameraError = err;
            }
          }
          throw err;
        }
        if (constraints.audio) {
          this.microphoneError = void 0;
          this.emit(ParticipantEvent.AudioStreamAcquired);
        }
        if (constraints.video) {
          this.cameraError = void 0;
        }
        return Promise.all(stream.getTracks().map((mediaStreamTrack) => __awaiter(this, void 0, void 0, function* () {
          const isAudio = mediaStreamTrack.kind === "audio";
          isAudio ? mergedOptions.audio : mergedOptions.video;
          let trackConstraints;
          const conOrBool = isAudio ? constraints.audio : constraints.video;
          if (typeof conOrBool !== "boolean") {
            trackConstraints = conOrBool;
          }
          const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext
          });
          if (track.kind === Track.Kind.Video) {
            track.source = Track.Source.Camera;
          } else if (track.kind === Track.Kind.Audio) {
            track.source = Track.Source.Microphone;
            track.setAudioContext(this.audioContext);
          }
          track.mediaStream = stream;
          if (isAudioTrack(track) && audioProcessor) {
            yield track.setProcessor(audioProcessor);
          } else if (isVideoTrack(track) && videoProcessor) {
            yield track.setProcessor(videoProcessor);
          }
          return track;
        })));
      });
    }
    /**
     * Creates a screen capture tracks with getDisplayMedia().
     * A LocalVideoTrack is always created and returned.
     * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
     */
    createScreenTracks(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (options === void 0) {
          options = {};
        }
        if (navigator.mediaDevices.getDisplayMedia === void 0) {
          throw new DeviceUnsupportedError("getDisplayMedia not supported");
        }
        if (options.resolution === void 0 && !isSafari17()) {
          options.resolution = ScreenSharePresets.h1080fps30.resolution;
        }
        const constraints = screenCaptureToDisplayMediaStreamOptions(options);
        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);
        const tracks = stream.getVideoTracks();
        if (tracks.length === 0) {
          throw new TrackInvalidError("no video track found");
        }
        const screenVideo = new LocalVideoTrack(tracks[0], void 0, false, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        screenVideo.source = Track.Source.ScreenShare;
        if (options.contentHint) {
          screenVideo.mediaStreamTrack.contentHint = options.contentHint;
        }
        const localTracks = [screenVideo];
        if (stream.getAudioTracks().length > 0) {
          this.emit(ParticipantEvent.AudioStreamAcquired);
          const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false, this.audioContext, {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext
          });
          screenAudio.source = Track.Source.ScreenShareAudio;
          localTracks.push(screenAudio);
        }
        return localTracks;
      });
    }
    /**
     * Publish a new track to the room
     * @param track
     * @param options
     */
    publishTrack(track, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.publishOrRepublishTrack(track, options);
      });
    }
    publishOrRepublishTrack(track_1, options_1) {
      return __awaiter(this, arguments, void 0, function(track, options) {
        var _this2 = this;
        let isRepublish = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return function* () {
          var _a, _b, _c, _d;
          if (isLocalAudioTrack(track)) {
            track.setAudioContext(_this2.audioContext);
          }
          yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;
          if (_this2.republishPromise && !isRepublish) {
            yield _this2.republishPromise;
          }
          if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {
            yield _this2.pendingPublishPromises.get(track);
          }
          let defaultConstraints;
          if (track instanceof MediaStreamTrack) {
            defaultConstraints = track.getConstraints();
          } else {
            defaultConstraints = track.constraints;
            let deviceKind = void 0;
            switch (track.source) {
              case Track.Source.Microphone:
                deviceKind = "audioinput";
                break;
              case Track.Source.Camera:
                deviceKind = "videoinput";
            }
            if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {
              defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {
                deviceId: _this2.activeDeviceMap.get(deviceKind)
              });
            }
          }
          if (track instanceof MediaStreamTrack) {
            switch (track.kind) {
              case "audio":
                track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {
                  loggerName: _this2.roomOptions.loggerName,
                  loggerContextCb: () => _this2.logContext
                });
                break;
              case "video":
                track = new LocalVideoTrack(track, defaultConstraints, true, {
                  loggerName: _this2.roomOptions.loggerName,
                  loggerContextCb: () => _this2.logContext
                });
                break;
              default:
                throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(track.kind));
            }
          } else {
            track.updateLoggerOptions({
              loggerName: _this2.roomOptions.loggerName,
              loggerContextCb: () => _this2.logContext
            });
          }
          let existingPublication;
          _this2.trackPublications.forEach((publication) => {
            if (!publication.track) {
              return;
            }
            if (publication.track === track) {
              existingPublication = publication;
            }
          });
          if (existingPublication) {
            _this2.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));
            return existingPublication;
          }
          const isStereoInput = "channelCount" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
          track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;
          const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;
          if (isStereo) {
            if (!options) {
              options = {};
            }
            if (options.dtx === void 0) {
              _this2.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));
            }
            if (options.red === void 0) {
              _this2.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.");
            }
            (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;
            (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;
          }
          const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);
          if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {
            _this2.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2", Object.assign({}, _this2.logContext));
            opts.simulcast = false;
          }
          if (opts.source) {
            track.source = opts.source;
          }
          const publishPromise = _this2.publish(track, opts, isStereo);
          _this2.pendingPublishPromises.set(track, publishPromise);
          try {
            const publication = yield publishPromise;
            return publication;
          } catch (e2) {
            throw e2;
          } finally {
            _this2.pendingPublishPromises.delete(track);
          }
        }();
      });
    }
    publish(track, opts, isStereo) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k;
        const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack) => isLocalTrack(track) && publishedTrack.source === track.source);
        if (existingTrackOfSource && track.source !== Track.Source.Unknown) {
          this.log.info("publishing a second track with the same source: ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        }
        if (opts.stopMicTrackOnMute && isAudioTrack(track)) {
          track.stopOnMute = true;
        }
        if (track.source === Track.Source.ScreenShare && isFireFox()) {
          opts.simulcast = false;
        }
        if (opts.videoCodec === "av1" && !supportsAV1()) {
          opts.videoCodec = void 0;
        }
        if (opts.videoCodec === "vp9" && !supportsVP9()) {
          opts.videoCodec = void 0;
        }
        if (opts.videoCodec === void 0) {
          opts.videoCodec = defaultVideoCodec;
        }
        if (this.enabledPublishVideoCodecs.length > 0) {
          if (!this.enabledPublishVideoCodecs.some((c2) => opts.videoCodec === mimeTypeToVideoCodecString(c2.mime))) {
            opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);
          }
        }
        const videoCodec = opts.videoCodec;
        track.on(TrackEvent.Muted, this.onTrackMuted);
        track.on(TrackEvent.Unmuted, this.onTrackUnmuted);
        track.on(TrackEvent.Ended, this.handleTrackEnded);
        track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
        track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
        track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        const req = new AddTrackRequest({
          // get local track id for use during publishing
          cid: track.mediaStreamTrack.id,
          name: opts.name,
          type: Track.kindToProto(track.kind),
          muted: track.isMuted,
          source: Track.sourceToProto(track.source),
          disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),
          encryption: this.encryptionType,
          stereo: isStereo,
          disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),
          stream: opts === null || opts === void 0 ? void 0 : opts.stream,
          backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy
        });
        let encodings;
        if (track.kind === Track.Kind.Video) {
          let dims = {
            width: 0,
            height: 0
          };
          try {
            dims = yield track.waitForDimensions();
          } catch (e2) {
            const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;
            dims = {
              width: defaultRes.width,
              height: defaultRes.height
            };
            this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {
              dims
            }));
          }
          req.width = dims.width;
          req.height = dims.height;
          if (isLocalVideoTrack(track)) {
            if (isSVCCodec(videoCodec)) {
              if (track.source === Track.Source.ScreenShare) {
                opts.scalabilityMode = "L1T3";
                if ("contentHint" in track.mediaStreamTrack) {
                  track.mediaStreamTrack.contentHint = "motion";
                  this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
                }
              }
              opts.scalabilityMode = (_e2 = opts.scalabilityMode) !== null && _e2 !== void 0 ? _e2 : "L3T3_KEY";
            }
            req.simulcastCodecs = [new SimulcastCodec({
              codec: videoCodec,
              cid: track.mediaStreamTrack.id
            })];
            if (opts.backupCodec === true) {
              opts.backupCodec = {
                codec: defaultVideoCodec
              };
            }
            if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
            req.encryption === Encryption_Type.NONE) {
              if (!this.roomOptions.dynacast) {
                this.roomOptions.dynacast = true;
              }
              req.simulcastCodecs.push(new SimulcastCodec({
                codec: opts.backupCodec.codec,
                cid: ""
              }));
            }
          }
          encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);
          req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));
        } else if (track.kind === Track.Kind.Audio) {
          encodings = [{
            maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,
            priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : "high",
            networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : "high"
          }];
        }
        if (!this.engine || this.engine.isClosed) {
          throw new UnexpectedConnectionState("cannot publish track when not connected");
        }
        const negotiate = () => __awaiter(this, void 0, void 0, function* () {
          var _a2, _b2, _c2;
          if (!this.engine.pcManager) {
            throw new UnexpectedConnectionState("pcManager is not ready");
          }
          track.sender = yield this.engine.createSender(track, opts, encodings);
          if (isLocalVideoTrack(track)) {
            (_a2 = opts.degradationPreference) !== null && _a2 !== void 0 ? _a2 : opts.degradationPreference = getDefaultDegradationPreference(track);
            track.setDegradationPreference(opts.degradationPreference);
          }
          if (encodings) {
            if (isFireFox() && track.kind === Track.Kind.Audio) {
              let trackTransceiver = void 0;
              for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
                if (transceiver.sender === track.sender) {
                  trackTransceiver = transceiver;
                  break;
                }
              }
              if (trackTransceiver) {
                this.engine.pcManager.publisher.setTrackCodecBitrate({
                  transceiver: trackTransceiver,
                  codec: "opus",
                  maxbr: ((_b2 = encodings[0]) === null || _b2 === void 0 ? void 0 : _b2.maxBitrate) ? encodings[0].maxBitrate / 1e3 : 0
                });
              }
            } else if (track.codec && isSVCCodec(track.codec) && ((_c2 = encodings[0]) === null || _c2 === void 0 ? void 0 : _c2.maxBitrate)) {
              this.engine.pcManager.publisher.setTrackCodecBitrate({
                cid: req.cid,
                codec: track.codec,
                maxbr: encodings[0].maxBitrate / 1e3
              });
            }
          }
          yield this.engine.negotiate();
        });
        let ti;
        if (this.enabledPublishVideoCodecs.length > 0) {
          const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);
          ti = rets[0];
        } else {
          ti = yield this.engine.addTrack(req);
          let primaryCodecMime;
          ti.codecs.forEach((codec) => {
            if (primaryCodecMime === void 0) {
              primaryCodecMime = codec.mimeType;
            }
          });
          if (primaryCodecMime && track.kind === Track.Kind.Video) {
            const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);
            if (updatedCodec !== videoCodec) {
              this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {
                codec: updatedCodec
              }));
              opts.videoCodec = updatedCodec;
              encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);
            }
          }
          yield negotiate();
        }
        const publication = new LocalTrackPublication(track.kind, ti, track, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        publication.options = opts;
        track.sid = ti.sid;
        this.log.debug("publishing ".concat(track.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
          encodings,
          trackInfo: ti
        }));
        if (isLocalVideoTrack(track)) {
          track.startMonitor(this.engine.client);
        } else if (isLocalAudioTrack(track)) {
          track.startMonitor();
        }
        this.addTrackPublication(publication);
        this.emit(ParticipantEvent.LocalTrackPublished, publication);
        return publication;
      });
    }
    get isLocal() {
      return true;
    }
    /** @internal
     * publish additional codec to existing track
     */
    publishAdditionalCodecForTrack(track, videoCodec, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (this.encryptionType !== Encryption_Type.NONE) {
          return;
        }
        let existingPublication;
        this.trackPublications.forEach((publication) => {
          if (!publication.track) {
            return;
          }
          if (publication.track === track) {
            existingPublication = publication;
          }
        });
        if (!existingPublication) {
          throw new TrackInvalidError("track is not published");
        }
        if (!isLocalVideoTrack(track)) {
          throw new TrackInvalidError("track is not a video track");
        }
        const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);
        const encodings = computeTrackBackupEncodings(track, videoCodec, opts);
        if (!encodings) {
          this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          return;
        }
        const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);
        if (!simulcastTrack) {
          return;
        }
        const req = new AddTrackRequest({
          cid: simulcastTrack.mediaStreamTrack.id,
          type: Track.kindToProto(track.kind),
          muted: track.isMuted,
          source: Track.sourceToProto(track.source),
          sid: track.sid,
          simulcastCodecs: [{
            codec: opts.videoCodec,
            cid: simulcastTrack.mediaStreamTrack.id
          }]
        });
        req.layers = videoLayersFromEncodings(req.width, req.height, encodings);
        if (!this.engine || this.engine.isClosed) {
          throw new UnexpectedConnectionState("cannot publish track when not connected");
        }
        const negotiate = () => __awaiter(this, void 0, void 0, function* () {
          yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);
          yield this.engine.negotiate();
        });
        const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);
        const ti = rets[0];
        this.log.debug("published ".concat(videoCodec, " for track ").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {
          encodings,
          trackInfo: ti
        }));
      });
    }
    unpublishTrack(track, stopOnUnpublish) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (isLocalTrack(track)) {
          const publishPromise = this.pendingPublishPromises.get(track);
          if (publishPromise) {
            this.log.info("awaiting publish promise before attempting to unpublish", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
            yield publishPromise;
          }
        }
        const publication = this.getPublicationForTrack(track);
        const pubLogContext = publication ? getLogContextFromTrack(publication) : void 0;
        this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), pubLogContext));
        if (!publication || !publication.track) {
          this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), pubLogContext));
          return void 0;
        }
        track = publication.track;
        track.off(TrackEvent.Muted, this.onTrackMuted);
        track.off(TrackEvent.Unmuted, this.onTrackUnmuted);
        track.off(TrackEvent.Ended, this.handleTrackEnded);
        track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
        track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
        track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        if (stopOnUnpublish === void 0) {
          stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;
        }
        if (stopOnUnpublish) {
          track.stop();
        } else {
          track.stopMonitor();
        }
        let negotiationNeeded = false;
        const trackSender = track.sender;
        track.sender = void 0;
        if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {
          try {
            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
              if (transceiver.sender === trackSender) {
                transceiver.direction = "inactive";
                negotiationNeeded = true;
              }
            }
            if (this.engine.removeTrack(trackSender)) {
              negotiationNeeded = true;
            }
            if (isLocalVideoTrack(track)) {
              for (const [, trackInfo] of track.simulcastCodecs) {
                if (trackInfo.sender) {
                  if (this.engine.removeTrack(trackInfo.sender)) {
                    negotiationNeeded = true;
                  }
                  trackInfo.sender = void 0;
                }
              }
              track.simulcastCodecs.clear();
            }
          } catch (e2) {
            this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {
              error: e2
            }));
          }
        }
        this.trackPublications.delete(publication.trackSid);
        switch (publication.kind) {
          case Track.Kind.Audio:
            this.audioTrackPublications.delete(publication.trackSid);
            break;
          case Track.Kind.Video:
            this.videoTrackPublications.delete(publication.trackSid);
            break;
        }
        this.emit(ParticipantEvent.LocalTrackUnpublished, publication);
        publication.setTrack(void 0);
        if (negotiationNeeded) {
          yield this.engine.negotiate();
        }
        return publication;
      });
    }
    unpublishTracks(tracks) {
      return __awaiter(this, void 0, void 0, function* () {
        const results = yield Promise.all(tracks.map((track) => this.unpublishTrack(track)));
        return results.filter((track) => !!track);
      });
    }
    republishAllTracks(options_1) {
      return __awaiter(this, arguments, void 0, function(options) {
        var _this3 = this;
        let restartTracks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          if (_this3.republishPromise) {
            yield _this3.republishPromise;
          }
          _this3.republishPromise = new Promise((resolve, reject) => __awaiter(_this3, void 0, void 0, function* () {
            try {
              const localPubs = [];
              this.trackPublications.forEach((pub) => {
                if (pub.track) {
                  if (options) {
                    pub.options = Object.assign(Object.assign({}, pub.options), options);
                  }
                  localPubs.push(pub);
                }
              });
              yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {
                const track = pub.track;
                yield this.unpublishTrack(track, false);
                if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {
                  this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
                    track: pub.trackSid
                  }));
                  yield track.restartTrack();
                }
                yield this.publishOrRepublishTrack(track, pub.options, true);
              })));
              resolve();
            } catch (error) {
              reject(error);
            } finally {
              this.republishPromise = void 0;
            }
          }));
          yield _this3.republishPromise;
        }();
      });
    }
    /**
     * Publish a new data payload to the room. Data will be forwarded to each
     * participant in the room if the destination field in publishOptions is empty
     *
     * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
     * @param options optionally specify a `reliable`, `topic` and `destination`
     */
    publishData(data_1) {
      return __awaiter(this, arguments, void 0, function(data) {
        var _this4 = this;
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function* () {
          const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;
          const destinationIdentities = options.destinationIdentities;
          const topic = options.topic;
          const packet = new DataPacket({
            kind,
            value: {
              case: "user",
              value: new UserPacket({
                participantIdentity: _this4.identity,
                payload: data,
                destinationIdentities,
                topic
              })
            }
          });
          yield _this4.engine.sendDataPacket(packet, kind);
        }();
      });
    }
    /**
     * Publish SIP DTMF message to the room.
     *
     * @param code DTMF code
     * @param digit DTMF digit
     */
    publishDtmf(code, digit) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "sipDtmf",
            value: new SipDTMF({
              code,
              digit
            })
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    sendChatMessage(text, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = {
          id: $inject_window_crypto.randomUUID(),
          message: text,
          timestamp: Date.now(),
          attachedFiles: options === null || options === void 0 ? void 0 : options.attachments
        };
        const packet = new DataPacket({
          value: {
            case: "chatMessage",
            value: new ChatMessage(Object.assign(Object.assign({}, msg), {
              timestamp: protoInt64.parse(msg.timestamp)
            }))
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        this.emit(ParticipantEvent.ChatMessage, msg);
        return msg;
      });
    }
    editChatMessage(editText, originalMessage) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = Object.assign(Object.assign({}, originalMessage), {
          message: editText,
          editTimestamp: Date.now()
        });
        const packet = new DataPacket({
          value: {
            case: "chatMessage",
            value: new ChatMessage(Object.assign(Object.assign({}, msg), {
              timestamp: protoInt64.parse(msg.timestamp),
              editTimestamp: protoInt64.parse(msg.editTimestamp)
            }))
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        this.emit(ParticipantEvent.ChatMessage, msg);
        return msg;
      });
    }
    sendText(text, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const streamId = $inject_window_crypto.randomUUID();
        const textInBytes = new TextEncoder().encode(text);
        const totalTextLength = textInBytes.byteLength;
        const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(() => $inject_window_crypto.randomUUID());
        const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);
        const handleProgress = (progress, idx) => {
          var _a2;
          progresses[idx] = progress;
          const totalProgress = progresses.reduce((acc, val) => acc + val, 0);
          (_a2 = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a2 === void 0 ? void 0 : _a2.call(options, totalProgress);
        };
        const writer2 = yield this.streamText({
          streamId,
          totalSize: totalTextLength,
          destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,
          topic: options === null || options === void 0 ? void 0 : options.topic,
          attachedStreamIds: fileIds
        });
        const textChunkSize = Math.floor(STREAM_CHUNK_SIZE / 4);
        const totalTextChunks = Math.ceil(totalTextLength / textChunkSize);
        for (let i2 = 0; i2 < totalTextChunks; i2++) {
          const chunkData = text.slice(i2 * textChunkSize, Math.min((i2 + 1) * textChunkSize, totalTextLength));
          yield this.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
          yield writer2.write(chunkData);
          handleProgress(Math.ceil((i2 + 1) / totalTextChunks), 0);
        }
        yield writer2.close();
        if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {
          yield Promise.all(options.attachments.map((file, idx) => __awaiter(this, void 0, void 0, function* () {
            return this._sendFile(fileIds[idx], file, {
              topic: options.topic,
              mimeType: file.type,
              onProgress: (progress) => {
                handleProgress(progress, idx + 1);
              }
            });
          })));
        }
        return writer2.info;
      });
    }
    /**
     * @internal
     * @experimental CAUTION, might get removed in a minor release
     */
    streamText(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : $inject_window_crypto.randomUUID();
        const info = {
          id: streamId,
          mimeType: "text/plain",
          timestamp: Date.now(),
          topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : "",
          size: options === null || options === void 0 ? void 0 : options.totalSize
        };
        const header = new DataStream_Header({
          streamId,
          mimeType: info.mimeType,
          topic: info.topic,
          timestamp: numberToBigInt(info.timestamp),
          totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),
          contentHeader: {
            case: "textHeader",
            value: new DataStream_TextHeader({
              version: options === null || options === void 0 ? void 0 : options.version,
              attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,
              replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,
              operationType: (options === null || options === void 0 ? void 0 : options.type) === "update" ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE
            })
          }
        });
        const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;
        const packet = new DataPacket({
          destinationIdentities,
          value: {
            case: "streamHeader",
            value: header
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        let chunkId = 0;
        const localP = this;
        const writableStream = new WritableStream({
          // Implement the sink
          write(_ref3) {
            let [textChunk] = _ref3;
            var _a2;
            const textInBytes = new TextEncoder().encode(textChunk);
            if (textInBytes.byteLength > STREAM_CHUNK_SIZE) {
              (_a2 = this.abort) === null || _a2 === void 0 ? void 0 : _a2.call(this);
              throw new Error("chunk size too large");
            }
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
              yield localP.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
              const chunk = new DataStream_Chunk({
                content: textInBytes,
                streamId,
                chunkIndex: numberToBigInt(chunkId)
              });
              const chunkPacket = new DataPacket({
                destinationIdentities,
                value: {
                  case: "streamChunk",
                  value: chunk
                }
              });
              yield localP.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);
              chunkId += 1;
              resolve();
            }));
          },
          close() {
            return __awaiter(this, void 0, void 0, function* () {
              const trailer = new DataStream_Trailer({
                streamId
              });
              const trailerPacket = new DataPacket({
                destinationIdentities,
                value: {
                  case: "streamTrailer",
                  value: trailer
                }
              });
              yield localP.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);
            });
          },
          abort(err) {
            formatAppLog("log", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:20907", "Sink error:", err);
          }
        });
        let onEngineClose = () => __awaiter(this, void 0, void 0, function* () {
          yield writer2.close();
        });
        localP.engine.once(EngineEvent.Closing, onEngineClose);
        const writer2 = new TextStreamWriter(writableStream, info, () => this.engine.off(EngineEvent.Closing, onEngineClose));
        return writer2;
      });
    }
    sendFile(file, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const streamId = $inject_window_crypto.randomUUID();
        yield this._sendFile(streamId, file, options);
        return {
          id: streamId
        };
      });
    }
    _sendFile(streamId, file, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const totalLength = file.size;
        const header = new DataStream_Header({
          totalLength: numberToBigInt(totalLength),
          mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,
          streamId,
          topic: options === null || options === void 0 ? void 0 : options.topic,
          encryptionType: options === null || options === void 0 ? void 0 : options.encryptionType,
          timestamp: numberToBigInt(Date.now()),
          contentHeader: {
            case: "byteHeader",
            value: new DataStream_ByteHeader({
              name: file.name
            })
          }
        });
        const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;
        const packet = new DataPacket({
          destinationIdentities,
          value: {
            case: "streamHeader",
            value: header
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        function read(b2) {
          return new Promise((resolve) => {
            const fr = new FileReader();
            fr.onload = () => {
              resolve(new Uint8Array(fr.result));
            };
            fr.readAsArrayBuffer(b2);
          });
        }
        const totalChunks = Math.ceil(totalLength / STREAM_CHUNK_SIZE);
        for (let i2 = 0; i2 < totalChunks; i2++) {
          const chunkData = yield read(file.slice(i2 * STREAM_CHUNK_SIZE, Math.min((i2 + 1) * STREAM_CHUNK_SIZE, totalLength)));
          yield this.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
          const chunk = new DataStream_Chunk({
            content: chunkData,
            streamId,
            chunkIndex: numberToBigInt(i2)
          });
          const chunkPacket = new DataPacket({
            destinationIdentities,
            value: {
              case: "streamChunk",
              value: chunk
            }
          });
          yield this.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);
          (_b = options === null || options === void 0 ? void 0 : options.onProgress) === null || _b === void 0 ? void 0 : _b.call(options, (i2 + 1) / totalChunks);
        }
        const trailer = new DataStream_Trailer({
          streamId
        });
        const trailerPacket = new DataPacket({
          destinationIdentities,
          value: {
            case: "streamTrailer",
            value: trailer
          }
        });
        yield this.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);
      });
    }
    /**
     * Initiate an RPC call to a remote participant
     * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
     * @returns A promise that resolves with the response payload or rejects with an error.
     * @throws Error on failure. Details in `message`.
     */
    performRpc(_a) {
      return __awaiter(this, arguments, void 0, function(_ref4) {
        var _this5 = this;
        let {
          destinationIdentity,
          method,
          payload,
          responseTimeout = 1e4
        } = _ref4;
        return function* () {
          const maxRoundTripLatency = 2e3;
          return new Promise((resolve, reject) => __awaiter(_this5, void 0, void 0, function* () {
            var _a2, _b, _c, _d;
            if (byteLength(payload) > MAX_PAYLOAD_BYTES) {
              reject(RpcError.builtIn("REQUEST_PAYLOAD_TOO_LARGE"));
              return;
            }
            if (((_b = (_a2 = this.engine.latestJoinResponse) === null || _a2 === void 0 ? void 0 : _a2.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, "1.8.0") < 0) {
              reject(RpcError.builtIn("UNSUPPORTED_SERVER"));
              return;
            }
            const id = $inject_window_crypto.randomUUID();
            yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);
            const ackTimeoutId = setTimeout(() => {
              this.pendingAcks.delete(id);
              reject(RpcError.builtIn("CONNECTION_TIMEOUT"));
              this.pendingResponses.delete(id);
              clearTimeout(responseTimeoutId);
            }, maxRoundTripLatency);
            this.pendingAcks.set(id, {
              resolve: () => {
                clearTimeout(ackTimeoutId);
              },
              participantIdentity: destinationIdentity
            });
            const responseTimeoutId = setTimeout(() => {
              this.pendingResponses.delete(id);
              reject(RpcError.builtIn("RESPONSE_TIMEOUT"));
            }, responseTimeout);
            this.pendingResponses.set(id, {
              resolve: (responsePayload, responseError) => {
                clearTimeout(responseTimeoutId);
                if (this.pendingAcks.has(id)) {
                  formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:21045", "RPC response received before ack", id);
                  this.pendingAcks.delete(id);
                  clearTimeout(ackTimeoutId);
                }
                if (responseError) {
                  reject(responseError);
                } else {
                  resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : "");
                }
              },
              participantIdentity: destinationIdentity
            });
          }));
        }();
      });
    }
    /**
     * @deprecated use `room.registerRpcMethod` instead
     */
    registerRpcMethod(method, handler) {
      if (this.rpcHandlers.has(method)) {
        this.log.warn("you're overriding the RPC handler for method ".concat(method, ", in the future this will throw an error"));
      }
      this.rpcHandlers.set(method, handler);
    }
    /**
     * @deprecated use `room.unregisterRpcMethod` instead
     */
    unregisterRpcMethod(method) {
      this.rpcHandlers.delete(method);
    }
    /**
     * Control who can subscribe to LocalParticipant's published tracks.
     *
     * By default, all participants can subscribe. This allows fine-grained control over
     * who is able to subscribe at a participant and track level.
     *
     * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
     * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
     * will not grant permissions to any participants and will require a subsequent
     * permissions update to allow subscription.
     *
     * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
     *  Takes precedence over [[participantTrackPermissions]] if set to true.
     *  By default this is set to true.
     * @param participantTrackPermissions Full list of individual permissions per
     *  participant/track. Any omitted participants will not receive any permissions.
     */
    setTrackSubscriptionPermissions(allParticipantsAllowed) {
      let participantTrackPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      this.participantTrackPermissions = participantTrackPermissions;
      this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;
      if (!this.engine.client.isDisconnected) {
        this.updateTrackSubscriptionPermissions();
      }
    }
    handleIncomingRpcAck(requestId) {
      const handler = this.pendingAcks.get(requestId);
      if (handler) {
        handler.resolve();
        this.pendingAcks.delete(requestId);
      } else {
        formatAppLog("error", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:21107", "Ack received for unexpected RPC request", requestId);
      }
    }
    handleIncomingRpcResponse(requestId, payload, error) {
      const handler = this.pendingResponses.get(requestId);
      if (handler) {
        handler.resolve(payload, error);
        this.pendingResponses.delete(requestId);
      } else {
        formatAppLog("error", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:21116", "Response received for unexpected RPC request", requestId);
      }
    }
    /** @internal */
    publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcRequest",
            value: new RpcRequest({
              id: requestId,
              method,
              payload,
              responseTimeoutMs: responseTimeout,
              version: 1
            })
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    handleParticipantDisconnected(participantIdentity) {
      for (const [id, {
        participantIdentity: pendingIdentity
      }] of this.pendingAcks) {
        if (pendingIdentity === participantIdentity) {
          this.pendingAcks.delete(id);
        }
      }
      for (const [id, {
        participantIdentity: pendingIdentity,
        resolve
      }] of this.pendingResponses) {
        if (pendingIdentity === participantIdentity) {
          resolve(null, RpcError.builtIn("RECIPIENT_DISCONNECTED"));
          this.pendingResponses.delete(id);
        }
      }
    }
    /** @internal */
    setEnabledPublishCodecs(codecs) {
      this.enabledPublishVideoCodecs = codecs.filter((c2) => c2.mime.split("/")[0].toLowerCase() === "video");
    }
    /** @internal */
    updateInfo(info) {
      if (info.sid !== this.sid) {
        return false;
      }
      if (!super.updateInfo(info)) {
        return false;
      }
      info.tracks.forEach((ti) => {
        var _a, _b;
        const pub = this.trackPublications.get(ti.sid);
        if (pub) {
          const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);
          if (mutedOnServer !== ti.muted) {
            this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {
              mutedOnServer
            }));
            this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);
          }
        }
      });
      return true;
    }
    getPublicationForTrack(track) {
      let publication;
      this.trackPublications.forEach((pub) => {
        const localTrack = pub.track;
        if (!localTrack) {
          return;
        }
        if (track instanceof MediaStreamTrack) {
          if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {
            if (localTrack.mediaStreamTrack === track) {
              publication = pub;
            }
          }
        } else if (track === localTrack) {
          publication = pub;
        }
      });
      return publication;
    }
    waitForPendingPublicationOfSource(source) {
      return __awaiter(this, void 0, void 0, function* () {
        const waitForPendingTimeout = 1e4;
        const startTime = Date.now();
        while (Date.now() < startTime + waitForPendingTimeout) {
          const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find((_ref5) => {
            let [pendingTrack] = _ref5;
            return pendingTrack.source === source;
          });
          if (publishPromiseEntry) {
            return publishPromiseEntry[1];
          }
          yield sleep(20);
        }
      });
    }
  }
  class RemoteTrackPublication extends TrackPublication {
    constructor(kind, ti, autoSubscribe, loggerOptions) {
      super(kind, ti.sid, ti.name, loggerOptions);
      this.track = void 0;
      this.allowed = true;
      this.disabled = false;
      this.currentVideoQuality = VideoQuality.HIGH;
      this.handleEnded = (track) => {
        this.setTrack(void 0);
        this.emit(TrackEvent.Ended, track);
      };
      this.handleVisibilityChange = (visible) => {
        this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(visible), this.logContext);
        this.disabled = !visible;
        this.emitTrackUpdate();
      };
      this.handleVideoDimensionsChange = (dimensions) => {
        this.log.debug("adaptivestream video dimensions ".concat(dimensions.width, "x").concat(dimensions.height), this.logContext);
        this.videoDimensions = dimensions;
        this.emitTrackUpdate();
      };
      this.subscribed = autoSubscribe;
      this.updateInfo(ti);
    }
    /**
     * Subscribe or unsubscribe to this remote track
     * @param subscribed true to subscribe to a track, false to unsubscribe
     */
    setSubscribed(subscribed) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      this.subscribed = subscribed;
      if (subscribed) {
        this.allowed = true;
      }
      const sub = new UpdateSubscription({
        trackSids: [this.trackSid],
        subscribe: this.subscribed,
        participantTracks: [new ParticipantTracks({
          // sending an empty participant id since TrackPublication doesn't keep it
          // this is filled in by the participant that receives this message
          participantSid: "",
          trackSids: [this.trackSid]
        })]
      });
      this.emit(TrackEvent.UpdateSubscription, sub);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
      this.emitPermissionUpdateIfChanged(prevPermission);
    }
    get subscriptionStatus() {
      if (this.subscribed === false) {
        return TrackPublication.SubscriptionStatus.Unsubscribed;
      }
      if (!super.isSubscribed) {
        return TrackPublication.SubscriptionStatus.Desired;
      }
      return TrackPublication.SubscriptionStatus.Subscribed;
    }
    get permissionStatus() {
      return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
    }
    /**
     * Returns true if track is subscribed, and ready for playback
     */
    get isSubscribed() {
      if (this.subscribed === false) {
        return false;
      }
      return super.isSubscribed;
    }
    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
    get isDesired() {
      return this.subscribed !== false;
    }
    get isEnabled() {
      return !this.disabled;
    }
    get isLocal() {
      return false;
    }
    /**
     * disable server from sending down data for this track. this is useful when
     * the participant is off screen, you may disable streaming down their video
     * to reduce bandwidth requirements
     * @param enabled
     */
    setEnabled(enabled) {
      if (!this.isManualOperationAllowed() || this.disabled === !enabled) {
        return;
      }
      this.disabled = !enabled;
      this.emitTrackUpdate();
    }
    /**
     * for tracks that support simulcasting, adjust subscribed quality
     *
     * This indicates the highest quality the client can accept. if network
     * bandwidth does not allow, server will automatically reduce quality to
     * optimize for uninterrupted video
     */
    setVideoQuality(quality) {
      if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {
        return;
      }
      this.currentVideoQuality = quality;
      this.videoDimensions = void 0;
      this.emitTrackUpdate();
    }
    setVideoDimensions(dimensions) {
      var _a, _b;
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
        return;
      }
      if (isRemoteVideoTrack(this.track)) {
        this.videoDimensions = dimensions;
      }
      this.currentVideoQuality = void 0;
      this.emitTrackUpdate();
    }
    setVideoFPS(fps) {
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (!isRemoteVideoTrack(this.track)) {
        return;
      }
      if (this.fps === fps) {
        return;
      }
      this.fps = fps;
      this.emitTrackUpdate();
    }
    get videoQuality() {
      return this.currentVideoQuality;
    }
    /** @internal */
    setTrack(track) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      const prevTrack = this.track;
      if (prevTrack === track) {
        return;
      }
      if (prevTrack) {
        prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        prevTrack.off(TrackEvent.Ended, this.handleEnded);
        prevTrack.detach();
        prevTrack.stopMonitor();
        this.emit(TrackEvent.Unsubscribed, prevTrack);
      }
      super.setTrack(track);
      if (track) {
        track.sid = this.trackSid;
        track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        track.on(TrackEvent.Ended, this.handleEnded);
        this.emit(TrackEvent.Subscribed, track);
      }
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
    setAllowed(allowed) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      this.allowed = allowed;
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
    setSubscriptionError(error) {
      this.emit(TrackEvent.SubscriptionFailed, error);
    }
    /** @internal */
    updateInfo(info) {
      super.updateInfo(info);
      const prevMetadataMuted = this.metadataMuted;
      this.metadataMuted = info.muted;
      if (this.track) {
        this.track.setMuted(info.muted);
      } else if (prevMetadataMuted !== info.muted) {
        this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
      }
    }
    emitSubscriptionUpdateIfChanged(previousStatus) {
      const currentStatus = this.subscriptionStatus;
      if (previousStatus === currentStatus) {
        return;
      }
      this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);
    }
    emitPermissionUpdateIfChanged(previousPermissionStatus) {
      const currentPermissionStatus = this.permissionStatus;
      if (currentPermissionStatus !== previousPermissionStatus) {
        this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);
      }
    }
    isManualOperationAllowed() {
      if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {
        this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext);
        return false;
      }
      if (!this.isDesired) {
        this.log.warn("cannot update track settings when not subscribed", this.logContext);
        return false;
      }
      return true;
    }
    get isAdaptiveStream() {
      return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;
    }
    /* @internal */
    emitTrackUpdate() {
      const settings = new UpdateTrackSettings({
        trackSids: [this.trackSid],
        disabled: this.disabled,
        fps: this.fps
      });
      if (this.videoDimensions) {
        settings.width = Math.ceil(this.videoDimensions.width);
        settings.height = Math.ceil(this.videoDimensions.height);
      } else if (this.currentVideoQuality !== void 0) {
        settings.quality = this.currentVideoQuality;
      } else {
        settings.quality = VideoQuality.HIGH;
      }
      this.emit(TrackEvent.UpdateSettings, settings);
    }
  }
  class RemoteParticipant extends Participant {
    /** @internal */
    static fromParticipantInfo(signalClient, pi, loggerOptions) {
      return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);
    }
    get logContext() {
      return Object.assign(Object.assign({}, super.logContext), {
        rpID: this.sid,
        remoteParticipant: this.identity
      });
    }
    /** @internal */
    constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {
      let kind = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : ParticipantInfo_Kind.STANDARD;
      super(sid, identity || "", name, metadata, attributes, loggerOptions, kind);
      this.signalClient = signalClient;
      this.trackPublications = /* @__PURE__ */ new Map();
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.volumeMap = /* @__PURE__ */ new Map();
    }
    addTrackPublication(publication) {
      super.addTrackPublication(publication);
      publication.on(TrackEvent.UpdateSettings, (settings) => {
        this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
        this.signalClient.sendUpdateTrackSettings(settings);
      });
      publication.on(TrackEvent.UpdateSubscription, (sub) => {
        sub.participantTracks.forEach((pt2) => {
          pt2.participantSid = this.sid;
        });
        this.signalClient.sendUpdateSubscription(sub);
      });
      publication.on(TrackEvent.SubscriptionPermissionChanged, (status) => {
        this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);
      });
      publication.on(TrackEvent.SubscriptionStatusChanged, (status) => {
        this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);
      });
      publication.on(TrackEvent.Subscribed, (track) => {
        this.emit(ParticipantEvent.TrackSubscribed, track, publication);
      });
      publication.on(TrackEvent.Unsubscribed, (previousTrack) => {
        this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);
      });
      publication.on(TrackEvent.SubscriptionFailed, (error) => {
        this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);
      });
    }
    getTrackPublication(source) {
      const track = super.getTrackPublication(source);
      if (track) {
        return track;
      }
    }
    getTrackPublicationByName(name) {
      const track = super.getTrackPublicationByName(name);
      if (track) {
        return track;
      }
    }
    /**
     * sets the volume on the participant's audio track
     * by default, this affects the microphone publication
     * a different source can be passed in as a second argument
     * if no track exists the volume will be applied when the microphone track is added
     */
    setVolume(volume) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
      this.volumeMap.set(source, volume);
      const audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        audioPublication.track.setVolume(volume);
      }
    }
    /**
     * gets the volume on the participant's microphone track
     */
    getVolume() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
      const audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        return audioPublication.track.getVolume();
      }
      return this.volumeMap.get(source);
    }
    /** @internal */
    addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {
      let publication = this.getTrackPublicationBySid(sid);
      if (!publication) {
        if (!sid.startsWith("TR")) {
          this.trackPublications.forEach((p2) => {
            if (!publication && mediaTrack.kind === p2.kind.toString()) {
              publication = p2;
            }
          });
        }
      }
      if (!publication) {
        if (triesLeft === 0) {
          this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: sid
          }));
          this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
          return;
        }
        if (triesLeft === void 0)
          triesLeft = 20;
        setTimeout(() => {
          this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);
        }, 150);
        return;
      }
      if (mediaTrack.readyState === "ended") {
        this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
        return;
      }
      const isVideo = mediaTrack.kind === "video";
      let track;
      if (isVideo) {
        track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);
      } else {
        track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);
      }
      track.source = publication.source;
      track.isMuted = publication.isMuted;
      track.setMediaStream(mediaStream);
      track.start();
      publication.setTrack(track);
      if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {
        track.setVolume(this.volumeMap.get(publication.source));
      }
      return publication;
    }
    /** @internal */
    get hasMetadata() {
      return !!this.participantInfo;
    }
    /**
     * @internal
     */
    getTrackPublicationBySid(sid) {
      return this.trackPublications.get(sid);
    }
    /** @internal */
    updateInfo(info) {
      if (!super.updateInfo(info)) {
        return false;
      }
      const validTracks = /* @__PURE__ */ new Map();
      const newTracks = /* @__PURE__ */ new Map();
      info.tracks.forEach((ti) => {
        var _a, _b;
        let publication = this.getTrackPublicationBySid(ti.sid);
        if (!publication) {
          const kind = Track.kindFromProto(ti.type);
          if (!kind) {
            return;
          }
          publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {
            loggerContextCb: () => this.logContext,
            loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName
          });
          publication.updateInfo(ti);
          newTracks.set(ti.sid, publication);
          const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack) => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));
          if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {
            this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {
              oldTrack: getLogContextFromTrack(existingTrackOfSource),
              newTrack: getLogContextFromTrack(publication)
            }));
          }
          this.addTrackPublication(publication);
        } else {
          publication.updateInfo(ti);
        }
        validTracks.set(ti.sid, publication);
      });
      this.trackPublications.forEach((publication) => {
        if (!validTracks.has(publication.trackSid)) {
          this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
          this.unpublishTrack(publication.trackSid, true);
        }
      });
      newTracks.forEach((publication) => {
        this.emit(ParticipantEvent.TrackPublished, publication);
      });
      return true;
    }
    /** @internal */
    unpublishTrack(sid, sendUnpublish) {
      const publication = this.trackPublications.get(sid);
      if (!publication) {
        return;
      }
      const {
        track
      } = publication;
      if (track) {
        track.stop();
        publication.setTrack(void 0);
      }
      this.trackPublications.delete(sid);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(sid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(sid);
          break;
      }
      if (sendUnpublish) {
        this.emit(ParticipantEvent.TrackUnpublished, publication);
      }
    }
    /**
     * @internal
     */
    setAudioOutput(output) {
      return __awaiter(this, void 0, void 0, function* () {
        this.audioOutput = output;
        const promises = [];
        this.audioTrackPublications.forEach((pub) => {
          var _a;
          if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {
            promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : "default"));
          }
        });
        yield Promise.all(promises);
      });
    }
    /** @internal */
    emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
        event,
        args
      }));
      return super.emit(event, ...args);
    }
  }
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2["Disconnected"] = "disconnected";
    ConnectionState2["Connecting"] = "connecting";
    ConnectionState2["Connected"] = "connected";
    ConnectionState2["Reconnecting"] = "reconnecting";
    ConnectionState2["SignalReconnecting"] = "signalReconnecting";
  })(ConnectionState || (ConnectionState = {}));
  const connectionReconcileFrequency = 4 * 1e3;
  class Room extends eventsExports.EventEmitter {
    /**
     * Creates a new Room, the primary construct for a LiveKit session.
     * @param options
     */
    constructor(options) {
      var _this;
      var _a, _b, _c;
      super();
      _this = this;
      this.state = ConnectionState.Disconnected;
      this.activeSpeakers = [];
      this.isE2EEEnabled = false;
      this.audioEnabled = true;
      this.isVideoPlaybackBlocked = false;
      this.log = livekitLogger;
      this.bufferedEvents = [];
      this.isResuming = false;
      this.byteStreamControllers = /* @__PURE__ */ new Map();
      this.textStreamControllers = /* @__PURE__ */ new Map();
      this.byteStreamHandlers = /* @__PURE__ */ new Map();
      this.textStreamHandlers = /* @__PURE__ */ new Map();
      this.rpcHandlers = /* @__PURE__ */ new Map();
      this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {
        var _a2;
        if (!isBrowserSupported()) {
          if (isReactNative()) {
            throw Error("WebRTC isn't detected, have you called registerGlobals?");
          } else {
            throw Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
          }
        }
        const unlockDisconnect = yield this.disconnectLock.lock();
        if (this.state === ConnectionState.Connected) {
          this.log.info("already connected to room ".concat(this.name), this.logContext);
          unlockDisconnect();
          return Promise.resolve();
        }
        if (this.connectFuture) {
          unlockDisconnect();
          return this.connectFuture.promise;
        }
        this.setAndEmitConnectionState(ConnectionState.Connecting);
        if (((_a2 = this.regionUrlProvider) === null || _a2 === void 0 ? void 0 : _a2.getServerUrl().toString()) !== url) {
          this.regionUrl = void 0;
          this.regionUrlProvider = void 0;
        }
        if (isCloud(new URL(url))) {
          if (this.regionUrlProvider === void 0) {
            this.regionUrlProvider = new RegionUrlProvider(url, token);
          } else {
            this.regionUrlProvider.updateToken(token);
          }
          this.regionUrlProvider.fetchRegionSettings().then((settings) => {
            var _a3;
            (_a3 = this.regionUrlProvider) === null || _a3 === void 0 ? void 0 : _a3.setServerReportedRegions(settings);
          }).catch((e2) => {
            this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
              error: e2
            }));
          });
        }
        const connectFn = (resolve, reject, regionUrl2) => __awaiter(this, void 0, void 0, function* () {
          var _a3, _b2;
          if (this.abortController) {
            this.abortController.abort();
          }
          const abortController = new AbortController();
          this.abortController = abortController;
          unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();
          try {
            yield this.attemptConnection(regionUrl2 !== null && regionUrl2 !== void 0 ? regionUrl2 : url, token, opts, abortController);
            this.abortController = void 0;
            resolve();
          } catch (e2) {
            if (this.regionUrlProvider && e2 instanceof ConnectionError && e2.reason !== ConnectionErrorReason.Cancelled && e2.reason !== ConnectionErrorReason.NotAllowed) {
              let nextUrl = null;
              try {
                nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a3 = this.abortController) === null || _a3 === void 0 ? void 0 : _a3.signal);
              } catch (error) {
                if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {
                  this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
                  reject(error);
                  return;
                }
              }
              if (nextUrl && !((_b2 = this.abortController) === null || _b2 === void 0 ? void 0 : _b2.signal.aborted)) {
                this.log.info("Initial connection failed with ConnectionError: ".concat(e2.message, ". Retrying with another region: ").concat(nextUrl), this.logContext);
                this.recreateEngine();
                yield connectFn(resolve, reject, nextUrl);
              } else {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e2));
                reject(e2);
              }
            } else {
              let disconnectReason = DisconnectReason.UNKNOWN_REASON;
              if (e2 instanceof ConnectionError) {
                disconnectReason = getDisconnectReasonFromConnectionError(e2);
              }
              this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);
              reject(e2);
            }
          }
        });
        const regionUrl = this.regionUrl;
        this.regionUrl = void 0;
        this.connectFuture = new Future((resolve, reject) => {
          connectFn(resolve, reject, regionUrl);
        }, () => {
          this.clearConnectionFutures();
        });
        return this.connectFuture.promise;
      });
      this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2, _c2;
        const joinResponse = yield engine.join(url, token, {
          autoSubscribe: connectOptions.autoSubscribe,
          adaptiveStream: typeof roomOptions.adaptiveStream === "object" ? true : roomOptions.adaptiveStream,
          maxRetries: connectOptions.maxRetries,
          e2eeEnabled: !!this.e2eeManager,
          websocketTimeout: connectOptions.websocketTimeout
        }, abortController.signal);
        let serverInfo = joinResponse.serverInfo;
        if (!serverInfo) {
          serverInfo = {
            version: joinResponse.serverVersion,
            region: joinResponse.serverRegion
          };
        }
        this.serverInfo = serverInfo;
        this.log.debug("connected to Livekit Server ".concat(Object.entries(serverInfo).map((_ref) => {
          let [key, value] = _ref;
          return "".concat(key, ": ").concat(value);
        }).join(", ")), {
          room: (_a2 = joinResponse.room) === null || _a2 === void 0 ? void 0 : _a2.name,
          roomSid: (_b2 = joinResponse.room) === null || _b2 === void 0 ? void 0 : _b2.sid,
          identity: (_c2 = joinResponse.participant) === null || _c2 === void 0 ? void 0 : _c2.identity
        });
        if (!serverInfo.version) {
          throw new UnsupportedServer("unknown server version");
        }
        if (serverInfo.version === "0.15.1" && this.options.dynacast) {
          this.log.debug("disabling dynacast due to server version", this.logContext);
          roomOptions.dynacast = false;
        }
        return joinResponse;
      });
      this.applyJoinResponse = (joinResponse) => {
        const pi = joinResponse.participant;
        this.localParticipant.sid = pi.sid;
        this.localParticipant.identity = pi.identity;
        this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);
        if (this.options.e2ee && this.e2eeManager) {
          try {
            this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);
          } catch (e2) {
            this.log.error(e2 instanceof Error ? e2.message : "Could not set SifTrailer", Object.assign(Object.assign({}, this.logContext), {
              error: e2
            }));
          }
        }
        this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);
        if (joinResponse.room) {
          this.handleRoomUpdate(joinResponse.room);
        }
      };
      this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2;
        if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.pendingReconnect)) {
          this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext);
          this.recreateEngine();
        } else {
          this.maybeCreateEngine();
        }
        if ((_b2 = this.regionUrlProvider) === null || _b2 === void 0 ? void 0 : _b2.isCloud()) {
          this.engine.setRegionUrlProvider(this.regionUrlProvider);
        }
        this.acquireAudioContext();
        this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);
        if (this.connOptions.rtcConfig) {
          this.engine.rtcConfig = this.connOptions.rtcConfig;
        }
        if (this.connOptions.peerConnectionTimeout) {
          this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;
        }
        try {
          const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);
          this.applyJoinResponse(joinResponse);
          this.setupLocalParticipantEvents();
          this.emit(RoomEvent.SignalConnected);
        } catch (err) {
          yield this.engine.close();
          this.recreateEngine();
          const resultingError = new ConnectionError("could not establish signal connection", ConnectionErrorReason.ServerUnreachable);
          if (err instanceof Error) {
            resultingError.message = "".concat(resultingError.message, ": ").concat(err.message);
          }
          if (err instanceof ConnectionError) {
            resultingError.reason = err.reason;
            resultingError.status = err.status;
          }
          this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
            error: err
          }));
          throw resultingError;
        }
        if (abortController.signal.aborted) {
          yield this.engine.close();
          this.recreateEngine();
          throw new ConnectionError("Connection attempt aborted", ConnectionErrorReason.Cancelled);
        }
        try {
          yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);
        } catch (e2) {
          yield this.engine.close();
          this.recreateEngine();
          throw e2;
        }
        if (isWeb() && this.options.disconnectOnPageLeave) {
          window.addEventListener("pagehide", this.onPageLeave);
          window.addEventListener("beforeunload", this.onPageLeave);
        }
        if (isWeb()) {
          document.addEventListener("freeze", this.onPageLeave);
        }
        this.setAndEmitConnectionState(ConnectionState.Connected);
        this.emit(RoomEvent.Connected);
        this.registerConnectionReconcile();
      });
      this.disconnect = function() {
        for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {
          args_1[_key] = arguments[_key];
        }
        return __awaiter(_this, [...args_1], void 0, function() {
          var _this2 = this;
          let stopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          return function* () {
            var _a2, _b2, _c2, _d;
            const unlock = yield _this2.disconnectLock.lock();
            try {
              if (_this2.state === ConnectionState.Disconnected) {
                _this2.log.debug("already disconnected", _this2.logContext);
                return;
              }
              _this2.log.info("disconnect from room", Object.assign({}, _this2.logContext));
              if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {
                _this2.log.warn("abort connection attempt", _this2.logContext);
                (_a2 = _this2.abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
                (_c2 = (_b2 = _this2.connectFuture) === null || _b2 === void 0 ? void 0 : _b2.reject) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, new ConnectionError("Client initiated disconnect", ConnectionErrorReason.Cancelled));
                _this2.connectFuture = void 0;
              }
              if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {
                yield _this2.engine.client.sendLeave();
              }
              if (_this2.engine) {
                yield _this2.engine.close();
              }
              _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);
              _this2.engine = void 0;
            } finally {
              unlock();
            }
          }();
        });
      };
      this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {
        this.log.info("Page leave detected, disconnecting", this.logContext);
        yield this.disconnect();
      });
      this.startAudio = () => __awaiter(this, void 0, void 0, function* () {
        const elements = [];
        const browser = getBrowser();
        if (browser && browser.os === "iOS") {
          const audioId = "livekit-dummy-audio-el";
          let dummyAudioEl = document.getElementById(audioId);
          if (!dummyAudioEl) {
            dummyAudioEl = document.createElement("audio");
            dummyAudioEl.id = audioId;
            dummyAudioEl.autoplay = true;
            dummyAudioEl.hidden = true;
            const track = getEmptyAudioStreamTrack();
            track.enabled = true;
            const stream = new MediaStream([track]);
            dummyAudioEl.srcObject = stream;
            document.addEventListener("visibilitychange", () => {
              if (!dummyAudioEl) {
                return;
              }
              dummyAudioEl.srcObject = document.hidden ? null : stream;
              if (!document.hidden) {
                this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext);
                this.startAudio();
              }
            });
            document.body.append(dummyAudioEl);
            this.once(RoomEvent.Disconnected, () => {
              dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();
              dummyAudioEl = null;
            });
          }
          elements.push(dummyAudioEl);
        }
        this.remoteParticipants.forEach((p2) => {
          p2.audioTrackPublications.forEach((t2) => {
            if (t2.track) {
              t2.track.attachedElements.forEach((e2) => {
                elements.push(e2);
              });
            }
          });
        });
        try {
          yield Promise.all([this.acquireAudioContext(), ...elements.map((e2) => {
            e2.muted = false;
            return e2.play();
          })]);
          this.handleAudioPlaybackStarted();
        } catch (err) {
          this.handleAudioPlaybackFailed(err);
          throw err;
        }
      });
      this.startVideo = () => __awaiter(this, void 0, void 0, function* () {
        const elements = [];
        for (const p2 of this.remoteParticipants.values()) {
          p2.videoTrackPublications.forEach((tr) => {
            var _a2;
            (_a2 = tr.track) === null || _a2 === void 0 ? void 0 : _a2.attachedElements.forEach((el) => {
              if (!elements.includes(el)) {
                elements.push(el);
              }
            });
          });
        }
        yield Promise.all(elements.map((el) => el.play())).then(() => {
          this.handleVideoPlaybackStarted();
        }).catch((e2) => {
          if (e2.name === "NotAllowedError") {
            this.handleVideoPlaybackFailed();
          } else {
            this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
          }
        });
      });
      this.handleRestarting = () => {
        this.clearConnectionReconcile();
        this.isResuming = false;
        for (const p2 of this.remoteParticipants.values()) {
          this.handleParticipantDisconnected(p2.identity, p2);
        }
        if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
          this.emit(RoomEvent.Reconnecting);
        }
      };
      this.handleSignalRestarted = (joinResponse) => __awaiter(this, void 0, void 0, function* () {
        this.log.debug("signal reconnected to server, region ".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {
          region: joinResponse.serverRegion
        }));
        this.bufferedEvents = [];
        this.applyJoinResponse(joinResponse);
        try {
          yield this.localParticipant.republishAllTracks(void 0, true);
        } catch (error) {
          this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
            error
          }));
        }
        try {
          yield this.engine.waitForRestarted();
          this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
            region: joinResponse.serverRegion
          }));
        } catch (_a2) {
          return;
        }
        this.setAndEmitConnectionState(ConnectionState.Connected);
        this.emit(RoomEvent.Reconnected);
        this.registerConnectionReconcile();
        this.emitBufferedEvents();
      });
      this.handleParticipantUpdates = (participantInfos) => {
        participantInfos.forEach((info) => {
          var _a2;
          if (info.identity === this.localParticipant.identity) {
            this.localParticipant.updateInfo(info);
            return;
          }
          if (info.identity === "") {
            info.identity = (_a2 = this.sidToIdentity.get(info.sid)) !== null && _a2 !== void 0 ? _a2 : "";
          }
          let remoteParticipant = this.remoteParticipants.get(info.identity);
          if (info.state === ParticipantInfo_State.DISCONNECTED) {
            this.handleParticipantDisconnected(info.identity, remoteParticipant);
          } else {
            remoteParticipant = this.getOrCreateParticipant(info.identity, info);
          }
        });
      };
      this.handleActiveSpeakersUpdate = (speakers) => {
        const activeSpeakers = [];
        const seenSids = {};
        speakers.forEach((speaker) => {
          seenSids[speaker.sid] = true;
          if (speaker.sid === this.localParticipant.sid) {
            this.localParticipant.audioLevel = speaker.level;
            this.localParticipant.setIsSpeaking(true);
            activeSpeakers.push(this.localParticipant);
          } else {
            const p2 = this.getRemoteParticipantBySid(speaker.sid);
            if (p2) {
              p2.audioLevel = speaker.level;
              p2.setIsSpeaking(true);
              activeSpeakers.push(p2);
            }
          }
        });
        if (!seenSids[this.localParticipant.sid]) {
          this.localParticipant.audioLevel = 0;
          this.localParticipant.setIsSpeaking(false);
        }
        this.remoteParticipants.forEach((p2) => {
          if (!seenSids[p2.sid]) {
            p2.audioLevel = 0;
            p2.setIsSpeaking(false);
          }
        });
        this.activeSpeakers = activeSpeakers;
        this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleSpeakersChanged = (speakerUpdates) => {
        const lastSpeakers = /* @__PURE__ */ new Map();
        this.activeSpeakers.forEach((p2) => {
          const remoteParticipant = this.remoteParticipants.get(p2.identity);
          if (remoteParticipant && remoteParticipant.sid !== p2.sid) {
            return;
          }
          lastSpeakers.set(p2.sid, p2);
        });
        speakerUpdates.forEach((speaker) => {
          let p2 = this.getRemoteParticipantBySid(speaker.sid);
          if (speaker.sid === this.localParticipant.sid) {
            p2 = this.localParticipant;
          }
          if (!p2) {
            return;
          }
          p2.audioLevel = speaker.level;
          p2.setIsSpeaking(speaker.active);
          if (speaker.active) {
            lastSpeakers.set(speaker.sid, p2);
          } else {
            lastSpeakers.delete(speaker.sid);
          }
        });
        const activeSpeakers = Array.from(lastSpeakers.values());
        activeSpeakers.sort((a2, b2) => b2.audioLevel - a2.audioLevel);
        this.activeSpeakers = activeSpeakers;
        this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleStreamStateUpdate = (streamStateUpdate) => {
        streamStateUpdate.streamStates.forEach((streamState) => {
          const participant = this.getRemoteParticipantBySid(streamState.participantSid);
          if (!participant) {
            return;
          }
          const pub = participant.getTrackPublicationBySid(streamState.trackSid);
          if (!pub || !pub.track) {
            return;
          }
          const newStreamState = Track.streamStateFromProto(streamState.state);
          if (newStreamState !== pub.track.streamState) {
            pub.track.streamState = newStreamState;
            participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
            this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
          }
        });
      };
      this.handleSubscriptionPermissionUpdate = (update) => {
        const participant = this.getRemoteParticipantBySid(update.participantSid);
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(update.trackSid);
        if (!pub) {
          return;
        }
        pub.setAllowed(update.allowed);
      };
      this.handleSubscriptionError = (update) => {
        const participant = Array.from(this.remoteParticipants.values()).find((p2) => p2.trackPublications.has(update.trackSid));
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(update.trackSid);
        if (!pub) {
          return;
        }
        pub.setSubscriptionError(update.err);
      };
      this.handleDataPacket = (packet) => {
        const participant = this.remoteParticipants.get(packet.participantIdentity);
        if (packet.value.case === "user") {
          this.handleUserPacket(participant, packet.value.value, packet.kind);
        } else if (packet.value.case === "transcription") {
          this.handleTranscription(participant, packet.value.value);
        } else if (packet.value.case === "sipDtmf") {
          this.handleSipDtmf(participant, packet.value.value);
        } else if (packet.value.case === "chatMessage") {
          this.handleChatMessage(participant, packet.value.value);
        } else if (packet.value.case === "metrics") {
          this.handleMetrics(packet.value.value, participant);
        } else if (packet.value.case === "streamHeader") {
          this.handleStreamHeader(packet.value.value, packet.participantIdentity);
        } else if (packet.value.case === "streamChunk") {
          this.handleStreamChunk(packet.value.value);
        } else if (packet.value.case === "streamTrailer") {
          this.handleStreamTrailer(packet.value.value);
        } else if (packet.value.case === "rpcRequest") {
          const rpc = packet.value.value;
          this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);
        }
      };
      this.handleUserPacket = (participant, userPacket, kind) => {
        this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);
      };
      this.handleSipDtmf = (participant, dtmf) => {
        this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);
      };
      this.bufferedSegments = /* @__PURE__ */ new Map();
      this.handleTranscription = (_remoteParticipant, transcription) => {
        const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);
        const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);
        const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);
        publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);
        this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);
      };
      this.handleChatMessage = (participant, chatMessage) => {
        const msg = extractChatMessage(chatMessage);
        this.emit(RoomEvent.ChatMessage, msg, participant);
      };
      this.handleMetrics = (metrics, participant) => {
        this.emit(RoomEvent.MetricsReceived, metrics, participant);
      };
      this.handleAudioPlaybackStarted = () => {
        if (this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = true;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, true);
      };
      this.handleAudioPlaybackFailed = (e2) => {
        this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
          error: e2
        }));
        if (!this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = false;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, false);
      };
      this.handleVideoPlaybackStarted = () => {
        if (this.isVideoPlaybackBlocked) {
          this.isVideoPlaybackBlocked = false;
          this.emit(RoomEvent.VideoPlaybackStatusChanged, true);
        }
      };
      this.handleVideoPlaybackFailed = () => {
        if (!this.isVideoPlaybackBlocked) {
          this.isVideoPlaybackBlocked = true;
          this.emit(RoomEvent.VideoPlaybackStatusChanged, false);
        }
      };
      this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2;
        const previousDevices = DeviceManager.getInstance().previousDevices;
        const availableDevices = yield DeviceManager.getInstance().getDevices(void 0, false);
        const browser = getBrowser();
        if ((browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && browser.os !== "iOS") {
          for (let availableDevice of availableDevices) {
            const previousDevice = previousDevices.find((info) => info.deviceId === availableDevice.deviceId);
            if (previousDevice && previousDevice.label !== "" && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {
              if (this.getActiveDevice(availableDevice.kind) === "default") {
                this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);
              }
            }
          }
        }
        const kinds = ["audiooutput", "audioinput", "videoinput"];
        for (let kind of kinds) {
          const devicesOfKind = availableDevices.filter((d2) => d2.kind === kind);
          const activeDevice = this.getActiveDevice(kind);
          if (activeDevice === ((_a2 = previousDevices.filter((info) => info.kind === kind)[0]) === null || _a2 === void 0 ? void 0 : _a2.deviceId)) {
            if (devicesOfKind.length > 0 && ((_b2 = devicesOfKind[0]) === null || _b2 === void 0 ? void 0 : _b2.deviceId) !== activeDevice) {
              yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
              continue;
            }
          }
          if (kind === "audioinput" && !isSafari() || kind === "videoinput") {
            continue;
          }
          if (devicesOfKind.length > 0 && !devicesOfKind.find((deviceInfo) => deviceInfo.deviceId === this.getActiveDevice(kind))) {
            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
          }
        }
        this.emit(RoomEvent.MediaDevicesChanged);
      });
      this.handleRoomUpdate = (room) => {
        const oldRoom = this.roomInfo;
        this.roomInfo = room;
        if (oldRoom && oldRoom.metadata !== room.metadata) {
          this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);
        }
        if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {
          this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);
        }
      };
      this.handleConnectionQualityUpdate = (update) => {
        update.updates.forEach((info) => {
          if (info.participantSid === this.localParticipant.sid) {
            this.localParticipant.setConnectionQuality(info.quality);
            return;
          }
          const participant = this.getRemoteParticipantBySid(info.participantSid);
          if (participant) {
            participant.setConnectionQuality(info.quality);
          }
        });
      };
      this.onLocalParticipantMetadataChanged = (metadata) => {
        this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
      };
      this.onLocalParticipantNameChanged = (name) => {
        this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);
      };
      this.onLocalAttributesChanged = (changedAttributes) => {
        this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);
      };
      this.onLocalTrackMuted = (pub) => {
        this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);
      };
      this.onLocalTrackUnmuted = (pub) => {
        this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);
      };
      this.onTrackProcessorUpdate = (processor) => {
        var _a2;
        (_a2 = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a2 === void 0 ? void 0 : _a2.call(processor, this);
      };
      this.onLocalTrackPublished = (pub) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2, _c2, _d, _e2, _f;
        (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
        (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.on(TrackEvent.Restarted, this.onLocalTrackRestarted);
        (_e2 = (_d = (_c2 = pub.track) === null || _c2 === void 0 ? void 0 : _c2.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e2 === void 0 ? void 0 : _e2.call(_d, this);
        this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);
        if (isLocalAudioTrack(pub.track)) {
          const trackIsSilent = yield pub.track.checkForSilence();
          if (trackIsSilent) {
            this.emit(RoomEvent.LocalAudioSilenceDetected, pub);
          }
        }
        const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);
        const deviceKind = sourceToKind(pub.source);
        if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
          this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
          this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
        }
      });
      this.onLocalTrackUnpublished = (pub) => {
        var _a2, _b2;
        (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
        (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.off(TrackEvent.Restarted, this.onLocalTrackRestarted);
        this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
      };
      this.onLocalTrackRestarted = (track) => __awaiter(this, void 0, void 0, function* () {
        const deviceId = yield track.getDeviceId(false);
        const deviceKind = sourceToKind(track.source);
        if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
          this.log.debug("local track restarted, setting ".concat(deviceKind, " ").concat(deviceId, " active"), this.logContext);
          this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
          this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
        }
      });
      this.onLocalConnectionQualityChanged = (quality) => {
        this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
      };
      this.onMediaDevicesError = (e2) => {
        this.emit(RoomEvent.MediaDevicesError, e2);
      };
      this.onLocalParticipantPermissionsChanged = (prevPermissions) => {
        this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);
      };
      this.onLocalChatMessageSent = (msg) => {
        this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);
      };
      this.setMaxListeners(100);
      this.remoteParticipants = /* @__PURE__ */ new Map();
      this.sidToIdentity = /* @__PURE__ */ new Map();
      this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);
      this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);
      this.transcriptionReceivedTimes = /* @__PURE__ */ new Map();
      this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);
      this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);
      this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);
      this.maybeCreateEngine();
      this.disconnectLock = new _$1();
      this.localParticipant = new LocalParticipant("", "", this.engine, this.options, this.rpcHandlers);
      if (this.options.videoCaptureDefaults.deviceId) {
        this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));
      }
      if (this.options.audioCaptureDefaults.deviceId) {
        this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));
      }
      if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {
        this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e2) => this.log.warn("Could not set audio output: ".concat(e2.message), this.logContext));
      }
      if (this.options.e2ee) {
        this.setupE2EE();
      }
      if (isWeb()) {
        const abortController = new AbortController();
        (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener("devicechange", this.handleDeviceChange, {
          signal: abortController.signal
        });
        if (Room.cleanupRegistry) {
          Room.cleanupRegistry.register(this, () => {
            abortController.abort();
          });
        }
      }
    }
    registerTextStreamHandler(topic, callback) {
      if (this.textStreamHandlers.has(topic)) {
        throw new TypeError('A text stream handler for topic "'.concat(topic, '" has already been set.'));
      }
      this.textStreamHandlers.set(topic, callback);
    }
    unregisterTextStreamHandler(topic) {
      this.textStreamHandlers.delete(topic);
    }
    registerByteStreamHandler(topic, callback) {
      if (this.byteStreamHandlers.has(topic)) {
        throw new TypeError('A byte stream handler for topic "'.concat(topic, '" has already been set.'));
      }
      this.byteStreamHandlers.set(topic, callback);
    }
    unregisterByteStreamHandler(topic) {
      this.byteStreamHandlers.delete(topic);
    }
    /**
     * Establishes the participant as a receiver for calls of the specified RPC method.
     * Will overwrite any existing callback for the same method.
     *
     * @param method - The name of the indicated RPC method
     * @param handler - Will be invoked when an RPC request for this method is received
     * @returns A promise that resolves when the method is successfully registered
     * @throws {Error} if the handler for a specific method has already been registered already
     *
     * @example
     * ```typescript
     * room.localParticipant?.registerRpcMethod(
     *   'greet',
     *   async (data: RpcInvocationData) => {
     *     __f__('log','at node_modules/livekit-client/dist/livekit-client.esm.mjs:22580',`Received greeting from ${data.callerIdentity}: ${data.payload}`);
     *     return `Hello, ${data.callerIdentity}!`;
     *   }
     * );
     * ```
     *
     * The handler should return a Promise that resolves to a string.
     * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
     *
     * You may throw errors of type `RpcError` with a string `message` in the handler,
     * and they will be received on the caller's side with the message intact.
     * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
     */
    registerRpcMethod(method, handler) {
      if (this.rpcHandlers.has(method)) {
        throw Error("RPC handler already registered for method ".concat(method, ", unregisterRpcMethod before trying to register again"));
      }
      this.rpcHandlers.set(method, handler);
    }
    /**
     * Unregisters a previously registered RPC method.
     *
     * @param method - The name of the RPC method to unregister
     */
    unregisterRpcMethod(method) {
      this.rpcHandlers.delete(method);
    }
    handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version2) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.engine.publishRpcAck(callerIdentity, requestId);
        if (version2 !== 1) {
          yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_VERSION"));
          return;
        }
        const handler = this.rpcHandlers.get(method);
        if (!handler) {
          yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_METHOD"));
          return;
        }
        let responseError = null;
        let responsePayload = null;
        try {
          const response = yield handler({
            requestId,
            callerIdentity,
            payload,
            responseTimeout
          });
          if (byteLength(response) > MAX_PAYLOAD_BYTES) {
            responseError = RpcError.builtIn("RESPONSE_PAYLOAD_TOO_LARGE");
            formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:22630", "RPC Response payload too large for ".concat(method));
          } else {
            responsePayload = response;
          }
        } catch (error) {
          if (error instanceof RpcError) {
            responseError = error;
          } else {
            formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:22638", "Uncaught error returned by RPC handler for ".concat(method, ". Returning APPLICATION_ERROR instead."), error);
            responseError = RpcError.builtIn("APPLICATION_ERROR");
          }
        }
        yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);
      });
    }
    /**
     * @experimental
     */
    setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.e2eeManager) {
          yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);
          if (this.localParticipant.identity !== "") {
            this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);
          }
        } else {
          throw Error("e2ee not configured, please set e2ee settings within the room options");
        }
      });
    }
    setupE2EE() {
      var _a;
      if (this.options.e2ee) {
        if ("e2eeManager" in this.options.e2ee) {
          this.e2eeManager = this.options.e2ee.e2eeManager;
        } else {
          this.e2eeManager = new E2EEManager(this.options.e2ee);
        }
        this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant) => {
          if (isLocalParticipant(participant)) {
            this.isE2EEEnabled = enabled;
          }
          this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);
        });
        this.e2eeManager.on(EncryptionEvent.EncryptionError, (error) => this.emit(RoomEvent.EncryptionError, error));
        (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);
      }
    }
    get logContext() {
      var _a;
      return {
        room: this.name,
        roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,
        participant: this.localParticipant.identity,
        pID: this.localParticipant.sid
      };
    }
    /**
     * if the current room has a participant with `recorder: true` in its JWT grant
     **/
    get isRecording() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * server assigned unique room id.
     * returns once a sid has been issued by the server.
     */
    getSid() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state === ConnectionState.Disconnected) {
          return "";
        }
        if (this.roomInfo && this.roomInfo.sid !== "") {
          return this.roomInfo.sid;
        }
        return new Promise((resolve, reject) => {
          const handleRoomUpdate = (roomInfo) => {
            if (roomInfo.sid !== "") {
              this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
              resolve(roomInfo.sid);
            }
          };
          this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);
          this.once(RoomEvent.Disconnected, () => {
            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
            reject("Room disconnected before room server id was available");
          });
        });
      });
    }
    /** user assigned name, derived from JWT token */
    get name() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "";
    }
    /** room metadata */
    get metadata() {
      var _a;
      return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;
    }
    get numParticipants() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;
    }
    get numPublishers() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;
    }
    maybeCreateEngine() {
      if (this.engine && !this.engine.isClosed) {
        return;
      }
      this.engine = new RTCEngine(this.options);
      this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {
        this.onTrackAdded(mediaTrack, stream, receiver);
      }).on(EngineEvent.Disconnected, (reason) => {
        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);
      }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
        this.clearConnectionReconcile();
        this.isResuming = true;
        this.log.info("Resuming signal connection", this.logContext);
        if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {
          this.emit(RoomEvent.SignalReconnecting);
        }
      }).on(EngineEvent.Resumed, () => {
        this.registerConnectionReconcile();
        this.isResuming = false;
        this.log.info("Resumed signal connection", this.logContext);
        this.updateSubscriptions();
        this.emitBufferedEvents();
        if (this.setAndEmitConnectionState(ConnectionState.Connected)) {
          this.emit(RoomEvent.Reconnected);
        }
      }).on(EngineEvent.SignalResumed, () => {
        this.bufferedEvents = [];
        if (this.state === ConnectionState.Reconnecting || this.isResuming) {
          this.sendSyncState();
        }
      }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {
        if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
          this.emit(RoomEvent.Reconnecting);
        }
      }).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {
        this.emit(RoomEvent.DCBufferStatusChanged, status, kind);
      }).on(EngineEvent.LocalTrackSubscribed, (subscribedSid) => {
        const trackPublication = this.localParticipant.getTrackPublications().find((_ref2) => {
          let {
            trackSid
          } = _ref2;
          return trackSid === subscribedSid;
        });
        if (!trackPublication) {
          this.log.warn("could not find local track subscription for subscribed event", this.logContext);
          return;
        }
        this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);
        this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);
      });
      if (this.localParticipant) {
        this.localParticipant.setupEngine(this.engine);
      }
      if (this.e2eeManager) {
        this.e2eeManager.setupEngine(this.engine);
      }
    }
    /**
     * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
     * In particular, it requests device permissions by default if needed
     * and makes sure the returned device does not consist of dummy devices
     * @param kind
     * @returns a list of available local devices
     */
    static getLocalDevices(kind) {
      let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return DeviceManager.getInstance().getDevices(kind, requestPermissions);
    }
    /**
     * prepareConnection should be called as soon as the page is loaded, in order
     * to speed up the connection attempt. This function will
     * - perform DNS resolution and pre-warm the DNS cache
     * - establish TLS connection and cache TLS keys
     *
     * With LiveKit Cloud, it will also determine the best edge data center for
     * the current client to connect to if a token is provided.
     */
    prepareConnection(url, token) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state !== ConnectionState.Disconnected) {
          return;
        }
        this.log.debug("prepareConnection to ".concat(url), this.logContext);
        try {
          if (isCloud(new URL(url)) && token) {
            this.regionUrlProvider = new RegionUrlProvider(url, token);
            const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();
            if (regionUrl && this.state === ConnectionState.Disconnected) {
              this.regionUrl = regionUrl;
              yield fetch(toHttpUrl(regionUrl), {
                method: "HEAD"
              });
              this.log.debug("prepared connection to ".concat(regionUrl), this.logContext);
            }
          } else {
            yield fetch(toHttpUrl(url), {
              method: "HEAD"
            });
          }
        } catch (e2) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: e2
          }));
        }
      });
    }
    /**
     * retrieves a participant by identity
     * @param identity
     * @returns
     */
    getParticipantByIdentity(identity) {
      if (this.localParticipant.identity === identity) {
        return this.localParticipant;
      }
      return this.remoteParticipants.get(identity);
    }
    clearConnectionFutures() {
      this.connectFuture = void 0;
    }
    /**
     * @internal for testing
     */
    simulateScenario(scenario, arg) {
      return __awaiter(this, void 0, void 0, function* () {
        let postAction = () => {
        };
        let req;
        switch (scenario) {
          case "signal-reconnect":
            yield this.engine.client.handleOnClose("simulate disconnect");
            break;
          case "speaker":
            req = new SimulateScenario({
              scenario: {
                case: "speakerUpdate",
                value: 3
              }
            });
            break;
          case "node-failure":
            req = new SimulateScenario({
              scenario: {
                case: "nodeFailure",
                value: true
              }
            });
            break;
          case "server-leave":
            req = new SimulateScenario({
              scenario: {
                case: "serverLeave",
                value: true
              }
            });
            break;
          case "migration":
            req = new SimulateScenario({
              scenario: {
                case: "migration",
                value: true
              }
            });
            break;
          case "resume-reconnect":
            this.engine.failNext();
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
            break;
          case "disconnect-signal-on-resume":
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              yield this.engine.client.handleOnClose("simulate resume-disconnect");
            });
            req = new SimulateScenario({
              scenario: {
                case: "disconnectSignalOnResume",
                value: true
              }
            });
            break;
          case "disconnect-signal-on-resume-no-messages":
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              yield this.engine.client.handleOnClose("simulate resume-disconnect");
            });
            req = new SimulateScenario({
              scenario: {
                case: "disconnectSignalOnResumeNoMessages",
                value: true
              }
            });
            break;
          case "full-reconnect":
            this.engine.fullReconnectOnNext = true;
            yield this.engine.client.handleOnClose("simulate full-reconnect");
            break;
          case "force-tcp":
          case "force-tls":
            req = new SimulateScenario({
              scenario: {
                case: "switchCandidateProtocol",
                value: scenario === "force-tls" ? 2 : 1
              }
            });
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              const onLeave = this.engine.client.onLeave;
              if (onLeave) {
                onLeave(new LeaveRequest({
                  reason: DisconnectReason.CLIENT_INITIATED,
                  action: LeaveRequest_Action.RECONNECT
                }));
              }
            });
            break;
          case "subscriber-bandwidth":
            if (arg === void 0 || typeof arg !== "number") {
              throw new Error("subscriber-bandwidth requires a number as argument");
            }
            req = new SimulateScenario({
              scenario: {
                case: "subscriberBandwidth",
                value: numberToBigInt(arg)
              }
            });
            break;
          case "leave-full-reconnect":
            req = new SimulateScenario({
              scenario: {
                case: "leaveRequestFullReconnect",
                value: true
              }
            });
        }
        if (req) {
          yield this.engine.client.sendSimulateScenario(req);
          yield postAction();
        }
      });
    }
    /**
     * Returns true if audio playback is enabled
     */
    get canPlaybackAudio() {
      return this.audioEnabled;
    }
    /**
     * Returns true if video playback is enabled
     */
    get canPlaybackVideo() {
      return !this.isVideoPlaybackBlocked;
    }
    getActiveDevice(kind) {
      return this.localParticipant.activeDeviceMap.get(kind);
    }
    /**
     * Switches all active devices used in this room to the given device.
     *
     * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
     *
     * @param kind use `videoinput` for camera track,
     *  `audioinput` for microphone track,
     *  `audiooutput` to set speaker for all incoming audio tracks
     * @param deviceId
     */
    switchActiveDevice(kind_1, deviceId_1) {
      return __awaiter(this, arguments, void 0, function(kind, deviceId) {
        var _this3 = this;
        let exact = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return function* () {
          var _a, _b, _c, _d, _e2, _f, _g;
          var _h;
          let success = true;
          let needsUpdateWithoutTracks = false;
          const deviceConstraint = exact ? {
            exact: deviceId
          } : deviceId;
          if (kind === "audioinput") {
            needsUpdateWithoutTracks = _this3.localParticipant.audioTrackPublications.size === 0;
            const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;
            _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;
            const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter((track) => track.source === Track.Source.Microphone);
            try {
              success = (yield Promise.all(tracks.map((t2) => {
                var _a2;
                return (_a2 = t2.audioTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);
              }))).every((val) => val === true);
            } catch (e2) {
              _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;
              throw e2;
            }
          } else if (kind === "videoinput") {
            needsUpdateWithoutTracks = _this3.localParticipant.videoTrackPublications.size === 0;
            const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;
            _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;
            const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter((track) => track.source === Track.Source.Camera);
            try {
              success = (yield Promise.all(tracks.map((t2) => {
                var _a2;
                return (_a2 = t2.videoTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);
              }))).every((val) => val === true);
            } catch (e2) {
              _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;
              throw e2;
            }
          } else if (kind === "audiooutput") {
            if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !("setSinkId" in _this3.audioContext)) {
              throw new Error("cannot switch audio output, setSinkId not supported");
            }
            if (_this3.options.webAudioMix) {
              deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId("audiooutput", deviceId)) !== null && _c !== void 0 ? _c : "";
            }
            (_d = (_h = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _h.audioOutput = {};
            const prevDeviceId = (_e2 = _this3.getActiveDevice(kind)) !== null && _e2 !== void 0 ? _e2 : _this3.options.audioOutput.deviceId;
            _this3.options.audioOutput.deviceId = deviceId;
            try {
              if (_this3.options.webAudioMix) {
                (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);
              }
              yield Promise.all(Array.from(_this3.remoteParticipants.values()).map((p2) => p2.setAudioOutput({
                deviceId
              })));
            } catch (e2) {
              _this3.options.audioOutput.deviceId = prevDeviceId;
              throw e2;
            }
          }
          if (needsUpdateWithoutTracks || kind === "audiooutput") {
            _this3.localParticipant.activeDeviceMap.set(kind, kind === "audiooutput" && ((_g = _this3.options.audioOutput) === null || _g === void 0 ? void 0 : _g.deviceId) || deviceId);
            _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);
          }
          return success;
        }();
      });
    }
    setupLocalParticipantEvents() {
      this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
    }
    recreateEngine() {
      var _a;
      (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
      this.engine = void 0;
      this.isResuming = false;
      this.remoteParticipants.clear();
      this.sidToIdentity.clear();
      this.bufferedEvents = [];
      this.maybeCreateEngine();
    }
    onTrackAdded(mediaTrack, stream, receiver) {
      if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
        const reconnectedHandler = () => {
          this.onTrackAdded(mediaTrack, stream, receiver);
          cleanup();
        };
        const cleanup = () => {
          this.off(RoomEvent.Reconnected, reconnectedHandler);
          this.off(RoomEvent.Connected, reconnectedHandler);
          this.off(RoomEvent.Disconnected, cleanup);
        };
        this.once(RoomEvent.Reconnected, reconnectedHandler);
        this.once(RoomEvent.Connected, reconnectedHandler);
        this.once(RoomEvent.Disconnected, cleanup);
        return;
      }
      if (this.state === ConnectionState.Disconnected) {
        this.log.warn("skipping incoming track after Room disconnected", this.logContext);
        return;
      }
      const parts = unpackStreamId(stream.id);
      const participantSid = parts[0];
      let streamId = parts[1];
      let trackId = mediaTrack.id;
      if (streamId && streamId.startsWith("TR"))
        trackId = streamId;
      if (participantSid === this.localParticipant.sid) {
        this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
        return;
      }
      const participant = Array.from(this.remoteParticipants.values()).find((p2) => p2.sid === participantSid);
      if (!participant) {
        this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(participantSid), this.logContext);
        return;
      }
      let adaptiveStreamSettings;
      if (this.options.adaptiveStream) {
        if (typeof this.options.adaptiveStream === "object") {
          adaptiveStreamSettings = this.options.adaptiveStream;
        } else {
          adaptiveStreamSettings = {};
        }
      }
      participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);
    }
    handleDisconnect() {
      let shouldStopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      let reason = arguments.length > 1 ? arguments[1] : void 0;
      var _a;
      this.clearConnectionReconcile();
      this.isResuming = false;
      this.bufferedEvents = [];
      this.transcriptionReceivedTimes.clear();
      if (this.state === ConnectionState.Disconnected) {
        return;
      }
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((p2) => {
          p2.trackPublications.forEach((pub) => {
            p2.unpublishTrack(pub.trackSid);
          });
        });
        this.localParticipant.trackPublications.forEach((pub) => {
          var _a2, _b, _c;
          if (pub.track) {
            this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);
          }
          if (shouldStopTracks) {
            (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.detach();
            (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
          } else {
            (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();
          }
        });
        this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
        this.localParticipant.trackPublications.clear();
        this.localParticipant.videoTrackPublications.clear();
        this.localParticipant.audioTrackPublications.clear();
        this.remoteParticipants.clear();
        this.sidToIdentity.clear();
        this.activeSpeakers = [];
        if (this.audioContext && typeof this.options.webAudioMix === "boolean") {
          this.audioContext.close();
          this.audioContext = void 0;
        }
        if (isWeb()) {
          window.removeEventListener("beforeunload", this.onPageLeave);
          window.removeEventListener("pagehide", this.onPageLeave);
          window.removeEventListener("freeze", this.onPageLeave);
          (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener("devicechange", this.handleDeviceChange);
        }
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected);
        this.emit(RoomEvent.Disconnected, reason);
      }
    }
    handleParticipantDisconnected(identity, participant) {
      var _a;
      this.remoteParticipants.delete(identity);
      if (!participant) {
        return;
      }
      participant.trackPublications.forEach((publication) => {
        participant.unpublishTrack(publication.trackSid, true);
      });
      this.emit(RoomEvent.ParticipantDisconnected, participant);
      (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);
    }
    handleStreamHeader(streamHeader, participantIdentity) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (streamHeader.contentHeader.case === "byteHeader") {
          const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);
          if (!streamHandlerCallback) {
            this.log.debug("ignoring incoming byte stream due to no handler for topic", streamHeader.topic);
            return;
          }
          let streamController;
          const info = {
            id: streamHeader.streamId,
            name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : "unknown",
            mimeType: streamHeader.mimeType,
            size: streamHeader.totalLength ? Number(streamHeader.totalLength) : void 0,
            topic: streamHeader.topic,
            timestamp: bigIntToNumber(streamHeader.timestamp),
            attributes: streamHeader.attributes
          };
          const stream = new ReadableStream({
            start: (controller) => {
              streamController = controller;
              this.byteStreamControllers.set(streamHeader.streamId, {
                info,
                controller: streamController,
                startTime: Date.now()
              });
            }
          });
          streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {
            identity: participantIdentity
          });
        } else if (streamHeader.contentHeader.case === "textHeader") {
          const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);
          if (!streamHandlerCallback) {
            this.log.debug("ignoring incoming text stream due to no handler for topic", streamHeader.topic);
            return;
          }
          let streamController;
          const info = {
            id: streamHeader.streamId,
            mimeType: streamHeader.mimeType,
            size: streamHeader.totalLength ? Number(streamHeader.totalLength) : void 0,
            topic: streamHeader.topic,
            timestamp: Number(streamHeader.timestamp),
            attributes: streamHeader.attributes
          };
          const stream = new ReadableStream({
            start: (controller) => {
              streamController = controller;
              this.textStreamControllers.set(streamHeader.streamId, {
                info,
                controller: streamController,
                startTime: Date.now()
              });
            }
          });
          streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {
            identity: participantIdentity
          });
        }
      });
    }
    handleStreamChunk(chunk) {
      const fileBuffer = this.byteStreamControllers.get(chunk.streamId);
      if (fileBuffer) {
        if (chunk.content.length > 0) {
          fileBuffer.controller.enqueue(chunk);
        }
      }
      const textBuffer = this.textStreamControllers.get(chunk.streamId);
      if (textBuffer) {
        if (chunk.content.length > 0) {
          textBuffer.controller.enqueue(chunk);
        }
      }
    }
    handleStreamTrailer(trailer) {
      const textBuffer = this.textStreamControllers.get(trailer.streamId);
      if (textBuffer) {
        textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);
        textBuffer.controller.close();
        this.byteStreamControllers.delete(trailer.streamId);
      }
      const fileBuffer = this.byteStreamControllers.get(trailer.streamId);
      if (fileBuffer) {
        {
          fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);
          fileBuffer.controller.close();
          this.byteStreamControllers.delete(trailer.streamId);
        }
      }
    }
    acquireAudioContext() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (typeof this.options.webAudioMix !== "boolean" && this.options.webAudioMix.audioContext) {
          this.audioContext = this.options.webAudioMix.audioContext;
        } else if (!this.audioContext || this.audioContext.state === "closed") {
          this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : void 0;
        }
        if (this.options.webAudioMix) {
          this.remoteParticipants.forEach((participant) => participant.setAudioContext(this.audioContext));
        }
        this.localParticipant.setAudioContext(this.audioContext);
        if (this.audioContext && this.audioContext.state === "suspended") {
          try {
            yield Promise.race([this.audioContext.resume(), sleep(200)]);
          } catch (e2) {
            this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
              error: e2
            }));
          }
        }
        const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === "running";
        if (newContextIsRunning !== this.canPlaybackAudio) {
          this.audioEnabled = newContextIsRunning;
          this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);
        }
      });
    }
    createParticipant(identity, info) {
      var _a;
      let participant;
      if (info) {
        participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {
          loggerContextCb: () => this.logContext,
          loggerName: this.options.loggerName
        });
      } else {
        participant = new RemoteParticipant(this.engine.client, "", identity, void 0, void 0, void 0, {
          loggerContextCb: () => this.logContext,
          loggerName: this.options.loggerName
        });
      }
      if (this.options.webAudioMix) {
        participant.setAudioContext(this.audioContext);
      }
      if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {
        participant.setAudioOutput(this.options.audioOutput).catch((e2) => this.log.warn("Could not set audio output: ".concat(e2.message), this.logContext));
      }
      return participant;
    }
    getOrCreateParticipant(identity, info) {
      if (this.remoteParticipants.has(identity)) {
        const existingParticipant = this.remoteParticipants.get(identity);
        if (info) {
          const wasUpdated = existingParticipant.updateInfo(info);
          if (wasUpdated) {
            this.sidToIdentity.set(info.sid, info.identity);
          }
        }
        return existingParticipant;
      }
      const participant = this.createParticipant(identity, info);
      this.remoteParticipants.set(identity, participant);
      this.sidToIdentity.set(info.sid, info.identity);
      this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);
      participant.on(ParticipantEvent.TrackPublished, (trackPublication) => {
        this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);
      }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {
        if (track.kind === Track.Kind.Audio) {
          track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
          track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
        } else if (track.kind === Track.Kind.Video) {
          track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);
          track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);
        }
        this.emit(RoomEvent.TrackSubscribed, track, publication, participant);
      }).on(ParticipantEvent.TrackUnpublished, (publication) => {
        this.emit(RoomEvent.TrackUnpublished, publication, participant);
      }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {
        this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);
      }).on(ParticipantEvent.TrackMuted, (pub) => {
        this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);
      }).on(ParticipantEvent.TrackUnmuted, (pub) => {
        this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);
      }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
        this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);
      }).on(ParticipantEvent.ParticipantNameChanged, (name) => {
        this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);
      }).on(ParticipantEvent.AttributesChanged, (changedAttributes) => {
        this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);
      }).on(ParticipantEvent.ConnectionQualityChanged, (quality) => {
        this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);
      }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {
        this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);
      }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {
        this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);
      }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {
        this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);
      }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {
        this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);
      });
      if (info) {
        participant.updateInfo(info);
      }
      return participant;
    }
    sendSyncState() {
      const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant) => {
        acc.push(...participant.getTrackPublications());
        return acc;
      }, []);
      const localTracks = this.localParticipant.getTrackPublications();
      this.engine.sendSyncState(remoteTracks, localTracks);
    }
    /**
     * After resuming, we'll need to notify the server of the current
     * subscription settings.
     */
    updateSubscriptions() {
      for (const p2 of this.remoteParticipants.values()) {
        for (const pub of p2.videoTrackPublications.values()) {
          if (pub.isSubscribed && isRemotePub(pub)) {
            pub.emitTrackUpdate();
          }
        }
      }
    }
    getRemoteParticipantBySid(sid) {
      const identity = this.sidToIdentity.get(sid);
      if (identity) {
        return this.remoteParticipants.get(identity);
      }
    }
    registerConnectionReconcile() {
      this.clearConnectionReconcile();
      let consecutiveFailures = 0;
      this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
        if (
          // ensure we didn't tear it down
          !this.engine || // engine detected close, but Room missed it
          this.engine.isClosed || // transports failed without notifying engine
          !this.engine.verifyTransport()
        ) {
          consecutiveFailures++;
          this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
            numFailures: consecutiveFailures,
            engine: this.engine ? {
              closed: this.engine.isClosed,
              transportsConnected: this.engine.verifyTransport()
            } : void 0
          }));
          if (consecutiveFailures >= 3) {
            this.recreateEngine();
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);
          }
        } else {
          consecutiveFailures = 0;
        }
      }, connectionReconcileFrequency);
    }
    clearConnectionReconcile() {
      if (this.connectionReconcileInterval) {
        CriticalTimers.clearInterval(this.connectionReconcileInterval);
      }
    }
    setAndEmitConnectionState(state) {
      if (state === this.state) {
        return false;
      }
      this.state = state;
      this.emit(RoomEvent.ConnectionStateChanged, this.state);
      return true;
    }
    emitBufferedEvents() {
      this.bufferedEvents.forEach((_ref3) => {
        let [ev, args] = _ref3;
        this.emit(ev, ...args);
      });
      this.bufferedEvents = [];
    }
    emitWhenConnected(event) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {
        this.bufferedEvents.push([event, args]);
      } else if (this.state === ConnectionState.Connected) {
        return this.emit(event, ...args);
      }
      return false;
    }
    /**
     * Allows to populate a room with simulated participants.
     * No actual connection to a server will be established, all state is
     * @experimental
     */
    simulateParticipants(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const publishOptions = Object.assign({
          audio: true,
          video: true,
          useRealTracks: false
        }, options.publish);
        const participantOptions = Object.assign({
          count: 9,
          audio: false,
          video: true,
          aspectRatios: [1.66, 1.7, 1.3]
        }, options.participants);
        this.handleDisconnect();
        this.roomInfo = new Room$1({
          sid: "RM_SIMULATED",
          name: "simulated-room",
          emptyTimeout: 0,
          maxParticipants: 0,
          creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
          metadata: "",
          numParticipants: 1,
          numPublishers: 1,
          turnPassword: "",
          enabledCodecs: [],
          activeRecording: false
        });
        this.localParticipant.updateInfo(new ParticipantInfo({
          identity: "simulated-local",
          name: "local-name"
        }));
        this.setupLocalParticipantEvents();
        this.emit(RoomEvent.SignalConnected);
        this.emit(RoomEvent.Connected);
        this.setAndEmitConnectionState(ConnectionState.Connected);
        if (publishOptions.video) {
          const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO,
            name: "video-dummy"
          }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
            video: true
          })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), void 0, false, {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          }), {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          });
          this.localParticipant.addTrackPublication(camPub);
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);
        }
        if (publishOptions.audio) {
          const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
            audio: true
          })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, false, this.audioContext, {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          }), {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          });
          this.localParticipant.addTrackPublication(audioPub);
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);
        }
        for (let i2 = 0; i2 < participantOptions.count - 1; i2 += 1) {
          let info = new ParticipantInfo({
            sid: Math.floor(Math.random() * 1e4).toString(),
            identity: "simulated-".concat(i2),
            state: ParticipantInfo_State.ACTIVE,
            tracks: [],
            joinedAt: protoInt64.parse(Date.now())
          });
          const p2 = this.getOrCreateParticipant(info.identity, info);
          if (participantOptions.video) {
            const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i2 % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);
            const videoTrack = new TrackInfo({
              source: TrackSource.CAMERA,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO
            });
            p2.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());
            info.tracks = [...info.tracks, videoTrack];
          }
          if (participantOptions.audio) {
            const dummyTrack = getEmptyAudioStreamTrack();
            const audioTrack = new TrackInfo({
              source: TrackSource.MICROPHONE,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO
            });
            p2.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());
            info.tracks = [...info.tracks, audioTrack];
          }
          p2.updateInfo(info);
        }
      });
    }
    // /** @internal */
    emit(event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      if (event !== RoomEvent.ActiveSpeakersChanged) {
        const minimizedArgs = mapArgs(args).filter((arg) => arg !== void 0);
        this.log.debug("room event ".concat(event), Object.assign(Object.assign({}, this.logContext), {
          event,
          args: minimizedArgs
        }));
      }
      return super.emit(event, ...args);
    }
  }
  Room.cleanupRegistry = typeof FinalizationRegistry !== "undefined" && new FinalizationRegistry((cleanup) => {
    cleanup();
  });
  function mapArgs(args) {
    return args.map((arg) => {
      if (!arg) {
        return;
      }
      if (Array.isArray(arg)) {
        return mapArgs(arg);
      }
      if (typeof arg === "object") {
        return "logContext" in arg ? arg.logContext : void 0;
      }
      return arg;
    });
  }
  var CheckStatus;
  (function(CheckStatus2) {
    CheckStatus2[CheckStatus2["IDLE"] = 0] = "IDLE";
    CheckStatus2[CheckStatus2["RUNNING"] = 1] = "RUNNING";
    CheckStatus2[CheckStatus2["SKIPPED"] = 2] = "SKIPPED";
    CheckStatus2[CheckStatus2["SUCCESS"] = 3] = "SUCCESS";
    CheckStatus2[CheckStatus2["FAILED"] = 4] = "FAILED";
  })(CheckStatus || (CheckStatus = {}));
  class Checker extends eventsExports.EventEmitter {
    constructor(url, token) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super();
      this.status = CheckStatus.IDLE;
      this.logs = [];
      this.errorsAsWarnings = false;
      this.url = url;
      this.token = token;
      this.name = this.constructor.name;
      this.room = new Room(options.roomOptions);
      this.connectOptions = options.connectOptions;
      if (options.errorsAsWarnings) {
        this.errorsAsWarnings = options.errorsAsWarnings;
      }
    }
    run(onComplete) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.status !== CheckStatus.IDLE) {
          throw Error("check is running already");
        }
        this.setStatus(CheckStatus.RUNNING);
        try {
          yield this.perform();
        } catch (err) {
          if (err instanceof Error) {
            if (this.errorsAsWarnings) {
              this.appendWarning(err.message);
            } else {
              this.appendError(err.message);
            }
          }
        }
        yield this.disconnect();
        yield new Promise((resolve) => setTimeout(resolve, 500));
        if (this.status !== CheckStatus.SKIPPED) {
          this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);
        }
        if (onComplete) {
          onComplete();
        }
        return this.getInfo();
      });
    }
    isSuccess() {
      return !this.logs.some((l2) => l2.level === "error");
    }
    connect() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.room.state === ConnectionState.Connected) {
          return this.room;
        }
        yield this.room.connect(this.url, this.token, this.connectOptions);
        return this.room;
      });
    }
    disconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.room && this.room.state !== ConnectionState.Disconnected) {
          yield this.room.disconnect();
          yield new Promise((resolve) => setTimeout(resolve, 500));
        }
      });
    }
    skip() {
      this.setStatus(CheckStatus.SKIPPED);
    }
    appendMessage(message) {
      this.logs.push({
        level: "info",
        message
      });
      this.emit("update", this.getInfo());
    }
    appendWarning(message) {
      this.logs.push({
        level: "warning",
        message
      });
      this.emit("update", this.getInfo());
    }
    appendError(message) {
      this.logs.push({
        level: "error",
        message
      });
      this.emit("update", this.getInfo());
    }
    setStatus(status) {
      this.status = status;
      this.emit("update", this.getInfo());
    }
    get engine() {
      var _a;
      return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;
    }
    getInfo() {
      return {
        logs: this.logs,
        name: this.name,
        status: this.status,
        description: this.description
      };
    }
  }
  function createLocalTracks(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      options !== null && options !== void 0 ? options : options = {};
      (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = {
        deviceId: "default"
      };
      (_b = options.video) !== null && _b !== void 0 ? _b : options.video = {
        deviceId: "default"
      };
      const {
        audioProcessor,
        videoProcessor
      } = extractProcessorsFromOptions(options);
      const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);
      const constraints = constraintsForOptions(opts);
      const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);
      if (options.audio) {
        DeviceManager.userMediaPromiseMap.set("audioinput", mediaPromise);
        mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"));
      }
      if (options.video) {
        DeviceManager.userMediaPromiseMap.set("videoinput", mediaPromise);
        mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput"));
      }
      const stream = yield mediaPromise;
      return Promise.all(stream.getTracks().map((mediaStreamTrack) => __awaiter(this, void 0, void 0, function* () {
        const isAudio = mediaStreamTrack.kind === "audio";
        isAudio ? opts.audio : opts.video;
        let trackConstraints;
        const conOrBool = isAudio ? constraints.audio : constraints.video;
        if (typeof conOrBool !== "boolean") {
          trackConstraints = conOrBool;
        }
        if (trackConstraints) {
          trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;
        } else {
          trackConstraints = {
            deviceId: mediaStreamTrack.getSettings().deviceId
          };
        }
        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
        if (track.kind === Track.Kind.Video) {
          track.source = Track.Source.Camera;
        } else if (track.kind === Track.Kind.Audio) {
          track.source = Track.Source.Microphone;
        }
        track.mediaStream = stream;
        if (isAudioTrack(track) && audioProcessor) {
          yield track.setProcessor(audioProcessor);
        } else if (isVideoTrack(track) && videoProcessor) {
          yield track.setProcessor(videoProcessor);
        }
        return track;
      })));
    });
  }
  function createLocalVideoTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const tracks = yield createLocalTracks({
        audio: false,
        video: options
      });
      return tracks[0];
    });
  }
  function createLocalAudioTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const tracks = yield createLocalTracks({
        audio: options,
        video: false
      });
      return tracks[0];
    });
  }
  class PublishAudioCheck extends Checker {
    get description() {
      return "Can publish audio";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        const track = yield createLocalAudioTrack();
        room.localParticipant.publishTrack(track);
        yield new Promise((resolve) => setTimeout(resolve, 3e3));
        const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
        if (!stats) {
          throw new Error("Could not get RTCStats");
        }
        let numPackets = 0;
        stats.forEach((stat) => {
          if (stat.type === "outbound-rtp" && (stat.kind === "audio" || !stat.kind && stat.mediaType === "audio")) {
            numPackets = stat.packetsSent;
          }
        });
        if (numPackets === 0) {
          throw new Error("Could not determine packets are sent");
        }
        this.appendMessage("published ".concat(numPackets, " audio packets"));
      });
    }
  }
  class PublishVideoCheck extends Checker {
    get description() {
      return "Can publish video";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        const track = yield createLocalVideoTrack();
        room.localParticipant.publishTrack(track);
        yield new Promise((resolve) => setTimeout(resolve, 5e3));
        const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
        if (!stats) {
          throw new Error("Could not get RTCStats");
        }
        let numPackets = 0;
        stats.forEach((stat) => {
          if (stat.type === "outbound-rtp" && (stat.kind === "video" || !stat.kind && stat.mediaType === "video")) {
            numPackets += stat.packetsSent;
          }
        });
        if (numPackets === 0) {
          throw new Error("Could not determine packets are sent");
        }
        this.appendMessage("published ".concat(numPackets, " video packets"));
      });
    }
  }
  class ReconnectCheck extends Checker {
    get description() {
      return "Resuming connection after interruption";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        let reconnectingTriggered = false;
        let reconnected = false;
        let reconnectResolver;
        const reconnectTimeout = new Promise((resolve) => {
          setTimeout(resolve, 5e3);
          reconnectResolver = resolve;
        });
        const handleReconnecting = () => {
          reconnectingTriggered = true;
        };
        room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, () => {
          reconnected = true;
          reconnectResolver(true);
        });
        (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();
        const onClose = room.engine.client.onClose;
        if (onClose) {
          onClose("");
        }
        yield reconnectTimeout;
        if (!reconnectingTriggered) {
          throw new Error("Did not attempt to reconnect");
        } else if (!reconnected || room.state !== ConnectionState.Connected) {
          this.appendWarning("reconnection is only possible in Redis-based configurations");
          throw new Error("Not able to reconnect");
        }
      });
    }
  }
  class TURNCheck extends Checker {
    get description() {
      return "Can connect via TURN";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const signalClient = new SignalClient();
        const joinRes = yield signalClient.join(this.url, this.token, {
          autoSubscribe: true,
          maxRetries: 0,
          e2eeEnabled: false,
          websocketTimeout: 15e3
        });
        let hasTLS = false;
        let hasTURN = false;
        let hasSTUN = false;
        for (let iceServer of joinRes.iceServers) {
          for (let url of iceServer.urls) {
            if (url.startsWith("turn:")) {
              hasTURN = true;
              hasSTUN = true;
            } else if (url.startsWith("turns:")) {
              hasTURN = true;
              hasSTUN = true;
              hasTLS = true;
            }
            if (url.startsWith("stun:")) {
              hasSTUN = true;
            }
          }
        }
        if (!hasSTUN) {
          this.appendWarning("No STUN servers configured on server side.");
        } else if (hasTURN && !hasTLS) {
          this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.");
        }
        yield signalClient.close();
        if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {
          yield this.room.connect(this.url, this.token, {
            rtcConfig: {
              iceTransportPolicy: "relay"
            }
          });
        } else {
          this.appendWarning("No TURN servers configured.");
          this.skip();
          yield new Promise((resolve) => setTimeout(resolve, 0));
        }
      });
    }
  }
  class WebRTCCheck extends Checker {
    get description() {
      return "Establishing WebRTC connection";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        let hasTcp = false;
        let hasIpv4Udp = false;
        this.room.on(RoomEvent.SignalConnected, () => {
          const prevTrickle = this.room.engine.client.onTrickle;
          this.room.engine.client.onTrickle = (sd, target) => {
            if (sd.candidate) {
              const candidate = new RTCIceCandidate(sd);
              let str = "".concat(candidate.protocol, " ").concat(candidate.address, ":").concat(candidate.port, " ").concat(candidate.type);
              if (candidate.address) {
                if (isIPPrivate(candidate.address)) {
                  str += " (private)";
                } else {
                  if (candidate.protocol === "tcp" && candidate.tcpType === "passive") {
                    hasTcp = true;
                    str += " (passive)";
                  } else if (candidate.protocol === "udp") {
                    hasIpv4Udp = true;
                  }
                }
              }
              this.appendMessage(str);
            }
            if (prevTrickle) {
              prevTrickle(sd, target);
            }
          };
          if (this.room.engine.pcManager) {
            this.room.engine.pcManager.subscriber.onIceCandidateError = (ev) => {
              if (ev instanceof RTCPeerConnectionIceErrorEvent) {
                this.appendWarning("error with ICE candidate: ".concat(ev.errorCode, " ").concat(ev.errorText, " ").concat(ev.url));
              }
            };
          }
        });
        try {
          yield this.connect();
          livekitLogger.info("now the room is connected");
        } catch (err) {
          this.appendWarning("ports need to be open on firewall in order to connect.");
          throw err;
        }
        if (!hasTcp) {
          this.appendWarning("Server is not configured for ICE/TCP");
        }
        if (!hasIpv4Udp) {
          this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
        }
      });
    }
  }
  function isIPPrivate(address) {
    const parts = address.split(".");
    if (parts.length === 4) {
      if (parts[0] === "10") {
        return true;
      } else if (parts[0] === "192" && parts[1] === "168") {
        return true;
      } else if (parts[0] === "172") {
        const second = parseInt(parts[1], 10);
        if (second >= 16 && second <= 31) {
          return true;
        }
      }
    }
    return false;
  }
  class WebSocketCheck extends Checker {
    get description() {
      return "Connecting to signal connection via WebSocket";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (this.url.startsWith("ws:") || this.url.startsWith("http:")) {
          this.appendWarning("Server is insecure, clients may block connections to it");
        }
        let signalClient = new SignalClient();
        const joinRes = yield signalClient.join(this.url, this.token, {
          autoSubscribe: true,
          maxRetries: 0,
          e2eeEnabled: false,
          websocketTimeout: 15e3
        });
        this.appendMessage("Connected to server, version ".concat(joinRes.serverVersion, "."));
        if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {
          this.appendMessage("LiveKit Cloud: ".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));
        }
        yield signalClient.close();
      });
    }
  }
  class ConnectionCheck extends eventsExports.EventEmitter {
    constructor(url, token) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super();
      this.options = {};
      this.checkResults = /* @__PURE__ */ new Map();
      this.url = url;
      this.token = token;
      this.options = options;
    }
    getNextCheckId() {
      const nextId = this.checkResults.size;
      this.checkResults.set(nextId, {
        logs: [],
        status: CheckStatus.IDLE,
        name: "",
        description: ""
      });
      return nextId;
    }
    updateCheck(checkId, info) {
      this.checkResults.set(checkId, info);
      this.emit("checkUpdate", checkId, info);
    }
    isSuccess() {
      return Array.from(this.checkResults.values()).every((r2) => r2.status !== CheckStatus.FAILED);
    }
    getResults() {
      return Array.from(this.checkResults.values());
    }
    createAndRunCheck(check) {
      return __awaiter(this, void 0, void 0, function* () {
        const checkId = this.getNextCheckId();
        const test = new check(this.url, this.token, this.options);
        const handleUpdate = (info) => {
          this.updateCheck(checkId, info);
        };
        test.on("update", handleUpdate);
        const result = yield test.run();
        test.off("update", handleUpdate);
        return result;
      });
    }
    checkWebsocket() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebSocketCheck);
      });
    }
    checkWebRTC() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebRTCCheck);
      });
    }
    checkTURN() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(TURNCheck);
      });
    }
    checkReconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(ReconnectCheck);
      });
    }
    checkPublishAudio() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishAudioCheck);
      });
    }
    checkPublishVideo() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishVideoCheck);
      });
    }
  }
  const useMeetingStore = defineStore("meeting", () => {
    const showMeetingDialog = vue.ref(false);
    const userStore = useUserStore();
    const webSocket = useWebSocket();
    const currentVideoRef = vue.ref();
    const remoteVideoRef = vue.ref();
    const currentAudioRef = vue.ref();
    const remoteAudioRef = vue.ref();
    let room = vue.ref(null);
    let token = "";
    let isCaller = vue.ref(true);
    let callerId = vue.ref("");
    let callerName = vue.ref("");
    let isAnswered = vue.ref(false);
    let isGroup = vue.ref(false);
    let isVideoCall = vue.ref(false);
    async function createRoom(status) {
      const { roomType } = status;
      isVideoCall.value = roomType === "video";
      room.value = new Room({
        // automatically manage subscribed video quality
        adaptiveStream: true,
        // optimize publishing bandwidth and CPU for published tracks
        dynacast: true,
        // default capture settings
        videoCaptureDefaults: {
          resolution: VideoPresets.h720.resolution
        }
      });
      const roomName = $inject_window_crypto.randomUUID();
      const res = await getToken(roomName, userStore.userInfo.id);
      token = res.token;
      room.value.prepareConnection(LIVEKITURL, token);
      room.value.on(RoomEvent.TrackSubscribed, handleTrackSubscribed).on(RoomEvent.TrackUnsubscribed, handleTrackUnsubscribed).on(RoomEvent.ActiveSpeakersChanged, handleActiveSpeakerChange).on(RoomEvent.Disconnected, handleDisconnect).on(RoomEvent.LocalTrackUnpublished, handleLocalTrackUnpublished);
      await room.value.connect(LIVEKITURL, token);
      await room.value.localParticipant.setMicrophoneEnabled(true);
      await room.value.localParticipant.setCameraEnabled(isVideoCall.value);
    }
    function informParticipant(participant) {
      if (participant !== userStore.userInfo.id) {
        const message = JSON.stringify({
          type: "room-created",
          sender: userStore.userInfo.id,
          receiver: participant,
          roomId: room.value.name,
          roomType: isVideoCall.value ? "video" : "audio"
        });
        webSocket.sendMessage(message);
      }
    }
    async function joinRoom(status) {
      const { roomName, roomType } = status;
      isVideoCall.value = roomType === "video";
      formatAppLog("log", "at store/meeting.js:91", "join room", status);
      room.value = new Room({
        // 自动调整订阅的视频质量
        adaptiveStream: true,
        // 优化发布的音视频流的带宽和CPU
        dynacast: true,
        // 默认的音视频流设置
        videoCaptureDefaults: {
          resolution: VideoPresets.h720.resolution
        }
      });
      const res = await getToken(roomName, userStore.userInfo.id);
      token = res.token;
      room.value.prepareConnection(LIVEKITURL, token);
      room.value.on(RoomEvent.TrackSubscribed, handleTrackSubscribed).on(RoomEvent.TrackUnsubscribed, handleTrackUnsubscribed).on(RoomEvent.ActiveSpeakersChanged, handleActiveSpeakerChange).on(RoomEvent.Disconnected, handleDisconnect).on(RoomEvent.LocalTrackUnpublished, handleLocalTrackUnpublished);
      await room.value.connect(LIVEKITURL, token);
      await room.value.localParticipant.setMicrophoneEnabled(true);
      await room.value.localParticipant.setCameraEnabled(isVideoCall.value);
    }
    function handleTrackSubscribed(track, publication, participant) {
      var _a;
      const cameraPub = participant.getTrackPublication(Track.Source.Camera);
      participant.getTrackPublication(Track.Source.Microphone);
      (_a = cameraPub == null ? void 0 : cameraPub.videoTrack) == null ? void 0 : _a.attach(remoteVideoRef.value);
    }
    function handleTrackUnsubscribed(track, publication, participant) {
      track.detach();
    }
    function handleLocalTrackUnpublished(publication, participant) {
      publication.track.detach();
    }
    function handleActiveSpeakerChange(speakers) {
    }
    function handleDisconnect() {
      formatAppLog("log", "at store/meeting.js:168", "disconnected from room");
    }
    async function callRemote(target) {
      formatAppLog("log", "at store/meeting.js:172", "call remote", target);
      if (target.isGroup) {
        isGroup.value = true;
        for (let member of target.members) {
          if (member.id === userStore.userInfo.id) {
            continue;
          }
          const message = JSON.stringify({
            type: "call-remote",
            sender: userStore.userInfo.id,
            receiver: member.id,
            isGroup: true,
            roomType: isVideoCall.value ? "video" : "audio"
          });
          webSocket.sendMessage(message);
        }
      } else {
        isGroup.value = false;
        const message = JSON.stringify({
          type: "call-remote",
          sender: userStore.userInfo.id,
          receiver: target.id,
          isGroup: false,
          roomType: isVideoCall.value ? "video" : "audio"
        });
        webSocket.sendMessage(message);
      }
    }
    function acceptVideoCall() {
      const message = JSON.stringify({
        type: "answer-call",
        sender: userStore.state.id,
        receiver: callerId.value,
        reply: "accept"
      });
      webSocket.sendMessage(message);
      isAnswered.value = true;
    }
    function rejectVideoCall() {
      if (isCaller.value)
        ;
      else {
        isAnswered.value = false;
        const message = JSON.stringify({
          type: "answer-call",
          sender: userStore.userInfo.id,
          receiver: callerId.value,
          reply: "reject"
        });
        webSocket.sendMessage(message);
      }
      showMeetingDialog.value = false;
    }
    function leaveRoom() {
      if (room.value) {
        room.value.disconnect();
      }
      formatAppLog("log", "at store/meeting.js:239", "leave room", room.value.name);
      const message = JSON.stringify({
        type: "leave-room",
        sender: userStore.userInfo.id,
        roomId: room.value.name
      });
      webSocket.sendMessage(message);
    }
    return {
      showMeetingDialog,
      currentVideoRef,
      remoteVideoRef,
      currentAudioRef,
      remoteAudioRef,
      room,
      isCaller,
      isAnswered,
      callerId,
      callerName,
      isGroup,
      isVideoCall,
      createRoom,
      informParticipant,
      joinRoom,
      callRemote,
      acceptVideoCall,
      rejectVideoCall,
      leaveRoom
    };
  });
  const isCurrentPageMain = () => {
    const pages2 = getCurrentPages();
    if (pages2 && pages2.length > 0) {
      const currentPage = pages2[pages2.length - 1];
      formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:14", currentPage, currentPage.route);
      return currentPage && currentPage.route === "pages/tabBar/tabBar";
    }
    return false;
  };
  const useWebSocket = () => {
    const isConnected = vue.ref(false);
    const reconnectAttempts = vue.ref(0);
    const maxReconnectAttempts = 5;
    let socket = null;
    useMeetingStore();
    const connect = (userId, token) => {
      formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:31", token, "tokentokentokentoken");
      if (!userId || !token) {
        formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:33", "WebSocket 连接失败: userId 或 token 未提供", { userId, token });
        return;
      }
      if (isConnected.value) {
        formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:38", "WebSocket 已经连接");
        return;
      }
      const wsProtocol = backendHost.startsWith("https") ? "wss" : "ws";
      const wsUrl = `${wsProtocol}://${backendHost.split("://")[1]}/chat/${userId}`;
      formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:45", "尝试连接 WebSocket:", wsUrl);
      socket = uni.connectSocket({
        url: wsUrl,
        header: {
          "content-type": "application/json"
        },
        protocols: [token],
        success: () => {
          formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:54", "WebSocket 连接成功");
        },
        fail: (error) => {
          formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:57", "WebSocket 连接失败:", error);
        }
      });
      socket.onOpen(() => {
        formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:62", "WebSocket 已连接");
        isConnected.value = true;
        reconnectAttempts.value = 0;
        startPingInterval();
      });
      socket.onMessage((res) => {
        formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:69", "收到消息:", res.data);
        try {
          const message = JSON.parse(res.data);
          handleMessage(message);
        } catch (error) {
          formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:74", "解析消息失败:", error);
        }
      });
      socket.onError((res) => {
        formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:79", "WebSocket 错误:", res);
      });
      socket.onClose((res) => {
        formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:83", "WebSocket 已断开", res);
        isConnected.value = false;
        stopPingInterval();
        if (reconnectAttempts.value < maxReconnectAttempts) {
          const delay = Math.min(1e3 * Math.pow(2, reconnectAttempts.value), 3e4);
          formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:89", `将在 ${delay}ms 后尝试重新连接...`);
          setTimeout(() => {
            formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:91", `尝试重新连接... (${reconnectAttempts.value + 1}/${maxReconnectAttempts})`);
            reconnectAttempts.value++;
            connect(userId, token);
          }, delay);
        } else {
          formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:96", "WebSocket 重连失败，请检查网络连接或联系管理员");
        }
      });
    };
    const disconnect = () => {
      if (isConnected.value && socket) {
        socket.close({
          success: () => {
            formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:105", "WebSocket 已关闭");
            isConnected.value = false;
            reconnectAttempts.value = 0;
            stopPingInterval();
          }
        });
      }
    };
    const sendMessage = (message) => {
      if (isConnected.value && socket) {
        socket.send({
          data: JSON.stringify(message),
          success: () => {
            formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:119", "消息发送成功");
          },
          fail: (error) => {
            formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:122", "消息发送失败:", error);
          }
        });
      } else {
        formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:126", "WebSocket 未连接，无法发送消息");
      }
    };
    const handleMessage = (message) => {
      formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:131", "消息", message);
      uni.$emit("newChatMessage", message);
      if (isCurrentPageMain()) {
        uni.$emit("refreshMainPage");
      }
    };
    const ping = () => {
      sendMessage({ type: "ping" });
    };
    let pingInterval;
    const startPingInterval = () => {
      pingInterval = setInterval(() => {
        ping();
      }, 3e4);
    };
    const stopPingInterval = () => {
      if (pingInterval) {
        clearInterval(pingInterval);
      }
    };
    vue.onUnmounted(() => {
      disconnect();
    });
    return {
      isConnected,
      connect,
      disconnect,
      sendMessage
    };
  };
  const _imports_0$d = "/static/icon/login.png";
  const _sfc_main$19 = {
    __name: "login",
    setup(__props, { expose: __expose }) {
      __expose();
      const { connect } = useWebSocket();
      const userStore = useUserStore();
      const autoLogin = vue.ref(false);
      const username = vue.ref("test-app");
      const password = vue.ref("Test123456");
      const goToRegister = () => {
        uni.navigateTo({
          url: "/pages/register/register"
        });
      };
      const goToForgetPassword = () => {
        uni.navigateTo({
          url: "/pages/forgetPassword/forgetPassword"
        });
      };
      const goToFingerLogin = () => {
        uni.navigateTo({
          url: "/pages/fingerLogin/fingerLogin"
        });
      };
      const goToTask = () => {
        uni.redirectTo({
          url: "/pages/tabBar/tabBar"
        });
      };
      const toggleAutoLogin = (e2) => {
        autoLogin.value = e2.detail.value.length > 0;
        if (autoLogin.value) {
          uni.navigateTo({
            url: "/pages/register/register"
          });
        }
      };
      const checkLogin = () => {
        uni.showLoading({
          title: "正在登录",
          mask: true
        });
        login({
          account: username.value,
          password: password.value
        }).then((res) => {
          if (res.code === 200) {
            uni.setStorageSync("username", username.value);
            uni.setStorageSync("password", password.value);
            uni.setStorageSync("token", res.data.token);
            const userData = {
              id: res.data.id,
              account: res.data.account,
              name: res.data.name,
              department: res.data.department,
              role: res.data.role,
              phone: res.data.phone,
              created: res.data.created,
              avatar: res.data.avatar,
              avatarUrl: res.data.avatarUrl,
              token: res.data.token,
              status: res.data.status
            };
            userStore.setUserData(userData);
            connect(res.data.id, res.data.token);
            uni.setStorageSync("userInfo", userData);
            formatAppLog("log", "at pages/login/login.vue:117", "登录成功。用户数据:", userData);
            uni.hideLoading();
            uni.showToast({
              title: "登录成功",
              duration: 2e3
            }).then(() => {
              goToTask();
            });
          } else {
            throw new Error(res.message || "登录失败");
          }
        }).catch((error) => {
          formatAppLog("error", "at pages/login/login.vue:130", "登录失败:", error);
          uni.hideLoading();
          uni.showToast({
            title: error.message || "登录失败",
            icon: "none",
            duration: 2e3
          });
        });
      };
      const __returned__ = { connect, userStore, autoLogin, username, password, goToRegister, goToForgetPassword, goToFingerLogin, goToTask, toggleAutoLogin, checkLogin, ref: vue.ref, get login() {
        return login;
      }, get useUserStore() {
        return useUserStore;
      }, useWebSocket };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "layout" }, [
      vue.createElementVNode("view", { class: "iconView" }, [
        vue.createElementVNode("image", {
          src: _imports_0$d,
          class: "icon"
        })
      ]),
      vue.createElementVNode("view", { class: "text" }, [
        vue.createElementVNode("text", null, "欢迎登录！")
      ]),
      vue.createElementVNode("view", {
        class: "account",
        style: { "margin-top": "25px" }
      }, [
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin-bottom": "7px" }
        }, "用户名"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            focus: "",
            placeholder: "请输入用户名",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.username = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $setup.username]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "密码"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            password: "",
            type: "text",
            placeholder: "请输入密码",
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.password = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $setup.password]
        ]),
        vue.createElementVNode("button", {
          onClick: $setup.checkLogin,
          type: "primary",
          style: { "margin-top": "15px" }
        }, "登录")
      ]),
      vue.createElementVNode("view", { class: "container" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("label", { class: "checkbox" }, [
            vue.createElementVNode("checkbox", {
              value: $setup.autoLogin,
              onChange: $setup.toggleAutoLogin
            }, "自动登录", 40, ["value"])
          ])
        ]),
        vue.createElementVNode("view", { class: "right" }, [
          vue.createElementVNode("text", {
            onClick: $setup.goToRegister,
            class: "clicked_text"
          }, "注册 "),
          vue.createElementVNode("text", {
            onClick: $setup.goToForgetPassword,
            class: "clicked_text"
          }, " 忘记密码"),
          vue.createElementVNode("text", null, " | "),
          vue.createElementVNode("text", {
            onClick: $setup.goToFingerLogin,
            class: "clicked_text"
          }, "指纹登录")
        ])
      ])
    ]);
  }
  const PagesLoginLogin = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$18], ["__file", "E:/代码/new/zk_uniapp/pages/login/login.vue"]]);
  const isObject = (val) => val !== null && typeof val === "object";
  const defaultDelimiters = ["{", "}"];
  class BaseFormatter {
    constructor() {
      this._caches = /* @__PURE__ */ Object.create(null);
    }
    interpolate(message, values, delimiters = defaultDelimiters) {
      if (!values) {
        return [message];
      }
      let tokens = this._caches[message];
      if (!tokens) {
        tokens = parse(message, delimiters);
        this._caches[message] = tokens;
      }
      return compile(tokens, values);
    }
  }
  const RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
  const RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;
  function parse(format, [startDelimiter, endDelimiter]) {
    const tokens = [];
    let position = 0;
    let text = "";
    while (position < format.length) {
      let char = format[position++];
      if (char === startDelimiter) {
        if (text) {
          tokens.push({ type: "text", value: text });
        }
        text = "";
        let sub = "";
        char = format[position++];
        while (char !== void 0 && char !== endDelimiter) {
          sub += char;
          char = format[position++];
        }
        const isClosed = char === endDelimiter;
        const type = RE_TOKEN_LIST_VALUE.test(sub) ? "list" : isClosed && RE_TOKEN_NAMED_VALUE.test(sub) ? "named" : "unknown";
        tokens.push({ value: sub, type });
      } else {
        text += char;
      }
    }
    text && tokens.push({ type: "text", value: text });
    return tokens;
  }
  function compile(tokens, values) {
    const compiled = [];
    let index = 0;
    const mode = Array.isArray(values) ? "list" : isObject(values) ? "named" : "unknown";
    if (mode === "unknown") {
      return compiled;
    }
    while (index < tokens.length) {
      const token = tokens[index];
      switch (token.type) {
        case "text":
          compiled.push(token.value);
          break;
        case "list":
          compiled.push(values[parseInt(token.value, 10)]);
          break;
        case "named":
          if (mode === "named") {
            compiled.push(values[token.value]);
          } else {
            {
              console.warn(`Type of token '${token.type}' and format of value '${mode}' don't match!`);
            }
          }
          break;
        case "unknown":
          {
            console.warn(`Detect 'unknown' type of token!`);
          }
          break;
      }
      index++;
    }
    return compiled;
  }
  const LOCALE_ZH_HANS = "zh-Hans";
  const LOCALE_ZH_HANT = "zh-Hant";
  const LOCALE_EN = "en";
  const LOCALE_FR = "fr";
  const LOCALE_ES = "es";
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty.call(val, key);
  const defaultFormatter = new BaseFormatter();
  function include(str, parts) {
    return !!parts.find((part) => str.indexOf(part) !== -1);
  }
  function startsWith(str, parts) {
    return parts.find((part) => str.indexOf(part) === 0);
  }
  function normalizeLocale(locale, messages2) {
    if (!locale) {
      return;
    }
    locale = locale.trim().replace(/_/g, "-");
    if (messages2 && messages2[locale]) {
      return locale;
    }
    locale = locale.toLowerCase();
    if (locale === "chinese") {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf("zh") === 0) {
      if (locale.indexOf("-hans") > -1) {
        return LOCALE_ZH_HANS;
      }
      if (locale.indexOf("-hant") > -1) {
        return LOCALE_ZH_HANT;
      }
      if (include(locale, ["-tw", "-hk", "-mo", "-cht"])) {
        return LOCALE_ZH_HANT;
      }
      return LOCALE_ZH_HANS;
    }
    let locales = [LOCALE_EN, LOCALE_FR, LOCALE_ES];
    if (messages2 && Object.keys(messages2).length > 0) {
      locales = Object.keys(messages2);
    }
    const lang = startsWith(locale, locales);
    if (lang) {
      return lang;
    }
  }
  class I18n {
    constructor({ locale, fallbackLocale, messages: messages2, watcher, formater: formater2 }) {
      this.locale = LOCALE_EN;
      this.fallbackLocale = LOCALE_EN;
      this.message = {};
      this.messages = {};
      this.watchers = [];
      if (fallbackLocale) {
        this.fallbackLocale = fallbackLocale;
      }
      this.formater = formater2 || defaultFormatter;
      this.messages = messages2 || {};
      this.setLocale(locale || LOCALE_EN);
      if (watcher) {
        this.watchLocale(watcher);
      }
    }
    setLocale(locale) {
      const oldLocale = this.locale;
      this.locale = normalizeLocale(locale, this.messages) || this.fallbackLocale;
      if (!this.messages[this.locale]) {
        this.messages[this.locale] = {};
      }
      this.message = this.messages[this.locale];
      if (oldLocale !== this.locale) {
        this.watchers.forEach((watcher) => {
          watcher(this.locale, oldLocale);
        });
      }
    }
    getLocale() {
      return this.locale;
    }
    watchLocale(fn) {
      const index = this.watchers.push(fn) - 1;
      return () => {
        this.watchers.splice(index, 1);
      };
    }
    add(locale, message, override = true) {
      const curMessages = this.messages[locale];
      if (curMessages) {
        if (override) {
          Object.assign(curMessages, message);
        } else {
          Object.keys(message).forEach((key) => {
            if (!hasOwn(curMessages, key)) {
              curMessages[key] = message[key];
            }
          });
        }
      } else {
        this.messages[locale] = message;
      }
    }
    f(message, values, delimiters) {
      return this.formater.interpolate(message, values, delimiters).join("");
    }
    t(key, locale, values) {
      let message = this.message;
      if (typeof locale === "string") {
        locale = normalizeLocale(locale, this.messages);
        locale && (message = this.messages[locale]);
      } else {
        values = locale;
      }
      if (!hasOwn(message, key)) {
        console.warn(`Cannot translate the value of keypath ${key}. Use the value of keypath as default.`);
        return key;
      }
      return this.formater.interpolate(message[key], values).join("");
    }
  }
  function watchAppLocale(appVm, i18n) {
    if (appVm.$watchLocale) {
      appVm.$watchLocale((newLocale) => {
        i18n.setLocale(newLocale);
      });
    } else {
      appVm.$watch(() => appVm.$locale, (newLocale) => {
        i18n.setLocale(newLocale);
      });
    }
  }
  function getDefaultLocale() {
    if (typeof uni !== "undefined" && uni.getLocale) {
      return uni.getLocale();
    }
    if (typeof global !== "undefined" && global.getLocale) {
      return global.getLocale();
    }
    return LOCALE_EN;
  }
  function initVueI18n(locale, messages2 = {}, fallbackLocale, watcher) {
    if (typeof locale !== "string") {
      const options = [
        messages2,
        locale
      ];
      locale = options[0];
      messages2 = options[1];
    }
    if (typeof locale !== "string") {
      locale = getDefaultLocale();
    }
    if (typeof fallbackLocale !== "string") {
      fallbackLocale = typeof __uniConfig !== "undefined" && __uniConfig.fallbackLocale || LOCALE_EN;
    }
    const i18n = new I18n({
      locale,
      fallbackLocale,
      messages: messages2,
      watcher
    });
    let t2 = (key, values) => {
      if (typeof getApp !== "function") {
        t2 = function(key2, values2) {
          return i18n.t(key2, values2);
        };
      } else {
        let isWatchedAppLocale = false;
        t2 = function(key2, values2) {
          const appVm = getApp().$vm;
          if (appVm) {
            appVm.$locale;
            if (!isWatchedAppLocale) {
              isWatchedAppLocale = true;
              watchAppLocale(appVm, i18n);
            }
          }
          return i18n.t(key2, values2);
        };
      }
      return t2(key, values);
    };
    return {
      i18n,
      f(message, values, delimiters) {
        return i18n.f(message, values, delimiters);
      },
      t(key, values) {
        return t2(key, values);
      },
      add(locale2, message, override = true) {
        return i18n.add(locale2, message, override);
      },
      watch(fn) {
        return i18n.watchLocale(fn);
      },
      getLocale() {
        return i18n.getLocale();
      },
      setLocale(newLocale) {
        return i18n.setLocale(newLocale);
      }
    };
  }
  const en$1 = {
    "uni-load-more.contentdown": "Pull up to show more",
    "uni-load-more.contentrefresh": "loading...",
    "uni-load-more.contentnomore": "No more data"
  };
  const zhHans$1 = {
    "uni-load-more.contentdown": "上拉显示更多",
    "uni-load-more.contentrefresh": "正在加载...",
    "uni-load-more.contentnomore": "没有更多数据了"
  };
  const zhHant$1 = {
    "uni-load-more.contentdown": "上拉顯示更多",
    "uni-load-more.contentrefresh": "正在加載...",
    "uni-load-more.contentnomore": "沒有更多數據了"
  };
  const messages$1 = {
    en: en$1,
    "zh-Hans": zhHans$1,
    "zh-Hant": zhHant$1
  };
  let platform$1;
  setTimeout(() => {
    platform$1 = uni.getSystemInfoSync().platform;
  }, 16);
  const {
    t: t$2
  } = initVueI18n(messages$1);
  const _sfc_main$18 = {
    name: "UniLoadMore",
    emits: ["clickLoadMore"],
    props: {
      status: {
        // 上拉的状态：more-loading前；loading-loading中；noMore-没有更多了
        type: String,
        default: "more"
      },
      showIcon: {
        type: Boolean,
        default: true
      },
      iconType: {
        type: String,
        default: "auto"
      },
      iconSize: {
        type: Number,
        default: 24
      },
      color: {
        type: String,
        default: "#777777"
      },
      contentText: {
        type: Object,
        default() {
          return {
            contentdown: "",
            contentrefresh: "",
            contentnomore: ""
          };
        }
      },
      showText: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        webviewHide: false,
        platform: platform$1,
        imgBase64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzlBMzU3OTlEOUM0MTFFOUI0NTZDNERBQURBQzI4RkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzlBMzU3OUFEOUM0MTFFOUI0NTZDNERBQURBQzI4RkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDOUEzNTc5N0Q5QzQxMUU5QjQ1NkM0REFBREFDMjhGRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDOUEzNTc5OEQ5QzQxMUU5QjQ1NkM0REFBREFDMjhGRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pt+ALSwAAA6CSURBVHja1FsLkFZVHb98LM+F5bHL8khA1iSeiyQBCRM+YGqKUnnJTDLGI0BGZlKDIU2MMglUiDApEZvSsZnQtBRJtKwQNKQMFYeRDR10WOLd8ljYXdh+v8v5fR3Od+797t1dnOnO/Ofce77z+J//+b/P+ZqtXbs2sJ9MJhNUV1cHJ06cCJo3bx7EPc2aNcvpy7pWrVoF+/fvDyoqKoI2bdoE9fX1F7TjN8a+EXBn/fkfvw942Tf+wYMHg9mzZwfjxo0LDhw4EPa1x2MbFw/fOGfPng1qa2tzcCkILsLDydq2bRsunpOTMM7TD/W/tZDZhPdeKD+yGxHhdu3aBV27dg3OnDlzMVANMheLAO3btw8KCwuDmpoaX5OxbgUIMEq7K8IcPnw4KCsrC/r37x8cP378/4cAXAB3vqSkJMuiDhTkw+XcuXNhOWbMmKBly5YhUT8xArhyFvP0BfwRsAuwxJZJsm/nzp2DTp06he/OU+cZ64K6o0ePBkOHDg2GDx8e6gEbJ5Q/NHNuAJQ1hgBeHUDlR7nVTkY8rQAvAi4z34vR/mPs1FoRsaCgIJThI0eOBC1atEiFGGV+5MiRoS45efJkqFjJFXV1dQuA012m2WcwTw98fy6CqBdsaiIO4CScrGPHjvk4odhavPquRtFWXEC25VgkREKOCh/qDSq+vn37htzD/mZTOmOc5U7zKzBPEedygWshcDyWvs30igAbU+6oyMgJBCFhwQE0fccxN60Ay9iebbjoDh06hMowjQxT4fXq1SskArmHZpkArvixp/kWzHdMeArExSJEaiXIjjRjRJ4DaAGWpibLzXN3Fm1vA5teBgh3j1Rv3bp1YgKwPdmf2p9zcyNYYgPKMfY0T5f5nNYdw158nJ8QawW4CLKwiOBSEgO/hok2eBydR+3dYH+PLxA5J8Vv0KBBwenTp0P2JWAx6+yFEBfs8lMY+y0SWMBNI9E4ThKi58VKTg3FQZS1RQF1cz27eC0QHMu+3E0SkUowjhVt5VdaWhp07949ZHv2Qd1EjDXM2cla1M0nl3GxAs3J9yREzyTdFVKVFOaE9qRA8GM0WebRuo9JGZKA7Mv2SeS/Z8+eoQ9BArMfFrLGo6jvxbhHbJZnKX2Rzz1O7QhJJ9Cs2ZMaWIyq/zhdeqPNfIoHd58clIQD+JSXl4dKlyIAuBdVXZwFVWKspSSoxE++h8x4k3uCnEhE4I5KwRiFWGOU0QWKiCYLbdoRMRKAu2kQ9vkfLU6dOhX06NEjlH+yMRZSinnuyWnYosVcji8CEA/6Cg2JF+IIUBqnGKUTCNwtwBN4f89RiK1R96DEgO2o0NDmtEdvVFdVVYV+P3UAPUEs6GFwV3PHmXkD4vh74iDFJysVI/MlaQhwKeBNTLYX5VuA8T4/gZxA4MRGFxDB6R7OmYPfyykGRJbyie+XnGYnQIC/coH9+vULiYrxrkL9ZA9+0ykaHIfEpM7ge8TiJ2CsHYwyMfafAF1yCGBHYIbCVDjDjKt7BeB51D+LgQa6OkG7IDYEEtvQ7lnXLKLtLdLuJBpE4gPUXcW2+PkZwOex+4cGDhwYDBkyRL7/HFcEwUGPo/8uWRUpYnfxGHco8HkewLHLyYmAawAPuIFZxhOpDfJQ8gbUv41yORAptMWBNr6oqMhWird5+u+iHmBb2nhjDV7HWBNQTgK8y11l5NetWzc5ULscAtSj7nbNI0skhWeUZCc0W4nyH/jO4Vz0u1IeYhbk4AiwM6tjxIWByHsoZ9qcIBPJd/y+DwPfBESOmCa/QF3WiZHucLlEDpNxcNhmheEOPgdQNx6/VZFQzFZ5TN08AHXQt2Ii3EdyFuUsPtTcGPhW5iMiCNELvz+Gdn9huG4HUJaW/w3g0wxV0XaG7arG2WeKiUWYM4Y7GO5ezshTARbbWGw/DvXkpp/ivVvE0JVoMxN4rpGzJMhE5Pl+xlATsDIqikP9F9D2z3h9nOksEUFhK+qO4rcPkoalMQ/HqJLIyb3F3JdjrCcw1yZ8joyJLR5gCo54etlag7qIoeNh1N1BRYj3DTFJ0elotxPlVzkGuYAmL0VSJVGAJA41c4Z6A3BzTLfn0HYwYKEI6CUAMzZEWvLsIcQOo1AmmyyM72nHJCfYsogflGV6jEk9vyQZXSuq6w4c16NsGcGZbwOPr+H1RkOk2LEzjNepxQkihHSCQ4ynAYNRx2zMKV92CQMWqj8J0BRE8EShxRFN6YrfCRhC0x3r/Zm4IbQCcmJoV0kMamllccR6FjHqUC5F2R/wS2dcymOlfAKOS4KmzQb5cpNC2MC7JhVn5wjXoJ44rYhLh8n0eXOCorJxa7POjbSlCGVczr34/RsAmrcvo9s+wGp3tzVhntxiXiJ4nvEYb4FJkf0O8HocAePmLvCxnL0AORraVekJk6TYjDabRVXfRE2lCN1h6ZQRN1+InUbsCpKwoBZHh0dODN9JBCUffItXxEavTQkUtnfTVAplCWL3JISz29h4NjotnuSsQKJCk8dF+kJR6RARjrqFVmfPnj3ZbK8cIJ0msd6jgHPGtfVTQ8VLmlvh4mct9sobRmPic0DyDQQnx/NlfYUgyz59+oScsH379pAwXABD32nTpoUHIToESeI5mnbE/UqDdyLcafEBf2MCqgC7NwxIbMREJQ0g4D4sfJwnD+AmRrII05cfMWJE+L1169bQr+fip06dGp4oJ83lmYd5wj/EmMa4TaHivo4EeCguYZBnkB5g2aWA69OIEnUHOaGysjIYMGBAMGnSpODYsWPZwCpFmm4lNq+4gSLQA7jcX8DwtjEyRC8wjabnXEx9kfWnTJkSJkAo90xpJVV+FmcVNeYAF5zWngS4C4O91MBxmAv8blLEpbjI5sz9MTdAhcgkCT1RO8mZkAjfiYpTEvStAS53Uw1vAiUGgZ3GpuQEYvoiBqlIan7kSDHnTwJQFNiPu0+5VxCVYhcZIjNrdXUDdp+Eq5AZ3Gkg8QAyVZRZIk4Tl4QAbF9cXJxNYZMAtAokgs4BrNxEpCtteXg7DDTMDKYNSuQdKsnJBek7HxewvxaosWxLYXtw+cJp18217wql4aKCfBNoEu0O5VU+PhctJ0YeXD4C6JQpyrlpSLTojpGGGN5YwNziChdIZLk4lvLcFJ9jMX3QdiImY9bmGQU+TRUL5CHITTRlgF8D9ouD1MfmLoEPl5xokIumZ2cfgMpHt47IW9N64Hsh7wQYYjyIugWuF5fCqYncXRd5vPMWyizzvhi/32+nvG0dZc9vR6fZOu0md5e+uC408FvKSIOZwXlGvxPv95izA2Vtvg1xKFWARI+vMX66HUhpQQb643uW1bSjuTWyw2SBvDrBvjFic1eGGlz5esq3ko9uSIlBRqPuFcCv8F4WIcN12nVaBd0SaYwI6PDDImR11JkqgHcPmQssjxIn6bUshygDFJUTxPMpHk+jfjPgupgdnYV2R/g7xSjtpah8RJBewhwf0gGK6XI92u4wXFEU40afJ4DN4h5LcAd+40HI3JgJecuT0c062W0i2hQJUTcxan3/CMW1PF2K6bbA+Daz4xRs1D3Br1Cm0OihKCqizW78/nXAF/G5TXrEcVzaNMH6CyMswqsAHqDyDLEyou8lwOXnKF8DjI6KjV3KzMBiXkDH8ij/H214J5A596ekrZ3F0zXlWeL7+P5eUrNo3/QwC15uxthuzidy7DzKRwEDaAViiDgKbTbz7CJnzo0bN7pIfIiid8SuPwn25o3QCmpnyjlZkyxPP8EomCJzrGb7GJMx7tNsq4MT2xMUYaiErZOluTzKsnz3gwCeCZyVRZJfYplNEokEjwrPtxlxjeYAk+F1F74VAzPxQRNYYdtpOUvWs8J1sGhBJMNsb7igN8plJs1eSmLIhLKE4rvaCX27gOhLpLOsIzJ7qn/i+wZzcvSOZ23/du8TZjwV8zHIXoP4R3ifBxiFz1dcVpa3aPntPE+c6TmIWE9EtcMmAcPdWAhYhAXxcLOQi9L1WhD1Sc8p1d2oL7XGiRKp8F4A2i8K/nfI+y/gsTDJ/YC/8+AD5Uh04KHiGl+cIFPnBDDrPMjwRGkLXyxO4VGbfQWnDH2v0bVWE3C9QOXlepbgjEfIJQI6XDG3z5ahD9cw2pS78ipB85wyScNTvsVzlzzhL8/jRrnmVjfFJK/m3m4nj9vbgQTguT8XZTjsm672R5uJKEaQmBI/c58gyus8ZDagLpEVSJBIyHp4jn++xqPV71OgQgJYEWOtZ/haxRtKmWOBu8xdBLftWltsY84zE6WIEy/eIOWL+BaayMx+KHtL7EAkqdNDLiEXmEMUHniedtJqg9HmZtfvt26vNi0BdG3Ft3g8ZOf7PAu59TxtzivLNIekyi+wD1i8CuUiD9FXAa8C+/xS3JPmZnomyc7H+fb4/Se0bk41Fel621r4cgVxbq91V4jVqwB7HTe2M7jgB+QWHavZkDRPmZcASoZEmBx6i75bGjPcMdL4/VKGFAGWZkGzPG0XAbdL9A81G5LOmUnC9hHKJeO7dcUMjblSl12867ElFTtaGl20xvvLGPdVz/8TVuU7y0x1PG7vtNg24oz9Uo/Z412++VFWI7Fcog9tu9Lm6gvRmIPv9x1xmQAu6RDkXtbOtlGEmpgD5Nvnyc0dcv0EE6cfdi1HmhMf9wDF3k3gtRvEedhxjpgfqPb9PU9iEJHnyOUA7bQUXh6kq/D7l2iTjWv7XOD530BDr8jIrus+srXjt4MzumJMHuTsBa63YKE1+RR5lBjEikCCnWKWiHdzOgKO+nRIBAF88za/IFmJ3eMZov4CYxGBabcpGL8EYx+SeMXJeRwHNsV/h+vdxeuhEpN3ZyNY78Gm2fknJxVGhyjixPiQvVkNzT1elD9Py/aTAL64Hb9vcYmC9zfdXdT/C1LeGbg4rnBaAihDFJH12W5ulfNCNe/xTsP3bp8ikzJs5BF+5PNfAQYAPaseTdsEcaYAAAAASUVORK5CYII="
      };
    },
    computed: {
      iconSnowWidth() {
        return (Math.floor(this.iconSize / 24) || 1) * 2;
      },
      contentdownText() {
        return this.contentText.contentdown || t$2("uni-load-more.contentdown");
      },
      contentrefreshText() {
        return this.contentText.contentrefresh || t$2("uni-load-more.contentrefresh");
      },
      contentnomoreText() {
        return this.contentText.contentnomore || t$2("uni-load-more.contentnomore");
      }
    },
    mounted() {
      var pages2 = getCurrentPages();
      var page = pages2[pages2.length - 1];
      var currentWebview = page.$getAppWebview();
      currentWebview.addEventListener("hide", () => {
        this.webviewHide = true;
      });
      currentWebview.addEventListener("show", () => {
        this.webviewHide = false;
      });
    },
    methods: {
      onClick() {
        this.$emit("clickLoadMore", {
          detail: {
            status: this.status
          }
        });
      }
    }
  };
  function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "uni-load-more",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
    }, [
      !$data.webviewHide && ($props.iconType === "circle" || $props.iconType === "auto" && $data.platform === "android") && $props.status === "loading" && $props.showIcon ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 0,
          style: vue.normalizeStyle({ width: $props.iconSize + "px", height: $props.iconSize + "px" }),
          class: "uni-load-more__img uni-load-more__img--android-MP"
        },
        [
          vue.createElementVNode(
            "view",
            {
              class: "uni-load-more__img-icon",
              style: vue.normalizeStyle({ borderTopColor: $props.color, borderTopWidth: $props.iconSize / 12 })
            },
            null,
            4
            /* STYLE */
          ),
          vue.createElementVNode(
            "view",
            {
              class: "uni-load-more__img-icon",
              style: vue.normalizeStyle({ borderTopColor: $props.color, borderTopWidth: $props.iconSize / 12 })
            },
            null,
            4
            /* STYLE */
          ),
          vue.createElementVNode(
            "view",
            {
              class: "uni-load-more__img-icon",
              style: vue.normalizeStyle({ borderTopColor: $props.color, borderTopWidth: $props.iconSize / 12 })
            },
            null,
            4
            /* STYLE */
          )
        ],
        4
        /* STYLE */
      )) : !$data.webviewHide && $props.status === "loading" && $props.showIcon ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 1,
          style: vue.normalizeStyle({ width: $props.iconSize + "px", height: $props.iconSize + "px" }),
          class: "uni-load-more__img uni-load-more__img--ios-H5"
        },
        [
          vue.createElementVNode("image", {
            src: $data.imgBase64,
            mode: "widthFix"
          }, null, 8, ["src"])
        ],
        4
        /* STYLE */
      )) : vue.createCommentVNode("v-if", true),
      $props.showText ? (vue.openBlock(), vue.createElementBlock(
        "text",
        {
          key: 2,
          class: "uni-load-more__text",
          style: vue.normalizeStyle({ color: $props.color })
        },
        vue.toDisplayString($props.status === "more" ? $options.contentdownText : $props.status === "loading" ? $options.contentrefreshText : $options.contentnomoreText),
        5
        /* TEXT, STYLE */
      )) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const __easycom_0$6 = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$17], ["__scopeId", "data-v-9245e42c"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-load-more/components/uni-load-more/uni-load-more.vue"]]);
  const fontData = [
    {
      "font_class": "arrow-down",
      "unicode": ""
    },
    {
      "font_class": "arrow-left",
      "unicode": ""
    },
    {
      "font_class": "arrow-right",
      "unicode": ""
    },
    {
      "font_class": "arrow-up",
      "unicode": ""
    },
    {
      "font_class": "auth",
      "unicode": ""
    },
    {
      "font_class": "auth-filled",
      "unicode": ""
    },
    {
      "font_class": "back",
      "unicode": ""
    },
    {
      "font_class": "bars",
      "unicode": ""
    },
    {
      "font_class": "calendar",
      "unicode": ""
    },
    {
      "font_class": "calendar-filled",
      "unicode": ""
    },
    {
      "font_class": "camera",
      "unicode": ""
    },
    {
      "font_class": "camera-filled",
      "unicode": ""
    },
    {
      "font_class": "cart",
      "unicode": ""
    },
    {
      "font_class": "cart-filled",
      "unicode": ""
    },
    {
      "font_class": "chat",
      "unicode": ""
    },
    {
      "font_class": "chat-filled",
      "unicode": ""
    },
    {
      "font_class": "chatboxes",
      "unicode": ""
    },
    {
      "font_class": "chatboxes-filled",
      "unicode": ""
    },
    {
      "font_class": "chatbubble",
      "unicode": ""
    },
    {
      "font_class": "chatbubble-filled",
      "unicode": ""
    },
    {
      "font_class": "checkbox",
      "unicode": ""
    },
    {
      "font_class": "checkbox-filled",
      "unicode": ""
    },
    {
      "font_class": "checkmarkempty",
      "unicode": ""
    },
    {
      "font_class": "circle",
      "unicode": ""
    },
    {
      "font_class": "circle-filled",
      "unicode": ""
    },
    {
      "font_class": "clear",
      "unicode": ""
    },
    {
      "font_class": "close",
      "unicode": ""
    },
    {
      "font_class": "closeempty",
      "unicode": ""
    },
    {
      "font_class": "cloud-download",
      "unicode": ""
    },
    {
      "font_class": "cloud-download-filled",
      "unicode": ""
    },
    {
      "font_class": "cloud-upload",
      "unicode": ""
    },
    {
      "font_class": "cloud-upload-filled",
      "unicode": ""
    },
    {
      "font_class": "color",
      "unicode": ""
    },
    {
      "font_class": "color-filled",
      "unicode": ""
    },
    {
      "font_class": "compose",
      "unicode": ""
    },
    {
      "font_class": "contact",
      "unicode": ""
    },
    {
      "font_class": "contact-filled",
      "unicode": ""
    },
    {
      "font_class": "down",
      "unicode": ""
    },
    {
      "font_class": "bottom",
      "unicode": ""
    },
    {
      "font_class": "download",
      "unicode": ""
    },
    {
      "font_class": "download-filled",
      "unicode": ""
    },
    {
      "font_class": "email",
      "unicode": ""
    },
    {
      "font_class": "email-filled",
      "unicode": ""
    },
    {
      "font_class": "eye",
      "unicode": ""
    },
    {
      "font_class": "eye-filled",
      "unicode": ""
    },
    {
      "font_class": "eye-slash",
      "unicode": ""
    },
    {
      "font_class": "eye-slash-filled",
      "unicode": ""
    },
    {
      "font_class": "fire",
      "unicode": ""
    },
    {
      "font_class": "fire-filled",
      "unicode": ""
    },
    {
      "font_class": "flag",
      "unicode": ""
    },
    {
      "font_class": "flag-filled",
      "unicode": ""
    },
    {
      "font_class": "folder-add",
      "unicode": ""
    },
    {
      "font_class": "folder-add-filled",
      "unicode": ""
    },
    {
      "font_class": "font",
      "unicode": ""
    },
    {
      "font_class": "forward",
      "unicode": ""
    },
    {
      "font_class": "gear",
      "unicode": ""
    },
    {
      "font_class": "gear-filled",
      "unicode": ""
    },
    {
      "font_class": "gift",
      "unicode": ""
    },
    {
      "font_class": "gift-filled",
      "unicode": ""
    },
    {
      "font_class": "hand-down",
      "unicode": ""
    },
    {
      "font_class": "hand-down-filled",
      "unicode": ""
    },
    {
      "font_class": "hand-up",
      "unicode": ""
    },
    {
      "font_class": "hand-up-filled",
      "unicode": ""
    },
    {
      "font_class": "headphones",
      "unicode": ""
    },
    {
      "font_class": "heart",
      "unicode": ""
    },
    {
      "font_class": "heart-filled",
      "unicode": ""
    },
    {
      "font_class": "help",
      "unicode": ""
    },
    {
      "font_class": "help-filled",
      "unicode": ""
    },
    {
      "font_class": "home",
      "unicode": ""
    },
    {
      "font_class": "home-filled",
      "unicode": ""
    },
    {
      "font_class": "image",
      "unicode": ""
    },
    {
      "font_class": "image-filled",
      "unicode": ""
    },
    {
      "font_class": "images",
      "unicode": ""
    },
    {
      "font_class": "images-filled",
      "unicode": ""
    },
    {
      "font_class": "info",
      "unicode": ""
    },
    {
      "font_class": "info-filled",
      "unicode": ""
    },
    {
      "font_class": "left",
      "unicode": ""
    },
    {
      "font_class": "link",
      "unicode": ""
    },
    {
      "font_class": "list",
      "unicode": ""
    },
    {
      "font_class": "location",
      "unicode": ""
    },
    {
      "font_class": "location-filled",
      "unicode": ""
    },
    {
      "font_class": "locked",
      "unicode": ""
    },
    {
      "font_class": "locked-filled",
      "unicode": ""
    },
    {
      "font_class": "loop",
      "unicode": ""
    },
    {
      "font_class": "mail-open",
      "unicode": ""
    },
    {
      "font_class": "mail-open-filled",
      "unicode": ""
    },
    {
      "font_class": "map",
      "unicode": ""
    },
    {
      "font_class": "map-filled",
      "unicode": ""
    },
    {
      "font_class": "map-pin",
      "unicode": ""
    },
    {
      "font_class": "map-pin-ellipse",
      "unicode": ""
    },
    {
      "font_class": "medal",
      "unicode": ""
    },
    {
      "font_class": "medal-filled",
      "unicode": ""
    },
    {
      "font_class": "mic",
      "unicode": ""
    },
    {
      "font_class": "mic-filled",
      "unicode": ""
    },
    {
      "font_class": "micoff",
      "unicode": ""
    },
    {
      "font_class": "micoff-filled",
      "unicode": ""
    },
    {
      "font_class": "minus",
      "unicode": ""
    },
    {
      "font_class": "minus-filled",
      "unicode": ""
    },
    {
      "font_class": "more",
      "unicode": ""
    },
    {
      "font_class": "more-filled",
      "unicode": ""
    },
    {
      "font_class": "navigate",
      "unicode": ""
    },
    {
      "font_class": "navigate-filled",
      "unicode": ""
    },
    {
      "font_class": "notification",
      "unicode": ""
    },
    {
      "font_class": "notification-filled",
      "unicode": ""
    },
    {
      "font_class": "paperclip",
      "unicode": ""
    },
    {
      "font_class": "paperplane",
      "unicode": ""
    },
    {
      "font_class": "paperplane-filled",
      "unicode": ""
    },
    {
      "font_class": "person",
      "unicode": ""
    },
    {
      "font_class": "person-filled",
      "unicode": ""
    },
    {
      "font_class": "personadd",
      "unicode": ""
    },
    {
      "font_class": "personadd-filled",
      "unicode": ""
    },
    {
      "font_class": "personadd-filled-copy",
      "unicode": ""
    },
    {
      "font_class": "phone",
      "unicode": ""
    },
    {
      "font_class": "phone-filled",
      "unicode": ""
    },
    {
      "font_class": "plus",
      "unicode": ""
    },
    {
      "font_class": "plus-filled",
      "unicode": ""
    },
    {
      "font_class": "plusempty",
      "unicode": ""
    },
    {
      "font_class": "pulldown",
      "unicode": ""
    },
    {
      "font_class": "pyq",
      "unicode": ""
    },
    {
      "font_class": "qq",
      "unicode": ""
    },
    {
      "font_class": "redo",
      "unicode": ""
    },
    {
      "font_class": "redo-filled",
      "unicode": ""
    },
    {
      "font_class": "refresh",
      "unicode": ""
    },
    {
      "font_class": "refresh-filled",
      "unicode": ""
    },
    {
      "font_class": "refreshempty",
      "unicode": ""
    },
    {
      "font_class": "reload",
      "unicode": ""
    },
    {
      "font_class": "right",
      "unicode": ""
    },
    {
      "font_class": "scan",
      "unicode": ""
    },
    {
      "font_class": "search",
      "unicode": ""
    },
    {
      "font_class": "settings",
      "unicode": ""
    },
    {
      "font_class": "settings-filled",
      "unicode": ""
    },
    {
      "font_class": "shop",
      "unicode": ""
    },
    {
      "font_class": "shop-filled",
      "unicode": ""
    },
    {
      "font_class": "smallcircle",
      "unicode": ""
    },
    {
      "font_class": "smallcircle-filled",
      "unicode": ""
    },
    {
      "font_class": "sound",
      "unicode": ""
    },
    {
      "font_class": "sound-filled",
      "unicode": ""
    },
    {
      "font_class": "spinner-cycle",
      "unicode": ""
    },
    {
      "font_class": "staff",
      "unicode": ""
    },
    {
      "font_class": "staff-filled",
      "unicode": ""
    },
    {
      "font_class": "star",
      "unicode": ""
    },
    {
      "font_class": "star-filled",
      "unicode": ""
    },
    {
      "font_class": "starhalf",
      "unicode": ""
    },
    {
      "font_class": "trash",
      "unicode": ""
    },
    {
      "font_class": "trash-filled",
      "unicode": ""
    },
    {
      "font_class": "tune",
      "unicode": ""
    },
    {
      "font_class": "tune-filled",
      "unicode": ""
    },
    {
      "font_class": "undo",
      "unicode": ""
    },
    {
      "font_class": "undo-filled",
      "unicode": ""
    },
    {
      "font_class": "up",
      "unicode": ""
    },
    {
      "font_class": "top",
      "unicode": ""
    },
    {
      "font_class": "upload",
      "unicode": ""
    },
    {
      "font_class": "upload-filled",
      "unicode": ""
    },
    {
      "font_class": "videocam",
      "unicode": ""
    },
    {
      "font_class": "videocam-filled",
      "unicode": ""
    },
    {
      "font_class": "vip",
      "unicode": ""
    },
    {
      "font_class": "vip-filled",
      "unicode": ""
    },
    {
      "font_class": "wallet",
      "unicode": ""
    },
    {
      "font_class": "wallet-filled",
      "unicode": ""
    },
    {
      "font_class": "weibo",
      "unicode": ""
    },
    {
      "font_class": "weixin",
      "unicode": ""
    }
  ];
  const getVal$1 = (val) => {
    const reg = /^[0-9]*$/g;
    return typeof val === "number" || reg.test(val) ? val + "px" : val;
  };
  const _sfc_main$17 = {
    name: "UniIcons",
    emits: ["click"],
    props: {
      type: {
        type: String,
        default: ""
      },
      color: {
        type: String,
        default: "#333333"
      },
      size: {
        type: [Number, String],
        default: 16
      },
      customPrefix: {
        type: String,
        default: ""
      },
      fontFamily: {
        type: String,
        default: ""
      }
    },
    data() {
      return {
        icons: fontData
      };
    },
    computed: {
      unicode() {
        let code = this.icons.find((v2) => v2.font_class === this.type);
        if (code) {
          return code.unicode;
        }
        return "";
      },
      iconSize() {
        return getVal$1(this.size);
      },
      styleObj() {
        if (this.fontFamily !== "") {
          return `color: ${this.color}; font-size: ${this.iconSize}; font-family: ${this.fontFamily};`;
        }
        return `color: ${this.color}; font-size: ${this.iconSize};`;
      }
    },
    methods: {
      _onClick() {
        this.$emit("click");
      }
    }
  };
  function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "text",
      {
        style: vue.normalizeStyle($options.styleObj),
        class: vue.normalizeClass(["uni-icons", ["uniui-" + $props.type, $props.customPrefix, $props.customPrefix ? $props.type : ""]]),
        onClick: _cache[0] || (_cache[0] = (...args) => $options._onClick && $options._onClick(...args))
      },
      [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const __easycom_0$5 = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$16], ["__scopeId", "data-v-d31e1c47"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-icons/components/uni-icons/uni-icons.vue"]]);
  const pages = [
    {
      path: "pages/login/camouflageLogin/camouflageLogin",
      style: {
        navigationBarTitleText: "",
        navigationStyle: "custom",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/login/login",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/register/register",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/forgetPassword/forgetPassword",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/fingerLogin/fingerLogin",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/task/task",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/task/task_detail/task_detail",
      style: {
        navigationBarTitleText: "任务列表",
        "app-plus": {
          scrollIndicator: "none",
          titleNView: {
            buttons: [
              {
                type: "menu"
              }
            ]
          }
        }
      }
    },
    {
      path: "pages/task/task_detail/document/document",
      style: {
        navigationBarTitleText: "文件",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/task/task_detail/baidu_map/baidu_map",
      style: {
        navigationBarTitleText: "百度地图测试"
      }
    },
    {
      path: "pages/profile/profile",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/message/main",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/message/chat",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/tabBar/tabBar",
      style: {
        navigationBarTitleText: "首页",
        navigationStyle: "custom",
        titleNView: {
          autoBackButton: false
        },
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/message/video-call",
      style: {
        navigationBarTitleText: "视频通话"
      }
    },
    {
      path: "pages/message/ChatComponent/CallReminder",
      style: {
        navigationBarTitleText: ""
      }
    },
    {
      path: "pages/message/video-answer",
      style: {
        navigationBarTitleText: ""
      }
    },
    {
      path: "pages/login/camouflageLogin/inputAccount/inputAccount",
      style: {
        navigationBarTitleText: "",
        navigationStyle: "custom"
      }
    },
    {
      path: "pages/contacts/pages/contacts",
      style: {
        navigationBarTitleText: "通讯录"
      }
    },
    {
      path: "pages/contacts/pages/contacts/create-group-chat/index",
      style: {
        navigationBarTitleText: "发起群聊",
        navigationStyle: "custom"
      }
    },
    {
      path: "pages/contacts/components/ContactDetail/ContactDetailView",
      style: {
        navigationBarTitleText: "联系人详情"
      }
    },
    {
      path: "pages/message/ChatComponent/MessageReadStatus",
      style: {
        navigationBarTitleText: "消息详情",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    }
  ];
  const globalStyle = {
    navigationBarTextStyle: "black",
    navigationBarTitleText: "uni-app",
    navigationBarBackgroundColor: "#F8F8F8",
    backgroundColor: "#F8F8F8",
    "app-plus": {
      background: "#efeff4",
      bounce: "none"
    }
  };
  const e = {
    pages,
    globalStyle
  };
  var define_process_env_UNI_SECURE_NETWORK_CONFIG_default = [];
  function t$1(e2) {
    return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  function n(e2, t2, n2) {
    return e2(n2 = { path: t2, exports: {}, require: function(e3, t3) {
      return function() {
        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
      }(null == t3 && n2.path);
    } }, n2.exports), n2.exports;
  }
  var s = n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = n2 || function(e3, t3) {
      var n3 = Object.create || /* @__PURE__ */ function() {
        function e4() {
        }
        return function(t4) {
          var n4;
          return e4.prototype = t4, n4 = new e4(), e4.prototype = null, n4;
        };
      }(), s2 = {}, r2 = s2.lib = {}, i2 = r2.Base = { extend: function(e4) {
        var t4 = n3(this);
        return e4 && t4.mixIn(e4), t4.hasOwnProperty("init") && this.init !== t4.init || (t4.init = function() {
          t4.$super.init.apply(this, arguments);
        }), t4.init.prototype = t4, t4.$super = this, t4;
      }, create: function() {
        var e4 = this.extend();
        return e4.init.apply(e4, arguments), e4;
      }, init: function() {
      }, mixIn: function(e4) {
        for (var t4 in e4)
          e4.hasOwnProperty(t4) && (this[t4] = e4[t4]);
        e4.hasOwnProperty("toString") && (this.toString = e4.toString);
      }, clone: function() {
        return this.init.prototype.extend(this);
      } }, o2 = r2.WordArray = i2.extend({ init: function(e4, n4) {
        e4 = this.words = e4 || [], this.sigBytes = n4 != t3 ? n4 : 4 * e4.length;
      }, toString: function(e4) {
        return (e4 || c2).stringify(this);
      }, concat: function(e4) {
        var t4 = this.words, n4 = e4.words, s3 = this.sigBytes, r3 = e4.sigBytes;
        if (this.clamp(), s3 % 4)
          for (var i3 = 0; i3 < r3; i3++) {
            var o3 = n4[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
            t4[s3 + i3 >>> 2] |= o3 << 24 - (s3 + i3) % 4 * 8;
          }
        else
          for (i3 = 0; i3 < r3; i3 += 4)
            t4[s3 + i3 >>> 2] = n4[i3 >>> 2];
        return this.sigBytes += r3, this;
      }, clamp: function() {
        var t4 = this.words, n4 = this.sigBytes;
        t4[n4 >>> 2] &= 4294967295 << 32 - n4 % 4 * 8, t4.length = e3.ceil(n4 / 4);
      }, clone: function() {
        var e4 = i2.clone.call(this);
        return e4.words = this.words.slice(0), e4;
      }, random: function(t4) {
        for (var n4, s3 = [], r3 = function(t5) {
          t5 = t5;
          var n5 = 987654321, s4 = 4294967295;
          return function() {
            var r4 = ((n5 = 36969 * (65535 & n5) + (n5 >> 16) & s4) << 16) + (t5 = 18e3 * (65535 & t5) + (t5 >> 16) & s4) & s4;
            return r4 /= 4294967296, (r4 += 0.5) * (e3.random() > 0.5 ? 1 : -1);
          };
        }, i3 = 0; i3 < t4; i3 += 4) {
          var a3 = r3(4294967296 * (n4 || e3.random()));
          n4 = 987654071 * a3(), s3.push(4294967296 * a3() | 0);
        }
        return new o2.init(s3, t4);
      } }), a2 = s2.enc = {}, c2 = a2.Hex = { stringify: function(e4) {
        for (var t4 = e4.words, n4 = e4.sigBytes, s3 = [], r3 = 0; r3 < n4; r3++) {
          var i3 = t4[r3 >>> 2] >>> 24 - r3 % 4 * 8 & 255;
          s3.push((i3 >>> 4).toString(16)), s3.push((15 & i3).toString(16));
        }
        return s3.join("");
      }, parse: function(e4) {
        for (var t4 = e4.length, n4 = [], s3 = 0; s3 < t4; s3 += 2)
          n4[s3 >>> 3] |= parseInt(e4.substr(s3, 2), 16) << 24 - s3 % 8 * 4;
        return new o2.init(n4, t4 / 2);
      } }, u2 = a2.Latin1 = { stringify: function(e4) {
        for (var t4 = e4.words, n4 = e4.sigBytes, s3 = [], r3 = 0; r3 < n4; r3++) {
          var i3 = t4[r3 >>> 2] >>> 24 - r3 % 4 * 8 & 255;
          s3.push(String.fromCharCode(i3));
        }
        return s3.join("");
      }, parse: function(e4) {
        for (var t4 = e4.length, n4 = [], s3 = 0; s3 < t4; s3++)
          n4[s3 >>> 2] |= (255 & e4.charCodeAt(s3)) << 24 - s3 % 4 * 8;
        return new o2.init(n4, t4);
      } }, l2 = a2.Utf8 = { stringify: function(e4) {
        try {
          return decodeURIComponent(escape(u2.stringify(e4)));
        } catch (e5) {
          throw new Error("Malformed UTF-8 data");
        }
      }, parse: function(e4) {
        return u2.parse(unescape(encodeURIComponent(e4)));
      } }, h2 = r2.BufferedBlockAlgorithm = i2.extend({ reset: function() {
        this._data = new o2.init(), this._nDataBytes = 0;
      }, _append: function(e4) {
        "string" == typeof e4 && (e4 = l2.parse(e4)), this._data.concat(e4), this._nDataBytes += e4.sigBytes;
      }, _process: function(t4) {
        var n4 = this._data, s3 = n4.words, r3 = n4.sigBytes, i3 = this.blockSize, a3 = r3 / (4 * i3), c3 = (a3 = t4 ? e3.ceil(a3) : e3.max((0 | a3) - this._minBufferSize, 0)) * i3, u3 = e3.min(4 * c3, r3);
        if (c3) {
          for (var l3 = 0; l3 < c3; l3 += i3)
            this._doProcessBlock(s3, l3);
          var h3 = s3.splice(0, c3);
          n4.sigBytes -= u3;
        }
        return new o2.init(h3, u3);
      }, clone: function() {
        var e4 = i2.clone.call(this);
        return e4._data = this._data.clone(), e4;
      }, _minBufferSize: 0 });
      r2.Hasher = h2.extend({ cfg: i2.extend(), init: function(e4) {
        this.cfg = this.cfg.extend(e4), this.reset();
      }, reset: function() {
        h2.reset.call(this), this._doReset();
      }, update: function(e4) {
        return this._append(e4), this._process(), this;
      }, finalize: function(e4) {
        return e4 && this._append(e4), this._doFinalize();
      }, blockSize: 16, _createHelper: function(e4) {
        return function(t4, n4) {
          return new e4.init(n4).finalize(t4);
        };
      }, _createHmacHelper: function(e4) {
        return function(t4, n4) {
          return new d2.HMAC.init(e4, n4).finalize(t4);
        };
      } });
      var d2 = s2.algo = {};
      return s2;
    }(Math), n2);
  }), r = s, i = (n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = r, function(e3) {
      var t3 = n2, s2 = t3.lib, r2 = s2.WordArray, i2 = s2.Hasher, o2 = t3.algo, a2 = [];
      !function() {
        for (var t4 = 0; t4 < 64; t4++)
          a2[t4] = 4294967296 * e3.abs(e3.sin(t4 + 1)) | 0;
      }();
      var c2 = o2.MD5 = i2.extend({ _doReset: function() {
        this._hash = new r2.init([1732584193, 4023233417, 2562383102, 271733878]);
      }, _doProcessBlock: function(e4, t4) {
        for (var n3 = 0; n3 < 16; n3++) {
          var s3 = t4 + n3, r3 = e4[s3];
          e4[s3] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8);
        }
        var i3 = this._hash.words, o3 = e4[t4 + 0], c3 = e4[t4 + 1], p2 = e4[t4 + 2], f2 = e4[t4 + 3], g2 = e4[t4 + 4], m2 = e4[t4 + 5], y2 = e4[t4 + 6], _2 = e4[t4 + 7], w2 = e4[t4 + 8], v2 = e4[t4 + 9], I2 = e4[t4 + 10], S2 = e4[t4 + 11], b2 = e4[t4 + 12], k2 = e4[t4 + 13], A2 = e4[t4 + 14], C2 = e4[t4 + 15], P2 = i3[0], T2 = i3[1], x2 = i3[2], O2 = i3[3];
        P2 = u2(P2, T2, x2, O2, o3, 7, a2[0]), O2 = u2(O2, P2, T2, x2, c3, 12, a2[1]), x2 = u2(x2, O2, P2, T2, p2, 17, a2[2]), T2 = u2(T2, x2, O2, P2, f2, 22, a2[3]), P2 = u2(P2, T2, x2, O2, g2, 7, a2[4]), O2 = u2(O2, P2, T2, x2, m2, 12, a2[5]), x2 = u2(x2, O2, P2, T2, y2, 17, a2[6]), T2 = u2(T2, x2, O2, P2, _2, 22, a2[7]), P2 = u2(P2, T2, x2, O2, w2, 7, a2[8]), O2 = u2(O2, P2, T2, x2, v2, 12, a2[9]), x2 = u2(x2, O2, P2, T2, I2, 17, a2[10]), T2 = u2(T2, x2, O2, P2, S2, 22, a2[11]), P2 = u2(P2, T2, x2, O2, b2, 7, a2[12]), O2 = u2(O2, P2, T2, x2, k2, 12, a2[13]), x2 = u2(x2, O2, P2, T2, A2, 17, a2[14]), P2 = l2(P2, T2 = u2(T2, x2, O2, P2, C2, 22, a2[15]), x2, O2, c3, 5, a2[16]), O2 = l2(O2, P2, T2, x2, y2, 9, a2[17]), x2 = l2(x2, O2, P2, T2, S2, 14, a2[18]), T2 = l2(T2, x2, O2, P2, o3, 20, a2[19]), P2 = l2(P2, T2, x2, O2, m2, 5, a2[20]), O2 = l2(O2, P2, T2, x2, I2, 9, a2[21]), x2 = l2(x2, O2, P2, T2, C2, 14, a2[22]), T2 = l2(T2, x2, O2, P2, g2, 20, a2[23]), P2 = l2(P2, T2, x2, O2, v2, 5, a2[24]), O2 = l2(O2, P2, T2, x2, A2, 9, a2[25]), x2 = l2(x2, O2, P2, T2, f2, 14, a2[26]), T2 = l2(T2, x2, O2, P2, w2, 20, a2[27]), P2 = l2(P2, T2, x2, O2, k2, 5, a2[28]), O2 = l2(O2, P2, T2, x2, p2, 9, a2[29]), x2 = l2(x2, O2, P2, T2, _2, 14, a2[30]), P2 = h2(P2, T2 = l2(T2, x2, O2, P2, b2, 20, a2[31]), x2, O2, m2, 4, a2[32]), O2 = h2(O2, P2, T2, x2, w2, 11, a2[33]), x2 = h2(x2, O2, P2, T2, S2, 16, a2[34]), T2 = h2(T2, x2, O2, P2, A2, 23, a2[35]), P2 = h2(P2, T2, x2, O2, c3, 4, a2[36]), O2 = h2(O2, P2, T2, x2, g2, 11, a2[37]), x2 = h2(x2, O2, P2, T2, _2, 16, a2[38]), T2 = h2(T2, x2, O2, P2, I2, 23, a2[39]), P2 = h2(P2, T2, x2, O2, k2, 4, a2[40]), O2 = h2(O2, P2, T2, x2, o3, 11, a2[41]), x2 = h2(x2, O2, P2, T2, f2, 16, a2[42]), T2 = h2(T2, x2, O2, P2, y2, 23, a2[43]), P2 = h2(P2, T2, x2, O2, v2, 4, a2[44]), O2 = h2(O2, P2, T2, x2, b2, 11, a2[45]), x2 = h2(x2, O2, P2, T2, C2, 16, a2[46]), P2 = d2(P2, T2 = h2(T2, x2, O2, P2, p2, 23, a2[47]), x2, O2, o3, 6, a2[48]), O2 = d2(O2, P2, T2, x2, _2, 10, a2[49]), x2 = d2(x2, O2, P2, T2, A2, 15, a2[50]), T2 = d2(T2, x2, O2, P2, m2, 21, a2[51]), P2 = d2(P2, T2, x2, O2, b2, 6, a2[52]), O2 = d2(O2, P2, T2, x2, f2, 10, a2[53]), x2 = d2(x2, O2, P2, T2, I2, 15, a2[54]), T2 = d2(T2, x2, O2, P2, c3, 21, a2[55]), P2 = d2(P2, T2, x2, O2, w2, 6, a2[56]), O2 = d2(O2, P2, T2, x2, C2, 10, a2[57]), x2 = d2(x2, O2, P2, T2, y2, 15, a2[58]), T2 = d2(T2, x2, O2, P2, k2, 21, a2[59]), P2 = d2(P2, T2, x2, O2, g2, 6, a2[60]), O2 = d2(O2, P2, T2, x2, S2, 10, a2[61]), x2 = d2(x2, O2, P2, T2, p2, 15, a2[62]), T2 = d2(T2, x2, O2, P2, v2, 21, a2[63]), i3[0] = i3[0] + P2 | 0, i3[1] = i3[1] + T2 | 0, i3[2] = i3[2] + x2 | 0, i3[3] = i3[3] + O2 | 0;
      }, _doFinalize: function() {
        var t4 = this._data, n3 = t4.words, s3 = 8 * this._nDataBytes, r3 = 8 * t4.sigBytes;
        n3[r3 >>> 5] |= 128 << 24 - r3 % 32;
        var i3 = e3.floor(s3 / 4294967296), o3 = s3;
        n3[15 + (r3 + 64 >>> 9 << 4)] = 16711935 & (i3 << 8 | i3 >>> 24) | 4278255360 & (i3 << 24 | i3 >>> 8), n3[14 + (r3 + 64 >>> 9 << 4)] = 16711935 & (o3 << 8 | o3 >>> 24) | 4278255360 & (o3 << 24 | o3 >>> 8), t4.sigBytes = 4 * (n3.length + 1), this._process();
        for (var a3 = this._hash, c3 = a3.words, u3 = 0; u3 < 4; u3++) {
          var l3 = c3[u3];
          c3[u3] = 16711935 & (l3 << 8 | l3 >>> 24) | 4278255360 & (l3 << 24 | l3 >>> 8);
        }
        return a3;
      }, clone: function() {
        var e4 = i2.clone.call(this);
        return e4._hash = this._hash.clone(), e4;
      } });
      function u2(e4, t4, n3, s3, r3, i3, o3) {
        var a3 = e4 + (t4 & n3 | ~t4 & s3) + r3 + o3;
        return (a3 << i3 | a3 >>> 32 - i3) + t4;
      }
      function l2(e4, t4, n3, s3, r3, i3, o3) {
        var a3 = e4 + (t4 & s3 | n3 & ~s3) + r3 + o3;
        return (a3 << i3 | a3 >>> 32 - i3) + t4;
      }
      function h2(e4, t4, n3, s3, r3, i3, o3) {
        var a3 = e4 + (t4 ^ n3 ^ s3) + r3 + o3;
        return (a3 << i3 | a3 >>> 32 - i3) + t4;
      }
      function d2(e4, t4, n3, s3, r3, i3, o3) {
        var a3 = e4 + (n3 ^ (t4 | ~s3)) + r3 + o3;
        return (a3 << i3 | a3 >>> 32 - i3) + t4;
      }
      t3.MD5 = i2._createHelper(c2), t3.HmacMD5 = i2._createHmacHelper(c2);
    }(Math), n2.MD5);
  }), n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = r, void function() {
      var e3 = n2, t3 = e3.lib.Base, s2 = e3.enc.Utf8;
      e3.algo.HMAC = t3.extend({ init: function(e4, t4) {
        e4 = this._hasher = new e4.init(), "string" == typeof t4 && (t4 = s2.parse(t4));
        var n3 = e4.blockSize, r2 = 4 * n3;
        t4.sigBytes > r2 && (t4 = e4.finalize(t4)), t4.clamp();
        for (var i2 = this._oKey = t4.clone(), o2 = this._iKey = t4.clone(), a2 = i2.words, c2 = o2.words, u2 = 0; u2 < n3; u2++)
          a2[u2] ^= 1549556828, c2[u2] ^= 909522486;
        i2.sigBytes = o2.sigBytes = r2, this.reset();
      }, reset: function() {
        var e4 = this._hasher;
        e4.reset(), e4.update(this._iKey);
      }, update: function(e4) {
        return this._hasher.update(e4), this;
      }, finalize: function(e4) {
        var t4 = this._hasher, n3 = t4.finalize(e4);
        return t4.reset(), t4.finalize(this._oKey.clone().concat(n3));
      } });
    }());
  }), n(function(e2, t2) {
    e2.exports = r.HmacMD5;
  })), o = n(function(e2, t2) {
    e2.exports = r.enc.Utf8;
  }), a = n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = r, function() {
      var e3 = n2, t3 = e3.lib.WordArray;
      function s2(e4, n3, s3) {
        for (var r2 = [], i2 = 0, o2 = 0; o2 < n3; o2++)
          if (o2 % 4) {
            var a2 = s3[e4.charCodeAt(o2 - 1)] << o2 % 4 * 2, c2 = s3[e4.charCodeAt(o2)] >>> 6 - o2 % 4 * 2;
            r2[i2 >>> 2] |= (a2 | c2) << 24 - i2 % 4 * 8, i2++;
          }
        return t3.create(r2, i2);
      }
      e3.enc.Base64 = { stringify: function(e4) {
        var t4 = e4.words, n3 = e4.sigBytes, s3 = this._map;
        e4.clamp();
        for (var r2 = [], i2 = 0; i2 < n3; i2 += 3)
          for (var o2 = (t4[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) << 16 | (t4[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255) << 8 | t4[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255, a2 = 0; a2 < 4 && i2 + 0.75 * a2 < n3; a2++)
            r2.push(s3.charAt(o2 >>> 6 * (3 - a2) & 63));
        var c2 = s3.charAt(64);
        if (c2)
          for (; r2.length % 4; )
            r2.push(c2);
        return r2.join("");
      }, parse: function(e4) {
        var t4 = e4.length, n3 = this._map, r2 = this._reverseMap;
        if (!r2) {
          r2 = this._reverseMap = [];
          for (var i2 = 0; i2 < n3.length; i2++)
            r2[n3.charCodeAt(i2)] = i2;
        }
        var o2 = n3.charAt(64);
        if (o2) {
          var a2 = e4.indexOf(o2);
          -1 !== a2 && (t4 = a2);
        }
        return s2(e4, t4, r2);
      }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
    }(), n2.enc.Base64);
  });
  const c = "FUNCTION", u = "OBJECT", l = "CLIENT_DB", h = "pending", d = "fulfilled", p = "rejected";
  function f(e2) {
    return Object.prototype.toString.call(e2).slice(8, -1).toLowerCase();
  }
  function g(e2) {
    return "object" === f(e2);
  }
  function m(e2) {
    return "function" == typeof e2;
  }
  function y(e2) {
    return function() {
      try {
        return e2.apply(e2, arguments);
      } catch (e3) {
        console.error(e3);
      }
    };
  }
  const _ = "REJECTED", w = "NOT_PENDING";
  class v {
    constructor({ createPromise: e2, retryRule: t2 = _ } = {}) {
      this.createPromise = e2, this.status = null, this.promise = null, this.retryRule = t2;
    }
    get needRetry() {
      if (!this.status)
        return true;
      switch (this.retryRule) {
        case _:
          return this.status === p;
        case w:
          return this.status !== h;
      }
    }
    exec() {
      return this.needRetry ? (this.status = h, this.promise = this.createPromise().then((e2) => (this.status = d, Promise.resolve(e2)), (e2) => (this.status = p, Promise.reject(e2))), this.promise) : this.promise;
    }
  }
  function I(e2) {
    return e2 && "string" == typeof e2 ? JSON.parse(e2) : e2;
  }
  const S = true, b = "app", A = I(define_process_env_UNI_SECURE_NETWORK_CONFIG_default), C = b, P = I(""), T = I("[]") || [];
  let O = "";
  try {
    O = "__UNI__2368BC0";
  } catch (e2) {
  }
  let E = {};
  function L(e2, t2 = {}) {
    var n2, s2;
    return n2 = E, s2 = e2, Object.prototype.hasOwnProperty.call(n2, s2) || (E[e2] = t2), E[e2];
  }
  E = uni._globalUniCloudObj ? uni._globalUniCloudObj : uni._globalUniCloudObj = {};
  const R = ["invoke", "success", "fail", "complete"], U = L("_globalUniCloudInterceptor");
  function N(e2, t2) {
    U[e2] || (U[e2] = {}), g(t2) && Object.keys(t2).forEach((n2) => {
      R.indexOf(n2) > -1 && function(e3, t3, n3) {
        let s2 = U[e3][t3];
        s2 || (s2 = U[e3][t3] = []), -1 === s2.indexOf(n3) && m(n3) && s2.push(n3);
      }(e2, n2, t2[n2]);
    });
  }
  function D(e2, t2) {
    U[e2] || (U[e2] = {}), g(t2) ? Object.keys(t2).forEach((n2) => {
      R.indexOf(n2) > -1 && function(e3, t3, n3) {
        const s2 = U[e3][t3];
        if (!s2)
          return;
        const r2 = s2.indexOf(n3);
        r2 > -1 && s2.splice(r2, 1);
      }(e2, n2, t2[n2]);
    }) : delete U[e2];
  }
  function M(e2, t2) {
    return e2 && 0 !== e2.length ? e2.reduce((e3, n2) => e3.then(() => n2(t2)), Promise.resolve()) : Promise.resolve();
  }
  function q(e2, t2) {
    return U[e2] && U[e2][t2] || [];
  }
  function F(e2) {
    N("callObject", e2);
  }
  const K = L("_globalUniCloudListener"), j = "response", $ = "needLogin", B = "refreshToken", W = "clientdb", H = "cloudfunction", J = "cloudobject";
  function z(e2) {
    return K[e2] || (K[e2] = []), K[e2];
  }
  function V(e2, t2) {
    const n2 = z(e2);
    n2.includes(t2) || n2.push(t2);
  }
  function G(e2, t2) {
    const n2 = z(e2), s2 = n2.indexOf(t2);
    -1 !== s2 && n2.splice(s2, 1);
  }
  function Y(e2, t2) {
    const n2 = z(e2);
    for (let e3 = 0; e3 < n2.length; e3++) {
      (0, n2[e3])(t2);
    }
  }
  let Q, X = false;
  function Z() {
    return Q || (Q = new Promise((e2) => {
      X && e2(), function t2() {
        if ("function" == typeof getCurrentPages) {
          const t3 = getCurrentPages();
          t3 && t3[0] && (X = true, e2());
        }
        X || setTimeout(() => {
          t2();
        }, 30);
      }();
    }), Q);
  }
  function ee(e2) {
    const t2 = {};
    for (const n2 in e2) {
      const s2 = e2[n2];
      m(s2) && (t2[n2] = y(s2));
    }
    return t2;
  }
  class te extends Error {
    constructor(e2) {
      super(e2.message), this.errMsg = e2.message || e2.errMsg || "unknown system error", this.code = this.errCode = e2.code || e2.errCode || "SYSTEM_ERROR", this.errSubject = this.subject = e2.subject || e2.errSubject, this.cause = e2.cause, this.requestId = e2.requestId;
    }
    toJson(e2 = 0) {
      if (!(e2 >= 10))
        return e2++, { errCode: this.errCode, errMsg: this.errMsg, errSubject: this.errSubject, cause: this.cause && this.cause.toJson ? this.cause.toJson(e2) : this.cause };
    }
  }
  var ne = { request: (e2) => uni.request(e2), uploadFile: (e2) => uni.uploadFile(e2), setStorageSync: (e2, t2) => uni.setStorageSync(e2, t2), getStorageSync: (e2) => uni.getStorageSync(e2), removeStorageSync: (e2) => uni.removeStorageSync(e2), clearStorageSync: () => uni.clearStorageSync(), connectSocket: (e2) => uni.connectSocket(e2) };
  function se(e2) {
    return e2 && se(e2.__v_raw) || e2;
  }
  function re() {
    return { token: ne.getStorageSync("uni_id_token") || ne.getStorageSync("uniIdToken"), tokenExpired: ne.getStorageSync("uni_id_token_expired") };
  }
  function ie({ token: e2, tokenExpired: t2 } = {}) {
    e2 && ne.setStorageSync("uni_id_token", e2), t2 && ne.setStorageSync("uni_id_token_expired", t2);
  }
  let oe, ae;
  function ce() {
    return oe || (oe = uni.getSystemInfoSync()), oe;
  }
  function ue() {
    let e2, t2;
    try {
      if (uni.getLaunchOptionsSync) {
        if (uni.getLaunchOptionsSync.toString().indexOf("not yet implemented") > -1)
          return;
        const { scene: n2, channel: s2 } = uni.getLaunchOptionsSync();
        e2 = s2, t2 = n2;
      }
    } catch (e3) {
    }
    return { channel: e2, scene: t2 };
  }
  let le = {};
  function he() {
    const e2 = uni.getLocale && uni.getLocale() || "en";
    if (ae)
      return { ...le, ...ae, locale: e2, LOCALE: e2 };
    const t2 = ce(), { deviceId: n2, osName: s2, uniPlatform: r2, appId: i2 } = t2, o2 = ["appId", "appLanguage", "appName", "appVersion", "appVersionCode", "appWgtVersion", "browserName", "browserVersion", "deviceBrand", "deviceId", "deviceModel", "deviceType", "osName", "osVersion", "romName", "romVersion", "ua", "hostName", "hostVersion", "uniPlatform", "uniRuntimeVersion", "uniRuntimeVersionCode", "uniCompilerVersion", "uniCompilerVersionCode"];
    for (const e3 in t2)
      Object.hasOwnProperty.call(t2, e3) && -1 === o2.indexOf(e3) && delete t2[e3];
    return ae = { PLATFORM: r2, OS: s2, APPID: i2, DEVICEID: n2, ...ue(), ...t2 }, { ...le, ...ae, locale: e2, LOCALE: e2 };
  }
  var de = { sign: function(e2, t2) {
    let n2 = "";
    return Object.keys(e2).sort().forEach(function(t3) {
      e2[t3] && (n2 = n2 + "&" + t3 + "=" + e2[t3]);
    }), n2 = n2.slice(1), i(n2, t2).toString();
  }, wrappedRequest: function(e2, t2) {
    return new Promise((n2, s2) => {
      t2(Object.assign(e2, { complete(e3) {
        e3 || (e3 = {});
        const t3 = e3.data && e3.data.header && e3.data.header["x-serverless-request-id"] || e3.header && e3.header["request-id"];
        if (!e3.statusCode || e3.statusCode >= 400) {
          const n3 = e3.data && e3.data.error && e3.data.error.code || "SYS_ERR", r3 = e3.data && e3.data.error && e3.data.error.message || e3.errMsg || "request:fail";
          return s2(new te({ code: n3, message: r3, requestId: t3 }));
        }
        const r2 = e3.data;
        if (r2.error)
          return s2(new te({ code: r2.error.code, message: r2.error.message, requestId: t3 }));
        r2.result = r2.data, r2.requestId = t3, delete r2.data, n2(r2);
      } }));
    });
  }, toBase64: function(e2) {
    return a.stringify(o.parse(e2));
  } };
  var pe = class {
    constructor(e2) {
      ["spaceId", "clientSecret"].forEach((t2) => {
        if (!Object.prototype.hasOwnProperty.call(e2, t2))
          throw new Error(`${t2} required`);
      }), this.config = Object.assign({}, { endpoint: 0 === e2.spaceId.indexOf("mp-") ? "https://api.next.bspapp.com" : "https://api.bspapp.com" }, e2), this.config.provider = "aliyun", this.config.requestUrl = this.config.endpoint + "/client", this.config.envType = this.config.envType || "public", this.config.accessTokenKey = "access_token_" + this.config.spaceId, this.adapter = ne, this._getAccessTokenPromiseHub = new v({ createPromise: () => this.requestAuth(this.setupRequest({ method: "serverless.auth.user.anonymousAuthorize", params: "{}" }, "auth")).then((e3) => {
        if (!e3.result || !e3.result.accessToken)
          throw new te({ code: "AUTH_FAILED", message: "获取accessToken失败" });
        this.setAccessToken(e3.result.accessToken);
      }), retryRule: w });
    }
    get hasAccessToken() {
      return !!this.accessToken;
    }
    setAccessToken(e2) {
      this.accessToken = e2;
    }
    requestWrapped(e2) {
      return de.wrappedRequest(e2, this.adapter.request);
    }
    requestAuth(e2) {
      return this.requestWrapped(e2);
    }
    request(e2, t2) {
      return Promise.resolve().then(() => this.hasAccessToken ? t2 ? this.requestWrapped(e2) : this.requestWrapped(e2).catch((t3) => new Promise((e3, n2) => {
        !t3 || "GATEWAY_INVALID_TOKEN" !== t3.code && "InvalidParameter.InvalidToken" !== t3.code ? n2(t3) : e3();
      }).then(() => this.getAccessToken()).then(() => {
        const t4 = this.rebuildRequest(e2);
        return this.request(t4, true);
      })) : this.getAccessToken().then(() => {
        const t3 = this.rebuildRequest(e2);
        return this.request(t3, true);
      }));
    }
    rebuildRequest(e2) {
      const t2 = Object.assign({}, e2);
      return t2.data.token = this.accessToken, t2.header["x-basement-token"] = this.accessToken, t2.header["x-serverless-sign"] = de.sign(t2.data, this.config.clientSecret), t2;
    }
    setupRequest(e2, t2) {
      const n2 = Object.assign({}, e2, { spaceId: this.config.spaceId, timestamp: Date.now() }), s2 = { "Content-Type": "application/json" };
      return "auth" !== t2 && (n2.token = this.accessToken, s2["x-basement-token"] = this.accessToken), s2["x-serverless-sign"] = de.sign(n2, this.config.clientSecret), { url: this.config.requestUrl, method: "POST", data: n2, dataType: "json", header: s2 };
    }
    getAccessToken() {
      return this._getAccessTokenPromiseHub.exec();
    }
    async authorize() {
      await this.getAccessToken();
    }
    callFunction(e2) {
      const t2 = { method: "serverless.function.runtime.invoke", params: JSON.stringify({ functionTarget: e2.name, functionArgs: e2.data || {} }) };
      return this.request({ ...this.setupRequest(t2), timeout: e2.timeout });
    }
    getOSSUploadOptionsFromPath(e2) {
      const t2 = { method: "serverless.file.resource.generateProximalSign", params: JSON.stringify(e2) };
      return this.request(this.setupRequest(t2));
    }
    uploadFileToOSS({ url: e2, formData: t2, name: n2, filePath: s2, fileType: r2, onUploadProgress: i2 }) {
      return new Promise((o2, a2) => {
        const c2 = this.adapter.uploadFile({ url: e2, formData: t2, name: n2, filePath: s2, fileType: r2, header: { "X-OSS-server-side-encrpytion": "AES256" }, success(e3) {
          e3 && e3.statusCode < 400 ? o2(e3) : a2(new te({ code: "UPLOAD_FAILED", message: "文件上传失败" }));
        }, fail(e3) {
          a2(new te({ code: e3.code || "UPLOAD_FAILED", message: e3.message || e3.errMsg || "文件上传失败" }));
        } });
        "function" == typeof i2 && c2 && "function" == typeof c2.onProgressUpdate && c2.onProgressUpdate((e3) => {
          i2({ loaded: e3.totalBytesSent, total: e3.totalBytesExpectedToSend });
        });
      });
    }
    reportOSSUpload(e2) {
      const t2 = { method: "serverless.file.resource.report", params: JSON.stringify(e2) };
      return this.request(this.setupRequest(t2));
    }
    async uploadFile({ filePath: e2, cloudPath: t2, fileType: n2 = "image", cloudPathAsRealPath: s2 = false, onUploadProgress: r2, config: i2 }) {
      if ("string" !== f(t2))
        throw new te({ code: "INVALID_PARAM", message: "cloudPath必须为字符串类型" });
      if (!(t2 = t2.trim()))
        throw new te({ code: "INVALID_PARAM", message: "cloudPath不可为空" });
      if (/:\/\//.test(t2))
        throw new te({ code: "INVALID_PARAM", message: "cloudPath不合法" });
      const o2 = i2 && i2.envType || this.config.envType;
      if (s2 && ("/" !== t2[0] && (t2 = "/" + t2), t2.indexOf("\\") > -1))
        throw new te({ code: "INVALID_PARAM", message: "使用cloudPath作为路径时，cloudPath不可包含“\\”" });
      const a2 = (await this.getOSSUploadOptionsFromPath({ env: o2, filename: s2 ? t2.split("/").pop() : t2, fileId: s2 ? t2 : void 0 })).result, c2 = "https://" + a2.cdnDomain + "/" + a2.ossPath, { securityToken: u2, accessKeyId: l2, signature: h2, host: d2, ossPath: p2, id: g2, policy: m2, ossCallbackUrl: y2 } = a2, _2 = { "Cache-Control": "max-age=2592000", "Content-Disposition": "attachment", OSSAccessKeyId: l2, Signature: h2, host: d2, id: g2, key: p2, policy: m2, success_action_status: 200 };
      if (u2 && (_2["x-oss-security-token"] = u2), y2) {
        const e3 = JSON.stringify({ callbackUrl: y2, callbackBody: JSON.stringify({ fileId: g2, spaceId: this.config.spaceId }), callbackBodyType: "application/json" });
        _2.callback = de.toBase64(e3);
      }
      const w2 = { url: "https://" + a2.host, formData: _2, fileName: "file", name: "file", filePath: e2, fileType: n2 };
      if (await this.uploadFileToOSS(Object.assign({}, w2, { onUploadProgress: r2 })), y2)
        return { success: true, filePath: e2, fileID: c2 };
      if ((await this.reportOSSUpload({ id: g2 })).success)
        return { success: true, filePath: e2, fileID: c2 };
      throw new te({ code: "UPLOAD_FAILED", message: "文件上传失败" });
    }
    getTempFileURL({ fileList: e2 } = {}) {
      return new Promise((t2, n2) => {
        Array.isArray(e2) && 0 !== e2.length || n2(new te({ code: "INVALID_PARAM", message: "fileList的元素必须是非空的字符串" })), t2({ fileList: e2.map((e3) => ({ fileID: e3, tempFileURL: e3 })) });
      });
    }
    async getFileInfo({ fileList: e2 } = {}) {
      if (!Array.isArray(e2) || 0 === e2.length)
        throw new te({ code: "INVALID_PARAM", message: "fileList的元素必须是非空的字符串" });
      const t2 = { method: "serverless.file.resource.info", params: JSON.stringify({ id: e2.map((e3) => e3.split("?")[0]).join(",") }) };
      return { fileList: (await this.request(this.setupRequest(t2))).result };
    }
  };
  var fe = { init(e2) {
    const t2 = new pe(e2), n2 = { signInAnonymously: function() {
      return t2.authorize();
    }, getLoginState: function() {
      return Promise.resolve(false);
    } };
    return t2.auth = function() {
      return n2;
    }, t2.customAuth = t2.auth, t2;
  } };
  const ge = "undefined" != typeof location && "http:" === location.protocol ? "http:" : "https:";
  var me;
  !function(e2) {
    e2.local = "local", e2.none = "none", e2.session = "session";
  }(me || (me = {}));
  var ye = function() {
  }, _e = n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = r, function(e3) {
      var t3 = n2, s2 = t3.lib, r2 = s2.WordArray, i2 = s2.Hasher, o2 = t3.algo, a2 = [], c2 = [];
      !function() {
        function t4(t5) {
          for (var n4 = e3.sqrt(t5), s4 = 2; s4 <= n4; s4++)
            if (!(t5 % s4))
              return false;
          return true;
        }
        function n3(e4) {
          return 4294967296 * (e4 - (0 | e4)) | 0;
        }
        for (var s3 = 2, r3 = 0; r3 < 64; )
          t4(s3) && (r3 < 8 && (a2[r3] = n3(e3.pow(s3, 0.5))), c2[r3] = n3(e3.pow(s3, 1 / 3)), r3++), s3++;
      }();
      var u2 = [], l2 = o2.SHA256 = i2.extend({ _doReset: function() {
        this._hash = new r2.init(a2.slice(0));
      }, _doProcessBlock: function(e4, t4) {
        for (var n3 = this._hash.words, s3 = n3[0], r3 = n3[1], i3 = n3[2], o3 = n3[3], a3 = n3[4], l3 = n3[5], h2 = n3[6], d2 = n3[7], p2 = 0; p2 < 64; p2++) {
          if (p2 < 16)
            u2[p2] = 0 | e4[t4 + p2];
          else {
            var f2 = u2[p2 - 15], g2 = (f2 << 25 | f2 >>> 7) ^ (f2 << 14 | f2 >>> 18) ^ f2 >>> 3, m2 = u2[p2 - 2], y2 = (m2 << 15 | m2 >>> 17) ^ (m2 << 13 | m2 >>> 19) ^ m2 >>> 10;
            u2[p2] = g2 + u2[p2 - 7] + y2 + u2[p2 - 16];
          }
          var _2 = s3 & r3 ^ s3 & i3 ^ r3 & i3, w2 = (s3 << 30 | s3 >>> 2) ^ (s3 << 19 | s3 >>> 13) ^ (s3 << 10 | s3 >>> 22), v2 = d2 + ((a3 << 26 | a3 >>> 6) ^ (a3 << 21 | a3 >>> 11) ^ (a3 << 7 | a3 >>> 25)) + (a3 & l3 ^ ~a3 & h2) + c2[p2] + u2[p2];
          d2 = h2, h2 = l3, l3 = a3, a3 = o3 + v2 | 0, o3 = i3, i3 = r3, r3 = s3, s3 = v2 + (w2 + _2) | 0;
        }
        n3[0] = n3[0] + s3 | 0, n3[1] = n3[1] + r3 | 0, n3[2] = n3[2] + i3 | 0, n3[3] = n3[3] + o3 | 0, n3[4] = n3[4] + a3 | 0, n3[5] = n3[5] + l3 | 0, n3[6] = n3[6] + h2 | 0, n3[7] = n3[7] + d2 | 0;
      }, _doFinalize: function() {
        var t4 = this._data, n3 = t4.words, s3 = 8 * this._nDataBytes, r3 = 8 * t4.sigBytes;
        return n3[r3 >>> 5] |= 128 << 24 - r3 % 32, n3[14 + (r3 + 64 >>> 9 << 4)] = e3.floor(s3 / 4294967296), n3[15 + (r3 + 64 >>> 9 << 4)] = s3, t4.sigBytes = 4 * n3.length, this._process(), this._hash;
      }, clone: function() {
        var e4 = i2.clone.call(this);
        return e4._hash = this._hash.clone(), e4;
      } });
      t3.SHA256 = i2._createHelper(l2), t3.HmacSHA256 = i2._createHmacHelper(l2);
    }(Math), n2.SHA256);
  }), we = _e, ve = n(function(e2, t2) {
    e2.exports = r.HmacSHA256;
  });
  const Ie = () => {
    let e2;
    if (!Promise) {
      e2 = () => {
      }, e2.promise = {};
      const t3 = () => {
        throw new te({ message: 'Your Node runtime does support ES6 Promises. Set "global.Promise" to your preferred implementation of promises.' });
      };
      return Object.defineProperty(e2.promise, "then", { get: t3 }), Object.defineProperty(e2.promise, "catch", { get: t3 }), e2;
    }
    const t2 = new Promise((t3, n2) => {
      e2 = (e3, s2) => e3 ? n2(e3) : t3(s2);
    });
    return e2.promise = t2, e2;
  };
  function Se(e2) {
    return void 0 === e2;
  }
  function be(e2) {
    return "[object Null]" === Object.prototype.toString.call(e2);
  }
  var ke;
  function Ae(e2) {
    const t2 = (n2 = e2, "[object Array]" === Object.prototype.toString.call(n2) ? e2 : [e2]);
    var n2;
    for (const e3 of t2) {
      const { isMatch: t3, genAdapter: n3, runtime: s2 } = e3;
      if (t3())
        return { adapter: n3(), runtime: s2 };
    }
  }
  !function(e2) {
    e2.WEB = "web", e2.WX_MP = "wx_mp";
  }(ke || (ke = {}));
  const Ce = { adapter: null, runtime: void 0 }, Pe = ["anonymousUuidKey"];
  class Te extends ye {
    constructor() {
      super(), Ce.adapter.root.tcbObject || (Ce.adapter.root.tcbObject = {});
    }
    setItem(e2, t2) {
      Ce.adapter.root.tcbObject[e2] = t2;
    }
    getItem(e2) {
      return Ce.adapter.root.tcbObject[e2];
    }
    removeItem(e2) {
      delete Ce.adapter.root.tcbObject[e2];
    }
    clear() {
      delete Ce.adapter.root.tcbObject;
    }
  }
  function xe(e2, t2) {
    switch (e2) {
      case "local":
        return t2.localStorage || new Te();
      case "none":
        return new Te();
      default:
        return t2.sessionStorage || new Te();
    }
  }
  class Oe {
    constructor(e2) {
      if (!this._storage) {
        this._persistence = Ce.adapter.primaryStorage || e2.persistence, this._storage = xe(this._persistence, Ce.adapter);
        const t2 = `access_token_${e2.env}`, n2 = `access_token_expire_${e2.env}`, s2 = `refresh_token_${e2.env}`, r2 = `anonymous_uuid_${e2.env}`, i2 = `login_type_${e2.env}`, o2 = `user_info_${e2.env}`;
        this.keys = { accessTokenKey: t2, accessTokenExpireKey: n2, refreshTokenKey: s2, anonymousUuidKey: r2, loginTypeKey: i2, userInfoKey: o2 };
      }
    }
    updatePersistence(e2) {
      if (e2 === this._persistence)
        return;
      const t2 = "local" === this._persistence;
      this._persistence = e2;
      const n2 = xe(e2, Ce.adapter);
      for (const e3 in this.keys) {
        const s2 = this.keys[e3];
        if (t2 && Pe.includes(e3))
          continue;
        const r2 = this._storage.getItem(s2);
        Se(r2) || be(r2) || (n2.setItem(s2, r2), this._storage.removeItem(s2));
      }
      this._storage = n2;
    }
    setStore(e2, t2, n2) {
      if (!this._storage)
        return;
      const s2 = { version: n2 || "localCachev1", content: t2 }, r2 = JSON.stringify(s2);
      try {
        this._storage.setItem(e2, r2);
      } catch (e3) {
        throw e3;
      }
    }
    getStore(e2, t2) {
      try {
        if (!this._storage)
          return;
      } catch (e3) {
        return "";
      }
      t2 = t2 || "localCachev1";
      const n2 = this._storage.getItem(e2);
      if (!n2)
        return "";
      if (n2.indexOf(t2) >= 0) {
        return JSON.parse(n2).content;
      }
      return "";
    }
    removeStore(e2) {
      this._storage.removeItem(e2);
    }
  }
  const Ee = {}, Le = {};
  function Re(e2) {
    return Ee[e2];
  }
  class Ue {
    constructor(e2, t2) {
      this.data = t2 || null, this.name = e2;
    }
  }
  class Ne extends Ue {
    constructor(e2, t2) {
      super("error", { error: e2, data: t2 }), this.error = e2;
    }
  }
  const De = new class {
    constructor() {
      this._listeners = {};
    }
    on(e2, t2) {
      return function(e3, t3, n2) {
        n2[e3] = n2[e3] || [], n2[e3].push(t3);
      }(e2, t2, this._listeners), this;
    }
    off(e2, t2) {
      return function(e3, t3, n2) {
        if (n2 && n2[e3]) {
          const s2 = n2[e3].indexOf(t3);
          -1 !== s2 && n2[e3].splice(s2, 1);
        }
      }(e2, t2, this._listeners), this;
    }
    fire(e2, t2) {
      if (e2 instanceof Ne)
        return console.error(e2.error), this;
      const n2 = "string" == typeof e2 ? new Ue(e2, t2 || {}) : e2;
      const s2 = n2.name;
      if (this._listens(s2)) {
        n2.target = this;
        const e3 = this._listeners[s2] ? [...this._listeners[s2]] : [];
        for (const t3 of e3)
          t3.call(this, n2);
      }
      return this;
    }
    _listens(e2) {
      return this._listeners[e2] && this._listeners[e2].length > 0;
    }
  }();
  function Me(e2, t2) {
    De.on(e2, t2);
  }
  function qe(e2, t2 = {}) {
    De.fire(e2, t2);
  }
  function Fe(e2, t2) {
    De.off(e2, t2);
  }
  const Ke = "loginStateChanged", je = "loginStateExpire", $e = "loginTypeChanged", Be = "anonymousConverted", We = "refreshAccessToken";
  var He;
  !function(e2) {
    e2.ANONYMOUS = "ANONYMOUS", e2.WECHAT = "WECHAT", e2.WECHAT_PUBLIC = "WECHAT-PUBLIC", e2.WECHAT_OPEN = "WECHAT-OPEN", e2.CUSTOM = "CUSTOM", e2.EMAIL = "EMAIL", e2.USERNAME = "USERNAME", e2.NULL = "NULL";
  }(He || (He = {}));
  const Je = ["auth.getJwt", "auth.logout", "auth.signInWithTicket", "auth.signInAnonymously", "auth.signIn", "auth.fetchAccessTokenWithRefreshToken", "auth.signUpWithEmailAndPassword", "auth.activateEndUserMail", "auth.sendPasswordResetEmail", "auth.resetPasswordWithToken", "auth.isUsernameRegistered"], ze = { "X-SDK-Version": "1.3.5" };
  function Ve(e2, t2, n2) {
    const s2 = e2[t2];
    e2[t2] = function(t3) {
      const r2 = {}, i2 = {};
      n2.forEach((n3) => {
        const { data: s3, headers: o3 } = n3.call(e2, t3);
        Object.assign(r2, s3), Object.assign(i2, o3);
      });
      const o2 = t3.data;
      return o2 && (() => {
        var e3;
        if (e3 = o2, "[object FormData]" !== Object.prototype.toString.call(e3))
          t3.data = { ...o2, ...r2 };
        else
          for (const e4 in r2)
            o2.append(e4, r2[e4]);
      })(), t3.headers = { ...t3.headers || {}, ...i2 }, s2.call(e2, t3);
    };
  }
  function Ge() {
    const e2 = Math.random().toString(16).slice(2);
    return { data: { seqId: e2 }, headers: { ...ze, "x-seqid": e2 } };
  }
  class Ye {
    constructor(e2 = {}) {
      var t2;
      this.config = e2, this._reqClass = new Ce.adapter.reqClass({ timeout: this.config.timeout, timeoutMsg: `请求在${this.config.timeout / 1e3}s内未完成，已中断`, restrictedMethods: ["post"] }), this._cache = Re(this.config.env), this._localCache = (t2 = this.config.env, Le[t2]), Ve(this._reqClass, "post", [Ge]), Ve(this._reqClass, "upload", [Ge]), Ve(this._reqClass, "download", [Ge]);
    }
    async post(e2) {
      return await this._reqClass.post(e2);
    }
    async upload(e2) {
      return await this._reqClass.upload(e2);
    }
    async download(e2) {
      return await this._reqClass.download(e2);
    }
    async refreshAccessToken() {
      let e2, t2;
      this._refreshAccessTokenPromise || (this._refreshAccessTokenPromise = this._refreshAccessToken());
      try {
        e2 = await this._refreshAccessTokenPromise;
      } catch (e3) {
        t2 = e3;
      }
      if (this._refreshAccessTokenPromise = null, this._shouldRefreshAccessTokenHook = null, t2)
        throw t2;
      return e2;
    }
    async _refreshAccessToken() {
      const { accessTokenKey: e2, accessTokenExpireKey: t2, refreshTokenKey: n2, loginTypeKey: s2, anonymousUuidKey: r2 } = this._cache.keys;
      this._cache.removeStore(e2), this._cache.removeStore(t2);
      let i2 = this._cache.getStore(n2);
      if (!i2)
        throw new te({ message: "未登录CloudBase" });
      const o2 = { refresh_token: i2 }, a2 = await this.request("auth.fetchAccessTokenWithRefreshToken", o2);
      if (a2.data.code) {
        const { code: e3 } = a2.data;
        if ("SIGN_PARAM_INVALID" === e3 || "REFRESH_TOKEN_EXPIRED" === e3 || "INVALID_REFRESH_TOKEN" === e3) {
          if (this._cache.getStore(s2) === He.ANONYMOUS && "INVALID_REFRESH_TOKEN" === e3) {
            const e4 = this._cache.getStore(r2), t3 = this._cache.getStore(n2), s3 = await this.send("auth.signInAnonymously", { anonymous_uuid: e4, refresh_token: t3 });
            return this.setRefreshToken(s3.refresh_token), this._refreshAccessToken();
          }
          qe(je), this._cache.removeStore(n2);
        }
        throw new te({ code: a2.data.code, message: `刷新access token失败：${a2.data.code}` });
      }
      if (a2.data.access_token)
        return qe(We), this._cache.setStore(e2, a2.data.access_token), this._cache.setStore(t2, a2.data.access_token_expire + Date.now()), { accessToken: a2.data.access_token, accessTokenExpire: a2.data.access_token_expire };
      a2.data.refresh_token && (this._cache.removeStore(n2), this._cache.setStore(n2, a2.data.refresh_token), this._refreshAccessToken());
    }
    async getAccessToken() {
      const { accessTokenKey: e2, accessTokenExpireKey: t2, refreshTokenKey: n2 } = this._cache.keys;
      if (!this._cache.getStore(n2))
        throw new te({ message: "refresh token不存在，登录状态异常" });
      let s2 = this._cache.getStore(e2), r2 = this._cache.getStore(t2), i2 = true;
      return this._shouldRefreshAccessTokenHook && !await this._shouldRefreshAccessTokenHook(s2, r2) && (i2 = false), (!s2 || !r2 || r2 < Date.now()) && i2 ? this.refreshAccessToken() : { accessToken: s2, accessTokenExpire: r2 };
    }
    async request(e2, t2, n2) {
      const s2 = `x-tcb-trace_${this.config.env}`;
      let r2 = "application/x-www-form-urlencoded";
      const i2 = { action: e2, env: this.config.env, dataVersion: "2019-08-16", ...t2 };
      if (-1 === Je.indexOf(e2)) {
        const { refreshTokenKey: e3 } = this._cache.keys;
        this._cache.getStore(e3) && (i2.access_token = (await this.getAccessToken()).accessToken);
      }
      let o2;
      if ("storage.uploadFile" === e2) {
        o2 = new FormData();
        for (let e3 in o2)
          o2.hasOwnProperty(e3) && void 0 !== o2[e3] && o2.append(e3, i2[e3]);
        r2 = "multipart/form-data";
      } else {
        r2 = "application/json", o2 = {};
        for (let e3 in i2)
          void 0 !== i2[e3] && (o2[e3] = i2[e3]);
      }
      let a2 = { headers: { "content-type": r2 } };
      n2 && n2.timeout && (a2.timeout = n2.timeout), n2 && n2.onUploadProgress && (a2.onUploadProgress = n2.onUploadProgress);
      const c2 = this._localCache.getStore(s2);
      c2 && (a2.headers["X-TCB-Trace"] = c2);
      const { parse: u2, inQuery: l2, search: h2 } = t2;
      let d2 = { env: this.config.env };
      u2 && (d2.parse = true), l2 && (d2 = { ...l2, ...d2 });
      let p2 = function(e3, t3, n3 = {}) {
        const s3 = /\?/.test(t3);
        let r3 = "";
        for (let e4 in n3)
          "" === r3 ? !s3 && (t3 += "?") : r3 += "&", r3 += `${e4}=${encodeURIComponent(n3[e4])}`;
        return /^http(s)?\:\/\//.test(t3 += r3) ? t3 : `${e3}${t3}`;
      }(ge, "//tcb-api.tencentcloudapi.com/web", d2);
      h2 && (p2 += h2);
      const f2 = await this.post({ url: p2, data: o2, ...a2 }), g2 = f2.header && f2.header["x-tcb-trace"];
      if (g2 && this._localCache.setStore(s2, g2), 200 !== Number(f2.status) && 200 !== Number(f2.statusCode) || !f2.data)
        throw new te({ code: "NETWORK_ERROR", message: "network request error" });
      return f2;
    }
    async send(e2, t2 = {}, n2 = {}) {
      const s2 = await this.request(e2, t2, { ...n2, onUploadProgress: t2.onUploadProgress });
      if ("ACCESS_TOKEN_EXPIRED" === s2.data.code && -1 === Je.indexOf(e2)) {
        await this.refreshAccessToken();
        const s3 = await this.request(e2, t2, { ...n2, onUploadProgress: t2.onUploadProgress });
        if (s3.data.code)
          throw new te({ code: s3.data.code, message: s3.data.message });
        return s3.data;
      }
      if (s2.data.code)
        throw new te({ code: s2.data.code, message: s2.data.message });
      return s2.data;
    }
    setRefreshToken(e2) {
      const { accessTokenKey: t2, accessTokenExpireKey: n2, refreshTokenKey: s2 } = this._cache.keys;
      this._cache.removeStore(t2), this._cache.removeStore(n2), this._cache.setStore(s2, e2);
    }
  }
  const Qe = {};
  function Xe(e2) {
    return Qe[e2];
  }
  class Ze {
    constructor(e2) {
      this.config = e2, this._cache = Re(e2.env), this._request = Xe(e2.env);
    }
    setRefreshToken(e2) {
      const { accessTokenKey: t2, accessTokenExpireKey: n2, refreshTokenKey: s2 } = this._cache.keys;
      this._cache.removeStore(t2), this._cache.removeStore(n2), this._cache.setStore(s2, e2);
    }
    setAccessToken(e2, t2) {
      const { accessTokenKey: n2, accessTokenExpireKey: s2 } = this._cache.keys;
      this._cache.setStore(n2, e2), this._cache.setStore(s2, t2);
    }
    async refreshUserInfo() {
      const { data: e2 } = await this._request.send("auth.getUserInfo", {});
      return this.setLocalUserInfo(e2), e2;
    }
    setLocalUserInfo(e2) {
      const { userInfoKey: t2 } = this._cache.keys;
      this._cache.setStore(t2, e2);
    }
  }
  class et {
    constructor(e2) {
      if (!e2)
        throw new te({ code: "PARAM_ERROR", message: "envId is not defined" });
      this._envId = e2, this._cache = Re(this._envId), this._request = Xe(this._envId), this.setUserInfo();
    }
    linkWithTicket(e2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "ticket must be string" });
      return this._request.send("auth.linkWithTicket", { ticket: e2 });
    }
    linkWithRedirect(e2) {
      e2.signInWithRedirect();
    }
    updatePassword(e2, t2) {
      return this._request.send("auth.updatePassword", { oldPassword: t2, newPassword: e2 });
    }
    updateEmail(e2) {
      return this._request.send("auth.updateEmail", { newEmail: e2 });
    }
    updateUsername(e2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "username must be a string" });
      return this._request.send("auth.updateUsername", { username: e2 });
    }
    async getLinkedUidList() {
      const { data: e2 } = await this._request.send("auth.getLinkedUidList", {});
      let t2 = false;
      const { users: n2 } = e2;
      return n2.forEach((e3) => {
        e3.wxOpenId && e3.wxPublicId && (t2 = true);
      }), { users: n2, hasPrimaryUid: t2 };
    }
    setPrimaryUid(e2) {
      return this._request.send("auth.setPrimaryUid", { uid: e2 });
    }
    unlink(e2) {
      return this._request.send("auth.unlink", { platform: e2 });
    }
    async update(e2) {
      const { nickName: t2, gender: n2, avatarUrl: s2, province: r2, country: i2, city: o2 } = e2, { data: a2 } = await this._request.send("auth.updateUserInfo", { nickName: t2, gender: n2, avatarUrl: s2, province: r2, country: i2, city: o2 });
      this.setLocalUserInfo(a2);
    }
    async refresh() {
      const { data: e2 } = await this._request.send("auth.getUserInfo", {});
      return this.setLocalUserInfo(e2), e2;
    }
    setUserInfo() {
      const { userInfoKey: e2 } = this._cache.keys, t2 = this._cache.getStore(e2);
      ["uid", "loginType", "openid", "wxOpenId", "wxPublicId", "unionId", "qqMiniOpenId", "email", "hasPassword", "customUserId", "nickName", "gender", "avatarUrl"].forEach((e3) => {
        this[e3] = t2[e3];
      }), this.location = { country: t2.country, province: t2.province, city: t2.city };
    }
    setLocalUserInfo(e2) {
      const { userInfoKey: t2 } = this._cache.keys;
      this._cache.setStore(t2, e2), this.setUserInfo();
    }
  }
  class tt {
    constructor(e2) {
      if (!e2)
        throw new te({ code: "PARAM_ERROR", message: "envId is not defined" });
      this._cache = Re(e2);
      const { refreshTokenKey: t2, accessTokenKey: n2, accessTokenExpireKey: s2 } = this._cache.keys, r2 = this._cache.getStore(t2), i2 = this._cache.getStore(n2), o2 = this._cache.getStore(s2);
      this.credential = { refreshToken: r2, accessToken: i2, accessTokenExpire: o2 }, this.user = new et(e2);
    }
    get isAnonymousAuth() {
      return this.loginType === He.ANONYMOUS;
    }
    get isCustomAuth() {
      return this.loginType === He.CUSTOM;
    }
    get isWeixinAuth() {
      return this.loginType === He.WECHAT || this.loginType === He.WECHAT_OPEN || this.loginType === He.WECHAT_PUBLIC;
    }
    get loginType() {
      return this._cache.getStore(this._cache.keys.loginTypeKey);
    }
  }
  class nt extends Ze {
    async signIn() {
      this._cache.updatePersistence("local");
      const { anonymousUuidKey: e2, refreshTokenKey: t2 } = this._cache.keys, n2 = this._cache.getStore(e2) || void 0, s2 = this._cache.getStore(t2) || void 0, r2 = await this._request.send("auth.signInAnonymously", { anonymous_uuid: n2, refresh_token: s2 });
      if (r2.uuid && r2.refresh_token) {
        this._setAnonymousUUID(r2.uuid), this.setRefreshToken(r2.refresh_token), await this._request.refreshAccessToken(), qe(Ke), qe($e, { env: this.config.env, loginType: He.ANONYMOUS, persistence: "local" });
        const e3 = new tt(this.config.env);
        return await e3.user.refresh(), e3;
      }
      throw new te({ message: "匿名登录失败" });
    }
    async linkAndRetrieveDataWithTicket(e2) {
      const { anonymousUuidKey: t2, refreshTokenKey: n2 } = this._cache.keys, s2 = this._cache.getStore(t2), r2 = this._cache.getStore(n2), i2 = await this._request.send("auth.linkAndRetrieveDataWithTicket", { anonymous_uuid: s2, refresh_token: r2, ticket: e2 });
      if (i2.refresh_token)
        return this._clearAnonymousUUID(), this.setRefreshToken(i2.refresh_token), await this._request.refreshAccessToken(), qe(Be, { env: this.config.env }), qe($e, { loginType: He.CUSTOM, persistence: "local" }), { credential: { refreshToken: i2.refresh_token } };
      throw new te({ message: "匿名转化失败" });
    }
    _setAnonymousUUID(e2) {
      const { anonymousUuidKey: t2, loginTypeKey: n2 } = this._cache.keys;
      this._cache.removeStore(t2), this._cache.setStore(t2, e2), this._cache.setStore(n2, He.ANONYMOUS);
    }
    _clearAnonymousUUID() {
      this._cache.removeStore(this._cache.keys.anonymousUuidKey);
    }
  }
  class st extends Ze {
    async signIn(e2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "ticket must be a string" });
      const { refreshTokenKey: t2 } = this._cache.keys, n2 = await this._request.send("auth.signInWithTicket", { ticket: e2, refresh_token: this._cache.getStore(t2) || "" });
      if (n2.refresh_token)
        return this.setRefreshToken(n2.refresh_token), await this._request.refreshAccessToken(), qe(Ke), qe($e, { env: this.config.env, loginType: He.CUSTOM, persistence: this.config.persistence }), await this.refreshUserInfo(), new tt(this.config.env);
      throw new te({ message: "自定义登录失败" });
    }
  }
  class rt extends Ze {
    async signIn(e2, t2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "email must be a string" });
      const { refreshTokenKey: n2 } = this._cache.keys, s2 = await this._request.send("auth.signIn", { loginType: "EMAIL", email: e2, password: t2, refresh_token: this._cache.getStore(n2) || "" }), { refresh_token: r2, access_token: i2, access_token_expire: o2 } = s2;
      if (r2)
        return this.setRefreshToken(r2), i2 && o2 ? this.setAccessToken(i2, o2) : await this._request.refreshAccessToken(), await this.refreshUserInfo(), qe(Ke), qe($e, { env: this.config.env, loginType: He.EMAIL, persistence: this.config.persistence }), new tt(this.config.env);
      throw s2.code ? new te({ code: s2.code, message: `邮箱登录失败: ${s2.message}` }) : new te({ message: "邮箱登录失败" });
    }
    async activate(e2) {
      return this._request.send("auth.activateEndUserMail", { token: e2 });
    }
    async resetPasswordWithToken(e2, t2) {
      return this._request.send("auth.resetPasswordWithToken", { token: e2, newPassword: t2 });
    }
  }
  class it extends Ze {
    async signIn(e2, t2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "username must be a string" });
      "string" != typeof t2 && (t2 = "", console.warn("password is empty"));
      const { refreshTokenKey: n2 } = this._cache.keys, s2 = await this._request.send("auth.signIn", { loginType: He.USERNAME, username: e2, password: t2, refresh_token: this._cache.getStore(n2) || "" }), { refresh_token: r2, access_token_expire: i2, access_token: o2 } = s2;
      if (r2)
        return this.setRefreshToken(r2), o2 && i2 ? this.setAccessToken(o2, i2) : await this._request.refreshAccessToken(), await this.refreshUserInfo(), qe(Ke), qe($e, { env: this.config.env, loginType: He.USERNAME, persistence: this.config.persistence }), new tt(this.config.env);
      throw s2.code ? new te({ code: s2.code, message: `用户名密码登录失败: ${s2.message}` }) : new te({ message: "用户名密码登录失败" });
    }
  }
  class ot {
    constructor(e2) {
      this.config = e2, this._cache = Re(e2.env), this._request = Xe(e2.env), this._onAnonymousConverted = this._onAnonymousConverted.bind(this), this._onLoginTypeChanged = this._onLoginTypeChanged.bind(this), Me($e, this._onLoginTypeChanged);
    }
    get currentUser() {
      const e2 = this.hasLoginState();
      return e2 && e2.user || null;
    }
    get loginType() {
      return this._cache.getStore(this._cache.keys.loginTypeKey);
    }
    anonymousAuthProvider() {
      return new nt(this.config);
    }
    customAuthProvider() {
      return new st(this.config);
    }
    emailAuthProvider() {
      return new rt(this.config);
    }
    usernameAuthProvider() {
      return new it(this.config);
    }
    async signInAnonymously() {
      return new nt(this.config).signIn();
    }
    async signInWithEmailAndPassword(e2, t2) {
      return new rt(this.config).signIn(e2, t2);
    }
    signInWithUsernameAndPassword(e2, t2) {
      return new it(this.config).signIn(e2, t2);
    }
    async linkAndRetrieveDataWithTicket(e2) {
      this._anonymousAuthProvider || (this._anonymousAuthProvider = new nt(this.config)), Me(Be, this._onAnonymousConverted);
      return await this._anonymousAuthProvider.linkAndRetrieveDataWithTicket(e2);
    }
    async signOut() {
      if (this.loginType === He.ANONYMOUS)
        throw new te({ message: "匿名用户不支持登出操作" });
      const { refreshTokenKey: e2, accessTokenKey: t2, accessTokenExpireKey: n2 } = this._cache.keys, s2 = this._cache.getStore(e2);
      if (!s2)
        return;
      const r2 = await this._request.send("auth.logout", { refresh_token: s2 });
      return this._cache.removeStore(e2), this._cache.removeStore(t2), this._cache.removeStore(n2), qe(Ke), qe($e, { env: this.config.env, loginType: He.NULL, persistence: this.config.persistence }), r2;
    }
    async signUpWithEmailAndPassword(e2, t2) {
      return this._request.send("auth.signUpWithEmailAndPassword", { email: e2, password: t2 });
    }
    async sendPasswordResetEmail(e2) {
      return this._request.send("auth.sendPasswordResetEmail", { email: e2 });
    }
    onLoginStateChanged(e2) {
      Me(Ke, () => {
        const t3 = this.hasLoginState();
        e2.call(this, t3);
      });
      const t2 = this.hasLoginState();
      e2.call(this, t2);
    }
    onLoginStateExpired(e2) {
      Me(je, e2.bind(this));
    }
    onAccessTokenRefreshed(e2) {
      Me(We, e2.bind(this));
    }
    onAnonymousConverted(e2) {
      Me(Be, e2.bind(this));
    }
    onLoginTypeChanged(e2) {
      Me($e, () => {
        const t2 = this.hasLoginState();
        e2.call(this, t2);
      });
    }
    async getAccessToken() {
      return { accessToken: (await this._request.getAccessToken()).accessToken, env: this.config.env };
    }
    hasLoginState() {
      const { refreshTokenKey: e2 } = this._cache.keys;
      return this._cache.getStore(e2) ? new tt(this.config.env) : null;
    }
    async isUsernameRegistered(e2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "username must be a string" });
      const { data: t2 } = await this._request.send("auth.isUsernameRegistered", { username: e2 });
      return t2 && t2.isRegistered;
    }
    getLoginState() {
      return Promise.resolve(this.hasLoginState());
    }
    async signInWithTicket(e2) {
      return new st(this.config).signIn(e2);
    }
    shouldRefreshAccessToken(e2) {
      this._request._shouldRefreshAccessTokenHook = e2.bind(this);
    }
    getUserInfo() {
      return this._request.send("auth.getUserInfo", {}).then((e2) => e2.code ? e2 : { ...e2.data, requestId: e2.seqId });
    }
    getAuthHeader() {
      const { refreshTokenKey: e2, accessTokenKey: t2 } = this._cache.keys, n2 = this._cache.getStore(e2);
      return { "x-cloudbase-credentials": this._cache.getStore(t2) + "/@@/" + n2 };
    }
    _onAnonymousConverted(e2) {
      const { env: t2 } = e2.data;
      t2 === this.config.env && this._cache.updatePersistence(this.config.persistence);
    }
    _onLoginTypeChanged(e2) {
      const { loginType: t2, persistence: n2, env: s2 } = e2.data;
      s2 === this.config.env && (this._cache.updatePersistence(n2), this._cache.setStore(this._cache.keys.loginTypeKey, t2));
    }
  }
  const at = function(e2, t2) {
    t2 = t2 || Ie();
    const n2 = Xe(this.config.env), { cloudPath: s2, filePath: r2, onUploadProgress: i2, fileType: o2 = "image" } = e2;
    return n2.send("storage.getUploadMetadata", { path: s2 }).then((e3) => {
      const { data: { url: a2, authorization: c2, token: u2, fileId: l2, cosFileId: h2 }, requestId: d2 } = e3, p2 = { key: s2, signature: c2, "x-cos-meta-fileid": h2, success_action_status: "201", "x-cos-security-token": u2 };
      n2.upload({ url: a2, data: p2, file: r2, name: s2, fileType: o2, onUploadProgress: i2 }).then((e4) => {
        201 === e4.statusCode ? t2(null, { fileID: l2, requestId: d2 }) : t2(new te({ code: "STORAGE_REQUEST_FAIL", message: `STORAGE_REQUEST_FAIL: ${e4.data}` }));
      }).catch((e4) => {
        t2(e4);
      });
    }).catch((e3) => {
      t2(e3);
    }), t2.promise;
  }, ct = function(e2, t2) {
    t2 = t2 || Ie();
    const n2 = Xe(this.config.env), { cloudPath: s2 } = e2;
    return n2.send("storage.getUploadMetadata", { path: s2 }).then((e3) => {
      t2(null, e3);
    }).catch((e3) => {
      t2(e3);
    }), t2.promise;
  }, ut = function({ fileList: e2 }, t2) {
    if (t2 = t2 || Ie(), !e2 || !Array.isArray(e2))
      return { code: "INVALID_PARAM", message: "fileList必须是非空的数组" };
    for (let t3 of e2)
      if (!t3 || "string" != typeof t3)
        return { code: "INVALID_PARAM", message: "fileList的元素必须是非空的字符串" };
    const n2 = { fileid_list: e2 };
    return Xe(this.config.env).send("storage.batchDeleteFile", n2).then((e3) => {
      e3.code ? t2(null, e3) : t2(null, { fileList: e3.data.delete_list, requestId: e3.requestId });
    }).catch((e3) => {
      t2(e3);
    }), t2.promise;
  }, lt = function({ fileList: e2 }, t2) {
    t2 = t2 || Ie(), e2 && Array.isArray(e2) || t2(null, { code: "INVALID_PARAM", message: "fileList必须是非空的数组" });
    let n2 = [];
    for (let s3 of e2)
      "object" == typeof s3 ? (s3.hasOwnProperty("fileID") && s3.hasOwnProperty("maxAge") || t2(null, { code: "INVALID_PARAM", message: "fileList的元素必须是包含fileID和maxAge的对象" }), n2.push({ fileid: s3.fileID, max_age: s3.maxAge })) : "string" == typeof s3 ? n2.push({ fileid: s3 }) : t2(null, { code: "INVALID_PARAM", message: "fileList的元素必须是字符串" });
    const s2 = { file_list: n2 };
    return Xe(this.config.env).send("storage.batchGetDownloadUrl", s2).then((e3) => {
      e3.code ? t2(null, e3) : t2(null, { fileList: e3.data.download_list, requestId: e3.requestId });
    }).catch((e3) => {
      t2(e3);
    }), t2.promise;
  }, ht = async function({ fileID: e2 }, t2) {
    const n2 = (await lt.call(this, { fileList: [{ fileID: e2, maxAge: 600 }] })).fileList[0];
    if ("SUCCESS" !== n2.code)
      return t2 ? t2(n2) : new Promise((e3) => {
        e3(n2);
      });
    const s2 = Xe(this.config.env);
    let r2 = n2.download_url;
    if (r2 = encodeURI(r2), !t2)
      return s2.download({ url: r2 });
    t2(await s2.download({ url: r2 }));
  }, dt = function({ name: e2, data: t2, query: n2, parse: s2, search: r2, timeout: i2 }, o2) {
    const a2 = o2 || Ie();
    let c2;
    try {
      c2 = t2 ? JSON.stringify(t2) : "";
    } catch (e3) {
      return Promise.reject(e3);
    }
    if (!e2)
      return Promise.reject(new te({ code: "PARAM_ERROR", message: "函数名不能为空" }));
    const u2 = { inQuery: n2, parse: s2, search: r2, function_name: e2, request_data: c2 };
    return Xe(this.config.env).send("functions.invokeFunction", u2, { timeout: i2 }).then((e3) => {
      if (e3.code)
        a2(null, e3);
      else {
        let t3 = e3.data.response_data;
        if (s2)
          a2(null, { result: t3, requestId: e3.requestId });
        else
          try {
            t3 = JSON.parse(e3.data.response_data), a2(null, { result: t3, requestId: e3.requestId });
          } catch (e4) {
            a2(new te({ message: "response data must be json" }));
          }
      }
      return a2.promise;
    }).catch((e3) => {
      a2(e3);
    }), a2.promise;
  }, pt = { timeout: 15e3, persistence: "session" }, ft = {};
  class gt {
    constructor(e2) {
      this.config = e2 || this.config, this.authObj = void 0;
    }
    init(e2) {
      switch (Ce.adapter || (this.requestClient = new Ce.adapter.reqClass({ timeout: e2.timeout || 5e3, timeoutMsg: `请求在${(e2.timeout || 5e3) / 1e3}s内未完成，已中断` })), this.config = { ...pt, ...e2 }, true) {
        case this.config.timeout > 6e5:
          console.warn("timeout大于可配置上限[10分钟]，已重置为上限数值"), this.config.timeout = 6e5;
          break;
        case this.config.timeout < 100:
          console.warn("timeout小于可配置下限[100ms]，已重置为下限数值"), this.config.timeout = 100;
      }
      return new gt(this.config);
    }
    auth({ persistence: e2 } = {}) {
      if (this.authObj)
        return this.authObj;
      const t2 = e2 || Ce.adapter.primaryStorage || pt.persistence;
      var n2;
      return t2 !== this.config.persistence && (this.config.persistence = t2), function(e3) {
        const { env: t3 } = e3;
        Ee[t3] = new Oe(e3), Le[t3] = new Oe({ ...e3, persistence: "local" });
      }(this.config), n2 = this.config, Qe[n2.env] = new Ye(n2), this.authObj = new ot(this.config), this.authObj;
    }
    on(e2, t2) {
      return Me.apply(this, [e2, t2]);
    }
    off(e2, t2) {
      return Fe.apply(this, [e2, t2]);
    }
    callFunction(e2, t2) {
      return dt.apply(this, [e2, t2]);
    }
    deleteFile(e2, t2) {
      return ut.apply(this, [e2, t2]);
    }
    getTempFileURL(e2, t2) {
      return lt.apply(this, [e2, t2]);
    }
    downloadFile(e2, t2) {
      return ht.apply(this, [e2, t2]);
    }
    uploadFile(e2, t2) {
      return at.apply(this, [e2, t2]);
    }
    getUploadMetadata(e2, t2) {
      return ct.apply(this, [e2, t2]);
    }
    registerExtension(e2) {
      ft[e2.name] = e2;
    }
    async invokeExtension(e2, t2) {
      const n2 = ft[e2];
      if (!n2)
        throw new te({ message: `扩展${e2} 必须先注册` });
      return await n2.invoke(t2, this);
    }
    useAdapters(e2) {
      const { adapter: t2, runtime: n2 } = Ae(e2) || {};
      t2 && (Ce.adapter = t2), n2 && (Ce.runtime = n2);
    }
  }
  var mt = new gt();
  function yt(e2, t2, n2) {
    void 0 === n2 && (n2 = {});
    var s2 = /\?/.test(t2), r2 = "";
    for (var i2 in n2)
      "" === r2 ? !s2 && (t2 += "?") : r2 += "&", r2 += i2 + "=" + encodeURIComponent(n2[i2]);
    return /^http(s)?:\/\//.test(t2 += r2) ? t2 : "" + e2 + t2;
  }
  class _t {
    post(e2) {
      const { url: t2, data: n2, headers: s2, timeout: r2 } = e2;
      return new Promise((e3, i2) => {
        ne.request({ url: yt("https:", t2), data: n2, method: "POST", header: s2, timeout: r2, success(t3) {
          e3(t3);
        }, fail(e4) {
          i2(e4);
        } });
      });
    }
    upload(e2) {
      return new Promise((t2, n2) => {
        const { url: s2, file: r2, data: i2, headers: o2, fileType: a2 } = e2, c2 = ne.uploadFile({ url: yt("https:", s2), name: "file", formData: Object.assign({}, i2), filePath: r2, fileType: a2, header: o2, success(e3) {
          const n3 = { statusCode: e3.statusCode, data: e3.data || {} };
          200 === e3.statusCode && i2.success_action_status && (n3.statusCode = parseInt(i2.success_action_status, 10)), t2(n3);
        }, fail(e3) {
          n2(new Error(e3.errMsg || "uploadFile:fail"));
        } });
        "function" == typeof e2.onUploadProgress && c2 && "function" == typeof c2.onProgressUpdate && c2.onProgressUpdate((t3) => {
          e2.onUploadProgress({ loaded: t3.totalBytesSent, total: t3.totalBytesExpectedToSend });
        });
      });
    }
  }
  const wt = { setItem(e2, t2) {
    ne.setStorageSync(e2, t2);
  }, getItem: (e2) => ne.getStorageSync(e2), removeItem(e2) {
    ne.removeStorageSync(e2);
  }, clear() {
    ne.clearStorageSync();
  } };
  var vt = { genAdapter: function() {
    return { root: {}, reqClass: _t, localStorage: wt, primaryStorage: "local" };
  }, isMatch: function() {
    return true;
  }, runtime: "uni_app" };
  mt.useAdapters(vt);
  const It = mt, St = It.init;
  It.init = function(e2) {
    e2.env = e2.spaceId;
    const t2 = St.call(this, e2);
    t2.config.provider = "tencent", t2.config.spaceId = e2.spaceId;
    const n2 = t2.auth;
    return t2.auth = function(e3) {
      const t3 = n2.call(this, e3);
      return ["linkAndRetrieveDataWithTicket", "signInAnonymously", "signOut", "getAccessToken", "getLoginState", "signInWithTicket", "getUserInfo"].forEach((e4) => {
        var n3;
        t3[e4] = (n3 = t3[e4], function(e5) {
          e5 = e5 || {};
          const { success: t4, fail: s2, complete: r2 } = ee(e5);
          if (!(t4 || s2 || r2))
            return n3.call(this, e5);
          n3.call(this, e5).then((e6) => {
            t4 && t4(e6), r2 && r2(e6);
          }, (e6) => {
            s2 && s2(e6), r2 && r2(e6);
          });
        }).bind(t3);
      }), t3;
    }, t2.customAuth = t2.auth, t2;
  };
  var bt = It;
  async function kt(e2, t2) {
    const n2 = `http://${e2}:${t2}/system/ping`;
    try {
      const e3 = await (s2 = { url: n2, timeout: 500 }, new Promise((e4, t3) => {
        ne.request({ ...s2, success(t4) {
          e4(t4);
        }, fail(e5) {
          t3(e5);
        } });
      }));
      return !(!e3.data || 0 !== e3.data.code);
    } catch (e3) {
      return false;
    }
    var s2;
  }
  async function At(e2, t2) {
    let n2;
    for (let s2 = 0; s2 < e2.length; s2++) {
      const r2 = e2[s2];
      if (await kt(r2, t2)) {
        n2 = r2;
        break;
      }
    }
    return { address: n2, port: t2 };
  }
  const Ct = { "serverless.file.resource.generateProximalSign": "storage/generate-proximal-sign", "serverless.file.resource.report": "storage/report", "serverless.file.resource.delete": "storage/delete", "serverless.file.resource.getTempFileURL": "storage/get-temp-file-url" };
  var Pt = class {
    constructor(e2) {
      if (["spaceId", "clientSecret"].forEach((t2) => {
        if (!Object.prototype.hasOwnProperty.call(e2, t2))
          throw new Error(`${t2} required`);
      }), !e2.endpoint)
        throw new Error("集群空间未配置ApiEndpoint，配置后需要重新关联服务空间后生效");
      this.config = Object.assign({}, e2), this.config.provider = "dcloud", this.config.requestUrl = this.config.endpoint + "/client", this.config.envType = this.config.envType || "public", this.adapter = ne;
    }
    async request(e2, t2 = true) {
      const n2 = t2;
      return e2 = n2 ? await this.setupLocalRequest(e2) : this.setupRequest(e2), Promise.resolve().then(() => n2 ? this.requestLocal(e2) : de.wrappedRequest(e2, this.adapter.request));
    }
    requestLocal(e2) {
      return new Promise((t2, n2) => {
        this.adapter.request(Object.assign(e2, { complete(e3) {
          if (e3 || (e3 = {}), !e3.statusCode || e3.statusCode >= 400) {
            const t3 = e3.data && e3.data.code || "SYS_ERR", s2 = e3.data && e3.data.message || "request:fail";
            return n2(new te({ code: t3, message: s2 }));
          }
          t2({ success: true, result: e3.data });
        } }));
      });
    }
    setupRequest(e2) {
      const t2 = Object.assign({}, e2, { spaceId: this.config.spaceId, timestamp: Date.now() }), n2 = { "Content-Type": "application/json" };
      n2["x-serverless-sign"] = de.sign(t2, this.config.clientSecret);
      const s2 = he();
      n2["x-client-info"] = encodeURIComponent(JSON.stringify(s2));
      const { token: r2 } = re();
      return n2["x-client-token"] = r2, { url: this.config.requestUrl, method: "POST", data: t2, dataType: "json", header: JSON.parse(JSON.stringify(n2)) };
    }
    async setupLocalRequest(e2) {
      const t2 = he(), { token: n2 } = re(), s2 = Object.assign({}, e2, { spaceId: this.config.spaceId, timestamp: Date.now(), clientInfo: t2, token: n2 }), { address: r2, servePort: i2 } = this.__dev__ && this.__dev__.debugInfo || {}, { address: o2 } = await At(r2, i2);
      return { url: `http://${o2}:${i2}/${Ct[e2.method]}`, method: "POST", data: s2, dataType: "json", header: JSON.parse(JSON.stringify({ "Content-Type": "application/json" })) };
    }
    callFunction(e2) {
      const t2 = { method: "serverless.function.runtime.invoke", params: JSON.stringify({ functionTarget: e2.name, functionArgs: e2.data || {} }) };
      return this.request(t2, false);
    }
    getUploadFileOptions(e2) {
      const t2 = { method: "serverless.file.resource.generateProximalSign", params: JSON.stringify(e2) };
      return this.request(t2);
    }
    reportUploadFile(e2) {
      const t2 = { method: "serverless.file.resource.report", params: JSON.stringify(e2) };
      return this.request(t2);
    }
    uploadFile({ filePath: e2, cloudPath: t2, fileType: n2 = "image", onUploadProgress: s2 }) {
      if (!t2)
        throw new te({ code: "CLOUDPATH_REQUIRED", message: "cloudPath不可为空" });
      let r2;
      return this.getUploadFileOptions({ cloudPath: t2 }).then((t3) => {
        const { url: i2, formData: o2, name: a2 } = t3.result;
        return r2 = t3.result.fileUrl, new Promise((t4, r3) => {
          const c2 = this.adapter.uploadFile({ url: i2, formData: o2, name: a2, filePath: e2, fileType: n2, success(e3) {
            e3 && e3.statusCode < 400 ? t4(e3) : r3(new te({ code: "UPLOAD_FAILED", message: "文件上传失败" }));
          }, fail(e3) {
            r3(new te({ code: e3.code || "UPLOAD_FAILED", message: e3.message || e3.errMsg || "文件上传失败" }));
          } });
          "function" == typeof s2 && c2 && "function" == typeof c2.onProgressUpdate && c2.onProgressUpdate((e3) => {
            s2({ loaded: e3.totalBytesSent, total: e3.totalBytesExpectedToSend });
          });
        });
      }).then(() => this.reportUploadFile({ cloudPath: t2 })).then((t3) => new Promise((n3, s3) => {
        t3.success ? n3({ success: true, filePath: e2, fileID: r2 }) : s3(new te({ code: "UPLOAD_FAILED", message: "文件上传失败" }));
      }));
    }
    deleteFile({ fileList: e2 }) {
      const t2 = { method: "serverless.file.resource.delete", params: JSON.stringify({ fileList: e2 }) };
      return this.request(t2).then((e3) => {
        if (e3.success)
          return e3.result;
        throw new te({ code: "DELETE_FILE_FAILED", message: "删除文件失败" });
      });
    }
    getTempFileURL({ fileList: e2, maxAge: t2 } = {}) {
      if (!Array.isArray(e2) || 0 === e2.length)
        throw new te({ code: "INVALID_PARAM", message: "fileList的元素必须是非空的字符串" });
      const n2 = { method: "serverless.file.resource.getTempFileURL", params: JSON.stringify({ fileList: e2, maxAge: t2 }) };
      return this.request(n2).then((e3) => {
        if (e3.success)
          return { fileList: e3.result.fileList.map((e4) => ({ fileID: e4.fileID, tempFileURL: e4.tempFileURL })) };
        throw new te({ code: "GET_TEMP_FILE_URL_FAILED", message: "获取临时文件链接失败" });
      });
    }
  };
  var Tt = { init(e2) {
    const t2 = new Pt(e2), n2 = { signInAnonymously: function() {
      return Promise.resolve();
    }, getLoginState: function() {
      return Promise.resolve(false);
    } };
    return t2.auth = function() {
      return n2;
    }, t2.customAuth = t2.auth, t2;
  } }, xt = n(function(e2, t2) {
    e2.exports = r.enc.Hex;
  });
  function Ot() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e2) {
      var t2 = 16 * Math.random() | 0;
      return ("x" === e2 ? t2 : 3 & t2 | 8).toString(16);
    });
  }
  function Et(e2 = "", t2 = {}) {
    const { data: n2, functionName: s2, method: r2, headers: i2, signHeaderKeys: o2 = [], config: a2 } = t2, c2 = Date.now(), u2 = Ot(), l2 = Object.assign({}, i2, { "x-from-app-id": a2.spaceAppId, "x-from-env-id": a2.spaceId, "x-to-env-id": a2.spaceId, "x-from-instance-id": c2, "x-from-function-name": s2, "x-client-timestamp": c2, "x-alipay-source": "client", "x-request-id": u2, "x-alipay-callid": u2, "x-trace-id": u2 }), h2 = ["x-from-app-id", "x-from-env-id", "x-to-env-id", "x-from-instance-id", "x-from-function-name", "x-client-timestamp"].concat(o2), [d2 = "", p2 = ""] = e2.split("?") || [], f2 = function(e3) {
      const t3 = e3.signedHeaders.join(";"), n3 = e3.signedHeaders.map((t4) => `${t4.toLowerCase()}:${e3.headers[t4]}
`).join(""), s3 = we(e3.body).toString(xt), r3 = `${e3.method.toUpperCase()}
${e3.path}
${e3.query}
${n3}
${t3}
${s3}
`, i3 = we(r3).toString(xt), o3 = `HMAC-SHA256
${e3.timestamp}
${i3}
`, a3 = ve(o3, e3.secretKey).toString(xt);
      return `HMAC-SHA256 Credential=${e3.secretId}, SignedHeaders=${t3}, Signature=${a3}`;
    }({ path: d2, query: p2, method: r2, headers: l2, timestamp: c2, body: JSON.stringify(n2), secretId: a2.accessKey, secretKey: a2.secretKey, signedHeaders: h2.sort() });
    return { url: `${a2.endpoint}${e2}`, headers: Object.assign({}, l2, { Authorization: f2 }) };
  }
  function Lt({ url: e2, data: t2, method: n2 = "POST", headers: s2 = {}, timeout: r2 }) {
    return new Promise((i2, o2) => {
      ne.request({ url: e2, method: n2, data: "object" == typeof t2 ? JSON.stringify(t2) : t2, header: s2, dataType: "json", timeout: r2, complete: (e3 = {}) => {
        const t3 = s2["x-trace-id"] || "";
        if (!e3.statusCode || e3.statusCode >= 400) {
          const { message: n3, errMsg: s3, trace_id: r3 } = e3.data || {};
          return o2(new te({ code: "SYS_ERR", message: n3 || s3 || "request:fail", requestId: r3 || t3 }));
        }
        i2({ status: e3.statusCode, data: e3.data, headers: e3.header, requestId: t3 });
      } });
    });
  }
  function Rt(e2, t2) {
    const { path: n2, data: s2, method: r2 = "GET" } = e2, { url: i2, headers: o2 } = Et(n2, { functionName: "", data: s2, method: r2, headers: { "x-alipay-cloud-mode": "oss", "x-data-api-type": "oss", "x-expire-timestamp": Date.now() + 6e4 }, signHeaderKeys: ["x-data-api-type", "x-expire-timestamp"], config: t2 });
    return Lt({ url: i2, data: s2, method: r2, headers: o2 }).then((e3) => {
      const t3 = e3.data || {};
      if (!t3.success)
        throw new te({ code: e3.errCode, message: e3.errMsg, requestId: e3.requestId });
      return t3.data || {};
    }).catch((e3) => {
      throw new te({ code: e3.errCode, message: e3.errMsg, requestId: e3.requestId });
    });
  }
  function Ut(e2 = "") {
    const t2 = e2.trim().replace(/^cloud:\/\//, ""), n2 = t2.indexOf("/");
    if (n2 <= 0)
      throw new te({ code: "INVALID_PARAM", message: "fileID不合法" });
    const s2 = t2.substring(0, n2), r2 = t2.substring(n2 + 1);
    return s2 !== this.config.spaceId && console.warn("file ".concat(e2, " does not belong to env ").concat(this.config.spaceId)), r2;
  }
  function Nt(e2 = "") {
    return "cloud://".concat(this.config.spaceId, "/").concat(e2.replace(/^\/+/, ""));
  }
  class Dt {
    constructor(e2) {
      this.config = e2;
    }
    signedURL(e2, t2 = {}) {
      const n2 = `/ws/function/${e2}`, s2 = this.config.wsEndpoint.replace(/^ws(s)?:\/\//, ""), r2 = Object.assign({}, t2, { accessKeyId: this.config.accessKey, signatureNonce: Ot(), timestamp: "" + Date.now() }), i2 = [n2, ["accessKeyId", "authorization", "signatureNonce", "timestamp"].sort().map(function(e3) {
        return r2[e3] ? "".concat(e3, "=").concat(r2[e3]) : null;
      }).filter(Boolean).join("&"), `host:${s2}`].join("\n"), o2 = ["HMAC-SHA256", we(i2).toString(xt)].join("\n"), a2 = ve(o2, this.config.secretKey).toString(xt), c2 = Object.keys(r2).map((e3) => `${e3}=${encodeURIComponent(r2[e3])}`).join("&");
      return `${this.config.wsEndpoint}${n2}?${c2}&signature=${a2}`;
    }
  }
  var Mt = class {
    constructor(e2) {
      if (["spaceId", "spaceAppId", "accessKey", "secretKey"].forEach((t2) => {
        if (!Object.prototype.hasOwnProperty.call(e2, t2))
          throw new Error(`${t2} required`);
      }), e2.endpoint) {
        if ("string" != typeof e2.endpoint)
          throw new Error("endpoint must be string");
        if (!/^https:\/\//.test(e2.endpoint))
          throw new Error("endpoint must start with https://");
        e2.endpoint = e2.endpoint.replace(/\/$/, "");
      }
      this.config = Object.assign({}, e2, { endpoint: e2.endpoint || `https://${e2.spaceId}.api-hz.cloudbasefunction.cn`, wsEndpoint: e2.wsEndpoint || `wss://${e2.spaceId}.api-hz.cloudbasefunction.cn` }), this._websocket = new Dt(this.config);
    }
    callFunction(e2) {
      return function(e3, t2) {
        const { name: n2, data: s2, async: r2 = false, timeout: i2 } = e3, o2 = "POST", a2 = { "x-to-function-name": n2 };
        r2 && (a2["x-function-invoke-type"] = "async");
        const { url: c2, headers: u2 } = Et("/functions/invokeFunction", { functionName: n2, data: s2, method: o2, headers: a2, signHeaderKeys: ["x-to-function-name"], config: t2 });
        return Lt({ url: c2, data: s2, method: o2, headers: u2, timeout: i2 }).then((e4) => {
          let t3 = 0;
          if (r2) {
            const n3 = e4.data || {};
            t3 = "200" === n3.errCode ? 0 : n3.errCode, e4.data = n3.data || {}, e4.errMsg = n3.errMsg;
          }
          if (0 !== t3)
            throw new te({ code: t3, message: e4.errMsg, requestId: e4.requestId });
          return { errCode: t3, success: 0 === t3, requestId: e4.requestId, result: e4.data };
        }).catch((e4) => {
          throw new te({ code: e4.errCode, message: e4.errMsg, requestId: e4.requestId });
        });
      }(e2, this.config);
    }
    uploadFileToOSS({ url: e2, filePath: t2, fileType: n2, formData: s2, onUploadProgress: r2 }) {
      return new Promise((i2, o2) => {
        const a2 = ne.uploadFile({ url: e2, filePath: t2, fileType: n2, formData: s2, name: "file", success(e3) {
          e3 && e3.statusCode < 400 ? i2(e3) : o2(new te({ code: "UPLOAD_FAILED", message: "文件上传失败" }));
        }, fail(e3) {
          o2(new te({ code: e3.code || "UPLOAD_FAILED", message: e3.message || e3.errMsg || "文件上传失败" }));
        } });
        "function" == typeof r2 && a2 && "function" == typeof a2.onProgressUpdate && a2.onProgressUpdate((e3) => {
          r2({ loaded: e3.totalBytesSent, total: e3.totalBytesExpectedToSend });
        });
      });
    }
    async uploadFile({ filePath: e2, cloudPath: t2 = "", fileType: n2 = "image", onUploadProgress: s2 }) {
      if ("string" !== f(t2))
        throw new te({ code: "INVALID_PARAM", message: "cloudPath必须为字符串类型" });
      if (!(t2 = t2.trim()))
        throw new te({ code: "INVALID_PARAM", message: "cloudPath不可为空" });
      if (/:\/\//.test(t2))
        throw new te({ code: "INVALID_PARAM", message: "cloudPath不合法" });
      const r2 = await Rt({ path: "/".concat(t2.replace(/^\//, ""), "?post_url") }, this.config), { file_id: i2, upload_url: o2, form_data: a2 } = r2, c2 = a2 && a2.reduce((e3, t3) => (e3[t3.key] = t3.value, e3), {});
      return this.uploadFileToOSS({ url: o2, filePath: e2, fileType: n2, formData: c2, onUploadProgress: s2 }).then(() => ({ fileID: i2 }));
    }
    async getTempFileURL({ fileList: e2 }) {
      return new Promise((t2, n2) => {
        (!e2 || e2.length < 0) && n2(new te({ errCode: "INVALID_PARAM", errMsg: "fileList不能为空数组" })), e2.length > 50 && n2(new te({ errCode: "INVALID_PARAM", errMsg: "fileList数组长度不能超过50" }));
        const s2 = [];
        for (const t3 of e2) {
          "string" !== f(t3) && n2(new te({ errCode: "INVALID_PARAM", errMsg: "fileList的元素必须是非空的字符串" }));
          const e3 = Ut.call(this, t3);
          s2.push({ file_id: e3, expire: 600 });
        }
        Rt({ path: "/?download_url", data: { file_list: s2 }, method: "POST" }, this.config).then((e3) => {
          const { file_list: n3 = [] } = e3;
          t2({ fileList: n3.map((e4) => ({ fileID: Nt.call(this, e4.file_id), tempFileURL: e4.download_url })) });
        }).catch((e3) => n2(e3));
      });
    }
    async connectWebSocket(e2) {
      const { name: t2, query: n2 } = e2;
      return ne.connectSocket({ url: this._websocket.signedURL(t2, n2), complete: () => {
      } });
    }
  };
  var qt = { init: (e2) => {
    e2.provider = "alipay";
    const t2 = new Mt(e2);
    return t2.auth = function() {
      return { signInAnonymously: function() {
        return Promise.resolve();
      }, getLoginState: function() {
        return Promise.resolve(true);
      } };
    }, t2;
  } };
  function Ft({ data: e2 }) {
    let t2;
    t2 = he();
    const n2 = JSON.parse(JSON.stringify(e2 || {}));
    if (Object.assign(n2, { clientInfo: t2 }), !n2.uniIdToken) {
      const { token: e3 } = re();
      e3 && (n2.uniIdToken = e3);
    }
    return n2;
  }
  async function Kt(e2 = {}) {
    await this.__dev__.initLocalNetwork();
    const { localAddress: t2, localPort: n2 } = this.__dev__, s2 = { aliyun: "aliyun", tencent: "tcb", alipay: "alipay", dcloud: "dcloud" }[this.config.provider], r2 = this.config.spaceId, i2 = `http://${t2}:${n2}/system/check-function`, o2 = `http://${t2}:${n2}/cloudfunctions/${e2.name}`;
    return new Promise((t3, n3) => {
      ne.request({ method: "POST", url: i2, data: { name: e2.name, platform: C, provider: s2, spaceId: r2 }, timeout: 3e3, success(e3) {
        t3(e3);
      }, fail() {
        t3({ data: { code: "NETWORK_ERROR", message: "连接本地调试服务失败，请检查客户端是否和主机在同一局域网下，自动切换为已部署的云函数。" } });
      } });
    }).then(({ data: e3 } = {}) => {
      const { code: t3, message: n3 } = e3 || {};
      return { code: 0 === t3 ? 0 : t3 || "SYS_ERR", message: n3 || "SYS_ERR" };
    }).then(({ code: t3, message: n3 }) => {
      if (0 !== t3) {
        switch (t3) {
          case "MODULE_ENCRYPTED":
            console.error(`此云函数（${e2.name}）依赖加密公共模块不可本地调试，自动切换为云端已部署的云函数`);
            break;
          case "FUNCTION_ENCRYPTED":
            console.error(`此云函数（${e2.name}）已加密不可本地调试，自动切换为云端已部署的云函数`);
            break;
          case "ACTION_ENCRYPTED":
            console.error(n3 || "需要访问加密的uni-clientDB-action，自动切换为云端环境");
            break;
          case "NETWORK_ERROR":
            console.error(n3 || "连接本地调试服务失败，请检查客户端是否和主机在同一局域网下");
            break;
          case "SWITCH_TO_CLOUD":
            break;
          default: {
            const e3 = `检测本地调试服务出现错误：${n3}，请检查网络环境或重启客户端再试`;
            throw console.error(e3), new Error(e3);
          }
        }
        return this._callCloudFunction(e2);
      }
      return new Promise((t4, n4) => {
        const r3 = Ft.call(this, { data: e2.data });
        ne.request({ method: "POST", url: o2, data: { provider: s2, platform: C, param: r3 }, timeout: e2.timeout, success: ({ statusCode: e3, data: s3 } = {}) => !e3 || e3 >= 400 ? n4(new te({ code: s3.code || "SYS_ERR", message: s3.message || "request:fail" })) : t4({ result: s3 }), fail(e3) {
          n4(new te({ code: e3.code || e3.errCode || "SYS_ERR", message: e3.message || e3.errMsg || "request:fail" }));
        } });
      });
    });
  }
  const jt = [{ rule: /fc_function_not_found|FUNCTION_NOT_FOUND/, content: "，云函数[{functionName}]在云端不存在，请检查此云函数名称是否正确以及该云函数是否已上传到服务空间", mode: "append" }];
  var $t = /[\\^$.*+?()[\]{}|]/g, Bt = RegExp($t.source);
  function Wt(e2, t2, n2) {
    return e2.replace(new RegExp((s2 = t2) && Bt.test(s2) ? s2.replace($t, "\\$&") : s2, "g"), n2);
    var s2;
  }
  const Jt = "request", zt = "response", Vt = "both";
  const En = { code: 2e4, message: "System error" }, Ln = { code: 20101, message: "Invalid client" };
  function Nn(e2) {
    const { errSubject: t2, subject: n2, errCode: s2, errMsg: r2, code: i2, message: o2, cause: a2 } = e2 || {};
    return new te({ subject: t2 || n2 || "uni-secure-network", code: s2 || i2 || En.code, message: r2 || o2, cause: a2 });
  }
  let Mn;
  function $n({ secretType: e2 } = {}) {
    return e2 === Jt || e2 === zt || e2 === Vt;
  }
  function Bn({ name: e2, data: t2 = {} } = {}) {
    return "DCloud-clientDB" === e2 && "encryption" === t2.redirectTo && "getAppClientKey" === t2.action;
  }
  function Wn({ provider: e2, spaceId: t2, functionName: n2 } = {}) {
    const { appId: s2, uniPlatform: r2, osName: i2 } = ce();
    let o2 = r2;
    "app" === r2 && (o2 = i2);
    const a2 = function({ provider: e3, spaceId: t3 } = {}) {
      const n3 = A;
      if (!n3)
        return {};
      e3 = /* @__PURE__ */ function(e4) {
        return "tencent" === e4 ? "tcb" : e4;
      }(e3);
      const s3 = n3.find((n4) => n4.provider === e3 && n4.spaceId === t3);
      return s3 && s3.config;
    }({ provider: e2, spaceId: t2 });
    if (!a2 || !a2.accessControl || !a2.accessControl.enable)
      return false;
    const c2 = a2.accessControl.function || {}, u2 = Object.keys(c2);
    if (0 === u2.length)
      return true;
    const l2 = function(e3, t3) {
      let n3, s3, r3;
      for (let i3 = 0; i3 < e3.length; i3++) {
        const o3 = e3[i3];
        o3 !== t3 ? "*" !== o3 ? o3.split(",").map((e4) => e4.trim()).indexOf(t3) > -1 && (s3 = o3) : r3 = o3 : n3 = o3;
      }
      return n3 || s3 || r3;
    }(u2, n2);
    if (!l2)
      return false;
    if ((c2[l2] || []).find((e3 = {}) => e3.appId === s2 && (e3.platform || "").toLowerCase() === o2.toLowerCase()))
      return true;
    throw console.error(`此应用[appId: ${s2}, platform: ${o2}]不在云端配置的允许访问的应用列表内，参考：https://uniapp.dcloud.net.cn/uniCloud/secure-network.html#verify-client`), Nn(Ln);
  }
  function Hn({ functionName: e2, result: t2, logPvd: n2 }) {
    if (this.__dev__.debugLog && t2 && t2.requestId) {
      const s2 = JSON.stringify({ spaceId: this.config.spaceId, functionName: e2, requestId: t2.requestId });
      console.log(`[${n2}-request]${s2}[/${n2}-request]`);
    }
  }
  function Jn(e2) {
    const t2 = e2.callFunction, n2 = function(n3) {
      const s2 = n3.name;
      n3.data = Ft.call(e2, { data: n3.data });
      const r2 = { aliyun: "aliyun", tencent: "tcb", tcb: "tcb", alipay: "alipay", dcloud: "dcloud" }[this.config.provider], i2 = $n(n3), o2 = Bn(n3), a2 = i2 || o2;
      return t2.call(this, n3).then((e3) => (e3.errCode = 0, !a2 && Hn.call(this, { functionName: s2, result: e3, logPvd: r2 }), Promise.resolve(e3)), (e3) => (!a2 && Hn.call(this, { functionName: s2, result: e3, logPvd: r2 }), e3 && e3.message && (e3.message = function({ message: e4 = "", extraInfo: t3 = {}, formatter: n4 = [] } = {}) {
        for (let s3 = 0; s3 < n4.length; s3++) {
          const { rule: r3, content: i3, mode: o3 } = n4[s3], a3 = e4.match(r3);
          if (!a3)
            continue;
          let c2 = i3;
          for (let e5 = 1; e5 < a3.length; e5++)
            c2 = Wt(c2, `{$${e5}}`, a3[e5]);
          for (const e5 in t3)
            c2 = Wt(c2, `{${e5}}`, t3[e5]);
          return "replace" === o3 ? c2 : e4 + c2;
        }
        return e4;
      }({ message: `[${n3.name}]: ${e3.message}`, formatter: jt, extraInfo: { functionName: s2 } })), Promise.reject(e3)));
    };
    e2.callFunction = function(t3) {
      const { provider: s2, spaceId: r2 } = e2.config, i2 = t3.name;
      let o2, a2;
      if (t3.data = t3.data || {}, e2.__dev__.debugInfo && !e2.__dev__.debugInfo.forceRemote && T ? (e2._callCloudFunction || (e2._callCloudFunction = n2, e2._callLocalFunction = Kt), o2 = Kt) : o2 = n2, o2 = o2.bind(e2), Bn(t3))
        a2 = n2.call(e2, t3);
      else if ($n(t3)) {
        a2 = new Mn({ secretType: t3.secretType, uniCloudIns: e2 }).wrapEncryptDataCallFunction(n2.bind(e2))(t3);
      } else if (Wn({ provider: s2, spaceId: r2, functionName: i2 })) {
        a2 = new Mn({ secretType: t3.secretType, uniCloudIns: e2 }).wrapVerifyClientCallFunction(n2.bind(e2))(t3);
      } else
        a2 = o2(t3);
      return Object.defineProperty(a2, "result", { get: () => (console.warn("当前返回结果为Promise类型，不可直接访问其result属性，详情请参考：https://uniapp.dcloud.net.cn/uniCloud/faq?id=promise"), {}) }), a2.then((e3) => ("undefined" != typeof UTSJSONObject && (e3.result = new UTSJSONObject(e3.result)), e3));
    };
  }
  Mn = class {
    constructor() {
      throw Nn({ message: `Platform ${C} is not enabled, please check whether secure network module is enabled in your manifest.json` });
    }
  };
  const zn = Symbol("CLIENT_DB_INTERNAL");
  function Vn(e2, t2) {
    return e2.then = "DoNotReturnProxyWithAFunctionNamedThen", e2._internalType = zn, e2.inspect = null, e2.__v_raw = void 0, new Proxy(e2, { get(e3, n2, s2) {
      if ("_uniClient" === n2)
        return null;
      if ("symbol" == typeof n2)
        return e3[n2];
      if (n2 in e3 || "string" != typeof n2) {
        const t3 = e3[n2];
        return "function" == typeof t3 ? t3.bind(e3) : t3;
      }
      return t2.get(e3, n2, s2);
    } });
  }
  function Gn(e2) {
    return { on: (t2, n2) => {
      e2[t2] = e2[t2] || [], e2[t2].indexOf(n2) > -1 || e2[t2].push(n2);
    }, off: (t2, n2) => {
      e2[t2] = e2[t2] || [];
      const s2 = e2[t2].indexOf(n2);
      -1 !== s2 && e2[t2].splice(s2, 1);
    } };
  }
  const Yn = ["db.Geo", "db.command", "command.aggregate"];
  function Qn(e2, t2) {
    return Yn.indexOf(`${e2}.${t2}`) > -1;
  }
  function Xn(e2) {
    switch (f(e2 = se(e2))) {
      case "array":
        return e2.map((e3) => Xn(e3));
      case "object":
        return e2._internalType === zn || Object.keys(e2).forEach((t2) => {
          e2[t2] = Xn(e2[t2]);
        }), e2;
      case "regexp":
        return { $regexp: { source: e2.source, flags: e2.flags } };
      case "date":
        return { $date: e2.toISOString() };
      default:
        return e2;
    }
  }
  function Zn(e2) {
    return e2 && e2.content && e2.content.$method;
  }
  class es {
    constructor(e2, t2, n2) {
      this.content = e2, this.prevStage = t2 || null, this.udb = null, this._database = n2;
    }
    toJSON() {
      let e2 = this;
      const t2 = [e2.content];
      for (; e2.prevStage; )
        e2 = e2.prevStage, t2.push(e2.content);
      return { $db: t2.reverse().map((e3) => ({ $method: e3.$method, $param: Xn(e3.$param) })) };
    }
    toString() {
      return JSON.stringify(this.toJSON());
    }
    getAction() {
      const e2 = this.toJSON().$db.find((e3) => "action" === e3.$method);
      return e2 && e2.$param && e2.$param[0];
    }
    getCommand() {
      return { $db: this.toJSON().$db.filter((e2) => "action" !== e2.$method) };
    }
    get isAggregate() {
      let e2 = this;
      for (; e2; ) {
        const t2 = Zn(e2), n2 = Zn(e2.prevStage);
        if ("aggregate" === t2 && "collection" === n2 || "pipeline" === t2)
          return true;
        e2 = e2.prevStage;
      }
      return false;
    }
    get isCommand() {
      let e2 = this;
      for (; e2; ) {
        if ("command" === Zn(e2))
          return true;
        e2 = e2.prevStage;
      }
      return false;
    }
    get isAggregateCommand() {
      let e2 = this;
      for (; e2; ) {
        const t2 = Zn(e2), n2 = Zn(e2.prevStage);
        if ("aggregate" === t2 && "command" === n2)
          return true;
        e2 = e2.prevStage;
      }
      return false;
    }
    getNextStageFn(e2) {
      const t2 = this;
      return function() {
        return ts({ $method: e2, $param: Xn(Array.from(arguments)) }, t2, t2._database);
      };
    }
    get count() {
      return this.isAggregate ? this.getNextStageFn("count") : function() {
        return this._send("count", Array.from(arguments));
      };
    }
    get remove() {
      return this.isCommand ? this.getNextStageFn("remove") : function() {
        return this._send("remove", Array.from(arguments));
      };
    }
    get() {
      return this._send("get", Array.from(arguments));
    }
    get add() {
      return this.isCommand ? this.getNextStageFn("add") : function() {
        return this._send("add", Array.from(arguments));
      };
    }
    update() {
      return this._send("update", Array.from(arguments));
    }
    end() {
      return this._send("end", Array.from(arguments));
    }
    get set() {
      return this.isCommand ? this.getNextStageFn("set") : function() {
        throw new Error("JQL禁止使用set方法");
      };
    }
    _send(e2, t2) {
      const n2 = this.getAction(), s2 = this.getCommand();
      if (s2.$db.push({ $method: e2, $param: Xn(t2) }), S) {
        const e3 = s2.$db.find((e4) => "collection" === e4.$method), t3 = e3 && e3.$param;
        t3 && 1 === t3.length && "string" == typeof e3.$param[0] && e3.$param[0].indexOf(",") > -1 && console.warn("检测到使用JQL语法联表查询时，未使用getTemp先过滤主表数据，在主表数据量大的情况下可能会查询缓慢。\n- 如何优化请参考此文档：https://uniapp.dcloud.net.cn/uniCloud/jql?id=lookup-with-temp \n- 如果主表数据量很小请忽略此信息，项目发行时不会出现此提示。");
      }
      return this._database._callCloudFunction({ action: n2, command: s2 });
    }
  }
  function ts(e2, t2, n2) {
    return Vn(new es(e2, t2, n2), { get(e3, t3) {
      let s2 = "db";
      return e3 && e3.content && (s2 = e3.content.$method), Qn(s2, t3) ? ts({ $method: t3 }, e3, n2) : function() {
        return ts({ $method: t3, $param: Xn(Array.from(arguments)) }, e3, n2);
      };
    } });
  }
  function ns({ path: e2, method: t2 }) {
    return class {
      constructor() {
        this.param = Array.from(arguments);
      }
      toJSON() {
        return { $newDb: [...e2.map((e3) => ({ $method: e3 })), { $method: t2, $param: this.param }] };
      }
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
  }
  function ss(e2, t2 = {}) {
    return Vn(new e2(t2), { get: (e3, t3) => Qn("db", t3) ? ts({ $method: t3 }, null, e3) : function() {
      return ts({ $method: t3, $param: Xn(Array.from(arguments)) }, null, e3);
    } });
  }
  class rs extends class {
    constructor({ uniClient: e2 = {}, isJQL: t2 = false } = {}) {
      this._uniClient = e2, this._authCallBacks = {}, this._dbCallBacks = {}, e2._isDefault && (this._dbCallBacks = L("_globalUniCloudDatabaseCallback")), t2 || (this.auth = Gn(this._authCallBacks)), this._isJQL = t2, Object.assign(this, Gn(this._dbCallBacks)), this.env = Vn({}, { get: (e3, t3) => ({ $env: t3 }) }), this.Geo = Vn({}, { get: (e3, t3) => ns({ path: ["Geo"], method: t3 }) }), this.serverDate = ns({ path: [], method: "serverDate" }), this.RegExp = ns({ path: [], method: "RegExp" });
    }
    getCloudEnv(e2) {
      if ("string" != typeof e2 || !e2.trim())
        throw new Error("getCloudEnv参数错误");
      return { $env: e2.replace("$cloudEnv_", "") };
    }
    _callback(e2, t2) {
      const n2 = this._dbCallBacks;
      n2[e2] && n2[e2].forEach((e3) => {
        e3(...t2);
      });
    }
    _callbackAuth(e2, t2) {
      const n2 = this._authCallBacks;
      n2[e2] && n2[e2].forEach((e3) => {
        e3(...t2);
      });
    }
    multiSend() {
      const e2 = Array.from(arguments), t2 = e2.map((e3) => {
        const t3 = e3.getAction(), n2 = e3.getCommand();
        if ("getTemp" !== n2.$db[n2.$db.length - 1].$method)
          throw new Error("multiSend只支持子命令内使用getTemp");
        return { action: t3, command: n2 };
      });
      return this._callCloudFunction({ multiCommand: t2, queryList: e2 });
    }
  } {
    _parseResult(e2) {
      return this._isJQL ? e2.result : e2;
    }
    _callCloudFunction({ action: e2, command: t2, multiCommand: n2, queryList: s2 }) {
      function r2(e3, t3) {
        if (n2 && s2)
          for (let n3 = 0; n3 < s2.length; n3++) {
            const r3 = s2[n3];
            r3.udb && "function" == typeof r3.udb.setResult && (t3 ? r3.udb.setResult(t3) : r3.udb.setResult(e3.result.dataList[n3]));
          }
      }
      const i2 = this, o2 = this._isJQL ? "databaseForJQL" : "database";
      function a2(e3) {
        return i2._callback("error", [e3]), M(q(o2, "fail"), e3).then(() => M(q(o2, "complete"), e3)).then(() => (r2(null, e3), Y(j, { type: W, content: e3 }), Promise.reject(e3)));
      }
      const c2 = M(q(o2, "invoke")), u2 = this._uniClient;
      return c2.then(() => u2.callFunction({ name: "DCloud-clientDB", type: l, data: { action: e2, command: t2, multiCommand: n2 } })).then((e3) => {
        const { code: t3, message: n3, token: s3, tokenExpired: c3, systemInfo: u3 = [] } = e3.result;
        if (u3)
          for (let e4 = 0; e4 < u3.length; e4++) {
            const { level: t4, message: n4, detail: s4 } = u3[e4], r3 = console["warn" === t4 ? "error" : t4] || console.log;
            let i3 = "[System Info]" + n4;
            s4 && (i3 = `${i3}
详细信息：${s4}`), r3(i3);
          }
        if (t3) {
          return a2(new te({ code: t3, message: n3, requestId: e3.requestId }));
        }
        e3.result.errCode = e3.result.errCode || e3.result.code, e3.result.errMsg = e3.result.errMsg || e3.result.message, s3 && c3 && (ie({ token: s3, tokenExpired: c3 }), this._callbackAuth("refreshToken", [{ token: s3, tokenExpired: c3 }]), this._callback("refreshToken", [{ token: s3, tokenExpired: c3 }]), Y(B, { token: s3, tokenExpired: c3 }));
        const l2 = [{ prop: "affectedDocs", tips: "affectedDocs不再推荐使用，请使用inserted/deleted/updated/data.length替代" }, { prop: "code", tips: "code不再推荐使用，请使用errCode替代" }, { prop: "message", tips: "message不再推荐使用，请使用errMsg替代" }];
        for (let t4 = 0; t4 < l2.length; t4++) {
          const { prop: n4, tips: s4 } = l2[t4];
          if (n4 in e3.result) {
            const t5 = e3.result[n4];
            Object.defineProperty(e3.result, n4, { get: () => (console.warn(s4), t5) });
          }
        }
        return function(e4) {
          return M(q(o2, "success"), e4).then(() => M(q(o2, "complete"), e4)).then(() => {
            r2(e4, null);
            const t4 = i2._parseResult(e4);
            return Y(j, { type: W, content: t4 }), Promise.resolve(t4);
          });
        }(e3);
      }, (e3) => {
        /fc_function_not_found|FUNCTION_NOT_FOUND/g.test(e3.message) && console.warn("clientDB未初始化，请在web控制台保存一次schema以开启clientDB");
        return a2(new te({ code: e3.code || "SYSTEM_ERROR", message: e3.message, requestId: e3.requestId }));
      });
    }
  }
  const is = "token无效，跳转登录页面", os = "token过期，跳转登录页面", as = { TOKEN_INVALID_TOKEN_EXPIRED: os, TOKEN_INVALID_INVALID_CLIENTID: is, TOKEN_INVALID: is, TOKEN_INVALID_WRONG_TOKEN: is, TOKEN_INVALID_ANONYMOUS_USER: is }, cs = { "uni-id-token-expired": os, "uni-id-check-token-failed": is, "uni-id-token-not-exist": is, "uni-id-check-device-feature-failed": is };
  function us(e2, t2) {
    let n2 = "";
    return n2 = e2 ? `${e2}/${t2}` : t2, n2.replace(/^\//, "");
  }
  function ls(e2 = [], t2 = "") {
    const n2 = [], s2 = [];
    return e2.forEach((e3) => {
      true === e3.needLogin ? n2.push(us(t2, e3.path)) : false === e3.needLogin && s2.push(us(t2, e3.path));
    }), { needLoginPage: n2, notNeedLoginPage: s2 };
  }
  function hs(e2) {
    return e2.split("?")[0].replace(/^\//, "");
  }
  function ds() {
    return function(e2) {
      let t2 = e2 && e2.$page && e2.$page.fullPath || "";
      return t2 ? ("/" !== t2.charAt(0) && (t2 = "/" + t2), t2) : t2;
    }(function() {
      const e2 = getCurrentPages();
      return e2[e2.length - 1];
    }());
  }
  function ps() {
    return hs(ds());
  }
  function fs(e2 = "", t2 = {}) {
    if (!e2)
      return false;
    if (!(t2 && t2.list && t2.list.length))
      return false;
    const n2 = t2.list, s2 = hs(e2);
    return n2.some((e3) => e3.pagePath === s2);
  }
  const gs = !!e.uniIdRouter;
  const { loginPage: ms, routerNeedLogin: ys, resToLogin: _s, needLoginPage: ws, notNeedLoginPage: vs, loginPageInTabBar: Is } = function({ pages: t2 = [], subPackages: n2 = [], uniIdRouter: s2 = {}, tabBar: r2 = {} } = e) {
    const { loginPage: i2, needLogin: o2 = [], resToLogin: a2 = true } = s2, { needLoginPage: c2, notNeedLoginPage: u2 } = ls(t2), { needLoginPage: l2, notNeedLoginPage: h2 } = function(e2 = []) {
      const t3 = [], n3 = [];
      return e2.forEach((e3) => {
        const { root: s3, pages: r3 = [] } = e3, { needLoginPage: i3, notNeedLoginPage: o3 } = ls(r3, s3);
        t3.push(...i3), n3.push(...o3);
      }), { needLoginPage: t3, notNeedLoginPage: n3 };
    }(n2);
    return { loginPage: i2, routerNeedLogin: o2, resToLogin: a2, needLoginPage: [...c2, ...l2], notNeedLoginPage: [...u2, ...h2], loginPageInTabBar: fs(i2, r2) };
  }();
  if (ws.indexOf(ms) > -1)
    throw new Error(`Login page [${ms}] should not be "needLogin", please check your pages.json`);
  function Ss(e2) {
    const t2 = ps();
    if ("/" === e2.charAt(0))
      return e2;
    const [n2, s2] = e2.split("?"), r2 = n2.replace(/^\//, "").split("/"), i2 = t2.split("/");
    i2.pop();
    for (let e3 = 0; e3 < r2.length; e3++) {
      const t3 = r2[e3];
      ".." === t3 ? i2.pop() : "." !== t3 && i2.push(t3);
    }
    return "" === i2[0] && i2.shift(), "/" + i2.join("/") + (s2 ? "?" + s2 : "");
  }
  function bs(e2) {
    const t2 = hs(Ss(e2));
    return !(vs.indexOf(t2) > -1) && (ws.indexOf(t2) > -1 || ys.some((t3) => function(e3, t4) {
      return new RegExp(t4).test(e3);
    }(e2, t3)));
  }
  function ks({ redirect: e2 }) {
    const t2 = hs(e2), n2 = hs(ms);
    return ps() !== n2 && t2 !== n2;
  }
  function As({ api: e2, redirect: t2 } = {}) {
    if (!t2 || !ks({ redirect: t2 }))
      return;
    const n2 = function(e3, t3) {
      return "/" !== e3.charAt(0) && (e3 = "/" + e3), t3 ? e3.indexOf("?") > -1 ? e3 + `&uniIdRedirectUrl=${encodeURIComponent(t3)}` : e3 + `?uniIdRedirectUrl=${encodeURIComponent(t3)}` : e3;
    }(ms, t2);
    Is ? "navigateTo" !== e2 && "redirectTo" !== e2 || (e2 = "switchTab") : "switchTab" === e2 && (e2 = "navigateTo");
    const s2 = { navigateTo: uni.navigateTo, redirectTo: uni.redirectTo, switchTab: uni.switchTab, reLaunch: uni.reLaunch };
    setTimeout(() => {
      s2[e2]({ url: n2 });
    }, 0);
  }
  function Cs({ url: e2 } = {}) {
    const t2 = { abortLoginPageJump: false, autoToLoginPage: false }, n2 = function() {
      const { token: e3, tokenExpired: t3 } = re();
      let n3;
      if (e3) {
        if (t3 < Date.now()) {
          const e4 = "uni-id-token-expired";
          n3 = { errCode: e4, errMsg: cs[e4] };
        }
      } else {
        const e4 = "uni-id-check-token-failed";
        n3 = { errCode: e4, errMsg: cs[e4] };
      }
      return n3;
    }();
    if (bs(e2) && n2) {
      n2.uniIdRedirectUrl = e2;
      if (z($).length > 0)
        return setTimeout(() => {
          Y($, n2);
        }, 0), t2.abortLoginPageJump = true, t2;
      t2.autoToLoginPage = true;
    }
    return t2;
  }
  function Ps() {
    !function() {
      const e3 = ds(), { abortLoginPageJump: t2, autoToLoginPage: n2 } = Cs({ url: e3 });
      t2 || n2 && As({ api: "redirectTo", redirect: e3 });
    }();
    const e2 = ["navigateTo", "redirectTo", "reLaunch", "switchTab"];
    for (let t2 = 0; t2 < e2.length; t2++) {
      const n2 = e2[t2];
      uni.addInterceptor(n2, { invoke(e3) {
        const { abortLoginPageJump: t3, autoToLoginPage: s2 } = Cs({ url: e3.url });
        return t3 ? e3 : s2 ? (As({ api: n2, redirect: Ss(e3.url) }), false) : e3;
      } });
    }
  }
  function Ts() {
    this.onResponse((e2) => {
      const { type: t2, content: n2 } = e2;
      let s2 = false;
      switch (t2) {
        case "cloudobject":
          s2 = function(e3) {
            if ("object" != typeof e3)
              return false;
            const { errCode: t3 } = e3 || {};
            return t3 in cs;
          }(n2);
          break;
        case "clientdb":
          s2 = function(e3) {
            if ("object" != typeof e3)
              return false;
            const { errCode: t3 } = e3 || {};
            return t3 in as;
          }(n2);
      }
      s2 && function(e3 = {}) {
        const t3 = z($);
        Z().then(() => {
          const n3 = ds();
          if (n3 && ks({ redirect: n3 }))
            return t3.length > 0 ? Y($, Object.assign({ uniIdRedirectUrl: n3 }, e3)) : void (ms && As({ api: "navigateTo", redirect: n3 }));
        });
      }(n2);
    });
  }
  function xs(e2) {
    !function(e3) {
      e3.onResponse = function(e4) {
        V(j, e4);
      }, e3.offResponse = function(e4) {
        G(j, e4);
      };
    }(e2), function(e3) {
      e3.onNeedLogin = function(e4) {
        V($, e4);
      }, e3.offNeedLogin = function(e4) {
        G($, e4);
      }, gs && (L("_globalUniCloudStatus").needLoginInit || (L("_globalUniCloudStatus").needLoginInit = true, Z().then(() => {
        Ps.call(e3);
      }), _s && Ts.call(e3)));
    }(e2), function(e3) {
      e3.onRefreshToken = function(e4) {
        V(B, e4);
      }, e3.offRefreshToken = function(e4) {
        G(B, e4);
      };
    }(e2);
  }
  let Os;
  const Es = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Ls = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;
  function Rs() {
    const e2 = re().token || "", t2 = e2.split(".");
    if (!e2 || 3 !== t2.length)
      return { uid: null, role: [], permission: [], tokenExpired: 0 };
    let n2;
    try {
      n2 = JSON.parse((s2 = t2[1], decodeURIComponent(Os(s2).split("").map(function(e3) {
        return "%" + ("00" + e3.charCodeAt(0).toString(16)).slice(-2);
      }).join(""))));
    } catch (e3) {
      throw new Error("获取当前用户信息出错，详细错误信息为：" + e3.message);
    }
    var s2;
    return n2.tokenExpired = 1e3 * n2.exp, delete n2.exp, delete n2.iat, n2;
  }
  Os = "function" != typeof atob ? function(e2) {
    if (e2 = String(e2).replace(/[\t\n\f\r ]+/g, ""), !Ls.test(e2))
      throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
    var t2;
    e2 += "==".slice(2 - (3 & e2.length));
    for (var n2, s2, r2 = "", i2 = 0; i2 < e2.length; )
      t2 = Es.indexOf(e2.charAt(i2++)) << 18 | Es.indexOf(e2.charAt(i2++)) << 12 | (n2 = Es.indexOf(e2.charAt(i2++))) << 6 | (s2 = Es.indexOf(e2.charAt(i2++))), r2 += 64 === n2 ? String.fromCharCode(t2 >> 16 & 255) : 64 === s2 ? String.fromCharCode(t2 >> 16 & 255, t2 >> 8 & 255) : String.fromCharCode(t2 >> 16 & 255, t2 >> 8 & 255, 255 & t2);
    return r2;
  } : atob;
  var Us = n(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true });
    const n2 = "chooseAndUploadFile:ok", s2 = "chooseAndUploadFile:fail";
    function r2(e3, t3) {
      return e3.tempFiles.forEach((e4, n3) => {
        e4.name || (e4.name = e4.path.substring(e4.path.lastIndexOf("/") + 1)), t3 && (e4.fileType = t3), e4.cloudPath = Date.now() + "_" + n3 + e4.name.substring(e4.name.lastIndexOf("."));
      }), e3.tempFilePaths || (e3.tempFilePaths = e3.tempFiles.map((e4) => e4.path)), e3;
    }
    function i2(e3, t3, { onChooseFile: s3, onUploadProgress: r3 }) {
      return t3.then((e4) => {
        if (s3) {
          const t4 = s3(e4);
          if (void 0 !== t4)
            return Promise.resolve(t4).then((t5) => void 0 === t5 ? e4 : t5);
        }
        return e4;
      }).then((t4) => false === t4 ? { errMsg: n2, tempFilePaths: [], tempFiles: [] } : function(e4, t5, s4 = 5, r4) {
        (t5 = Object.assign({}, t5)).errMsg = n2;
        const i3 = t5.tempFiles, o2 = i3.length;
        let a2 = 0;
        return new Promise((n3) => {
          for (; a2 < s4; )
            c2();
          function c2() {
            const s5 = a2++;
            if (s5 >= o2)
              return void (!i3.find((e5) => !e5.url && !e5.errMsg) && n3(t5));
            const u2 = i3[s5];
            e4.uploadFile({ provider: u2.provider, filePath: u2.path, cloudPath: u2.cloudPath, fileType: u2.fileType, cloudPathAsRealPath: u2.cloudPathAsRealPath, onUploadProgress(e5) {
              e5.index = s5, e5.tempFile = u2, e5.tempFilePath = u2.path, r4 && r4(e5);
            } }).then((e5) => {
              u2.url = e5.fileID, s5 < o2 && c2();
            }).catch((e5) => {
              u2.errMsg = e5.errMsg || e5.message, s5 < o2 && c2();
            });
          }
        });
      }(e3, t4, 5, r3));
    }
    t2.initChooseAndUploadFile = function(e3) {
      return function(t3 = { type: "all" }) {
        return "image" === t3.type ? i2(e3, function(e4) {
          const { count: t4, sizeType: n3, sourceType: i3 = ["album", "camera"], extension: o2 } = e4;
          return new Promise((e5, a2) => {
            uni.chooseImage({ count: t4, sizeType: n3, sourceType: i3, extension: o2, success(t5) {
              e5(r2(t5, "image"));
            }, fail(e6) {
              a2({ errMsg: e6.errMsg.replace("chooseImage:fail", s2) });
            } });
          });
        }(t3), t3) : "video" === t3.type ? i2(e3, function(e4) {
          const { camera: t4, compressed: n3, maxDuration: i3, sourceType: o2 = ["album", "camera"], extension: a2 } = e4;
          return new Promise((e5, c2) => {
            uni.chooseVideo({ camera: t4, compressed: n3, maxDuration: i3, sourceType: o2, extension: a2, success(t5) {
              const { tempFilePath: n4, duration: s3, size: i4, height: o3, width: a3 } = t5;
              e5(r2({ errMsg: "chooseVideo:ok", tempFilePaths: [n4], tempFiles: [{ name: t5.tempFile && t5.tempFile.name || "", path: n4, size: i4, type: t5.tempFile && t5.tempFile.type || "", width: a3, height: o3, duration: s3, fileType: "video", cloudPath: "" }] }, "video"));
            }, fail(e6) {
              c2({ errMsg: e6.errMsg.replace("chooseVideo:fail", s2) });
            } });
          });
        }(t3), t3) : i2(e3, function(e4) {
          const { count: t4, extension: n3 } = e4;
          return new Promise((e5, i3) => {
            let o2 = uni.chooseFile;
            if ("undefined" != typeof wx && "function" == typeof wx.chooseMessageFile && (o2 = wx.chooseMessageFile), "function" != typeof o2)
              return i3({ errMsg: s2 + " 请指定 type 类型，该平台仅支持选择 image 或 video。" });
            o2({ type: "all", count: t4, extension: n3, success(t5) {
              e5(r2(t5));
            }, fail(e6) {
              i3({ errMsg: e6.errMsg.replace("chooseFile:fail", s2) });
            } });
          });
        }(t3), t3);
      };
    };
  }), Ns = t$1(Us);
  const Ds = "manual";
  function Ms(e2) {
    return { props: { localdata: { type: Array, default: () => [] }, options: { type: [Object, Array], default: () => ({}) }, spaceInfo: { type: Object, default: () => ({}) }, collection: { type: [String, Array], default: "" }, action: { type: String, default: "" }, field: { type: String, default: "" }, orderby: { type: String, default: "" }, where: { type: [String, Object], default: "" }, pageData: { type: String, default: "add" }, pageCurrent: { type: Number, default: 1 }, pageSize: { type: Number, default: 20 }, getcount: { type: [Boolean, String], default: false }, gettree: { type: [Boolean, String], default: false }, gettreepath: { type: [Boolean, String], default: false }, startwith: { type: String, default: "" }, limitlevel: { type: Number, default: 10 }, groupby: { type: String, default: "" }, groupField: { type: String, default: "" }, distinct: { type: [Boolean, String], default: false }, foreignKey: { type: String, default: "" }, loadtime: { type: String, default: "auto" }, manual: { type: Boolean, default: false } }, data: () => ({ mixinDatacomLoading: false, mixinDatacomHasMore: false, mixinDatacomResData: [], mixinDatacomErrorMessage: "", mixinDatacomPage: {}, mixinDatacomError: null }), created() {
      this.mixinDatacomPage = { current: this.pageCurrent, size: this.pageSize, count: 0 }, this.$watch(() => {
        var e3 = [];
        return ["pageCurrent", "pageSize", "localdata", "collection", "action", "field", "orderby", "where", "getont", "getcount", "gettree", "groupby", "groupField", "distinct"].forEach((t2) => {
          e3.push(this[t2]);
        }), e3;
      }, (e3, t2) => {
        if (this.loadtime === Ds)
          return;
        let n2 = false;
        const s2 = [];
        for (let r2 = 2; r2 < e3.length; r2++)
          e3[r2] !== t2[r2] && (s2.push(e3[r2]), n2 = true);
        e3[0] !== t2[0] && (this.mixinDatacomPage.current = this.pageCurrent), this.mixinDatacomPage.size = this.pageSize, this.onMixinDatacomPropsChange(n2, s2);
      });
    }, methods: { onMixinDatacomPropsChange(e3, t2) {
    }, mixinDatacomEasyGet({ getone: e3 = false, success: t2, fail: n2 } = {}) {
      this.mixinDatacomLoading || (this.mixinDatacomLoading = true, this.mixinDatacomErrorMessage = "", this.mixinDatacomError = null, this.mixinDatacomGet().then((n3) => {
        this.mixinDatacomLoading = false;
        const { data: s2, count: r2 } = n3.result;
        this.getcount && (this.mixinDatacomPage.count = r2), this.mixinDatacomHasMore = s2.length < this.pageSize;
        const i2 = e3 ? s2.length ? s2[0] : void 0 : s2;
        this.mixinDatacomResData = i2, t2 && t2(i2);
      }).catch((e4) => {
        this.mixinDatacomLoading = false, this.mixinDatacomErrorMessage = e4, this.mixinDatacomError = e4, n2 && n2(e4);
      }));
    }, mixinDatacomGet(t2 = {}) {
      let n2;
      t2 = t2 || {}, n2 = "undefined" != typeof __uniX && __uniX ? e2.databaseForJQL(this.spaceInfo) : e2.database(this.spaceInfo);
      const s2 = t2.action || this.action;
      s2 && (n2 = n2.action(s2));
      const r2 = t2.collection || this.collection;
      n2 = Array.isArray(r2) ? n2.collection(...r2) : n2.collection(r2);
      const i2 = t2.where || this.where;
      i2 && Object.keys(i2).length && (n2 = n2.where(i2));
      const o2 = t2.field || this.field;
      o2 && (n2 = n2.field(o2));
      const a2 = t2.foreignKey || this.foreignKey;
      a2 && (n2 = n2.foreignKey(a2));
      const c2 = t2.groupby || this.groupby;
      c2 && (n2 = n2.groupBy(c2));
      const u2 = t2.groupField || this.groupField;
      u2 && (n2 = n2.groupField(u2));
      true === (void 0 !== t2.distinct ? t2.distinct : this.distinct) && (n2 = n2.distinct());
      const l2 = t2.orderby || this.orderby;
      l2 && (n2 = n2.orderBy(l2));
      const h2 = void 0 !== t2.pageCurrent ? t2.pageCurrent : this.mixinDatacomPage.current, d2 = void 0 !== t2.pageSize ? t2.pageSize : this.mixinDatacomPage.size, p2 = void 0 !== t2.getcount ? t2.getcount : this.getcount, f2 = void 0 !== t2.gettree ? t2.gettree : this.gettree, g2 = void 0 !== t2.gettreepath ? t2.gettreepath : this.gettreepath, m2 = { getCount: p2 }, y2 = { limitLevel: void 0 !== t2.limitlevel ? t2.limitlevel : this.limitlevel, startWith: void 0 !== t2.startwith ? t2.startwith : this.startwith };
      return f2 && (m2.getTree = y2), g2 && (m2.getTreePath = y2), n2 = n2.skip(d2 * (h2 - 1)).limit(d2).get(m2), n2;
    } } };
  }
  function qs(e2) {
    return function(t2, n2 = {}) {
      n2 = function(e3, t3 = {}) {
        return e3.customUI = t3.customUI || e3.customUI, e3.parseSystemError = t3.parseSystemError || e3.parseSystemError, Object.assign(e3.loadingOptions, t3.loadingOptions), Object.assign(e3.errorOptions, t3.errorOptions), "object" == typeof t3.secretMethods && (e3.secretMethods = t3.secretMethods), e3;
      }({ customUI: false, loadingOptions: { title: "加载中...", mask: true }, errorOptions: { type: "modal", retry: false } }, n2);
      const { customUI: s2, loadingOptions: r2, errorOptions: i2, parseSystemError: o2 } = n2, a2 = !s2;
      return new Proxy({}, { get(s3, c2) {
        switch (c2) {
          case "toString":
            return "[object UniCloudObject]";
          case "toJSON":
            return {};
        }
        return function({ fn: e3, interceptorName: t3, getCallbackArgs: n3 } = {}) {
          return async function(...s4) {
            const r3 = n3 ? n3({ params: s4 }) : {};
            let i3, o3;
            try {
              return await M(q(t3, "invoke"), { ...r3 }), i3 = await e3(...s4), await M(q(t3, "success"), { ...r3, result: i3 }), i3;
            } catch (e4) {
              throw o3 = e4, await M(q(t3, "fail"), { ...r3, error: o3 }), o3;
            } finally {
              await M(q(t3, "complete"), o3 ? { ...r3, error: o3 } : { ...r3, result: i3 });
            }
          };
        }({ fn: async function s4(...l2) {
          let h2;
          a2 && uni.showLoading({ title: r2.title, mask: r2.mask });
          const d2 = { name: t2, type: u, data: { method: c2, params: l2 } };
          "object" == typeof n2.secretMethods && function(e3, t3) {
            const n3 = t3.data.method, s5 = e3.secretMethods || {}, r3 = s5[n3] || s5["*"];
            r3 && (t3.secretType = r3);
          }(n2, d2);
          let p2 = false;
          try {
            h2 = await e2.callFunction(d2);
          } catch (e3) {
            p2 = true, h2 = { result: new te(e3) };
          }
          const { errSubject: f2, errCode: g2, errMsg: m2, newToken: y2 } = h2.result || {};
          if (a2 && uni.hideLoading(), y2 && y2.token && y2.tokenExpired && (ie(y2), Y(B, { ...y2 })), g2) {
            let e3 = m2;
            if (p2 && o2) {
              e3 = (await o2({ objectName: t2, methodName: c2, params: l2, errSubject: f2, errCode: g2, errMsg: m2 })).errMsg || m2;
            }
            if (a2)
              if ("toast" === i2.type)
                uni.showToast({ title: e3, icon: "none" });
              else {
                if ("modal" !== i2.type)
                  throw new Error(`Invalid errorOptions.type: ${i2.type}`);
                {
                  const { confirm: t3 } = await async function({ title: e4, content: t4, showCancel: n4, cancelText: s5, confirmText: r3 } = {}) {
                    return new Promise((i3, o3) => {
                      uni.showModal({ title: e4, content: t4, showCancel: n4, cancelText: s5, confirmText: r3, success(e5) {
                        i3(e5);
                      }, fail() {
                        i3({ confirm: false, cancel: true });
                      } });
                    });
                  }({ title: "提示", content: e3, showCancel: i2.retry, cancelText: "取消", confirmText: i2.retry ? "重试" : "确定" });
                  if (i2.retry && t3)
                    return s4(...l2);
                }
              }
            const n3 = new te({ subject: f2, code: g2, message: m2, requestId: h2.requestId });
            throw n3.detail = h2.result, Y(j, { type: J, content: n3 }), n3;
          }
          return Y(j, { type: J, content: h2.result }), h2.result;
        }, interceptorName: "callObject", getCallbackArgs: function({ params: e3 } = {}) {
          return { objectName: t2, methodName: c2, params: e3 };
        } });
      } });
    };
  }
  function Fs(e2) {
    return L("_globalUniCloudSecureNetworkCache__{spaceId}".replace("{spaceId}", e2.config.spaceId));
  }
  async function Ks({ openid: e2, callLoginByWeixin: t2 = false } = {}) {
    Fs(this);
    throw new Error(`[SecureNetwork] API \`initSecureNetworkByWeixin\` is not supported on platform \`${C}\``);
  }
  async function js(e2) {
    const t2 = Fs(this);
    return t2.initPromise || (t2.initPromise = Ks.call(this, e2).then((e3) => e3).catch((e3) => {
      throw delete t2.initPromise, e3;
    })), t2.initPromise;
  }
  function $s(e2) {
    return function({ openid: t2, callLoginByWeixin: n2 = false } = {}) {
      return js.call(e2, { openid: t2, callLoginByWeixin: n2 });
    };
  }
  function Bs(e2) {
    !function(e3) {
      le = e3;
    }(e2);
  }
  function Ws(e2) {
    const t2 = { getSystemInfo: uni.getSystemInfo, getPushClientId: uni.getPushClientId };
    return function(n2) {
      return new Promise((s2, r2) => {
        t2[e2]({ ...n2, success(e3) {
          s2(e3);
        }, fail(e3) {
          r2(e3);
        } });
      });
    };
  }
  class Hs extends class {
    constructor() {
      this._callback = {};
    }
    addListener(e2, t2) {
      this._callback[e2] || (this._callback[e2] = []), this._callback[e2].push(t2);
    }
    on(e2, t2) {
      return this.addListener(e2, t2);
    }
    removeListener(e2, t2) {
      if (!t2)
        throw new Error('The "listener" argument must be of type function. Received undefined');
      const n2 = this._callback[e2];
      if (!n2)
        return;
      const s2 = function(e3, t3) {
        for (let n3 = e3.length - 1; n3 >= 0; n3--)
          if (e3[n3] === t3)
            return n3;
        return -1;
      }(n2, t2);
      n2.splice(s2, 1);
    }
    off(e2, t2) {
      return this.removeListener(e2, t2);
    }
    removeAllListener(e2) {
      delete this._callback[e2];
    }
    emit(e2, ...t2) {
      const n2 = this._callback[e2];
      if (n2)
        for (let e3 = 0; e3 < n2.length; e3++)
          n2[e3](...t2);
    }
  } {
    constructor() {
      super(), this._uniPushMessageCallback = this._receivePushMessage.bind(this), this._currentMessageId = -1, this._payloadQueue = [];
    }
    init() {
      return Promise.all([Ws("getSystemInfo")(), Ws("getPushClientId")()]).then(([{ appId: e2 } = {}, { cid: t2 } = {}] = []) => {
        if (!e2)
          throw new Error("Invalid appId, please check the manifest.json file");
        if (!t2)
          throw new Error("Invalid push client id");
        this._appId = e2, this._pushClientId = t2, this._seqId = Date.now() + "-" + Math.floor(9e5 * Math.random() + 1e5), this.emit("open"), this._initMessageListener();
      }, (e2) => {
        throw this.emit("error", e2), this.close(), e2;
      });
    }
    async open() {
      return this.init();
    }
    _isUniCloudSSE(e2) {
      if ("receive" !== e2.type)
        return false;
      const t2 = e2 && e2.data && e2.data.payload;
      return !(!t2 || "UNI_CLOUD_SSE" !== t2.channel || t2.seqId !== this._seqId);
    }
    _receivePushMessage(e2) {
      if (!this._isUniCloudSSE(e2))
        return;
      const t2 = e2 && e2.data && e2.data.payload, { action: n2, messageId: s2, message: r2 } = t2;
      this._payloadQueue.push({ action: n2, messageId: s2, message: r2 }), this._consumMessage();
    }
    _consumMessage() {
      for (; ; ) {
        const e2 = this._payloadQueue.find((e3) => e3.messageId === this._currentMessageId + 1);
        if (!e2)
          break;
        this._currentMessageId++, this._parseMessagePayload(e2);
      }
    }
    _parseMessagePayload(e2) {
      const { action: t2, messageId: n2, message: s2 } = e2;
      "end" === t2 ? this._end({ messageId: n2, message: s2 }) : "message" === t2 && this._appendMessage({ messageId: n2, message: s2 });
    }
    _appendMessage({ messageId: e2, message: t2 } = {}) {
      this.emit("message", t2);
    }
    _end({ messageId: e2, message: t2 } = {}) {
      this.emit("end", t2), this.close();
    }
    _initMessageListener() {
      uni.onPushMessage(this._uniPushMessageCallback);
    }
    _destroy() {
      uni.offPushMessage(this._uniPushMessageCallback);
    }
    toJSON() {
      return { appId: this._appId, pushClientId: this._pushClientId, seqId: this._seqId };
    }
    close() {
      this._destroy(), this.emit("close");
    }
  }
  async function Js(e2) {
    {
      const { osName: e3, osVersion: t3 } = ce();
      "ios" === e3 && function(e4) {
        if (!e4 || "string" != typeof e4)
          return 0;
        const t4 = e4.match(/^(\d+)./);
        return t4 && t4[1] ? parseInt(t4[1]) : 0;
      }(t3) >= 14 && console.warn("iOS 14及以上版本连接uniCloud本地调试服务需要允许客户端查找并连接到本地网络上的设备（仅开发期间需要，发行后不需要）");
    }
    const t2 = e2.__dev__;
    if (!t2.debugInfo)
      return;
    const { address: n2, servePort: s2 } = t2.debugInfo, { address: r2 } = await At(n2, s2);
    if (r2)
      return t2.localAddress = r2, void (t2.localPort = s2);
    const i2 = console["error"];
    let o2 = "";
    if ("remote" === t2.debugInfo.initialLaunchType ? (t2.debugInfo.forceRemote = true, o2 = "当前客户端和HBuilderX不在同一局域网下（或其他网络原因无法连接HBuilderX），uniCloud本地调试服务不对当前客户端生效。\n- 如果不使用uniCloud本地调试服务，请直接忽略此信息。\n- 如需使用uniCloud本地调试服务，请将客户端与主机连接到同一局域网下并重新运行到客户端。") : o2 = "无法连接uniCloud本地调试服务，请检查当前客户端是否与主机在同一局域网下。\n- 如需使用uniCloud本地调试服务，请将客户端与主机连接到同一局域网下并重新运行到客户端。", o2 += "\n- 如果在HBuilderX开启的状态下切换过网络环境，请重启HBuilderX后再试\n- 检查系统防火墙是否拦截了HBuilderX自带的nodejs\n- 检查是否错误的使用拦截器修改uni.request方法的参数", 0 === C.indexOf("mp-") && (o2 += "\n- 小程序中如何使用uniCloud，请参考：https://uniapp.dcloud.net.cn/uniCloud/publish.html#useinmp"), !t2.debugInfo.forceRemote)
      throw new Error(o2);
    i2(o2);
  }
  function zs(e2) {
    e2._initPromiseHub || (e2._initPromiseHub = new v({ createPromise: function() {
      let t2 = Promise.resolve();
      var n2;
      n2 = 1, t2 = new Promise((e3) => {
        setTimeout(() => {
          e3();
        }, n2);
      });
      const s2 = e2.auth();
      return t2.then(() => s2.getLoginState()).then((e3) => e3 ? Promise.resolve() : s2.signInAnonymously());
    } }));
  }
  const Vs = { tcb: bt, tencent: bt, aliyun: fe, private: Tt, dcloud: Tt, alipay: qt };
  let Gs = new class {
    init(e2) {
      let t2 = {};
      const n2 = Vs[e2.provider];
      if (!n2)
        throw new Error("未提供正确的provider参数");
      t2 = n2.init(e2), function(e3) {
        const t3 = {};
        e3.__dev__ = t3, t3.debugLog = "app" === C;
        const n3 = P;
        n3 && !n3.code && (t3.debugInfo = n3);
        const s2 = new v({ createPromise: function() {
          return Js(e3);
        } });
        t3.initLocalNetwork = function() {
          return s2.exec();
        };
      }(t2), zs(t2), Jn(t2), function(e3) {
        const t3 = e3.uploadFile;
        e3.uploadFile = function(e4) {
          return t3.call(this, e4);
        };
      }(t2), function(e3) {
        e3.database = function(t3) {
          if (t3 && Object.keys(t3).length > 0)
            return e3.init(t3).database();
          if (this._database)
            return this._database;
          const n3 = ss(rs, { uniClient: e3 });
          return this._database = n3, n3;
        }, e3.databaseForJQL = function(t3) {
          if (t3 && Object.keys(t3).length > 0)
            return e3.init(t3).databaseForJQL();
          if (this._databaseForJQL)
            return this._databaseForJQL;
          const n3 = ss(rs, { uniClient: e3, isJQL: true });
          return this._databaseForJQL = n3, n3;
        };
      }(t2), function(e3) {
        e3.getCurrentUserInfo = Rs, e3.chooseAndUploadFile = Ns.initChooseAndUploadFile(e3), Object.assign(e3, { get mixinDatacom() {
          return Ms(e3);
        } }), e3.SSEChannel = Hs, e3.initSecureNetworkByWeixin = $s(e3), e3.setCustomClientInfo = Bs, e3.importObject = qs(e3);
      }(t2);
      return ["callFunction", "uploadFile", "deleteFile", "getTempFileURL", "downloadFile", "chooseAndUploadFile"].forEach((e3) => {
        if (!t2[e3])
          return;
        const n3 = t2[e3];
        t2[e3] = function() {
          return n3.apply(t2, Array.from(arguments));
        }, t2[e3] = (/* @__PURE__ */ function(e4, t3) {
          return function(n4) {
            let s2 = false;
            if ("callFunction" === t3) {
              const e5 = n4 && n4.type || c;
              s2 = e5 !== c;
            }
            const r2 = "callFunction" === t3 && !s2, i2 = this._initPromiseHub.exec();
            n4 = n4 || {};
            const { success: o2, fail: a2, complete: u2 } = ee(n4), l2 = i2.then(() => s2 ? Promise.resolve() : M(q(t3, "invoke"), n4)).then(() => e4.call(this, n4)).then((e5) => s2 ? Promise.resolve(e5) : M(q(t3, "success"), e5).then(() => M(q(t3, "complete"), e5)).then(() => (r2 && Y(j, { type: H, content: e5 }), Promise.resolve(e5))), (e5) => s2 ? Promise.reject(e5) : M(q(t3, "fail"), e5).then(() => M(q(t3, "complete"), e5)).then(() => (Y(j, { type: H, content: e5 }), Promise.reject(e5))));
            if (!(o2 || a2 || u2))
              return l2;
            l2.then((e5) => {
              o2 && o2(e5), u2 && u2(e5), r2 && Y(j, { type: H, content: e5 });
            }, (e5) => {
              a2 && a2(e5), u2 && u2(e5), r2 && Y(j, { type: H, content: e5 });
            });
          };
        }(t2[e3], e3)).bind(t2);
      }), t2.init = this.init, t2;
    }
  }();
  (() => {
    const e2 = T;
    let t2 = {};
    if (e2 && 1 === e2.length)
      t2 = e2[0], Gs = Gs.init(t2), Gs._isDefault = true;
    else {
      const t3 = ["auth", "callFunction", "uploadFile", "deleteFile", "getTempFileURL", "downloadFile", "database", "getCurrentUSerInfo", "importObject"];
      let n2;
      n2 = e2 && e2.length > 0 ? "应用有多个服务空间，请通过uniCloud.init方法指定要使用的服务空间" : "应用未关联服务空间，请在uniCloud目录右键关联服务空间", t3.forEach((e3) => {
        Gs[e3] = function() {
          return console.error(n2), Promise.reject(new te({ code: "SYS_ERR", message: n2 }));
        };
      });
    }
    Object.assign(Gs, { get mixinDatacom() {
      return Ms(Gs);
    } }), xs(Gs), Gs.addInterceptor = N, Gs.removeInterceptor = D, Gs.interceptObject = F;
  })();
  var Ys = Gs;
  const dataPicker = {
    props: {
      localdata: {
        type: [Array, Object],
        default() {
          return [];
        }
      },
      spaceInfo: {
        type: Object,
        default() {
          return {};
        }
      },
      collection: {
        type: String,
        default: ""
      },
      action: {
        type: String,
        default: ""
      },
      field: {
        type: String,
        default: ""
      },
      orderby: {
        type: String,
        default: ""
      },
      where: {
        type: [String, Object],
        default: ""
      },
      pageData: {
        type: String,
        default: "add"
      },
      pageCurrent: {
        type: Number,
        default: 1
      },
      pageSize: {
        type: Number,
        default: 500
      },
      getcount: {
        type: [Boolean, String],
        default: false
      },
      getone: {
        type: [Boolean, String],
        default: false
      },
      gettree: {
        type: [Boolean, String],
        default: false
      },
      manual: {
        type: Boolean,
        default: false
      },
      value: {
        type: [Array, String, Number],
        default() {
          return [];
        }
      },
      modelValue: {
        type: [Array, String, Number],
        default() {
          return [];
        }
      },
      preload: {
        type: Boolean,
        default: false
      },
      stepSearh: {
        type: Boolean,
        default: true
      },
      selfField: {
        type: String,
        default: ""
      },
      parentField: {
        type: String,
        default: ""
      },
      multiple: {
        type: Boolean,
        default: false
      },
      map: {
        type: Object,
        default() {
          return {
            text: "text",
            value: "value"
          };
        }
      }
    },
    data() {
      return {
        loading: false,
        errorMessage: "",
        loadMore: {
          contentdown: "",
          contentrefresh: "",
          contentnomore: ""
        },
        dataList: [],
        selected: [],
        selectedIndex: 0,
        page: {
          current: this.pageCurrent,
          size: this.pageSize,
          count: 0
        }
      };
    },
    computed: {
      isLocalData() {
        return !this.collection.length;
      },
      isCloudData() {
        return this.collection.length > 0;
      },
      isCloudDataList() {
        return this.isCloudData && (!this.parentField && !this.selfField);
      },
      isCloudDataTree() {
        return this.isCloudData && this.parentField && this.selfField;
      },
      dataValue() {
        let isModelValue = Array.isArray(this.modelValue) ? this.modelValue.length > 0 : this.modelValue !== null || this.modelValue !== void 0;
        return isModelValue ? this.modelValue : this.value;
      },
      hasValue() {
        if (typeof this.dataValue === "number") {
          return true;
        }
        return this.dataValue != null && this.dataValue.length > 0;
      }
    },
    created() {
      this.$watch(() => {
        var al = [];
        [
          "pageCurrent",
          "pageSize",
          "spaceInfo",
          "value",
          "modelValue",
          "localdata",
          "collection",
          "action",
          "field",
          "orderby",
          "where",
          "getont",
          "getcount",
          "gettree"
        ].forEach((key) => {
          al.push(this[key]);
        });
        return al;
      }, (newValue, oldValue) => {
        for (let i2 = 2; i2 < newValue.length; i2++) {
          if (newValue[i2] != oldValue[i2]) {
            break;
          }
        }
        if (newValue[0] != oldValue[0]) {
          this.page.current = this.pageCurrent;
        }
        this.page.size = this.pageSize;
        this.onPropsChange();
      });
      this._treeData = [];
    },
    methods: {
      onPropsChange() {
        this._treeData = [];
      },
      // 填充 pickview 数据
      async loadData() {
        if (this.isLocalData) {
          this.loadLocalData();
        } else if (this.isCloudDataList) {
          this.loadCloudDataList();
        } else if (this.isCloudDataTree) {
          this.loadCloudDataTree();
        }
      },
      // 加载本地数据
      async loadLocalData() {
        this._treeData = [];
        this._extractTree(this.localdata, this._treeData);
        let inputValue = this.dataValue;
        if (inputValue === void 0) {
          return;
        }
        if (Array.isArray(inputValue)) {
          inputValue = inputValue[inputValue.length - 1];
          if (typeof inputValue === "object" && inputValue[this.map.value]) {
            inputValue = inputValue[this.map.value];
          }
        }
        this.selected = this._findNodePath(inputValue, this.localdata);
      },
      // 加载 Cloud 数据 (单列)
      async loadCloudDataList() {
        if (this.loading) {
          return;
        }
        this.loading = true;
        try {
          let response = await this.getCommand();
          let responseData = response.result.data;
          this._treeData = responseData;
          this._updateBindData();
          this._updateSelected();
          this.onDataChange();
        } catch (e2) {
          this.errorMessage = e2;
        } finally {
          this.loading = false;
        }
      },
      // 加载 Cloud 数据 (树形)
      async loadCloudDataTree() {
        if (this.loading) {
          return;
        }
        this.loading = true;
        try {
          let commandOptions = {
            field: this._cloudDataPostField(),
            where: this._cloudDataTreeWhere()
          };
          if (this.gettree) {
            commandOptions.startwith = `${this.selfField}=='${this.dataValue}'`;
          }
          let response = await this.getCommand(commandOptions);
          let responseData = response.result.data;
          this._treeData = responseData;
          this._updateBindData();
          this._updateSelected();
          this.onDataChange();
        } catch (e2) {
          this.errorMessage = e2;
        } finally {
          this.loading = false;
        }
      },
      // 加载 Cloud 数据 (节点)
      async loadCloudDataNode(callback) {
        if (this.loading) {
          return;
        }
        this.loading = true;
        try {
          let commandOptions = {
            field: this._cloudDataPostField(),
            where: this._cloudDataNodeWhere()
          };
          let response = await this.getCommand(commandOptions);
          let responseData = response.result.data;
          callback(responseData);
        } catch (e2) {
          this.errorMessage = e2;
        } finally {
          this.loading = false;
        }
      },
      // 回显 Cloud 数据
      getCloudDataValue() {
        if (this.isCloudDataList) {
          return this.getCloudDataListValue();
        }
        if (this.isCloudDataTree) {
          return this.getCloudDataTreeValue();
        }
      },
      // 回显 Cloud 数据 (单列)
      getCloudDataListValue() {
        let where = [];
        let whereField = this._getForeignKeyByField();
        if (whereField) {
          where.push(`${whereField} == '${this.dataValue}'`);
        }
        where = where.join(" || ");
        if (this.where) {
          where = `(${this.where}) && (${where})`;
        }
        return this.getCommand({
          field: this._cloudDataPostField(),
          where
        }).then((res) => {
          this.selected = res.result.data;
          return res.result.data;
        });
      },
      // 回显 Cloud 数据 (树形)
      getCloudDataTreeValue() {
        return this.getCommand({
          field: this._cloudDataPostField(),
          getTreePath: {
            startWith: `${this.selfField}=='${this.dataValue}'`
          }
        }).then((res) => {
          let treePath = [];
          this._extractTreePath(res.result.data, treePath);
          this.selected = treePath;
          return treePath;
        });
      },
      getCommand(options = {}) {
        let db = Ys.database(this.spaceInfo);
        const action = options.action || this.action;
        if (action) {
          db = db.action(action);
        }
        const collection = options.collection || this.collection;
        db = db.collection(collection);
        const where = options.where || this.where;
        if (!(!where || !Object.keys(where).length)) {
          db = db.where(where);
        }
        const field = options.field || this.field;
        if (field) {
          db = db.field(field);
        }
        const orderby = options.orderby || this.orderby;
        if (orderby) {
          db = db.orderBy(orderby);
        }
        const current = options.pageCurrent !== void 0 ? options.pageCurrent : this.page.current;
        const size = options.pageSize !== void 0 ? options.pageSize : this.page.size;
        const getCount = options.getcount !== void 0 ? options.getcount : this.getcount;
        const getTree = options.gettree !== void 0 ? options.gettree : this.gettree;
        const getOptions = {
          getCount,
          getTree
        };
        if (options.getTreePath) {
          getOptions.getTreePath = options.getTreePath;
        }
        db = db.skip(size * (current - 1)).limit(size).get(getOptions);
        return db;
      },
      _cloudDataPostField() {
        let fields = [this.field];
        if (this.parentField) {
          fields.push(`${this.parentField} as parent_value`);
        }
        return fields.join(",");
      },
      _cloudDataTreeWhere() {
        let result = [];
        let selected = this.selected;
        let parentField = this.parentField;
        if (parentField) {
          result.push(`${parentField} == null || ${parentField} == ""`);
        }
        if (selected.length) {
          for (var i2 = 0; i2 < selected.length - 1; i2++) {
            result.push(`${parentField} == '${selected[i2].value}'`);
          }
        }
        let where = [];
        if (this.where) {
          where.push(`(${this.where})`);
        }
        if (result.length) {
          where.push(`(${result.join(" || ")})`);
        }
        return where.join(" && ");
      },
      _cloudDataNodeWhere() {
        let where = [];
        let selected = this.selected;
        if (selected.length) {
          where.push(`${this.parentField} == '${selected[selected.length - 1].value}'`);
        }
        where = where.join(" || ");
        if (this.where) {
          return `(${this.where}) && (${where})`;
        }
        return where;
      },
      _getWhereByForeignKey() {
        let result = [];
        let whereField = this._getForeignKeyByField();
        if (whereField) {
          result.push(`${whereField} == '${this.dataValue}'`);
        }
        if (this.where) {
          return `(${this.where}) && (${result.join(" || ")})`;
        }
        return result.join(" || ");
      },
      _getForeignKeyByField() {
        let fields = this.field.split(",");
        let whereField = null;
        for (let i2 = 0; i2 < fields.length; i2++) {
          const items = fields[i2].split("as");
          if (items.length < 2) {
            continue;
          }
          if (items[1].trim() === "value") {
            whereField = items[0].trim();
            break;
          }
        }
        return whereField;
      },
      _updateBindData(node) {
        const {
          dataList,
          hasNodes
        } = this._filterData(this._treeData, this.selected);
        let isleaf = this._stepSearh === false && !hasNodes;
        if (node) {
          node.isleaf = isleaf;
        }
        this.dataList = dataList;
        this.selectedIndex = dataList.length - 1;
        if (!isleaf && this.selected.length < dataList.length) {
          this.selected.push({
            value: null,
            text: "请选择"
          });
        }
        return {
          isleaf,
          hasNodes
        };
      },
      _updateSelected() {
        let dl = this.dataList;
        let sl = this.selected;
        let textField = this.map.text;
        let valueField = this.map.value;
        for (let i2 = 0; i2 < sl.length; i2++) {
          let value = sl[i2].value;
          let dl2 = dl[i2];
          for (let j2 = 0; j2 < dl2.length; j2++) {
            let item2 = dl2[j2];
            if (item2[valueField] === value) {
              sl[i2].text = item2[textField];
              break;
            }
          }
        }
      },
      _filterData(data, paths) {
        let dataList = [];
        let hasNodes = true;
        dataList.push(data.filter((item) => {
          return item.parent_value === null || item.parent_value === void 0 || item.parent_value === "";
        }));
        for (let i2 = 0; i2 < paths.length; i2++) {
          let value = paths[i2].value;
          let nodes = data.filter((item) => {
            return item.parent_value === value;
          });
          if (nodes.length) {
            dataList.push(nodes);
          } else {
            hasNodes = false;
          }
        }
        return {
          dataList,
          hasNodes
        };
      },
      _extractTree(nodes, result, parent_value) {
        let valueField = this.map.value;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          let node = nodes[i2];
          let child = {};
          for (let key in node) {
            if (key !== "children") {
              child[key] = node[key];
            }
          }
          if (parent_value !== null && parent_value !== void 0 && parent_value !== "") {
            child.parent_value = parent_value;
          }
          result.push(child);
          let children = node.children;
          if (children) {
            this._extractTree(children, result, node[valueField]);
          }
        }
      },
      _extractTreePath(nodes, result) {
        for (let i2 = 0; i2 < nodes.length; i2++) {
          let node = nodes[i2];
          let child = {};
          for (let key in node) {
            if (key !== "children") {
              child[key] = node[key];
            }
          }
          result.push(child);
          let children = node.children;
          if (children) {
            this._extractTreePath(children, result);
          }
        }
      },
      _findNodePath(key, nodes, path = []) {
        let textField = this.map.text;
        let valueField = this.map.value;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          let node = nodes[i2];
          let children = node.children;
          let text = node[textField];
          let value = node[valueField];
          path.push({
            value,
            text
          });
          if (value === key) {
            return path;
          }
          if (children) {
            const p2 = this._findNodePath(key, children, path);
            if (p2.length) {
              return p2;
            }
          }
          path.pop();
        }
        return [];
      }
    }
  };
  const _sfc_main$16 = {
    name: "UniDataPickerView",
    emits: ["nodeclick", "change", "datachange", "update:modelValue"],
    mixins: [dataPicker],
    props: {
      managedMode: {
        type: Boolean,
        default: false
      },
      ellipsis: {
        type: Boolean,
        default: true
      }
    },
    created() {
      if (!this.managedMode) {
        this.$nextTick(() => {
          this.loadData();
        });
      }
    },
    methods: {
      onPropsChange() {
        this._treeData = [];
        this.selectedIndex = 0;
        this.$nextTick(() => {
          this.loadData();
        });
      },
      handleSelect(index) {
        this.selectedIndex = index;
      },
      handleNodeClick(item, i2, j2) {
        if (item.disable) {
          return;
        }
        const node = this.dataList[i2][j2];
        const text = node[this.map.text];
        const value = node[this.map.value];
        if (i2 < this.selected.length - 1) {
          this.selected.splice(i2, this.selected.length - i2);
          this.selected.push({
            text,
            value
          });
        } else if (i2 === this.selected.length - 1) {
          this.selected.splice(i2, 1, {
            text,
            value
          });
        }
        if (node.isleaf) {
          this.onSelectedChange(node, node.isleaf);
          return;
        }
        const {
          isleaf,
          hasNodes
        } = this._updateBindData();
        if (this.isLocalData) {
          this.onSelectedChange(node, !hasNodes || isleaf);
        } else if (this.isCloudDataList) {
          this.onSelectedChange(node, true);
        } else if (this.isCloudDataTree) {
          if (isleaf) {
            this.onSelectedChange(node, node.isleaf);
          } else if (!hasNodes) {
            this.loadCloudDataNode((data) => {
              if (!data.length) {
                node.isleaf = true;
              } else {
                this._treeData.push(...data);
                this._updateBindData(node);
              }
              this.onSelectedChange(node, node.isleaf);
            });
          }
        }
      },
      updateData(data) {
        this._treeData = data.treeData;
        this.selected = data.selected;
        if (!this._treeData.length) {
          this.loadData();
        } else {
          this._updateBindData();
        }
      },
      onDataChange() {
        this.$emit("datachange");
      },
      onSelectedChange(node, isleaf) {
        if (isleaf) {
          this._dispatchEvent();
        }
        if (node) {
          this.$emit("nodeclick", node);
        }
      },
      _dispatchEvent() {
        this.$emit("change", this.selected.slice(0));
      }
    }
  };
  function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_load_more = resolveEasycom(vue.resolveDynamicComponent("uni-load-more"), __easycom_0$6);
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-data-pickerview" }, [
      !_ctx.isCloudDataList ? (vue.openBlock(), vue.createElementBlock("scroll-view", {
        key: 0,
        class: "selected-area",
        "scroll-x": "true"
      }, [
        vue.createElementVNode("view", { class: "selected-list" }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.selected, (item, index) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: vue.normalizeClass(["selected-item", {
                  "selected-item-active": index == _ctx.selectedIndex
                }]),
                key: index,
                onClick: ($event) => $options.handleSelect(index)
              }, [
                vue.createElementVNode(
                  "text",
                  null,
                  vue.toDisplayString(item.text || ""),
                  1
                  /* TEXT */
                )
              ], 10, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("view", { class: "tab-c" }, [
        vue.createElementVNode("scroll-view", {
          class: "list",
          "scroll-y": true
        }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.dataList[_ctx.selectedIndex], (item, j2) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: vue.normalizeClass(["item", { "is-disabled": !!item.disable }]),
                key: j2,
                onClick: ($event) => $options.handleNodeClick(item, _ctx.selectedIndex, j2)
              }, [
                vue.createElementVNode(
                  "text",
                  { class: "item-text" },
                  vue.toDisplayString(item[_ctx.map.text]),
                  1
                  /* TEXT */
                ),
                _ctx.selected.length > _ctx.selectedIndex && item[_ctx.map.value] == _ctx.selected[_ctx.selectedIndex].value ? (vue.openBlock(), vue.createElementBlock("view", {
                  key: 0,
                  class: "check"
                })) : vue.createCommentVNode("v-if", true)
              ], 10, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        _ctx.loading ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "loading-cover"
        }, [
          vue.createVNode(_component_uni_load_more, {
            class: "load-more",
            contentText: _ctx.loadMore,
            status: "loading"
          }, null, 8, ["contentText"])
        ])) : vue.createCommentVNode("v-if", true),
        _ctx.errorMessage ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 1,
          class: "error-message"
        }, [
          vue.createElementVNode(
            "text",
            { class: "error-text" },
            vue.toDisplayString(_ctx.errorMessage),
            1
            /* TEXT */
          )
        ])) : vue.createCommentVNode("v-if", true)
      ])
    ]);
  }
  const DataPickerView = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$15], ["__scopeId", "data-v-91ec6a82"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-data-picker/components/uni-data-pickerview/uni-data-pickerview.vue"]]);
  const _sfc_main$15 = {
    name: "UniDataPicker",
    emits: ["popupopened", "popupclosed", "nodeclick", "input", "change", "update:modelValue", "inputclick"],
    mixins: [dataPicker],
    components: {
      DataPickerView
    },
    props: {
      options: {
        type: [Object, Array],
        default() {
          return {};
        }
      },
      popupTitle: {
        type: String,
        default: "请选择"
      },
      placeholder: {
        type: String,
        default: "请选择"
      },
      heightMobile: {
        type: String,
        default: ""
      },
      readonly: {
        type: Boolean,
        default: false
      },
      clearIcon: {
        type: Boolean,
        default: true
      },
      border: {
        type: Boolean,
        default: true
      },
      split: {
        type: String,
        default: "/"
      },
      ellipsis: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        isOpened: false,
        inputSelected: []
      };
    },
    created() {
      this.$nextTick(() => {
        this.load();
      });
    },
    watch: {
      localdata: {
        handler() {
          this.load();
        },
        deep: true
      }
    },
    methods: {
      clear() {
        this._dispatchEvent([]);
      },
      onPropsChange() {
        this._treeData = [];
        this.selectedIndex = 0;
        this.load();
      },
      load() {
        if (this.readonly) {
          this._processReadonly(this.localdata, this.dataValue);
          return;
        }
        if (this.isLocalData) {
          this.loadData();
          this.inputSelected = this.selected.slice(0);
        } else if (this.isCloudDataList || this.isCloudDataTree) {
          this.loading = true;
          this.getCloudDataValue().then((res) => {
            this.loading = false;
            this.inputSelected = res;
          }).catch((err) => {
            this.loading = false;
            this.errorMessage = err;
          });
        }
      },
      show() {
        this.isOpened = true;
        setTimeout(() => {
          this.$refs.pickerView.updateData({
            treeData: this._treeData,
            selected: this.selected,
            selectedIndex: this.selectedIndex
          });
        }, 200);
        this.$emit("popupopened");
      },
      hide() {
        this.isOpened = false;
        this.$emit("popupclosed");
      },
      handleInput() {
        if (this.readonly) {
          this.$emit("inputclick");
          return;
        }
        this.show();
      },
      handleClose(e2) {
        this.hide();
      },
      onnodeclick(e2) {
        this.$emit("nodeclick", e2);
      },
      ondatachange(e2) {
        this._treeData = this.$refs.pickerView._treeData;
      },
      onchange(e2) {
        this.hide();
        this.$nextTick(() => {
          this.inputSelected = e2;
        });
        this._dispatchEvent(e2);
      },
      _processReadonly(dataList, value) {
        var isTree = dataList.findIndex((item2) => {
          return item2.children;
        });
        if (isTree > -1) {
          let inputValue;
          if (Array.isArray(value)) {
            inputValue = value[value.length - 1];
            if (typeof inputValue === "object" && inputValue.value) {
              inputValue = inputValue.value;
            }
          } else {
            inputValue = value;
          }
          this.inputSelected = this._findNodePath(inputValue, this.localdata);
          return;
        }
        if (!this.hasValue) {
          this.inputSelected = [];
          return;
        }
        let result = [];
        for (let i2 = 0; i2 < value.length; i2++) {
          var val = value[i2];
          var item = dataList.find((v2) => {
            return v2.value == val;
          });
          if (item) {
            result.push(item);
          }
        }
        if (result.length) {
          this.inputSelected = result;
        }
      },
      _filterForArray(data, valueArray) {
        var result = [];
        for (let i2 = 0; i2 < valueArray.length; i2++) {
          var value = valueArray[i2];
          var found = data.find((item) => {
            return item.value == value;
          });
          if (found) {
            result.push(found);
          }
        }
        return result;
      },
      _dispatchEvent(selected) {
        let item = {};
        if (selected.length) {
          var value = new Array(selected.length);
          for (var i2 = 0; i2 < selected.length; i2++) {
            value[i2] = selected[i2].value;
          }
          item = selected[selected.length - 1];
        } else {
          item.value = "";
        }
        if (this.formItem) {
          this.formItem.setValue(item.value);
        }
        this.$emit("input", item.value);
        this.$emit("update:modelValue", item.value);
        this.$emit("change", {
          detail: {
            value: selected
          }
        });
      }
    }
  };
  function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_load_more = resolveEasycom(vue.resolveDynamicComponent("uni-load-more"), __easycom_0$6);
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    const _component_data_picker_view = vue.resolveComponent("data-picker-view");
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-data-tree" }, [
      vue.createElementVNode("view", {
        class: "uni-data-tree-input",
        onClick: _cache[1] || (_cache[1] = (...args) => $options.handleInput && $options.handleInput(...args))
      }, [
        vue.renderSlot(_ctx.$slots, "default", {
          options: $props.options,
          data: $data.inputSelected,
          error: _ctx.errorMessage
        }, () => [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["input-value", { "input-value-border": $props.border }])
            },
            [
              _ctx.errorMessage ? (vue.openBlock(), vue.createElementBlock(
                "text",
                {
                  key: 0,
                  class: "selected-area error-text"
                },
                vue.toDisplayString(_ctx.errorMessage),
                1
                /* TEXT */
              )) : _ctx.loading && !$data.isOpened ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 1,
                class: "selected-area"
              }, [
                vue.createVNode(_component_uni_load_more, {
                  class: "load-more",
                  contentText: _ctx.loadMore,
                  status: "loading"
                }, null, 8, ["contentText"])
              ])) : $data.inputSelected.length ? (vue.openBlock(), vue.createElementBlock("scroll-view", {
                key: 2,
                class: "selected-area",
                "scroll-x": "true"
              }, [
                vue.createElementVNode("view", { class: "selected-list" }, [
                  (vue.openBlock(true), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList($data.inputSelected, (item, index) => {
                      return vue.openBlock(), vue.createElementBlock("view", {
                        class: "selected-item",
                        key: index
                      }, [
                        vue.createElementVNode(
                          "text",
                          { class: "text-color" },
                          vue.toDisplayString(item.text),
                          1
                          /* TEXT */
                        ),
                        index < $data.inputSelected.length - 1 ? (vue.openBlock(), vue.createElementBlock(
                          "text",
                          {
                            key: 0,
                            class: "input-split-line"
                          },
                          vue.toDisplayString($props.split),
                          1
                          /* TEXT */
                        )) : vue.createCommentVNode("v-if", true)
                      ]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ])
              ])) : (vue.openBlock(), vue.createElementBlock(
                "text",
                {
                  key: 3,
                  class: "selected-area placeholder"
                },
                vue.toDisplayString($props.placeholder),
                1
                /* TEXT */
              )),
              $props.clearIcon && !$props.readonly && $data.inputSelected.length ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 4,
                class: "icon-clear",
                onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $options.clear && $options.clear(...args), ["stop"]))
              }, [
                vue.createVNode(_component_uni_icons, {
                  type: "clear",
                  color: "#c0c4cc",
                  size: "24"
                })
              ])) : vue.createCommentVNode("v-if", true),
              (!$props.clearIcon || !$data.inputSelected.length) && !$props.readonly ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 5,
                class: "arrow-area"
              }, [
                vue.createElementVNode("view", { class: "input-arrow" })
              ])) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )
        ], true)
      ]),
      $data.isOpened ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "uni-data-tree-cover",
        onClick: _cache[2] || (_cache[2] = (...args) => $options.handleClose && $options.handleClose(...args))
      })) : vue.createCommentVNode("v-if", true),
      $data.isOpened ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 1,
        class: "uni-data-tree-dialog"
      }, [
        vue.createElementVNode("view", { class: "uni-popper__arrow" }),
        vue.createElementVNode("view", { class: "dialog-caption" }, [
          vue.createElementVNode("view", { class: "title-area" }, [
            vue.createElementVNode(
              "text",
              { class: "dialog-title" },
              vue.toDisplayString($props.popupTitle),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", {
            class: "dialog-close",
            onClick: _cache[3] || (_cache[3] = (...args) => $options.handleClose && $options.handleClose(...args))
          }, [
            vue.createElementVNode("view", {
              class: "dialog-close-plus",
              "data-id": "close"
            }),
            vue.createElementVNode("view", {
              class: "dialog-close-plus dialog-close-rotate",
              "data-id": "close"
            })
          ])
        ]),
        vue.createVNode(_component_data_picker_view, {
          class: "picker-view",
          ref: "pickerView",
          modelValue: _ctx.dataValue,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.dataValue = $event),
          localdata: _ctx.localdata,
          preload: _ctx.preload,
          collection: _ctx.collection,
          field: _ctx.field,
          orderby: _ctx.orderby,
          where: _ctx.where,
          "step-searh": _ctx.stepSearh,
          "self-field": _ctx.selfField,
          "parent-field": _ctx.parentField,
          "managed-mode": true,
          map: _ctx.map,
          ellipsis: $props.ellipsis,
          onChange: $options.onchange,
          onDatachange: $options.ondatachange,
          onNodeclick: $options.onnodeclick
        }, null, 8, ["modelValue", "localdata", "preload", "collection", "field", "orderby", "where", "step-searh", "self-field", "parent-field", "map", "ellipsis", "onChange", "onDatachange", "onNodeclick"])
      ])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const __easycom_0$4 = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$14], ["__scopeId", "data-v-2653531e"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-data-picker/components/uni-data-picker/uni-data-picker.vue"]]);
  const _sfc_main$14 = {
    data() {
      return {
        account: "test-app",
        username: "test-app",
        password: "Test123456",
        confirmPassword: "Test123456",
        phone: "13888888888",
        department: "二十一室",
        departments: []
      };
    },
    mounted() {
      this.getDepartments();
    },
    methods: {
      validatePasswordComplexity(password) {
        const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z\d]{8,}$/;
        return regex.test(password);
      },
      submitRegister() {
        const data = {
          "account": this.account,
          "department": this.department,
          "name": this.username,
          "password": this.password,
          "phone": this.phone,
          "role": "ACTOR",
          "status": "USING"
        };
        if (this.password !== this.confirmPassword) {
          uni.showToast({
            title: "两次输入的密码不一致",
            icon: "none"
          });
          return;
        }
        if (!this.validatePasswordComplexity(this.password)) {
          uni.showToast({
            title: "密码必须包含至少8个字符，且包含大小写字母和数字",
            icon: "none"
          });
          return;
        }
        register(data).then((res) => {
          formatAppLog("log", "at pages/register/register.vue:75", res);
          if (res.code == 200) {
            uni.showToast({
              title: "注册成功",
              duration: 2e3
            }).then((res2) => {
              uni.navigateTo({
                url: "/pages/login/login"
                // 替换为目标页面的路径
              });
            });
          }
        });
      },
      // 获取部门列表
      getDepartments() {
        this.departments = [
          {
            text: "二十一室",
            value: "二十一室"
          },
          {
            text: "二十二室",
            value: "二十二室"
          },
          {
            text: "二十三室",
            value: "二十三室"
          }
        ];
      },
      dataPickerChange(item) {
        this.department = item.detail.value[0].text;
        formatAppLog("log", "at pages/register/register.vue:107", this.department);
      }
    }
  };
  function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_data_picker = resolveEasycom(vue.resolveDynamicComponent("uni-data-picker"), __easycom_0$4);
    return vue.openBlock(), vue.createElementBlock("view", { class: "layout" }, [
      vue.createElementVNode("view", { class: "text" }, [
        vue.createElementVNode("text", null, "欢迎注册！")
      ]),
      vue.createElementVNode("view", {
        class: "account",
        style: { "margin-top": "25px" }
      }, [
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin-bottom": "7px" }
        }, "账户名"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            focus: "",
            placeholder: "请输入账户名",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.account = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.account]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin-bottom": "7px" }
        }, "姓名"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            focus: "",
            placeholder: "请输入姓名",
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.username = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.username]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "密码"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            password: "",
            type: "text",
            placeholder: "请输入密码",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.password = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.password]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "再次输入密码"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            password: "",
            type: "text",
            placeholder: "请再次输入密码",
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.confirmPassword = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.confirmPassword]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "部门"),
        vue.createVNode(_component_uni_data_picker, {
          localdata: $data.departments,
          "popup-title": "请选择部门",
          onChange: $options.dataPickerChange
        }, null, 8, ["localdata", "onChange"]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "手机号"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            type: "text",
            placeholder: "请输入手机号",
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.phone = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.phone]
        ]),
        vue.createElementVNode("button", {
          type: "primary",
          style: { "margin-top": "30px" },
          onClick: _cache[5] || (_cache[5] = (...args) => $options.submitRegister && $options.submitRegister(...args))
        }, "注册")
      ])
    ]);
  }
  const PagesRegisterRegister = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$13], ["__file", "E:/代码/new/zk_uniapp/pages/register/register.vue"]]);
  const _sfc_main$13 = {
    data() {
      return {};
    },
    methods: {}
  };
  function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view");
  }
  const PagesForgetPasswordForgetPassword = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$12], ["__file", "E:/代码/new/zk_uniapp/pages/forgetPassword/forgetPassword.vue"]]);
  const _imports_0$c = "/static/icon/finger.png";
  const _sfc_main$12 = {
    data() {
      return {
        result: "",
        disabled: true,
        show: false
      };
    },
    onLoad() {
      if (!plus.fingerprint.isSupport()) {
        this.result = "此设备不支持指纹识别";
        this.disabled = true;
      } else if (!plus.fingerprint.isKeyguardSecure()) {
        this.result = "此设备未设置密码锁屏，无法使用指纹识别";
        this.disabled = true;
      } else if (!plus.fingerprint.isEnrolledFingerprints()) {
        this.result = "此设备未录入指纹，请到设置中开启";
        this.disabled = true;
      } else {
        this.result = "此设备支持指纹识别";
        this.disabled = false;
      }
    },
    methods: {
      printCancel: function() {
        plus.fingerprint.cancel();
        this.result = "停止指纹识别";
      },
      fingerprint: function() {
        let that = this;
        plus.fingerprint.authenticate(function() {
          plus.nativeUI.closeWaiting();
          that.show = false;
          that.result = "指纹识别成功";
          const username = uni.getStorageSync("username");
          const password = uni.getStorageSync("password");
          login({
            account: username,
            password
          }).then((res) => {
            formatAppLog("log", "at pages/fingerLogin/fingerLogin.vue:68", res);
            if (res.code == 200) {
              uni.setStorageSync("token", res.data.token);
              uni.setStorageSync("userInfo", res.data.account);
              formatAppLog("log", "at pages/fingerLogin/fingerLogin.vue:72", uni.getStorageSync("token"));
              uni.showToast({
                title: "登录成功",
                duration: 2e3
              }).then(
                that.goToTask()
              );
            }
          });
        }, function(e2) {
          switch (e2.code) {
            case e2.AUTHENTICATE_MISMATCH:
              plus.nativeUI.toast("指纹匹配失败，请重新输入");
              break;
            case e2.AUTHENTICATE_OVERLIMIT:
              plus.nativeUI.closeWaiting();
              plus.nativeUI.alert("指纹识别失败次数超出限制，请使用其它方式进行认证");
              break;
            case e2.CANCEL:
              plus.nativeUI.toast("已取消识别");
              break;
            default:
              plus.nativeUI.closeWaiting();
              plus.nativeUI.alert("指纹识别失败，请重试");
              break;
          }
        });
        if ("Android" == plus.os.name) {
          this.show = true;
        }
      },
      goToTask() {
        uni.redirectTo({
          url: "/pages/tabBar/tabBar"
        });
      }
    }
  };
  function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "layout" }, [
      vue.createElementVNode("view", {
        class: "fingerView",
        onClick: _cache[0] || (_cache[0] = ($event) => $options.fingerprint()),
        disabled: $data.disabled
      }, [
        vue.createElementVNode("image", {
          src: _imports_0$c,
          class: "fingerIcon"
        })
      ], 8, ["disabled"]),
      vue.createElementVNode("view", {
        onClick: _cache[1] || (_cache[1] = ($event) => $options.fingerprint()),
        disabled: $data.disabled
      }, [
        vue.createElementVNode("text", { style: { "color": "rgb(45, 130, 254)" } }, "点击进行指纹认证")
      ], 8, ["disabled"]),
      vue.createElementVNode("view", { style: { "margin-top": "70px" } }, [
        vue.createElementVNode("text", null, [
          vue.createElementVNode("navigator", {
            url: "/pages/login/login",
            "open-type": "navigateBack",
            "hover-class": "null"
          }, "账号密码登录")
        ])
      ]),
      vue.createElementVNode(
        "view",
        { style: { "color": "red" } },
        vue.toDisplayString($data.result),
        1
        /* TEXT */
      )
    ]);
  }
  const PagesFingerLoginFingerLogin = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$11], ["__file", "E:/代码/new/zk_uniapp/pages/fingerLogin/fingerLogin.vue"]]);
  const searchMission = (query) => {
    return request({
      url: `/mission/search`,
      method: "post",
      data: query
    });
  };
  const deleteMission = (missionId) => {
    return request({
      url: `/mission/delete/${missionId}`,
      method: "delete"
    });
  };
  const getMissionFileById = (missionId, curPage, pageSize) => {
    return request({
      url: "/missionFile/get/files",
      method: "get",
      data: {
        missionId,
        curPage,
        pageSize
      }
    });
  };
  const getMissionDetails = (params) => {
    return request({
      url: `/mission/details`,
      method: "post",
      data: params
    });
  };
  const getFileUrl = (id) => {
    return request({
      url: "/missionFile/get/file/mission",
      method: "get",
      data: {
        missionFileId: id
      }
    });
  };
  const _imports_0$b = "/static/icon/location_grey.png";
  const _imports_1$5 = "/static/icon/time_grey.png";
  const _sfc_main$11 = {
    name: "TaskPage",
    data() {
      return {
        currentTime: /* @__PURE__ */ new Date(),
        taskItem: [],
        tabbarIndex: 0,
        handlingType: [
          {
            value: "全部"
          },
          {
            value: "未开始"
          },
          {
            value: "进行中"
          },
          {
            value: "已完成"
          }
        ],
        query: {
          "param": {
            "curPage": 1,
            "pageSize": 10
          },
          "statuses": [
            "USING",
            "UNUSED",
            "COMING"
          ]
        }
      };
    },
    mounted() {
      this.initializeTasks();
    },
    computed: {},
    methods: {
      initializeTasks() {
        uni.showLoading({
          title: "正在加载任务",
          mask: true
        });
        searchMission(this.query).then((res) => {
          this.taskItem = res.data.records.map((e2) => ({
            id: e2.id,
            task_name: e2.missionName,
            country: e2.missionCountry,
            position: e2.missionCity,
            start_time: e2.missionStartTime,
            end_time: e2.missionEndTime,
            type: this.getTaskType(e2.missionStartTime, e2.missionEndTime),
            description: e2.missionDescription,
            key: e2.missionPassword,
            latitude: e2.latitude,
            longitude: e2.longitude,
            geoJson: e2.geoJson
          }));
          uni.hideLoading();
        });
      },
      getItems(index) {
        switch (index) {
          case 0:
            return this.taskItem;
          case 1:
            return this.filterUpcomingTasks();
          case 2:
            return this.filterComingTasks();
          case 3:
            return this.filterEndedTasks();
        }
      },
      getTaskType(startTime, endTime) {
        const start = new Date(startTime);
        const end = new Date(endTime);
        if (this.currentTime < start) {
          return "1";
        } else if (this.currentTime >= start && this.currentTime <= end) {
          return "2";
        } else {
          return "3";
        }
      },
      getTypeString(type) {
        switch (type) {
          case "1":
            return "未开始";
          case "2":
            return "进行中";
          case "3":
            return "已完成";
        }
      },
      getColor(type) {
        switch (type) {
          case "1":
            return "#ffcccc";
          case "2":
            return "#ccffcc";
          case "3":
            return "#dadada";
          default:
            return "#ffffff";
        }
      },
      showType(tbIndex) {
        this.tabbarIndex = tbIndex;
        formatAppLog("info", "at pages/task/task.vue:179", this.tabbarIndex);
      },
      filterUpcomingTasks() {
        return this.taskItem.filter((item) => item.type === "1");
      },
      filterComingTasks() {
        return this.taskItem.filter((item) => item.type === "2");
      },
      filterEndedTasks() {
        return this.taskItem.filter((item) => item.type === "3");
      },
      goToDetail(index, tabbarIndex) {
        var jsonData = this.getItems(tabbarIndex)[index];
        var strData = JSON.stringify(jsonData);
        uni.navigateTo({
          url: `/pages/task/task_detail/task_detail?taskItem=${strData}`
        });
      }
    }
  };
  function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createCommentVNode(" 顶部Tab菜单 "),
      vue.createElementVNode("view", { class: "topTabBar" }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($data.handlingType, (item, tbIndex) => {
            return vue.openBlock(), vue.createElementBlock("view", {
              class: "grid",
              key: tbIndex,
              onClick: ($event) => $options.showType(tbIndex)
            }, [
              vue.createElementVNode(
                "view",
                {
                  class: vue.normalizeClass(["text", [tbIndex === $data.tabbarIndex ? "active" : ""]])
                },
                vue.toDisplayString(item.value),
                3
                /* TEXT, CLASS */
              )
            ], 8, ["onClick"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]),
      vue.createCommentVNode(" 任务列表展示区域 "),
      vue.createElementVNode("view", { style: { "margin-top": "100upx", "padding": "0 20upx 50px 20upx" } }, [
        vue.createCommentVNode(" 循环设置四个菜单项 "),
        (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList(4, (top_item, top_index) => {
            return vue.createElementVNode("view", { key: top_index }, [
              vue.createCommentVNode(" 根据top_index决定所属菜单项 "),
              $data.tabbarIndex === top_index ? (vue.openBlock(), vue.createElementBlock(
                vue.Fragment,
                { key: 0 },
                [
                  vue.createCommentVNode(" 任务列表 "),
                  (vue.openBlock(true), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList($options.getItems($data.tabbarIndex), (item, index) => {
                      return vue.openBlock(), vue.createElementBlock("view", { key: index }, [
                        vue.createCommentVNode(" 列表项 "),
                        vue.createElementVNode("view", {
                          onClick: ($event) => $options.goToDetail(index, $data.tabbarIndex),
                          class: "task_item"
                        }, [
                          vue.createCommentVNode(" 任务名称、任务状态 "),
                          vue.createElementVNode("view", { class: "item_top" }, [
                            vue.createElementVNode("view", null, [
                              vue.createElementVNode(
                                "text",
                                null,
                                vue.toDisplayString(item.task_name),
                                1
                                /* TEXT */
                              )
                            ]),
                            vue.createElementVNode("view", null, [
                              vue.createElementVNode(
                                "text",
                                {
                                  style: vue.normalizeStyle({ background: $options.getColor(item.type) })
                                },
                                vue.toDisplayString($options.getTypeString(item.type)),
                                5
                                /* TEXT, STYLE */
                              )
                            ])
                          ]),
                          vue.createCommentVNode(" 任务地点 "),
                          vue.createElementVNode("view", { class: "item_bottom" }, [
                            vue.createElementVNode("view", null, [
                              vue.createElementVNode("image", {
                                src: _imports_0$b,
                                style: { "width": "15px", "height": "15px" }
                              })
                            ]),
                            vue.createElementVNode("view", { style: { "margin-left": "7px" } }, [
                              vue.createElementVNode(
                                "text",
                                { style: { "line-height": "20px", "text-align": "center" } },
                                vue.toDisplayString(item.position),
                                1
                                /* TEXT */
                              )
                            ])
                          ]),
                          vue.createCommentVNode(" 任务时间 "),
                          vue.createElementVNode("view", { class: "item_bottom" }, [
                            vue.createElementVNode("view", null, [
                              vue.createElementVNode("image", {
                                src: _imports_1$5,
                                style: { "width": "16px", "height": "16px" }
                              })
                            ]),
                            vue.createElementVNode("view", { style: { "margin-left": "7px" } }, [
                              vue.createElementVNode(
                                "text",
                                null,
                                vue.toDisplayString(item.start_time) + " - " + vue.toDisplayString(item.end_time),
                                1
                                /* TEXT */
                              )
                            ])
                          ])
                        ], 8, ["onClick"])
                      ]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ],
                64
                /* STABLE_FRAGMENT */
              )) : vue.createCommentVNode("v-if", true)
            ]);
          }),
          64
          /* STABLE_FRAGMENT */
        ))
      ])
    ]);
  }
  const PagesTaskTask = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$10], ["__file", "E:/代码/new/zk_uniapp/pages/task/task.vue"]]);
  const _sfc_main$10 = {
    name: "UniStatusBar",
    data() {
      return {
        statusBarHeight: uni.getSystemInfoSync().statusBarHeight + "px"
      };
    }
  };
  function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        style: vue.normalizeStyle({ height: $data.statusBarHeight }),
        class: "uni-status-bar"
      },
      [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ],
      4
      /* STYLE */
    );
  }
  const statusBar = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$$], ["__scopeId", "data-v-7920e3e0"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-nav-bar/components/uni-nav-bar/uni-status-bar.vue"]]);
  const getVal = (val) => typeof val === "number" ? val + "px" : val;
  const _sfc_main$$ = {
    name: "UniNavBar",
    components: {
      statusBar
    },
    emits: ["clickLeft", "clickRight", "clickTitle"],
    props: {
      dark: {
        type: Boolean,
        default: false
      },
      title: {
        type: String,
        default: ""
      },
      leftText: {
        type: String,
        default: ""
      },
      rightText: {
        type: String,
        default: ""
      },
      leftIcon: {
        type: String,
        default: ""
      },
      rightIcon: {
        type: String,
        default: ""
      },
      fixed: {
        type: [Boolean, String],
        default: false
      },
      color: {
        type: String,
        default: ""
      },
      backgroundColor: {
        type: String,
        default: ""
      },
      statusBar: {
        type: [Boolean, String],
        default: false
      },
      shadow: {
        type: [Boolean, String],
        default: false
      },
      border: {
        type: [Boolean, String],
        default: true
      },
      height: {
        type: [Number, String],
        default: 44
      },
      leftWidth: {
        type: [Number, String],
        default: 60
      },
      rightWidth: {
        type: [Number, String],
        default: 60
      },
      stat: {
        type: [Boolean, String],
        default: ""
      }
    },
    computed: {
      themeBgColor() {
        if (this.dark) {
          if (this.backgroundColor) {
            return this.backgroundColor;
          } else {
            return this.dark ? "#333" : "#FFF";
          }
        }
        return this.backgroundColor || "#FFF";
      },
      themeColor() {
        if (this.dark) {
          if (this.color) {
            return this.color;
          } else {
            return this.dark ? "#fff" : "#333";
          }
        }
        return this.color || "#333";
      },
      navbarHeight() {
        return getVal(this.height);
      },
      leftIconWidth() {
        return getVal(this.leftWidth);
      },
      rightIconWidth() {
        return getVal(this.rightWidth);
      }
    },
    mounted() {
      if (uni.report && this.stat && this.title !== "") {
        uni.report("title", this.title);
      }
    },
    methods: {
      onClickLeft() {
        this.$emit("clickLeft");
      },
      onClickRight() {
        this.$emit("clickRight");
      },
      onClickTitle() {
        this.$emit("clickTitle");
      }
    }
  };
  function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_status_bar = vue.resolveComponent("status-bar");
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["uni-navbar", { "uni-dark": $props.dark, "uni-nvue-fixed": $props.fixed }])
      },
      [
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["uni-navbar__content", { "uni-navbar--fixed": $props.fixed, "uni-navbar--shadow": $props.shadow, "uni-navbar--border": $props.border }]),
            style: vue.normalizeStyle({ "background-color": $options.themeBgColor, "border-bottom-color": $options.themeColor })
          },
          [
            $props.statusBar ? (vue.openBlock(), vue.createBlock(_component_status_bar, { key: 0 })) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "view",
              {
                style: vue.normalizeStyle({ color: $options.themeColor, backgroundColor: $options.themeBgColor, height: $options.navbarHeight }),
                class: "uni-navbar__header"
              },
              [
                vue.createElementVNode(
                  "view",
                  {
                    onClick: _cache[0] || (_cache[0] = (...args) => $options.onClickLeft && $options.onClickLeft(...args)),
                    class: "uni-navbar__header-btns uni-navbar__header-btns-left",
                    style: vue.normalizeStyle({ width: $options.leftIconWidth })
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "left", {}, () => [
                      $props.leftIcon.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", {
                        key: 0,
                        class: "uni-navbar__content_view"
                      }, [
                        vue.createVNode(_component_uni_icons, {
                          color: $options.themeColor,
                          type: $props.leftIcon,
                          size: "20"
                        }, null, 8, ["color", "type"])
                      ])) : vue.createCommentVNode("v-if", true),
                      $props.leftText.length ? (vue.openBlock(), vue.createElementBlock(
                        "view",
                        {
                          key: 1,
                          class: vue.normalizeClass([{ "uni-navbar-btn-icon-left": !$props.leftIcon.length > 0 }, "uni-navbar-btn-text"])
                        },
                        [
                          vue.createElementVNode(
                            "text",
                            {
                              style: vue.normalizeStyle({ color: $options.themeColor, fontSize: "12px" })
                            },
                            vue.toDisplayString($props.leftText),
                            5
                            /* TEXT, STYLE */
                          )
                        ],
                        2
                        /* CLASS */
                      )) : vue.createCommentVNode("v-if", true)
                    ], true)
                  ],
                  4
                  /* STYLE */
                ),
                vue.createElementVNode("view", {
                  class: "uni-navbar__header-container",
                  onClick: _cache[1] || (_cache[1] = (...args) => $options.onClickTitle && $options.onClickTitle(...args))
                }, [
                  vue.renderSlot(_ctx.$slots, "default", {}, () => [
                    $props.title.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", {
                      key: 0,
                      class: "uni-navbar__header-container-inner"
                    }, [
                      vue.createElementVNode(
                        "text",
                        {
                          class: "uni-nav-bar-text uni-ellipsis-1",
                          style: vue.normalizeStyle({ color: $options.themeColor })
                        },
                        vue.toDisplayString($props.title),
                        5
                        /* TEXT, STYLE */
                      )
                    ])) : vue.createCommentVNode("v-if", true)
                  ], true)
                ]),
                vue.createElementVNode(
                  "view",
                  {
                    onClick: _cache[2] || (_cache[2] = (...args) => $options.onClickRight && $options.onClickRight(...args)),
                    class: "uni-navbar__header-btns uni-navbar__header-btns-right",
                    style: vue.normalizeStyle({ width: $options.rightIconWidth })
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "right", {}, () => [
                      $props.rightIcon.length ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, [
                        vue.createVNode(_component_uni_icons, {
                          color: $options.themeColor,
                          type: $props.rightIcon,
                          size: "22"
                        }, null, 8, ["color", "type"])
                      ])) : vue.createCommentVNode("v-if", true),
                      $props.rightText.length && !$props.rightIcon.length ? (vue.openBlock(), vue.createElementBlock("view", {
                        key: 1,
                        class: "uni-navbar-btn-text"
                      }, [
                        vue.createElementVNode(
                          "text",
                          {
                            class: "uni-nav-bar-right-text",
                            style: vue.normalizeStyle({ color: $options.themeColor })
                          },
                          vue.toDisplayString($props.rightText),
                          5
                          /* TEXT, STYLE */
                        )
                      ])) : vue.createCommentVNode("v-if", true)
                    ], true)
                  ],
                  4
                  /* STYLE */
                )
              ],
              4
              /* STYLE */
            )
          ],
          6
          /* CLASS, STYLE */
        ),
        $props.fixed ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "uni-navbar__placeholder"
        }, [
          $props.statusBar ? (vue.openBlock(), vue.createBlock(_component_status_bar, { key: 0 })) : vue.createCommentVNode("v-if", true),
          vue.createElementVNode(
            "view",
            {
              class: "uni-navbar__placeholder-view",
              style: vue.normalizeStyle({ height: $options.navbarHeight })
            },
            null,
            4
            /* STYLE */
          )
        ])) : vue.createCommentVNode("v-if", true)
      ],
      2
      /* CLASS */
    );
  }
  const __easycom_0$3 = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$_], ["__scopeId", "data-v-26544265"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-nav-bar/components/uni-nav-bar/uni-nav-bar.vue"]]);
  const _sfc_main$_ = {
    name: "uni-data-select",
    mixins: [Ys.mixinDatacom || {}],
    props: {
      localdata: {
        type: Array,
        default() {
          return [];
        }
      },
      value: {
        type: [String, Number],
        default: ""
      },
      modelValue: {
        type: [String, Number],
        default: ""
      },
      label: {
        type: String,
        default: ""
      },
      placeholder: {
        type: String,
        default: "请选择"
      },
      emptyTips: {
        type: String,
        default: "无选项"
      },
      clear: {
        type: Boolean,
        default: true
      },
      defItem: {
        type: Number,
        default: 0
      },
      disabled: {
        type: Boolean,
        default: false
      },
      // 格式化输出 用法 field="_id as value, version as text, uni_platform as label" format="{label} - {text}"
      format: {
        type: String,
        default: ""
      },
      placement: {
        type: String,
        default: "bottom"
      }
    },
    data() {
      return {
        showSelector: false,
        current: "",
        mixinDatacomResData: [],
        apps: [],
        channels: [],
        cacheKey: "uni-data-select-lastSelectedValue"
      };
    },
    created() {
      this.debounceGet = this.debounce(() => {
        this.query();
      }, 300);
      if (this.collection && !this.localdata.length) {
        this.debounceGet();
      }
    },
    computed: {
      typePlaceholder() {
        const text = {
          "opendb-stat-app-versions": "版本",
          "opendb-app-channels": "渠道",
          "opendb-app-list": "应用"
        };
        const common = this.placeholder;
        const placeholder = text[this.collection];
        return placeholder ? common + placeholder : common;
      },
      valueCom() {
        return this.modelValue;
      },
      textShow() {
        let text = this.current;
        if (text.length > 10) {
          return text.slice(0, 25) + "...";
        }
        return text;
      },
      getOffsetByPlacement() {
        switch (this.placement) {
          case "top":
            return "bottom:calc(100% + 12px);";
          case "bottom":
            return "top:calc(100% + 12px);";
        }
      }
    },
    watch: {
      localdata: {
        immediate: true,
        handler(val, old) {
          if (Array.isArray(val) && old !== val) {
            this.mixinDatacomResData = val;
          }
        }
      },
      valueCom(val, old) {
        this.initDefVal();
      },
      mixinDatacomResData: {
        immediate: true,
        handler(val) {
          if (val.length) {
            this.initDefVal();
          }
        }
      }
    },
    methods: {
      debounce(fn, time = 100) {
        let timer = null;
        return function(...args) {
          if (timer)
            clearTimeout(timer);
          timer = setTimeout(() => {
            fn.apply(this, args);
          }, time);
        };
      },
      // 执行数据库查询
      query() {
        this.mixinDatacomEasyGet();
      },
      // 监听查询条件变更事件
      onMixinDatacomPropsChange() {
        if (this.collection) {
          this.debounceGet();
        }
      },
      initDefVal() {
        let defValue = "";
        if ((this.valueCom || this.valueCom === 0) && !this.isDisabled(this.valueCom)) {
          defValue = this.valueCom;
        } else {
          let strogeValue;
          if (this.collection) {
            strogeValue = this.getCache();
          }
          if (strogeValue || strogeValue === 0) {
            defValue = strogeValue;
          } else {
            let defItem = "";
            if (this.defItem > 0 && this.defItem <= this.mixinDatacomResData.length) {
              defItem = this.mixinDatacomResData[this.defItem - 1].value;
            }
            defValue = defItem;
          }
          if (defValue || defValue === 0) {
            this.emit(defValue);
          }
        }
        const def = this.mixinDatacomResData.find((item) => item.value === defValue);
        this.current = def ? this.formatItemName(def) : "";
      },
      /**
       * @param {[String, Number]} value
       * 判断用户给的 value 是否同时为禁用状态
       */
      isDisabled(value) {
        let isDisabled = false;
        this.mixinDatacomResData.forEach((item) => {
          if (item.value === value) {
            isDisabled = item.disable;
          }
        });
        return isDisabled;
      },
      clearVal() {
        this.emit("");
        if (this.collection) {
          this.removeCache();
        }
      },
      change(item) {
        if (!item.disable) {
          this.showSelector = false;
          this.current = this.formatItemName(item);
          this.emit(item.value);
        }
      },
      emit(val) {
        this.$emit("input", val);
        this.$emit("update:modelValue", val);
        this.$emit("change", val);
        if (this.collection) {
          this.setCache(val);
        }
      },
      toggleSelector() {
        if (this.disabled) {
          return;
        }
        this.showSelector = !this.showSelector;
      },
      formatItemName(item) {
        let {
          text,
          value,
          channel_code
        } = item;
        channel_code = channel_code ? `(${channel_code})` : "";
        if (this.format) {
          let str = "";
          str = this.format;
          for (let key in item) {
            str = str.replace(new RegExp(`{${key}}`, "g"), item[key]);
          }
          return str;
        } else {
          return this.collection.indexOf("app-list") > 0 ? `${text}(${value})` : text ? text : `未命名${channel_code}`;
        }
      },
      // 获取当前加载的数据
      getLoadData() {
        return this.mixinDatacomResData;
      },
      // 获取当前缓存key
      getCurrentCacheKey() {
        return this.collection;
      },
      // 获取缓存
      getCache(name = this.getCurrentCacheKey()) {
        let cacheData = uni.getStorageSync(this.cacheKey) || {};
        return cacheData[name];
      },
      // 设置缓存
      setCache(value, name = this.getCurrentCacheKey()) {
        let cacheData = uni.getStorageSync(this.cacheKey) || {};
        cacheData[name] = value;
        uni.setStorageSync(this.cacheKey, cacheData);
      },
      // 删除缓存
      removeCache(name = this.getCurrentCacheKey()) {
        let cacheData = uni.getStorageSync(this.cacheKey) || {};
        delete cacheData[name];
        uni.setStorageSync(this.cacheKey, cacheData);
      }
    }
  };
  function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-stat__select" }, [
      $props.label ? (vue.openBlock(), vue.createElementBlock(
        "span",
        {
          key: 0,
          class: "uni-label-text hide-on-phone"
        },
        vue.toDisplayString($props.label + "："),
        1
        /* TEXT */
      )) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode(
        "view",
        {
          class: vue.normalizeClass(["uni-stat-box", { "uni-stat__actived": $data.current }])
        },
        [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["uni-select", { "uni-select--disabled": $props.disabled }])
            },
            [
              vue.createElementVNode("view", {
                class: "uni-select__input-box",
                onClick: _cache[1] || (_cache[1] = (...args) => $options.toggleSelector && $options.toggleSelector(...args))
              }, [
                $data.current ? (vue.openBlock(), vue.createElementBlock(
                  "view",
                  {
                    key: 0,
                    class: "uni-select__input-text"
                  },
                  vue.toDisplayString($options.textShow),
                  1
                  /* TEXT */
                )) : (vue.openBlock(), vue.createElementBlock(
                  "view",
                  {
                    key: 1,
                    class: "uni-select__input-text uni-select__input-placeholder"
                  },
                  vue.toDisplayString($options.typePlaceholder),
                  1
                  /* TEXT */
                )),
                $data.current && $props.clear && !$props.disabled ? (vue.openBlock(), vue.createElementBlock("view", {
                  key: 2,
                  onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $options.clearVal && $options.clearVal(...args), ["stop"]))
                }, [
                  vue.createVNode(_component_uni_icons, {
                    type: "clear",
                    color: "#c0c4cc",
                    size: "24"
                  })
                ])) : (vue.openBlock(), vue.createElementBlock("view", { key: 3 }, [
                  vue.createVNode(_component_uni_icons, {
                    type: $data.showSelector ? "top" : "bottom",
                    size: "14",
                    color: "#999"
                  }, null, 8, ["type"])
                ]))
              ]),
              $data.showSelector ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 0,
                class: "uni-select--mask",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.toggleSelector && $options.toggleSelector(...args))
              })) : vue.createCommentVNode("v-if", true),
              $data.showSelector ? (vue.openBlock(), vue.createElementBlock(
                "view",
                {
                  key: 1,
                  class: "uni-select__selector",
                  style: vue.normalizeStyle($options.getOffsetByPlacement)
                },
                [
                  vue.createElementVNode(
                    "view",
                    {
                      class: vue.normalizeClass($props.placement == "bottom" ? "uni-popper__arrow_bottom" : "uni-popper__arrow_top")
                    },
                    null,
                    2
                    /* CLASS */
                  ),
                  vue.createElementVNode("scroll-view", {
                    "scroll-y": "true",
                    class: "uni-select__selector-scroll"
                  }, [
                    $data.mixinDatacomResData.length === 0 ? (vue.openBlock(), vue.createElementBlock("view", {
                      key: 0,
                      class: "uni-select__selector-empty"
                    }, [
                      vue.createElementVNode(
                        "text",
                        null,
                        vue.toDisplayString($props.emptyTips),
                        1
                        /* TEXT */
                      )
                    ])) : (vue.openBlock(true), vue.createElementBlock(
                      vue.Fragment,
                      { key: 1 },
                      vue.renderList($data.mixinDatacomResData, (item, index) => {
                        return vue.openBlock(), vue.createElementBlock("view", {
                          class: "uni-select__selector-item",
                          key: index,
                          onClick: ($event) => $options.change(item)
                        }, [
                          vue.createElementVNode(
                            "text",
                            {
                              class: vue.normalizeClass({ "uni-select__selector__disabled": item.disable })
                            },
                            vue.toDisplayString($options.formatItemName(item)),
                            3
                            /* TEXT, CLASS */
                          )
                        ], 8, ["onClick"]);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ])
                ],
                4
                /* STYLE */
              )) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      )
    ]);
  }
  const __easycom_1$2 = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$Z], ["__scopeId", "data-v-ddf9e0a2"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-data-select/components/uni-data-select/uni-data-select.vue"]]);
  class MPAnimation {
    constructor(options, _this) {
      this.options = options;
      this.animation = uni.createAnimation({
        ...options
      });
      this.currentStepAnimates = {};
      this.next = 0;
      this.$ = _this;
    }
    _nvuePushAnimates(type, args) {
      let aniObj = this.currentStepAnimates[this.next];
      let styles = {};
      if (!aniObj) {
        styles = {
          styles: {},
          config: {}
        };
      } else {
        styles = aniObj;
      }
      if (animateTypes1.includes(type)) {
        if (!styles.styles.transform) {
          styles.styles.transform = "";
        }
        let unit = "";
        if (type === "rotate") {
          unit = "deg";
        }
        styles.styles.transform += `${type}(${args + unit}) `;
      } else {
        styles.styles[type] = `${args}`;
      }
      this.currentStepAnimates[this.next] = styles;
    }
    _animateRun(styles = {}, config = {}) {
      let ref = this.$.$refs["ani"].ref;
      if (!ref)
        return;
      return new Promise((resolve, reject) => {
        nvueAnimation.transition(ref, {
          styles,
          ...config
        }, (res) => {
          resolve();
        });
      });
    }
    _nvueNextAnimate(animates, step = 0, fn) {
      let obj = animates[step];
      if (obj) {
        let {
          styles,
          config
        } = obj;
        this._animateRun(styles, config).then(() => {
          step += 1;
          this._nvueNextAnimate(animates, step, fn);
        });
      } else {
        this.currentStepAnimates = {};
        typeof fn === "function" && fn();
        this.isEnd = true;
      }
    }
    step(config = {}) {
      this.animation.step(config);
      return this;
    }
    run(fn) {
      this.$.animationData = this.animation.export();
      this.$.timer = setTimeout(() => {
        typeof fn === "function" && fn();
      }, this.$.durationTime);
    }
  }
  const animateTypes1 = [
    "matrix",
    "matrix3d",
    "rotate",
    "rotate3d",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scale3d",
    "scaleX",
    "scaleY",
    "scaleZ",
    "skew",
    "skewX",
    "skewY",
    "translate",
    "translate3d",
    "translateX",
    "translateY",
    "translateZ"
  ];
  const animateTypes2 = ["opacity", "backgroundColor"];
  const animateTypes3 = ["width", "height", "left", "right", "top", "bottom"];
  animateTypes1.concat(animateTypes2, animateTypes3).forEach((type) => {
    MPAnimation.prototype[type] = function(...args) {
      this.animation[type](...args);
      return this;
    };
  });
  function createAnimation(option, _this) {
    if (!_this)
      return;
    clearTimeout(_this.timer);
    return new MPAnimation(option, _this);
  }
  const _sfc_main$Z = {
    name: "uniTransition",
    emits: ["click", "change"],
    props: {
      show: {
        type: Boolean,
        default: false
      },
      modeClass: {
        type: [Array, String],
        default() {
          return "fade";
        }
      },
      duration: {
        type: Number,
        default: 300
      },
      styles: {
        type: Object,
        default() {
          return {};
        }
      },
      customClass: {
        type: String,
        default: ""
      },
      onceRender: {
        type: Boolean,
        default: false
      }
    },
    data() {
      return {
        isShow: false,
        transform: "",
        opacity: 1,
        animationData: {},
        durationTime: 300,
        config: {}
      };
    },
    watch: {
      show: {
        handler(newVal) {
          if (newVal) {
            this.open();
          } else {
            if (this.isShow) {
              this.close();
            }
          }
        },
        immediate: true
      }
    },
    computed: {
      // 生成样式数据
      stylesObject() {
        let styles = {
          ...this.styles,
          "transition-duration": this.duration / 1e3 + "s"
        };
        let transform = "";
        for (let i2 in styles) {
          let line = this.toLine(i2);
          transform += line + ":" + styles[i2] + ";";
        }
        return transform;
      },
      // 初始化动画条件
      transformStyles() {
        return "transform:" + this.transform + ";opacity:" + this.opacity + ";" + this.stylesObject;
      }
    },
    created() {
      this.config = {
        duration: this.duration,
        timingFunction: "ease",
        transformOrigin: "50% 50%",
        delay: 0
      };
      this.durationTime = this.duration;
    },
    methods: {
      /**
       *  ref 触发 初始化动画
       */
      init(obj = {}) {
        if (obj.duration) {
          this.durationTime = obj.duration;
        }
        this.animation = createAnimation(Object.assign(this.config, obj), this);
      },
      /**
       * 点击组件触发回调
       */
      onClick() {
        this.$emit("click", {
          detail: this.isShow
        });
      },
      /**
       * ref 触发 动画分组
       * @param {Object} obj
       */
      step(obj, config = {}) {
        if (!this.animation)
          return;
        for (let i2 in obj) {
          try {
            if (typeof obj[i2] === "object") {
              this.animation[i2](...obj[i2]);
            } else {
              this.animation[i2](obj[i2]);
            }
          } catch (e2) {
            formatAppLog("error", "at uni_modules/uni-transition/components/uni-transition/uni-transition.vue:148", `方法 ${i2} 不存在`);
          }
        }
        this.animation.step(config);
        return this;
      },
      /**
       *  ref 触发 执行动画
       */
      run(fn) {
        if (!this.animation)
          return;
        this.animation.run(fn);
      },
      // 开始过度动画
      open() {
        clearTimeout(this.timer);
        this.transform = "";
        this.isShow = true;
        let { opacity, transform } = this.styleInit(false);
        if (typeof opacity !== "undefined") {
          this.opacity = opacity;
        }
        this.transform = transform;
        this.$nextTick(() => {
          this.timer = setTimeout(() => {
            this.animation = createAnimation(this.config, this);
            this.tranfromInit(false).step();
            this.animation.run();
            this.$emit("change", {
              detail: this.isShow
            });
          }, 20);
        });
      },
      // 关闭过度动画
      close(type) {
        if (!this.animation)
          return;
        this.tranfromInit(true).step().run(() => {
          this.isShow = false;
          this.animationData = null;
          this.animation = null;
          let { opacity, transform } = this.styleInit(false);
          this.opacity = opacity || 1;
          this.transform = transform;
          this.$emit("change", {
            detail: this.isShow
          });
        });
      },
      // 处理动画开始前的默认样式
      styleInit(type) {
        let styles = {
          transform: ""
        };
        let buildStyle = (type2, mode) => {
          if (mode === "fade") {
            styles.opacity = this.animationType(type2)[mode];
          } else {
            styles.transform += this.animationType(type2)[mode] + " ";
          }
        };
        if (typeof this.modeClass === "string") {
          buildStyle(type, this.modeClass);
        } else {
          this.modeClass.forEach((mode) => {
            buildStyle(type, mode);
          });
        }
        return styles;
      },
      // 处理内置组合动画
      tranfromInit(type) {
        let buildTranfrom = (type2, mode) => {
          let aniNum = null;
          if (mode === "fade") {
            aniNum = type2 ? 0 : 1;
          } else {
            aniNum = type2 ? "-100%" : "0";
            if (mode === "zoom-in") {
              aniNum = type2 ? 0.8 : 1;
            }
            if (mode === "zoom-out") {
              aniNum = type2 ? 1.2 : 1;
            }
            if (mode === "slide-right") {
              aniNum = type2 ? "100%" : "0";
            }
            if (mode === "slide-bottom") {
              aniNum = type2 ? "100%" : "0";
            }
          }
          this.animation[this.animationMode()[mode]](aniNum);
        };
        if (typeof this.modeClass === "string") {
          buildTranfrom(type, this.modeClass);
        } else {
          this.modeClass.forEach((mode) => {
            buildTranfrom(type, mode);
          });
        }
        return this.animation;
      },
      animationType(type) {
        return {
          fade: type ? 0 : 1,
          "slide-top": `translateY(${type ? "0" : "-100%"})`,
          "slide-right": `translateX(${type ? "0" : "100%"})`,
          "slide-bottom": `translateY(${type ? "0" : "100%"})`,
          "slide-left": `translateX(${type ? "0" : "-100%"})`,
          "zoom-in": `scaleX(${type ? 1 : 0.8}) scaleY(${type ? 1 : 0.8})`,
          "zoom-out": `scaleX(${type ? 1 : 1.2}) scaleY(${type ? 1 : 1.2})`
        };
      },
      // 内置动画类型与实际动画对应字典
      animationMode() {
        return {
          fade: "opacity",
          "slide-top": "translateY",
          "slide-right": "translateX",
          "slide-bottom": "translateY",
          "slide-left": "translateX",
          "zoom-in": "scale",
          "zoom-out": "scale"
        };
      },
      // 驼峰转中横线
      toLine(name) {
        return name.replace(/([A-Z])/g, "-$1").toLowerCase();
      }
    }
  };
  function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.withDirectives((vue.openBlock(), vue.createElementBlock("view", {
      ref: "ani",
      animation: $data.animationData,
      class: vue.normalizeClass($props.customClass),
      style: vue.normalizeStyle($options.transformStyles),
      onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 14, ["animation"])), [
      [vue.vShow, $data.isShow]
    ]);
  }
  const __easycom_0$2 = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Y], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-transition/components/uni-transition/uni-transition.vue"]]);
  const _sfc_main$Y = {
    name: "uniPopup",
    components: {},
    emits: ["change", "maskClick"],
    props: {
      // 开启动画
      animation: {
        type: Boolean,
        default: true
      },
      // 弹出层类型，可选值，top: 顶部弹出层；bottom：底部弹出层；center：全屏弹出层
      // message: 消息提示 ; dialog : 对话框
      type: {
        type: String,
        default: "center"
      },
      // maskClick
      isMaskClick: {
        type: Boolean,
        default: null
      },
      // TODO 2 个版本后废弃属性 ，使用 isMaskClick
      maskClick: {
        type: Boolean,
        default: null
      },
      backgroundColor: {
        type: String,
        default: "none"
      },
      safeArea: {
        type: Boolean,
        default: true
      },
      maskBackgroundColor: {
        type: String,
        default: "rgba(0, 0, 0, 0.4)"
      },
      borderRadius: {
        type: String
      }
    },
    watch: {
      /**
       * 监听type类型
       */
      type: {
        handler: function(type) {
          if (!this.config[type])
            return;
          this[this.config[type]](true);
        },
        immediate: true
      },
      isDesktop: {
        handler: function(newVal) {
          if (!this.config[newVal])
            return;
          this[this.config[this.type]](true);
        },
        immediate: true
      },
      /**
       * 监听遮罩是否可点击
       * @param {Object} val
       */
      maskClick: {
        handler: function(val) {
          this.mkclick = val;
        },
        immediate: true
      },
      isMaskClick: {
        handler: function(val) {
          this.mkclick = val;
        },
        immediate: true
      },
      // H5 下禁止底部滚动
      showPopup(show) {
      }
    },
    data() {
      return {
        duration: 300,
        ani: [],
        showPopup: false,
        showTrans: false,
        popupWidth: 0,
        popupHeight: 0,
        config: {
          top: "top",
          bottom: "bottom",
          center: "center",
          left: "left",
          right: "right",
          message: "top",
          dialog: "center",
          share: "bottom"
        },
        maskClass: {
          position: "fixed",
          bottom: 0,
          top: 0,
          left: 0,
          right: 0,
          backgroundColor: "rgba(0, 0, 0, 0.4)"
        },
        transClass: {
          backgroundColor: "transparent",
          borderRadius: this.borderRadius || "0",
          position: "fixed",
          left: 0,
          right: 0
        },
        maskShow: true,
        mkclick: true,
        popupstyle: "top"
      };
    },
    computed: {
      getStyles() {
        let res = { backgroundColor: this.bg };
        if (this.borderRadius || "0") {
          res = Object.assign(res, { borderRadius: this.borderRadius });
        }
        return res;
      },
      isDesktop() {
        return this.popupWidth >= 500 && this.popupHeight >= 500;
      },
      bg() {
        if (this.backgroundColor === "" || this.backgroundColor === "none") {
          return "transparent";
        }
        return this.backgroundColor;
      }
    },
    mounted() {
      const fixSize = () => {
        const {
          windowWidth,
          windowHeight,
          windowTop,
          safeArea,
          screenHeight,
          safeAreaInsets
        } = uni.getSystemInfoSync();
        this.popupWidth = windowWidth;
        this.popupHeight = windowHeight + (windowTop || 0);
        if (safeArea && this.safeArea) {
          this.safeAreaInsets = safeAreaInsets.bottom;
        } else {
          this.safeAreaInsets = 0;
        }
      };
      fixSize();
    },
    // TODO vue3
    unmounted() {
      this.setH5Visible();
    },
    activated() {
      this.setH5Visible(!this.showPopup);
    },
    deactivated() {
      this.setH5Visible(true);
    },
    created() {
      if (this.isMaskClick === null && this.maskClick === null) {
        this.mkclick = true;
      } else {
        this.mkclick = this.isMaskClick !== null ? this.isMaskClick : this.maskClick;
      }
      if (this.animation) {
        this.duration = 300;
      } else {
        this.duration = 0;
      }
      this.messageChild = null;
      this.clearPropagation = false;
      this.maskClass.backgroundColor = this.maskBackgroundColor;
    },
    methods: {
      setH5Visible(visible = true) {
      },
      /**
       * 公用方法，不显示遮罩层
       */
      closeMask() {
        this.maskShow = false;
      },
      /**
       * 公用方法，遮罩层禁止点击
       */
      disableMask() {
        this.mkclick = false;
      },
      // TODO nvue 取消冒泡
      clear(e2) {
        e2.stopPropagation();
        this.clearPropagation = true;
      },
      open(direction) {
        if (this.showPopup) {
          return;
        }
        let innerType = ["top", "center", "bottom", "left", "right", "message", "dialog", "share"];
        if (!(direction && innerType.indexOf(direction) !== -1)) {
          direction = this.type;
        }
        if (!this.config[direction]) {
          formatAppLog("error", "at uni_modules/uni-popup/components/uni-popup/uni-popup.vue:298", "缺少类型：", direction);
          return;
        }
        this[this.config[direction]]();
        this.$emit("change", {
          show: true,
          type: direction
        });
      },
      close(type) {
        this.showTrans = false;
        this.$emit("change", {
          show: false,
          type: this.type
        });
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          this.showPopup = false;
        }, 300);
      },
      // TODO 处理冒泡事件，头条的冒泡事件有问题 ，先这样兼容
      touchstart() {
        this.clearPropagation = false;
      },
      onTap() {
        if (this.clearPropagation) {
          this.clearPropagation = false;
          return;
        }
        this.$emit("maskClick");
        if (!this.mkclick)
          return;
        this.close();
      },
      /**
       * 顶部弹出样式处理
       */
      top(type) {
        this.popupstyle = this.isDesktop ? "fixforpc-top" : "top";
        this.ani = ["slide-top"];
        this.transClass = {
          position: "fixed",
          left: 0,
          right: 0,
          backgroundColor: this.bg,
          borderRadius: this.borderRadius || "0"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
        this.$nextTick(() => {
          if (this.messageChild && this.type === "message") {
            this.messageChild.timerClose();
          }
        });
      },
      /**
       * 底部弹出样式处理
       */
      bottom(type) {
        this.popupstyle = "bottom";
        this.ani = ["slide-bottom"];
        this.transClass = {
          position: "fixed",
          left: 0,
          right: 0,
          bottom: 0,
          paddingBottom: this.safeAreaInsets + "px",
          backgroundColor: this.bg,
          borderRadius: this.borderRadius || "0"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
      },
      /**
       * 中间弹出样式处理
       */
      center(type) {
        this.popupstyle = "center";
        this.ani = ["zoom-out", "fade"];
        this.transClass = {
          position: "fixed",
          display: "flex",
          flexDirection: "column",
          bottom: 0,
          left: 0,
          right: 0,
          top: 0,
          justifyContent: "center",
          alignItems: "center",
          borderRadius: this.borderRadius || "0"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
      },
      left(type) {
        this.popupstyle = "left";
        this.ani = ["slide-left"];
        this.transClass = {
          position: "fixed",
          left: 0,
          bottom: 0,
          top: 0,
          backgroundColor: this.bg,
          borderRadius: this.borderRadius || "0",
          display: "flex",
          flexDirection: "column"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
      },
      right(type) {
        this.popupstyle = "right";
        this.ani = ["slide-right"];
        this.transClass = {
          position: "fixed",
          bottom: 0,
          right: 0,
          top: 0,
          backgroundColor: this.bg,
          borderRadius: this.borderRadius || "0",
          display: "flex",
          flexDirection: "column"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
      }
    }
  };
  function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_transition = resolveEasycom(vue.resolveDynamicComponent("uni-transition"), __easycom_0$2);
    return $data.showPopup ? (vue.openBlock(), vue.createElementBlock(
      "view",
      {
        key: 0,
        class: vue.normalizeClass(["uni-popup", [$data.popupstyle, $options.isDesktop ? "fixforpc-z-index" : ""]])
      },
      [
        vue.createElementVNode(
          "view",
          {
            onTouchstart: _cache[1] || (_cache[1] = (...args) => $options.touchstart && $options.touchstart(...args))
          },
          [
            $data.maskShow ? (vue.openBlock(), vue.createBlock(_component_uni_transition, {
              key: "1",
              name: "mask",
              "mode-class": "fade",
              styles: $data.maskClass,
              duration: $data.duration,
              show: $data.showTrans,
              onClick: $options.onTap
            }, null, 8, ["styles", "duration", "show", "onClick"])) : vue.createCommentVNode("v-if", true),
            vue.createVNode(_component_uni_transition, {
              key: "2",
              "mode-class": $data.ani,
              name: "content",
              styles: $data.transClass,
              duration: $data.duration,
              show: $data.showTrans,
              onClick: $options.onTap
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode(
                  "view",
                  {
                    class: vue.normalizeClass(["uni-popup__wrapper", [$data.popupstyle]]),
                    style: vue.normalizeStyle($options.getStyles),
                    onClick: _cache[0] || (_cache[0] = (...args) => $options.clear && $options.clear(...args))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
                  ],
                  6
                  /* CLASS, STYLE */
                )
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["mode-class", "styles", "duration", "show", "onClick"])
          ],
          32
          /* NEED_HYDRATION */
        )
      ],
      2
      /* CLASS */
    )) : vue.createCommentVNode("v-if", true);
  }
  const __easycom_2$1 = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$X], ["__scopeId", "data-v-4dd3c44b"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-popup/components/uni-popup/uni-popup.vue"]]);
  const _sfc_main$X = {
    name: "uniCollapseItem",
    props: {
      // 列表标题
      title: {
        type: String,
        default: ""
      },
      name: {
        type: [Number, String],
        default: ""
      },
      // 是否禁用
      disabled: {
        type: Boolean,
        default: false
      },
      // 是否显示动画,app 端默认不开启动画，卡顿严重
      showAnimation: {
        type: Boolean,
        default: false
      },
      // 是否展开
      open: {
        type: Boolean,
        default: false
      },
      // 缩略图
      thumb: {
        type: String,
        default: ""
      },
      // 标题分隔线显示类型
      titleBorder: {
        type: String,
        default: "auto"
      },
      border: {
        type: Boolean,
        default: true
      },
      showArrow: {
        type: Boolean,
        default: true
      }
    },
    data() {
      const elId = `Uni_${Math.ceil(Math.random() * 1e6).toString(36)}`;
      return {
        isOpen: false,
        isheight: null,
        height: 0,
        elId,
        nameSync: 0
      };
    },
    watch: {
      open(val) {
        this.isOpen = val;
        this.onClick(val, "init");
      }
    },
    updated(e2) {
      this.$nextTick(() => {
        this.init(true);
      });
    },
    created() {
      this.collapse = this.getCollapse();
      this.oldHeight = 0;
      this.onClick(this.open, "init");
    },
    // TODO vue3
    unmounted() {
      this.__isUnmounted = true;
      this.uninstall();
    },
    mounted() {
      if (!this.collapse)
        return;
      if (this.name !== "") {
        this.nameSync = this.name;
      } else {
        this.nameSync = this.collapse.childrens.length + "";
      }
      if (this.collapse.names.indexOf(this.nameSync) === -1) {
        this.collapse.names.push(this.nameSync);
      } else {
        formatAppLog("warn", "at uni_modules/uni-collapse/components/uni-collapse-item/uni-collapse-item.vue:154", `name 值 ${this.nameSync} 重复`);
      }
      if (this.collapse.childrens.indexOf(this) === -1) {
        this.collapse.childrens.push(this);
      }
      this.init();
    },
    methods: {
      init(type) {
        this.getCollapseHeight(type);
      },
      uninstall() {
        if (this.collapse) {
          this.collapse.childrens.forEach((item, index) => {
            if (item === this) {
              this.collapse.childrens.splice(index, 1);
            }
          });
          this.collapse.names.forEach((item, index) => {
            if (item === this.nameSync) {
              this.collapse.names.splice(index, 1);
            }
          });
        }
      },
      onClick(isOpen, type) {
        if (this.disabled)
          return;
        this.isOpen = isOpen;
        if (this.isOpen && this.collapse) {
          this.collapse.setAccordion(this);
        }
        if (type !== "init") {
          this.collapse.onChange(isOpen, this);
        }
      },
      getCollapseHeight(type, index = 0) {
        const views = uni.createSelectorQuery().in(this);
        views.select(`#${this.elId}`).fields({
          size: true
        }, (data) => {
          if (index >= 10)
            return;
          if (!data) {
            index++;
            this.getCollapseHeight(false, index);
            return;
          }
          this.height = data.height;
          this.isheight = true;
          if (type)
            return;
          this.onClick(this.isOpen, "init");
        }).exec();
      },
      getNvueHwight(type) {
        dom.getComponentRect(this.$refs["collapse--hook"], (option) => {
          if (option && option.result && option.size) {
            this.height = option.size.height;
            this.isheight = true;
            if (type)
              return;
            this.onClick(this.open, "init");
          }
        });
      },
      /**
       * 获取父元素实例
       */
      getCollapse(name = "uniCollapse") {
        let parent = this.$parent;
        let parentName = parent.$options.name;
        while (parentName !== name) {
          parent = parent.$parent;
          if (!parent)
            return false;
          parentName = parent.$options.name;
        }
        return parent;
      }
    }
  };
  function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-collapse-item" }, [
      vue.createCommentVNode(" onClick(!isOpen) "),
      vue.createElementVNode(
        "view",
        {
          onClick: _cache[0] || (_cache[0] = ($event) => $options.onClick(!$data.isOpen)),
          class: vue.normalizeClass(["uni-collapse-item__title", { "is-open": $data.isOpen && $props.titleBorder === "auto", "uni-collapse-item-border": $props.titleBorder !== "none" }])
        },
        [
          vue.createElementVNode("view", { class: "uni-collapse-item__title-wrap" }, [
            vue.renderSlot(_ctx.$slots, "title", {}, () => [
              vue.createElementVNode(
                "view",
                {
                  class: vue.normalizeClass(["uni-collapse-item__title-box", { "is-disabled": $props.disabled }])
                },
                [
                  $props.thumb ? (vue.openBlock(), vue.createElementBlock("image", {
                    key: 0,
                    src: $props.thumb,
                    class: "uni-collapse-item__title-img"
                  }, null, 8, ["src"])) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode(
                    "text",
                    { class: "uni-collapse-item__title-text" },
                    vue.toDisplayString($props.title),
                    1
                    /* TEXT */
                  )
                ],
                2
                /* CLASS */
              )
            ], true)
          ]),
          $props.showArrow ? (vue.openBlock(), vue.createElementBlock(
            "view",
            {
              key: 0,
              class: vue.normalizeClass([{ "uni-collapse-item__title-arrow-active": $data.isOpen, "uni-collapse-item--animation": $props.showAnimation === true }, "uni-collapse-item__title-arrow"])
            },
            [
              vue.createVNode(_component_uni_icons, {
                color: $props.disabled ? "#ddd" : "#bbb",
                size: "14",
                type: "bottom"
              }, null, 8, ["color"])
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      ),
      vue.createElementVNode(
        "view",
        {
          class: vue.normalizeClass(["uni-collapse-item__wrap", { "is--transition": $props.showAnimation }]),
          style: vue.normalizeStyle({ height: ($data.isOpen ? $data.height : 0) + "px" })
        },
        [
          vue.createElementVNode("view", {
            id: $data.elId,
            ref: "collapse--hook",
            class: vue.normalizeClass(["uni-collapse-item__wrap-content", { open: $data.isheight, "uni-collapse-item--border": $props.border && $data.isOpen }])
          }, [
            vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 10, ["id"])
        ],
        6
        /* CLASS, STYLE */
      )
    ]);
  }
  const __easycom_3$1 = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$W], ["__scopeId", "data-v-3d2dde9f"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-collapse/components/uni-collapse-item/uni-collapse-item.vue"]]);
  const _sfc_main$W = {
    name: "uniCollapse",
    emits: ["change", "activeItem", "input", "update:modelValue"],
    props: {
      value: {
        type: [String, Array],
        default: ""
      },
      modelValue: {
        type: [String, Array],
        default: ""
      },
      accordion: {
        // 是否开启手风琴效果
        type: [Boolean, String],
        default: false
      }
    },
    data() {
      return {};
    },
    computed: {
      // TODO 兼容 vue2 和 vue3
      dataValue() {
        let value = typeof this.value === "string" && this.value === "" || Array.isArray(this.value) && this.value.length === 0;
        let modelValue = typeof this.modelValue === "string" && this.modelValue === "" || Array.isArray(this.modelValue) && this.modelValue.length === 0;
        if (value) {
          return this.modelValue;
        }
        if (modelValue) {
          return this.value;
        }
        return this.value;
      }
    },
    watch: {
      dataValue(val) {
        this.setOpen(val);
      }
    },
    created() {
      this.childrens = [];
      this.names = [];
    },
    mounted() {
      this.$nextTick(() => {
        this.setOpen(this.dataValue);
      });
    },
    methods: {
      setOpen(val) {
        let str = typeof val === "string";
        let arr = Array.isArray(val);
        this.childrens.forEach((vm, index) => {
          if (str) {
            if (val === vm.nameSync) {
              if (!this.accordion) {
                formatAppLog("warn", "at uni_modules/uni-collapse/components/uni-collapse/uni-collapse.vue:75", "accordion 属性为 false ,v-model 类型应该为 array");
                return;
              }
              vm.isOpen = true;
            }
          }
          if (arr) {
            val.forEach((v2) => {
              if (v2 === vm.nameSync) {
                if (this.accordion) {
                  formatAppLog("warn", "at uni_modules/uni-collapse/components/uni-collapse/uni-collapse.vue:85", "accordion 属性为 true ,v-model 类型应该为 string");
                  return;
                }
                vm.isOpen = true;
              }
            });
          }
        });
        this.emit(val);
      },
      setAccordion(self2) {
        if (!this.accordion)
          return;
        this.childrens.forEach((vm, index) => {
          if (self2 !== vm) {
            vm.isOpen = false;
          }
        });
      },
      resize() {
        this.childrens.forEach((vm, index) => {
          vm.getCollapseHeight();
        });
      },
      onChange(isOpen, self2) {
        let activeItem = [];
        if (this.accordion) {
          activeItem = isOpen ? self2.nameSync : "";
        } else {
          this.childrens.forEach((vm, index) => {
            if (vm.isOpen) {
              activeItem.push(vm.nameSync);
            }
          });
        }
        this.$emit("change", activeItem);
        this.emit(activeItem);
      },
      emit(val) {
        this.$emit("input", val);
        this.$emit("update:modelValue", val);
      }
    }
  };
  function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-collapse" }, [
      vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ]);
  }
  const __easycom_4 = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$V], ["__scopeId", "data-v-3f050360"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-collapse/components/uni-collapse/uni-collapse.vue"]]);
  const _sfc_main$V = {
    name: "uniDataChecklist",
    mixins: [Ys.mixinDatacom || {}],
    emits: ["input", "update:modelValue", "change"],
    props: {
      mode: {
        type: String,
        default: "default"
      },
      multiple: {
        type: Boolean,
        default: false
      },
      value: {
        type: [Array, String, Number],
        default() {
          return "";
        }
      },
      // TODO vue3
      modelValue: {
        type: [Array, String, Number],
        default() {
          return "";
        }
      },
      localdata: {
        type: Array,
        default() {
          return [];
        }
      },
      min: {
        type: [Number, String],
        default: ""
      },
      max: {
        type: [Number, String],
        default: ""
      },
      wrap: {
        type: Boolean,
        default: false
      },
      icon: {
        type: String,
        default: "left"
      },
      selectedColor: {
        type: String,
        default: ""
      },
      selectedTextColor: {
        type: String,
        default: ""
      },
      emptyText: {
        type: String,
        default: "暂无数据"
      },
      disabled: {
        type: Boolean,
        default: false
      },
      map: {
        type: Object,
        default() {
          return {
            text: "text",
            value: "value"
          };
        }
      }
    },
    watch: {
      localdata: {
        handler(newVal) {
          this.range = newVal;
          this.dataList = this.getDataList(this.getSelectedValue(newVal));
        },
        deep: true
      },
      mixinDatacomResData(newVal) {
        this.range = newVal;
        this.dataList = this.getDataList(this.getSelectedValue(newVal));
      },
      value(newVal) {
        this.dataList = this.getDataList(newVal);
      },
      modelValue(newVal) {
        this.dataList = this.getDataList(newVal);
      }
    },
    data() {
      return {
        dataList: [],
        range: [],
        contentText: {
          contentdown: "查看更多",
          contentrefresh: "加载中",
          contentnomore: "没有更多"
        },
        isLocal: true,
        styles: {
          selectedColor: "#2979ff",
          selectedTextColor: "#666"
        },
        isTop: 0
      };
    },
    computed: {
      dataValue() {
        if (this.value === "")
          return this.modelValue;
        if (this.modelValue === "")
          return this.value;
        return this.value;
      }
    },
    created() {
      if (this.localdata && this.localdata.length !== 0) {
        this.isLocal = true;
        this.range = this.localdata;
        this.dataList = this.getDataList(this.getSelectedValue(this.range));
      } else {
        if (this.collection) {
          this.isLocal = false;
          this.loadData();
        }
      }
    },
    methods: {
      loadData() {
        this.mixinDatacomGet().then((res) => {
          this.mixinDatacomResData = res.result.data;
          if (this.mixinDatacomResData.length === 0) {
            this.isLocal = false;
            this.mixinDatacomErrorMessage = this.emptyText;
          } else {
            this.isLocal = true;
          }
        }).catch((err) => {
          this.mixinDatacomErrorMessage = err.message;
        });
      },
      /**
       * 获取父元素实例
       */
      getForm(name = "uniForms") {
        let parent = this.$parent;
        let parentName = parent.$options.name;
        while (parentName !== name) {
          parent = parent.$parent;
          if (!parent)
            return false;
          parentName = parent.$options.name;
        }
        return parent;
      },
      change(e2) {
        const values = e2.detail.value;
        let detail = {
          value: [],
          data: []
        };
        if (this.multiple) {
          this.range.forEach((item) => {
            if (values.includes(item[this.map.value] + "")) {
              detail.value.push(item[this.map.value]);
              detail.data.push(item);
            }
          });
        } else {
          const range = this.range.find((item) => item[this.map.value] + "" === values);
          if (range) {
            detail = {
              value: range[this.map.value],
              data: range
            };
          }
        }
        this.$emit("input", detail.value);
        this.$emit("update:modelValue", detail.value);
        this.$emit("change", {
          detail
        });
        if (this.multiple) {
          this.dataList = this.getDataList(detail.value, true);
        } else {
          this.dataList = this.getDataList(detail.value);
        }
      },
      /**
       * 获取渲染的新数组
       * @param {Object} value 选中内容
       */
      getDataList(value) {
        let dataList = JSON.parse(JSON.stringify(this.range));
        let list = [];
        if (this.multiple) {
          if (!Array.isArray(value)) {
            value = [];
          }
        }
        dataList.forEach((item, index) => {
          item.disabled = item.disable || item.disabled || false;
          if (this.multiple) {
            if (value.length > 0) {
              let have = value.find((val) => val === item[this.map.value]);
              item.selected = have !== void 0;
            } else {
              item.selected = false;
            }
          } else {
            item.selected = value === item[this.map.value];
          }
          list.push(item);
        });
        return this.setRange(list);
      },
      /**
       * 处理最大最小值
       * @param {Object} list
       */
      setRange(list) {
        let selectList = list.filter((item) => item.selected);
        let min = Number(this.min) || 0;
        let max = Number(this.max) || "";
        list.forEach((item, index) => {
          if (this.multiple) {
            if (selectList.length <= min) {
              let have = selectList.find((val) => val[this.map.value] === item[this.map.value]);
              if (have !== void 0) {
                item.disabled = true;
              }
            }
            if (selectList.length >= max && max !== "") {
              let have = selectList.find((val) => val[this.map.value] === item[this.map.value]);
              if (have === void 0) {
                item.disabled = true;
              }
            }
          }
          this.setStyles(item, index);
          list[index] = item;
        });
        return list;
      },
      /**
       * 设置 class
       * @param {Object} item
       * @param {Object} index
       */
      setStyles(item, index) {
        item.styleBackgroud = this.setStyleBackgroud(item);
        item.styleIcon = this.setStyleIcon(item);
        item.styleIconText = this.setStyleIconText(item);
        item.styleRightIcon = this.setStyleRightIcon(item);
      },
      /**
       * 获取选中值
       * @param {Object} range
       */
      getSelectedValue(range) {
        if (!this.multiple)
          return this.dataValue;
        let selectedArr = [];
        range.forEach((item) => {
          if (item.selected) {
            selectedArr.push(item[this.map.value]);
          }
        });
        return this.dataValue.length > 0 ? this.dataValue : selectedArr;
      },
      /**
       * 设置背景样式
       */
      setStyleBackgroud(item) {
        let styles = {};
        let selectedColor = this.selectedColor ? this.selectedColor : "#2979ff";
        if (this.selectedColor) {
          if (this.mode !== "list") {
            styles["border-color"] = item.selected ? selectedColor : "#DCDFE6";
          }
          if (this.mode === "tag") {
            styles["background-color"] = item.selected ? selectedColor : "#f5f5f5";
          }
        }
        let classles = "";
        for (let i2 in styles) {
          classles += `${i2}:${styles[i2]};`;
        }
        return classles;
      },
      setStyleIcon(item) {
        let styles = {};
        let classles = "";
        if (this.selectedColor) {
          let selectedColor = this.selectedColor ? this.selectedColor : "#2979ff";
          styles["background-color"] = item.selected ? selectedColor : "#fff";
          styles["border-color"] = item.selected ? selectedColor : "#DCDFE6";
          if (!item.selected && item.disabled) {
            styles["background-color"] = "#F2F6FC";
            styles["border-color"] = item.selected ? selectedColor : "#DCDFE6";
          }
        }
        for (let i2 in styles) {
          classles += `${i2}:${styles[i2]};`;
        }
        return classles;
      },
      setStyleIconText(item) {
        let styles = {};
        let classles = "";
        if (this.selectedColor) {
          let selectedColor = this.selectedColor ? this.selectedColor : "#2979ff";
          if (this.mode === "tag") {
            styles.color = item.selected ? this.selectedTextColor ? this.selectedTextColor : "#fff" : "#666";
          } else {
            styles.color = item.selected ? this.selectedTextColor ? this.selectedTextColor : selectedColor : "#666";
          }
          if (!item.selected && item.disabled) {
            styles.color = "#999";
          }
        }
        for (let i2 in styles) {
          classles += `${i2}:${styles[i2]};`;
        }
        return classles;
      },
      setStyleRightIcon(item) {
        let styles = {};
        let classles = "";
        if (this.mode === "list") {
          styles["border-color"] = item.selected ? this.styles.selectedColor : "#DCDFE6";
        }
        for (let i2 in styles) {
          classles += `${i2}:${styles[i2]};`;
        }
        return classles;
      }
    }
  };
  function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_load_more = resolveEasycom(vue.resolveDynamicComponent("uni-load-more"), __easycom_0$6);
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: "uni-data-checklist",
        style: vue.normalizeStyle({ "margin-top": $data.isTop + "px" })
      },
      [
        !$data.isLocal ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "uni-data-loading"
        }, [
          !_ctx.mixinDatacomErrorMessage ? (vue.openBlock(), vue.createBlock(_component_uni_load_more, {
            key: 0,
            status: "loading",
            iconType: "snow",
            iconSize: 18,
            "content-text": $data.contentText
          }, null, 8, ["content-text"])) : (vue.openBlock(), vue.createElementBlock(
            "text",
            { key: 1 },
            vue.toDisplayString(_ctx.mixinDatacomErrorMessage),
            1
            /* TEXT */
          ))
        ])) : (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          { key: 1 },
          [
            $props.multiple ? (vue.openBlock(), vue.createElementBlock(
              "checkbox-group",
              {
                key: 0,
                class: vue.normalizeClass(["checklist-group", { "is-list": $props.mode === "list" || $props.wrap }]),
                onChange: _cache[0] || (_cache[0] = (...args) => $options.change && $options.change(...args))
              },
              [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList($data.dataList, (item, index) => {
                    return vue.openBlock(), vue.createElementBlock(
                      "label",
                      {
                        class: vue.normalizeClass(["checklist-box", ["is--" + $props.mode, item.selected ? "is-checked" : "", $props.disabled || !!item.disabled ? "is-disable" : "", index !== 0 && $props.mode === "list" ? "is-list-border" : ""]]),
                        style: vue.normalizeStyle(item.styleBackgroud),
                        key: index
                      },
                      [
                        vue.createElementVNode("checkbox", {
                          class: "hidden",
                          hidden: "",
                          disabled: $props.disabled || !!item.disabled,
                          value: item[$props.map.value] + "",
                          checked: item.selected
                        }, null, 8, ["disabled", "value", "checked"]),
                        $props.mode !== "tag" && $props.mode !== "list" || $props.mode === "list" && $props.icon === "left" ? (vue.openBlock(), vue.createElementBlock(
                          "view",
                          {
                            key: 0,
                            class: "checkbox__inner",
                            style: vue.normalizeStyle(item.styleIcon)
                          },
                          [
                            vue.createElementVNode("view", { class: "checkbox__inner-icon" })
                          ],
                          4
                          /* STYLE */
                        )) : vue.createCommentVNode("v-if", true),
                        vue.createElementVNode(
                          "view",
                          {
                            class: vue.normalizeClass(["checklist-content", { "list-content": $props.mode === "list" && $props.icon === "left" }])
                          },
                          [
                            vue.createElementVNode(
                              "text",
                              {
                                class: "checklist-text",
                                style: vue.normalizeStyle(item.styleIconText)
                              },
                              vue.toDisplayString(item[$props.map.text]),
                              5
                              /* TEXT, STYLE */
                            ),
                            $props.mode === "list" && $props.icon === "right" ? (vue.openBlock(), vue.createElementBlock(
                              "view",
                              {
                                key: 0,
                                class: "checkobx__list",
                                style: vue.normalizeStyle(item.styleBackgroud)
                              },
                              null,
                              4
                              /* STYLE */
                            )) : vue.createCommentVNode("v-if", true)
                          ],
                          2
                          /* CLASS */
                        )
                      ],
                      6
                      /* CLASS, STYLE */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              34
              /* CLASS, NEED_HYDRATION */
            )) : (vue.openBlock(), vue.createElementBlock(
              "radio-group",
              {
                key: 1,
                class: vue.normalizeClass(["checklist-group", { "is-list": $props.mode === "list", "is-wrap": $props.wrap }]),
                onChange: _cache[1] || (_cache[1] = (...args) => $options.change && $options.change(...args))
              },
              [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList($data.dataList, (item, index) => {
                    return vue.openBlock(), vue.createElementBlock(
                      "label",
                      {
                        class: vue.normalizeClass(["checklist-box", ["is--" + $props.mode, item.selected ? "is-checked" : "", $props.disabled || !!item.disabled ? "is-disable" : "", index !== 0 && $props.mode === "list" ? "is-list-border" : ""]]),
                        style: vue.normalizeStyle(item.styleBackgroud),
                        key: index
                      },
                      [
                        vue.createElementVNode("radio", {
                          class: "hidden",
                          hidden: "",
                          disabled: $props.disabled || item.disabled,
                          value: item[$props.map.value] + "",
                          checked: item.selected
                        }, null, 8, ["disabled", "value", "checked"]),
                        $props.mode !== "tag" && $props.mode !== "list" || $props.mode === "list" && $props.icon === "left" ? (vue.openBlock(), vue.createElementBlock(
                          "view",
                          {
                            key: 0,
                            class: "radio__inner",
                            style: vue.normalizeStyle(item.styleBackgroud)
                          },
                          [
                            vue.createElementVNode(
                              "view",
                              {
                                class: "radio__inner-icon",
                                style: vue.normalizeStyle(item.styleIcon)
                              },
                              null,
                              4
                              /* STYLE */
                            )
                          ],
                          4
                          /* STYLE */
                        )) : vue.createCommentVNode("v-if", true),
                        vue.createElementVNode(
                          "view",
                          {
                            class: vue.normalizeClass(["checklist-content", { "list-content": $props.mode === "list" && $props.icon === "left" }])
                          },
                          [
                            vue.createElementVNode(
                              "text",
                              {
                                class: "checklist-text",
                                style: vue.normalizeStyle(item.styleIconText)
                              },
                              vue.toDisplayString(item[$props.map.text]),
                              5
                              /* TEXT, STYLE */
                            ),
                            $props.mode === "list" && $props.icon === "right" ? (vue.openBlock(), vue.createElementBlock(
                              "view",
                              {
                                key: 0,
                                style: vue.normalizeStyle(item.styleRightIcon),
                                class: "checkobx__list"
                              },
                              null,
                              4
                              /* STYLE */
                            )) : vue.createCommentVNode("v-if", true)
                          ],
                          2
                          /* CLASS */
                        )
                      ],
                      6
                      /* CLASS, STYLE */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              34
              /* CLASS, NEED_HYDRATION */
            ))
          ],
          64
          /* STABLE_FRAGMENT */
        ))
      ],
      4
      /* STYLE */
    );
  }
  const __easycom_5$1 = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$U], ["__scopeId", "data-v-2f788efd"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-data-checkbox/components/uni-data-checkbox/uni-data-checkbox.vue"]]);
  const _sfc_main$U = {
    name: "uniFormsItem",
    options: {
      virtualHost: true
    },
    provide() {
      return {
        uniFormItem: this
      };
    },
    inject: {
      form: {
        from: "uniForm",
        default: null
      }
    },
    props: {
      // 表单校验规则
      rules: {
        type: Array,
        default() {
          return null;
        }
      },
      // 表单域的属性名，在使用校验规则时必填
      name: {
        type: [String, Array],
        default: ""
      },
      required: {
        type: Boolean,
        default: false
      },
      label: {
        type: String,
        default: ""
      },
      // label的宽度
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      // label 居中方式，默认 left 取值 left/center/right
      labelAlign: {
        type: String,
        default: ""
      },
      // 强制显示错误信息
      errorMessage: {
        type: [String, Boolean],
        default: ""
      },
      // 1.4.0 弃用，统一使用 form 的校验时机
      // validateTrigger: {
      // 	type: String,
      // 	default: ''
      // },
      // 1.4.0 弃用，统一使用 form 的label 位置
      // labelPosition: {
      // 	type: String,
      // 	default: ''
      // },
      // 1.4.0 以下属性已经废弃，请使用  #label 插槽代替
      leftIcon: String,
      iconColor: {
        type: String,
        default: "#606266"
      }
    },
    data() {
      return {
        errMsg: "",
        userRules: null,
        localLabelAlign: "left",
        localLabelWidth: "70px",
        localLabelPos: "left",
        border: false,
        isFirstBorder: false
      };
    },
    computed: {
      // 处理错误信息
      msg() {
        return this.errorMessage || this.errMsg;
      }
    },
    watch: {
      // 规则发生变化通知子组件更新
      "form.formRules"(val) {
        this.init();
      },
      "form.labelWidth"(val) {
        this.localLabelWidth = this._labelWidthUnit(val);
      },
      "form.labelPosition"(val) {
        this.localLabelPos = this._labelPosition();
      },
      "form.labelAlign"(val) {
      }
    },
    created() {
      this.init(true);
      if (this.name && this.form) {
        this.$watch(
          () => {
            const val = this.form._getDataValue(this.name, this.form.localData);
            return val;
          },
          (value, oldVal) => {
            const isEqual2 = this.form._isEqual(value, oldVal);
            if (!isEqual2) {
              const val = this.itemSetValue(value);
              this.onFieldChange(val, false);
            }
          },
          {
            immediate: false
          }
        );
      }
    },
    unmounted() {
      this.__isUnmounted = true;
      this.unInit();
    },
    methods: {
      /**
       * 外部调用方法
       * 设置规则 ，主要用于小程序自定义检验规则
       * @param {Array} rules 规则源数据
       */
      setRules(rules = null) {
        this.userRules = rules;
        this.init(false);
      },
      // 兼容老版本表单组件
      setValue() {
      },
      /**
       * 外部调用方法
       * 校验数据
       * @param {any} value 需要校验的数据
       * @param {boolean} 是否立即校验
       * @return {Array|null} 校验内容
       */
      async onFieldChange(value, formtrigger = true) {
        const {
          formData,
          localData,
          errShowType,
          validateCheck,
          validateTrigger,
          _isRequiredField,
          _realName
        } = this.form;
        const name = _realName(this.name);
        if (!value) {
          value = this.form.formData[name];
        }
        const ruleLen = this.itemRules.rules && this.itemRules.rules.length;
        if (!this.validator || !ruleLen || ruleLen === 0)
          return;
        const isRequiredField2 = _isRequiredField(this.itemRules.rules || []);
        let result = null;
        if (validateTrigger === "bind" || formtrigger) {
          result = await this.validator.validateUpdate(
            {
              [name]: value
            },
            formData
          );
          if (!isRequiredField2 && (value === void 0 || value === "")) {
            result = null;
          }
          if (result && result.errorMessage) {
            if (errShowType === "undertext") {
              this.errMsg = !result ? "" : result.errorMessage;
            }
            if (errShowType === "toast") {
              uni.showToast({
                title: result.errorMessage || "校验错误",
                icon: "none"
              });
            }
            if (errShowType === "modal") {
              uni.showModal({
                title: "提示",
                content: result.errorMessage || "校验错误"
              });
            }
          } else {
            this.errMsg = "";
          }
          validateCheck(result ? result : null);
        } else {
          this.errMsg = "";
        }
        return result ? result : null;
      },
      /**
       * 初始组件数据
       */
      init(type = false) {
        const {
          validator,
          formRules,
          childrens,
          formData,
          localData,
          _realName,
          labelWidth,
          _getDataValue,
          _setDataValue
        } = this.form || {};
        this.localLabelAlign = this._justifyContent();
        this.localLabelWidth = this._labelWidthUnit(labelWidth);
        this.localLabelPos = this._labelPosition();
        this.form && type && childrens.push(this);
        if (!validator || !formRules)
          return;
        if (!this.form.isFirstBorder) {
          this.form.isFirstBorder = true;
          this.isFirstBorder = true;
        }
        if (this.group) {
          if (!this.group.isFirstBorder) {
            this.group.isFirstBorder = true;
            this.isFirstBorder = true;
          }
        }
        this.border = this.form.border;
        const name = _realName(this.name);
        const itemRule = this.userRules || this.rules;
        if (typeof formRules === "object" && itemRule) {
          formRules[name] = {
            rules: itemRule
          };
          validator.updateSchema(formRules);
        }
        const itemRules = formRules[name] || {};
        this.itemRules = itemRules;
        this.validator = validator;
        this.itemSetValue(_getDataValue(this.name, localData));
      },
      unInit() {
        if (this.form) {
          const {
            childrens,
            formData,
            _realName
          } = this.form;
          childrens.forEach((item, index) => {
            if (item === this) {
              this.form.childrens.splice(index, 1);
              delete formData[_realName(item.name)];
            }
          });
        }
      },
      // 设置item 的值
      itemSetValue(value) {
        const name = this.form._realName(this.name);
        const rules = this.itemRules.rules || [];
        const val = this.form._getValue(name, value, rules);
        this.form._setDataValue(name, this.form.formData, val);
        return val;
      },
      /**
       * 移除该表单项的校验结果
       */
      clearValidate() {
        this.errMsg = "";
      },
      // 是否显示星号
      _isRequired() {
        return this.required;
      },
      // 处理对齐方式
      _justifyContent() {
        if (this.form) {
          const {
            labelAlign
          } = this.form;
          let labelAli = this.labelAlign ? this.labelAlign : labelAlign;
          if (labelAli === "left")
            return "flex-start";
          if (labelAli === "center")
            return "center";
          if (labelAli === "right")
            return "flex-end";
        }
        return "flex-start";
      },
      // 处理 label宽度单位 ,继承父元素的值
      _labelWidthUnit(labelWidth) {
        return this.num2px(this.labelWidth ? this.labelWidth : labelWidth || (this.label ? 70 : "auto"));
      },
      // 处理 label 位置
      _labelPosition() {
        if (this.form)
          return this.form.labelPosition || "left";
        return "left";
      },
      /**
       * 触发时机
       * @param {Object} rule 当前规则内时机
       * @param {Object} itemRlue 当前组件时机
       * @param {Object} parentRule 父组件时机
       */
      isTrigger(rule, itemRlue, parentRule) {
        if (rule === "submit" || !rule) {
          if (rule === void 0) {
            if (itemRlue !== "bind") {
              if (!itemRlue) {
                return parentRule === "" ? "bind" : "submit";
              }
              return "submit";
            }
            return "bind";
          }
          return "submit";
        }
        return "bind";
      },
      num2px(num) {
        if (typeof num === "number") {
          return `${num}px`;
        }
        return num;
      }
    }
  };
  function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["uni-forms-item", ["is-direction-" + $data.localLabelPos, $data.border ? "uni-forms-item--border" : "", $data.border && $data.isFirstBorder ? "is-first-border" : ""]])
      },
      [
        vue.renderSlot(_ctx.$slots, "label", {}, () => [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["uni-forms-item__label", { "no-label": !$props.label && !$props.required }]),
              style: vue.normalizeStyle({ width: $data.localLabelWidth, justifyContent: $data.localLabelAlign })
            },
            [
              $props.required ? (vue.openBlock(), vue.createElementBlock("text", {
                key: 0,
                class: "is-required"
              }, "*")) : vue.createCommentVNode("v-if", true),
              vue.createElementVNode(
                "text",
                null,
                vue.toDisplayString($props.label),
                1
                /* TEXT */
              )
            ],
            6
            /* CLASS, STYLE */
          )
        ], true),
        vue.createElementVNode("view", { class: "uni-forms-item__content" }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true),
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["uni-forms-item__error", { "msg--active": $options.msg }])
            },
            [
              vue.createElementVNode(
                "text",
                null,
                vue.toDisplayString($options.msg),
                1
                /* TEXT */
              )
            ],
            2
            /* CLASS */
          )
        ])
      ],
      2
      /* CLASS */
    );
  }
  const __easycom_6$1 = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$T], ["__scopeId", "data-v-462874dd"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-forms/components/uni-forms-item/uni-forms-item.vue"]]);
  function obj2strClass(obj) {
    let classess = "";
    for (let key in obj) {
      const val = obj[key];
      if (val) {
        classess += `${key} `;
      }
    }
    return classess;
  }
  function obj2strStyle(obj) {
    let style = "";
    for (let key in obj) {
      const val = obj[key];
      style += `${key}:${val};`;
    }
    return style;
  }
  const _sfc_main$T = {
    name: "uni-easyinput",
    emits: [
      "click",
      "iconClick",
      "update:modelValue",
      "input",
      "focus",
      "blur",
      "confirm",
      "clear",
      "eyes",
      "change",
      "keyboardheightchange"
    ],
    model: {
      prop: "modelValue",
      event: "update:modelValue"
    },
    options: {
      virtualHost: true
    },
    inject: {
      form: {
        from: "uniForm",
        default: null
      },
      formItem: {
        from: "uniFormItem",
        default: null
      }
    },
    props: {
      name: String,
      value: [Number, String],
      modelValue: [Number, String],
      type: {
        type: String,
        default: "text"
      },
      clearable: {
        type: Boolean,
        default: true
      },
      autoHeight: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: " "
      },
      placeholderStyle: String,
      focus: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      maxlength: {
        type: [Number, String],
        default: 140
      },
      confirmType: {
        type: String,
        default: "done"
      },
      clearSize: {
        type: [Number, String],
        default: 24
      },
      inputBorder: {
        type: Boolean,
        default: true
      },
      prefixIcon: {
        type: String,
        default: ""
      },
      suffixIcon: {
        type: String,
        default: ""
      },
      trim: {
        type: [Boolean, String],
        default: false
      },
      cursorSpacing: {
        type: Number,
        default: 0
      },
      passwordIcon: {
        type: Boolean,
        default: true
      },
      adjustPosition: {
        type: Boolean,
        default: true
      },
      primaryColor: {
        type: String,
        default: "#2979ff"
      },
      styles: {
        type: Object,
        default() {
          return {
            color: "#333",
            backgroundColor: "#fff",
            disableColor: "#F7F6F6",
            borderColor: "#e5e5e5"
          };
        }
      },
      errorMessage: {
        type: [String, Boolean],
        default: ""
      }
    },
    data() {
      return {
        focused: false,
        val: "",
        showMsg: "",
        border: false,
        isFirstBorder: false,
        showClearIcon: false,
        showPassword: false,
        focusShow: false,
        localMsg: "",
        isEnter: false
        // 用于判断当前是否是使用回车操作
      };
    },
    computed: {
      // 输入框内是否有值
      isVal() {
        const val = this.val;
        if (val || val === 0) {
          return true;
        }
        return false;
      },
      msg() {
        return this.localMsg || this.errorMessage;
      },
      // 因为uniapp的input组件的maxlength组件必须要数值，这里转为数值，用户可以传入字符串数值
      inputMaxlength() {
        return Number(this.maxlength);
      },
      // 处理外层样式的style
      boxStyle() {
        return `color:${this.inputBorder && this.msg ? "#e43d33" : this.styles.color};`;
      },
      // input 内容的类和样式处理
      inputContentClass() {
        return obj2strClass({
          "is-input-border": this.inputBorder,
          "is-input-error-border": this.inputBorder && this.msg,
          "is-textarea": this.type === "textarea",
          "is-disabled": this.disabled,
          "is-focused": this.focusShow
        });
      },
      inputContentStyle() {
        const focusColor = this.focusShow ? this.primaryColor : this.styles.borderColor;
        const borderColor = this.inputBorder && this.msg ? "#dd524d" : focusColor;
        return obj2strStyle({
          "border-color": borderColor || "#e5e5e5",
          "background-color": this.disabled ? this.styles.disableColor : this.styles.backgroundColor
        });
      },
      // input右侧样式
      inputStyle() {
        const paddingRight = this.type === "password" || this.clearable || this.prefixIcon ? "" : "10px";
        return obj2strStyle({
          "padding-right": paddingRight,
          "padding-left": this.prefixIcon ? "" : "10px"
        });
      }
    },
    watch: {
      value(newVal) {
        this.val = newVal;
      },
      modelValue(newVal) {
        this.val = newVal;
      },
      focus(newVal) {
        this.$nextTick(() => {
          this.focused = this.focus;
          this.focusShow = this.focus;
        });
      }
    },
    created() {
      this.init();
      if (this.form && this.formItem) {
        this.$watch("formItem.errMsg", (newVal) => {
          this.localMsg = newVal;
        });
      }
    },
    mounted() {
      this.$nextTick(() => {
        this.focused = this.focus;
        this.focusShow = this.focus;
      });
    },
    methods: {
      /**
       * 初始化变量值
       */
      init() {
        if (this.value || this.value === 0) {
          this.val = this.value;
        } else if (this.modelValue || this.modelValue === 0 || this.modelValue === "") {
          this.val = this.modelValue;
        } else {
          this.val = null;
        }
      },
      /**
       * 点击图标时触发
       * @param {Object} type
       */
      onClickIcon(type) {
        this.$emit("iconClick", type);
      },
      /**
       * 显示隐藏内容，密码框时生效
       */
      onEyes() {
        this.showPassword = !this.showPassword;
        this.$emit("eyes", this.showPassword);
      },
      /**
       * 输入时触发
       * @param {Object} event
       */
      onInput(event) {
        let value = event.detail.value;
        if (this.trim) {
          if (typeof this.trim === "boolean" && this.trim) {
            value = this.trimStr(value);
          }
          if (typeof this.trim === "string") {
            value = this.trimStr(value, this.trim);
          }
        }
        if (this.errMsg)
          this.errMsg = "";
        this.val = value;
        this.$emit("input", value);
        this.$emit("update:modelValue", value);
      },
      /**
       * 外部调用方法
       * 获取焦点时触发
       * @param {Object} event
       */
      onFocus() {
        this.$nextTick(() => {
          this.focused = true;
        });
        this.$emit("focus", null);
      },
      _Focus(event) {
        this.focusShow = true;
        this.$emit("focus", event);
      },
      /**
       * 外部调用方法
       * 失去焦点时触发
       * @param {Object} event
       */
      onBlur() {
        this.focused = false;
        this.$emit("blur", null);
      },
      _Blur(event) {
        event.detail.value;
        this.focusShow = false;
        this.$emit("blur", event);
        if (this.isEnter === false) {
          this.$emit("change", this.val);
        }
        if (this.form && this.formItem) {
          const { validateTrigger } = this.form;
          if (validateTrigger === "blur") {
            this.formItem.onFieldChange();
          }
        }
      },
      /**
       * 按下键盘的发送键
       * @param {Object} e
       */
      onConfirm(e2) {
        this.$emit("confirm", this.val);
        this.isEnter = true;
        this.$emit("change", this.val);
        this.$nextTick(() => {
          this.isEnter = false;
        });
      },
      /**
       * 清理内容
       * @param {Object} event
       */
      onClear(event) {
        this.val = "";
        this.$emit("input", "");
        this.$emit("update:modelValue", "");
        this.$emit("clear");
      },
      /**
       * 键盘高度发生变化的时候触发此事件
       * 兼容性：微信小程序2.7.0+、App 3.1.0+
       * @param {Object} event
       */
      onkeyboardheightchange(event) {
        this.$emit("keyboardheightchange", event);
      },
      /**
       * 去除空格
       */
      trimStr(str, pos = "both") {
        if (pos === "both") {
          return str.trim();
        } else if (pos === "left") {
          return str.trimLeft();
        } else if (pos === "right") {
          return str.trimRight();
        } else if (pos === "start") {
          return str.trimStart();
        } else if (pos === "end") {
          return str.trimEnd();
        } else if (pos === "all") {
          return str.replace(/\s+/g, "");
        } else if (pos === "none") {
          return str;
        }
        return str;
      }
    }
  };
  function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["uni-easyinput", { "uni-easyinput-error": $options.msg }]),
        style: vue.normalizeStyle($options.boxStyle)
      },
      [
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["uni-easyinput__content", $options.inputContentClass]),
            style: vue.normalizeStyle($options.inputContentStyle)
          },
          [
            $props.prefixIcon ? (vue.openBlock(), vue.createBlock(_component_uni_icons, {
              key: 0,
              class: "content-clear-icon",
              type: $props.prefixIcon,
              color: "#c0c4cc",
              onClick: _cache[0] || (_cache[0] = ($event) => $options.onClickIcon("prefix")),
              size: "22"
            }, null, 8, ["type"])) : vue.createCommentVNode("v-if", true),
            vue.renderSlot(_ctx.$slots, "left", {}, void 0, true),
            $props.type === "textarea" ? (vue.openBlock(), vue.createElementBlock("textarea", {
              key: 1,
              class: vue.normalizeClass(["uni-easyinput__content-textarea", { "input-padding": $props.inputBorder }]),
              name: $props.name,
              value: $data.val,
              placeholder: $props.placeholder,
              placeholderStyle: $props.placeholderStyle,
              disabled: $props.disabled,
              "placeholder-class": "uni-easyinput__placeholder-class",
              maxlength: $options.inputMaxlength,
              focus: $data.focused,
              autoHeight: $props.autoHeight,
              "cursor-spacing": $props.cursorSpacing,
              "adjust-position": $props.adjustPosition,
              onInput: _cache[1] || (_cache[1] = (...args) => $options.onInput && $options.onInput(...args)),
              onBlur: _cache[2] || (_cache[2] = (...args) => $options._Blur && $options._Blur(...args)),
              onFocus: _cache[3] || (_cache[3] = (...args) => $options._Focus && $options._Focus(...args)),
              onConfirm: _cache[4] || (_cache[4] = (...args) => $options.onConfirm && $options.onConfirm(...args)),
              onKeyboardheightchange: _cache[5] || (_cache[5] = (...args) => $options.onkeyboardheightchange && $options.onkeyboardheightchange(...args))
            }, null, 42, ["name", "value", "placeholder", "placeholderStyle", "disabled", "maxlength", "focus", "autoHeight", "cursor-spacing", "adjust-position"])) : (vue.openBlock(), vue.createElementBlock("input", {
              key: 2,
              type: $props.type === "password" ? "text" : $props.type,
              class: "uni-easyinput__content-input",
              style: vue.normalizeStyle($options.inputStyle),
              name: $props.name,
              value: $data.val,
              password: !$data.showPassword && $props.type === "password",
              placeholder: $props.placeholder,
              placeholderStyle: $props.placeholderStyle,
              "placeholder-class": "uni-easyinput__placeholder-class",
              disabled: $props.disabled,
              maxlength: $options.inputMaxlength,
              focus: $data.focused,
              confirmType: $props.confirmType,
              "cursor-spacing": $props.cursorSpacing,
              "adjust-position": $props.adjustPosition,
              onFocus: _cache[6] || (_cache[6] = (...args) => $options._Focus && $options._Focus(...args)),
              onBlur: _cache[7] || (_cache[7] = (...args) => $options._Blur && $options._Blur(...args)),
              onInput: _cache[8] || (_cache[8] = (...args) => $options.onInput && $options.onInput(...args)),
              onConfirm: _cache[9] || (_cache[9] = (...args) => $options.onConfirm && $options.onConfirm(...args)),
              onKeyboardheightchange: _cache[10] || (_cache[10] = (...args) => $options.onkeyboardheightchange && $options.onkeyboardheightchange(...args))
            }, null, 44, ["type", "name", "value", "password", "placeholder", "placeholderStyle", "disabled", "maxlength", "focus", "confirmType", "cursor-spacing", "adjust-position"])),
            $props.type === "password" && $props.passwordIcon ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 3 },
              [
                vue.createCommentVNode(" 开启密码时显示小眼睛 "),
                $options.isVal ? (vue.openBlock(), vue.createBlock(_component_uni_icons, {
                  key: 0,
                  class: vue.normalizeClass(["content-clear-icon", { "is-textarea-icon": $props.type === "textarea" }]),
                  type: $data.showPassword ? "eye-slash-filled" : "eye-filled",
                  size: 22,
                  color: $data.focusShow ? $props.primaryColor : "#c0c4cc",
                  onClick: $options.onEyes
                }, null, 8, ["class", "type", "color", "onClick"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : vue.createCommentVNode("v-if", true),
            $props.suffixIcon ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 4 },
              [
                $props.suffixIcon ? (vue.openBlock(), vue.createBlock(_component_uni_icons, {
                  key: 0,
                  class: "content-clear-icon",
                  type: $props.suffixIcon,
                  color: "#c0c4cc",
                  onClick: _cache[11] || (_cache[11] = ($event) => $options.onClickIcon("suffix")),
                  size: "22"
                }, null, 8, ["type"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 5 },
              [
                $props.clearable && $options.isVal && !$props.disabled && $props.type !== "textarea" ? (vue.openBlock(), vue.createBlock(_component_uni_icons, {
                  key: 0,
                  class: vue.normalizeClass(["content-clear-icon", { "is-textarea-icon": $props.type === "textarea" }]),
                  type: "clear",
                  size: $props.clearSize,
                  color: $options.msg ? "#dd524d" : $data.focusShow ? $props.primaryColor : "#c0c4cc",
                  onClick: $options.onClear
                }, null, 8, ["class", "size", "color", "onClick"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )),
            vue.renderSlot(_ctx.$slots, "right", {}, void 0, true)
          ],
          6
          /* CLASS, STYLE */
        )
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const __easycom_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$S], ["__scopeId", "data-v-09fd5285"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-easyinput/components/uni-easyinput/uni-easyinput.vue"]]);
  var pattern = {
    email: /^\S+?@\S+?\.\S+?$/,
    idcard: /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/,
    url: new RegExp(
      "^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$",
      "i"
    )
  };
  const FORMAT_MAPPING = {
    "int": "integer",
    "bool": "boolean",
    "double": "number",
    "long": "number",
    "password": "string"
    // "fileurls": 'array'
  };
  function formatMessage(args, resources = "") {
    var defaultMessage = ["label"];
    defaultMessage.forEach((item) => {
      if (args[item] === void 0) {
        args[item] = "";
      }
    });
    let str = resources;
    for (let key in args) {
      let reg = new RegExp("{" + key + "}");
      str = str.replace(reg, args[key]);
    }
    return str;
  }
  function isEmptyValue(value, type) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (typeof value === "string" && !value) {
      return true;
    }
    if (Array.isArray(value) && !value.length) {
      return true;
    }
    if (type === "object" && !Object.keys(value).length) {
      return true;
    }
    return false;
  }
  const types = {
    integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    string(value) {
      return typeof value === "string";
    },
    number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    "boolean": function(value) {
      return typeof value === "boolean";
    },
    "float": function(value) {
      return types.number(value) && !types.integer(value);
    },
    array(value) {
      return Array.isArray(value);
    },
    object(value) {
      return typeof value === "object" && !types.array(value);
    },
    date(value) {
      return value instanceof Date;
    },
    timestamp(value) {
      if (!this.integer(value) || Math.abs(value).toString().length > 16) {
        return false;
      }
      return true;
    },
    file(value) {
      return typeof value.url === "string";
    },
    email(value) {
      return typeof value === "string" && !!value.match(pattern.email) && value.length < 255;
    },
    url(value) {
      return typeof value === "string" && !!value.match(pattern.url);
    },
    pattern(reg, value) {
      try {
        return new RegExp(reg).test(value);
      } catch (e2) {
        return false;
      }
    },
    method(value) {
      return typeof value === "function";
    },
    idcard(value) {
      return typeof value === "string" && !!value.match(pattern.idcard);
    },
    "url-https"(value) {
      return this.url(value) && value.startsWith("https://");
    },
    "url-scheme"(value) {
      return value.startsWith("://");
    },
    "url-web"(value) {
      return false;
    }
  };
  class RuleValidator {
    constructor(message) {
      this._message = message;
    }
    async validateRule(fieldKey, fieldValue, value, data, allData) {
      var result = null;
      let rules = fieldValue.rules;
      let hasRequired = rules.findIndex((item) => {
        return item.required;
      });
      if (hasRequired < 0) {
        if (value === null || value === void 0) {
          return result;
        }
        if (typeof value === "string" && !value.length) {
          return result;
        }
      }
      var message = this._message;
      if (rules === void 0) {
        return message["default"];
      }
      for (var i2 = 0; i2 < rules.length; i2++) {
        let rule = rules[i2];
        let vt2 = this._getValidateType(rule);
        Object.assign(rule, {
          label: fieldValue.label || `["${fieldKey}"]`
        });
        if (RuleValidatorHelper[vt2]) {
          result = RuleValidatorHelper[vt2](rule, value, message);
          if (result != null) {
            break;
          }
        }
        if (rule.validateExpr) {
          let now2 = Date.now();
          let resultExpr = rule.validateExpr(value, allData, now2);
          if (resultExpr === false) {
            result = this._getMessage(rule, rule.errorMessage || this._message["default"]);
            break;
          }
        }
        if (rule.validateFunction) {
          result = await this.validateFunction(rule, value, data, allData, vt2);
          if (result !== null) {
            break;
          }
        }
      }
      if (result !== null) {
        result = message.TAG + result;
      }
      return result;
    }
    async validateFunction(rule, value, data, allData, vt2) {
      let result = null;
      try {
        let callbackMessage = null;
        const res = await rule.validateFunction(rule, value, allData || data, (message) => {
          callbackMessage = message;
        });
        if (callbackMessage || typeof res === "string" && res || res === false) {
          result = this._getMessage(rule, callbackMessage || res, vt2);
        }
      } catch (e2) {
        result = this._getMessage(rule, e2.message, vt2);
      }
      return result;
    }
    _getMessage(rule, message, vt2) {
      return formatMessage(rule, message || rule.errorMessage || this._message[vt2] || message["default"]);
    }
    _getValidateType(rule) {
      var result = "";
      if (rule.required) {
        result = "required";
      } else if (rule.format) {
        result = "format";
      } else if (rule.arrayType) {
        result = "arrayTypeFormat";
      } else if (rule.range) {
        result = "range";
      } else if (rule.maximum !== void 0 || rule.minimum !== void 0) {
        result = "rangeNumber";
      } else if (rule.maxLength !== void 0 || rule.minLength !== void 0) {
        result = "rangeLength";
      } else if (rule.pattern) {
        result = "pattern";
      } else if (rule.validateFunction) {
        result = "validateFunction";
      }
      return result;
    }
  }
  const RuleValidatorHelper = {
    required(rule, value, message) {
      if (rule.required && isEmptyValue(value, rule.format || typeof value)) {
        return formatMessage(rule, rule.errorMessage || message.required);
      }
      return null;
    },
    range(rule, value, message) {
      const {
        range,
        errorMessage
      } = rule;
      let list = new Array(range.length);
      for (let i2 = 0; i2 < range.length; i2++) {
        const item = range[i2];
        if (types.object(item) && item.value !== void 0) {
          list[i2] = item.value;
        } else {
          list[i2] = item;
        }
      }
      let result = false;
      if (Array.isArray(value)) {
        result = new Set(value.concat(list)).size === list.length;
      } else {
        if (list.indexOf(value) > -1) {
          result = true;
        }
      }
      if (!result) {
        return formatMessage(rule, errorMessage || message["enum"]);
      }
      return null;
    },
    rangeNumber(rule, value, message) {
      if (!types.number(value)) {
        return formatMessage(rule, rule.errorMessage || message.pattern.mismatch);
      }
      let {
        minimum,
        maximum,
        exclusiveMinimum,
        exclusiveMaximum
      } = rule;
      let min = exclusiveMinimum ? value <= minimum : value < minimum;
      let max = exclusiveMaximum ? value >= maximum : value > maximum;
      if (minimum !== void 0 && min) {
        return formatMessage(rule, rule.errorMessage || message["number"][exclusiveMinimum ? "exclusiveMinimum" : "minimum"]);
      } else if (maximum !== void 0 && max) {
        return formatMessage(rule, rule.errorMessage || message["number"][exclusiveMaximum ? "exclusiveMaximum" : "maximum"]);
      } else if (minimum !== void 0 && maximum !== void 0 && (min || max)) {
        return formatMessage(rule, rule.errorMessage || message["number"].range);
      }
      return null;
    },
    rangeLength(rule, value, message) {
      if (!types.string(value) && !types.array(value)) {
        return formatMessage(rule, rule.errorMessage || message.pattern.mismatch);
      }
      let min = rule.minLength;
      let max = rule.maxLength;
      let val = value.length;
      if (min !== void 0 && val < min) {
        return formatMessage(rule, rule.errorMessage || message["length"].minLength);
      } else if (max !== void 0 && val > max) {
        return formatMessage(rule, rule.errorMessage || message["length"].maxLength);
      } else if (min !== void 0 && max !== void 0 && (val < min || val > max)) {
        return formatMessage(rule, rule.errorMessage || message["length"].range);
      }
      return null;
    },
    pattern(rule, value, message) {
      if (!types["pattern"](rule.pattern, value)) {
        return formatMessage(rule, rule.errorMessage || message.pattern.mismatch);
      }
      return null;
    },
    format(rule, value, message) {
      var customTypes = Object.keys(types);
      var format = FORMAT_MAPPING[rule.format] ? FORMAT_MAPPING[rule.format] : rule.format || rule.arrayType;
      if (customTypes.indexOf(format) > -1) {
        if (!types[format](value)) {
          return formatMessage(rule, rule.errorMessage || message.typeError);
        }
      }
      return null;
    },
    arrayTypeFormat(rule, value, message) {
      if (!Array.isArray(value)) {
        return formatMessage(rule, rule.errorMessage || message.typeError);
      }
      for (let i2 = 0; i2 < value.length; i2++) {
        const element = value[i2];
        let formatResult = this.format(rule, element, message);
        if (formatResult !== null) {
          return formatResult;
        }
      }
      return null;
    }
  };
  class SchemaValidator extends RuleValidator {
    constructor(schema, options) {
      super(SchemaValidator.message);
      this._schema = schema;
      this._options = options || null;
    }
    updateSchema(schema) {
      this._schema = schema;
    }
    async validate(data, allData) {
      let result = this._checkFieldInSchema(data);
      if (!result) {
        result = await this.invokeValidate(data, false, allData);
      }
      return result.length ? result[0] : null;
    }
    async validateAll(data, allData) {
      let result = this._checkFieldInSchema(data);
      if (!result) {
        result = await this.invokeValidate(data, true, allData);
      }
      return result;
    }
    async validateUpdate(data, allData) {
      let result = this._checkFieldInSchema(data);
      if (!result) {
        result = await this.invokeValidateUpdate(data, false, allData);
      }
      return result.length ? result[0] : null;
    }
    async invokeValidate(data, all, allData) {
      let result = [];
      let schema = this._schema;
      for (let key in schema) {
        let value = schema[key];
        let errorMessage = await this.validateRule(key, value, data[key], data, allData);
        if (errorMessage != null) {
          result.push({
            key,
            errorMessage
          });
          if (!all)
            break;
        }
      }
      return result;
    }
    async invokeValidateUpdate(data, all, allData) {
      let result = [];
      for (let key in data) {
        let errorMessage = await this.validateRule(key, this._schema[key], data[key], data, allData);
        if (errorMessage != null) {
          result.push({
            key,
            errorMessage
          });
          if (!all)
            break;
        }
      }
      return result;
    }
    _checkFieldInSchema(data) {
      var keys = Object.keys(data);
      var keys2 = Object.keys(this._schema);
      if (new Set(keys.concat(keys2)).size === keys2.length) {
        return "";
      }
      var noExistFields = keys.filter((key) => {
        return keys2.indexOf(key) < 0;
      });
      var errorMessage = formatMessage({
        field: JSON.stringify(noExistFields)
      }, SchemaValidator.message.TAG + SchemaValidator.message["defaultInvalid"]);
      return [{
        key: "invalid",
        errorMessage
      }];
    }
  }
  function Message$1() {
    return {
      TAG: "",
      default: "验证错误",
      defaultInvalid: "提交的字段{field}在数据库中并不存在",
      validateFunction: "验证无效",
      required: "{label}必填",
      "enum": "{label}超出范围",
      timestamp: "{label}格式无效",
      whitespace: "{label}不能为空",
      typeError: "{label}类型无效",
      date: {
        format: "{label}日期{value}格式无效",
        parse: "{label}日期无法解析,{value}无效",
        invalid: "{label}日期{value}无效"
      },
      length: {
        minLength: "{label}长度不能少于{minLength}",
        maxLength: "{label}长度不能超过{maxLength}",
        range: "{label}必须介于{minLength}和{maxLength}之间"
      },
      number: {
        minimum: "{label}不能小于{minimum}",
        maximum: "{label}不能大于{maximum}",
        exclusiveMinimum: "{label}不能小于等于{minimum}",
        exclusiveMaximum: "{label}不能大于等于{maximum}",
        range: "{label}必须介于{minimum}and{maximum}之间"
      },
      pattern: {
        mismatch: "{label}格式不匹配"
      }
    };
  }
  SchemaValidator.message = new Message$1();
  const deepCopy = (val) => {
    return JSON.parse(JSON.stringify(val));
  };
  const typeFilter = (format) => {
    return format === "int" || format === "double" || format === "number" || format === "timestamp";
  };
  const getValue = (key, value, rules) => {
    const isRuleNumType = rules.find((val) => val.format && typeFilter(val.format));
    const isRuleBoolType = rules.find((val) => val.format && val.format === "boolean" || val.format === "bool");
    if (!!isRuleNumType) {
      if (!value && value !== 0) {
        value = null;
      } else {
        value = isNumber(Number(value)) ? Number(value) : value;
      }
    }
    if (!!isRuleBoolType) {
      value = isBoolean(value) ? value : false;
    }
    return value;
  };
  const setDataValue = (field, formdata, value) => {
    formdata[field] = value;
    return value || "";
  };
  const getDataValue = (field, data) => {
    return objGet(data, field);
  };
  const realName = (name, data = {}) => {
    const base_name = _basePath(name);
    if (typeof base_name === "object" && Array.isArray(base_name) && base_name.length > 1) {
      const realname = base_name.reduce((a2, b2) => a2 += `#${b2}`, "_formdata_");
      return realname;
    }
    return base_name[0] || name;
  };
  const isRealName = (name) => {
    const reg = /^_formdata_#*/;
    return reg.test(name);
  };
  const rawData = (object = {}, name) => {
    let newData = JSON.parse(JSON.stringify(object));
    let formData = {};
    for (let i2 in newData) {
      let path = name2arr(i2);
      objSet(formData, path, newData[i2]);
    }
    return formData;
  };
  const name2arr = (name) => {
    let field = name.replace("_formdata_#", "");
    field = field.split("#").map((v2) => isNumber(v2) ? Number(v2) : v2);
    return field;
  };
  const objSet = (object, path, value) => {
    if (typeof object !== "object")
      return object;
    _basePath(path).reduce((o2, k, i2, _2) => {
      if (i2 === _2.length - 1) {
        o2[k] = value;
        return null;
      } else if (k in o2) {
        return o2[k];
      } else {
        o2[k] = /^[0-9]{1,}$/.test(_2[i2 + 1]) ? [] : {};
        return o2[k];
      }
    }, object);
    return object;
  };
  function _basePath(path) {
    if (Array.isArray(path))
      return path;
    return path.replace(/\[/g, ".").replace(/\]/g, "").split(".");
  }
  const objGet = (object, path, defaultVal = "undefined") => {
    let newPath = _basePath(path);
    let val = newPath.reduce((o2, k) => {
      return (o2 || {})[k];
    }, object);
    return !val || val !== void 0 ? val : defaultVal;
  };
  const isNumber = (num) => {
    return !isNaN(Number(num));
  };
  const isBoolean = (bool) => {
    return typeof bool === "boolean";
  };
  const isRequiredField = (rules) => {
    let isNoField = false;
    for (let i2 = 0; i2 < rules.length; i2++) {
      const ruleData = rules[i2];
      if (ruleData.required) {
        isNoField = true;
        break;
      }
    }
    return isNoField;
  };
  const isEqual = (a2, b2) => {
    if (a2 === b2) {
      return a2 !== 0 || 1 / a2 === 1 / b2;
    }
    if (a2 == null || b2 == null) {
      return a2 === b2;
    }
    var classNameA = toString.call(a2), classNameB = toString.call(b2);
    if (classNameA !== classNameB) {
      return false;
    }
    switch (classNameA) {
      case "[object RegExp]":
      case "[object String]":
        return "" + a2 === "" + b2;
      case "[object Number]":
        if (+a2 !== +a2) {
          return +b2 !== +b2;
        }
        return +a2 === 0 ? 1 / +a2 === 1 / b2 : +a2 === +b2;
      case "[object Date]":
      case "[object Boolean]":
        return +a2 === +b2;
    }
    if (classNameA == "[object Object]") {
      var propsA = Object.getOwnPropertyNames(a2), propsB = Object.getOwnPropertyNames(b2);
      if (propsA.length != propsB.length) {
        return false;
      }
      for (var i2 = 0; i2 < propsA.length; i2++) {
        var propName = propsA[i2];
        if (a2[propName] !== b2[propName]) {
          return false;
        }
      }
      return true;
    }
    if (classNameA == "[object Array]") {
      if (a2.toString() == b2.toString()) {
        return true;
      }
      return false;
    }
  };
  const _sfc_main$S = {
    name: "uniForms",
    emits: ["validate", "submit"],
    options: {
      virtualHost: true
    },
    props: {
      // 即将弃用
      value: {
        type: Object,
        default() {
          return null;
        }
      },
      // vue3 替换 value 属性
      modelValue: {
        type: Object,
        default() {
          return null;
        }
      },
      // 1.4.0 开始将不支持 v-model ，且废弃 value 和 modelValue
      model: {
        type: Object,
        default() {
          return null;
        }
      },
      // 表单校验规则
      rules: {
        type: Object,
        default() {
          return {};
        }
      },
      //校验错误信息提示方式 默认 undertext 取值 [undertext|toast|modal]
      errShowType: {
        type: String,
        default: "undertext"
      },
      // 校验触发器方式 默认 bind 取值 [bind|submit]
      validateTrigger: {
        type: String,
        default: "submit"
      },
      // label 位置，默认 left 取值  top/left
      labelPosition: {
        type: String,
        default: "left"
      },
      // label 宽度
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      // label 居中方式，默认 left 取值 left/center/right
      labelAlign: {
        type: String,
        default: "left"
      },
      border: {
        type: Boolean,
        default: false
      }
    },
    provide() {
      return {
        uniForm: this
      };
    },
    data() {
      return {
        // 表单本地值的记录，不应该与传如的值进行关联
        formData: {},
        formRules: {}
      };
    },
    computed: {
      // 计算数据源变化的
      localData() {
        const localVal = this.model || this.modelValue || this.value;
        if (localVal) {
          return deepCopy(localVal);
        }
        return {};
      }
    },
    watch: {
      // 监听数据变化 ,暂时不使用，需要单独赋值
      // localData: {},
      // 监听规则变化
      rules: {
        handler: function(val, oldVal) {
          this.setRules(val);
        },
        deep: true,
        immediate: true
      }
    },
    created() {
      let getbinddata = getApp().$vm.$.appContext.config.globalProperties.binddata;
      if (!getbinddata) {
        getApp().$vm.$.appContext.config.globalProperties.binddata = function(name, value, formName) {
          if (formName) {
            this.$refs[formName].setValue(name, value);
          } else {
            let formVm;
            for (let i2 in this.$refs) {
              const vm = this.$refs[i2];
              if (vm && vm.$options && vm.$options.name === "uniForms") {
                formVm = vm;
                break;
              }
            }
            if (!formVm)
              return formatAppLog("error", "at uni_modules/uni-forms/components/uni-forms/uni-forms.vue:182", "当前 uni-froms 组件缺少 ref 属性");
            formVm.setValue(name, value);
          }
        };
      }
      this.childrens = [];
      this.inputChildrens = [];
      this.setRules(this.rules);
    },
    methods: {
      /**
       * 外部调用方法
       * 设置规则 ，主要用于小程序自定义检验规则
       * @param {Array} rules 规则源数据
       */
      setRules(rules) {
        this.formRules = Object.assign({}, this.formRules, rules);
        this.validator = new SchemaValidator(rules);
      },
      /**
       * 外部调用方法
       * 设置数据，用于设置表单数据，公开给用户使用 ， 不支持在动态表单中使用
       * @param {Object} key
       * @param {Object} value
       */
      setValue(key, value) {
        let example = this.childrens.find((child) => child.name === key);
        if (!example)
          return null;
        this.formData[key] = getValue(key, value, this.formRules[key] && this.formRules[key].rules || []);
        return example.onFieldChange(this.formData[key]);
      },
      /**
       * 外部调用方法
       * 手动提交校验表单
       * 对整个表单进行校验的方法，参数为一个回调函数。
       * @param {Array} keepitem 保留不参与校验的字段
       * @param {type} callback 方法回调
       */
      validate(keepitem, callback) {
        return this.checkAll(this.formData, keepitem, callback);
      },
      /**
       * 外部调用方法
       * 部分表单校验
       * @param {Array|String} props 需要校验的字段
       * @param {Function} 回调函数
       */
      validateField(props = [], callback) {
        props = [].concat(props);
        let invalidFields = {};
        this.childrens.forEach((item) => {
          const name = realName(item.name);
          if (props.indexOf(name) !== -1) {
            invalidFields = Object.assign({}, invalidFields, {
              [name]: this.formData[name]
            });
          }
        });
        return this.checkAll(invalidFields, [], callback);
      },
      /**
       * 外部调用方法
       * 移除表单项的校验结果。传入待移除的表单项的 prop 属性或者 prop 组成的数组，如不传则移除整个表单的校验结果
       * @param {Array|String} props 需要移除校验的字段 ，不填为所有
       */
      clearValidate(props = []) {
        props = [].concat(props);
        this.childrens.forEach((item) => {
          if (props.length === 0) {
            item.errMsg = "";
          } else {
            const name = realName(item.name);
            if (props.indexOf(name) !== -1) {
              item.errMsg = "";
            }
          }
        });
      },
      /**
       * 外部调用方法 ，即将废弃
       * 手动提交校验表单
       * 对整个表单进行校验的方法，参数为一个回调函数。
       * @param {Array} keepitem 保留不参与校验的字段
       * @param {type} callback 方法回调
       */
      submit(keepitem, callback, type) {
        for (let i2 in this.dataValue) {
          const itemData = this.childrens.find((v2) => v2.name === i2);
          if (itemData) {
            if (this.formData[i2] === void 0) {
              this.formData[i2] = this._getValue(i2, this.dataValue[i2]);
            }
          }
        }
        if (!type) {
          formatAppLog("warn", "at uni_modules/uni-forms/components/uni-forms/uni-forms.vue:289", "submit 方法即将废弃，请使用validate方法代替！");
        }
        return this.checkAll(this.formData, keepitem, callback, "submit");
      },
      // 校验所有
      async checkAll(invalidFields, keepitem, callback, type) {
        if (!this.validator)
          return;
        let childrens = [];
        for (let i2 in invalidFields) {
          const item = this.childrens.find((v2) => realName(v2.name) === i2);
          if (item) {
            childrens.push(item);
          }
        }
        if (!callback && typeof keepitem === "function") {
          callback = keepitem;
        }
        let promise;
        if (!callback && typeof callback !== "function" && Promise) {
          promise = new Promise((resolve, reject) => {
            callback = function(valid, invalidFields2) {
              !valid ? resolve(invalidFields2) : reject(valid);
            };
          });
        }
        let results = [];
        let tempFormData = JSON.parse(JSON.stringify(invalidFields));
        for (let i2 in childrens) {
          const child = childrens[i2];
          let name = realName(child.name);
          const result = await child.onFieldChange(tempFormData[name]);
          if (result) {
            results.push(result);
            if (this.errShowType === "toast" || this.errShowType === "modal")
              break;
          }
        }
        if (Array.isArray(results)) {
          if (results.length === 0)
            results = null;
        }
        if (Array.isArray(keepitem)) {
          keepitem.forEach((v2) => {
            let vName = realName(v2);
            let value = getDataValue(v2, this.localData);
            if (value !== void 0) {
              tempFormData[vName] = value;
            }
          });
        }
        if (type === "submit") {
          this.$emit("submit", {
            detail: {
              value: tempFormData,
              errors: results
            }
          });
        } else {
          this.$emit("validate", results);
        }
        let resetFormData = {};
        resetFormData = rawData(tempFormData, this.name);
        callback && typeof callback === "function" && callback(results, resetFormData);
        if (promise && callback) {
          return promise;
        } else {
          return null;
        }
      },
      /**
       * 返回validate事件
       * @param {Object} result
       */
      validateCheck(result) {
        this.$emit("validate", result);
      },
      _getValue: getValue,
      _isRequiredField: isRequiredField,
      _setDataValue: setDataValue,
      _getDataValue: getDataValue,
      _realName: realName,
      _isRealName: isRealName,
      _isEqual: isEqual
    }
  };
  function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-forms" }, [
      vue.createElementVNode("form", null, [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ]);
  }
  const __easycom_8 = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$R], ["__scopeId", "data-v-9a1e3c32"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-forms/components/uni-forms/uni-forms.vue"]]);
  const getOrderList = (params) => {
    return request({
      url: `/instruction/search/received/orders`,
      method: "get",
      data: params
    });
  };
  const getWarningList = (params) => {
    return request({
      url: `/instruction/search/received/warnings`,
      method: "get",
      data: params
    });
  };
  const sendWarning = (data) => {
    return request({
      url: `/instruction/send/warning`,
      method: "post",
      data
    });
  };
  const _imports_0$a = "/static/icon/alert.png";
  const _imports_1$4 = "/static/icon/flag.png";
  const _imports_2$2 = "/static/icon/document.png";
  const _imports_3$1 = "/static/icon/tuceng.png";
  const _imports_2$1 = "/static/icon/close.png";
  const _imports_5$1 = "/static/icon/video.png";
  const _imports_6 = "/static/icon/photo.png";
  const _imports_7 = "/static/icon/micro.png";
  const _imports_8 = "/static/icon/delete.png";
  const _imports_10 = "/static/images/none.png";
  const block0 = (Comp) => {
    (Comp.$renderjs || (Comp.$renderjs = [])).push("m");
    (Comp.$renderjsModules || (Comp.$renderjsModules = {}))["m"] = "55b5cda2";
  };
  const recorderManager = uni.getRecorderManager();
  const innerAudioContext = uni.createInnerAudioContext();
  innerAudioContext.autoplay = true;
  const _sfc_main$R = {
    data() {
      return {
        selectedMap: "gaode",
        //当前地图
        navIndex: 0,
        instruct_none: false,
        alert_none1: false,
        alert_none2: false,
        filePaths: {
          imagePath: "",
          videoPath: "",
          voicePath: ""
        },
        range: [
          {
            value: "1",
            text: "未开始"
          },
          {
            value: "2",
            text: "进行中"
          },
          {
            value: "3",
            text: "已完成"
          }
        ],
        alert_form_data: {
          alert_grade: "",
          alert_time: "",
          sender_name: "",
          alert_content: ""
        },
        grades: [
          {
            text: "一般告警",
            value: "一般告警"
          },
          {
            text: "严重告警",
            value: "严重告警"
          },
          {
            text: "紧急告警",
            value: "紧急告警"
          }
        ],
        taskItem: {},
        position: {
          longitude: "120.686250",
          latitude: "24.182220"
        },
        map_options: [
          {
            key: "google",
            src: "../../static/icon/google.png",
            htmlSrc: "/static/html/map_gaode.html",
            name: "谷歌地图"
          },
          {
            key: "gaode",
            src: "../../static/icon/gaode.png",
            htmlSrc: "/static/html/map_gaode.html",
            name: "高德地图"
          },
          {
            key: "baidu",
            src: "../../static/icon/baidu.png",
            htmlSrc: "/static/html/map_baidu.html",
            name: "百度地图"
          },
          {
            key: "local",
            src: "../../static/icon/offline.png",
            htmlSrc: "/static/html/map_gaode.html",
            name: "离线地图"
          }
          // 继续添加更多图片
        ],
        task_instructions: [
          // {
          // 	src: '../../../static/uni.png',
          // 	sender_name: 'admin',
          // 	detail: '测试指令1',
          // 	isConfirmed: false
          // },
          // {
          // 	src: '../../../static/uni.png',
          // 	sender_name: 'lihua',
          // 	detail: '测试指令2',
          // 	isConfirmed: false
          // },
          // {
          // 	src: '../../../static/uni.png',
          // 	sender_name: 'wanghao',
          // 	detail: '测试指令3',
          // 	isConfirmed: false
          // },
        ],
        alert_data: [
          // {
          // 	alert_grade: '重要告警',
          // 	alert_time: '2024.5.1',
          // 	sender_name: '张三',
          // 	alert_content: '告警内容',
          // 	isConfirmed: false
          // },
          // {
          // 	alert_grade: '一般告警',
          // 	alert_time: '2024.2.6',
          // 	sender_name: '李四',
          // 	alert_content: '告警内容',
          // 	isConfirmed: false
          // },
          // {
          // 	alert_grade: '重要告警',
          // 	alert_time: '2024.1.3',
          // 	sender_name: '张三',
          // 	alert_content: '告警内容',
          // 	isConfirmed: false
          // },
          // {
          // 	alert_grade: '严重告警',
          // 	alert_time: '2024.7.9',
          // 	sender_name: '张三',
          // 	alert_content: '告警内容',
          // 	isConfirmed: false
          // },
        ],
        alert_data_mine: [
          // {
          // 	alert_grade: '一般告警',
          // 	alert_time: '2024.5.1',
          // 	sender_name: '张三',
          // 	alert_content: '告警内容'
          // },
          // {
          // 	alert_grade: '一般告警',
          // 	alert_time: '2024.2.6',
          // 	sender_name: '李四',
          // 	alert_content: '告警内容'
          // },
          // {
          // 	alert_grade: '重要告警',
          // 	alert_time: '2024.1.3',
          // 	sender_name: '张三',
          // 	alert_content: '告警内容'
          // },
          // {
          // 	alert_grade: '严重告警',
          // 	alert_time: '2024.7.9',
          // 	sender_name: '张三',
          // 	alert_content: '告警内容'
          // },
        ],
        // 行动回溯，false停止，true播放
        replay: false,
        query: {
          "param": {
            "curPage": 1,
            "pageSize": 10
          },
          "statuses": [
            "USING",
            "UNUSED",
            "COMING"
          ]
        },
        // geoJson数据
        geoJson: "0"
      };
    },
    // onNavigationBarButtonTap() {
    // 	this.$refs.popup.open('bottom')
    // },
    mounted() {
      uni.showLoading({
        title: "正在加载任务",
        mask: true
      });
      searchMission(this.query).then((res) => {
        this.taskItem = res.data.records.map((e2) => ({
          id: e2.id,
          task_name: e2.missionName,
          country: e2.missionCountry,
          position: e2.missionCity,
          start_time: e2.missionStartTime,
          end_time: e2.missionEndTime,
          type: this.getTaskType(e2.missionStartTime, e2.missionEndTime),
          description: e2.missionDescription,
          key: e2.missionPassword,
          latitude: e2.latitude,
          longitude: e2.longitude,
          geoJson: e2.geoJson
        }))[0];
        this.position.latitude = this.taskItem.latitude;
        this.position.longitude = this.taskItem.longitude;
        this.geoJson = this.taskItem.geoJson;
        this.getOrder();
        this.getWarning();
        uni.hideLoading();
      });
    },
    onLoad(options) {
      let self2 = this;
      this.recorderManager.onStop(function(res) {
        self2.filePaths.voicePath = res.tempFilePath;
        uni.uploadFile({
          url: `http://139.196.11.210:8500/communicate/mission/upload/file`,
          filePath: res.tempFilePath,
          name: "file",
          formData: {
            "latitude": "12",
            "longitude": "123",
            "missionId": this.taskItem.id
          },
          header: {
            "Content-Type": "multipart/form-data;",
            "Authorization": "Bearer " + uni.getStorageSync("token")
          },
          success: (uploadFileRes) => {
            const res2 = JSON.parse(uploadFileRes.data);
            if (res2.code === 200) {
              uni.showToast({
                title: "音频上传成功！",
                //将值设置为 success 或者直接不用写icon这个参数
                icon: "success",
                //显示持续时间为 2秒
                duration: 2e3
              });
            } else {
              uni.showToast({
                title: "音频上传失败！",
                icon: "none",
                //显示持续时间为 2秒
                duration: 2e3
              });
            }
            formatAppLog("log", "at pages/task/task_detail/task_detail.vue:824", uploadFileRes.data);
          }
        });
      });
    },
    methods: {
      take_picture() {
        var self2 = this;
        uni.chooseImage({
          count: 1,
          // 默认选择一张图片
          sourceType: ["camera"],
          // 只允许从相机拍照
          success: function(res) {
            const tempFilePath = res.tempFilePaths[0];
            formatAppLog("log", "at pages/task/task_detail/task_detail.vue:839", "拍照成功，文件路径：", tempFilePath);
            uni.previewImage({
              urls: [tempFilePath]
            });
            uni.uploadFile({
              url: "http://139.196.11.210:8500/communicate/mission/upload/file",
              filePath: tempFilePath,
              name: "files",
              formData: {
                "latitude": "12",
                "longitude": "123",
                "missionId": self2.taskItem.id
              },
              header: {
                "Content-Type": "multipart/form-data;",
                "Authorization": "Bearer " + uni.getStorageSync("token")
              },
              success: (uploadFileRes) => {
                const res2 = JSON.parse(uploadFileRes.data);
                if (res2.code === 200) {
                  uni.showToast({
                    title: "图片上传成功！",
                    //将值设置为 success 或者直接不用写icon这个参数
                    icon: "success",
                    //显示持续时间为 2秒
                    duration: 2e3
                  });
                } else {
                  uni.showToast({
                    title: "图片上传失败！",
                    icon: "none",
                    //显示持续时间为 2秒
                    duration: 2e3
                  });
                }
                formatAppLog("log", "at pages/task/task_detail/task_detail.vue:877", uploadFileRes.data);
              }
            });
          },
          fail: function(err) {
            formatAppLog("error", "at pages/task/task_detail/task_detail.vue:882", "拍照失败：", err);
          }
        });
      },
      take_video() {
        var self2 = this;
        uni.chooseVideo({
          sourceType: ["camera"],
          // 只允许从相机录制
          maxDuration: 60,
          // 录像时长最大为60秒
          camera: "back",
          // 使用后置摄像头
          success: function(res) {
            const tempFilePath = res.tempFilePath;
            self2.filePaths.videoPath = res.tempFilePath;
            formatAppLog("log", "at pages/task/task_detail/task_detail.vue:897", "录像成功，文件路径：", tempFilePath);
            uni.uploadFile({
              url: `http://139.196.11.210:8500/communicate/mission/upload/file`,
              filePath: tempFilePath,
              name: "file",
              formData: {
                "latitude": "12",
                "longitude": "123",
                "missionId": self2.taskItem.id
              },
              header: {
                "Content-Type": "multipart/form-data;",
                "Authorization": "Bearer " + uni.getStorageSync("token")
              },
              success: (uploadFileRes) => {
                const res2 = JSON.parse(uploadFileRes.data);
                if (res2.code === 200) {
                  uni.showToast({
                    title: "视频上传成功！",
                    //将值设置为 success 或者直接不用写icon这个参数
                    icon: "success",
                    //显示持续时间为 2秒
                    duration: 2e3
                  });
                } else {
                  uni.showToast({
                    title: "视频上传失败！",
                    icon: "none",
                    //显示持续时间为 2秒
                    duration: 2e3
                  });
                }
                formatAppLog("log", "at pages/task/task_detail/task_detail.vue:930", uploadFileRes.data);
              }
            });
          },
          fail: function(err) {
            formatAppLog("error", "at pages/task/task_detail/task_detail.vue:935", "录像失败：", err);
          }
        });
      },
      startRecording() {
        formatAppLog("log", "at pages/task/task_detail/task_detail.vue:940", "开始录音");
        recorderManager.start();
        uni.showLoading({
          title: "正在录音"
        });
      },
      stopRecording() {
        formatAppLog("log", "at pages/task/task_detail/task_detail.vue:949", "录音结束");
        recorderManager.stop();
        uni.hideLoading();
      },
      playVoice() {
        formatAppLog("log", "at pages/task/task_detail/task_detail.vue:954", "播放录音");
        formatAppLog("log", "at pages/task/task_detail/task_detail.vue:955", "this.voicePath", this.filePaths.voicePath);
        if (this.filePaths.voicePath) {
          this.innerAudioContext.src = this.filePaths.voicePath;
          this.innerAudioContext.play();
        }
      },
      checkIndex(index) {
        this.navIndex = index;
      },
      delete_alert(index) {
        this.alert_data.splice(index, 1);
      },
      delete_alert_mine(index) {
        this.alert_data_mine.splice(index, 1);
      },
      open() {
        this.$refs.popup.open();
      },
      close() {
        this.$refs.popup.close();
      },
      open_alert_form() {
        this.$refs.alert_form_popup.open();
      },
      close_alert_form() {
        this.$refs.alert_form_popup.close();
      },
      open_alert_popup() {
        this.$refs.alert_popup.open();
      },
      close_alert_popup() {
        this.$refs.alert_popup.close();
      },
      open_map_selector() {
        this.$refs.map_selector.open();
      },
      close_map_selector() {
        this.$refs.map_selector.close();
      },
      open_task_instructions() {
        this.$refs.task_instructions.open();
      },
      close_task_instructions() {
        this.$refs.task_instructions.close();
      },
      goToDocument() {
        uni.navigateTo({
          url: `/pages/task/task_detail/document/document?missionId=${this.taskItem.id}`
        });
      },
      goToMainPage() {
        uni.redirectTo({
          url: "/pages/tabBar/tabBar"
        });
      },
      selectImage(value) {
        this.selectedMap = value;
        this.$refs.map_selector.close();
      },
      receive_instruction(index) {
        this.task_instructions[index].isConfirmed = true;
      },
      receive_alert(index) {
        this.alert_data[index].isConfirmed = true;
      },
      isReceived(index) {
        return this.task_instructions[index].isConfirmed ? "已收到" : "收到";
      },
      isReceived_alert(index) {
        return this.alert_data[index].isConfirmed ? "已确认" : "确认";
      },
      submit(ref) {
        uni.showLoading({
          title: "正在发送",
          mask: true
        });
        let data = {
          isOrder: false,
          message: this.alert_form_data.alert_content,
          receiverMissionMemberIds: [],
          relatedMissionId: this.taskItem.id
        };
        getMissionDetails({
          missionId: this.taskItem.id
        }).then((res) => {
          if (res.code === 200) {
            sendWarning(data).then((res2) => {
              if (res2.code === 200) {
                uni.showToast({
                  title: "发送成功",
                  duration: 2e3
                });
              } else {
                uni.showToast({
                  title: "发送失败",
                  icon: "none",
                  duration: 2e3
                });
              }
              uni.hideLoading();
            });
          }
        });
        this.$refs.alert_form_popup.close();
        this.getWarning();
      },
      // 设置经纬度
      // setPoint() {
      // 	this.position.latitude = this.taskItem.latitude;
      // 	this.position.longitude = this.taskItem.longitude;
      // 	__f__('log','at pages/task/task_detail/task_detail.vue:1071',this.position,'position')
      // },
      // setGeoJson() {
      // 	this.geoJson = this.taskItem.geoJson;
      // 	__f__('log','at pages/task/task_detail/task_detail.vue:1075',this.geoJson, 'owner-setGeoJson')
      // },
      // 删除任务
      deleteMisson() {
        const id = this.taskItem.id;
        uni.showModal({
          title: "提示",
          content: "确定删除任务？",
          success: function(res) {
            uni.showLoading({
              title: "正在删除",
              mask: true
            });
            deleteMission(id).then((res2) => {
              uni.hideLoading();
              if (res2.code == 200) {
                uni.showToast({
                  title: "删除成功",
                  duration: 2e3
                });
              } else {
                uni.showToast({
                  title: res2.msg,
                  duration: 2e3
                });
              }
            });
          }
        });
      },
      setReplay(value) {
        this.replay = value;
      },
      getOrder() {
        getOrderList({
          missionId: this.taskItem.id,
          curPage: 1,
          pageSize: 20
        }).then((res) => {
          if (res.code === 200) {
            this.task_instructions = res.data.records.map((item) => ({
              src: "../../../static/uni.png",
              sender_name: item.user.name,
              detail: item.message,
              isConfirmed: item.isRead
            }));
            if (this.task_instructions.length === 0) {
              this.instruct_none = true;
            } else {
              this.instruct_none = false;
            }
          } else {
            this.instruct_none = true;
          }
        });
      },
      getTaskType(startTime, endTime) {
        const start = new Date(startTime);
        const end = new Date(endTime);
        if (this.currentTime < start) {
          return "1";
        } else if (this.currentTime >= start && this.currentTime <= end) {
          return "2";
        } else {
          return "3";
        }
      },
      getWarning() {
        getWarningList({
          missionId: this.taskItem.id,
          curPage: 1,
          pageSize: 20
        }).then((res) => {
          formatAppLog("log", "at pages/task/task_detail/task_detail.vue:1150", res.data.records, "res");
          if (res.code === 200) {
            uni.getStorageSync("userInfo");
            this.alert_data = res.data.records.map(
              (item) => ({
                alert_grade: "严重告警",
                alert_time: item.sendTime,
                sender_name: item.user.name,
                alert_content: item.message,
                isConfirmed: item.isRead
              })
            );
            if (this.alert_data.length === 0) {
              this.alert_none1 = true;
            } else {
              this.alert_none1 = false;
            }
            if (this.alert_data_mine.length === 0) {
              this.alert_none2 = true;
            } else {
              this.alert_none2 = false;
            }
          }
        });
      }
    }
  };
  function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    const _component_uni_data_select = resolveEasycom(vue.resolveDynamicComponent("uni-data-select"), __easycom_1$2);
    const _component_uni_popup = resolveEasycom(vue.resolveDynamicComponent("uni-popup"), __easycom_2$1);
    const _component_uni_collapse_item = resolveEasycom(vue.resolveDynamicComponent("uni-collapse-item"), __easycom_3$1);
    const _component_uni_collapse = resolveEasycom(vue.resolveDynamicComponent("uni-collapse"), __easycom_4);
    const _component_uni_data_checkbox = resolveEasycom(vue.resolveDynamicComponent("uni-data-checkbox"), __easycom_5$1);
    const _component_uni_forms_item = resolveEasycom(vue.resolveDynamicComponent("uni-forms-item"), __easycom_6$1);
    const _component_uni_easyinput = resolveEasycom(vue.resolveDynamicComponent("uni-easyinput"), __easycom_0$1);
    const _component_uni_forms = resolveEasycom(vue.resolveDynamicComponent("uni-forms"), __easycom_8);
    return vue.openBlock(), vue.createElementBlock(
      vue.Fragment,
      null,
      [
        vue.createElementVNode("view", null, [
          vue.createVNode(_component_uni_nav_bar, {
            fixed: true,
            "status-bar": "",
            shadow: "",
            rightIcon: "more-filled",
            onClickRight: $options.open,
            title: "任务详情"
          }, null, 8, ["onClickRight"])
        ]),
        vue.createCommentVNode(" 地图容器 "),
        vue.createElementVNode("view", {
          id: "map_container",
          selectedMap: vue.wp($data.selectedMap),
          "change:selectedMap": _ctx.m.setMapType,
          replay: $data.replay,
          "change:replay": _ctx.m.setReplay,
          position: vue.wp($data.position),
          "change:position": _ctx.m.setPosition,
          geoJson: vue.wp($data.geoJson),
          "change:geoJson": _ctx.m.setGeoJson
        }, null, 8, ["selectedMap", "change:selectedMap", "replay", "change:replay", "position", "change:position", "geoJson", "change:geoJson"]),
        vue.createCommentVNode(" task_detail "),
        vue.createElementVNode("view", { class: "layout_task_detail" }, [
          vue.createCommentVNode(" 按钮组 "),
          vue.createElementVNode("view", { class: "condition_icons" }, [
            vue.createCommentVNode(" 左侧-选择任务状态按钮 "),
            vue.createElementVNode("view", { class: "condition_selector" }, [
              vue.createVNode(_component_uni_data_select, {
                modelValue: $data.taskItem.type,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.taskItem.type = $event),
                localdata: $data.range,
                clear: false
              }, null, 8, ["modelValue", "localdata"])
            ]),
            vue.createElementVNode("view", { class: "condition_selector" }, [
              vue.createElementVNode("button", {
                class: "mini-btn",
                type: "primary",
                size: "mini",
                onClick: _cache[1] || (_cache[1] = ($event) => $options.setReplay(!$data.replay))
              }, [
                !$data.replay ? (vue.openBlock(), vue.createElementBlock("text", { key: 0 }, " 行动回溯 ")) : (vue.openBlock(), vue.createElementBlock("text", { key: 1 }, " 正在回溯 "))
              ])
            ]),
            vue.createCommentVNode(" 右侧按钮组 "),
            vue.createElementVNode("view", { class: "right-button-groups" }, [
              vue.createCommentVNode(" 告警按钮 "),
              vue.createElementVNode("view", {
                class: "instructions_alert",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.open_alert_popup && $options.open_alert_popup(...args))
              }, [
                vue.createElementVNode("view", {
                  class: "alert_img",
                  style: { "text-align": "center", "padding-top": "5px" }
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_0$a,
                    style: { "width": "22px", "height": "22px" }
                  })
                ]),
                vue.createElementVNode("view", {
                  class: "text_setting",
                  style: { "text-align": "center" }
                }, [
                  vue.createElementVNode("text", { style: { "color": "#d81e06", "font-size": "small" } }, "告警")
                ])
              ]),
              vue.createCommentVNode(" 指令按钮 "),
              vue.createElementVNode("view", {
                class: "instructions_instruct",
                onClick: _cache[3] || (_cache[3] = (...args) => $options.open_task_instructions && $options.open_task_instructions(...args))
              }, [
                vue.createElementVNode("view", {
                  class: "alert_img",
                  style: { "text-align": "center", "padding-top": "5px" }
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_1$4,
                    style: { "width": "22px", "height": "22px" }
                  })
                ]),
                vue.createElementVNode("view", {
                  class: "text_setting",
                  style: { "text-align": "center" }
                }, [
                  vue.createElementVNode("text", { style: { "color": "#3171d3", "font-size": "small" } }, "指令")
                ])
              ]),
              vue.createCommentVNode(" 文件按钮+图层按钮 "),
              vue.createElementVNode("view", { class: "instructions_document" }, [
                vue.createCommentVNode(" 文件按钮 "),
                vue.createElementVNode("view", {
                  class: "document",
                  onClick: _cache[4] || (_cache[4] = (...args) => $options.goToDocument && $options.goToDocument(...args))
                }, [
                  vue.createElementVNode("view", {
                    class: "alert_img",
                    style: { "text-align": "center", "padding-top": "5px" }
                  }, [
                    vue.createElementVNode("image", {
                      src: _imports_2$2,
                      style: { "width": "22px", "height": "22px" }
                    })
                  ]),
                  vue.createElementVNode("view", {
                    class: "text_setting",
                    style: { "text-align": "center" }
                  }, [
                    vue.createElementVNode("text", { style: { "color": "#636363", "font-size": "small" } }, "文件")
                  ])
                ]),
                vue.createCommentVNode(" 图层按钮 "),
                vue.createElementVNode("view", {
                  class: "map_selector",
                  onClick: _cache[5] || (_cache[5] = (...args) => $options.open_map_selector && $options.open_map_selector(...args))
                }, [
                  vue.createElementVNode("view", {
                    class: "alert_img",
                    style: { "text-align": "center", "padding-top": "5px" }
                  }, [
                    vue.createElementVNode("image", {
                      src: _imports_3$1,
                      style: { "width": "22px", "height": "22px" }
                    })
                  ]),
                  vue.createElementVNode("view", {
                    class: "text_setting",
                    style: { "text-align": "center" }
                  }, [
                    vue.createElementVNode("text", { style: { "color": "#636363", "font-size": "small" } }, "图层")
                  ])
                ])
              ])
            ])
          ]),
          vue.createCommentVNode(" 详情界面弹窗 "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "popup",
                type: "bottom",
                "background-color": "#fff",
                "mask-click": false
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", {
                    class: "detail",
                    style: { "padding": "15px" }
                  }, [
                    vue.createElementVNode("view", { class: "detail_top" }, [
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode(
                          "text",
                          null,
                          vue.toDisplayString($data.taskItem.task_name),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", {
                        style: { "margin-right": "10px" },
                        onClick: _cache[6] || (_cache[6] = (...args) => $options.close && $options.close(...args))
                      }, [
                        vue.createElementVNode("image", {
                          src: _imports_2$1,
                          style: { "width": "15px", "height": "15px" }
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    vue.createElementVNode("view", { class: "detail_info" }, [
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "任务名称: " + vue.toDisplayString($data.taskItem.task_name),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "任务描述: " + vue.toDisplayString($data.taskItem.description),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "任务国家: " + vue.toDisplayString($data.taskItem.country),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "任务地点: " + vue.toDisplayString($data.taskItem.position),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "任务时间: " + vue.toDisplayString($data.taskItem.start_time) + " - " + vue.toDisplayString($data.taskItem.end_time),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "任务口令: " + vue.toDisplayString($data.taskItem.key),
                          1
                          /* TEXT */
                        )
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    vue.createElementVNode("view", { class: "text_setting" }, [
                      vue.createCommentVNode(" 录制视频按钮 "),
                      vue.createElementVNode("view", { style: { "margin-right": "50px" } }, [
                        vue.createElementVNode("image", {
                          onClick: _cache[7] || (_cache[7] = ($event) => $options.take_video()),
                          src: _imports_5$1,
                          style: { "width": "30px", "height": "30px" }
                        })
                      ]),
                      vue.createCommentVNode(" 拍摄照片按钮 "),
                      vue.createElementVNode("view", { style: { "margin-right": "50px" } }, [
                        vue.createElementVNode("image", {
                          onClick: _cache[8] || (_cache[8] = ($event) => $options.take_picture()),
                          src: _imports_6,
                          style: { "width": "33px", "height": "33px" }
                        })
                      ]),
                      vue.createCommentVNode(" 录制音频按钮 "),
                      vue.createElementVNode("view", { style: { "margin-right": "50px" } }, [
                        vue.createElementVNode(
                          "image",
                          {
                            onLongpress: _cache[9] || (_cache[9] = ($event) => $options.startRecording()),
                            onTouchend: _cache[10] || (_cache[10] = ($event) => $options.stopRecording()),
                            src: _imports_7,
                            style: { "width": "32px", "height": "32px" }
                          },
                          null,
                          32
                          /* NEED_HYDRATION */
                        )
                      ]),
                      vue.createCommentVNode(" 删除任务按钮 "),
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode("image", {
                          src: _imports_8,
                          style: { "width": "28px", "height": "28px" },
                          onClick: _cache[11] || (_cache[11] = (...args) => $options.deleteMisson && $options.deleteMisson(...args))
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { style: { "height": "50px" } })
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ]),
          vue.createCommentVNode(" 图层弹窗 "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "map_selector",
                type: "bottom",
                "background-color": "#fff",
                "mask-click": false
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", {
                    class: "detail",
                    style: { "padding": "15px" }
                  }, [
                    vue.createElementVNode("view", { class: "detail_top" }, [
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode("text", null, "图层切换")
                      ]),
                      vue.createElementVNode("view", {
                        style: { "margin-right": "10px" },
                        onClick: _cache[12] || (_cache[12] = (...args) => $options.close_map_selector && $options.close_map_selector(...args))
                      }, [
                        vue.createElementVNode("image", {
                          src: _imports_2$1,
                          style: { "width": "15px", "height": "15px" }
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    vue.createElementVNode("view", { style: { "margin-top": "20px" } }, [
                      vue.createElementVNode("view", { class: "map_icons" }, [
                        (vue.openBlock(true), vue.createElementBlock(
                          vue.Fragment,
                          null,
                          vue.renderList($data.map_options, (item, index) => {
                            return vue.openBlock(), vue.createElementBlock("view", { key: index }, [
                              vue.createElementVNode("view", {
                                class: "map_icon",
                                style: { "margin": "0 15px" }
                              }, [
                                vue.createCommentVNode(` 									<image :class="{ 'selected': selectedIndex === index }" @click="selectImage(index)"\r
										:src=item.src style="width: 55px; height: 55px; border-radius: 15px;"></image> `),
                                vue.createElementVNode("image", {
                                  class: vue.normalizeClass({ "selected": $data.selectedMap === item.key }),
                                  onClick: ($event) => $options.selectImage(item.key),
                                  src: item.src,
                                  style: { "width": "55px", "height": "55px", "border-radius": "15px" }
                                }, null, 10, ["onClick", "src"])
                              ]),
                              vue.createElementVNode("view", { style: { "text-align": "center" } }, [
                                vue.createElementVNode(
                                  "text",
                                  null,
                                  vue.toDisplayString(item.name),
                                  1
                                  /* TEXT */
                                )
                              ])
                            ]);
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ])
                    ]),
                    vue.createElementVNode("view", { style: { "height": "50px" } })
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ]),
          vue.createCommentVNode(" 任务指令弹窗 "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "task_instructions",
                type: "bottom",
                "background-color": "#fff",
                "mask-click": false
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", {
                    class: "detail",
                    style: { "padding": "15px" }
                  }, [
                    vue.createElementVNode("view", { class: "detail_top" }, [
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode("text", null, "任务指令")
                      ]),
                      vue.createElementVNode("view", {
                        style: { "margin-right": "10px" },
                        onClick: _cache[13] || (_cache[13] = (...args) => $options.close_task_instructions && $options.close_task_instructions(...args))
                      }, [
                        vue.createElementVNode("image", {
                          src: _imports_2$1,
                          style: { "width": "15px", "height": "15px" }
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    $data.instruct_none ? (vue.openBlock(), vue.createElementBlock("view", {
                      key: 0,
                      style: { "text-align": "center" }
                    }, [
                      vue.createElementVNode("image", {
                        src: _imports_10,
                        style: { "width": "60%", "height": "60%" },
                        mode: "widthFix"
                      }),
                      vue.createElementVNode("view", null, "暂未发现任务指令")
                    ])) : vue.createCommentVNode("v-if", true),
                    vue.createElementVNode("view", { style: { "margin-top": "20px" } }, [
                      vue.createElementVNode("view", { class: "instructions" }, [
                        (vue.openBlock(true), vue.createElementBlock(
                          vue.Fragment,
                          null,
                          vue.renderList($data.task_instructions, (item, index) => {
                            return vue.openBlock(), vue.createElementBlock("view", {
                              key: index,
                              class: "instructions_item",
                              style: { "display": "flex", "justify-content": "space-between", "align-items": "center", "margin-bottom": "20px" }
                            }, [
                              vue.createElementVNode("view", { style: { "display": "flex" } }, [
                                vue.createElementVNode("view", { style: { "margin-right": "10px" } }, [
                                  vue.createElementVNode("image", {
                                    src: item.src,
                                    style: { "width": "45px", "height": "45px" }
                                  }, null, 8, ["src"])
                                ]),
                                vue.createElementVNode("view", null, [
                                  vue.createElementVNode("view", null, [
                                    vue.createElementVNode(
                                      "text",
                                      null,
                                      vue.toDisplayString(item.sender_name),
                                      1
                                      /* TEXT */
                                    )
                                  ]),
                                  vue.createElementVNode("view", null, [
                                    vue.createElementVNode(
                                      "text",
                                      { style: { "color": "#858585" } },
                                      vue.toDisplayString(item.detail),
                                      1
                                      /* TEXT */
                                    )
                                  ])
                                ])
                              ]),
                              vue.createElementVNode("view", null, [
                                vue.createElementVNode("button", {
                                  onClick: ($event) => $options.receive_instruction(index),
                                  disabled: item.isConfirmed,
                                  class: "mini-btn",
                                  type: "primary",
                                  size: "mini"
                                }, vue.toDisplayString($options.isReceived(index)), 9, ["onClick", "disabled"])
                              ])
                            ]);
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ])
                    ]),
                    vue.createElementVNode("view", { style: { "height": "50px" } })
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ]),
          vue.createCommentVNode(" 告警弹窗 "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "alert_popup",
                type: "bottom",
                "background-color": "#fff"
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", { style: { "padding": "15px" } }, [
                    vue.createElementVNode("view", { class: "detail" }, [
                      vue.createElementVNode("view", { class: "detail_top" }, [
                        vue.createElementVNode("view", null, [
                          vue.createElementVNode("text", null, "告警列表")
                        ]),
                        vue.createElementVNode("view", {
                          style: { "margin-right": "10px" },
                          onClick: _cache[14] || (_cache[14] = (...args) => $options.close_alert_popup && $options.close_alert_popup(...args))
                        }, [
                          vue.createElementVNode("image", {
                            src: _imports_2$1,
                            style: { "width": "15px", "height": "15px" }
                          })
                        ])
                      ]),
                      vue.createElementVNode("view", { class: "divider" })
                    ]),
                    vue.createElementVNode("view", null, [
                      vue.createElementVNode("view", { class: "head-nav" }, [
                        vue.createElementVNode(
                          "view",
                          {
                            class: vue.normalizeClass($data.navIndex == 0 ? "activite" : ""),
                            onClick: _cache[15] || (_cache[15] = ($event) => $options.checkIndex(0)),
                            style: { "width": "50%", "text-align": "center" }
                          },
                          "接收",
                          2
                          /* CLASS */
                        ),
                        vue.createElementVNode(
                          "view",
                          {
                            class: vue.normalizeClass($data.navIndex == 1 ? "activite" : ""),
                            onClick: _cache[16] || (_cache[16] = ($event) => $options.checkIndex(1)),
                            style: { "width": "50%", "text-align": "center" }
                          },
                          "发送",
                          2
                          /* CLASS */
                        )
                      ]),
                      vue.createCommentVNode(" 内容切换 "),
                      $data.navIndex == 0 ? (vue.openBlock(), vue.createElementBlock("view", {
                        key: 0,
                        class: "alert_content"
                      }, [
                        $data.alert_none1 ? (vue.openBlock(), vue.createElementBlock("view", {
                          key: 0,
                          style: { "text-align": "center" }
                        }, [
                          vue.createElementVNode("image", {
                            src: _imports_10,
                            style: { "width": "60%", "height": "60%" },
                            mode: "widthFix"
                          }),
                          vue.createElementVNode("view", null, "暂未发现告警信息")
                        ])) : vue.createCommentVNode("v-if", true),
                        vue.createVNode(
                          _component_uni_collapse,
                          {
                            ref: "collapse",
                            accordion: ""
                          },
                          {
                            default: vue.withCtx(() => [
                              (vue.openBlock(true), vue.createElementBlock(
                                vue.Fragment,
                                null,
                                vue.renderList($data.alert_data, (item, index) => {
                                  return vue.openBlock(), vue.createBlock(_component_uni_collapse_item, {
                                    key: index,
                                    title: item.alert_content
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createElementVNode("view", {
                                        class: "detail_info",
                                        style: { "margin": "0 15px 5px 0" }
                                      }, [
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "告警等级: " + vue.toDisplayString(item.alert_grade),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "告警时间: " + vue.toDisplayString(item.alert_time),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "创建用户: " + vue.toDisplayString(item.sender_name),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "告警内容: " + vue.toDisplayString(item.alert_content),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { style: { "text-align": "right" } }, [
                                          vue.createElementVNode("button", {
                                            class: "mini-btn",
                                            type: "warn",
                                            size: "mini",
                                            style: { "margin-right": "10px" },
                                            onClick: ($event) => $options.delete_alert(index)
                                          }, "删除", 8, ["onClick"]),
                                          vue.createElementVNode("button", {
                                            class: "mini-btn",
                                            type: "default",
                                            size: "mini",
                                            onClick: ($event) => $options.receive_alert(index),
                                            disabled: item.isConfirmed
                                          }, vue.toDisplayString($options.isReceived_alert(index)), 9, ["onClick", "disabled"])
                                        ])
                                      ])
                                    ]),
                                    _: 2
                                    /* DYNAMIC */
                                  }, 1032, ["title"]);
                                }),
                                128
                                /* KEYED_FRAGMENT */
                              ))
                            ]),
                            _: 1
                            /* STABLE */
                          },
                          512
                          /* NEED_PATCH */
                        )
                      ])) : vue.createCommentVNode("v-if", true),
                      $data.navIndex == 1 ? (vue.openBlock(), vue.createElementBlock("view", {
                        key: 1,
                        class: "content"
                      }, [
                        $data.alert_none2 ? (vue.openBlock(), vue.createElementBlock("view", {
                          key: 0,
                          style: { "text-align": "center", "margin-bottom": "15px" }
                        }, [
                          vue.createElementVNode("image", {
                            src: _imports_10,
                            style: { "width": "60%", "height": "60%" },
                            mode: "widthFix"
                          }),
                          vue.createElementVNode("view", null, "暂未发现告警信息")
                        ])) : vue.createCommentVNode("v-if", true),
                        vue.createVNode(
                          _component_uni_collapse,
                          {
                            ref: "collapse",
                            accordion: ""
                          },
                          {
                            default: vue.withCtx(() => [
                              (vue.openBlock(true), vue.createElementBlock(
                                vue.Fragment,
                                null,
                                vue.renderList($data.alert_data_mine, (item, index) => {
                                  return vue.openBlock(), vue.createBlock(_component_uni_collapse_item, {
                                    key: index,
                                    title: item.alert_content
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createElementVNode("view", {
                                        class: "detail_info",
                                        style: { "margin": "0 15px 5px 0" }
                                      }, [
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "告警等级: " + vue.toDisplayString(item.alert_grade),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "告警时间: " + vue.toDisplayString(item.alert_time),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "创建用户: " + vue.toDisplayString(item.sender_name),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "告警内容: " + vue.toDisplayString(item.alert_content),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { style: { "text-align": "right" } }, [
                                          vue.createElementVNode("button", {
                                            class: "mini-btn",
                                            type: "warn",
                                            size: "mini",
                                            style: { "margin-right": "10px" },
                                            onClick: ($event) => $options.delete_alert_mine(index)
                                          }, "删除", 8, ["onClick"])
                                        ])
                                      ])
                                    ]),
                                    _: 2
                                    /* DYNAMIC */
                                  }, 1032, ["title"]);
                                }),
                                128
                                /* KEYED_FRAGMENT */
                              ))
                            ]),
                            _: 1
                            /* STABLE */
                          },
                          512
                          /* NEED_PATCH */
                        ),
                        vue.createElementVNode("view", null, [
                          vue.createElementVNode("button", {
                            type: "primary",
                            onClick: _cache[17] || (_cache[17] = (...args) => $options.open_alert_form && $options.open_alert_form(...args))
                          }, "发布告警")
                        ])
                      ])) : vue.createCommentVNode("v-if", true)
                    ]),
                    vue.createElementVNode("view", { style: { "height": "50px" } })
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ]),
          vue.createCommentVNode(" 发布告警弹窗 "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "alert_form_popup",
                type: "dialog"
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", {
                    class: "example",
                    style: { "background": "#fff", "border-radius": "5px", "padding": "10px" }
                  }, [
                    vue.createElementVNode("view", { class: "detail_top" }, [
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode("text", null, "发布告警")
                      ]),
                      vue.createElementVNode("view", {
                        style: { "margin-right": "10px" },
                        onClick: _cache[18] || (_cache[18] = (...args) => $options.close_alert_form && $options.close_alert_form(...args))
                      }, [
                        vue.createElementVNode("image", {
                          src: _imports_2$1,
                          style: { "width": "15px", "height": "15px" }
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    vue.createCommentVNode(" 基础用法，不包含校验规则 "),
                    vue.createVNode(_component_uni_forms, {
                      ref: "alert_form",
                      modelValue: $data.alert_form_data
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_uni_forms_item, {
                          label: "告警等级",
                          style: { "display": "flex", "align-items": "center" }
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(_component_uni_data_checkbox, {
                              modelValue: $data.alert_form_data.alert_grade,
                              "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => $data.alert_form_data.alert_grade = $event),
                              localdata: $data.grades
                            }, null, 8, ["modelValue", "localdata"])
                          ]),
                          _: 1
                          /* STABLE */
                        }),
                        vue.createVNode(_component_uni_forms_item, { label: "告警内容" }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(_component_uni_easyinput, {
                              type: "textarea",
                              modelValue: $data.alert_form_data.alert_content,
                              "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => $data.alert_form_data.alert_content = $event),
                              placeholder: "请输入告警内容"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                          /* STABLE */
                        })
                      ]),
                      _: 1
                      /* STABLE */
                    }, 8, ["modelValue"]),
                    vue.createElementVNode("button", {
                      type: "primary",
                      onClick: _cache[21] || (_cache[21] = ($event) => $options.submit("alert_form"))
                    }, "提交")
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ])
        ])
      ],
      64
      /* STABLE_FRAGMENT */
    );
  }
  if (typeof block0 === "function")
    block0(_sfc_main$R);
  const PagesTaskTaskDetailTaskDetail = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$Q], ["__file", "E:/代码/new/zk_uniapp/pages/task/task_detail/task_detail.vue"]]);
  const _sfc_main$Q = {
    name: "UniGridItem",
    inject: ["grid"],
    props: {
      index: {
        type: Number,
        default: 0
      }
    },
    data() {
      return {
        column: 0,
        showBorder: true,
        square: true,
        highlight: true,
        left: 0,
        top: 0,
        openNum: 2,
        width: 0,
        borderColor: "#e5e5e5"
      };
    },
    created() {
      this.column = this.grid.column;
      this.showBorder = this.grid.showBorder;
      this.square = this.grid.square;
      this.highlight = this.grid.highlight;
      this.top = this.hor === 0 ? this.grid.hor : this.hor;
      this.left = this.ver === 0 ? this.grid.ver : this.ver;
      this.borderColor = this.grid.borderColor;
      this.grid.children.push(this);
      this.width = this.grid.width;
    },
    beforeDestroy() {
      this.grid.children.forEach((item, index) => {
        if (item === this) {
          this.grid.children.splice(index, 1);
        }
      });
    },
    methods: {
      _onClick() {
        this.grid.change({
          detail: {
            index: this.index
          }
        });
      }
    }
  };
  function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
    return $data.width ? (vue.openBlock(), vue.createElementBlock(
      "view",
      {
        key: 0,
        style: vue.normalizeStyle("width:" + $data.width + ";" + ($data.square ? "height:" + $data.width : "")),
        class: "uni-grid-item"
      },
      [
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass([{ "uni-grid-item--border": $data.showBorder, "uni-grid-item--border-top": $data.showBorder && $props.index < $data.column, "uni-highlight": $data.highlight }, "uni-grid-item__box"]),
            style: vue.normalizeStyle({ "border-right-color": $data.borderColor, "border-bottom-color": $data.borderColor, "border-top-color": $data.borderColor }),
            onClick: _cache[0] || (_cache[0] = (...args) => $options._onClick && $options._onClick(...args))
          },
          [
            vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ],
          6
          /* CLASS, STYLE */
        )
      ],
      4
      /* STYLE */
    )) : vue.createCommentVNode("v-if", true);
  }
  const __easycom_0 = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$P], ["__scopeId", "data-v-7a807eb7"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-grid/components/uni-grid-item/uni-grid-item.vue"]]);
  const _sfc_main$P = {
    name: "UniGrid",
    emits: ["change"],
    props: {
      // 每列显示个数
      column: {
        type: Number,
        default: 3
      },
      // 是否显示边框
      showBorder: {
        type: Boolean,
        default: true
      },
      // 边框颜色
      borderColor: {
        type: String,
        default: "#D2D2D2"
      },
      // 是否正方形显示,默认为 true
      square: {
        type: Boolean,
        default: true
      },
      highlight: {
        type: Boolean,
        default: true
      }
    },
    provide() {
      return {
        grid: this
      };
    },
    data() {
      const elId = `Uni_${Math.ceil(Math.random() * 1e6).toString(36)}`;
      return {
        elId,
        width: 0
      };
    },
    created() {
      this.children = [];
    },
    mounted() {
      this.$nextTick(() => {
        this.init();
      });
    },
    methods: {
      init() {
        setTimeout(() => {
          this._getSize((width) => {
            this.children.forEach((item, index) => {
              item.width = width;
            });
          });
        }, 50);
      },
      change(e2) {
        this.$emit("change", e2);
      },
      _getSize(fn) {
        uni.createSelectorQuery().in(this).select(`#${this.elId}`).boundingClientRect().exec((ret) => {
          this.width = parseInt((ret[0].width - 1) / this.column) + "px";
          fn(this.width);
        });
      }
    }
  };
  function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-grid-wrap" }, [
      vue.createElementVNode("view", {
        id: $data.elId,
        ref: "uni-grid",
        class: vue.normalizeClass(["uni-grid", { "uni-grid--border": $props.showBorder }]),
        style: vue.normalizeStyle({ "border-left-color": $props.borderColor })
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 14, ["id"])
    ]);
  }
  const __easycom_1$1 = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$O], ["__scopeId", "data-v-07acefee"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-grid/components/uni-grid/uni-grid.vue"]]);
  const _sfc_main$O = {
    name: "UniSection",
    emits: ["click"],
    props: {
      type: {
        type: String,
        default: ""
      },
      title: {
        type: String,
        required: true,
        default: ""
      },
      titleFontSize: {
        type: String,
        default: "14px"
      },
      titleColor: {
        type: String,
        default: "#333"
      },
      subTitle: {
        type: String,
        default: ""
      },
      subTitleFontSize: {
        type: String,
        default: "12px"
      },
      subTitleColor: {
        type: String,
        default: "#999"
      },
      padding: {
        type: [Boolean, String],
        default: false
      }
    },
    computed: {
      _padding() {
        if (typeof this.padding === "string") {
          return this.padding;
        }
        return this.padding ? "10px" : "";
      }
    },
    watch: {
      title(newVal) {
        if (uni.report && newVal !== "") {
          uni.report("title", newVal);
        }
      }
    },
    methods: {
      onClick() {
        this.$emit("click");
      }
    }
  };
  function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-section" }, [
      vue.createElementVNode("view", {
        class: "uni-section-header",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
      }, [
        $props.type ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 0,
            class: vue.normalizeClass(["uni-section-header__decoration", $props.type])
          },
          null,
          2
          /* CLASS */
        )) : vue.renderSlot(_ctx.$slots, "decoration", { key: 1 }, void 0, true),
        vue.createElementVNode("view", { class: "uni-section-header__content" }, [
          vue.createElementVNode(
            "text",
            {
              style: vue.normalizeStyle({ "font-size": $props.titleFontSize, "color": $props.titleColor }),
              class: vue.normalizeClass(["uni-section__content-title", { "distraction": !$props.subTitle }])
            },
            vue.toDisplayString($props.title),
            7
            /* TEXT, CLASS, STYLE */
          ),
          $props.subTitle ? (vue.openBlock(), vue.createElementBlock(
            "text",
            {
              key: 0,
              style: vue.normalizeStyle({ "font-size": $props.subTitleFontSize, "color": $props.subTitleColor }),
              class: "uni-section-header__content-sub"
            },
            vue.toDisplayString($props.subTitle),
            5
            /* TEXT, STYLE */
          )) : vue.createCommentVNode("v-if", true)
        ]),
        vue.createElementVNode("view", { class: "uni-section-header__slot-right" }, [
          vue.renderSlot(_ctx.$slots, "right", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode(
        "view",
        {
          class: "uni-section-content",
          style: vue.normalizeStyle({ padding: $options._padding })
        },
        [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ],
        4
        /* STYLE */
      )
    ]);
  }
  const __easycom_2 = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$N], ["__scopeId", "data-v-637fd36b"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-section/components/uni-section/uni-section.vue"]]);
  const _sfc_main$N = {
    props: {
      urls: {
        type: Array,
        required: true,
        default: () => {
          return [];
        }
      }
    },
    data() {
      return {
        show: false,
        current: 0,
        //当前页
        scale: 1,
        isZooming: false
        // 是否处于缩放状态
      };
    },
    methods: {
      getFileName(url) {
        const fileName = url.split("/").pop();
        const nameWithoutExtension = fileName.includes(".") ? fileName.substring(0, fileName.lastIndexOf(".")) : fileName;
        return nameWithoutExtension;
      },
      //打开
      open(current, index) {
        this.current = index;
        this.show = true;
        this.$emit("open");
      },
      //关闭
      close() {
        if (!this.isZooming) {
          this.show = false;
          this.current = 0;
          this.$emit("close");
        }
      },
      //图片改变
      swiperChange(e2) {
        this.current = e2.detail.current;
      },
      //监听长按
      onLongpress(e2) {
        this.$emit("onLongpress", e2);
      },
      handleTouchStart() {
        this.isZooming = true;
      },
      handleTouchEnd() {
        this.isZooming = false;
      }
    }
  };
  function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
    return $data.show ? (vue.openBlock(), vue.createElementBlock("view", {
      key: 0,
      class: "previewImage",
      onClick: _cache[3] || (_cache[3] = (...args) => $options.close && $options.close(...args))
    }, [
      $props.urls.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "page"
      }, [
        vue.createElementVNode("view", null, [
          vue.createElementVNode(
            "text",
            { class: "text" },
            vue.toDisplayString($data.current + 1) + " / " + vue.toDisplayString($props.urls.length),
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode("view", { style: { "height": "10px" } }),
        vue.createElementVNode("view", null, [
          vue.createElementVNode(
            "text",
            { class: "text" },
            vue.toDisplayString($options.getFileName($props.urls[$data.current])),
            1
            /* TEXT */
          )
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("swiper", {
        class: "swiper",
        current: $data.current,
        onChange: _cache[0] || (_cache[0] = (...args) => $options.swiperChange && $options.swiperChange(...args)),
        onTouchstart: _cache[1] || (_cache[1] = (...args) => $options.handleTouchStart && $options.handleTouchStart(...args)),
        onTouchend: _cache[2] || (_cache[2] = (...args) => $options.handleTouchEnd && $options.handleTouchEnd(...args))
      }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($props.urls, (item, index) => {
            return vue.openBlock(), vue.createElementBlock("swiper-item", { key: index }, [
              vue.createElementVNode("movable-area", {
                class: "movable-area",
                "scale-area": ""
              }, [
                vue.createElementVNode("movable-view", {
                  class: "movable-view",
                  direction: "all",
                  inertia: true,
                  damping: "100",
                  scale: "true",
                  "scale-min": "1",
                  "scale-max": "4",
                  "scale-value": $data.scale
                }, [
                  vue.createElementVNode("scroll-view", {
                    "scroll-y": "true",
                    class: "uni-scroll-view"
                  }, [
                    vue.createElementVNode("view", { class: "scroll-view" }, [
                      (vue.openBlock(), vue.createElementBlock("image", {
                        key: index,
                        class: "image",
                        src: item,
                        mode: "widthFix",
                        onLongpress: ($event) => $options.onLongpress(item)
                      }, null, 40, ["src", "onLongpress"]))
                    ])
                  ])
                ], 8, ["scale-value"])
              ])
            ]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ], 40, ["current"])
    ])) : vue.createCommentVNode("v-if", true);
  }
  const __easycom_3 = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$M], ["__scopeId", "data-v-fdd21252"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/q-previewImage/components/q-previewImage/q-previewImage.vue"]]);
  const _sfc_main$M = {
    name: "ysh-file-manager",
    props: {},
    data() {
      return {};
    },
    methods: {
      _openFile() {
        this.qxcz();
      },
      qxcz() {
        plus.android.requestPermissions(["android.permission.READ_EXTERNAL_STORAGE"], (e2) => {
          if (e2.deniedAlways.length > 0) {
            uni.showToast({
              title: "您拒绝了存储权限，请去设置-应用开启存储权限！",
              icon: "none",
              duration: 2e3
            });
          }
          if (e2.deniedPresent.length > 0) {
            plus.android.requestPermissions(["android.permission.READ_EXTERNAL_STORAGE"]);
          }
          if (e2.granted.length > 0) {
            this._openFileTemp();
          }
        }, function(e2) {
          formatAppLog("log", "at components/ysh-file-manager/ysh-file-manager.vue:41", "R12133313221" + JSON.stringify(e2));
        });
      },
      _openFileTemp() {
        let CODE_REQUEST = 1e3;
        if (plus.os.name.toLowerCase() != "android") {
          uni.showModal({
            title: "提示",
            content: "仅支持Android平台！",
            success: function(res) {
            }
          });
          return false;
        }
        let that = this;
        let main2 = plus.android.runtimeMainActivity();
        let Intent = plus.android.importClass("android.content.Intent");
        let fileIntent = new Intent(Intent.ACTION_GET_CONTENT);
        fileIntent.setType("*/*");
        fileIntent.addCategory(Intent.CATEGORY_OPENABLE);
        main2.onActivityResult = function(requestCode, resultCode, data) {
          let Activity = plus.android.importClass("android.app.Activity");
          let ContentUris = plus.android.importClass("android.content.ContentUris");
          plus.android.importClass("android.database.Cursor");
          let Uri = plus.android.importClass("android.net.Uri");
          let Build = plus.android.importClass("android.os.Build");
          let Environment = plus.android.importClass("android.os.Environment");
          let DocumentsContract = plus.android.importClass("android.provider.DocumentsContract");
          let MediaStore = plus.android.importClass("android.provider.MediaStore");
          let contentResolver = main2.getContentResolver();
          plus.android.importClass(contentResolver);
          let path = "";
          let size = "";
          if (resultCode == Activity.RESULT_OK) {
            let uri = data.getData();
            if ("file" == uri.getScheme().toLowerCase()) {
              path = uri.getPath();
            } else {
              if (Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT) {
                path = getPath(this, uri);
                let FileInputStream = plus.android.importClass("java.io.FileInputStream");
                let fileSize = new FileInputStream(path);
                size = fileSize.available();
                if (size == 0)
                  ;
                else if (size < 1024)
                  ;
                else if (size < 1048576) {
                  (size / 1024).toFixed(2) + "KB";
                } else if (size < 1073741824) {
                  (size / 1048576).toFixed(2) + "MB";
                } else {
                  (size / 1073741824).toFixed(2) + "GB";
                }
              } else {
                path = getRealPathFromURI(uri);
              }
            }
            that.$emit("result", {
              path,
              size
            });
          }
          function getPath(context, uri) {
            let isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
            let scheme = uri.getScheme().toLowerCase();
            if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {
              if (isExternalStorageDocument(uri)) {
                let docId = DocumentsContract.getDocumentId(uri);
                let split = docId.split(":");
                let type = split[0];
                if ("primary" == type.toLowerCase()) {
                  return Environment.getExternalStorageDirectory() + "/" + split[1];
                } else {
                  return "/storage/" + type + "/" + split[1];
                }
              } else if (isDownloadsDocument(uri)) {
                let id = DocumentsContract.getDocumentId(uri);
                if (id.indexOf(":") != -1) {
                  let split = id.split(":");
                  return split[1];
                } else {
                  let contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), id);
                  return getDataColumn(context, contentUri, null, null);
                }
              } else if (isMediaDocument(uri)) {
                let docId = DocumentsContract.getDocumentId(uri);
                let split = docId.split(":");
                let type = split[0];
                let contentUri = null;
                if ("image" == type.toLowerCase()) {
                  contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                } else if ("video" == type.toLowerCase()) {
                  contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
                } else if ("audio" == type.toLowerCase()) {
                  contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
                } else if ("document" == type.toLowerCase()) {
                  contentUri = MediaStore.Files.getContentUri("external");
                }
                let selection = "_id=?";
                let selectionArgs = [split[1]];
                return getDataColumn(context, contentUri, selection, selectionArgs);
              }
            } else if ("content" == scheme) {
              return getDataColumn(context, uri, null, null);
            } else if ("file" == scheme) {
              return uri.getPath();
            }
          }
          function getRealPathFromURI(uri) {
            let res = null;
            let proj = [MediaStore.Images.Media.DATA];
            let cursor = contentResolver.query(uri, proj, null, null, null);
            if (null != cursor && cursor.moveToFirst()) {
              let column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
              res = cursor.getString(column_index);
              cursor.close();
            }
            return res;
          }
          function getDataColumn(context, uri, selection, selectionArgs) {
            let cursor = null;
            let column = "_data";
            let projection = [column];
            cursor = contentResolver.query(uri, projection, selection, selectionArgs, null);
            if (cursor != null && cursor.moveToFirst()) {
              let column_index = cursor.getColumnIndexOrThrow(column);
              return cursor.getString(column_index);
            } else {
              return "";
            }
          }
          function isExternalStorageDocument(uri) {
            return "com.android.externalstorage.documents" == uri.getAuthority() ? true : false;
          }
          function isDownloadsDocument(uri) {
            return "com.android.providers.downloads.documents" == uri.getAuthority() ? true : false;
          }
          function isMediaDocument(uri) {
            return "com.android.providers.media.documents" == uri.getAuthority() ? true : false;
          }
        };
        main2.startActivityForResult(fileIntent, CODE_REQUEST);
      }
    }
  };
  function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view");
  }
  const __easycom_5 = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$L], ["__file", "E:/代码/new/zk_uniapp/components/ysh-file-manager/ysh-file-manager.vue"]]);
  let platform = "other";
  const _sfc_main$L = {
    name: "UniFab",
    emits: ["fabClick", "trigger"],
    props: {
      pattern: {
        type: Object,
        default() {
          return {};
        }
      },
      horizontal: {
        type: String,
        default: "left"
      },
      vertical: {
        type: String,
        default: "bottom"
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      content: {
        type: Array,
        default() {
          return [];
        }
      },
      show: {
        type: Boolean,
        default: false
      },
      popMenu: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        fabShow: false,
        isShow: false,
        isAndroidNvue: platform === "android",
        styles: {
          color: "#3c3e49",
          selectedColor: "#007AFF",
          backgroundColor: "#fff",
          buttonColor: "#007AFF",
          iconColor: "#fff",
          icon: "plusempty"
        }
      };
    },
    computed: {
      contentWidth(e2) {
        return (this.content.length + 1) * 55 + 15 + "px";
      },
      contentWidthMin() {
        return "55px";
      },
      // 动态计算宽度
      boxWidth() {
        return this.getPosition(3, "horizontal");
      },
      // 动态计算高度
      boxHeight() {
        return this.getPosition(3, "vertical");
      },
      // 计算左下位置
      leftBottom() {
        return this.getPosition(0, "left", "bottom");
      },
      // 计算右下位置
      rightBottom() {
        return this.getPosition(0, "right", "bottom");
      },
      // 计算左上位置
      leftTop() {
        return this.getPosition(0, "left", "top");
      },
      rightTop() {
        return this.getPosition(0, "right", "top");
      },
      flexDirectionStart() {
        return this.getPosition(1, "vertical", "top");
      },
      flexDirectionEnd() {
        return this.getPosition(1, "vertical", "bottom");
      },
      horizontalLeft() {
        return this.getPosition(2, "horizontal", "left");
      },
      horizontalRight() {
        return this.getPosition(2, "horizontal", "right");
      },
      // 计算 nvue bottom
      nvueBottom() {
        uni.getSystemInfoSync().windowBottom;
        return 30;
      }
    },
    watch: {
      pattern: {
        handler(val, oldVal) {
          this.styles = Object.assign({}, this.styles, val);
        },
        deep: true
      }
    },
    created() {
      this.isShow = this.show;
      if (this.top === 0) {
        this.fabShow = true;
      }
      this.styles = Object.assign({}, this.styles, this.pattern);
    },
    methods: {
      _onClick() {
        this.$emit("fabClick");
        if (!this.popMenu) {
          return;
        }
        this.isShow = !this.isShow;
      },
      open() {
        this.isShow = true;
      },
      close() {
        this.isShow = false;
      },
      /**
       * 按钮点击事件
       */
      _onItemClick(index, item) {
        if (!this.isShow) {
          return;
        }
        this.$emit("trigger", {
          index,
          item
        });
      },
      /**
       * 获取 位置信息
       */
      getPosition(types2, paramA, paramB) {
        if (types2 === 0) {
          return this.horizontal === paramA && this.vertical === paramB;
        } else if (types2 === 1) {
          return this.direction === paramA && this.vertical === paramB;
        } else if (types2 === 2) {
          return this.direction === paramA && this.horizontal === paramB;
        } else {
          return this.isShow && this.direction === paramA ? this.contentWidth : this.contentWidthMin;
        }
      }
    }
  };
  function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-cursor-point" }, [
      $props.popMenu && ($options.leftBottom || $options.rightBottom || $options.leftTop || $options.rightTop) && $props.content.length > 0 ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 0,
          class: vue.normalizeClass([{
            "uni-fab--leftBottom": $options.leftBottom,
            "uni-fab--rightBottom": $options.rightBottom,
            "uni-fab--leftTop": $options.leftTop,
            "uni-fab--rightTop": $options.rightTop
          }, "uni-fab"]),
          style: vue.normalizeStyle($options.nvueBottom)
        },
        [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass([{
                "uni-fab__content--left": $props.horizontal === "left",
                "uni-fab__content--right": $props.horizontal === "right",
                "uni-fab__content--flexDirection": $props.direction === "vertical",
                "uni-fab__content--flexDirectionStart": $options.flexDirectionStart,
                "uni-fab__content--flexDirectionEnd": $options.flexDirectionEnd,
                "uni-fab__content--other-platform": !$data.isAndroidNvue
              }, "uni-fab__content"]),
              style: vue.normalizeStyle({ width: $options.boxWidth, height: $options.boxHeight, backgroundColor: $data.styles.backgroundColor }),
              elevation: "5"
            },
            [
              $options.flexDirectionStart || $options.horizontalLeft ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 0,
                class: "uni-fab__item uni-fab__item--first"
              })) : vue.createCommentVNode("v-if", true),
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList($props.content, (item, index) => {
                  return vue.openBlock(), vue.createElementBlock("view", {
                    key: index,
                    class: vue.normalizeClass([{ "uni-fab__item--active": $data.isShow }, "uni-fab__item"]),
                    onClick: ($event) => $options._onItemClick(index, item)
                  }, [
                    vue.createElementVNode("image", {
                      src: item.active ? item.selectedIconPath : item.iconPath,
                      class: "uni-fab__item-image",
                      mode: "aspectFit"
                    }, null, 8, ["src"]),
                    vue.createElementVNode(
                      "text",
                      {
                        class: "uni-fab__item-text",
                        style: vue.normalizeStyle({ color: item.active ? $data.styles.selectedColor : $data.styles.color })
                      },
                      vue.toDisplayString(item.text),
                      5
                      /* TEXT, STYLE */
                    )
                  ], 10, ["onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              )),
              $options.flexDirectionEnd || $options.horizontalRight ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 1,
                class: "uni-fab__item uni-fab__item--first"
              })) : vue.createCommentVNode("v-if", true)
            ],
            6
            /* CLASS, STYLE */
          )
        ],
        6
        /* CLASS, STYLE */
      )) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode(
        "view",
        {
          class: vue.normalizeClass([{
            "uni-fab__circle--leftBottom": $options.leftBottom,
            "uni-fab__circle--rightBottom": $options.rightBottom,
            "uni-fab__circle--leftTop": $options.leftTop,
            "uni-fab__circle--rightTop": $options.rightTop,
            "uni-fab__content--other-platform": !$data.isAndroidNvue
          }, "uni-fab__circle uni-fab__plus"]),
          style: vue.normalizeStyle({ "background-color": $data.styles.buttonColor, "bottom": $options.nvueBottom }),
          onClick: _cache[0] || (_cache[0] = (...args) => $options._onClick && $options._onClick(...args))
        },
        [
          vue.createVNode(_component_uni_icons, {
            class: vue.normalizeClass(["fab-circle-icon", { "uni-fab__plus--active": $data.isShow && $props.content.length > 0 }]),
            type: $data.styles.icon,
            color: $data.styles.iconColor,
            size: "32"
          }, null, 8, ["type", "color", "class"]),
          vue.createCommentVNode(` <view class="fab-circle-v"  :class="{'uni-fab__plus--active': isShow && content.length > 0}"></view>\r
			<view class="fab-circle-h" :class="{'uni-fab__plus--active': isShow  && content.length > 0}"></view> `)
        ],
        6
        /* CLASS, STYLE */
      )
    ]);
  }
  const __easycom_6 = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$K], ["__scopeId", "data-v-85f34dfc"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-fab/components/uni-fab/uni-fab.vue"]]);
  const _sfc_main$K = {
    data() {
      return {
        context: null,
        currentTime: 0,
        duration: 100,
        status: false
      };
    },
    props: {
      url: String,
      activeColor: {
        type: String,
        default: "#0E7EFC"
      },
      startPic: String,
      endPic: String,
      audioId: [String, Number]
    },
    created() {
      this.context = uni.createInnerAudioContext();
      this.context.src = this.url;
      this.onTimeUpdate();
      this.onCanplay();
      this.onEnded();
      uni.$on("stop", (id) => {
        if (id && id != this.audioId) {
          this.context.stop();
          this.status = false;
        } else if (!id) {
          this.context.stop();
          this.status = false;
        }
      });
    },
    methods: {
      start(id) {
        if (this.status) {
          this.context.pause();
          this.status = !this.status;
        } else {
          uni.$emit("stop", id);
          this.context.play();
          this.status = !this.status;
        }
      },
      onCanplay() {
        this.context.onCanplay(() => {
          this.context.duration;
          setTimeout(() => {
            this.duration = this.context.duration;
          }, 1e3);
        });
      },
      onTimeUpdate() {
        this.context.onTimeUpdate(() => {
          if (!Number.isFinite(this.context.duration)) {
            this.duration = this.context.currentTime + 10;
            this.currentTime = this.context.currentTime;
          } else {
            this.duration = this.context.duration;
            this.currentTime = this.context.currentTime;
          }
        });
      },
      onEnded() {
        this.context.onEnded(() => {
          this.status = false;
          this.currentTime = 0;
        });
      },
      changeAudio(e2) {
        let paused = this.context.paused;
        this.context.pause();
        this.context.seek(e2.detail.value);
        if (!paused) {
          this.context.play();
        }
      },
      getTime(time) {
        let m2 = parseInt(time / 60);
        let s2 = time % 60;
        return this.towNum(m2) + ":" + this.towNum(s2);
      },
      towNum(num) {
        if (num >= 10) {
          return num;
        } else {
          return "0" + num;
        }
      }
    }
  };
  function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      vue.Fragment,
      null,
      [
        vue.createCommentVNode(" 音频播放器组件 "),
        $props.url ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "flex justify-between align-center audio"
        }, [
          vue.createElementVNode("view", {
            class: "mr-3",
            onClick: _cache[0] || (_cache[0] = ($event) => $options.start($props.audioId))
          }, [
            vue.withDirectives(vue.createElementVNode("image", {
              src: $props.startPic,
              class: "icon"
            }, null, 8, ["src"]), [
              [vue.vShow, !$data.status]
            ]),
            vue.withDirectives(vue.createElementVNode("image", {
              src: $props.endPic,
              class: "icon"
            }, null, 8, ["src"]), [
              [vue.vShow, $data.status]
            ])
          ]),
          vue.createElementVNode("view", { class: "flex-1" }, [
            vue.createElementVNode("slider", {
              onChange: _cache[1] || (_cache[1] = (...args) => $options.changeAudio && $options.changeAudio(...args)),
              activeColor: $props.activeColor,
              min: 0,
              max: $data.duration.toFixed(0),
              value: $data.currentTime.toFixed(0),
              step: 0.1
            }, null, 40, ["activeColor", "max", "value"])
          ]),
          vue.createElementVNode(
            "view",
            { class: "ml-3" },
            vue.toDisplayString($options.getTime(Math.round($data.currentTime))),
            1
            /* TEXT */
          )
        ])) : vue.createCommentVNode("v-if", true)
      ],
      2112
      /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
    );
  }
  const freeAudio = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$J], ["__scopeId", "data-v-615c0603"], ["__file", "E:/代码/new/zk_uniapp/components/chengpeng-audio/free-audio.vue"]]);
  const _imports_0$9 = "/static/icon/take_video.png";
  const _imports_1$3 = "/static/icon/audio.png";
  const _sfc_main$J = {
    components: { freeAudio, yshFileManager: __easycom_5 },
    data() {
      return {
        missionId: "",
        fileInfo: [],
        pattern: {
          color: "#7A7E83",
          backgroundColor: "#fff",
          selectedColor: "#007AFF",
          buttonColor: "#007AFF",
          iconColor: "#fff"
        },
        horizontal: "right",
        vertical: "bottom",
        direction: "horizontal",
        isFullScreen: false,
        videoPlay: false,
        videoUrl: "",
        audioUrl: "",
        imgPath: [
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
        ],
        videoPath: [
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
        ],
        audioPath: [],
        content: [
          {
            iconPath: "../../../../static/icon/图片-选中.png",
            selectedIconPath: "../../../../static/icon/图片-选中.png",
            text: "上传图片",
            active: false
          },
          {
            iconPath: "../../../../static/icon/video.png",
            selectedIconPath: "../../../../static/icon/video.png",
            text: "上传视频",
            active: false
          },
          {
            iconPath: "../../../../static/icon/document_select.png",
            selectedIconPath: "../../../../static/icon/document_select.png",
            text: "其他文件",
            active: false
          }
        ],
        video_src: "",
        image_src: [],
        FileTypes: [
          { type: "图片", iconName: "image" },
          { type: "视频", iconName: "camera" },
          { type: "音频", iconName: "mic" }
        ],
        videoContext: uni.createVideoContext("myVideo", this)
        // 这个是实例对象
      };
    },
    mounted() {
      this.initializeDocuments();
    },
    onLoad(options) {
      if (options.missionId) {
        this.missionId = options.missionId;
      } else {
        formatAppLog("error", "at pages/task/task_detail/document/document.vue:149", "没有传递类型参数");
      }
    },
    methods: {
      initializeDocuments() {
        uni.showLoading({
          title: "正在加载文件",
          mask: true
        });
        getMissionFileById(this.missionId, 1, 100).then((res) => {
          formatAppLog("log", "at pages/task/task_detail/document/document.vue:159", "res", res);
          this.fileInfo = res.data.missionFiles.records;
          uni.hideLoading();
          if (this.fileInfo != null && this.fileInfo != "") {
            this.fileInfo.forEach((item, index) => {
              getFileUrl(item.id).then((res2) => {
                switch (item.fileType) {
                  case "mp3":
                    this.audioPath.push(res2.data);
                    break;
                  case "png":
                    this.imgPath.push(res2.data);
                    break;
                  case "jpg":
                    this.imgPath.push(res2.data);
                    break;
                  case "mp4":
                    this.videoPath.push(res2.data);
                    break;
                }
              });
            });
          }
        });
      },
      uploadFile() {
        this.$refs.filemanager._openFile();
      },
      getFileName(url) {
        const fileName = url.split("/").pop();
        const nameWithoutExtension = fileName.includes(".") ? fileName.substring(0, fileName.lastIndexOf(".")) : fileName;
        return nameWithoutExtension;
      },
      preview(url, index) {
        this.$refs.previewImage.open(url, index);
      },
      screenChange(e2) {
        this.isFullScreen = e2.detail.fullScreen;
        if (!this.isFullScreen) {
          this.videoPlay = false;
          this.videoContext.stop();
        }
      },
      // 触发全屏播放的点击事件
      async videoShow(item) {
        this.videoPlay = true;
        this.videoUrl = item;
        this.videoContext.requestFullScreen({ direction: 0 });
        this.videoContext.play();
      },
      openVideo() {
        this.videoPlay = true;
      },
      openAudioPopup(index) {
        this.$refs.audioPopup.open();
        this.audioUrl = this.audioPath[index];
        formatAppLog("log", "at pages/task/task_detail/document/document.vue:226", "url", this.audioPath);
      },
      clickMask() {
        this.$refs.audioPopup.close();
        uni.$emit("stop");
      },
      trigger(e2) {
        if (e2.item.text === "上传图片") {
          this.uploadImage();
        } else if (e2.item.text === "上传视频") {
          this.uploadVideo();
        } else if (e2.item.text === "其他文件") {
          this.uploadFile();
        }
      },
      handleResult(fileInfo) {
        formatAppLog("log", "at pages/task/task_detail/document/document.vue:242", "fileInfoPath", fileInfo.path);
        uni.uploadFile({
          url: `http://139.196.11.210:8500/communicate/mission/upload/file`,
          filePath: fileInfo.path,
          name: "files",
          formData: {
            "latitude": "12",
            "longitude": "123",
            "missionId": this.missionId
          },
          header: {
            "Content-Type": "multipart/form-data;",
            "Authorization": "Bearer " + uni.getStorageSync("token")
          },
          success: (uploadFileRes) => {
            const res = JSON.parse(uploadFileRes.data);
            if (res.code === 200) {
              uni.showToast({
                title: "文件上传成功！",
                //将值设置为 success 或者直接不用写icon这个参数
                icon: "success",
                //显示持续时间为 2秒
                duration: 2e3
              });
            } else {
              uni.showToast({
                title: "文件上传失败！",
                icon: "none",
                //显示持续时间为 2秒
                duration: 2e3
              });
            }
            formatAppLog("log", "at pages/task/task_detail/document/document.vue:274", uploadFileRes.data);
          }
        });
      },
      uploadVideo: function() {
        var self2 = this;
        uni.chooseVideo({
          sourceType: ["camera", "album"],
          success: function(res) {
            const tempFilePath = res.tempFilePath;
            formatAppLog("log", "at pages/task/task_detail/document/document.vue:284", "tempFilePath", tempFilePath);
            formatAppLog("log", "at pages/task/task_detail/document/document.vue:285", "id", self2.missionId);
            uni.uploadFile({
              url: `http://139.196.11.210:8500/communicate/mission/upload/file`,
              filePath: tempFilePath,
              name: "files",
              formData: {
                "latitude": "12",
                "longitude": "123",
                "missionId": self2.missionId
              },
              header: {
                "Content-Type": "multipart/form-data;",
                "Authorization": "Bearer " + uni.getStorageSync("token")
              },
              success: (uploadFileRes) => {
                const res2 = JSON.parse(uploadFileRes.data);
                if (res2.code === 200) {
                  uni.showToast({
                    title: "视频上传成功！",
                    //将值设置为 success 或者直接不用写icon这个参数
                    icon: "success",
                    //显示持续时间为 2秒
                    duration: 2e3
                  });
                } else {
                  uni.showToast({
                    title: "视频上传失败！",
                    icon: "none",
                    //显示持续时间为 2秒
                    duration: 2e3
                  });
                }
                formatAppLog("log", "at pages/task/task_detail/document/document.vue:318", uploadFileRes.data);
              }
            });
          }
        });
      },
      uploadImage: function() {
        var self2 = this;
        uni.chooseImage({
          count: 6,
          //默认9
          sizeType: ["original", "compressed"],
          //可以指定是原图还是压缩图，默认二者都有
          sourceType: ["album", "camera"],
          success: function(res) {
            let ok = 0;
            let index = 0;
            const length = res.tempFilePaths.length;
            for (const tempFilePath of res.tempFilePaths) {
              uni.uploadFile({
                url: "http://139.196.11.210:8500/communicate/mission/upload/file",
                filePath: tempFilePath,
                name: "files",
                formData: {
                  "latitude": "12",
                  "longitude": "123",
                  "missionId": self2.missionId
                },
                header: {
                  "Content-Type": "multipart/form-data;",
                  "Authorization": "Bearer " + uni.getStorageSync("token")
                },
                success: (uploadFileRes) => {
                  index = index + 1;
                  if (uploadFileRes.statusCode === 200) {
                    ok = ok + 1;
                  }
                  if (ok === length) {
                    uni.showToast({
                      title: "上传成功！",
                      icon: "success",
                      duration: 2e3
                    });
                  }
                  if (index === length && ok < length) {
                    const fail = length - ok;
                    uni.showToast({
                      title: fail + "张上传失败！",
                      icon: "none",
                      duration: 2e3
                    });
                  }
                }
              });
            }
          }
        });
      }
    }
  };
  function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_grid_item = resolveEasycom(vue.resolveDynamicComponent("uni-grid-item"), __easycom_0);
    const _component_uni_grid = resolveEasycom(vue.resolveDynamicComponent("uni-grid"), __easycom_1$1);
    const _component_uni_section = resolveEasycom(vue.resolveDynamicComponent("uni-section"), __easycom_2);
    const _component_q_previewImage = resolveEasycom(vue.resolveDynamicComponent("q-previewImage"), __easycom_3);
    const _component_free_audio = vue.resolveComponent("free-audio");
    const _component_uni_popup = resolveEasycom(vue.resolveDynamicComponent("uni-popup"), __easycom_2$1);
    const _component_ysh_file_manager = resolveEasycom(vue.resolveDynamicComponent("ysh-file-manager"), __easycom_5);
    const _component_uni_fab = resolveEasycom(vue.resolveDynamicComponent("uni-fab"), __easycom_6);
    return vue.openBlock(), vue.createElementBlock("view", { style: { "background": "#fff" } }, [
      vue.createElementVNode("view", { style: { "padding": "0 0 10px 7px", "box-sizing": "border-box" } }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($data.FileTypes, (file, file_index) => {
            return vue.openBlock(), vue.createBlock(_component_uni_section, {
              key: file_index,
              title: file.type,
              type: "line"
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(
                  _component_uni_grid,
                  {
                    column: 4,
                    "show-border": false
                  },
                  {
                    default: vue.withCtx(() => [
                      vue.createCommentVNode(" 图片 "),
                      file_index === 0 ? (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        { key: 0 },
                        vue.renderList($data.imgPath, (item, index) => {
                          return vue.openBlock(), vue.createBlock(
                            _component_uni_grid_item,
                            { key: index },
                            {
                              default: vue.withCtx(() => [
                                vue.createElementVNode("view", { style: { "border-radius": "3px", "width": "83px", "height": "83px", "display": "flex", "align-items": "center", "justify-content": "center" } }, [
                                  vue.createElementVNode("image", {
                                    src: item,
                                    onClick: ($event) => $options.preview(item, index),
                                    style: { "width": "83px", "height": "83px" }
                                  }, null, 8, ["src", "onClick"])
                                ])
                              ]),
                              _: 2
                              /* DYNAMIC */
                            },
                            1024
                            /* DYNAMIC_SLOTS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      )) : vue.createCommentVNode("v-if", true),
                      vue.createCommentVNode(" 视频 "),
                      file_index === 1 ? (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        vue.renderList($data.videoPath, (item, index) => {
                          return vue.openBlock(), vue.createBlock(
                            _component_uni_grid_item,
                            { key: index },
                            {
                              default: vue.withCtx(() => [
                                vue.createElementVNode("view", { style: { "background-color": "black", "border-radius": "3px", "width": "83px", "height": "83px", "display": "flex", "align-items": "center", "justify-content": "center" } }, [
                                  vue.createElementVNode("image", {
                                    onTouchstart: _cache[0] || (_cache[0] = ($event) => $options.openVideo()),
                                    onClick: ($event) => $options.videoShow(item),
                                    src: _imports_0$9,
                                    style: { "width": "50px", "height": "50px" }
                                  }, null, 40, ["onClick"])
                                ])
                              ]),
                              _: 2
                              /* DYNAMIC */
                            },
                            1024
                            /* DYNAMIC_SLOTS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      )) : vue.createCommentVNode("v-if", true),
                      file_index === 2 ? (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        { key: 2 },
                        vue.renderList($data.audioPath, (item, index) => {
                          return vue.openBlock(), vue.createBlock(
                            _component_uni_grid_item,
                            { key: index },
                            {
                              default: vue.withCtx(() => [
                                vue.createElementVNode("view", { style: { "background-color": "lightgrey", "border-radius": "3px", "width": "83px", "height": "83px", "display": "flex", "align-items": "center", "justify-content": "center" } }, [
                                  vue.createElementVNode("image", {
                                    onClick: ($event) => $options.openAudioPopup(index),
                                    src: _imports_1$3,
                                    style: { "width": "35px", "height": "35px" }
                                  }, null, 8, ["onClick"])
                                ])
                              ]),
                              _: 2
                              /* DYNAMIC */
                            },
                            1024
                            /* DYNAMIC_SLOTS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      )) : vue.createCommentVNode("v-if", true)
                    ]),
                    _: 2
                    /* DYNAMIC */
                  },
                  1024
                  /* DYNAMIC_SLOTS */
                )
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["title"]);
          }),
          128
          /* KEYED_FRAGMENT */
        )),
        vue.createCommentVNode(" 图片预览组件 "),
        vue.createVNode(_component_q_previewImage, {
          ref: "previewImage",
          urls: $data.imgPath,
          onOnLongpress: _cache[1] || (_cache[1] = () => {
          }),
          onOpen: _cache[2] || (_cache[2] = () => {
          }),
          onClose: _cache[3] || (_cache[3] = () => {
          })
        }, null, 8, ["urls"]),
        vue.createCommentVNode(" 视频预览界面 "),
        $data.videoPlay ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, [
          vue.createElementVNode("video", {
            id: "myVideo",
            src: $data.videoUrl,
            onFullscreenchange: _cache[4] || (_cache[4] = (...args) => $options.screenChange && $options.screenChange(...args)),
            style: { "height": "1px", "width": "1px" },
            controls: "",
            autoplay: ""
          }, null, 40, ["src"])
        ])) : vue.createCommentVNode("v-if", true)
      ]),
      vue.createCommentVNode(" 音频预览弹窗 "),
      vue.createVNode(
        _component_uni_popup,
        {
          ref: "audioPopup",
          type: "bottom",
          onMaskClick: _cache[6] || (_cache[6] = ($event) => $options.clickMask())
        },
        {
          default: vue.withCtx(() => [
            vue.createElementVNode("view", { style: { "background": "#fff", "border-radius": "5px", "padding": "10px" } }, [
              vue.createElementVNode("view", { style: { "display": "flex", "justify-content": "space-between" } }, [
                vue.createElementVNode("view", null, [
                  vue.createElementVNode(
                    "text",
                    null,
                    vue.toDisplayString($options.getFileName($data.audioUrl)),
                    1
                    /* TEXT */
                  )
                ]),
                vue.createElementVNode("view", {
                  style: { "margin-right": "10px" },
                  onClick: _cache[5] || (_cache[5] = ($event) => $options.clickMask())
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_2$1,
                    style: { "width": "15px", "height": "15px" }
                  })
                ])
              ]),
              vue.createElementVNode("view", { class: "divider" }),
              vue.createCommentVNode(" 支持mp3、ogg等 "),
              $data.audioUrl ? (vue.openBlock(), vue.createBlock(_component_free_audio, {
                key: 0,
                startPic: "../../../../static/icon/take_video.png",
                endPic: "../../../../static/icon/pause.png",
                audioId: "audio1",
                url: $data.audioUrl
              }, null, 8, ["url"])) : vue.createCommentVNode("v-if", true)
            ])
          ]),
          _: 1
          /* STABLE */
        },
        512
        /* NEED_PATCH */
      ),
      vue.createCommentVNode(" 文件上传 "),
      vue.createVNode(_component_ysh_file_manager, {
        ref: "filemanager",
        onResult: $options.handleResult
      }, null, 8, ["onResult"]),
      vue.createElementVNode("view", { style: { "background-color": "#fff" } }, [
        vue.createVNode(_component_uni_fab, {
          pattern: $data.pattern,
          content: $data.content,
          horizontal: $data.horizontal,
          vertical: $data.vertical,
          direction: $data.direction,
          onTrigger: $options.trigger
        }, null, 8, ["pattern", "content", "horizontal", "vertical", "direction", "onTrigger"])
      ])
    ]);
  }
  const PagesTaskTaskDetailDocumentDocument = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$I], ["__file", "E:/代码/new/zk_uniapp/pages/task/task_detail/document/document.vue"]]);
  const _sfc_main$I = {
    data() {
      return {};
    },
    mounted() {
      const subNVue = uni.getSubNVueById("condition_icons");
      subNVue.show("none", 300, function() {
        formatAppLog("log", "at pages/task/task_detail/baidu_map/baidu_map.vue:20", subNVue, "subNVue");
        subNVue.setStyle({
          top: "0px",
          bottom: "0px",
          left: "0px",
          right: "0px",
          zIndex: 999
        });
        formatAppLog("log", "at pages/task/task_detail/baidu_map/baidu_map.vue:28", "open success");
      });
    },
    methods: {}
  };
  function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "map-container" }, [
      vue.createElementVNode("web-view", { src: "/static/html/map_baidu.html" })
    ]);
  }
  const PagesTaskTaskDetailBaiduMapBaiduMap = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$H], ["__file", "E:/代码/new/zk_uniapp/pages/task/task_detail/baidu_map/baidu_map.vue"]]);
  const _sfc_main$H = {
    name: "OptionPicker",
    props: {
      title: String,
      options: Array,
      selectedValue: String
    },
    methods: {
      selectOption(value) {
        this.$emit("select", value);
      }
    }
  };
  function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "picker-wrapper" }, [
      vue.createElementVNode("view", {
        class: "picker-overlay",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("close"))
      }, [
        vue.createElementVNode("view", {
          class: "picker-content",
          onClick: _cache[2] || (_cache[2] = vue.withModifiers(() => {
          }, ["stop"]))
        }, [
          vue.createElementVNode("view", { class: "picker-header" }, [
            vue.createElementVNode(
              "text",
              { class: "picker-title" },
              vue.toDisplayString($props.title),
              1
              /* TEXT */
            ),
            vue.createElementVNode("text", {
              class: "picker-close",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
            }, "×")
          ]),
          vue.createElementVNode("view", { class: "picker-options" }, [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($props.options, (option) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  key: option.value,
                  class: vue.normalizeClass(["picker-option", { "selected": $props.selectedValue === option.value }]),
                  onClick: ($event) => $options.selectOption(option.value)
                }, [
                  vue.createElementVNode(
                    "text",
                    null,
                    vue.toDisplayString(option.label),
                    1
                    /* TEXT */
                  )
                ], 10, ["onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          vue.createElementVNode("view", { class: "picker-footer" }, [
            vue.createElementVNode("button", {
              class: "picker-btn",
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close"))
            }, "取消")
          ])
        ])
      ])
    ]);
  }
  const OptionPicker = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$G], ["__scopeId", "data-v-2798e3c8"], ["__file", "E:/代码/new/zk_uniapp/pages/profile/OptionPicker.vue"]]);
  const _imports_0$8 = "/static/my/编辑.svg";
  const _imports_1$2 = "/static/my/展开.svg";
  const _sfc_main$G = {
    __name: "profile",
    setup(__props, { expose: __expose }) {
      __expose();
      const userStore = useUserStore();
      const userData = vue.computed(() => userStore.getUserData());
      const locationSharing = vue.ref(false);
      const showConfirmDialog = vue.ref(false);
      const confirmMessage = vue.ref("");
      const deleteType = vue.ref("");
      const selectedStorageStrategy = vue.ref("7天");
      const storageOptions = [
        { label: "7天", value: "7天" },
        { label: "15天", value: "15天" },
        { label: "30天", value: "30天" }
      ];
      const selectedLocationInterval = vue.ref("5分钟");
      const locationIntervalOptions = [
        { label: "1分钟", value: "1分钟" },
        { label: "5分钟", value: "5分钟" },
        { label: "10分钟", value: "10分钟" },
        { label: "30分钟", value: "30分钟" }
      ];
      const showPicker = vue.ref(false);
      const pickerTitle = vue.ref("");
      const pickerOptions = vue.ref([]);
      const pickerSelectedValue = vue.ref("");
      const pickerType = vue.ref("");
      const settingItems = vue.reactive([
        { label: "定位信息回传间隔", value: "5分钟" },
        { label: "文件本地存储策略", value: "7天" },
        { label: "修改密码", value: "" }
      ]);
      const loadUserData = async () => {
        if (!userData.value.id) {
          const userInfo = uni.getStorageSync("userInfo");
          if (userInfo && typeof userInfo === "object") {
            userStore.setUserData(userInfo);
          }
        }
      };
      vue.onMounted(() => {
        loadUserData();
      });
      onShow(() => {
        loadUserData().catch((error) => {
          formatAppLog("error", "at pages/profile/profile.vue:163", "onShow 中出现错误:", error);
        });
      });
      const onSettingItemClick = (item) => {
        if (item.label === "文件本地存储策略") {
          openPicker("storage", "文件本地存储策略", storageOptions, selectedStorageStrategy.value);
        } else if (item.label === "定位信息回传间隔") {
          openPicker("location", "定位信息回传间隔", locationIntervalOptions, selectedLocationInterval.value);
        } else if (item.label === "修改密码") {
          uni.navigateTo({
            url: "/pages/forgetPassword/forgetPassword"
          });
        }
      };
      const openPicker = (type, title, options, selectedValue) => {
        pickerType.value = type;
        pickerTitle.value = title;
        pickerOptions.value = options;
        pickerSelectedValue.value = selectedValue;
        showPicker.value = true;
      };
      const closePicker = () => {
        showPicker.value = false;
      };
      const selectOption = (value) => {
        if (pickerType.value === "storage") {
          selectedStorageStrategy.value = value;
          settingItems.find((item) => item.label === "文件本地存储策略").value = value;
        } else if (pickerType.value === "location") {
          selectedLocationInterval.value = value;
          settingItems.find((item) => item.label === "定位信息回传间隔").value = value;
        }
        closePicker();
      };
      const showDeleteConfirm = (type) => {
        deleteType.value = type;
        confirmMessage.value = type === "chat" ? "确定删除聊天记录吗？" : "您确认要删除所有数据吗？";
        showConfirmDialog.value = true;
      };
      const cancelDelete = () => {
        showConfirmDialog.value = false;
      };
      const confirmDelete = () => {
        if (deleteType.value === "chat") {
          formatAppLog("log", "at pages/profile/profile.vue:214", "聊天记录已删除");
        } else {
          formatAppLog("log", "at pages/profile/profile.vue:216", "所有数据已删除");
        }
        showConfirmDialog.value = false;
      };
      const performLogout = async () => {
        uni.showLoading({
          title: "正在退出登录",
          mask: true
        });
        try {
          if (uni.getStorageSync("token")) {
            await logout();
          }
        } catch (error) {
          formatAppLog("error", "at pages/profile/profile.vue:232", "退出登录失败:", error);
        } finally {
          uni.removeStorageSync("token");
          uni.removeStorageSync("userInfo");
          userStore.clearUserData();
          uni.redirectTo({
            url: "/pages/login/camouflageLogin/camouflageLogin"
          });
          uni.hideLoading();
        }
      };
      const onLocationSharingChange = (e2) => {
        locationSharing.value = e2.detail.value;
      };
      const __returned__ = { userStore, userData, locationSharing, showConfirmDialog, confirmMessage, deleteType, selectedStorageStrategy, storageOptions, selectedLocationInterval, locationIntervalOptions, showPicker, pickerTitle, pickerOptions, pickerSelectedValue, pickerType, settingItems, loadUserData, onSettingItemClick, openPicker, closePicker, selectOption, showDeleteConfirm, cancelDelete, confirmDelete, performLogout, onLocationSharingChange, ref: vue.ref, reactive: vue.reactive, onMounted: vue.onMounted, computed: vue.computed, get onShow() {
        return onShow;
      }, OptionPicker, get useUserStore() {
        return useUserStore;
      }, get logout() {
        return logout;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    return vue.openBlock(), vue.createElementBlock("view", { class: "container" }, [
      vue.createElementVNode("view", null, [
        vue.createVNode(_component_uni_nav_bar, {
          fixed: true,
          "status-bar": "",
          title: "我的"
        })
      ]),
      vue.createCommentVNode(" 用户头像、姓名、用户名和电话 "),
      vue.createElementVNode("view", { class: "user-info" }, [
        vue.createElementVNode("image", {
          class: "avatar",
          src: $setup.userData.avatarUrl || "/static/my/默认头像.svg"
        }, null, 8, ["src"]),
        vue.createElementVNode("view", { class: "user-details" }, [
          vue.createElementVNode("view", { class: "name-container" }, [
            vue.createElementVNode(
              "text",
              { class: "name" },
              vue.toDisplayString($setup.userData.name || "未设置"),
              1
              /* TEXT */
            ),
            vue.createElementVNode("image", {
              class: "edit-icon",
              src: _imports_0$8
            })
          ]),
          vue.createElementVNode("view", { class: "info-item" }, [
            vue.createElementVNode("text", { class: "info-label" }, "用户名："),
            vue.createElementVNode(
              "text",
              { class: "info-value" },
              vue.toDisplayString($setup.userData.account || "未设置"),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", { class: "info-item" }, [
            vue.createElementVNode("text", { class: "info-label" }, "手机："),
            vue.createElementVNode(
              "text",
              { class: "info-value" },
              vue.toDisplayString($setup.userData.phone || "未设置"),
              1
              /* TEXT */
            )
          ])
        ])
      ]),
      vue.createCommentVNode(" 位置共享开关 "),
      vue.createElementVNode("view", { class: "switch-item" }, [
        vue.createElementVNode("text", null, "是否开启位置共享"),
        vue.createElementVNode("switch", {
          color: "#4285f4",
          checked: $setup.locationSharing,
          onChange: $setup.onLocationSharingChange
        }, null, 40, ["checked"])
      ]),
      vue.createCommentVNode(" 设置列表 "),
      vue.createElementVNode("view", { class: "setting-list" }, [
        vue.createElementVNode("view", {
          class: "setting-item",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.onSettingItemClick($setup.settingItems[0]))
        }, [
          vue.createElementVNode("text", null, "定位信息回传间隔"),
          vue.createElementVNode("view", { class: "setting-value" }, [
            vue.createElementVNode(
              "text",
              { class: "setting-value-text" },
              vue.toDisplayString($setup.selectedLocationInterval),
              1
              /* TEXT */
            ),
            vue.createElementVNode("image", {
              class: "expand-icon",
              src: _imports_1$2
            })
          ])
        ]),
        vue.createElementVNode("view", {
          class: "setting-item",
          onClick: _cache[1] || (_cache[1] = ($event) => $setup.onSettingItemClick($setup.settingItems[1]))
        }, [
          vue.createElementVNode("text", null, "文件本地存储策略"),
          vue.createElementVNode("view", { class: "setting-value" }, [
            vue.createElementVNode(
              "text",
              { class: "setting-value-text" },
              vue.toDisplayString($setup.selectedStorageStrategy),
              1
              /* TEXT */
            ),
            vue.createElementVNode("image", {
              class: "expand-icon",
              src: _imports_1$2
            })
          ])
        ]),
        vue.createElementVNode("view", {
          class: "setting-item",
          onClick: _cache[2] || (_cache[2] = ($event) => $setup.onSettingItemClick($setup.settingItems[2]))
        }, [
          vue.createElementVNode("text", null, "修改密码"),
          vue.createElementVNode("view", { class: "setting-value" }, [
            vue.createElementVNode("image", {
              class: "expand-icon",
              src: _imports_1$2
            })
          ])
        ])
      ]),
      vue.createCommentVNode(" 删除聊天记录按钮 "),
      vue.createElementVNode("view", {
        class: "delete-chat",
        onClick: _cache[3] || (_cache[3] = ($event) => $setup.showDeleteConfirm("chat"))
      }, [
        vue.createElementVNode("text", null, "删除聊天记录")
      ]),
      vue.createElementVNode("view", {
        class: "delete-all",
        onClick: _cache[4] || (_cache[4] = ($event) => $setup.showDeleteConfirm("all"))
      }, [
        vue.createElementVNode("text", null, "一键删除")
      ]),
      vue.createCommentVNode(" 退出登录按钮 "),
      vue.createElementVNode("view", {
        class: "logout",
        onClick: $setup.performLogout
      }, [
        vue.createElementVNode("text", null, "退出登录")
      ]),
      vue.createCommentVNode(" 确认对话框 "),
      $setup.showConfirmDialog ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "dialog-overlay"
      }, [
        vue.createElementVNode("view", { class: "dialog-content" }, [
          vue.createElementVNode("view", { class: "dialog-body" }, [
            vue.createElementVNode(
              "text",
              null,
              vue.toDisplayString($setup.confirmMessage),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", { class: "dialog-footer" }, [
            vue.createElementVNode("button", {
              class: "dialog-btn cancel-btn",
              onClick: $setup.cancelDelete
            }, "取消"),
            vue.createElementVNode("button", {
              class: "dialog-btn confirm-btn",
              onClick: $setup.confirmDelete
            }, "确认")
          ])
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" 选项选择器 "),
      $setup.showPicker ? (vue.openBlock(), vue.createBlock($setup["OptionPicker"], {
        key: 1,
        title: $setup.pickerTitle,
        options: $setup.pickerOptions,
        selectedValue: $setup.pickerSelectedValue,
        onSelect: $setup.selectOption,
        onClose: $setup.closePicker
      }, null, 8, ["title", "options", "selectedValue"])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const PagesProfileProfile = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$F], ["__file", "E:/代码/new/zk_uniapp/pages/profile/profile.vue"]]);
  const _sfc_main$F = {
    name: "SystemMessage",
    // 定义组件的属性
    props: {
      message: {
        type: Object,
        required: true
      }
    }
  };
  function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "message-item system-message" }, [
      vue.createElementVNode("view", { class: "avatar-container" }, [
        vue.createElementVNode("view", { class: "system-icon" }, [
          vue.createElementVNode("text", null, "📢")
        ]),
        $props.message.notificationCount > 0 ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 0,
            class: "avatar-badge"
          },
          vue.toDisplayString($props.message.notificationCount),
          1
          /* TEXT */
        )) : vue.createCommentVNode("v-if", true)
      ]),
      vue.createElementVNode("view", { class: "message-content-wrapper" }, [
        vue.createElementVNode("view", { class: "message-content" }, [
          vue.createElementVNode(
            "view",
            { class: "message-title" },
            vue.toDisplayString($props.message.title),
            1
            /* TEXT */
          ),
          vue.createElementVNode(
            "view",
            { class: "message-preview" },
            vue.toDisplayString($props.message.preview),
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode(
          "view",
          { class: "message-date" },
          vue.toDisplayString($props.message.date),
          1
          /* TEXT */
        )
      ])
    ]);
  }
  const SystemMessage = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$E], ["__scopeId", "data-v-75911b46"], ["__file", "E:/代码/new/zk_uniapp/pages/message/MainComponents/SystemMessage.vue"]]);
  const _sfc_main$E = {
    name: "GroupAvatar",
    props: {
      // 头像数组
      avatar: {
        type: Array,
        required: true
      }
    },
    computed: {
      // 计算要显示的头像源
      avatarSources() {
        return this.avatar.slice(0, 4);
      }
    }
  };
  function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "group-avatar" }, [
      (vue.openBlock(true), vue.createElementBlock(
        vue.Fragment,
        null,
        vue.renderList($options.avatarSources, (src, index) => {
          return vue.openBlock(), vue.createElementBlock("image", {
            key: index,
            src,
            class: "avatar-image"
          }, null, 8, ["src"]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]);
  }
  const GroupAvatar = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$D], ["__scopeId", "data-v-911ba5e2"], ["__file", "E:/代码/new/zk_uniapp/pages/message/MainComponents/GroupAvatar.vue"]]);
  const getCurrentDate = () => {
    const now2 = /* @__PURE__ */ new Date();
    const month = now2.getMonth() + 1;
    const day = now2.getDate();
    return `${month}月${day}日`;
  };
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const now2 = /* @__PURE__ */ new Date();
    const diffDays = Math.floor((now2 - date) / (1e3 * 60 * 60 * 24));
    if (diffDays === 0) {
      return formatTime(date);
    } else if (diffDays === 1) {
      return "昨天";
    } else if (diffDays < 7) {
      const weekdays = ["周日", "周一", "周二", "周三", "周四", "周五", "周六"];
      return weekdays[date.getDay()];
    } else {
      const month = date.getMonth() + 1;
      const day = date.getDate();
      return `${month}月${day}日`;
    }
  };
  const formatTime = (date) => {
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");
    return `${hours}:${minutes}`;
  };
  const createDemoMessages = () => vue.ref([
    // {
    //   id: '1',
    //   name: '张三',
    //   avatar: ['/static/avatar/avatar1.png'],
    //   preview: '你好，最近怎么样？',
    //   date: '2024-11-25T10:00:00',
    //   type: 'single',
    //   unreadCount: 2
    // },
    // {
    //   id: '2',
    //   name: '项目讨论群',
    //   avatar: ['/static/avatar/group1.png', '/static/avatar/group2.png', '/static/avatar/group3.png'],
    //   preview: '下周一开会，请大家准时参加',
    //   date: '2024-11-24T15:30:00',
    //   type: 'group',
    //   unreadCount: 5
    // }
  ]);
  const createCombinedMessages = (demoMessages, realMessages) => vue.computed(() => [...demoMessages.value, ...realMessages.value]);
  const createTotalMessageCount = (combinedMessages) => vue.computed(() => {
    const totalUnread = combinedMessages.value.reduce((sum, message) => sum + (message.unreadCount || 0), 0);
    return combinedMessages.value.length + totalUnread;
  });
  const createSystemMessage = () => vue.computed(() => ({
    title: "推送消息",
    preview: "系统版本更新",
    date: getCurrentDate(),
    notificationCount: Math.floor(Math.random() * 20) + 1
    // 随机生成1-20的未读数
  }));
  const getAvatarSrc = (avatar, defaultAvatarPath) => {
    return Array.isArray(avatar) ? avatar[0] : avatar || defaultAvatarPath;
  };
  const _sfc_main$D = {
    name: "MessageItem",
    components: {
      GroupAvatar
    },
    // 定义组件的属性
    props: {
      message: {
        type: Object,
        required: true
      }
    },
    setup() {
      return {
        getAvatarSrc,
        formatDate
      };
    }
  };
  function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_group_avatar = vue.resolveComponent("group-avatar");
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["message-item", { "personal-chat": !$props.message.group, "group-chat": $props.message.group }]),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $props.message))
      },
      [
        vue.createElementVNode("view", { class: "avatar-container" }, [
          vue.createCommentVNode(" 根据消息类型显示群组头像或个人头像 "),
          $props.message.group ? (vue.openBlock(), vue.createBlock(_component_group_avatar, {
            key: 0,
            avatar: [$props.message.avatarUrl],
            class: "avatar"
          }, null, 8, ["avatar"])) : (vue.openBlock(), vue.createElementBlock("image", {
            key: 1,
            src: $setup.getAvatarSrc($props.message.avatarUrl),
            class: "avatar",
            mode: "aspectFill"
          }, null, 8, ["src"])),
          vue.createCommentVNode(" 显示未读消息数量 "),
          $props.message.unreadCount > 0 ? (vue.openBlock(), vue.createElementBlock(
            "view",
            {
              key: 2,
              class: "avatar-badge"
            },
            vue.toDisplayString($props.message.unreadCount),
            1
            /* TEXT */
          )) : vue.createCommentVNode("v-if", true)
        ]),
        vue.createElementVNode("view", { class: "message-content-wrapper" }, [
          vue.createElementVNode("view", { class: "message-content" }, [
            vue.createElementVNode(
              "view",
              { class: "message-title" },
              vue.toDisplayString($props.message.group ? $props.message.groupName : $props.message.userName || $props.message.name),
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "view",
              { class: "message-preview" },
              vue.toDisplayString($props.message.latestMessage || $props.message.preview),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode(
            "view",
            { class: "message-date" },
            vue.toDisplayString($setup.formatDate($props.message.sendTime || $props.message.date)),
            1
            /* TEXT */
          )
        ])
      ],
      2
      /* CLASS */
    );
  }
  const MessageItem = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$C], ["__scopeId", "data-v-d65c0997"], ["__file", "E:/代码/new/zk_uniapp/pages/message/MainComponents/MessageItem.vue"]]);
  const useMainInterfaceStore = defineStore("mainInterface", () => {
    const cachedMessages = vue.ref([]);
    const lastUpdateTime = vue.ref(null);
    const isInitialized = vue.ref(false);
    function setCachedMessages(messages2) {
      cachedMessages.value = messages2;
      lastUpdateTime.value = Date.now();
      isInitialized.value = true;
    }
    function getCachedMessages() {
      return cachedMessages.value;
    }
    function updateCachedMessages(newMessages) {
      newMessages.forEach((newMsg) => {
        const index = cachedMessages.value.findIndex((msg) => msg.id === newMsg.id);
        if (index !== -1) {
          cachedMessages.value[index] = { ...cachedMessages.value[index], ...newMsg };
        } else {
          cachedMessages.value.push(newMsg);
        }
      });
      lastUpdateTime.value = Date.now();
    }
    function clearCache() {
      cachedMessages.value = [];
      lastUpdateTime.value = null;
      isInitialized.value = false;
    }
    return {
      cachedMessages,
      lastUpdateTime,
      isInitialized,
      setCachedMessages,
      getCachedMessages,
      updateCachedMessages,
      clearCache
    };
  });
  const calculateScrollViewHeight = () => {
    const systemInfo = uni.getSystemInfoSync();
    const headerHeight = 44;
    const tabBarHeight = 50;
    return systemInfo.windowHeight - headerHeight - tabBarHeight;
  };
  const getChatList = (missionId) => {
    if (!missionId) {
      formatAppLog("log", "at utils/api/message.js:10", "getChatList 需要 missionId 参数");
      return Promise.reject(new Error("getChatList 需要 missionId 参数"));
    }
    return request({
      url: `/message/chatList`,
      method: "get",
      data: { missionId }
    });
  };
  const sendMessageToUser = (data) => {
    formatAppLog("log", "at utils/api/message.js:23", "发送消息", data);
    return request({
      url: "/message/send/user",
      method: "post",
      data: {
        isPosition: data.isPosition !== void 0 ? data.isPosition : false,
        isSelfDestruct: data.isSelfDestruct !== void 0 ? data.isSelfDestruct : false,
        message: data.message,
        recipientId: data.recipientId,
        relatedMissionId: data.missionId[0]
      }
    });
  };
  const sendFilesToUser = (data) => {
    return new Promise((resolve, reject) => {
      if (!data.files || data.files.length === 0) {
        reject(new Error("没有要上传的文件"));
        return;
      }
      const file = data.files[0];
      const uploadTask = uni.uploadFile({
        url: backendHost + "/message/send/files",
        // 更新为正确的后端上传接口地址
        filePath: file.path || file,
        name: "files",
        header: {
          Authorization: "Bearer " + uni.getStorageSync("token")
        },
        formData: {
          isGroup: data.isGroup,
          isSelfDestruct: data.isSelfDestruct,
          latitude: data.latitude,
          longitude: data.longitude,
          missionId: data.missionId,
          receptionId: data.receptionId,
          voiceMessage: data.voiceMessage !== void 0 ? data.voiceMessage : false
        },
        success: (uploadFileRes) => {
          formatAppLog("log", "at utils/api/message.js:64", "服务器原始响应:", uploadFileRes);
          if (uploadFileRes.statusCode === 404) {
            reject(new Error("服务器端点未找到 (404)"));
            return;
          }
          if (uploadFileRes.statusCode !== 200) {
            reject(new Error(`服务器返回错误状态码: ${uploadFileRes.statusCode}`));
            return;
          }
          try {
            let response;
            if (typeof uploadFileRes.data === "string" && uploadFileRes.data.trim() !== "") {
              response = JSON.parse(uploadFileRes.data);
            } else if (typeof uploadFileRes.data === "object") {
              response = uploadFileRes.data;
            } else {
              throw new Error("服务器返回了空响应或无效的JSON");
            }
            formatAppLog("log", "at utils/api/message.js:82", "解析后的响应:", response);
            resolve(response);
          } catch (error) {
            formatAppLog("log", "at utils/api/message.js:85", "解析服务器响应失败:", error);
            reject(new Error("解析服务器响应失败"));
          }
        },
        fail: (error) => {
          formatAppLog("log", "at utils/api/message.js:90", "上传失败:", error);
          reject(error);
        }
      });
      uploadTask.onProgressUpdate((res) => {
        formatAppLog("log", "at utils/api/message.js:96", "上传进度", res.progress);
        formatAppLog("log", "at utils/api/message.js:97", "已经上传的数据长度", res.totalBytesSent);
        formatAppLog("log", "at utils/api/message.js:98", "预期需要上传的数据总长度", res.totalBytesExpectedToSend);
      });
    });
  };
  const getHistoryChatMessages = (data) => {
    return request({
      url: "/message/read/single",
      method: "post",
      data: {
        from: data.from,
        to: data.to,
        opponentId: data.opponentId,
        relatedMissionId: data.missionId[0]
      }
    });
  };
  const readSelfDestructMessage = (data) => {
    return request({
      url: "/message/read/selfDestruct/message",
      method: "post",
      data: {
        isGroup: data.isGroup,
        messageId: data.messageId,
        messageType: data.messageType
      }
    });
  };
  const getMissionAddressBook = (missionid) => {
    useUserStore();
    return request({
      // url: `/mission/address/book?missionId=${userStore.missionId}`,
      url: `/mission/address/book?missionId=` + missionid,
      method: "get"
    });
  };
  const sendGroupMessage = (data) => {
    return request({
      url: "/message/send/group",
      method: "post",
      data: {
        isGroupAnnouncement: data.isGroupAnnouncement !== void 0 ? data.isGroupAnnouncement : false,
        isPosition: data.isPosition !== void 0 ? data.isPosition : false,
        isSelfDestruct: data.isSelfDestruct !== void 0 ? data.isSelfDestruct : false,
        message: data.message,
        recipientId: data.recipientId,
        relatedMissionId: data.missionId
      }
    });
  };
  const getGroupChatMessages = (data) => {
    return request({
      url: "/message/read/group",
      method: "post",
      data: {
        from: data.from,
        opponentId: data.opponentId,
        to: data.to,
        relatedMissionId: data.missionId
      }
    });
  };
  const getGroupBasicInfo = (groupId) => {
    if (!groupId) {
      formatAppLog("log", "at utils/api/message.js:177", "getGroupBasicInfo 需要 groupId 参数");
      return Promise.reject(new Error("getGroupBasicInfo 需要 groupId 参数"));
    }
    return request({
      url: `/group/get/basicInf?groupId=${groupId}`,
      method: "get"
    });
  };
  const getUserBasicInfo = (userId) => {
    if (!userId) {
      formatAppLog("log", "at utils/api/message.js:188", "getUserBasicInfo 需要 userId 参数");
      return Promise.reject(new Error("getUserBasicInfo 需要 userId 参数"));
    }
    return request({
      url: `/user/search/basicInf?id=${userId}`,
      method: "get"
    });
  };
  const fetchChatList = async (missionId) => {
    formatAppLog("log", "at pages/message/MainComposables/chatApi.js:6", "正在获取聊天列表，使用的 missionId:", missionId);
    if (!missionId) {
      formatAppLog("log", "at pages/message/MainComposables/chatApi.js:8", "fetchChatList 中 missionId 未设置");
      return null;
    }
    try {
      const response = await getChatList(missionId);
      if (response.code === 200) {
        const messages2 = response.data.map((item) => ({
          ...item,
          avatar: item.avatar || "/static/message/默认头像.png",
          preview: item.latestMessage,
          date: item.sendTime
        }));
        formatAppLog("log", "at pages/message/MainComposables/chatApi.js:20", "获取到的聊天列表:", messages2);
        return messages2;
      } else {
        formatAppLog("log", "at pages/message/MainComposables/chatApi.js:23", "获取聊天列表失败:", response.msg);
        return null;
      }
    } catch (error) {
      formatAppLog("log", "at pages/message/MainComposables/chatApi.js:27", "获取聊天列表时发生错误:", error);
      return null;
    }
  };
  function useMessageList() {
    const userStore = useUserStore();
    const mainInterfaceStore = useMainInterfaceStore();
    const missionId = vue.ref("");
    const realMessages = vue.ref([]);
    const scrollViewHeight = vue.ref(0);
    const isLoading = vue.ref(false);
    const demoMessages = createDemoMessages();
    const combinedMessages = createCombinedMessages(demoMessages, realMessages);
    const totalMessageCount = createTotalMessageCount(combinedMessages);
    const systemMessage = createSystemMessage();
    const openChat = (message) => {
      const chatInfo = {
        id: message.group ? message.groupId : message.id || message.userId,
        name: message.group ? message.groupName : message.name || message.userName,
        avatar: message.avatarUrl || "/static/message/默认头像.png",
        type: message.group ? "group" : "single",
        missionId: missionId.value
      };
      uni.setStorageSync("chatQuery", JSON.stringify(chatInfo));
      uni.navigateTo({
        url: "/pages/message/chat",
        success: (res) => {
          if (res.eventChannel && res.eventChannel.emit) {
            res.eventChannel.emit("chatInfo", { chatInfo });
            formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:44", "通过 eventChannel 发送 chatInfo");
          } else {
            formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:46", "eventChannel 不可用，将使用本地存储的数据");
          }
        },
        fail: (err) => {
          formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:50", "导航到聊天页面失败:", JSON.stringify(err));
        }
      });
    };
    const loadMessages = async () => {
      missionId.value = userStore.state.missionId;
      scrollViewHeight.value = calculateScrollViewHeight();
      if (mainInterfaceStore.isInitialized) {
        realMessages.value = mainInterfaceStore.getCachedMessages();
      }
      await fetchAndUpdateMessages();
    };
    const fetchAndUpdateMessages = async () => {
      try {
        const newMessages = await fetchChatList(missionId.value);
        if (newMessages) {
          const hasChanges = compareMessages(newMessages, realMessages.value);
          if (hasChanges) {
            mainInterfaceStore.setCachedMessages(newMessages);
            realMessages.value = newMessages;
          } else {
            formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:81", "消息列表无变化");
          }
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:85", "获取聊天列表失败:", JSON.stringify(error));
      }
    };
    const compareMessages = (newMessages, oldMessages) => {
      if (newMessages.length !== oldMessages.length)
        return true;
      for (let i2 = 0; i2 < newMessages.length; i2++) {
        if (JSON.stringify(newMessages[i2]) !== JSON.stringify(oldMessages[i2])) {
          return true;
        }
      }
      return false;
    };
    vue.onMounted(loadMessages);
    vue.onActivated(() => {
      formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:103", "消息组件被激活");
      loadMessages();
    });
    return {
      combinedMessages,
      totalMessageCount,
      systemMessage,
      scrollViewHeight,
      isLoading,
      openChat,
      fetchAndUpdateMessages
    };
  }
  const _sfc_main$C = vue.defineComponent({
    name: "Messages",
    components: {
      SystemMessage,
      MessageItem
    },
    setup() {
      const {
        combinedMessages,
        totalMessageCount,
        systemMessage,
        scrollViewHeight,
        openChat,
        fetchAndUpdateMessages
      } = useMessageList();
      const refreshPage = () => {
        formatAppLog("log", "at pages/message/main.vue:52", "刷新main.vue页面");
        fetchAndUpdateMessages();
      };
      vue.onMounted(() => {
        uni.$on("refreshMainPage", refreshPage);
      });
      vue.onUnmounted(() => {
        uni.$off("refreshMainPage", refreshPage);
      });
      return {
        combinedMessages,
        totalMessageCount,
        systemMessage,
        scrollViewHeight,
        openChat,
        refreshPage
      };
    }
  });
  function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    const _component_SystemMessage = vue.resolveComponent("SystemMessage");
    const _component_MessageItem = vue.resolveComponent("MessageItem");
    return vue.openBlock(), vue.createElementBlock("view", { class: "messages-container" }, [
      vue.createElementVNode("view", null, [
        vue.createVNode(_component_uni_nav_bar, {
          fixed: true,
          "status-bar": "",
          rightIcon: "search",
          onClickRight: _cache[0] || (_cache[0] = () => {
          }),
          title: "消息"
        })
      ]),
      vue.createElementVNode("view", { class: "messages-view" }, [
        vue.createElementVNode("view", { class: "messages-header" }, [
          vue.createElementVNode(
            "text",
            { class: "header-title" },
            "消息(" + vue.toDisplayString(_ctx.totalMessageCount) + ")",
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode(
          "scroll-view",
          {
            class: "messages-list",
            "scroll-y": "",
            "enable-flex": "",
            style: vue.normalizeStyle({ height: _ctx.scrollViewHeight + "px" })
          },
          [
            vue.createCommentVNode(" 系统消息 "),
            vue.createVNode(_component_SystemMessage, { message: _ctx.systemMessage }, null, 8, ["message"]),
            vue.createCommentVNode(" 消息列表 "),
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(_ctx.combinedMessages, (message, index) => {
                return vue.openBlock(), vue.createBlock(_component_MessageItem, {
                  key: message.id || index,
                  message,
                  onClick: ($event) => _ctx.openChat(message)
                }, null, 8, ["message", "onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          4
          /* STYLE */
        )
      ])
    ]);
  }
  const PagesMessageMain = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$B], ["__file", "E:/代码/new/zk_uniapp/pages/message/main.vue"]]);
  const _imports_0$7 = "/static/message/返回.png";
  const _sfc_main$B = {
    name: "ChatHeader",
    components: {},
    props: {
      chatInfo: {
        type: Object,
        required: true
      }
    }
  };
  function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "chat-header" }, [
      vue.createElementVNode("div", {
        class: "uni-page-head-hd",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("goBack"))
      }, [
        vue.createElementVNode("div", { class: "uni-page-head-btn" }, [
          vue.createElementVNode("image", {
            src: _imports_0$7,
            class: "back-icon",
            mode: "aspectFit"
          })
        ])
      ]),
      vue.createElementVNode("view", { class: "chat-title-container" }, [
        vue.createElementVNode(
          "text",
          { class: "chat-title" },
          vue.toDisplayString($props.chatInfo.name),
          1
          /* TEXT */
        )
      ]),
      vue.createElementVNode("text", { class: "menu-button" }, "...")
    ]);
  }
  const ChatHeader = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$A], ["__scopeId", "data-v-120ff10e"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatHeader.vue"]]);
  const gaodeApiKey = "fc598a079d7d9cf5f54ecec04b17e414";
  const gaodeSecurityKey = "93849873dba769e7b6235a79330ae7f7";
  const AMAP_KEY = gaodeApiKey;
  const AMAP_API_URL = "https://restapi.amap.com/v3/staticmap?";
  const _sfc_main$A = {
    name: "LocationMessage",
    props: {
      content: {
        type: Object,
        required: true
      }
    },
    methods: {
      openMap(location2) {
        if (!location2 || !location2.latitude || !location2.longitude) {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/LocationMessage.vue:32", "无效的位置数据:", location2);
          return;
        }
        uni.openLocation({
          latitude: parseFloat(location2.latitude),
          longitude: parseFloat(location2.longitude),
          name: location2.name,
          address: location2.address,
          success: function() {
            formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/LocationMessage.vue:41", "成功打开地图");
          },
          fail: function(error) {
            formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/LocationMessage.vue:44", "打开地图失败:", error);
          }
        });
      },
      getStaticMapUrl(location2) {
        return `${AMAP_API_URL}location=${location2.longitude},${location2.latitude}&zoom=14&size=480*240&scale=2&markers=mid,,A:${location2.longitude},${location2.latitude}&key=${AMAP_KEY}`;
      }
    }
  };
  function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "location-bubble",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.openMap($props.content))
    }, [
      vue.createElementVNode(
        "view",
        { class: "location-title" },
        vue.toDisplayString($props.content.name),
        1
        /* TEXT */
      ),
      vue.createElementVNode(
        "view",
        { class: "location-address" },
        vue.toDisplayString($props.content.address),
        1
        /* TEXT */
      ),
      vue.createElementVNode("view", { class: "location-map" }, [
        vue.createElementVNode("image", {
          class: "map-image",
          src: $options.getStaticMapUrl($props.content),
          mode: "aspectFill"
        }, null, 8, ["src"])
      ])
    ]);
  }
  const LocationMessage = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$z], ["__scopeId", "data-v-820a3722"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageComponent/LocationMessage.vue"]]);
  const _sfc_main$z = {
    name: "ImageMessage",
    props: {
      content: {
        type: String,
        required: true
      }
    },
    methods: {
      previewImage(url) {
        uni.previewImage({
          urls: [url],
          current: url
        });
      }
    }
  };
  function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("image", {
      src: $props.content,
      mode: "widthFix",
      class: "message-image",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.previewImage($props.content))
    }, null, 8, ["src"]);
  }
  const ImageMessage = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$y], ["__scopeId", "data-v-2115df62"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageComponent/ImageMessage.vue"]]);
  const _imports_0$6 = "/assets/text.bd3c6783.png";
  const _imports_1$1 = "/assets/docx.b7b68f84.png";
  const _imports_2 = "/assets/jpg.3e4bf7f6.png";
  const _imports_3 = "/assets/png.ea62ff77.png";
  const _imports_4 = "/assets/pptx.feb4199f.png";
  const _imports_5 = "/assets/xlsx.ceae1396.png";
  const _sfc_main$y = {
    name: "FileMessage",
    props: {
      content: {
        type: String,
        required: true
      },
      messageType: {
        type: String,
        required: true
      }
    }
  };
  function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "file-bubble" }, [
      vue.createElementVNode(
        "view",
        { class: "file-name" },
        vue.toDisplayString($props.content),
        1
        /* TEXT */
      ),
      $props.messageType.toUpperCase() === "TEXT" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 0,
        src: _imports_0$6,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "DOCX" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 1,
        src: _imports_1$1,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "JPG" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 2,
        src: _imports_2,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "PNG" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 3,
        src: _imports_3,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "PPTX" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 4,
        src: _imports_4,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "XLSX" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 5,
        src: _imports_5,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const FileMessage = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$x], ["__scopeId", "data-v-ba23d37a"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageComponent/FileMessage.vue"]]);
  const _sfc_main$x = {
    __name: "VoiceMessageBubble",
    props: {
      content: {
        type: Object,
        required: true,
        default: () => ({
          url: "",
          duration: 0,
          isSelf: false
        })
      }
    },
    setup(__props, { expose: __expose }) {
      __expose();
      const props = __props;
      const isPlaying = vue.ref(false);
      const audioDuration = vue.ref(0);
      let audioContext = null;
      const formatDuration = (duration) => {
        return Math.round(duration || 0);
      };
      const beforeAudioRecordOrPlay2 = (type) => {
        const globalData = getApp().globalData;
        const audioPlaying = globalData.audioPlaying;
        const audioRecording = globalData.audioRecording;
        if (audioPlaying || audioRecording) {
          uni.showToast({
            title: audioPlaying ? "请先暂停其他音频播放" : "请先结束其他录音",
            icon: "none"
          });
          return false;
        } else {
          if (type === "play") {
            globalData.audioPlaying = true;
          } else if (type === "record") {
            globalData.audioRecording = true;
          } else {
            formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:64", `无效的类型: ${type}`);
            return false;
          }
          return true;
        }
      };
      const afterAudioPlay = () => {
        getApp().globalData.audioPlaying = false;
      };
      const checkAudioFileExists = (url) => {
        return new Promise((resolve, reject) => {
          uni.downloadFile({
            url,
            success: (res) => {
              if (res.statusCode === 200) {
                resolve(true);
              } else {
                reject(new Error(`音频文件下载失败，状态码：${res.statusCode}`));
              }
            },
            fail: (err) => {
              reject(new Error(`音频文件检查失败：${err.errMsg}`));
            }
          });
        });
      };
      const createAudioContext = async () => {
        if (audioContext) {
          audioContext.destroy();
        }
        if (!props.content.url) {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:101", "音频 URL 未定义");
          uni.showToast({
            title: "音频文件不存在",
            icon: "none"
          });
          return null;
        }
        try {
          await checkAudioFileExists(props.content.url);
        } catch (error) {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:112", "音频文件检查失败:", error);
          uni.showToast({
            title: "音频文件不可用",
            icon: "none"
          });
          return null;
        }
        audioContext = uni.createInnerAudioContext();
        audioContext.src = props.content.url;
        audioContext.onCanplay(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:124", "音频可以播放");
          audioDuration.value = audioContext.duration || props.content.duration || 0;
        });
        audioContext.onPlay(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:129", "音频开始播放");
          isPlaying.value = true;
        });
        audioContext.onEnded(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:134", "音频播放结束");
          isPlaying.value = false;
          afterAudioPlay();
        });
        audioContext.onError((res) => {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:140", "音频播放错误:", res.errMsg, res.errCode);
          uni.showToast({
            title: "播放失败: " + res.errMsg,
            icon: "none"
          });
          isPlaying.value = false;
          afterAudioPlay();
        });
        audioContext.onWaiting(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:150", "音频加载中...");
        });
        return audioContext;
      };
      const bubbleStyle = vue.computed(() => {
        const minWidth = 120;
        const maxWidth = 300;
        const widthPerSecond = 10;
        const duration = audioDuration.value || 0;
        let width = minWidth + duration * widthPerSecond;
        width = Math.min(width, maxWidth);
        return {
          width: `${width}rpx`
        };
      });
      const togglePlay = async () => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:173", "togglePlay 被调用");
        if (!audioContext) {
          audioContext = await createAudioContext();
        }
        if (!audioContext) {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:178", "无法创建音频上下文");
          return;
        }
        if (isPlaying.value) {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:183", "停止播放");
          audioContext.stop();
          isPlaying.value = false;
          afterAudioPlay();
        } else {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:188", "开始播放");
          if (beforeAudioRecordOrPlay2("play")) {
            try {
              await audioContext.play();
            } catch (error) {
              formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:193", "播放音频失败:", error);
              uni.showToast({
                title: "播放失败，请重试",
                icon: "none"
              });
              isPlaying.value = false;
              afterAudioPlay();
            }
          }
        }
      };
      vue.onMounted(async () => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:206", "VoiceMessageBubble 组件已挂载");
        audioContext = await createAudioContext();
      });
      vue.onUnmounted(() => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:211", "VoiceMessageBubble 组件即将卸载");
        if (audioContext) {
          audioContext.destroy();
        }
      });
      vue.watch(() => props.content, async (newContent) => {
        if (newContent.url !== (audioContext == null ? void 0 : audioContext.src)) {
          audioContext = await createAudioContext();
        }
        audioDuration.value = newContent.duration || 0;
      }, { deep: true });
      const __returned__ = { props, isPlaying, audioDuration, get audioContext() {
        return audioContext;
      }, set audioContext(v2) {
        audioContext = v2;
      }, formatDuration, beforeAudioRecordOrPlay: beforeAudioRecordOrPlay2, afterAudioPlay, checkAudioFileExists, createAudioContext, bubbleStyle, togglePlay, ref: vue.ref, onMounted: vue.onMounted, onUnmounted: vue.onUnmounted, watch: vue.watch, computed: vue.computed };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["voice-message-bubble", [
          $props.content.isSelf ? "self" : "friend",
          $setup.isPlaying ? "playing" : ""
        ]]),
        style: vue.normalizeStyle($setup.bubbleStyle),
        onClick: $setup.togglePlay
      },
      [
        vue.createElementVNode("view", { class: "audio-icon" }, [
          vue.createElementVNode("view", { class: "speaker-waves" }, [
            (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(3, (i2) => {
                return vue.createElementVNode("view", {
                  class: "wave",
                  key: i2
                });
              }),
              64
              /* STABLE_FRAGMENT */
            ))
          ])
        ]),
        vue.createElementVNode(
          "text",
          { class: "duration" },
          vue.toDisplayString($setup.formatDuration($setup.audioDuration)) + '"',
          1
          /* TEXT */
        )
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const VoiceMessageBubble = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$w], ["__scopeId", "data-v-021f7c82"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue"]]);
  const _sfc_main$w = {
    name: "BurnAfterReadingMessage",
    props: {
      content: {
        type: Object,
        required: true
      }
    },
    methods: {
      viewBurnAfterReading(message) {
        this.$emit("view-burn-after-reading", message);
      }
    }
  };
  function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "burn-after-reading",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.viewBurnAfterReading($props.content))
    }, [
      vue.createElementVNode("image", {
        src: $props.content.mosaicPath,
        mode: "widthFix",
        class: "message-image"
      }, null, 8, ["src"]),
      vue.createElementVNode("text", { class: "burn-after-reading-text" }, "阅后即焚")
    ]);
  }
  const BurnAfterReadingMessage = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$v], ["__scopeId", "data-v-6349b1a8"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageComponent/BurnAfterReadingMessage.vue"]]);
  const _sfc_main$v = {
    name: "AudioMessage",
    props: {
      content: {
        type: String,
        required: true
      },
      messageType: {
        type: String,
        required: true
      }
    },
    data() {
      return {
        isPlaying: false,
        duration: 0,
        currentTime: 0,
        audioContext: null,
        updateInterval: null,
        isMuted: false,
        previousVolume: 1
      };
    },
    computed: {
      isAudioFile() {
        return this.messageType === "AUDIO";
      },
      progress() {
        return this.duration > 0 ? this.currentTime / this.duration * 100 : 0;
      }
    },
    mounted() {
      if (this.isAudioFile) {
        this.initAudioContext();
      }
    },
    methods: {
      formatDuration(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
      },
      togglePlay() {
        if (this.isPlaying) {
          this.audioContext.pause();
          clearInterval(this.updateInterval);
        } else {
          this.audioContext.play();
          this.updateInterval = setInterval(this.updateProgress, 1e3);
        }
        this.isPlaying = !this.isPlaying;
      },
      initAudioContext() {
        this.audioContext = uni.createInnerAudioContext();
        this.audioContext.src = this.content;
        this.audioContext.playbackRate = 1;
        this.audioContext.onCanplay(() => {
          this.getDuration();
        });
        this.audioContext.onEnded(() => {
          this.isPlaying = false;
          this.currentTime = 0;
          clearInterval(this.updateInterval);
        });
        this.audioContext.onError((res) => {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/AudioMessage.vue:112", "音频错误:", res.errMsg);
          uni.showToast({
            title: "音频播放错误",
            icon: "none"
          });
        });
      },
      getDuration() {
        const checkDuration = () => {
          if (this.audioContext.duration > 0) {
            this.duration = this.audioContext.duration;
          } else {
            setTimeout(checkDuration, 100);
          }
        };
        checkDuration();
      },
      updateProgress() {
        if (this.audioContext) {
          this.currentTime = this.audioContext.currentTime;
        }
      },
      seekAudio(event) {
        if (!this.audioContext)
          return;
        const rect = event.target.getBoundingClientRect();
        const clickPosition = event.clientX - rect.left;
        const percentage = clickPosition / rect.width * 100;
        const newTime = percentage / 100 * this.duration;
        this.audioContext.seek(newTime);
        this.currentTime = newTime;
      },
      toggleMute() {
        if (!this.audioContext)
          return;
        if (this.isMuted) {
          this.audioContext.volume = this.previousVolume;
        } else {
          this.previousVolume = this.audioContext.volume;
          this.audioContext.volume = 0;
        }
        this.isMuted = !this.isMuted;
      }
    },
    beforeDestroy() {
      if (this.audioContext) {
        this.audioContext.destroy();
      }
      clearInterval(this.updateInterval);
    }
  };
  function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "audio-message" }, [
      $options.isAudioFile ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "audio-player"
      }, [
        vue.createElementVNode("view", { class: "player-container" }, [
          vue.createElementVNode("view", {
            class: "play-pause-button",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.togglePlay && $options.togglePlay(...args))
          }, [
            !$data.isPlaying ? (vue.openBlock(), vue.createElementBlock("svg", {
              key: 0,
              class: "play-icon",
              viewBox: "0 0 24 24",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg"
            }, [
              vue.createElementVNode("path", {
                d: "M8 5.14v14.72L19 12 8 5.14z",
                fill: "currentColor"
              })
            ])) : (vue.openBlock(), vue.createElementBlock("svg", {
              key: 1,
              class: "pause-icon",
              viewBox: "0 0 24 24",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg"
            }, [
              vue.createElementVNode("path", {
                d: "M8 5h3v14H8V5zm5 0h3v14h-3V5z",
                fill: "currentColor"
              })
            ]))
          ]),
          vue.createElementVNode("view", { class: "time-progress" }, [
            vue.createElementVNode("view", { class: "time-display" }, [
              vue.createElementVNode(
                "text",
                null,
                vue.toDisplayString($options.formatDuration($data.currentTime)),
                1
                /* TEXT */
              ),
              vue.createElementVNode("text", { class: "duration-separator" }, "/"),
              vue.createElementVNode(
                "text",
                null,
                vue.toDisplayString($options.formatDuration($data.duration)),
                1
                /* TEXT */
              )
            ]),
            vue.createElementVNode("view", {
              class: "progress-bar",
              onClick: _cache[1] || (_cache[1] = (...args) => $options.seekAudio && $options.seekAudio(...args))
            }, [
              vue.createElementVNode(
                "view",
                {
                  class: "progress",
                  style: vue.normalizeStyle({ width: `${$options.progress}%` })
                },
                null,
                4
                /* STYLE */
              )
            ])
          ]),
          vue.createElementVNode("view", { class: "controls" }, [
            vue.createElementVNode("view", {
              class: "volume-control",
              onClick: _cache[2] || (_cache[2] = (...args) => $options.toggleMute && $options.toggleMute(...args))
            }, [
              !$data.isMuted ? (vue.openBlock(), vue.createElementBlock("svg", {
                key: 0,
                class: "volume-icon",
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
              }, [
                vue.createElementVNode("path", {
                  d: "M16 9.5c.83.27 1.5 1.34 1.5 2.5s-.67 2.23-1.5 2.5",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-linecap": "round"
                }),
                vue.createElementVNode("path", {
                  d: "M3 11v2h2l3.5 3.5V7.5L5 11H3z",
                  fill: "currentColor"
                })
              ])) : (vue.openBlock(), vue.createElementBlock("svg", {
                key: 1,
                class: "volume-icon",
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
              }, [
                vue.createElementVNode("path", {
                  d: "M3 11v2h2l3.5 3.5V7.5L5 11H3z",
                  fill: "currentColor"
                }),
                vue.createElementVNode("path", {
                  d: "M14 9l-2 2m0 0l-2 2m2-2l2 2m-2-2l-2-2",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-linecap": "round"
                })
              ]))
            ])
          ])
        ])
      ])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const AudioMessage = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$u], ["__scopeId", "data-v-3578ca20"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageComponent/AudioMessage.vue"]]);
  const _imports_0$5 = "/static/message/信封.png";
  const _sfc_main$u = {
    name: "BurnAfterReadingTextMessage",
    props: {
      // 消息ID
      messageId: {
        type: String,
        required: true
      },
      // 是否为群组消息
      isGroup: {
        type: Boolean,
        default: false
      }
    },
    emits: ["message-deleted"],
    setup(props, { emit }) {
      const revealed = vue.ref(false);
      const revealedContent = vue.ref("");
      const countdown = vue.ref(10);
      let countdownTimer = null;
      const viewBurnAfterReading = async () => {
        if (revealed.value)
          return;
        try {
          const response = await readSelfDestructMessage({
            isGroup: props.isGroup,
            messageId: props.messageId,
            messageType: "MESSAGE"
          });
          if (response.code === 200) {
            revealed.value = true;
            revealedContent.value = response.data.content || response.data;
            startCountdown();
          }
        } catch (error) {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue:60", "读取阅后即焚消息失败:", error);
        }
      };
      const startCountdown = () => {
        countdownTimer = setInterval(() => {
          countdown.value--;
          if (countdown.value === 0) {
            clearInterval(countdownTimer);
            revealed.value = false;
            revealedContent.value = "";
            emit("message-deleted", props.messageId);
            formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue:73", "阅后即焚消息倒计时结束，已触发删除事件");
          }
        }, 1e3);
      };
      vue.onUnmounted(() => {
        if (countdownTimer) {
          clearInterval(countdownTimer);
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue:82", "组件卸载，清除定时器");
        }
        if (revealed.value && countdown.value > 0) {
          emit("message-deleted", props.messageId);
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue:86", "组件卸载时消息仍在显示，触发删除事件");
        }
      });
      return {
        revealed,
        revealedContent,
        countdown,
        viewBurnAfterReading
      };
    }
  };
  function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "burn-after-reading-text",
      onClick: _cache[0] || (_cache[0] = (...args) => $setup.viewBurnAfterReading && $setup.viewBurnAfterReading(...args))
    }, [
      !$setup.revealed ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "burn-button"
      }, [
        vue.createElementVNode("image", {
          src: _imports_0$5,
          class: "envelope-icon",
          mode: "aspectFit"
        }),
        vue.createElementVNode("text", { class: "burn-text" }, "阅后即焚")
      ])) : (vue.openBlock(), vue.createElementBlock("view", {
        key: 1,
        class: "revealed-message"
      }, [
        vue.createElementVNode(
          "text",
          { class: "revealed-content" },
          vue.toDisplayString($setup.revealedContent),
          1
          /* TEXT */
        ),
        vue.createElementVNode(
          "view",
          { class: "countdown" },
          vue.toDisplayString($setup.countdown) + "s",
          1
          /* TEXT */
        )
      ]))
    ]);
  }
  const BurnAfterReadingTextMessage = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$t], ["__scopeId", "data-v-9ce853fb"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue"]]);
  const _imports_0$4 = "/static/message/默认头像.png";
  const _sfc_main$t = {
    name: "Message",
    components: {
      LocationMessage,
      ImageMessage,
      FileMessage,
      VoiceMessageBubble,
      BurnAfterReadingMessage,
      AudioMessage,
      BurnAfterReadingTextMessage
    },
    props: {
      // 消息对象
      message: {
        type: Object,
        required: true
      },
      // 是否为群聊
      isGroup: {
        type: Boolean,
        default: false
      }
    },
    emits: ["view-burn-after-reading", "message-deleted"],
    setup(props, { emit }) {
      const userStore = useUserStore();
      const formatTime2 = (timestamp) => {
        if (!timestamp)
          return "无效日期";
        const date = new Date(timestamp);
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours().toString().padStart(2, "0");
        const minutes = date.getMinutes().toString().padStart(2, "0");
        return `${month}-${day} ${hours}:${minutes}`;
      };
      const viewBurnAfterReading = (message) => {
        emit("view-burn-after-reading", message);
      };
      const handleMessageDeleted = (messageId) => {
        emit("message-deleted", messageId);
      };
      const readStatusData = vue.computed(() => {
        if (!props.isGroup || !props.message.groupMessageUserReadVO) {
          return { readCount: 0, groupMessageUserReadVO: [] };
        }
        const groupMessageUserReadVO = props.message.groupMessageUserReadVO;
        const readCount = groupMessageUserReadVO.filter((user) => user.isRead).length;
        return { readCount, groupMessageUserReadVO };
      });
      const getReadCount = vue.computed(() => readStatusData.value.readCount);
      const handleReadCountClick = () => {
        formatAppLog("log", "at pages/message/ChatComponent/Message.vue:150", "处理已读人数点击事件");
        const messageData = {
          // 群消息用户阅读状态
          groupMessageUserReadVO: readStatusData.value.groupMessageUserReadVO,
          // 发送者名称
          senderName: props.message.senderName,
          // 消息内容
          content: props.message.content,
          // 消息发送时间戳
          timestamp: props.message.timestamp,
          // 消息类型（如text, image, file等）
          type: props.message.type,
          // 消息类型（如MESSAGE, SYSTEM等）
          messageType: props.message.messageType,
          // 是否为阅后即焚消息
          selfDestruct: props.message.selfDestruct,
          // 消息ID
          id: props.message.id
        };
        formatAppLog("log", "at pages/message/ChatComponent/Message.vue:172", "准备写入缓存的消息数据:", messageData);
        try {
          uni.setStorageSync("messageReadStatusData", JSON.stringify(messageData));
          formatAppLog("log", "at pages/message/ChatComponent/Message.vue:177", "消息数据已成功写入缓存");
        } catch (error) {
          formatAppLog("error", "at pages/message/ChatComponent/Message.vue:179", "写入缓存失败:", error);
          uni.showToast({
            title: "保存消息数据失败",
            icon: "none"
          });
          return;
        }
        uni.navigateTo({
          url: "/pages/message/ChatComponent/MessageReadStatus",
          success: (res) => {
            formatAppLog("log", "at pages/message/ChatComponent/Message.vue:191", "成功跳转到消息已读状态页面");
          },
          fail: (err) => {
            formatAppLog("error", "at pages/message/ChatComponent/Message.vue:194", "跳转到消息已读状态页面失败:", err);
            uni.showToast({
              title: "页面跳转失败",
              icon: "none"
            });
          }
        });
      };
      return {
        formatTime: formatTime2,
        viewBurnAfterReading,
        handleMessageDeleted,
        userStore,
        getReadCount,
        handleReadCountClick
      };
    }
  };
  function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_LocationMessage = vue.resolveComponent("LocationMessage");
    const _component_ImageMessage = vue.resolveComponent("ImageMessage");
    const _component_FileMessage = vue.resolveComponent("FileMessage");
    const _component_VoiceMessageBubble = vue.resolveComponent("VoiceMessageBubble");
    const _component_AudioMessage = vue.resolveComponent("AudioMessage");
    const _component_BurnAfterReadingMessage = vue.resolveComponent("BurnAfterReadingMessage");
    const _component_BurnAfterReadingTextMessage = vue.resolveComponent("BurnAfterReadingTextMessage");
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["message", [$props.message.userType]])
      },
      [
        vue.createElementVNode(
          "view",
          { class: "message-time" },
          vue.toDisplayString($setup.formatTime($props.message.timestamp)),
          1
          /* TEXT */
        ),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["message-content", { "self-message": $props.message.userType === "self" }])
          },
          [
            vue.createElementVNode("view", { class: "avatar-container" }, [
              vue.createElementVNode("image", {
                src: _imports_0$4,
                class: "avatar",
                mode: "aspectFill"
              }),
              $props.isGroup && $props.message.userType === "other" ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 0,
                class: "sender-name"
              })) : vue.createCommentVNode("v-if", true)
            ]),
            vue.createElementVNode("view", { class: "content-wrapper" }, [
              $props.message.userType === "friend" ? (vue.openBlock(), vue.createElementBlock(
                "view",
                {
                  key: 0,
                  class: "friend-name"
                },
                vue.toDisplayString($props.message.name),
                1
                /* TEXT */
              )) : vue.createCommentVNode("v-if", true),
              vue.createElementVNode("view", { class: "content-container" }, [
                vue.createElementVNode(
                  "view",
                  {
                    class: vue.normalizeClass(["content", {
                      "location-content": $props.message.type === "location",
                      "file-message": $props.message.type === "file",
                      "message-image": $props.message.type === "image",
                      "voice-message": $props.message.type === "voice_message",
                      "audio-message": $props.message.type === "audio",
                      "burn-after-reading": $props.message.selfDestruct && $props.message.messageType === "MESSAGE"
                    }])
                  },
                  [
                    vue.createCommentVNode(" 根据消息类型渲染不同的组件 "),
                    $props.message.type === "location" ? (vue.openBlock(), vue.createBlock(_component_LocationMessage, {
                      key: 0,
                      content: $props.message.content
                    }, null, 8, ["content"])) : $props.message.type === "image" ? (vue.openBlock(), vue.createBlock(_component_ImageMessage, {
                      key: 1,
                      content: $props.message.content
                    }, null, 8, ["content"])) : $props.message.type === "file" ? (vue.openBlock(), vue.createBlock(_component_FileMessage, {
                      key: 2,
                      content: $props.message.content,
                      messageType: $props.message.messageType
                    }, null, 8, ["content", "messageType"])) : $props.message.type === "voice_message" ? (vue.openBlock(), vue.createBlock(_component_VoiceMessageBubble, {
                      key: 3,
                      content: {
                        url: $props.message.content,
                        duration: $props.message.duration,
                        isSelf: $props.message.userType === "self"
                      }
                    }, null, 8, ["content"])) : $props.message.type === "audio" ? (vue.openBlock(), vue.createBlock(_component_AudioMessage, {
                      key: 4,
                      content: $props.message.content,
                      messageType: $props.message.messageType
                    }, null, 8, ["content", "messageType"])) : $props.message.type === "burn-after-reading" ? (vue.openBlock(), vue.createBlock(_component_BurnAfterReadingMessage, {
                      key: 5,
                      content: $props.message.content,
                      onViewBurnAfterReading: $setup.viewBurnAfterReading
                    }, null, 8, ["content", "onViewBurnAfterReading"])) : $props.message.selfDestruct && $props.message.messageType === "MESSAGE" ? (vue.openBlock(), vue.createBlock(_component_BurnAfterReadingTextMessage, {
                      key: 6,
                      messageId: $props.message.id,
                      isGroup: $props.isGroup,
                      onMessageDeleted: $setup.handleMessageDeleted
                    }, null, 8, ["messageId", "isGroup", "onMessageDeleted"])) : (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 7 },
                      [
                        vue.createTextVNode(
                          vue.toDisplayString($props.message.content || ""),
                          1
                          /* TEXT */
                        )
                      ],
                      64
                      /* STABLE_FRAGMENT */
                    ))
                  ],
                  2
                  /* CLASS */
                ),
                vue.createCommentVNode(" 已读人数指示器 "),
                $props.isGroup ? (vue.openBlock(), vue.createElementBlock(
                  "view",
                  {
                    key: 0,
                    class: vue.normalizeClass(["read-count", { "read-count-self": $props.message.userType === "self" }]),
                    onClick: _cache[0] || (_cache[0] = (...args) => $setup.handleReadCountClick && $setup.handleReadCountClick(...args))
                  },
                  vue.toDisplayString($setup.getReadCount),
                  3
                  /* TEXT, CLASS */
                )) : $props.message.userType === "self" ? (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 1 },
                  [
                    vue.createCommentVNode(" 私聊消息阅读状态 "),
                    vue.createElementVNode(
                      "view",
                      {
                        class: vue.normalizeClass(["read-status", { "read": $props.message.isRead, "unread": !$props.message.isRead }])
                      },
                      vue.toDisplayString($props.message.isRead ? "已读" : "未读"),
                      3
                      /* TEXT, CLASS */
                    )
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                )) : vue.createCommentVNode("v-if", true)
              ])
            ]),
            vue.createCommentVNode(" 消息状态（仅对自己发送的消息显示） "),
            $props.message.userType === "self" ? (vue.openBlock(), vue.createElementBlock("view", {
              key: 0,
              class: "message-status"
            }, [
              $props.message.status === "sending" ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 0,
                class: "loading-icon"
              })) : $props.message.status === "failed" ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 1,
                class: "failed-icon"
              }, "!")) : vue.createCommentVNode("v-if", true)
            ])) : vue.createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        )
      ],
      2
      /* CLASS */
    );
  }
  const Message = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$s], ["__scopeId", "data-v-1cea873d"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/Message.vue"]]);
  const _sfc_main$s = {
    name: "MessageList",
    components: {
      Message
    },
    props: {
      messages: {
        type: Array,
        required: true
      },
      scrollTop: {
        type: Number,
        default: 0
      },
      isGroup: {
        type: Boolean,
        default: false
      },
      onMessageDeleted: {
        type: Function,
        required: true
      }
    },
    data() {
      return {
        showLoadMore: false,
        internalScrollTop: 0,
        scrollViewHeight: 0,
        lastContentHeight: 0,
        isScrolling: false
        // 标记是否正在滚动
      };
    },
    watch: {
      messages: {
        handler(newMessages, oldMessages) {
          this.$nextTick(async () => {
            const newContentHeight = await this.getContentHeight();
            if (!oldMessages || newMessages.length > oldMessages.length) {
              if (!oldMessages || newMessages.length - oldMessages.length === 1 && newMessages[newMessages.length - 1].userType === "self") {
                this.scrollToBottom(true);
              } else {
                const heightDifference = newContentHeight - this.lastContentHeight;
                formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:80", "加载更多消息，保持位置。高度差:", heightDifference);
                if (heightDifference > 0) {
                  this.setScrollTop(this.internalScrollTop + heightDifference);
                }
              }
            }
            this.lastContentHeight = newContentHeight;
          });
        },
        immediate: true
      }
    },
    mounted() {
      formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:93", "MessageList组件挂载");
      this.initScrollViewHeight();
      this.getContentHeight().then((height) => {
        this.lastContentHeight = height;
        this.$nextTick(() => {
          this.scrollToBottom(true);
        });
      });
    },
    methods: {
      initScrollViewHeight() {
        const query = uni.createSelectorQuery().in(this);
        query.select(".message-list-container").boundingClientRect((data) => {
          if (data) {
            this.scrollViewHeight = data.height;
            formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:108", "滚动视图高度初始化:", this.scrollViewHeight);
          }
        }).exec();
      },
      async getContentHeight() {
        return new Promise((resolve) => {
          const query = uni.createSelectorQuery().in(this);
          query.select(".message-list-content").boundingClientRect((data) => {
            if (data) {
              resolve(data.height);
            } else {
              formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:119", "无法获取内容高度");
              resolve(0);
            }
          }).exec();
        });
      },
      onScroll(event) {
        if (this.isScrolling)
          return;
        const { scrollTop, scrollHeight } = event.detail;
        this.showLoadMore = scrollTop < 50;
        this.$emit("scroll", event);
      },
      handleLoadMore() {
        formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:135", "触发加载更多");
        this.$emit("load-more");
      },
      async scrollToBottom(force = false) {
        if (this.isScrolling && !force) {
          formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:140", "已在滚动中，跳过");
          return;
        }
        this.isScrolling = true;
        try {
          const contentHeight = await this.getContentHeight();
          const scrollTop = Math.max(0, contentHeight - this.scrollViewHeight);
          this.setScrollTop(scrollTop);
          await new Promise((resolve) => setTimeout(resolve, 100));
          this.setScrollTop(scrollTop);
        } finally {
          setTimeout(() => {
            this.isScrolling = false;
          }, 200);
        }
      },
      setScrollTop(value) {
        this.internalScrollTop = value;
      }
    }
  };
  function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_message = vue.resolveComponent("message");
    return vue.openBlock(), vue.createElementBlock("view", { class: "message-list-container" }, [
      vue.createElementVNode("scroll-view", {
        class: "scroll-view",
        "scroll-y": "",
        "scroll-top": $data.internalScrollTop,
        onScroll: _cache[2] || (_cache[2] = (...args) => $options.onScroll && $options.onScroll(...args)),
        style: vue.normalizeStyle({ height: $data.scrollViewHeight + "px" })
      }, [
        vue.createCommentVNode(" 加载更多按钮 "),
        $data.showLoadMore ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "load-more-button",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.handleLoadMore && $options.handleLoadMore(...args))
        }, [
          vue.createElementVNode("text", { class: "load-more-text" }, "点击加载更多")
        ])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("view", { class: "message-list-content" }, [
          vue.createCommentVNode(" 遍历消息列表，渲染每条消息 "),
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($props.messages, (item, index) => {
              return vue.openBlock(), vue.createBlock(_component_message, {
                key: item.id || index,
                id: `message-${index}`,
                message: item,
                "is-group": $props.isGroup,
                onViewBurnAfterReading: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("view-burn-after-reading", $event)),
                onMessageDeleted: $props.onMessageDeleted
              }, null, 8, ["id", "message", "is-group", "onMessageDeleted"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ], 44, ["scroll-top"])
    ]);
  }
  const MessageList = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$r], ["__scopeId", "data-v-dee4eb4b"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageList.vue"]]);
  const _sfc_main$r = {
    name: "AttachmentMenu",
    data() {
      return {
        // 附件选项配置
        attachOptions: [
          { icon: "/static/message/相册.png", label: "相册", action: "album" },
          { icon: "/static/message/拍摄.png", label: "拍摄", action: "camera" },
          { icon: "/static/message/视频通话.png", label: "视频通话", action: "video-call" },
          { icon: "/static/message/文件传输.png", label: "文件传输", action: "file" },
          { icon: "/static/message/阅后即焚.png", label: "阅后即焚", action: "burn-after-reading" },
          { icon: "/static/message/位置.png", label: "位置", action: "location" }
        ]
      };
    },
    methods: {
      // 处理附件项点击
      handleAttachItem(action) {
        this.$emit("attach", action);
        this.$emit("close");
      }
    }
  };
  function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "attach-menu" }, [
      vue.createElementVNode("view", { class: "attach-row" }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($data.attachOptions.slice(0, 4), (option) => {
            return vue.openBlock(), vue.createElementBlock("view", {
              key: option.action,
              class: "attach-option",
              onClick: ($event) => $options.handleAttachItem(option.action)
            }, [
              vue.createElementVNode("view", { class: "icon-wrapper" }, [
                vue.createElementVNode("image", {
                  src: option.icon,
                  class: "attach-icon",
                  mode: "aspectFit"
                }, null, 8, ["src"])
              ]),
              vue.createElementVNode(
                "text",
                { class: "attach-label" },
                vue.toDisplayString(option.label),
                1
                /* TEXT */
              )
            ], 8, ["onClick"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]),
      vue.createElementVNode("view", { class: "attach-row second-row" }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($data.attachOptions.slice(4, 6), (option) => {
            return vue.openBlock(), vue.createElementBlock("view", {
              key: option.action,
              class: "attach-option",
              onClick: ($event) => $options.handleAttachItem(option.action)
            }, [
              vue.createElementVNode("view", { class: "icon-wrapper" }, [
                vue.createElementVNode("image", {
                  src: option.icon,
                  class: "attach-icon",
                  mode: "aspectFit"
                }, null, 8, ["src"])
              ]),
              vue.createElementVNode(
                "text",
                { class: "attach-label" },
                vue.toDisplayString(option.label),
                1
                /* TEXT */
              )
            ], 8, ["onClick"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ])
    ]);
  }
  const AttachmentMenu = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$q], ["__scopeId", "data-v-00ea5aaf"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/AttachmentMenu.vue"]]);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n2) {
    if (n2.__esModule)
      return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a2 = function a3() {
        if (this instanceof a3) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a2.prototype = f2.prototype;
    } else
      a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k) {
      var d2 = Object.getOwnPropertyDescriptor(n2, k);
      Object.defineProperty(a2, k, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n2[k];
        }
      });
    });
    return a2;
  }
  var cryptoJs = { exports: {} };
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var core = { exports: {} };
  const __viteBrowserExternal = new Proxy({}, {
    get(_2, key) {
      throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${key}" in client code.  See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
    }
  });
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  var hasRequiredCore;
  function requireCore() {
    if (hasRequiredCore)
      return core.exports;
    hasRequiredCore = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory();
        }
      })(commonjsGlobal, function() {
        var CryptoJS2 = CryptoJS2 || function(Math2, undefined$1) {
          var crypto;
          if (typeof window !== "undefined" && $inject_window_crypto) {
            crypto = $inject_window_crypto;
          }
          if (typeof self !== "undefined" && self.crypto) {
            crypto = self.crypto;
          }
          if (typeof globalThis !== "undefined" && globalThis.crypto) {
            crypto = globalThis.crypto;
          }
          if (!crypto && typeof window !== "undefined" && window.msCrypto) {
            crypto = window.msCrypto;
          }
          if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
            crypto = commonjsGlobal.crypto;
          }
          if (!crypto && typeof commonjsRequire === "function") {
            try {
              crypto = require$$0;
            } catch (err) {
            }
          }
          var cryptoSecureRandomInt = function() {
            if (crypto) {
              if (typeof crypto.getRandomValues === "function") {
                try {
                  return crypto.getRandomValues(new Uint32Array(1))[0];
                } catch (err) {
                }
              }
              if (typeof crypto.randomBytes === "function") {
                try {
                  return crypto.randomBytes(4).readInt32LE();
                } catch (err) {
                }
              }
            }
            throw new Error("Native crypto module could not be used to get secure random number.");
          };
          var create = Object.create || /* @__PURE__ */ function() {
            function F2() {
            }
            return function(obj) {
              var subtype;
              F2.prototype = obj;
              subtype = new F2();
              F2.prototype = null;
              return subtype;
            };
          }();
          var C2 = {};
          var C_lib = C2.lib = {};
          var Base = C_lib.Base = /* @__PURE__ */ function() {
            return {
              /**
               * Creates a new object that inherits from this object.
               *
               * @param {Object} overrides Properties to copy into the new object.
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         field: 'value',
               *
               *         method: function () {
               *         }
               *     });
               */
              extend: function(overrides) {
                var subtype = create(this);
                if (overrides) {
                  subtype.mixIn(overrides);
                }
                if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                  subtype.init = function() {
                    subtype.$super.init.apply(this, arguments);
                  };
                }
                subtype.init.prototype = subtype;
                subtype.$super = this;
                return subtype;
              },
              /**
               * Extends this object and runs the init method.
               * Arguments to create() will be passed to init().
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var instance = MyType.create();
               */
              create: function() {
                var instance = this.extend();
                instance.init.apply(instance, arguments);
                return instance;
              },
              /**
               * Initializes a newly created object.
               * Override this method to add some logic when your objects are created.
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         init: function () {
               *             // ...
               *         }
               *     });
               */
              init: function() {
              },
              /**
               * Copies properties into this object.
               *
               * @param {Object} properties The properties to mix in.
               *
               * @example
               *
               *     MyType.mixIn({
               *         field: 'value'
               *     });
               */
              mixIn: function(properties) {
                for (var propertyName in properties) {
                  if (properties.hasOwnProperty(propertyName)) {
                    this[propertyName] = properties[propertyName];
                  }
                }
                if (properties.hasOwnProperty("toString")) {
                  this.toString = properties.toString;
                }
              },
              /**
               * Creates a copy of this object.
               *
               * @return {Object} The clone.
               *
               * @example
               *
               *     var clone = instance.clone();
               */
              clone: function() {
                return this.init.prototype.extend(this);
              }
            };
          }();
          var WordArray = C_lib.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of 32-bit words.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.create();
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined$1) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 4;
              }
            },
            /**
             * Converts this word array to a string.
             *
             * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
             *
             * @return {string} The stringified word array.
             *
             * @example
             *
             *     var string = wordArray + '';
             *     var string = wordArray.toString();
             *     var string = wordArray.toString(CryptoJS.enc.Utf8);
             */
            toString: function(encoder) {
              return (encoder || Hex).stringify(this);
            },
            /**
             * Concatenates a word array to this word array.
             *
             * @param {WordArray} wordArray The word array to append.
             *
             * @return {WordArray} This word array.
             *
             * @example
             *
             *     wordArray1.concat(wordArray2);
             */
            concat: function(wordArray) {
              var thisWords = this.words;
              var thatWords = wordArray.words;
              var thisSigBytes = this.sigBytes;
              var thatSigBytes = wordArray.sigBytes;
              this.clamp();
              if (thisSigBytes % 4) {
                for (var i2 = 0; i2 < thatSigBytes; i2++) {
                  var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                  thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
                }
              } else {
                for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                  thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
                }
              }
              this.sigBytes += thatSigBytes;
              return this;
            },
            /**
             * Removes insignificant bits.
             *
             * @example
             *
             *     wordArray.clamp();
             */
            clamp: function() {
              var words = this.words;
              var sigBytes = this.sigBytes;
              words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
              words.length = Math2.ceil(sigBytes / 4);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {WordArray} The clone.
             *
             * @example
             *
             *     var clone = wordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone.words = this.words.slice(0);
              return clone;
            },
            /**
             * Creates a word array filled with random bytes.
             *
             * @param {number} nBytes The number of random bytes to generate.
             *
             * @return {WordArray} The random word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.random(16);
             */
            random: function(nBytes) {
              var words = [];
              for (var i2 = 0; i2 < nBytes; i2 += 4) {
                words.push(cryptoSecureRandomInt());
              }
              return new WordArray.init(words, nBytes);
            }
          });
          var C_enc = C2.enc = {};
          var Hex = C_enc.Hex = {
            /**
             * Converts a word array to a hex string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The hex string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var hexChars = [];
              for (var i2 = 0; i2 < sigBytes; i2++) {
                var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 15).toString(16));
              }
              return hexChars.join("");
            },
            /**
             * Converts a hex string to a word array.
             *
             * @param {string} hexStr The hex string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
             */
            parse: function(hexStr) {
              var hexStrLength = hexStr.length;
              var words = [];
              for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
                words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
              }
              return new WordArray.init(words, hexStrLength / 2);
            }
          };
          var Latin1 = C_enc.Latin1 = {
            /**
             * Converts a word array to a Latin1 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Latin1 string.
             *
             * @static
             *
             * @example
             *
             *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var latin1Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2++) {
                var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                latin1Chars.push(String.fromCharCode(bite));
              }
              return latin1Chars.join("");
            },
            /**
             * Converts a Latin1 string to a word array.
             *
             * @param {string} latin1Str The Latin1 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
             */
            parse: function(latin1Str) {
              var latin1StrLength = latin1Str.length;
              var words = [];
              for (var i2 = 0; i2 < latin1StrLength; i2++) {
                words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
              }
              return new WordArray.init(words, latin1StrLength);
            }
          };
          var Utf8 = C_enc.Utf8 = {
            /**
             * Converts a word array to a UTF-8 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-8 string.
             *
             * @static
             *
             * @example
             *
             *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
             */
            stringify: function(wordArray) {
              try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
              } catch (e2) {
                throw new Error("Malformed UTF-8 data");
              }
            },
            /**
             * Converts a UTF-8 string to a word array.
             *
             * @param {string} utf8Str The UTF-8 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
             */
            parse: function(utf8Str) {
              return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
            }
          };
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
            /**
             * Resets this block algorithm's data buffer to its initial state.
             *
             * @example
             *
             *     bufferedBlockAlgorithm.reset();
             */
            reset: function() {
              this._data = new WordArray.init();
              this._nDataBytes = 0;
            },
            /**
             * Adds new data to this block algorithm's buffer.
             *
             * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
             *
             * @example
             *
             *     bufferedBlockAlgorithm._append('data');
             *     bufferedBlockAlgorithm._append(wordArray);
             */
            _append: function(data) {
              if (typeof data == "string") {
                data = Utf8.parse(data);
              }
              this._data.concat(data);
              this._nDataBytes += data.sigBytes;
            },
            /**
             * Processes available data blocks.
             *
             * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
             *
             * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
             *
             * @return {WordArray} The processed data.
             *
             * @example
             *
             *     var processedData = bufferedBlockAlgorithm._process();
             *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
             */
            _process: function(doFlush) {
              var processedWords;
              var data = this._data;
              var dataWords = data.words;
              var dataSigBytes = data.sigBytes;
              var blockSize = this.blockSize;
              var blockSizeBytes = blockSize * 4;
              var nBlocksReady = dataSigBytes / blockSizeBytes;
              if (doFlush) {
                nBlocksReady = Math2.ceil(nBlocksReady);
              } else {
                nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
              }
              var nWordsReady = nBlocksReady * blockSize;
              var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
              if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                  this._doProcessBlock(dataWords, offset);
                }
                processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
              }
              return new WordArray.init(processedWords, nBytesReady);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = bufferedBlockAlgorithm.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone._data = this._data.clone();
              return clone;
            },
            _minBufferSize: 0
          });
          C_lib.Hasher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             */
            cfg: Base.extend(),
            /**
             * Initializes a newly created hasher.
             *
             * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
             *
             * @example
             *
             *     var hasher = CryptoJS.algo.SHA256.create();
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
              this.reset();
            },
            /**
             * Resets this hasher to its initial state.
             *
             * @example
             *
             *     hasher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Updates this hasher with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {Hasher} This hasher.
             *
             * @example
             *
             *     hasher.update('message');
             *     hasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._append(messageUpdate);
              this._process();
              return this;
            },
            /**
             * Finalizes the hash computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The hash.
             *
             * @example
             *
             *     var hash = hasher.finalize();
             *     var hash = hasher.finalize('message');
             *     var hash = hasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              if (messageUpdate) {
                this._append(messageUpdate);
              }
              var hash = this._doFinalize();
              return hash;
            },
            blockSize: 512 / 32,
            /**
             * Creates a shortcut function to a hasher's object interface.
             *
             * @param {Hasher} hasher The hasher to create a helper for.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
             */
            _createHelper: function(hasher) {
              return function(message, cfg) {
                return new hasher.init(cfg).finalize(message);
              };
            },
            /**
             * Creates a shortcut function to the HMAC's object interface.
             *
             * @param {Hasher} hasher The hasher to use in this HMAC helper.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
             */
            _createHmacHelper: function(hasher) {
              return function(message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
              };
            }
          });
          var C_algo = C2.algo = {};
          return C2;
        }(Math);
        return CryptoJS2;
      });
    })(core);
    return core.exports;
  }
  var x64Core = { exports: {} };
  var hasRequiredX64Core;
  function requireX64Core() {
    if (hasRequiredX64Core)
      return x64Core.exports;
    hasRequiredX64Core = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(undefined$1) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var X32WordArray = C_lib.WordArray;
          var C_x64 = C2.x64 = {};
          C_x64.Word = Base.extend({
            /**
             * Initializes a newly created 64-bit word.
             *
             * @param {number} high The high 32 bits.
             * @param {number} low The low 32 bits.
             *
             * @example
             *
             *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
             */
            init: function(high, low) {
              this.high = high;
              this.low = low;
            }
            /**
             * Bitwise NOTs this word.
             *
             * @return {X64Word} A new x64-Word object after negating.
             *
             * @example
             *
             *     var negated = x64Word.not();
             */
            // not: function () {
            // var high = ~this.high;
            // var low = ~this.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ANDs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to AND with this word.
             *
             * @return {X64Word} A new x64-Word object after ANDing.
             *
             * @example
             *
             *     var anded = x64Word.and(anotherX64Word);
             */
            // and: function (word) {
            // var high = this.high & word.high;
            // var low = this.low & word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to OR with this word.
             *
             * @return {X64Word} A new x64-Word object after ORing.
             *
             * @example
             *
             *     var ored = x64Word.or(anotherX64Word);
             */
            // or: function (word) {
            // var high = this.high | word.high;
            // var low = this.low | word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise XORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to XOR with this word.
             *
             * @return {X64Word} A new x64-Word object after XORing.
             *
             * @example
             *
             *     var xored = x64Word.xor(anotherX64Word);
             */
            // xor: function (word) {
            // var high = this.high ^ word.high;
            // var low = this.low ^ word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the left.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftL(25);
             */
            // shiftL: function (n) {
            // if (n < 32) {
            // var high = (this.high << n) | (this.low >>> (32 - n));
            // var low = this.low << n;
            // } else {
            // var high = this.low << (n - 32);
            // var low = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the right.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftR(7);
             */
            // shiftR: function (n) {
            // if (n < 32) {
            // var low = (this.low >>> n) | (this.high << (32 - n));
            // var high = this.high >>> n;
            // } else {
            // var low = this.high >>> (n - 32);
            // var high = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Rotates this word n bits to the left.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotL(25);
             */
            // rotL: function (n) {
            // return this.shiftL(n).or(this.shiftR(64 - n));
            // },
            /**
             * Rotates this word n bits to the right.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotR(7);
             */
            // rotR: function (n) {
            // return this.shiftR(n).or(this.shiftL(64 - n));
            // },
            /**
             * Adds this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to add with this word.
             *
             * @return {X64Word} A new x64-Word object after adding.
             *
             * @example
             *
             *     var added = x64Word.add(anotherX64Word);
             */
            // add: function (word) {
            // var low = (this.low + word.low) | 0;
            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
            // var high = (this.high + word.high + carry) | 0;
            // return X64Word.create(high, low);
            // }
          });
          C_x64.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.x64.WordArray.create();
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ]);
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ], 10);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined$1) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 8;
              }
            },
            /**
             * Converts this 64-bit word array to a 32-bit word array.
             *
             * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
             *
             * @example
             *
             *     var x32WordArray = x64WordArray.toX32();
             */
            toX32: function() {
              var x64Words = this.words;
              var x64WordsLength = x64Words.length;
              var x32Words = [];
              for (var i2 = 0; i2 < x64WordsLength; i2++) {
                var x64Word = x64Words[i2];
                x32Words.push(x64Word.high);
                x32Words.push(x64Word.low);
              }
              return X32WordArray.create(x32Words, this.sigBytes);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {X64WordArray} The clone.
             *
             * @example
             *
             *     var clone = x64WordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              var words = clone.words = this.words.slice(0);
              var wordsLength = words.length;
              for (var i2 = 0; i2 < wordsLength; i2++) {
                words[i2] = words[i2].clone();
              }
              return clone;
            }
          });
        })();
        return CryptoJS2;
      });
    })(x64Core);
    return x64Core.exports;
  }
  var libTypedarrays = { exports: {} };
  var hasRequiredLibTypedarrays;
  function requireLibTypedarrays() {
    if (hasRequiredLibTypedarrays)
      return libTypedarrays.exports;
    hasRequiredLibTypedarrays = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          if (typeof ArrayBuffer != "function") {
            return;
          }
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var superInit = WordArray.init;
          var subInit = WordArray.init = function(typedArray) {
            if (typedArray instanceof ArrayBuffer) {
              typedArray = new Uint8Array(typedArray);
            }
            if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
              typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
            }
            if (typedArray instanceof Uint8Array) {
              var typedArrayByteLength = typedArray.byteLength;
              var words = [];
              for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
                words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
              }
              superInit.call(this, words, typedArrayByteLength);
            } else {
              superInit.apply(this, arguments);
            }
          };
          subInit.prototype = WordArray;
        })();
        return CryptoJS2.lib.WordArray;
      });
    })(libTypedarrays);
    return libTypedarrays.exports;
  }
  var encUtf16 = { exports: {} };
  var hasRequiredEncUtf16;
  function requireEncUtf16() {
    if (hasRequiredEncUtf16)
      return encUtf16.exports;
    hasRequiredEncUtf16 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C2.enc;
          C_enc.Utf16 = C_enc.Utf16BE = {
            /**
             * Converts a word array to a UTF-16 BE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 BE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 2) {
                var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 BE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 BE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i2 = 0; i2 < utf16StrLength; i2++) {
                words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          C_enc.Utf16LE = {
            /**
             * Converts a word array to a UTF-16 LE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 LE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 2) {
                var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 LE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 LE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i2 = 0; i2 < utf16StrLength; i2++) {
                words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          function swapEndian(word) {
            return word << 8 & 4278255360 | word >>> 8 & 16711935;
          }
        })();
        return CryptoJS2.enc.Utf16;
      });
    })(encUtf16);
    return encUtf16.exports;
  }
  var encBase64 = { exports: {} };
  var hasRequiredEncBase64;
  function requireEncBase64() {
    if (hasRequiredEncBase64)
      return encBase64.exports;
    hasRequiredEncBase64 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C2.enc;
          C_enc.Base64 = {
            /**
             * Converts a word array to a Base64 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Base64 string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map2 = this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 3) {
                var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
                var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j2 = 0; j2 < 4 && i2 + j2 * 0.75 < sigBytes; j2++) {
                  base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64 string to a word array.
             *
             * @param {string} base64Str The Base64 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
             */
            parse: function(base64Str) {
              var base64StrLength = base64Str.length;
              var map2 = this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j2 = 0; j2 < map2.length; j2++) {
                  reverseMap[map2.charCodeAt(j2)] = j2;
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i2 = 0; i2 < base64StrLength; i2++) {
              if (i2 % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS2.enc.Base64;
      });
    })(encBase64);
    return encBase64.exports;
  }
  var encBase64url = { exports: {} };
  var hasRequiredEncBase64url;
  function requireEncBase64url() {
    if (hasRequiredEncBase64url)
      return encBase64url.exports;
    hasRequiredEncBase64url = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C2.enc;
          C_enc.Base64url = {
            /**
             * Converts a word array to a Base64url string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {string} The Base64url string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
             */
            stringify: function(wordArray, urlSafe) {
              if (urlSafe === void 0) {
                urlSafe = true;
              }
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map2 = urlSafe ? this._safe_map : this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 3) {
                var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
                var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j2 = 0; j2 < 4 && i2 + j2 * 0.75 < sigBytes; j2++) {
                  base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64url string to a word array.
             *
             * @param {string} base64Str The Base64url string.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
             */
            parse: function(base64Str, urlSafe) {
              if (urlSafe === void 0) {
                urlSafe = true;
              }
              var base64StrLength = base64Str.length;
              var map2 = urlSafe ? this._safe_map : this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j2 = 0; j2 < map2.length; j2++) {
                  reverseMap[map2.charCodeAt(j2)] = j2;
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i2 = 0; i2 < base64StrLength; i2++) {
              if (i2 % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS2.enc.Base64url;
      });
    })(encBase64url);
    return encBase64url.exports;
  }
  var md5 = { exports: {} };
  var hasRequiredMd5;
  function requireMd5() {
    if (hasRequiredMd5)
      return md5.exports;
    hasRequiredMd5 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(Math2) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C2.algo;
          var T2 = [];
          (function() {
            for (var i2 = 0; i2 < 64; i2++) {
              T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
            }
          })();
          var MD5 = C_algo.MD5 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878
              ]);
            },
            _doProcessBlock: function(M2, offset) {
              for (var i2 = 0; i2 < 16; i2++) {
                var offset_i = offset + i2;
                var M_offset_i = M2[offset_i];
                M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H2 = this._hash.words;
              var M_offset_0 = M2[offset + 0];
              var M_offset_1 = M2[offset + 1];
              var M_offset_2 = M2[offset + 2];
              var M_offset_3 = M2[offset + 3];
              var M_offset_4 = M2[offset + 4];
              var M_offset_5 = M2[offset + 5];
              var M_offset_6 = M2[offset + 6];
              var M_offset_7 = M2[offset + 7];
              var M_offset_8 = M2[offset + 8];
              var M_offset_9 = M2[offset + 9];
              var M_offset_10 = M2[offset + 10];
              var M_offset_11 = M2[offset + 11];
              var M_offset_12 = M2[offset + 12];
              var M_offset_13 = M2[offset + 13];
              var M_offset_14 = M2[offset + 14];
              var M_offset_15 = M2[offset + 15];
              var a2 = H2[0];
              var b2 = H2[1];
              var c2 = H2[2];
              var d2 = H2[3];
              a2 = FF(a2, b2, c2, d2, M_offset_0, 7, T2[0]);
              d2 = FF(d2, a2, b2, c2, M_offset_1, 12, T2[1]);
              c2 = FF(c2, d2, a2, b2, M_offset_2, 17, T2[2]);
              b2 = FF(b2, c2, d2, a2, M_offset_3, 22, T2[3]);
              a2 = FF(a2, b2, c2, d2, M_offset_4, 7, T2[4]);
              d2 = FF(d2, a2, b2, c2, M_offset_5, 12, T2[5]);
              c2 = FF(c2, d2, a2, b2, M_offset_6, 17, T2[6]);
              b2 = FF(b2, c2, d2, a2, M_offset_7, 22, T2[7]);
              a2 = FF(a2, b2, c2, d2, M_offset_8, 7, T2[8]);
              d2 = FF(d2, a2, b2, c2, M_offset_9, 12, T2[9]);
              c2 = FF(c2, d2, a2, b2, M_offset_10, 17, T2[10]);
              b2 = FF(b2, c2, d2, a2, M_offset_11, 22, T2[11]);
              a2 = FF(a2, b2, c2, d2, M_offset_12, 7, T2[12]);
              d2 = FF(d2, a2, b2, c2, M_offset_13, 12, T2[13]);
              c2 = FF(c2, d2, a2, b2, M_offset_14, 17, T2[14]);
              b2 = FF(b2, c2, d2, a2, M_offset_15, 22, T2[15]);
              a2 = GG(a2, b2, c2, d2, M_offset_1, 5, T2[16]);
              d2 = GG(d2, a2, b2, c2, M_offset_6, 9, T2[17]);
              c2 = GG(c2, d2, a2, b2, M_offset_11, 14, T2[18]);
              b2 = GG(b2, c2, d2, a2, M_offset_0, 20, T2[19]);
              a2 = GG(a2, b2, c2, d2, M_offset_5, 5, T2[20]);
              d2 = GG(d2, a2, b2, c2, M_offset_10, 9, T2[21]);
              c2 = GG(c2, d2, a2, b2, M_offset_15, 14, T2[22]);
              b2 = GG(b2, c2, d2, a2, M_offset_4, 20, T2[23]);
              a2 = GG(a2, b2, c2, d2, M_offset_9, 5, T2[24]);
              d2 = GG(d2, a2, b2, c2, M_offset_14, 9, T2[25]);
              c2 = GG(c2, d2, a2, b2, M_offset_3, 14, T2[26]);
              b2 = GG(b2, c2, d2, a2, M_offset_8, 20, T2[27]);
              a2 = GG(a2, b2, c2, d2, M_offset_13, 5, T2[28]);
              d2 = GG(d2, a2, b2, c2, M_offset_2, 9, T2[29]);
              c2 = GG(c2, d2, a2, b2, M_offset_7, 14, T2[30]);
              b2 = GG(b2, c2, d2, a2, M_offset_12, 20, T2[31]);
              a2 = HH(a2, b2, c2, d2, M_offset_5, 4, T2[32]);
              d2 = HH(d2, a2, b2, c2, M_offset_8, 11, T2[33]);
              c2 = HH(c2, d2, a2, b2, M_offset_11, 16, T2[34]);
              b2 = HH(b2, c2, d2, a2, M_offset_14, 23, T2[35]);
              a2 = HH(a2, b2, c2, d2, M_offset_1, 4, T2[36]);
              d2 = HH(d2, a2, b2, c2, M_offset_4, 11, T2[37]);
              c2 = HH(c2, d2, a2, b2, M_offset_7, 16, T2[38]);
              b2 = HH(b2, c2, d2, a2, M_offset_10, 23, T2[39]);
              a2 = HH(a2, b2, c2, d2, M_offset_13, 4, T2[40]);
              d2 = HH(d2, a2, b2, c2, M_offset_0, 11, T2[41]);
              c2 = HH(c2, d2, a2, b2, M_offset_3, 16, T2[42]);
              b2 = HH(b2, c2, d2, a2, M_offset_6, 23, T2[43]);
              a2 = HH(a2, b2, c2, d2, M_offset_9, 4, T2[44]);
              d2 = HH(d2, a2, b2, c2, M_offset_12, 11, T2[45]);
              c2 = HH(c2, d2, a2, b2, M_offset_15, 16, T2[46]);
              b2 = HH(b2, c2, d2, a2, M_offset_2, 23, T2[47]);
              a2 = II(a2, b2, c2, d2, M_offset_0, 6, T2[48]);
              d2 = II(d2, a2, b2, c2, M_offset_7, 10, T2[49]);
              c2 = II(c2, d2, a2, b2, M_offset_14, 15, T2[50]);
              b2 = II(b2, c2, d2, a2, M_offset_5, 21, T2[51]);
              a2 = II(a2, b2, c2, d2, M_offset_12, 6, T2[52]);
              d2 = II(d2, a2, b2, c2, M_offset_3, 10, T2[53]);
              c2 = II(c2, d2, a2, b2, M_offset_10, 15, T2[54]);
              b2 = II(b2, c2, d2, a2, M_offset_1, 21, T2[55]);
              a2 = II(a2, b2, c2, d2, M_offset_8, 6, T2[56]);
              d2 = II(d2, a2, b2, c2, M_offset_15, 10, T2[57]);
              c2 = II(c2, d2, a2, b2, M_offset_6, 15, T2[58]);
              b2 = II(b2, c2, d2, a2, M_offset_13, 21, T2[59]);
              a2 = II(a2, b2, c2, d2, M_offset_4, 6, T2[60]);
              d2 = II(d2, a2, b2, c2, M_offset_11, 10, T2[61]);
              c2 = II(c2, d2, a2, b2, M_offset_2, 15, T2[62]);
              b2 = II(b2, c2, d2, a2, M_offset_9, 21, T2[63]);
              H2[0] = H2[0] + a2 | 0;
              H2[1] = H2[1] + b2 | 0;
              H2[2] = H2[2] + c2 | 0;
              H2[3] = H2[3] + d2 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
              var nBitsTotalL = nBitsTotal;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash = this._hash;
              var H2 = hash.words;
              for (var i2 = 0; i2 < 4; i2++) {
                var H_i = H2[i2];
                H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function FF(a2, b2, c2, d2, x, s2, t2) {
            var n2 = a2 + (b2 & c2 | ~b2 & d2) + x + t2;
            return (n2 << s2 | n2 >>> 32 - s2) + b2;
          }
          function GG(a2, b2, c2, d2, x, s2, t2) {
            var n2 = a2 + (b2 & d2 | c2 & ~d2) + x + t2;
            return (n2 << s2 | n2 >>> 32 - s2) + b2;
          }
          function HH(a2, b2, c2, d2, x, s2, t2) {
            var n2 = a2 + (b2 ^ c2 ^ d2) + x + t2;
            return (n2 << s2 | n2 >>> 32 - s2) + b2;
          }
          function II(a2, b2, c2, d2, x, s2, t2) {
            var n2 = a2 + (c2 ^ (b2 | ~d2)) + x + t2;
            return (n2 << s2 | n2 >>> 32 - s2) + b2;
          }
          C2.MD5 = Hasher._createHelper(MD5);
          C2.HmacMD5 = Hasher._createHmacHelper(MD5);
        })(Math);
        return CryptoJS2.MD5;
      });
    })(md5);
    return md5.exports;
  }
  var sha1 = { exports: {} };
  var hasRequiredSha1;
  function requireSha1() {
    if (hasRequiredSha1)
      return sha1.exports;
    hasRequiredSha1 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C2.algo;
          var W2 = [];
          var SHA1 = C_algo.SHA1 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
              ]);
            },
            _doProcessBlock: function(M2, offset) {
              var H2 = this._hash.words;
              var a2 = H2[0];
              var b2 = H2[1];
              var c2 = H2[2];
              var d2 = H2[3];
              var e2 = H2[4];
              for (var i2 = 0; i2 < 80; i2++) {
                if (i2 < 16) {
                  W2[i2] = M2[offset + i2] | 0;
                } else {
                  var n2 = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
                  W2[i2] = n2 << 1 | n2 >>> 31;
                }
                var t2 = (a2 << 5 | a2 >>> 27) + e2 + W2[i2];
                if (i2 < 20) {
                  t2 += (b2 & c2 | ~b2 & d2) + 1518500249;
                } else if (i2 < 40) {
                  t2 += (b2 ^ c2 ^ d2) + 1859775393;
                } else if (i2 < 60) {
                  t2 += (b2 & c2 | b2 & d2 | c2 & d2) - 1894007588;
                } else {
                  t2 += (b2 ^ c2 ^ d2) - 899497514;
                }
                e2 = d2;
                d2 = c2;
                c2 = b2 << 30 | b2 >>> 2;
                b2 = a2;
                a2 = t2;
              }
              H2[0] = H2[0] + a2 | 0;
              H2[1] = H2[1] + b2 | 0;
              H2[2] = H2[2] + c2 | 0;
              H2[3] = H2[3] + d2 | 0;
              H2[4] = H2[4] + e2 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C2.SHA1 = Hasher._createHelper(SHA1);
          C2.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        })();
        return CryptoJS2.SHA1;
      });
    })(sha1);
    return sha1.exports;
  }
  var sha256 = { exports: {} };
  var hasRequiredSha256;
  function requireSha256() {
    if (hasRequiredSha256)
      return sha256.exports;
    hasRequiredSha256 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(Math2) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C2.algo;
          var H2 = [];
          var K2 = [];
          (function() {
            function isPrime(n3) {
              var sqrtN = Math2.sqrt(n3);
              for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n3 % factor)) {
                  return false;
                }
              }
              return true;
            }
            function getFractionalBits(n3) {
              return (n3 - (n3 | 0)) * 4294967296 | 0;
            }
            var n2 = 2;
            var nPrime = 0;
            while (nPrime < 64) {
              if (isPrime(n2)) {
                if (nPrime < 8) {
                  H2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
                }
                K2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
                nPrime++;
              }
              n2++;
            }
          })();
          var W2 = [];
          var SHA256 = C_algo.SHA256 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init(H2.slice(0));
            },
            _doProcessBlock: function(M2, offset) {
              var H3 = this._hash.words;
              var a2 = H3[0];
              var b2 = H3[1];
              var c2 = H3[2];
              var d2 = H3[3];
              var e2 = H3[4];
              var f2 = H3[5];
              var g2 = H3[6];
              var h2 = H3[7];
              for (var i2 = 0; i2 < 64; i2++) {
                if (i2 < 16) {
                  W2[i2] = M2[offset + i2] | 0;
                } else {
                  var gamma0x = W2[i2 - 15];
                  var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                  var gamma1x = W2[i2 - 2];
                  var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                  W2[i2] = gamma0 + W2[i2 - 7] + gamma1 + W2[i2 - 16];
                }
                var ch = e2 & f2 ^ ~e2 & g2;
                var maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
                var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
                var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
                var t1 = h2 + sigma1 + ch + K2[i2] + W2[i2];
                var t2 = sigma0 + maj;
                h2 = g2;
                g2 = f2;
                f2 = e2;
                e2 = d2 + t1 | 0;
                d2 = c2;
                c2 = b2;
                b2 = a2;
                a2 = t1 + t2 | 0;
              }
              H3[0] = H3[0] + a2 | 0;
              H3[1] = H3[1] + b2 | 0;
              H3[2] = H3[2] + c2 | 0;
              H3[3] = H3[3] + d2 | 0;
              H3[4] = H3[4] + e2 | 0;
              H3[5] = H3[5] + f2 | 0;
              H3[6] = H3[6] + g2 | 0;
              H3[7] = H3[7] + h2 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C2.SHA256 = Hasher._createHelper(SHA256);
          C2.HmacSHA256 = Hasher._createHmacHelper(SHA256);
        })(Math);
        return CryptoJS2.SHA256;
      });
    })(sha256);
    return sha256.exports;
  }
  var sha224 = { exports: {} };
  var hasRequiredSha224;
  function requireSha224() {
    if (hasRequiredSha224)
      return sha224.exports;
    hasRequiredSha224 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireSha256());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var C_algo = C2.algo;
          var SHA256 = C_algo.SHA256;
          var SHA224 = C_algo.SHA224 = SHA256.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                3238371032,
                914150663,
                812702999,
                4144912697,
                4290775857,
                1750603025,
                1694076839,
                3204075428
              ]);
            },
            _doFinalize: function() {
              var hash = SHA256._doFinalize.call(this);
              hash.sigBytes -= 4;
              return hash;
            }
          });
          C2.SHA224 = SHA256._createHelper(SHA224);
          C2.HmacSHA224 = SHA256._createHmacHelper(SHA224);
        })();
        return CryptoJS2.SHA224;
      });
    })(sha224);
    return sha224.exports;
  }
  var sha512 = { exports: {} };
  var hasRequiredSha512;
  function requireSha512() {
    if (hasRequiredSha512)
      return sha512.exports;
    hasRequiredSha512 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireX64Core());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Hasher = C_lib.Hasher;
          var C_x64 = C2.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C2.algo;
          function X64Word_create() {
            return X64Word.create.apply(X64Word, arguments);
          }
          var K2 = [
            X64Word_create(1116352408, 3609767458),
            X64Word_create(1899447441, 602891725),
            X64Word_create(3049323471, 3964484399),
            X64Word_create(3921009573, 2173295548),
            X64Word_create(961987163, 4081628472),
            X64Word_create(1508970993, 3053834265),
            X64Word_create(2453635748, 2937671579),
            X64Word_create(2870763221, 3664609560),
            X64Word_create(3624381080, 2734883394),
            X64Word_create(310598401, 1164996542),
            X64Word_create(607225278, 1323610764),
            X64Word_create(1426881987, 3590304994),
            X64Word_create(1925078388, 4068182383),
            X64Word_create(2162078206, 991336113),
            X64Word_create(2614888103, 633803317),
            X64Word_create(3248222580, 3479774868),
            X64Word_create(3835390401, 2666613458),
            X64Word_create(4022224774, 944711139),
            X64Word_create(264347078, 2341262773),
            X64Word_create(604807628, 2007800933),
            X64Word_create(770255983, 1495990901),
            X64Word_create(1249150122, 1856431235),
            X64Word_create(1555081692, 3175218132),
            X64Word_create(1996064986, 2198950837),
            X64Word_create(2554220882, 3999719339),
            X64Word_create(2821834349, 766784016),
            X64Word_create(2952996808, 2566594879),
            X64Word_create(3210313671, 3203337956),
            X64Word_create(3336571891, 1034457026),
            X64Word_create(3584528711, 2466948901),
            X64Word_create(113926993, 3758326383),
            X64Word_create(338241895, 168717936),
            X64Word_create(666307205, 1188179964),
            X64Word_create(773529912, 1546045734),
            X64Word_create(1294757372, 1522805485),
            X64Word_create(1396182291, 2643833823),
            X64Word_create(1695183700, 2343527390),
            X64Word_create(1986661051, 1014477480),
            X64Word_create(2177026350, 1206759142),
            X64Word_create(2456956037, 344077627),
            X64Word_create(2730485921, 1290863460),
            X64Word_create(2820302411, 3158454273),
            X64Word_create(3259730800, 3505952657),
            X64Word_create(3345764771, 106217008),
            X64Word_create(3516065817, 3606008344),
            X64Word_create(3600352804, 1432725776),
            X64Word_create(4094571909, 1467031594),
            X64Word_create(275423344, 851169720),
            X64Word_create(430227734, 3100823752),
            X64Word_create(506948616, 1363258195),
            X64Word_create(659060556, 3750685593),
            X64Word_create(883997877, 3785050280),
            X64Word_create(958139571, 3318307427),
            X64Word_create(1322822218, 3812723403),
            X64Word_create(1537002063, 2003034995),
            X64Word_create(1747873779, 3602036899),
            X64Word_create(1955562222, 1575990012),
            X64Word_create(2024104815, 1125592928),
            X64Word_create(2227730452, 2716904306),
            X64Word_create(2361852424, 442776044),
            X64Word_create(2428436474, 593698344),
            X64Word_create(2756734187, 3733110249),
            X64Word_create(3204031479, 2999351573),
            X64Word_create(3329325298, 3815920427),
            X64Word_create(3391569614, 3928383900),
            X64Word_create(3515267271, 566280711),
            X64Word_create(3940187606, 3454069534),
            X64Word_create(4118630271, 4000239992),
            X64Word_create(116418474, 1914138554),
            X64Word_create(174292421, 2731055270),
            X64Word_create(289380356, 3203993006),
            X64Word_create(460393269, 320620315),
            X64Word_create(685471733, 587496836),
            X64Word_create(852142971, 1086792851),
            X64Word_create(1017036298, 365543100),
            X64Word_create(1126000580, 2618297676),
            X64Word_create(1288033470, 3409855158),
            X64Word_create(1501505948, 4234509866),
            X64Word_create(1607167915, 987167468),
            X64Word_create(1816402316, 1246189591)
          ];
          var W2 = [];
          (function() {
            for (var i2 = 0; i2 < 80; i2++) {
              W2[i2] = X64Word_create();
            }
          })();
          var SHA512 = C_algo.SHA512 = Hasher.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(1779033703, 4089235720),
                new X64Word.init(3144134277, 2227873595),
                new X64Word.init(1013904242, 4271175723),
                new X64Word.init(2773480762, 1595750129),
                new X64Word.init(1359893119, 2917565137),
                new X64Word.init(2600822924, 725511199),
                new X64Word.init(528734635, 4215389547),
                new X64Word.init(1541459225, 327033209)
              ]);
            },
            _doProcessBlock: function(M2, offset) {
              var H2 = this._hash.words;
              var H0 = H2[0];
              var H1 = H2[1];
              var H22 = H2[2];
              var H3 = H2[3];
              var H4 = H2[4];
              var H5 = H2[5];
              var H6 = H2[6];
              var H7 = H2[7];
              var H0h = H0.high;
              var H0l = H0.low;
              var H1h = H1.high;
              var H1l = H1.low;
              var H2h = H22.high;
              var H2l = H22.low;
              var H3h = H3.high;
              var H3l = H3.low;
              var H4h = H4.high;
              var H4l = H4.low;
              var H5h = H5.high;
              var H5l = H5.low;
              var H6h = H6.high;
              var H6l = H6.low;
              var H7h = H7.high;
              var H7l = H7.low;
              var ah = H0h;
              var al = H0l;
              var bh = H1h;
              var bl = H1l;
              var ch = H2h;
              var cl = H2l;
              var dh = H3h;
              var dl = H3l;
              var eh = H4h;
              var el = H4l;
              var fh = H5h;
              var fl = H5l;
              var gh = H6h;
              var gl = H6l;
              var hh = H7h;
              var hl = H7l;
              for (var i2 = 0; i2 < 80; i2++) {
                var Wil;
                var Wih;
                var Wi = W2[i2];
                if (i2 < 16) {
                  Wih = Wi.high = M2[offset + i2 * 2] | 0;
                  Wil = Wi.low = M2[offset + i2 * 2 + 1] | 0;
                } else {
                  var gamma0x = W2[i2 - 15];
                  var gamma0xh = gamma0x.high;
                  var gamma0xl = gamma0x.low;
                  var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                  var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                  var gamma1x = W2[i2 - 2];
                  var gamma1xh = gamma1x.high;
                  var gamma1xl = gamma1x.low;
                  var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                  var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                  var Wi7 = W2[i2 - 7];
                  var Wi7h = Wi7.high;
                  var Wi7l = Wi7.low;
                  var Wi16 = W2[i2 - 16];
                  var Wi16h = Wi16.high;
                  var Wi16l = Wi16.low;
                  Wil = gamma0l + Wi7l;
                  Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                  Wil = Wil + gamma1l;
                  Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                  Wil = Wil + Wi16l;
                  Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                  Wi.high = Wih;
                  Wi.low = Wil;
                }
                var chh = eh & fh ^ ~eh & gh;
                var chl = el & fl ^ ~el & gl;
                var majh = ah & bh ^ ah & ch ^ bh & ch;
                var majl = al & bl ^ al & cl ^ bl & cl;
                var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                var Ki = K2[i2];
                var Kih = Ki.high;
                var Kil = Ki.low;
                var t1l = hl + sigma1l;
                var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                var t1l = t1l + chl;
                var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                var t1l = t1l + Kil;
                var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                var t1l = t1l + Wil;
                var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                var t2l = sigma0l + majl;
                var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                hh = gh;
                hl = gl;
                gh = fh;
                gl = fl;
                fh = eh;
                fl = el;
                el = dl + t1l | 0;
                eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                dh = ch;
                dl = cl;
                ch = bh;
                cl = bl;
                bh = ah;
                bl = al;
                al = t1l + t2l | 0;
                ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
              }
              H0l = H0.low = H0l + al;
              H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
              H1l = H1.low = H1l + bl;
              H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
              H2l = H22.low = H2l + cl;
              H22.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
              H3l = H3.low = H3l + dl;
              H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
              H4l = H4.low = H4l + el;
              H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
              H5l = H5.low = H5l + fl;
              H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
              H6l = H6.low = H6l + gl;
              H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
              H7l = H7.low = H7l + hl;
              H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              var hash = this._hash.toX32();
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            },
            blockSize: 1024 / 32
          });
          C2.SHA512 = Hasher._createHelper(SHA512);
          C2.HmacSHA512 = Hasher._createHmacHelper(SHA512);
        })();
        return CryptoJS2.SHA512;
      });
    })(sha512);
    return sha512.exports;
  }
  var sha384 = { exports: {} };
  var hasRequiredSha384;
  function requireSha384() {
    if (hasRequiredSha384)
      return sha384.exports;
    hasRequiredSha384 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireX64Core(), requireSha512());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_x64 = C2.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C2.algo;
          var SHA512 = C_algo.SHA512;
          var SHA384 = C_algo.SHA384 = SHA512.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(3418070365, 3238371032),
                new X64Word.init(1654270250, 914150663),
                new X64Word.init(2438529370, 812702999),
                new X64Word.init(355462360, 4144912697),
                new X64Word.init(1731405415, 4290775857),
                new X64Word.init(2394180231, 1750603025),
                new X64Word.init(3675008525, 1694076839),
                new X64Word.init(1203062813, 3204075428)
              ]);
            },
            _doFinalize: function() {
              var hash = SHA512._doFinalize.call(this);
              hash.sigBytes -= 16;
              return hash;
            }
          });
          C2.SHA384 = SHA512._createHelper(SHA384);
          C2.HmacSHA384 = SHA512._createHmacHelper(SHA384);
        })();
        return CryptoJS2.SHA384;
      });
    })(sha384);
    return sha384.exports;
  }
  var sha3 = { exports: {} };
  var hasRequiredSha3;
  function requireSha3() {
    if (hasRequiredSha3)
      return sha3.exports;
    hasRequiredSha3 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireX64Core());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(Math2) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_x64 = C2.x64;
          var X64Word = C_x64.Word;
          var C_algo = C2.algo;
          var RHO_OFFSETS = [];
          var PI_INDEXES = [];
          var ROUND_CONSTANTS = [];
          (function() {
            var x = 1, y2 = 0;
            for (var t2 = 0; t2 < 24; t2++) {
              RHO_OFFSETS[x + 5 * y2] = (t2 + 1) * (t2 + 2) / 2 % 64;
              var newX = y2 % 5;
              var newY = (2 * x + 3 * y2) % 5;
              x = newX;
              y2 = newY;
            }
            for (var x = 0; x < 5; x++) {
              for (var y2 = 0; y2 < 5; y2++) {
                PI_INDEXES[x + 5 * y2] = y2 + (2 * x + 3 * y2) % 5 * 5;
              }
            }
            var LFSR = 1;
            for (var i2 = 0; i2 < 24; i2++) {
              var roundConstantMsw = 0;
              var roundConstantLsw = 0;
              for (var j2 = 0; j2 < 7; j2++) {
                if (LFSR & 1) {
                  var bitPosition = (1 << j2) - 1;
                  if (bitPosition < 32) {
                    roundConstantLsw ^= 1 << bitPosition;
                  } else {
                    roundConstantMsw ^= 1 << bitPosition - 32;
                  }
                }
                if (LFSR & 128) {
                  LFSR = LFSR << 1 ^ 113;
                } else {
                  LFSR <<= 1;
                }
              }
              ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
            }
          })();
          var T2 = [];
          (function() {
            for (var i2 = 0; i2 < 25; i2++) {
              T2[i2] = X64Word.create();
            }
          })();
          var SHA3 = C_algo.SHA3 = Hasher.extend({
            /**
             * Configuration options.
             *
             * @property {number} outputLength
             *   The desired number of bits in the output hash.
             *   Only values permitted are: 224, 256, 384, 512.
             *   Default: 512
             */
            cfg: Hasher.cfg.extend({
              outputLength: 512
            }),
            _doReset: function() {
              var state = this._state = [];
              for (var i2 = 0; i2 < 25; i2++) {
                state[i2] = new X64Word.init();
              }
              this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
            },
            _doProcessBlock: function(M2, offset) {
              var state = this._state;
              var nBlockSizeLanes = this.blockSize / 2;
              for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
                var M2i = M2[offset + 2 * i2];
                var M2i1 = M2[offset + 2 * i2 + 1];
                M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                var lane = state[i2];
                lane.high ^= M2i1;
                lane.low ^= M2i;
              }
              for (var round = 0; round < 24; round++) {
                for (var x = 0; x < 5; x++) {
                  var tMsw = 0, tLsw = 0;
                  for (var y2 = 0; y2 < 5; y2++) {
                    var lane = state[x + 5 * y2];
                    tMsw ^= lane.high;
                    tLsw ^= lane.low;
                  }
                  var Tx = T2[x];
                  Tx.high = tMsw;
                  Tx.low = tLsw;
                }
                for (var x = 0; x < 5; x++) {
                  var Tx4 = T2[(x + 4) % 5];
                  var Tx1 = T2[(x + 1) % 5];
                  var Tx1Msw = Tx1.high;
                  var Tx1Lsw = Tx1.low;
                  var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                  var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                  for (var y2 = 0; y2 < 5; y2++) {
                    var lane = state[x + 5 * y2];
                    lane.high ^= tMsw;
                    lane.low ^= tLsw;
                  }
                }
                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                  var tMsw;
                  var tLsw;
                  var lane = state[laneIndex];
                  var laneMsw = lane.high;
                  var laneLsw = lane.low;
                  var rhoOffset = RHO_OFFSETS[laneIndex];
                  if (rhoOffset < 32) {
                    tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                    tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                  } else {
                    tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                    tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                  }
                  var TPiLane = T2[PI_INDEXES[laneIndex]];
                  TPiLane.high = tMsw;
                  TPiLane.low = tLsw;
                }
                var T0 = T2[0];
                var state0 = state[0];
                T0.high = state0.high;
                T0.low = state0.low;
                for (var x = 0; x < 5; x++) {
                  for (var y2 = 0; y2 < 5; y2++) {
                    var laneIndex = x + 5 * y2;
                    var lane = state[laneIndex];
                    var TLane = T2[laneIndex];
                    var Tx1Lane = T2[(x + 1) % 5 + 5 * y2];
                    var Tx2Lane = T2[(x + 2) % 5 + 5 * y2];
                    lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                    lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                  }
                }
                var lane = state[0];
                var roundConstant = ROUND_CONSTANTS[round];
                lane.high ^= roundConstant.high;
                lane.low ^= roundConstant.low;
              }
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              var blockSizeBits = this.blockSize * 32;
              dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
              dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
              data.sigBytes = dataWords.length * 4;
              this._process();
              var state = this._state;
              var outputLengthBytes = this.cfg.outputLength / 8;
              var outputLengthLanes = outputLengthBytes / 8;
              var hashWords = [];
              for (var i2 = 0; i2 < outputLengthLanes; i2++) {
                var lane = state[i2];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                hashWords.push(laneLsw);
                hashWords.push(laneMsw);
              }
              return new WordArray.init(hashWords, outputLengthBytes);
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              var state = clone._state = this._state.slice(0);
              for (var i2 = 0; i2 < 25; i2++) {
                state[i2] = state[i2].clone();
              }
              return clone;
            }
          });
          C2.SHA3 = Hasher._createHelper(SHA3);
          C2.HmacSHA3 = Hasher._createHmacHelper(SHA3);
        })(Math);
        return CryptoJS2.SHA3;
      });
    })(sha3);
    return sha3.exports;
  }
  var ripemd160 = { exports: {} };
  var hasRequiredRipemd160;
  function requireRipemd160() {
    if (hasRequiredRipemd160)
      return ripemd160.exports;
    hasRequiredRipemd160 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        /** @preserve
        				(c) 2012 by Cédric Mesnil. All rights reserved.
        
        				Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
        
        				    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        				    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
        
        				THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        				*/
        (function(Math2) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C2.algo;
          var _zl = WordArray.create([
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            7,
            4,
            13,
            1,
            10,
            6,
            15,
            3,
            12,
            0,
            9,
            5,
            2,
            14,
            11,
            8,
            3,
            10,
            14,
            4,
            9,
            15,
            8,
            1,
            2,
            7,
            0,
            6,
            13,
            11,
            5,
            12,
            1,
            9,
            11,
            10,
            0,
            8,
            12,
            4,
            13,
            3,
            7,
            15,
            14,
            5,
            6,
            2,
            4,
            0,
            5,
            9,
            7,
            12,
            2,
            10,
            14,
            1,
            3,
            8,
            11,
            6,
            15,
            13
          ]);
          var _zr = WordArray.create([
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
          ]);
          var _sl = WordArray.create([
            11,
            14,
            15,
            12,
            5,
            8,
            7,
            9,
            11,
            13,
            14,
            15,
            6,
            7,
            9,
            8,
            7,
            6,
            8,
            13,
            11,
            9,
            7,
            15,
            7,
            12,
            15,
            9,
            11,
            7,
            13,
            12,
            11,
            13,
            6,
            7,
            14,
            9,
            13,
            15,
            14,
            8,
            13,
            6,
            5,
            12,
            7,
            5,
            11,
            12,
            14,
            15,
            14,
            15,
            9,
            8,
            9,
            14,
            5,
            6,
            8,
            6,
            5,
            12,
            9,
            15,
            5,
            11,
            6,
            8,
            13,
            12,
            5,
            12,
            13,
            14,
            11,
            8,
            5,
            6
          ]);
          var _sr = WordArray.create([
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
          ]);
          var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
          var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
          var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
            _doReset: function() {
              this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            },
            _doProcessBlock: function(M2, offset) {
              for (var i2 = 0; i2 < 16; i2++) {
                var offset_i = offset + i2;
                var M_offset_i = M2[offset_i];
                M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H2 = this._hash.words;
              var hl = _hl.words;
              var hr = _hr.words;
              var zl = _zl.words;
              var zr = _zr.words;
              var sl = _sl.words;
              var sr = _sr.words;
              var al, bl, cl, dl, el;
              var ar, br, cr, dr, er;
              ar = al = H2[0];
              br = bl = H2[1];
              cr = cl = H2[2];
              dr = dl = H2[3];
              er = el = H2[4];
              var t2;
              for (var i2 = 0; i2 < 80; i2 += 1) {
                t2 = al + M2[offset + zl[i2]] | 0;
                if (i2 < 16) {
                  t2 += f1(bl, cl, dl) + hl[0];
                } else if (i2 < 32) {
                  t2 += f2(bl, cl, dl) + hl[1];
                } else if (i2 < 48) {
                  t2 += f3(bl, cl, dl) + hl[2];
                } else if (i2 < 64) {
                  t2 += f4(bl, cl, dl) + hl[3];
                } else {
                  t2 += f5(bl, cl, dl) + hl[4];
                }
                t2 = t2 | 0;
                t2 = rotl(t2, sl[i2]);
                t2 = t2 + el | 0;
                al = el;
                el = dl;
                dl = rotl(cl, 10);
                cl = bl;
                bl = t2;
                t2 = ar + M2[offset + zr[i2]] | 0;
                if (i2 < 16) {
                  t2 += f5(br, cr, dr) + hr[0];
                } else if (i2 < 32) {
                  t2 += f4(br, cr, dr) + hr[1];
                } else if (i2 < 48) {
                  t2 += f3(br, cr, dr) + hr[2];
                } else if (i2 < 64) {
                  t2 += f2(br, cr, dr) + hr[3];
                } else {
                  t2 += f1(br, cr, dr) + hr[4];
                }
                t2 = t2 | 0;
                t2 = rotl(t2, sr[i2]);
                t2 = t2 + er | 0;
                ar = er;
                er = dr;
                dr = rotl(cr, 10);
                cr = br;
                br = t2;
              }
              t2 = H2[1] + cl + dr | 0;
              H2[1] = H2[2] + dl + er | 0;
              H2[2] = H2[3] + el + ar | 0;
              H2[3] = H2[4] + al + br | 0;
              H2[4] = H2[0] + bl + cr | 0;
              H2[0] = t2;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash = this._hash;
              var H2 = hash.words;
              for (var i2 = 0; i2 < 5; i2++) {
                var H_i = H2[i2];
                H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function f1(x, y2, z2) {
            return x ^ y2 ^ z2;
          }
          function f2(x, y2, z2) {
            return x & y2 | ~x & z2;
          }
          function f3(x, y2, z2) {
            return (x | ~y2) ^ z2;
          }
          function f4(x, y2, z2) {
            return x & z2 | y2 & ~z2;
          }
          function f5(x, y2, z2) {
            return x ^ (y2 | ~z2);
          }
          function rotl(x, n2) {
            return x << n2 | x >>> 32 - n2;
          }
          C2.RIPEMD160 = Hasher._createHelper(RIPEMD160);
          C2.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
        })();
        return CryptoJS2.RIPEMD160;
      });
    })(ripemd160);
    return ripemd160.exports;
  }
  var hmac = { exports: {} };
  var hasRequiredHmac;
  function requireHmac() {
    if (hasRequiredHmac)
      return hmac.exports;
    hasRequiredHmac = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var C_enc = C2.enc;
          var Utf8 = C_enc.Utf8;
          var C_algo = C2.algo;
          C_algo.HMAC = Base.extend({
            /**
             * Initializes a newly created HMAC.
             *
             * @param {Hasher} hasher The hash algorithm to use.
             * @param {WordArray|string} key The secret key.
             *
             * @example
             *
             *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
             */
            init: function(hasher, key) {
              hasher = this._hasher = new hasher.init();
              if (typeof key == "string") {
                key = Utf8.parse(key);
              }
              var hasherBlockSize = hasher.blockSize;
              var hasherBlockSizeBytes = hasherBlockSize * 4;
              if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
              }
              key.clamp();
              var oKey = this._oKey = key.clone();
              var iKey = this._iKey = key.clone();
              var oKeyWords = oKey.words;
              var iKeyWords = iKey.words;
              for (var i2 = 0; i2 < hasherBlockSize; i2++) {
                oKeyWords[i2] ^= 1549556828;
                iKeyWords[i2] ^= 909522486;
              }
              oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
              this.reset();
            },
            /**
             * Resets this HMAC to its initial state.
             *
             * @example
             *
             *     hmacHasher.reset();
             */
            reset: function() {
              var hasher = this._hasher;
              hasher.reset();
              hasher.update(this._iKey);
            },
            /**
             * Updates this HMAC with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {HMAC} This HMAC instance.
             *
             * @example
             *
             *     hmacHasher.update('message');
             *     hmacHasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._hasher.update(messageUpdate);
              return this;
            },
            /**
             * Finalizes the HMAC computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The HMAC.
             *
             * @example
             *
             *     var hmac = hmacHasher.finalize();
             *     var hmac = hmacHasher.finalize('message');
             *     var hmac = hmacHasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              var hasher = this._hasher;
              var innerHash = hasher.finalize(messageUpdate);
              hasher.reset();
              var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
              return hmac2;
            }
          });
        })();
      });
    })(hmac);
    return hmac.exports;
  }
  var pbkdf2 = { exports: {} };
  var hasRequiredPbkdf2;
  function requirePbkdf2() {
    if (hasRequiredPbkdf2)
      return pbkdf2.exports;
    hasRequiredPbkdf2 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireSha256(), requireHmac());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C2.algo;
          var SHA256 = C_algo.SHA256;
          var HMAC = C_algo.HMAC;
          var PBKDF2 = C_algo.PBKDF2 = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hasher to use. Default: SHA256
             * @property {number} iterations The number of iterations to perform. Default: 250000
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: SHA256,
              iterations: 25e4
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.PBKDF2.create();
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt) {
              var cfg = this.cfg;
              var hmac2 = HMAC.create(cfg.hasher, password);
              var derivedKey = WordArray.create();
              var blockIndex = WordArray.create([1]);
              var derivedKeyWords = derivedKey.words;
              var blockIndexWords = blockIndex.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                var block = hmac2.update(salt).finalize(blockIndex);
                hmac2.reset();
                var blockWords = block.words;
                var blockWordsLength = blockWords.length;
                var intermediate = block;
                for (var i2 = 1; i2 < iterations; i2++) {
                  intermediate = hmac2.finalize(intermediate);
                  hmac2.reset();
                  var intermediateWords = intermediate.words;
                  for (var j2 = 0; j2 < blockWordsLength; j2++) {
                    blockWords[j2] ^= intermediateWords[j2];
                  }
                }
                derivedKey.concat(block);
                blockIndexWords[0]++;
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C2.PBKDF2 = function(password, salt, cfg) {
            return PBKDF2.create(cfg).compute(password, salt);
          };
        })();
        return CryptoJS2.PBKDF2;
      });
    })(pbkdf2);
    return pbkdf2.exports;
  }
  var evpkdf = { exports: {} };
  var hasRequiredEvpkdf;
  function requireEvpkdf() {
    if (hasRequiredEvpkdf)
      return evpkdf.exports;
    hasRequiredEvpkdf = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireSha1(), requireHmac());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C2.algo;
          var MD5 = C_algo.MD5;
          var EvpKDF = C_algo.EvpKDF = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hash algorithm to use. Default: MD5
             * @property {number} iterations The number of iterations to perform. Default: 1
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: MD5,
              iterations: 1
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.EvpKDF.create();
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Derives a key from a password.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt) {
              var block;
              var cfg = this.cfg;
              var hasher = cfg.hasher.create();
              var derivedKey = WordArray.create();
              var derivedKeyWords = derivedKey.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                if (block) {
                  hasher.update(block);
                }
                block = hasher.update(password).finalize(salt);
                hasher.reset();
                for (var i2 = 1; i2 < iterations; i2++) {
                  block = hasher.finalize(block);
                  hasher.reset();
                }
                derivedKey.concat(block);
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C2.EvpKDF = function(password, salt, cfg) {
            return EvpKDF.create(cfg).compute(password, salt);
          };
        })();
        return CryptoJS2.EvpKDF;
      });
    })(evpkdf);
    return evpkdf.exports;
  }
  var cipherCore = { exports: {} };
  var hasRequiredCipherCore;
  function requireCipherCore() {
    if (hasRequiredCipherCore)
      return cipherCore.exports;
    hasRequiredCipherCore = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEvpkdf());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.lib.Cipher || function(undefined$1) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
          var C_enc = C2.enc;
          C_enc.Utf8;
          var Base64 = C_enc.Base64;
          var C_algo = C2.algo;
          var EvpKDF = C_algo.EvpKDF;
          var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             *
             * @property {WordArray} iv The IV to use for this operation.
             */
            cfg: Base.extend(),
            /**
             * Creates this cipher in encryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
             */
            createEncryptor: function(key, cfg) {
              return this.create(this._ENC_XFORM_MODE, key, cfg);
            },
            /**
             * Creates this cipher in decryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
             */
            createDecryptor: function(key, cfg) {
              return this.create(this._DEC_XFORM_MODE, key, cfg);
            },
            /**
             * Initializes a newly created cipher.
             *
             * @param {number} xformMode Either the encryption or decryption transormation mode constant.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
             */
            init: function(xformMode, key, cfg) {
              this.cfg = this.cfg.extend(cfg);
              this._xformMode = xformMode;
              this._key = key;
              this.reset();
            },
            /**
             * Resets this cipher to its initial state.
             *
             * @example
             *
             *     cipher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Adds data to be encrypted or decrypted.
             *
             * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
             *
             * @return {WordArray} The data after processing.
             *
             * @example
             *
             *     var encrypted = cipher.process('data');
             *     var encrypted = cipher.process(wordArray);
             */
            process: function(dataUpdate) {
              this._append(dataUpdate);
              return this._process();
            },
            /**
             * Finalizes the encryption or decryption process.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
             *
             * @return {WordArray} The data after final processing.
             *
             * @example
             *
             *     var encrypted = cipher.finalize();
             *     var encrypted = cipher.finalize('data');
             *     var encrypted = cipher.finalize(wordArray);
             */
            finalize: function(dataUpdate) {
              if (dataUpdate) {
                this._append(dataUpdate);
              }
              var finalProcessedData = this._doFinalize();
              return finalProcessedData;
            },
            keySize: 128 / 32,
            ivSize: 128 / 32,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            /**
             * Creates shortcut functions to a cipher's object interface.
             *
             * @param {Cipher} cipher The cipher to create a helper for.
             *
             * @return {Object} An object with encrypt and decrypt shortcut functions.
             *
             * @static
             *
             * @example
             *
             *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
             */
            _createHelper: /* @__PURE__ */ function() {
              function selectCipherStrategy(key) {
                if (typeof key == "string") {
                  return PasswordBasedCipher;
                } else {
                  return SerializableCipher;
                }
              }
              return function(cipher) {
                return {
                  encrypt: function(message, key, cfg) {
                    return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                  },
                  decrypt: function(ciphertext, key, cfg) {
                    return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                  }
                };
              };
            }()
          });
          C_lib.StreamCipher = Cipher.extend({
            _doFinalize: function() {
              var finalProcessedBlocks = this._process(true);
              return finalProcessedBlocks;
            },
            blockSize: 1
          });
          var C_mode = C2.mode = {};
          var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
            /**
             * Creates this mode for encryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
             */
            createEncryptor: function(cipher, iv) {
              return this.Encryptor.create(cipher, iv);
            },
            /**
             * Creates this mode for decryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
             */
            createDecryptor: function(cipher, iv) {
              return this.Decryptor.create(cipher, iv);
            },
            /**
             * Initializes a newly created mode.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
             */
            init: function(cipher, iv) {
              this._cipher = cipher;
              this._iv = iv;
            }
          });
          var CBC = C_mode.CBC = function() {
            var CBC2 = BlockCipherMode.extend();
            CBC2.Encryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);
                this._prevBlock = words.slice(offset, offset + blockSize);
              }
            });
            CBC2.Decryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var thisBlock = words.slice(offset, offset + blockSize);
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);
                this._prevBlock = thisBlock;
              }
            });
            function xorBlock(words, offset, blockSize) {
              var block;
              var iv = this._iv;
              if (iv) {
                block = iv;
                this._iv = undefined$1;
              } else {
                block = this._prevBlock;
              }
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= block[i2];
              }
            }
            return CBC2;
          }();
          var C_pad = C2.pad = {};
          var Pkcs7 = C_pad.Pkcs7 = {
            /**
             * Pads data using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to pad.
             * @param {number} blockSize The multiple that the data should be padded to.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
             */
            pad: function(data, blockSize) {
              var blockSizeBytes = blockSize * 4;
              var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
              var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
              var paddingWords = [];
              for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
                paddingWords.push(paddingWord);
              }
              var padding = WordArray.create(paddingWords, nPaddingBytes);
              data.concat(padding);
            },
            /**
             * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to unpad.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.unpad(wordArray);
             */
            unpad: function(data) {
              var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
              data.sigBytes -= nPaddingBytes;
            }
          };
          C_lib.BlockCipher = Cipher.extend({
            /**
             * Configuration options.
             *
             * @property {Mode} mode The block mode to use. Default: CBC
             * @property {Padding} padding The padding strategy to use. Default: Pkcs7
             */
            cfg: Cipher.cfg.extend({
              mode: CBC,
              padding: Pkcs7
            }),
            reset: function() {
              var modeCreator;
              Cipher.reset.call(this);
              var cfg = this.cfg;
              var iv = cfg.iv;
              var mode = cfg.mode;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                modeCreator = mode.createEncryptor;
              } else {
                modeCreator = mode.createDecryptor;
                this._minBufferSize = 1;
              }
              if (this._mode && this._mode.__creator == modeCreator) {
                this._mode.init(this, iv && iv.words);
              } else {
                this._mode = modeCreator.call(mode, this, iv && iv.words);
                this._mode.__creator = modeCreator;
              }
            },
            _doProcessBlock: function(words, offset) {
              this._mode.processBlock(words, offset);
            },
            _doFinalize: function() {
              var finalProcessedBlocks;
              var padding = this.cfg.padding;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                padding.pad(this._data, this.blockSize);
                finalProcessedBlocks = this._process(true);
              } else {
                finalProcessedBlocks = this._process(true);
                padding.unpad(finalProcessedBlocks);
              }
              return finalProcessedBlocks;
            },
            blockSize: 128 / 32
          });
          var CipherParams = C_lib.CipherParams = Base.extend({
            /**
             * Initializes a newly created cipher params object.
             *
             * @param {Object} cipherParams An object with any of the possible cipher parameters.
             *
             * @example
             *
             *     var cipherParams = CryptoJS.lib.CipherParams.create({
             *         ciphertext: ciphertextWordArray,
             *         key: keyWordArray,
             *         iv: ivWordArray,
             *         salt: saltWordArray,
             *         algorithm: CryptoJS.algo.AES,
             *         mode: CryptoJS.mode.CBC,
             *         padding: CryptoJS.pad.PKCS7,
             *         blockSize: 4,
             *         formatter: CryptoJS.format.OpenSSL
             *     });
             */
            init: function(cipherParams) {
              this.mixIn(cipherParams);
            },
            /**
             * Converts this cipher params object to a string.
             *
             * @param {Format} formatter (Optional) The formatting strategy to use.
             *
             * @return {string} The stringified cipher params.
             *
             * @throws Error If neither the formatter nor the default formatter is set.
             *
             * @example
             *
             *     var string = cipherParams + '';
             *     var string = cipherParams.toString();
             *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
             */
            toString: function(formatter) {
              return (formatter || this.formatter).stringify(this);
            }
          });
          var C_format = C2.format = {};
          var OpenSSLFormatter = C_format.OpenSSL = {
            /**
             * Converts a cipher params object to an OpenSSL-compatible string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The OpenSSL-compatible string.
             *
             * @static
             *
             * @example
             *
             *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              var wordArray;
              var ciphertext = cipherParams.ciphertext;
              var salt = cipherParams.salt;
              if (salt) {
                wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
              } else {
                wordArray = ciphertext;
              }
              return wordArray.toString(Base64);
            },
            /**
             * Converts an OpenSSL-compatible string to a cipher params object.
             *
             * @param {string} openSSLStr The OpenSSL-compatible string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
             */
            parse: function(openSSLStr) {
              var salt;
              var ciphertext = Base64.parse(openSSLStr);
              var ciphertextWords = ciphertext.words;
              if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                salt = WordArray.create(ciphertextWords.slice(2, 4));
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
              }
              return CipherParams.create({ ciphertext, salt });
            }
          };
          var SerializableCipher = C_lib.SerializableCipher = Base.extend({
            /**
             * Configuration options.
             *
             * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
             */
            cfg: Base.extend({
              format: OpenSSLFormatter
            }),
            /**
             * Encrypts a message.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, key, cfg) {
              cfg = this.cfg.extend(cfg);
              var encryptor = cipher.createEncryptor(key, cfg);
              var ciphertext = encryptor.finalize(message);
              var cipherCfg = encryptor.cfg;
              return CipherParams.create({
                ciphertext,
                key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
              });
            },
            /**
             * Decrypts serialized ciphertext.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, key, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
              return plaintext;
            },
            /**
             * Converts serialized ciphertext to CipherParams,
             * else assumed CipherParams already and returns ciphertext unchanged.
             *
             * @param {CipherParams|string} ciphertext The ciphertext.
             * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
             *
             * @return {CipherParams} The unserialized ciphertext.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
             */
            _parse: function(ciphertext, format) {
              if (typeof ciphertext == "string") {
                return format.parse(ciphertext, this);
              } else {
                return ciphertext;
              }
            }
          });
          var C_kdf = C2.kdf = {};
          var OpenSSLKdf = C_kdf.OpenSSL = {
            /**
             * Derives a key and IV from a password.
             *
             * @param {string} password The password to derive from.
             * @param {number} keySize The size in words of the key to generate.
             * @param {number} ivSize The size in words of the IV to generate.
             * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
             *
             * @return {CipherParams} A cipher params object with the key, IV, and salt.
             *
             * @static
             *
             * @example
             *
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
             */
            execute: function(password, keySize, ivSize, salt, hasher) {
              if (!salt) {
                salt = WordArray.random(64 / 8);
              }
              if (!hasher) {
                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
              } else {
                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
              }
              var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
              key.sigBytes = keySize * 4;
              return CipherParams.create({ key, iv, salt });
            }
          };
          var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
            /**
             * Configuration options.
             *
             * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
             */
            cfg: SerializableCipher.cfg.extend({
              kdf: OpenSSLKdf
            }),
            /**
             * Encrypts a message using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, password, cfg) {
              cfg = this.cfg.extend(cfg);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
              cfg.iv = derivedParams.iv;
              var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
              ciphertext.mixIn(derivedParams);
              return ciphertext;
            },
            /**
             * Decrypts serialized ciphertext using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, password, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
              cfg.iv = derivedParams.iv;
              var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
              return plaintext;
            }
          });
        }();
      });
    })(cipherCore);
    return cipherCore.exports;
  }
  var modeCfb = { exports: {} };
  var hasRequiredModeCfb;
  function requireModeCfb() {
    if (hasRequiredModeCfb)
      return modeCfb.exports;
    hasRequiredModeCfb = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.mode.CFB = function() {
          var CFB = CryptoJS2.lib.BlockCipherMode.extend();
          CFB.Encryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CFB.Decryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = thisBlock;
            }
          });
          function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
            var keystream;
            var iv = this._iv;
            if (iv) {
              keystream = iv.slice(0);
              this._iv = void 0;
            } else {
              keystream = this._prevBlock;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
          return CFB;
        }();
        return CryptoJS2.mode.CFB;
      });
    })(modeCfb);
    return modeCfb.exports;
  }
  var modeCtr = { exports: {} };
  var hasRequiredModeCtr;
  function requireModeCtr() {
    if (hasRequiredModeCtr)
      return modeCtr.exports;
    hasRequiredModeCtr = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.mode.CTR = function() {
          var CTR = CryptoJS2.lib.BlockCipherMode.extend();
          var Encryptor = CTR.Encryptor = CTR.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          CTR.Decryptor = Encryptor;
          return CTR;
        }();
        return CryptoJS2.mode.CTR;
      });
    })(modeCtr);
    return modeCtr.exports;
  }
  var modeCtrGladman = { exports: {} };
  var hasRequiredModeCtrGladman;
  function requireModeCtrGladman() {
    if (hasRequiredModeCtrGladman)
      return modeCtrGladman.exports;
    hasRequiredModeCtrGladman = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        /** @preserve
         * Counter block mode compatible with  Dr Brian Gladman fileenc.c
         * derived from CryptoJS.mode.CTR
         * Jan Hruby jhruby.web@gmail.com
         */
        CryptoJS2.mode.CTRGladman = function() {
          var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
          function incWord(word) {
            if ((word >> 24 & 255) === 255) {
              var b1 = word >> 16 & 255;
              var b2 = word >> 8 & 255;
              var b3 = word & 255;
              if (b1 === 255) {
                b1 = 0;
                if (b2 === 255) {
                  b2 = 0;
                  if (b3 === 255) {
                    b3 = 0;
                  } else {
                    ++b3;
                  }
                } else {
                  ++b2;
                }
              } else {
                ++b1;
              }
              word = 0;
              word += b1 << 16;
              word += b2 << 8;
              word += b3;
            } else {
              word += 1 << 24;
            }
            return word;
          }
          function incCounter(counter) {
            if ((counter[0] = incWord(counter[0])) === 0) {
              counter[1] = incWord(counter[1]);
            }
            return counter;
          }
          var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              incCounter(counter);
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          CTRGladman.Decryptor = Encryptor;
          return CTRGladman;
        }();
        return CryptoJS2.mode.CTRGladman;
      });
    })(modeCtrGladman);
    return modeCtrGladman.exports;
  }
  var modeOfb = { exports: {} };
  var hasRequiredModeOfb;
  function requireModeOfb() {
    if (hasRequiredModeOfb)
      return modeOfb.exports;
    hasRequiredModeOfb = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.mode.OFB = function() {
          var OFB = CryptoJS2.lib.BlockCipherMode.extend();
          var Encryptor = OFB.Encryptor = OFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var keystream = this._keystream;
              if (iv) {
                keystream = this._keystream = iv.slice(0);
                this._iv = void 0;
              }
              cipher.encryptBlock(keystream, 0);
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          OFB.Decryptor = Encryptor;
          return OFB;
        }();
        return CryptoJS2.mode.OFB;
      });
    })(modeOfb);
    return modeOfb.exports;
  }
  var modeEcb = { exports: {} };
  var hasRequiredModeEcb;
  function requireModeEcb() {
    if (hasRequiredModeEcb)
      return modeEcb.exports;
    hasRequiredModeEcb = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.mode.ECB = function() {
          var ECB = CryptoJS2.lib.BlockCipherMode.extend();
          ECB.Encryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.encryptBlock(words, offset);
            }
          });
          ECB.Decryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.decryptBlock(words, offset);
            }
          });
          return ECB;
        }();
        return CryptoJS2.mode.ECB;
      });
    })(modeEcb);
    return modeEcb.exports;
  }
  var padAnsix923 = { exports: {} };
  var hasRequiredPadAnsix923;
  function requirePadAnsix923() {
    if (hasRequiredPadAnsix923)
      return padAnsix923.exports;
    hasRequiredPadAnsix923 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.AnsiX923 = {
          pad: function(data, blockSize) {
            var dataSigBytes = data.sigBytes;
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
            var lastBytePos = dataSigBytes + nPaddingBytes - 1;
            data.clamp();
            data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
            data.sigBytes += nPaddingBytes;
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS2.pad.Ansix923;
      });
    })(padAnsix923);
    return padAnsix923.exports;
  }
  var padIso10126 = { exports: {} };
  var hasRequiredPadIso10126;
  function requirePadIso10126() {
    if (hasRequiredPadIso10126)
      return padIso10126.exports;
    hasRequiredPadIso10126 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.Iso10126 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            data.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS2.pad.Iso10126;
      });
    })(padIso10126);
    return padIso10126.exports;
  }
  var padIso97971 = { exports: {} };
  var hasRequiredPadIso97971;
  function requirePadIso97971() {
    if (hasRequiredPadIso97971)
      return padIso97971.exports;
    hasRequiredPadIso97971 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.Iso97971 = {
          pad: function(data, blockSize) {
            data.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
            CryptoJS2.pad.ZeroPadding.pad(data, blockSize);
          },
          unpad: function(data) {
            CryptoJS2.pad.ZeroPadding.unpad(data);
            data.sigBytes--;
          }
        };
        return CryptoJS2.pad.Iso97971;
      });
    })(padIso97971);
    return padIso97971.exports;
  }
  var padZeropadding = { exports: {} };
  var hasRequiredPadZeropadding;
  function requirePadZeropadding() {
    if (hasRequiredPadZeropadding)
      return padZeropadding.exports;
    hasRequiredPadZeropadding = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.ZeroPadding = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            data.clamp();
            data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
          },
          unpad: function(data) {
            var dataWords = data.words;
            var i2 = data.sigBytes - 1;
            for (var i2 = data.sigBytes - 1; i2 >= 0; i2--) {
              if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
                data.sigBytes = i2 + 1;
                break;
              }
            }
          }
        };
        return CryptoJS2.pad.ZeroPadding;
      });
    })(padZeropadding);
    return padZeropadding.exports;
  }
  var padNopadding = { exports: {} };
  var hasRequiredPadNopadding;
  function requirePadNopadding() {
    if (hasRequiredPadNopadding)
      return padNopadding.exports;
    hasRequiredPadNopadding = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.NoPadding = {
          pad: function() {
          },
          unpad: function() {
          }
        };
        return CryptoJS2.pad.NoPadding;
      });
    })(padNopadding);
    return padNopadding.exports;
  }
  var formatHex = { exports: {} };
  var hasRequiredFormatHex;
  function requireFormatHex() {
    if (hasRequiredFormatHex)
      return formatHex.exports;
    hasRequiredFormatHex = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(undefined$1) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var CipherParams = C_lib.CipherParams;
          var C_enc = C2.enc;
          var Hex = C_enc.Hex;
          var C_format = C2.format;
          C_format.Hex = {
            /**
             * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The hexadecimally encoded string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              return cipherParams.ciphertext.toString(Hex);
            },
            /**
             * Converts a hexadecimally encoded ciphertext string to a cipher params object.
             *
             * @param {string} input The hexadecimally encoded string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
             */
            parse: function(input) {
              var ciphertext = Hex.parse(input);
              return CipherParams.create({ ciphertext });
            }
          };
        })();
        return CryptoJS2.format.Hex;
      });
    })(formatHex);
    return formatHex.exports;
  }
  var aes = { exports: {} };
  var hasRequiredAes;
  function requireAes() {
    if (hasRequiredAes)
      return aes.exports;
    hasRequiredAes = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C2.algo;
          var SBOX = [];
          var INV_SBOX = [];
          var SUB_MIX_0 = [];
          var SUB_MIX_1 = [];
          var SUB_MIX_2 = [];
          var SUB_MIX_3 = [];
          var INV_SUB_MIX_0 = [];
          var INV_SUB_MIX_1 = [];
          var INV_SUB_MIX_2 = [];
          var INV_SUB_MIX_3 = [];
          (function() {
            var d2 = [];
            for (var i2 = 0; i2 < 256; i2++) {
              if (i2 < 128) {
                d2[i2] = i2 << 1;
              } else {
                d2[i2] = i2 << 1 ^ 283;
              }
            }
            var x = 0;
            var xi = 0;
            for (var i2 = 0; i2 < 256; i2++) {
              var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
              sx = sx >>> 8 ^ sx & 255 ^ 99;
              SBOX[x] = sx;
              INV_SBOX[sx] = x;
              var x2 = d2[x];
              var x4 = d2[x2];
              var x8 = d2[x4];
              var t2 = d2[sx] * 257 ^ sx * 16843008;
              SUB_MIX_0[x] = t2 << 24 | t2 >>> 8;
              SUB_MIX_1[x] = t2 << 16 | t2 >>> 16;
              SUB_MIX_2[x] = t2 << 8 | t2 >>> 24;
              SUB_MIX_3[x] = t2;
              var t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
              INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
              INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
              INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
              INV_SUB_MIX_3[sx] = t2;
              if (!x) {
                x = xi = 1;
              } else {
                x = x2 ^ d2[d2[d2[x8 ^ x2]]];
                xi ^= d2[d2[xi]];
              }
            }
          })();
          var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var AES = C_algo.AES = BlockCipher.extend({
            _doReset: function() {
              var t2;
              if (this._nRounds && this._keyPriorReset === this._key) {
                return;
              }
              var key = this._keyPriorReset = this._key;
              var keyWords = key.words;
              var keySize = key.sigBytes / 4;
              var nRounds = this._nRounds = keySize + 6;
              var ksRows = (nRounds + 1) * 4;
              var keySchedule = this._keySchedule = [];
              for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                  keySchedule[ksRow] = keyWords[ksRow];
                } else {
                  t2 = keySchedule[ksRow - 1];
                  if (!(ksRow % keySize)) {
                    t2 = t2 << 8 | t2 >>> 24;
                    t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                    t2 ^= RCON[ksRow / keySize | 0] << 24;
                  } else if (keySize > 6 && ksRow % keySize == 4) {
                    t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  }
                  keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
                }
              }
              var invKeySchedule = this._invKeySchedule = [];
              for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;
                if (invKsRow % 4) {
                  var t2 = keySchedule[ksRow];
                } else {
                  var t2 = keySchedule[ksRow - 4];
                }
                if (invKsRow < 4 || ksRow <= 4) {
                  invKeySchedule[invKsRow] = t2;
                } else {
                  invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
                }
              }
            },
            encryptBlock: function(M2, offset) {
              this._doCryptBlock(M2, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
            },
            decryptBlock: function(M2, offset) {
              var t2 = M2[offset + 1];
              M2[offset + 1] = M2[offset + 3];
              M2[offset + 3] = t2;
              this._doCryptBlock(M2, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
              var t2 = M2[offset + 1];
              M2[offset + 1] = M2[offset + 3];
              M2[offset + 3] = t2;
            },
            _doCryptBlock: function(M2, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
              var nRounds = this._nRounds;
              var s0 = M2[offset] ^ keySchedule[0];
              var s1 = M2[offset + 1] ^ keySchedule[1];
              var s2 = M2[offset + 2] ^ keySchedule[2];
              var s3 = M2[offset + 3] ^ keySchedule[3];
              var ksRow = 4;
              for (var round = 1; round < nRounds; round++) {
                var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
              }
              var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
              var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
              var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
              var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
              M2[offset] = t0;
              M2[offset + 1] = t1;
              M2[offset + 2] = t2;
              M2[offset + 3] = t3;
            },
            keySize: 256 / 32
          });
          C2.AES = BlockCipher._createHelper(AES);
        })();
        return CryptoJS2.AES;
      });
    })(aes);
    return aes.exports;
  }
  var tripledes = { exports: {} };
  var hasRequiredTripledes;
  function requireTripledes() {
    if (hasRequiredTripledes)
      return tripledes.exports;
    hasRequiredTripledes = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C2.algo;
          var PC1 = [
            57,
            49,
            41,
            33,
            25,
            17,
            9,
            1,
            58,
            50,
            42,
            34,
            26,
            18,
            10,
            2,
            59,
            51,
            43,
            35,
            27,
            19,
            11,
            3,
            60,
            52,
            44,
            36,
            63,
            55,
            47,
            39,
            31,
            23,
            15,
            7,
            62,
            54,
            46,
            38,
            30,
            22,
            14,
            6,
            61,
            53,
            45,
            37,
            29,
            21,
            13,
            5,
            28,
            20,
            12,
            4
          ];
          var PC2 = [
            14,
            17,
            11,
            24,
            1,
            5,
            3,
            28,
            15,
            6,
            21,
            10,
            23,
            19,
            12,
            4,
            26,
            8,
            16,
            7,
            27,
            20,
            13,
            2,
            41,
            52,
            31,
            37,
            47,
            55,
            30,
            40,
            51,
            45,
            33,
            48,
            44,
            49,
            39,
            56,
            34,
            53,
            46,
            42,
            50,
            36,
            29,
            32
          ];
          var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
          var SBOX_P = [
            {
              0: 8421888,
              268435456: 32768,
              536870912: 8421378,
              805306368: 2,
              1073741824: 512,
              1342177280: 8421890,
              1610612736: 8389122,
              1879048192: 8388608,
              2147483648: 514,
              2415919104: 8389120,
              2684354560: 33280,
              2952790016: 8421376,
              3221225472: 32770,
              3489660928: 8388610,
              3758096384: 0,
              4026531840: 33282,
              134217728: 0,
              402653184: 8421890,
              671088640: 33282,
              939524096: 32768,
              1207959552: 8421888,
              1476395008: 512,
              1744830464: 8421378,
              2013265920: 2,
              2281701376: 8389120,
              2550136832: 33280,
              2818572288: 8421376,
              3087007744: 8389122,
              3355443200: 8388610,
              3623878656: 32770,
              3892314112: 514,
              4160749568: 8388608,
              1: 32768,
              268435457: 2,
              536870913: 8421888,
              805306369: 8388608,
              1073741825: 8421378,
              1342177281: 33280,
              1610612737: 512,
              1879048193: 8389122,
              2147483649: 8421890,
              2415919105: 8421376,
              2684354561: 8388610,
              2952790017: 33282,
              3221225473: 514,
              3489660929: 8389120,
              3758096385: 32770,
              4026531841: 0,
              134217729: 8421890,
              402653185: 8421376,
              671088641: 8388608,
              939524097: 512,
              1207959553: 32768,
              1476395009: 8388610,
              1744830465: 2,
              2013265921: 33282,
              2281701377: 32770,
              2550136833: 8389122,
              2818572289: 514,
              3087007745: 8421888,
              3355443201: 8389120,
              3623878657: 0,
              3892314113: 33280,
              4160749569: 8421378
            },
            {
              0: 1074282512,
              16777216: 16384,
              33554432: 524288,
              50331648: 1074266128,
              67108864: 1073741840,
              83886080: 1074282496,
              100663296: 1073758208,
              117440512: 16,
              134217728: 540672,
              150994944: 1073758224,
              167772160: 1073741824,
              184549376: 540688,
              201326592: 524304,
              218103808: 0,
              234881024: 16400,
              251658240: 1074266112,
              8388608: 1073758208,
              25165824: 540688,
              41943040: 16,
              58720256: 1073758224,
              75497472: 1074282512,
              92274688: 1073741824,
              109051904: 524288,
              125829120: 1074266128,
              142606336: 524304,
              159383552: 0,
              176160768: 16384,
              192937984: 1074266112,
              209715200: 1073741840,
              226492416: 540672,
              243269632: 1074282496,
              260046848: 16400,
              268435456: 0,
              285212672: 1074266128,
              301989888: 1073758224,
              318767104: 1074282496,
              335544320: 1074266112,
              352321536: 16,
              369098752: 540688,
              385875968: 16384,
              402653184: 16400,
              419430400: 524288,
              436207616: 524304,
              452984832: 1073741840,
              469762048: 540672,
              486539264: 1073758208,
              503316480: 1073741824,
              520093696: 1074282512,
              276824064: 540688,
              293601280: 524288,
              310378496: 1074266112,
              327155712: 16384,
              343932928: 1073758208,
              360710144: 1074282512,
              377487360: 16,
              394264576: 1073741824,
              411041792: 1074282496,
              427819008: 1073741840,
              444596224: 1073758224,
              461373440: 524304,
              478150656: 0,
              494927872: 16400,
              511705088: 1074266128,
              528482304: 540672
            },
            {
              0: 260,
              1048576: 0,
              2097152: 67109120,
              3145728: 65796,
              4194304: 65540,
              5242880: 67108868,
              6291456: 67174660,
              7340032: 67174400,
              8388608: 67108864,
              9437184: 67174656,
              10485760: 65792,
              11534336: 67174404,
              12582912: 67109124,
              13631488: 65536,
              14680064: 4,
              15728640: 256,
              524288: 67174656,
              1572864: 67174404,
              2621440: 0,
              3670016: 67109120,
              4718592: 67108868,
              5767168: 65536,
              6815744: 65540,
              7864320: 260,
              8912896: 4,
              9961472: 256,
              11010048: 67174400,
              12058624: 65796,
              13107200: 65792,
              14155776: 67109124,
              15204352: 67174660,
              16252928: 67108864,
              16777216: 67174656,
              17825792: 65540,
              18874368: 65536,
              19922944: 67109120,
              20971520: 256,
              22020096: 67174660,
              23068672: 67108868,
              24117248: 0,
              25165824: 67109124,
              26214400: 67108864,
              27262976: 4,
              28311552: 65792,
              29360128: 67174400,
              30408704: 260,
              31457280: 65796,
              32505856: 67174404,
              17301504: 67108864,
              18350080: 260,
              19398656: 67174656,
              20447232: 0,
              21495808: 65540,
              22544384: 67109120,
              23592960: 256,
              24641536: 67174404,
              25690112: 65536,
              26738688: 67174660,
              27787264: 65796,
              28835840: 67108868,
              29884416: 67109124,
              30932992: 67174400,
              31981568: 4,
              33030144: 65792
            },
            {
              0: 2151682048,
              65536: 2147487808,
              131072: 4198464,
              196608: 2151677952,
              262144: 0,
              327680: 4198400,
              393216: 2147483712,
              458752: 4194368,
              524288: 2147483648,
              589824: 4194304,
              655360: 64,
              720896: 2147487744,
              786432: 2151678016,
              851968: 4160,
              917504: 4096,
              983040: 2151682112,
              32768: 2147487808,
              98304: 64,
              163840: 2151678016,
              229376: 2147487744,
              294912: 4198400,
              360448: 2151682112,
              425984: 0,
              491520: 2151677952,
              557056: 4096,
              622592: 2151682048,
              688128: 4194304,
              753664: 4160,
              819200: 2147483648,
              884736: 4194368,
              950272: 4198464,
              1015808: 2147483712,
              1048576: 4194368,
              1114112: 4198400,
              1179648: 2147483712,
              1245184: 0,
              1310720: 4160,
              1376256: 2151678016,
              1441792: 2151682048,
              1507328: 2147487808,
              1572864: 2151682112,
              1638400: 2147483648,
              1703936: 2151677952,
              1769472: 4198464,
              1835008: 2147487744,
              1900544: 4194304,
              1966080: 64,
              2031616: 4096,
              1081344: 2151677952,
              1146880: 2151682112,
              1212416: 0,
              1277952: 4198400,
              1343488: 4194368,
              1409024: 2147483648,
              1474560: 2147487808,
              1540096: 64,
              1605632: 2147483712,
              1671168: 4096,
              1736704: 2147487744,
              1802240: 2151678016,
              1867776: 4160,
              1933312: 2151682048,
              1998848: 4194304,
              2064384: 4198464
            },
            {
              0: 128,
              4096: 17039360,
              8192: 262144,
              12288: 536870912,
              16384: 537133184,
              20480: 16777344,
              24576: 553648256,
              28672: 262272,
              32768: 16777216,
              36864: 537133056,
              40960: 536871040,
              45056: 553910400,
              49152: 553910272,
              53248: 0,
              57344: 17039488,
              61440: 553648128,
              2048: 17039488,
              6144: 553648256,
              10240: 128,
              14336: 17039360,
              18432: 262144,
              22528: 537133184,
              26624: 553910272,
              30720: 536870912,
              34816: 537133056,
              38912: 0,
              43008: 553910400,
              47104: 16777344,
              51200: 536871040,
              55296: 553648128,
              59392: 16777216,
              63488: 262272,
              65536: 262144,
              69632: 128,
              73728: 536870912,
              77824: 553648256,
              81920: 16777344,
              86016: 553910272,
              90112: 537133184,
              94208: 16777216,
              98304: 553910400,
              102400: 553648128,
              106496: 17039360,
              110592: 537133056,
              114688: 262272,
              118784: 536871040,
              122880: 0,
              126976: 17039488,
              67584: 553648256,
              71680: 16777216,
              75776: 17039360,
              79872: 537133184,
              83968: 536870912,
              88064: 17039488,
              92160: 128,
              96256: 553910272,
              100352: 262272,
              104448: 553910400,
              108544: 0,
              112640: 553648128,
              116736: 16777344,
              120832: 262144,
              124928: 537133056,
              129024: 536871040
            },
            {
              0: 268435464,
              256: 8192,
              512: 270532608,
              768: 270540808,
              1024: 268443648,
              1280: 2097152,
              1536: 2097160,
              1792: 268435456,
              2048: 0,
              2304: 268443656,
              2560: 2105344,
              2816: 8,
              3072: 270532616,
              3328: 2105352,
              3584: 8200,
              3840: 270540800,
              128: 270532608,
              384: 270540808,
              640: 8,
              896: 2097152,
              1152: 2105352,
              1408: 268435464,
              1664: 268443648,
              1920: 8200,
              2176: 2097160,
              2432: 8192,
              2688: 268443656,
              2944: 270532616,
              3200: 0,
              3456: 270540800,
              3712: 2105344,
              3968: 268435456,
              4096: 268443648,
              4352: 270532616,
              4608: 270540808,
              4864: 8200,
              5120: 2097152,
              5376: 268435456,
              5632: 268435464,
              5888: 2105344,
              6144: 2105352,
              6400: 0,
              6656: 8,
              6912: 270532608,
              7168: 8192,
              7424: 268443656,
              7680: 270540800,
              7936: 2097160,
              4224: 8,
              4480: 2105344,
              4736: 2097152,
              4992: 268435464,
              5248: 268443648,
              5504: 8200,
              5760: 270540808,
              6016: 270532608,
              6272: 270540800,
              6528: 270532616,
              6784: 8192,
              7040: 2105352,
              7296: 2097160,
              7552: 0,
              7808: 268435456,
              8064: 268443656
            },
            {
              0: 1048576,
              16: 33555457,
              32: 1024,
              48: 1049601,
              64: 34604033,
              80: 0,
              96: 1,
              112: 34603009,
              128: 33555456,
              144: 1048577,
              160: 33554433,
              176: 34604032,
              192: 34603008,
              208: 1025,
              224: 1049600,
              240: 33554432,
              8: 34603009,
              24: 0,
              40: 33555457,
              56: 34604032,
              72: 1048576,
              88: 33554433,
              104: 33554432,
              120: 1025,
              136: 1049601,
              152: 33555456,
              168: 34603008,
              184: 1048577,
              200: 1024,
              216: 34604033,
              232: 1,
              248: 1049600,
              256: 33554432,
              272: 1048576,
              288: 33555457,
              304: 34603009,
              320: 1048577,
              336: 33555456,
              352: 34604032,
              368: 1049601,
              384: 1025,
              400: 34604033,
              416: 1049600,
              432: 1,
              448: 0,
              464: 34603008,
              480: 33554433,
              496: 1024,
              264: 1049600,
              280: 33555457,
              296: 34603009,
              312: 1,
              328: 33554432,
              344: 1048576,
              360: 1025,
              376: 34604032,
              392: 33554433,
              408: 34603008,
              424: 0,
              440: 34604033,
              456: 1049601,
              472: 1024,
              488: 33555456,
              504: 1048577
            },
            {
              0: 134219808,
              1: 131072,
              2: 134217728,
              3: 32,
              4: 131104,
              5: 134350880,
              6: 134350848,
              7: 2048,
              8: 134348800,
              9: 134219776,
              10: 133120,
              11: 134348832,
              12: 2080,
              13: 0,
              14: 134217760,
              15: 133152,
              2147483648: 2048,
              2147483649: 134350880,
              2147483650: 134219808,
              2147483651: 134217728,
              2147483652: 134348800,
              2147483653: 133120,
              2147483654: 133152,
              2147483655: 32,
              2147483656: 134217760,
              2147483657: 2080,
              2147483658: 131104,
              2147483659: 134350848,
              2147483660: 0,
              2147483661: 134348832,
              2147483662: 134219776,
              2147483663: 131072,
              16: 133152,
              17: 134350848,
              18: 32,
              19: 2048,
              20: 134219776,
              21: 134217760,
              22: 134348832,
              23: 131072,
              24: 0,
              25: 131104,
              26: 134348800,
              27: 134219808,
              28: 134350880,
              29: 133120,
              30: 2080,
              31: 134217728,
              2147483664: 131072,
              2147483665: 2048,
              2147483666: 134348832,
              2147483667: 133152,
              2147483668: 32,
              2147483669: 134348800,
              2147483670: 134217728,
              2147483671: 134219808,
              2147483672: 134350880,
              2147483673: 134217760,
              2147483674: 134219776,
              2147483675: 0,
              2147483676: 133120,
              2147483677: 2080,
              2147483678: 131104,
              2147483679: 134350848
            }
          ];
          var SBOX_MASK = [
            4160749569,
            528482304,
            33030144,
            2064384,
            129024,
            8064,
            504,
            2147483679
          ];
          var DES = C_algo.DES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keyBits = [];
              for (var i2 = 0; i2 < 56; i2++) {
                var keyBitPos = PC1[i2] - 1;
                keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
              }
              var subKeys = this._subKeys = [];
              for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                var subKey = subKeys[nSubKey] = [];
                var bitShift = BIT_SHIFTS[nSubKey];
                for (var i2 = 0; i2 < 24; i2++) {
                  subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                  subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
                }
                subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                for (var i2 = 1; i2 < 7; i2++) {
                  subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
                }
                subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
              }
              var invSubKeys = this._invSubKeys = [];
              for (var i2 = 0; i2 < 16; i2++) {
                invSubKeys[i2] = subKeys[15 - i2];
              }
            },
            encryptBlock: function(M2, offset) {
              this._doCryptBlock(M2, offset, this._subKeys);
            },
            decryptBlock: function(M2, offset) {
              this._doCryptBlock(M2, offset, this._invSubKeys);
            },
            _doCryptBlock: function(M2, offset, subKeys) {
              this._lBlock = M2[offset];
              this._rBlock = M2[offset + 1];
              exchangeLR.call(this, 4, 252645135);
              exchangeLR.call(this, 16, 65535);
              exchangeRL.call(this, 2, 858993459);
              exchangeRL.call(this, 8, 16711935);
              exchangeLR.call(this, 1, 1431655765);
              for (var round = 0; round < 16; round++) {
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;
                var f2 = 0;
                for (var i2 = 0; i2 < 8; i2++) {
                  f2 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f2;
              }
              var t2 = this._lBlock;
              this._lBlock = this._rBlock;
              this._rBlock = t2;
              exchangeLR.call(this, 1, 1431655765);
              exchangeRL.call(this, 8, 16711935);
              exchangeRL.call(this, 2, 858993459);
              exchangeLR.call(this, 16, 65535);
              exchangeLR.call(this, 4, 252645135);
              M2[offset] = this._lBlock;
              M2[offset + 1] = this._rBlock;
            },
            keySize: 64 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          function exchangeLR(offset, mask) {
            var t2 = (this._lBlock >>> offset ^ this._rBlock) & mask;
            this._rBlock ^= t2;
            this._lBlock ^= t2 << offset;
          }
          function exchangeRL(offset, mask) {
            var t2 = (this._rBlock >>> offset ^ this._lBlock) & mask;
            this._lBlock ^= t2;
            this._rBlock ^= t2 << offset;
          }
          C2.DES = BlockCipher._createHelper(DES);
          var TripleDES = C_algo.TripleDES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
              }
              var key1 = keyWords.slice(0, 2);
              var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
              var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
              this._des1 = DES.createEncryptor(WordArray.create(key1));
              this._des2 = DES.createEncryptor(WordArray.create(key2));
              this._des3 = DES.createEncryptor(WordArray.create(key3));
            },
            encryptBlock: function(M2, offset) {
              this._des1.encryptBlock(M2, offset);
              this._des2.decryptBlock(M2, offset);
              this._des3.encryptBlock(M2, offset);
            },
            decryptBlock: function(M2, offset) {
              this._des3.decryptBlock(M2, offset);
              this._des2.encryptBlock(M2, offset);
              this._des1.decryptBlock(M2, offset);
            },
            keySize: 192 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          C2.TripleDES = BlockCipher._createHelper(TripleDES);
        })();
        return CryptoJS2.TripleDES;
      });
    })(tripledes);
    return tripledes.exports;
  }
  var rc4 = { exports: {} };
  var hasRequiredRc4;
  function requireRc4() {
    if (hasRequiredRc4)
      return rc4.exports;
    hasRequiredRc4 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C2.algo;
          var RC4 = C_algo.RC4 = StreamCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keySigBytes = key.sigBytes;
              var S2 = this._S = [];
              for (var i2 = 0; i2 < 256; i2++) {
                S2[i2] = i2;
              }
              for (var i2 = 0, j2 = 0; i2 < 256; i2++) {
                var keyByteIndex = i2 % keySigBytes;
                var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                j2 = (j2 + S2[i2] + keyByte) % 256;
                var t2 = S2[i2];
                S2[i2] = S2[j2];
                S2[j2] = t2;
              }
              this._i = this._j = 0;
            },
            _doProcessBlock: function(M2, offset) {
              M2[offset] ^= generateKeystreamWord.call(this);
            },
            keySize: 256 / 32,
            ivSize: 0
          });
          function generateKeystreamWord() {
            var S2 = this._S;
            var i2 = this._i;
            var j2 = this._j;
            var keystreamWord = 0;
            for (var n2 = 0; n2 < 4; n2++) {
              i2 = (i2 + 1) % 256;
              j2 = (j2 + S2[i2]) % 256;
              var t2 = S2[i2];
              S2[i2] = S2[j2];
              S2[j2] = t2;
              keystreamWord |= S2[(S2[i2] + S2[j2]) % 256] << 24 - n2 * 8;
            }
            this._i = i2;
            this._j = j2;
            return keystreamWord;
          }
          C2.RC4 = StreamCipher._createHelper(RC4);
          var RC4Drop = C_algo.RC4Drop = RC4.extend({
            /**
             * Configuration options.
             *
             * @property {number} drop The number of keystream words to drop. Default 192
             */
            cfg: RC4.cfg.extend({
              drop: 192
            }),
            _doReset: function() {
              RC4._doReset.call(this);
              for (var i2 = this.cfg.drop; i2 > 0; i2--) {
                generateKeystreamWord.call(this);
              }
            }
          });
          C2.RC4Drop = StreamCipher._createHelper(RC4Drop);
        })();
        return CryptoJS2.RC4;
      });
    })(rc4);
    return rc4.exports;
  }
  var rabbit = { exports: {} };
  var hasRequiredRabbit;
  function requireRabbit() {
    if (hasRequiredRabbit)
      return rabbit.exports;
    hasRequiredRabbit = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C2.algo;
          var S2 = [];
          var C_ = [];
          var G2 = [];
          var Rabbit = C_algo.Rabbit = StreamCipher.extend({
            _doReset: function() {
              var K2 = this._key.words;
              var iv = this.cfg.iv;
              for (var i2 = 0; i2 < 4; i2++) {
                K2[i2] = (K2[i2] << 8 | K2[i2] >>> 24) & 16711935 | (K2[i2] << 24 | K2[i2] >>> 8) & 4278255360;
              }
              var X2 = this._X = [
                K2[0],
                K2[3] << 16 | K2[2] >>> 16,
                K2[1],
                K2[0] << 16 | K2[3] >>> 16,
                K2[2],
                K2[1] << 16 | K2[0] >>> 16,
                K2[3],
                K2[2] << 16 | K2[1] >>> 16
              ];
              var C3 = this._C = [
                K2[2] << 16 | K2[2] >>> 16,
                K2[0] & 4294901760 | K2[1] & 65535,
                K2[3] << 16 | K2[3] >>> 16,
                K2[1] & 4294901760 | K2[2] & 65535,
                K2[0] << 16 | K2[0] >>> 16,
                K2[2] & 4294901760 | K2[3] & 65535,
                K2[1] << 16 | K2[1] >>> 16,
                K2[3] & 4294901760 | K2[0] & 65535
              ];
              this._b = 0;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
              for (var i2 = 0; i2 < 8; i2++) {
                C3[i2] ^= X2[i2 + 4 & 7];
              }
              if (iv) {
                var IV = iv.words;
                var IV_0 = IV[0];
                var IV_1 = IV[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i22 & 4294901760;
                var i3 = i22 << 16 | i0 & 65535;
                C3[0] ^= i0;
                C3[1] ^= i1;
                C3[2] ^= i22;
                C3[3] ^= i3;
                C3[4] ^= i0;
                C3[5] ^= i1;
                C3[6] ^= i22;
                C3[7] ^= i3;
                for (var i2 = 0; i2 < 4; i2++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M2, offset) {
              var X2 = this._X;
              nextState.call(this);
              S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
              S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
              S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
              S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
              for (var i2 = 0; i2 < 4; i2++) {
                S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
                M2[offset + i2] ^= S2[i2];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X2 = this._X;
            var C3 = this._C;
            for (var i2 = 0; i2 < 8; i2++) {
              C_[i2] = C3[i2];
            }
            C3[0] = C3[0] + 1295307597 + this._b | 0;
            C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i2 = 0; i2 < 8; i2++) {
              var gx = X2[i2] + C3[i2];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G2[i2] = gh ^ gl;
            }
            X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
            X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
            X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
            X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
            X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
            X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
            X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
            X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
          }
          C2.Rabbit = StreamCipher._createHelper(Rabbit);
        })();
        return CryptoJS2.Rabbit;
      });
    })(rabbit);
    return rabbit.exports;
  }
  var rabbitLegacy = { exports: {} };
  var hasRequiredRabbitLegacy;
  function requireRabbitLegacy() {
    if (hasRequiredRabbitLegacy)
      return rabbitLegacy.exports;
    hasRequiredRabbitLegacy = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C2.algo;
          var S2 = [];
          var C_ = [];
          var G2 = [];
          var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
            _doReset: function() {
              var K2 = this._key.words;
              var iv = this.cfg.iv;
              var X2 = this._X = [
                K2[0],
                K2[3] << 16 | K2[2] >>> 16,
                K2[1],
                K2[0] << 16 | K2[3] >>> 16,
                K2[2],
                K2[1] << 16 | K2[0] >>> 16,
                K2[3],
                K2[2] << 16 | K2[1] >>> 16
              ];
              var C3 = this._C = [
                K2[2] << 16 | K2[2] >>> 16,
                K2[0] & 4294901760 | K2[1] & 65535,
                K2[3] << 16 | K2[3] >>> 16,
                K2[1] & 4294901760 | K2[2] & 65535,
                K2[0] << 16 | K2[0] >>> 16,
                K2[2] & 4294901760 | K2[3] & 65535,
                K2[1] << 16 | K2[1] >>> 16,
                K2[3] & 4294901760 | K2[0] & 65535
              ];
              this._b = 0;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
              for (var i2 = 0; i2 < 8; i2++) {
                C3[i2] ^= X2[i2 + 4 & 7];
              }
              if (iv) {
                var IV = iv.words;
                var IV_0 = IV[0];
                var IV_1 = IV[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i22 & 4294901760;
                var i3 = i22 << 16 | i0 & 65535;
                C3[0] ^= i0;
                C3[1] ^= i1;
                C3[2] ^= i22;
                C3[3] ^= i3;
                C3[4] ^= i0;
                C3[5] ^= i1;
                C3[6] ^= i22;
                C3[7] ^= i3;
                for (var i2 = 0; i2 < 4; i2++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M2, offset) {
              var X2 = this._X;
              nextState.call(this);
              S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
              S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
              S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
              S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
              for (var i2 = 0; i2 < 4; i2++) {
                S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
                M2[offset + i2] ^= S2[i2];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X2 = this._X;
            var C3 = this._C;
            for (var i2 = 0; i2 < 8; i2++) {
              C_[i2] = C3[i2];
            }
            C3[0] = C3[0] + 1295307597 + this._b | 0;
            C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i2 = 0; i2 < 8; i2++) {
              var gx = X2[i2] + C3[i2];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G2[i2] = gh ^ gl;
            }
            X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
            X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
            X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
            X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
            X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
            X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
            X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
            X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
          }
          C2.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
        })();
        return CryptoJS2.RabbitLegacy;
      });
    })(rabbitLegacy);
    return rabbitLegacy.exports;
  }
  var blowfish = { exports: {} };
  var hasRequiredBlowfish;
  function requireBlowfish() {
    if (hasRequiredBlowfish)
      return blowfish.exports;
    hasRequiredBlowfish = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C2.algo;
          const N2 = 16;
          const ORIG_P = [
            608135816,
            2242054355,
            320440878,
            57701188,
            2752067618,
            698298832,
            137296536,
            3964562569,
            1160258022,
            953160567,
            3193202383,
            887688300,
            3232508343,
            3380367581,
            1065670069,
            3041331479,
            2450970073,
            2306472731
          ];
          const ORIG_S = [
            [
              3509652390,
              2564797868,
              805139163,
              3491422135,
              3101798381,
              1780907670,
              3128725573,
              4046225305,
              614570311,
              3012652279,
              134345442,
              2240740374,
              1667834072,
              1901547113,
              2757295779,
              4103290238,
              227898511,
              1921955416,
              1904987480,
              2182433518,
              2069144605,
              3260701109,
              2620446009,
              720527379,
              3318853667,
              677414384,
              3393288472,
              3101374703,
              2390351024,
              1614419982,
              1822297739,
              2954791486,
              3608508353,
              3174124327,
              2024746970,
              1432378464,
              3864339955,
              2857741204,
              1464375394,
              1676153920,
              1439316330,
              715854006,
              3033291828,
              289532110,
              2706671279,
              2087905683,
              3018724369,
              1668267050,
              732546397,
              1947742710,
              3462151702,
              2609353502,
              2950085171,
              1814351708,
              2050118529,
              680887927,
              999245976,
              1800124847,
              3300911131,
              1713906067,
              1641548236,
              4213287313,
              1216130144,
              1575780402,
              4018429277,
              3917837745,
              3693486850,
              3949271944,
              596196993,
              3549867205,
              258830323,
              2213823033,
              772490370,
              2760122372,
              1774776394,
              2652871518,
              566650946,
              4142492826,
              1728879713,
              2882767088,
              1783734482,
              3629395816,
              2517608232,
              2874225571,
              1861159788,
              326777828,
              3124490320,
              2130389656,
              2716951837,
              967770486,
              1724537150,
              2185432712,
              2364442137,
              1164943284,
              2105845187,
              998989502,
              3765401048,
              2244026483,
              1075463327,
              1455516326,
              1322494562,
              910128902,
              469688178,
              1117454909,
              936433444,
              3490320968,
              3675253459,
              1240580251,
              122909385,
              2157517691,
              634681816,
              4142456567,
              3825094682,
              3061402683,
              2540495037,
              79693498,
              3249098678,
              1084186820,
              1583128258,
              426386531,
              1761308591,
              1047286709,
              322548459,
              995290223,
              1845252383,
              2603652396,
              3431023940,
              2942221577,
              3202600964,
              3727903485,
              1712269319,
              422464435,
              3234572375,
              1170764815,
              3523960633,
              3117677531,
              1434042557,
              442511882,
              3600875718,
              1076654713,
              1738483198,
              4213154764,
              2393238008,
              3677496056,
              1014306527,
              4251020053,
              793779912,
              2902807211,
              842905082,
              4246964064,
              1395751752,
              1040244610,
              2656851899,
              3396308128,
              445077038,
              3742853595,
              3577915638,
              679411651,
              2892444358,
              2354009459,
              1767581616,
              3150600392,
              3791627101,
              3102740896,
              284835224,
              4246832056,
              1258075500,
              768725851,
              2589189241,
              3069724005,
              3532540348,
              1274779536,
              3789419226,
              2764799539,
              1660621633,
              3471099624,
              4011903706,
              913787905,
              3497959166,
              737222580,
              2514213453,
              2928710040,
              3937242737,
              1804850592,
              3499020752,
              2949064160,
              2386320175,
              2390070455,
              2415321851,
              4061277028,
              2290661394,
              2416832540,
              1336762016,
              1754252060,
              3520065937,
              3014181293,
              791618072,
              3188594551,
              3933548030,
              2332172193,
              3852520463,
              3043980520,
              413987798,
              3465142937,
              3030929376,
              4245938359,
              2093235073,
              3534596313,
              375366246,
              2157278981,
              2479649556,
              555357303,
              3870105701,
              2008414854,
              3344188149,
              4221384143,
              3956125452,
              2067696032,
              3594591187,
              2921233993,
              2428461,
              544322398,
              577241275,
              1471733935,
              610547355,
              4027169054,
              1432588573,
              1507829418,
              2025931657,
              3646575487,
              545086370,
              48609733,
              2200306550,
              1653985193,
              298326376,
              1316178497,
              3007786442,
              2064951626,
              458293330,
              2589141269,
              3591329599,
              3164325604,
              727753846,
              2179363840,
              146436021,
              1461446943,
              4069977195,
              705550613,
              3059967265,
              3887724982,
              4281599278,
              3313849956,
              1404054877,
              2845806497,
              146425753,
              1854211946
            ],
            [
              1266315497,
              3048417604,
              3681880366,
              3289982499,
              290971e4,
              1235738493,
              2632868024,
              2414719590,
              3970600049,
              1771706367,
              1449415276,
              3266420449,
              422970021,
              1963543593,
              2690192192,
              3826793022,
              1062508698,
              1531092325,
              1804592342,
              2583117782,
              2714934279,
              4024971509,
              1294809318,
              4028980673,
              1289560198,
              2221992742,
              1669523910,
              35572830,
              157838143,
              1052438473,
              1016535060,
              1802137761,
              1753167236,
              1386275462,
              3080475397,
              2857371447,
              1040679964,
              2145300060,
              2390574316,
              1461121720,
              2956646967,
              4031777805,
              4028374788,
              33600511,
              2920084762,
              1018524850,
              629373528,
              3691585981,
              3515945977,
              2091462646,
              2486323059,
              586499841,
              988145025,
              935516892,
              3367335476,
              2599673255,
              2839830854,
              265290510,
              3972581182,
              2759138881,
              3795373465,
              1005194799,
              847297441,
              406762289,
              1314163512,
              1332590856,
              1866599683,
              4127851711,
              750260880,
              613907577,
              1450815602,
              3165620655,
              3734664991,
              3650291728,
              3012275730,
              3704569646,
              1427272223,
              778793252,
              1343938022,
              2676280711,
              2052605720,
              1946737175,
              3164576444,
              3914038668,
              3967478842,
              3682934266,
              1661551462,
              3294938066,
              4011595847,
              840292616,
              3712170807,
              616741398,
              312560963,
              711312465,
              1351876610,
              322626781,
              1910503582,
              271666773,
              2175563734,
              1594956187,
              70604529,
              3617834859,
              1007753275,
              1495573769,
              4069517037,
              2549218298,
              2663038764,
              504708206,
              2263041392,
              3941167025,
              2249088522,
              1514023603,
              1998579484,
              1312622330,
              694541497,
              2582060303,
              2151582166,
              1382467621,
              776784248,
              2618340202,
              3323268794,
              2497899128,
              2784771155,
              503983604,
              4076293799,
              907881277,
              423175695,
              432175456,
              1378068232,
              4145222326,
              3954048622,
              3938656102,
              3820766613,
              2793130115,
              2977904593,
              26017576,
              3274890735,
              3194772133,
              1700274565,
              1756076034,
              4006520079,
              3677328699,
              720338349,
              1533947780,
              354530856,
              688349552,
              3973924725,
              1637815568,
              332179504,
              3949051286,
              53804574,
              2852348879,
              3044236432,
              1282449977,
              3583942155,
              3416972820,
              4006381244,
              1617046695,
              2628476075,
              3002303598,
              1686838959,
              431878346,
              2686675385,
              1700445008,
              1080580658,
              1009431731,
              832498133,
              3223435511,
              2605976345,
              2271191193,
              2516031870,
              1648197032,
              4164389018,
              2548247927,
              300782431,
              375919233,
              238389289,
              3353747414,
              2531188641,
              2019080857,
              1475708069,
              455242339,
              2609103871,
              448939670,
              3451063019,
              1395535956,
              2413381860,
              1841049896,
              1491858159,
              885456874,
              4264095073,
              4001119347,
              1565136089,
              3898914787,
              1108368660,
              540939232,
              1173283510,
              2745871338,
              3681308437,
              4207628240,
              3343053890,
              4016749493,
              1699691293,
              1103962373,
              3625875870,
              2256883143,
              3830138730,
              1031889488,
              3479347698,
              1535977030,
              4236805024,
              3251091107,
              2132092099,
              1774941330,
              1199868427,
              1452454533,
              157007616,
              2904115357,
              342012276,
              595725824,
              1480756522,
              206960106,
              497939518,
              591360097,
              863170706,
              2375253569,
              3596610801,
              1814182875,
              2094937945,
              3421402208,
              1082520231,
              3463918190,
              2785509508,
              435703966,
              3908032597,
              1641649973,
              2842273706,
              3305899714,
              1510255612,
              2148256476,
              2655287854,
              3276092548,
              4258621189,
              236887753,
              3681803219,
              274041037,
              1734335097,
              3815195456,
              3317970021,
              1899903192,
              1026095262,
              4050517792,
              356393447,
              2410691914,
              3873677099,
              3682840055
            ],
            [
              3913112168,
              2491498743,
              4132185628,
              2489919796,
              1091903735,
              1979897079,
              3170134830,
              3567386728,
              3557303409,
              857797738,
              1136121015,
              1342202287,
              507115054,
              2535736646,
              337727348,
              3213592640,
              1301675037,
              2528481711,
              1895095763,
              1721773893,
              3216771564,
              62756741,
              2142006736,
              835421444,
              2531993523,
              1442658625,
              3659876326,
              2882144922,
              676362277,
              1392781812,
              170690266,
              3921047035,
              1759253602,
              3611846912,
              1745797284,
              664899054,
              1329594018,
              3901205900,
              3045908486,
              2062866102,
              2865634940,
              3543621612,
              3464012697,
              1080764994,
              553557557,
              3656615353,
              3996768171,
              991055499,
              499776247,
              1265440854,
              648242737,
              3940784050,
              980351604,
              3713745714,
              1749149687,
              3396870395,
              4211799374,
              3640570775,
              1161844396,
              3125318951,
              1431517754,
              545492359,
              4268468663,
              3499529547,
              1437099964,
              2702547544,
              3433638243,
              2581715763,
              2787789398,
              1060185593,
              1593081372,
              2418618748,
              4260947970,
              69676912,
              2159744348,
              86519011,
              2512459080,
              3838209314,
              1220612927,
              3339683548,
              133810670,
              1090789135,
              1078426020,
              1569222167,
              845107691,
              3583754449,
              4072456591,
              1091646820,
              628848692,
              1613405280,
              3757631651,
              526609435,
              236106946,
              48312990,
              2942717905,
              3402727701,
              1797494240,
              859738849,
              992217954,
              4005476642,
              2243076622,
              3870952857,
              3732016268,
              765654824,
              3490871365,
              2511836413,
              1685915746,
              3888969200,
              1414112111,
              2273134842,
              3281911079,
              4080962846,
              172450625,
              2569994100,
              980381355,
              4109958455,
              2819808352,
              2716589560,
              2568741196,
              3681446669,
              3329971472,
              1835478071,
              660984891,
              3704678404,
              4045999559,
              3422617507,
              3040415634,
              1762651403,
              1719377915,
              3470491036,
              2693910283,
              3642056355,
              3138596744,
              1364962596,
              2073328063,
              1983633131,
              926494387,
              3423689081,
              2150032023,
              4096667949,
              1749200295,
              3328846651,
              309677260,
              2016342300,
              1779581495,
              3079819751,
              111262694,
              1274766160,
              443224088,
              298511866,
              1025883608,
              3806446537,
              1145181785,
              168956806,
              3641502830,
              3584813610,
              1689216846,
              3666258015,
              3200248200,
              1692713982,
              2646376535,
              4042768518,
              1618508792,
              1610833997,
              3523052358,
              4130873264,
              2001055236,
              3610705100,
              2202168115,
              4028541809,
              2961195399,
              1006657119,
              2006996926,
              3186142756,
              1430667929,
              3210227297,
              1314452623,
              4074634658,
              4101304120,
              2273951170,
              1399257539,
              3367210612,
              3027628629,
              1190975929,
              2062231137,
              2333990788,
              2221543033,
              2438960610,
              1181637006,
              548689776,
              2362791313,
              3372408396,
              3104550113,
              3145860560,
              296247880,
              1970579870,
              3078560182,
              3769228297,
              1714227617,
              3291629107,
              3898220290,
              166772364,
              1251581989,
              493813264,
              448347421,
              195405023,
              2709975567,
              677966185,
              3703036547,
              1463355134,
              2715995803,
              1338867538,
              1343315457,
              2802222074,
              2684532164,
              233230375,
              2599980071,
              2000651841,
              3277868038,
              1638401717,
              4028070440,
              3237316320,
              6314154,
              819756386,
              300326615,
              590932579,
              1405279636,
              3267499572,
              3150704214,
              2428286686,
              3959192993,
              3461946742,
              1862657033,
              1266418056,
              963775037,
              2089974820,
              2263052895,
              1917689273,
              448879540,
              3550394620,
              3981727096,
              150775221,
              3627908307,
              1303187396,
              508620638,
              2975983352,
              2726630617,
              1817252668,
              1876281319,
              1457606340,
              908771278,
              3720792119,
              3617206836,
              2455994898,
              1729034894,
              1080033504
            ],
            [
              976866871,
              3556439503,
              2881648439,
              1522871579,
              1555064734,
              1336096578,
              3548522304,
              2579274686,
              3574697629,
              3205460757,
              3593280638,
              3338716283,
              3079412587,
              564236357,
              2993598910,
              1781952180,
              1464380207,
              3163844217,
              3332601554,
              1699332808,
              1393555694,
              1183702653,
              3581086237,
              1288719814,
              691649499,
              2847557200,
              2895455976,
              3193889540,
              2717570544,
              1781354906,
              1676643554,
              2592534050,
              3230253752,
              1126444790,
              2770207658,
              2633158820,
              2210423226,
              2615765581,
              2414155088,
              3127139286,
              673620729,
              2805611233,
              1269405062,
              4015350505,
              3341807571,
              4149409754,
              1057255273,
              2012875353,
              2162469141,
              2276492801,
              2601117357,
              993977747,
              3918593370,
              2654263191,
              753973209,
              36408145,
              2530585658,
              25011837,
              3520020182,
              2088578344,
              530523599,
              2918365339,
              1524020338,
              1518925132,
              3760827505,
              3759777254,
              1202760957,
              3985898139,
              3906192525,
              674977740,
              4174734889,
              2031300136,
              2019492241,
              3983892565,
              4153806404,
              3822280332,
              352677332,
              2297720250,
              60907813,
              90501309,
              3286998549,
              1016092578,
              2535922412,
              2839152426,
              457141659,
              509813237,
              4120667899,
              652014361,
              1966332200,
              2975202805,
              55981186,
              2327461051,
              676427537,
              3255491064,
              2882294119,
              3433927263,
              1307055953,
              942726286,
              933058658,
              2468411793,
              3933900994,
              4215176142,
              1361170020,
              2001714738,
              2830558078,
              3274259782,
              1222529897,
              1679025792,
              2729314320,
              3714953764,
              1770335741,
              151462246,
              3013232138,
              1682292957,
              1483529935,
              471910574,
              1539241949,
              458788160,
              3436315007,
              1807016891,
              3718408830,
              978976581,
              1043663428,
              3165965781,
              1927990952,
              4200891579,
              2372276910,
              3208408903,
              3533431907,
              1412390302,
              2931980059,
              4132332400,
              1947078029,
              3881505623,
              4168226417,
              2941484381,
              1077988104,
              1320477388,
              886195818,
              18198404,
              3786409e3,
              2509781533,
              112762804,
              3463356488,
              1866414978,
              891333506,
              18488651,
              661792760,
              1628790961,
              3885187036,
              3141171499,
              876946877,
              2693282273,
              1372485963,
              791857591,
              2686433993,
              3759982718,
              3167212022,
              3472953795,
              2716379847,
              445679433,
              3561995674,
              3504004811,
              3574258232,
              54117162,
              3331405415,
              2381918588,
              3769707343,
              4154350007,
              1140177722,
              4074052095,
              668550556,
              3214352940,
              367459370,
              261225585,
              2610173221,
              4209349473,
              3468074219,
              3265815641,
              314222801,
              3066103646,
              3808782860,
              282218597,
              3406013506,
              3773591054,
              379116347,
              1285071038,
              846784868,
              2669647154,
              3771962079,
              3550491691,
              2305946142,
              453669953,
              1268987020,
              3317592352,
              3279303384,
              3744833421,
              2610507566,
              3859509063,
              266596637,
              3847019092,
              517658769,
              3462560207,
              3443424879,
              370717030,
              4247526661,
              2224018117,
              4143653529,
              4112773975,
              2788324899,
              2477274417,
              1456262402,
              2901442914,
              1517677493,
              1846949527,
              2295493580,
              3734397586,
              2176403920,
              1280348187,
              1908823572,
              3871786941,
              846861322,
              1172426758,
              3287448474,
              3383383037,
              1655181056,
              3139813346,
              901632758,
              1897031941,
              2986607138,
              3066810236,
              3447102507,
              1393639104,
              373351379,
              950779232,
              625454576,
              3124240540,
              4148612726,
              2007998917,
              544563296,
              2244738638,
              2330496472,
              2058025392,
              1291430526,
              424198748,
              50039436,
              29584100,
              3605783033,
              2429876329,
              2791104160,
              1057563949,
              3255363231,
              3075367218,
              3463963227,
              1469046755,
              985887462
            ]
          ];
          var BLOWFISH_CTX = {
            pbox: [],
            sbox: []
          };
          function F2(ctx, x) {
            let a2 = x >> 24 & 255;
            let b2 = x >> 16 & 255;
            let c2 = x >> 8 & 255;
            let d2 = x & 255;
            let y2 = ctx.sbox[0][a2] + ctx.sbox[1][b2];
            y2 = y2 ^ ctx.sbox[2][c2];
            y2 = y2 + ctx.sbox[3][d2];
            return y2;
          }
          function BlowFish_Encrypt(ctx, left, right) {
            let Xl = left;
            let Xr = right;
            let temp;
            for (let i2 = 0; i2 < N2; ++i2) {
              Xl = Xl ^ ctx.pbox[i2];
              Xr = F2(ctx, Xl) ^ Xr;
              temp = Xl;
              Xl = Xr;
              Xr = temp;
            }
            temp = Xl;
            Xl = Xr;
            Xr = temp;
            Xr = Xr ^ ctx.pbox[N2];
            Xl = Xl ^ ctx.pbox[N2 + 1];
            return { left: Xl, right: Xr };
          }
          function BlowFish_Decrypt(ctx, left, right) {
            let Xl = left;
            let Xr = right;
            let temp;
            for (let i2 = N2 + 1; i2 > 1; --i2) {
              Xl = Xl ^ ctx.pbox[i2];
              Xr = F2(ctx, Xl) ^ Xr;
              temp = Xl;
              Xl = Xr;
              Xr = temp;
            }
            temp = Xl;
            Xl = Xr;
            Xr = temp;
            Xr = Xr ^ ctx.pbox[1];
            Xl = Xl ^ ctx.pbox[0];
            return { left: Xl, right: Xr };
          }
          function BlowFishInit(ctx, key, keysize) {
            for (let Row = 0; Row < 4; Row++) {
              ctx.sbox[Row] = [];
              for (let Col = 0; Col < 256; Col++) {
                ctx.sbox[Row][Col] = ORIG_S[Row][Col];
              }
            }
            let keyIndex = 0;
            for (let index = 0; index < N2 + 2; index++) {
              ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
              keyIndex++;
              if (keyIndex >= keysize) {
                keyIndex = 0;
              }
            }
            let Data1 = 0;
            let Data2 = 0;
            let res = 0;
            for (let i2 = 0; i2 < N2 + 2; i2 += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.pbox[i2] = Data1;
              ctx.pbox[i2 + 1] = Data2;
            }
            for (let i2 = 0; i2 < 4; i2++) {
              for (let j2 = 0; j2 < 256; j2 += 2) {
                res = BlowFish_Encrypt(ctx, Data1, Data2);
                Data1 = res.left;
                Data2 = res.right;
                ctx.sbox[i2][j2] = Data1;
                ctx.sbox[i2][j2 + 1] = Data2;
              }
            }
            return true;
          }
          var Blowfish = C_algo.Blowfish = BlockCipher.extend({
            _doReset: function() {
              if (this._keyPriorReset === this._key) {
                return;
              }
              var key = this._keyPriorReset = this._key;
              var keyWords = key.words;
              var keySize = key.sigBytes / 4;
              BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
            },
            encryptBlock: function(M2, offset) {
              var res = BlowFish_Encrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
              M2[offset] = res.left;
              M2[offset + 1] = res.right;
            },
            decryptBlock: function(M2, offset) {
              var res = BlowFish_Decrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
              M2[offset] = res.left;
              M2[offset + 1] = res.right;
            },
            blockSize: 64 / 32,
            keySize: 128 / 32,
            ivSize: 64 / 32
          });
          C2.Blowfish = BlockCipher._createHelper(Blowfish);
        })();
        return CryptoJS2.Blowfish;
      });
    })(blowfish);
    return blowfish.exports;
  }
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      return CryptoJS2;
    });
  })(cryptoJs);
  var cryptoJsExports = cryptoJs.exports;
  const CryptoJS = /* @__PURE__ */ getDefaultExportFromCjs(cryptoJsExports);
  function signRequest(params) {
    const sortedParams = Object.keys(params).sort().map((key) => `${key}=${params[key]}`).join("&");
    const signStr = `${sortedParams}${gaodeSecurityKey}`;
    const sign = CryptoJS.MD5(signStr).toString();
    return `${sortedParams}&sig=${sign}`;
  }
  const _imports_0$3 = "/static/icons/check.png";
  const AMAP_API = "https://restapi.amap.com/v3";
  const _sfc_main$q = {
    name: "LocationSharing",
    props: {
      recipientId: {
        type: String,
        required: true
      },
      missionId: {
        type: String,
        required: true
      }
    },
    data() {
      return {
        currentLocation: {
          latitude: 39.909604,
          longitude: 116.397228
        },
        searchKeyword: "",
        markers: [],
        nearbyPOIs: [],
        selectedPOI: null,
        searchDebounceTimer: null
      };
    },
    mounted() {
      this.getCurrentLocation();
      this.hideMessageInput();
    },
    beforeDestroy() {
      this.showMessageInput();
    },
    methods: {
      getCurrentLocation() {
        uni.getLocation({
          type: "gcj02",
          success: (res) => {
            this.currentLocation = {
              latitude: res.latitude,
              longitude: res.longitude
            };
            this.updateMarkers();
            this.searchNearbyPOIs();
          },
          fail: (err) => {
            formatAppLog("error", "at pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue:103", "获取位置失败:", err);
            uni.showToast({
              title: "获取位置失败，请检查定位权限",
              icon: "none"
            });
          }
        });
      },
      updateMarkers() {
        this.markers = [{
          id: 1,
          latitude: this.currentLocation.latitude,
          longitude: this.currentLocation.longitude,
          iconPath: "/static/icons/location-blue.png",
          width: 32,
          height: 32
        }];
        if (this.selectedPOI) {
          this.markers.push({
            id: 2,
            latitude: this.selectedPOI.location.split(",")[1],
            longitude: this.selectedPOI.location.split(",")[0],
            iconPath: "/static/icons/location-red.png",
            width: 32,
            height: 32
          });
        }
      },
      async searchNearbyPOIs(keyword = "") {
        try {
          const location2 = `${this.currentLocation.longitude},${this.currentLocation.latitude}`;
          const params = {
            key: gaodeApiKey,
            location: location2,
            keywords: keyword,
            radius: 1e3,
            extensions: "all"
          };
          const signedParams = signRequest(params);
          const url = `${AMAP_API}/place/around?${signedParams}`;
          const response = await uni.request({
            url,
            method: "GET"
          });
          if (response.data.status === "1") {
            this.nearbyPOIs = response.data.pois.map((poi) => ({
              id: poi.id,
              name: poi.name,
              address: poi.address,
              location: poi.location,
              distance: poi.distance
            }));
          } else {
            throw new Error(response.data.info || "未知错误");
          }
        } catch (error) {
          formatAppLog("error", "at pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue:162", "搜索位置失败:", error);
          let errorMessage = "搜索位置失败，请稍后重试";
          if (error.message === "USERKEY_PLAT_NOMATCH") {
            errorMessage = "API密钥配置错误，请联系管理员";
          }
          uni.showToast({
            title: errorMessage,
            icon: "none"
          });
        }
      },
      handleSearch(event) {
        if (this.searchDebounceTimer) {
          clearTimeout(this.searchDebounceTimer);
        }
        this.searchDebounceTimer = setTimeout(() => {
          this.searchNearbyPOIs(event.detail.value);
        }, 500);
      },
      selectLocation(poi) {
        this.selectedPOI = poi;
        this.updateMarkers();
      },
      async handleMapTap(e2) {
        const { latitude, longitude } = e2.detail;
        try {
          const params = {
            key: gaodeApiKey,
            location: `${longitude},${latitude}`
          };
          const signedParams = signRequest(params);
          const url = `${AMAP_API}/geocode/regeo?${signedParams}`;
          const response = await uni.request({ url });
          if (response.data.status === "1") {
            const regeocode = response.data.regeocode;
            this.selectedPOI = {
              id: Date.now().toString(),
              name: regeocode.formatted_address,
              address: regeocode.addressComponent.street + regeocode.addressComponent.streetNumber,
              location: `${longitude},${latitude}`
            };
            this.updateMarkers();
          } else {
            throw new Error(response.data.info || "获取地址信息失败");
          }
        } catch (error) {
          formatAppLog("error", "at pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue:210", "获取地址信息失败:", error);
          uni.showToast({
            title: "获取地址信息失败，请重试",
            icon: "none"
          });
        }
      },
      handleComplete() {
        if (!this.selectedPOI) {
          uni.showToast({
            title: "请选择位置",
            icon: "none"
          });
          return;
        }
        const locationData = {
          latitude: parseFloat(this.selectedPOI.location.split(",")[1]),
          longitude: parseFloat(this.selectedPOI.location.split(",")[0]),
          name: this.selectedPOI.name,
          address: this.selectedPOI.address,
          type: "location"
        };
        formatAppLog("log", "at pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue:234", "LocationSharing: 发送位置数据", locationData);
        this.$emit("location-selected", locationData);
        this.$emit("close");
      },
      formatDistance(distance) {
        if (distance < 1e3) {
          return `${distance}米`;
        }
        return `${(distance / 1e3).toFixed(1)}千米`;
      },
      hideMessageInput() {
        this.$emit("hide-message-input", true);
        uni.$emit("hide-chat-input", true);
      },
      showMessageInput() {
        this.$emit("show-message-input");
      }
    }
  };
  function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "location-sharing" }, [
      vue.createCommentVNode(" 地图容器 "),
      vue.createElementVNode("view", { class: "map-container" }, [
        vue.createElementVNode("map", {
          id: "locationMap",
          class: "map",
          latitude: $data.currentLocation.latitude,
          longitude: $data.currentLocation.longitude,
          markers: $data.markers,
          scale: 16,
          "show-location": "",
          onTap: _cache[0] || (_cache[0] = (...args) => $options.handleMapTap && $options.handleMapTap(...args))
        }, null, 40, ["latitude", "longitude", "markers"])
      ]),
      vue.createCommentVNode(" 头部搜索栏和完成按钮 "),
      vue.createElementVNode("view", { class: "header" }, [
        vue.createElementVNode("view", { class: "search-bar" }, [
          vue.withDirectives(vue.createElementVNode(
            "input",
            {
              type: "text",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.searchKeyword = $event),
              placeholder: "搜索地点",
              onInput: _cache[2] || (_cache[2] = (...args) => $options.handleSearch && $options.handleSearch(...args))
            },
            null,
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vue.vModelText, $data.searchKeyword]
          ])
        ]),
        vue.createElementVNode("button", {
          class: "complete-btn",
          onClick: _cache[3] || (_cache[3] = (...args) => $options.handleComplete && $options.handleComplete(...args))
        }, "完成")
      ]),
      vue.createCommentVNode(" 位置列表 "),
      vue.createElementVNode("view", { class: "location-list" }, [
        vue.createElementVNode("scroll-view", {
          "scroll-y": "",
          class: "scroll-view"
        }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($data.nearbyPOIs, (poi, index) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                key: index,
                class: vue.normalizeClass(["location-item", { "location-item-selected": $data.selectedPOI && $data.selectedPOI.id === poi.id }]),
                onClick: ($event) => $options.selectLocation(poi)
              }, [
                vue.createElementVNode(
                  "view",
                  { class: "location-name" },
                  vue.toDisplayString(poi.name),
                  1
                  /* TEXT */
                ),
                vue.createElementVNode(
                  "view",
                  { class: "location-address" },
                  vue.toDisplayString(poi.address),
                  1
                  /* TEXT */
                ),
                poi.distance ? (vue.openBlock(), vue.createElementBlock(
                  "view",
                  {
                    key: 0,
                    class: "location-distance"
                  },
                  vue.toDisplayString($options.formatDistance(poi.distance)),
                  1
                  /* TEXT */
                )) : vue.createCommentVNode("v-if", true),
                $data.selectedPOI && $data.selectedPOI.id === poi.id ? (vue.openBlock(), vue.createElementBlock("view", {
                  key: 1,
                  class: "location-check"
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_0$3,
                    class: "check-icon"
                  })
                ])) : vue.createCommentVNode("v-if", true)
              ], 10, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])
    ]);
  }
  const LocationSharing = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$p], ["__scopeId", "data-v-5719cec1"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue"]]);
  const _sfc_main$p = {
    name: "ToggleVoiceButton",
    props: {
      isVoiceInputActive: {
        type: Boolean,
        required: true
      },
      isBurnAfterReadingMode: {
        type: Boolean,
        default: false
      }
    },
    emits: ["toggle-voice-input"],
    methods: {
      getButtonImage() {
        if (this.isBurnAfterReadingMode) {
          return this.isVoiceInputActive ? "/static/message/fire-键盘.png" : "/static/message/fire-语音.png";
        } else {
          return this.isVoiceInputActive ? "/static/message/键盘.png" : "/static/message/语音.png";
        }
      }
    }
  };
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("image", {
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("toggle-voice-input")),
      src: $options.getButtonImage(),
      class: "toggle-button"
    }, null, 8, ["src"]);
  }
  const ToggleVoiceButton = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$o], ["__scopeId", "data-v-4e00339e"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/ToggleVoiceButton.vue"]]);
  const _sfc_main$o = {
    name: "VoiceRecordButton",
    props: {
      isRecording: {
        type: Boolean,
        default: false
      },
      voiceStatus: {
        type: Object,
        default: () => ({
          status: "ready",
          duration: 0,
          volume: 0
        })
      },
      startVoiceRecord: {
        type: Function,
        required: true
      },
      stopVoiceRecord: {
        type: Function,
        required: true
      }
    },
    methods: {
      formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${String(minutes).padStart(2, "0")}:${String(remainingSeconds).padStart(2, "0")}`;
      },
      startRecording() {
        this.startVoiceRecord();
      },
      stopRecording() {
        this.stopVoiceRecord();
      }
    }
  };
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "voice-record-container" }, [
      vue.createElementVNode(
        "view",
        {
          onTouchstart: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $options.startRecording && $options.startRecording(...args), ["prevent"])),
          onTouchend: _cache[1] || (_cache[1] = vue.withModifiers((...args) => $options.stopRecording && $options.stopRecording(...args), ["prevent"])),
          onTouchcancel: _cache[2] || (_cache[2] = vue.withModifiers((...args) => $options.stopRecording && $options.stopRecording(...args), ["prevent"])),
          class: "record-button"
        },
        [
          vue.createElementVNode("text", { class: "record-text" }, "按住 说话")
        ],
        32
        /* NEED_HYDRATION */
      ),
      $props.isRecording ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "voice-overlay"
      }, [
        vue.createElementVNode("view", { class: "voice-popup" }, [
          vue.createElementVNode(
            "view",
            { class: "voice-time" },
            vue.toDisplayString($options.formatTime($props.voiceStatus.duration)),
            1
            /* TEXT */
          ),
          vue.createElementVNode("view", { class: "voice-hint" }, "松开 结束")
        ])
      ])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const VoiceInputButton = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$n], ["__scopeId", "data-v-595166a0"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/VoiceInputButton.vue"]]);
  const _sfc_main$n = {
    name: "TextInput",
    props: {
      modelValue: {
        type: String,
        default: ""
      }
    },
    emits: ["update:modelValue", "send"],
    methods: {
      // 更新输入值
      updateValue(event) {
        const value = event.detail != void 0 ? event.detail.value : event.target.value;
        formatAppLog("log", "at pages/message/ChatComponent/ChatInputAreaComponent/TextInput.vue:28", event.detail, "value");
        this.$emit("update:modelValue", value || "");
      },
      // 发送消息
      sendMessage() {
        this.$emit("send");
      }
    }
  };
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("input", {
      type: "text",
      class: "text-input",
      placeholder: "输入消息...",
      value: $props.modelValue,
      onInput: _cache[0] || (_cache[0] = (...args) => $options.updateValue && $options.updateValue(...args)),
      onConfirm: _cache[1] || (_cache[1] = (...args) => $options.sendMessage && $options.sendMessage(...args))
    }, null, 40, ["value"]);
  }
  const TextInput = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$m], ["__scopeId", "data-v-c73de84a"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/TextInput.vue"]]);
  const _sfc_main$m = {
    name: "AttachButton",
    emits: ["click"],
    props: {
      isBurnAfterReadingMode: {
        type: Boolean,
        default: false
      }
    }
  };
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "attach-button",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
    }, [
      vue.createElementVNode("image", {
        src: $props.isBurnAfterReadingMode ? "/static/message/fire-展开对话工具.png" : "/static/message/展开对话工具.png",
        class: "attach-icon"
      }, null, 8, ["src"])
    ]);
  }
  const AttachButton = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$l], ["__scopeId", "data-v-a6f5c486"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/AttachButton.vue"]]);
  const _sfc_main$l = {
    name: "SendButton",
    emits: ["click"],
    methods: {
      sendMessage() {
        this.$emit("click");
      }
    }
  };
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "send-button",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.sendMessage && $options.sendMessage(...args))
    }, [
      vue.createElementVNode("text", { class: "send-text" }, "发送")
    ]);
  }
  const SendButton = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$k], ["__scopeId", "data-v-ab1b8027"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/SendButton.vue"]]);
  function afterAudioRecord() {
    getApp().globalData.audioRecording = false;
  }
  function beforeAudioRecordOrPlay(type) {
    const audioPlaying = getApp().globalData.audioPlaying;
    const audioRecording = getApp().globalData.audioRecording;
    if (audioPlaying || audioRecording) {
      uni.showToast({
        title: audioPlaying ? "请先暂停其他音频播放" : "请先结束其他录音",
        icon: "none"
      });
      return false;
    } else {
      if (type === "play") {
        getApp().globalData.audioPlaying = true;
      } else if (type === "record") {
        getApp().globalData.audioRecording = true;
      } else {
        throw new Error("type Error", type);
      }
      return true;
    }
  }
  function useVoiceInput(onFileSelected) {
    const isRecording = vue.ref(false);
    const recordAuth = vue.ref(false);
    const duration = vue.ref(6e5);
    const tempFilePath = vue.ref("");
    const time = vue.ref(0);
    const voiceAllTime = vue.ref(0);
    const playStatus = vue.ref(0);
    const recordImg = vue.ref("/static/images/icon_record.png");
    const voiceStatus = vue.reactive({
      status: "ready",
      duration: 0,
      volume: 0
    });
    let recorderManager2 = null;
    let timer = null;
    vue.onMounted(() => {
      initRecorderManager();
    });
    vue.onUnmounted(() => {
      if (recorderManager2) {
        recorderManager2.onStop(() => {
        });
        recorderManager2.onError(() => {
        });
      }
      stopTimer();
    });
    function initRecorderManager() {
      if (typeof uni !== "undefined" && uni.getRecorderManager) {
        recorderManager2 = uni.getRecorderManager();
        if (recorderManager2) {
          recorderManager2.onStart((e2) => onStart(e2));
          recorderManager2.onPause((e2) => onPause(e2));
          recorderManager2.onResume((e2) => onResume(e2));
          recorderManager2.onInterruptionBegin((e2) => onInterruptionBegin(e2));
          recorderManager2.onInterruptionEnd((e2) => onInterruptionEnd(e2));
          recorderManager2.onError((e2) => onError(e2));
          recorderManager2.onStop((e2) => onStop(e2));
          formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:80", "录音管理器初始化成功");
        } else {
          formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:82", "获取录音管理器实例失败");
        }
      } else {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:85", "当前平台不支持录音管理器");
      }
    }
    function startVoiceRecord() {
      if (!recorderManager2) {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:92", "录音管理器未初始化");
        uni.showToast({
          title: "录音功能初始化失败",
          icon: "none"
        });
        return;
      }
      if (recordImg.value === "/static/images/icon_record.png" && beforeAudioRecordOrPlay("record")) {
        resetTimer();
        recorderManager2.start({
          duration: duration.value,
          format: "mp3",
          sampleRate: 22050
        });
      } else if (recordImg.value === "/static/images/icon_recording.png") {
        stopVoiceRecord();
      }
    }
    function stopVoiceRecord() {
      if (!recorderManager2) {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:116", "录音管理器未初始化");
        return;
      }
      recorderManager2.stop();
      afterAudioRecord();
    }
    function onStart(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:126", "开始录音", e2);
      recordImg.value = "/static/images/icon_recording.png";
      isRecording.value = true;
      voiceStatus.status = "recording";
      startTimer();
    }
    function onPause(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:135", "录音暂停", e2);
      afterAudioRecord();
      stopTimer();
    }
    function onResume(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:142", "录音恢复", e2);
      startTimer();
    }
    function onStop(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:148", "录音结束", e2);
      recordImg.value = "/static/images/icon_record.png";
      isRecording.value = false;
      voiceStatus.status = "ready";
      tempFilePath.value = e2.tempFilePath;
      time.value = Math.round(e2.duration / 1e3);
      voiceAllTime.value = time.value;
      voiceStatus.duration = time.value;
      stopTimer();
      uploadMp3Action(e2);
    }
    function onInterruptionBegin(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:162", "录音因为受到系统占用而被中断", e2);
      stopTimer();
    }
    function onInterruptionEnd(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:168", "录音中断结束", e2);
      startTimer();
    }
    function onError(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:174", "录音错误", e2);
      uni.showToast({
        title: "录音失败，请重试",
        icon: "none"
      });
      stopTimer();
      resetTimer();
    }
    function startTimer() {
      if (!timer) {
        timer = setInterval(() => {
          time.value++;
          voiceStatus.duration = time.value;
        }, 1e3);
      }
    }
    function stopTimer() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
    }
    function resetTimer() {
      stopTimer();
      time.value = 0;
      voiceStatus.duration = 0;
    }
    function uploadMp3Action(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:210", "上传MP3，完整的事件对象:", JSON.stringify(e2));
      if (!e2 || !e2.tempFilePath) {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:213", "录音文件路径缺失:", e2);
        uni.showToast({
          title: "录音文件保存失败，请重试",
          icon: "none"
        });
        return;
      }
      const fileInfo = {
        type: "voice",
        path: e2.tempFilePath,
        duration: time.value,
        size: e2.fileSize,
        fromVoiceInput: true
      };
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:229", "准备发送的文件信息:", JSON.stringify(fileInfo));
      onFileSelected(fileInfo);
    }
    return {
      isRecording,
      recordAuth,
      duration,
      tempFilePath,
      time,
      voiceAllTime,
      playStatus,
      voiceStatus,
      recordImg,
      startVoiceRecord,
      stopVoiceRecord
    };
  }
  function useAttachmentHandling(emit, props) {
    const showLocationSharing = vue.ref(false);
    const isBurnAfterReadingMode = vue.ref(false);
    const attachItem = (action, data) => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:12", "附件项被选择:", action);
      switch (action) {
        case "file":
          chooseAndSendFile();
          break;
        case "album":
          chooseAndSendPhoto();
          break;
        case "burn-after-reading":
          toggleBurnAfterReadingMode();
          break;
        case "camera":
          takePhoto();
          break;
        case "location":
          openLocationSharing();
          break;
        case "video-call":
          emit("video-call", action);
          break;
        default:
          emit("attach", action);
      }
      if (action !== "location" && action !== "file" && action !== "burn-after-reading") {
        emit("toggle-attach-menu", false);
      }
    };
    const chooseAndSendPhoto = async () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:45", "选择照片方法被调用");
      try {
        const imageRes = await new Promise((resolve, reject) => {
          uni.chooseImage({
            count: 1,
            success: (res) => {
              formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:51", "图片选择成功:", JSON.stringify(res));
              resolve(res);
            },
            fail: (err) => {
              formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:55", "图片选择失败:", err);
              reject(err);
            }
          });
        });
        const tempFilePath = imageRes.tempFilePaths[0];
        const fileName = tempFilePath.split("/").pop();
        formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:63", "选择的图片名:", fileName);
        emit("file-selected", {
          type: "image",
          path: tempFilePath,
          name: fileName,
          recipientId: props.recipientId,
          missionId: props.missionId,
          isBurnAfterReading: isBurnAfterReadingMode.value
        });
        emit("toggle-attach-menu", false);
      } catch (error) {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:75", "选择图片时出错:", error);
        showToast("选择失败，请重试");
      }
    };
    const takePhoto = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:82", "拍摄照片");
      uni.chooseImage({
        count: 1,
        sourceType: ["camera"],
        success: (res) => {
          const tempFilePath = res.tempFilePaths[0];
          emit("file-selected", {
            type: "image",
            path: tempFilePath,
            name: "camera_photo.jpg",
            recipientId: props.recipientId,
            missionId: props.missionId,
            isBurnAfterReading: isBurnAfterReadingMode.value
          });
        },
        fail: (err) => {
          formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:98", "拍照失败:", err);
          showToast("拍照失败");
        }
      });
    };
    const openLocationSharing = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:106", "打开位置分享");
      showLocationSharing.value = true;
      emit("toggle-attach-menu", false);
    };
    const closeLocationSharing = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:113", "关闭位置分享");
      showLocationSharing.value = false;
    };
    const handleLocationSelected = (location2) => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:119", "位置被选择:", JSON.stringify(location2));
      emit("send-message", {
        type: "location",
        content: location2,
        missionId: props.missionId,
        isBurnAfterReading: isBurnAfterReadingMode.value
      });
      closeLocationSharing();
    };
    const chooseAndSendFile = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:131", "选择文件");
      chooseFileApp();
    };
    const chooseFileApp = () => {
      plus.io.resolveLocalFileSystemURL(
        "_doc/",
        (entry) => {
          entry.createReader().readEntries(
            (entries) => {
              const fileList = entries.filter((entry2) => !entry2.isDirectory);
              if (fileList.length > 0) {
                const selectedFile = fileList[0];
                handleFileSelected(selectedFile.fullPath, selectedFile.name, "file");
              } else {
                showToast("没有可选择的文件");
              }
            },
            (e2) => {
              formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:160", "读取文件夹失败:", e2);
              showToast("读取文件失败，请重试");
            }
          );
        },
        (e2) => {
          formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:166", "解析文件系统URL失败:", e2);
          showToast("无法访问文件系统，请重试");
        }
      );
    };
    const handleFileSelected = (tempFilePath, fileName, type) => {
      emit("file-selected", {
        type,
        path: tempFilePath,
        name: fileName,
        recipientId: props.recipientId,
        missionId: props.missionId,
        isBurnAfterReading: isBurnAfterReadingMode.value
      });
      emit("toggle-attach-menu", false);
    };
    const toggleBurnAfterReadingMode = () => {
      isBurnAfterReadingMode.value = !isBurnAfterReadingMode.value;
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:206", "阅后即焚模式已切换:", isBurnAfterReadingMode.value);
      emit("toggle-burn-after-reading", isBurnAfterReadingMode.value);
    };
    const showToast = (message) => {
      uni.showToast({
        title: message,
        icon: "none"
      });
    };
    return {
      showLocationSharing,
      attachItem,
      handleFileSelected,
      chooseAndSendFile,
      openLocationSharing,
      closeLocationSharing,
      handleLocationSelected,
      isBurnAfterReadingMode,
      toggleBurnAfterReadingMode
    };
  }
  function useMessageSending(newMessage, emit, props) {
    const sendMessage = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useMessageSending.js:5", "sendMessage 方法被调用");
      if (typeof newMessage.value !== "string" || !newMessage.value.trim()) {
        formatAppLog("log", "at pages/message/ChatComponent/composables/useMessageSending.js:8", "消息为空或不是字符串，不发送");
        return;
      }
      const messageData = {
        content: newMessage.value,
        type: "text",
        recipientId: props.recipientId,
        missionId: props.missionId
      };
      formatAppLog("log", "at pages/message/ChatComponent/composables/useMessageSending.js:19", "准备发送消息:", messageData);
      emit("send-message", messageData);
      newMessage.value = "";
    };
    return {
      sendMessage
    };
  }
  const _sfc_main$k = {
    name: "ChatInputArea",
    components: {
      AttachmentMenu,
      LocationSharing,
      ToggleVoiceButton,
      VoiceInputButton,
      TextInput,
      AttachButton,
      SendButton
    },
    props: {
      modelValue: {
        type: Boolean,
        default: false
      },
      recipientId: {
        type: String,
        required: true
      },
      missionId: {
        type: [String, Array],
        required: true
      },
      initialBurnAfterReadingMode: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: "请输入消息"
      }
    },
    emits: ["send-message", "update:modelValue", "attach", "video-call", "file-selected", "toggle-burn-after-reading"],
    setup(props, { emit }) {
      const newMessage = vue.ref("");
      const showLocationSharing = vue.ref(false);
      const isVoiceInputActive = vue.ref(false);
      const isBurnAfterReadingMode = vue.ref(props.initialBurnAfterReadingMode);
      const isAttachMenuVisible = vue.ref(false);
      const isSending = vue.ref(false);
      const inputPlaceholder = vue.computed(() => {
        return isBurnAfterReadingMode.value ? "阅后即焚模式已开启" : props.placeholder;
      });
      const handleVoiceFileSelected = (fileInfo) => {
        if (fileInfo && typeof fileInfo === "object" && fileInfo.fromVoiceInput) {
          if (!fileInfo.path) {
            uni.showToast({
              title: "语音文件保存失败，请重试",
              icon: "none"
            });
            return;
          }
          emit("file-selected", fileInfo);
        }
      };
      const {
        isRecording,
        recordAuth,
        duration,
        voiceStatus,
        startVoiceRecord,
        stopVoiceRecord
      } = useVoiceInput(handleVoiceFileSelected);
      const {
        attachItem: handleAttachItem,
        handleFileSelected,
        openLocationSharing,
        closeLocationSharing,
        handleLocationSelected,
        showLocationSharing: locationSharingState,
        isBurnAfterReadingMode: burnMode,
        toggleBurnAfterReadingMode
      } = useAttachmentHandling(emit, props);
      const { sendMessage: sendMessageHandler } = useMessageSending(newMessage, emit, props);
      const sendMessage = async () => {
        if (isSending.value || newMessage.value.trim().length === 0)
          return;
        isSending.value = true;
        try {
          await sendMessageHandler();
          newMessage.value = "";
        } catch (error) {
          formatAppLog("log", "at pages/message/ChatComponent/ChatInputArea.vue:171", "发送消息失败");
        } finally {
          isSending.value = false;
        }
        closeAttachMenu();
      };
      const toggleVoiceInput = () => {
        isVoiceInputActive.value = !isVoiceInputActive.value;
        closeAttachMenu();
      };
      const toggleAttachMenu = () => {
        isAttachMenuVisible.value = !isAttachMenuVisible.value;
        emit("update:modelValue", isAttachMenuVisible.value);
      };
      const closeAttachMenu = () => {
        isAttachMenuVisible.value = false;
        emit("update:modelValue", false);
      };
      vue.watch(() => props.recipientId, (newVal) => {
        if (!newVal) {
          showLocationSharing.value = false;
        }
      });
      vue.watch(locationSharingState, (newVal) => {
        showLocationSharing.value = newVal;
      });
      vue.watch(burnMode, (newVal) => {
        isBurnAfterReadingMode.value = newVal;
        emit("toggle-burn-after-reading", newVal);
      });
      vue.watch(isBurnAfterReadingMode, (newVal) => {
        emit("toggle-burn-after-reading", newVal);
      });
      vue.watch(() => props.initialBurnAfterReadingMode, (newVal) => {
        isBurnAfterReadingMode.value = newVal;
      });
      vue.watch(() => props.modelValue, (newValue) => {
        isAttachMenuVisible.value = newValue;
      });
      return {
        newMessage,
        showLocationSharing,
        isVoiceInputActive,
        isRecording,
        recordAuth,
        duration,
        voiceStatus,
        toggleVoiceInput,
        startVoiceRecord,
        stopVoiceRecord,
        sendMessage,
        toggleAttachMenu,
        closeAttachMenu,
        handleAttachItem,
        handleFileSelected,
        openLocationSharing,
        closeLocationSharing,
        handleLocationSelected,
        isBurnAfterReadingMode,
        toggleBurnAfterReadingMode,
        isAttachMenuVisible,
        inputPlaceholder,
        isSending
      };
    }
  };
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_attachment_menu = vue.resolveComponent("attachment-menu");
    const _component_toggle_voice_button = vue.resolveComponent("toggle-voice-button");
    const _component_voice_input_button = vue.resolveComponent("voice-input-button");
    const _component_text_input = vue.resolveComponent("text-input");
    const _component_attach_button = vue.resolveComponent("attach-button");
    const _component_send_button = vue.resolveComponent("send-button");
    const _component_location_sharing = vue.resolveComponent("location-sharing");
    return vue.openBlock(), vue.createElementBlock("view", { class: "chat-input-wrapper" }, [
      vue.createElementVNode("view", { class: "chat-content" }, [
        vue.createCommentVNode(" 附件菜单 "),
        $setup.isAttachMenuVisible ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "attachment-menu"
        }, [
          vue.createVNode(_component_attachment_menu, {
            onAttach: $setup.handleAttachItem,
            onClose: $setup.closeAttachMenu
          }, null, 8, ["onAttach", "onClose"])
        ])) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" 输入区域 "),
        vue.createElementVNode("view", { class: "input-container" }, [
          vue.createElementVNode("view", { class: "chat-input" }, [
            vue.createCommentVNode(" 语音/键盘切换按钮 "),
            vue.createVNode(_component_toggle_voice_button, {
              "is-voice-input-active": $setup.isVoiceInputActive,
              "is-burn-after-reading-mode": $setup.isBurnAfterReadingMode,
              onToggleVoiceInput: $setup.toggleVoiceInput
            }, null, 8, ["is-voice-input-active", "is-burn-after-reading-mode", "onToggleVoiceInput"]),
            vue.createCommentVNode(" 语音录音按钮 "),
            $setup.isVoiceInputActive ? (vue.openBlock(), vue.createBlock(_component_voice_input_button, {
              key: 0,
              "is-recording": $setup.isRecording,
              "voice-status": $setup.voiceStatus,
              "start-voice-record": $setup.startVoiceRecord,
              "stop-voice-record": $setup.stopVoiceRecord,
              class: "input-item"
            }, null, 8, ["is-recording", "voice-status", "start-voice-record", "stop-voice-record"])) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" 文本输入框 "),
                vue.createVNode(_component_text_input, {
                  modelValue: $setup.newMessage,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.newMessage = $event),
                  onSend: $setup.sendMessage,
                  placeholder: $setup.inputPlaceholder,
                  disabled: $setup.isSending,
                  class: "input-item"
                }, null, 8, ["modelValue", "onSend", "placeholder", "disabled"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )),
            vue.createCommentVNode(" 附件按钮 "),
            vue.createVNode(_component_attach_button, {
              onClick: $setup.toggleAttachMenu,
              "is-burn-after-reading-mode": $setup.isBurnAfterReadingMode
            }, null, 8, ["onClick", "is-burn-after-reading-mode"]),
            vue.createCommentVNode(" 发送按钮 "),
            !$setup.isVoiceInputActive && ($setup.isAttachMenuVisible || $setup.newMessage.trim().length > 0) ? (vue.openBlock(), vue.createBlock(_component_send_button, {
              key: 2,
              onClick: $setup.sendMessage,
              disabled: $setup.isSending
            }, null, 8, ["onClick", "disabled"])) : vue.createCommentVNode("v-if", true)
          ])
        ])
      ]),
      vue.createCommentVNode(" 位置共享组件 "),
      $setup.showLocationSharing ? (vue.openBlock(), vue.createBlock(_component_location_sharing, {
        key: 0,
        "recipient-id": $props.recipientId,
        "mission-id": $props.missionId,
        onLocationSelected: $setup.handleLocationSelected,
        onClose: $setup.closeLocationSharing
      }, null, 8, ["recipient-id", "mission-id", "onLocationSelected", "onClose"])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const ChatInputArea = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j], ["__scopeId", "data-v-e8a570ad"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ChatInputArea.vue"]]);
  const _sfc_main$j = {
    name: "ScrollToBottomButton",
    props: {
      show: {
        type: Boolean,
        default: false
      }
    }
  };
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return $props.show ? (vue.openBlock(), vue.createElementBlock("view", {
      key: 0,
      class: "scroll-to-bottom",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
    }, [
      vue.createElementVNode("text", { class: "scroll-to-bottom-icon" }, "↓")
    ])) : vue.createCommentVNode("v-if", true);
  }
  const ScrollToBottomButton = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i], ["__scopeId", "data-v-92969997"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/ScrollToBottomButton.vue"]]);
  const _sfc_main$i = {
    name: "LoadingAnimation"
  };
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", { class: "loading-animation" }, [
      vue.createElementVNode("div", { class: "spinner" }),
      vue.createElementVNode("p", null, "正在加载消息...")
    ]);
  }
  const LoadingAnimation$1 = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$h], ["__scopeId", "data-v-c7ff4daf"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/LoadingAnimation.vue"]]);
  const usePeerStore = defineStore("peerStore", {
    state() {
      return {
        /**
         * 本地对等体对象
         */
        localPeer: void 0,
        /**
         * 正在通话的数据连接对象
         */
        dataConnection: void 0,
        /**
         * 正在通话的媒体连接对象
         */
        mediaConnection: void 0,
        /**
         * 是否激活通知
         */
        activateNotification: false,
        /**
         * 视频通话指令枚举值
         */
        instruction: {
          /**
           * 请求视频通话
           */
          request: 1,
          /**
           * 拒绝视频通话
           */
          reject: 2,
          /**
           * 接受视频通话
           */
          accept: 3,
          /**
           * 取消视频通话
           */
          cancel: 4,
          /**
           * 正常挂断
           */
          ringOff: 5,
          /**
           * 忙碌挂断
           */
          busy: 6
        }
      };
    }
  });
  const useFriendStore = defineStore("friendStore", {
    state() {
      return {
        onlineList: []
      };
    }
  });
  const useGroupStore = defineStore("group", () => {
    const state = vue.reactive({
      groupInfo: null
    });
    function setGroupInfo(groupData) {
      state.groupInfo = groupData;
    }
    function clearGroupInfo() {
      state.groupInfo = null;
    }
    function getGroupInfo() {
      return { ...state.groupInfo };
    }
    return { state, setGroupInfo, clearGroupInfo, getGroupInfo };
  });
  function useChatInitialization() {
    vue.ref(null);
    const userStore = useUserStore();
    const groupStore = useGroupStore();
    const fetchAndStoreGroupInfo = async (groupId) => {
      try {
        const response = await getGroupBasicInfo(groupId);
        if (response.code === 200) {
          const groupInfo = response.data;
          groupStore.setGroupInfo({
            id: groupInfo.id,
            groupName: groupInfo.groupName,
            groupMembers: groupInfo.groupMembers
          });
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:23", "获取群组信息失败:", response.msg);
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:26", "获取群组信息时发生错误:", JSON.stringify(error));
      }
    };
    const goBack = () => {
      uni.navigateBack({
        success: () => {
          uni.$emit("updateTabBarActiveTab", 1);
        },
        fail: (err) => {
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:37", "返回失败:", JSON.stringify(err));
          uni.reLaunch({
            url: "/pages/tabBar/tabBar",
            success: () => {
              uni.$emit("updateTabBarActiveTab", 1);
            }
          });
        }
      });
    };
    const setupChatInfo = async (eventChannel, vm) => {
      if (!eventChannel) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:51", "事件通道未定义");
        return;
      }
      eventChannel.on("chatInfo", async (data) => {
        if (!data || !data.chatInfo) {
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:57", "接收到的聊天信息无效:", JSON.stringify(data));
          return;
        }
        try {
          vm.chatInfo.value = {
            ...vm.chatInfo.value,
            ...data.chatInfo
          };
          if (!vm.chatInfo.value.missionId) {
            vm.chatInfo.value.missionId = userStore.state.missionId.toString();
          } else if (Array.isArray(vm.chatInfo.value.missionId)) {
            vm.chatInfo.value.missionId = vm.chatInfo.value.missionId.join(",");
          }
          if (vm.chatInfo.value.type === "group") {
            await fetchAndStoreGroupInfo(vm.chatInfo.value.id);
          }
          uni.setStorageSync("chatQuery", JSON.stringify(vm.chatInfo.value));
          vm.loadHistoryMessages();
          vm.$nextTick(() => {
            vm.scrollToBottom();
          });
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:89", "聊天初始化:", {
            聊天ID: vm.chatInfo.value.id,
            聊天类型: vm.chatInfo.value.type,
            任务ID: vm.chatInfo.value.missionId
          });
        } catch (error) {
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:95", "处理 chatInfo 时发生错误:", JSON.stringify(error));
        }
      });
    };
    return {
      goBack,
      setupChatInfo
    };
  }
  function useMessageHandling(chatInfo, list, currentFrom, currentTo, hasMoreMessages, scrollToBottom) {
    const userStore = useUserStore();
    const groupStore = useGroupStore();
    let isLoadingHistory = false;
    let lastLoadTime = 0;
    const LOAD_COOLDOWN = 5e3;
    const sendMessage = async (message) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:21", "开始发送消息:", message);
      if (message.content && chatInfo.value && chatInfo.value.id) {
        try {
          let response;
          const messageData = {
            message: typeof message.content === "object" ? JSON.stringify(message.content) : message.content,
            recipientId: chatInfo.value.id,
            messageType: message.type || "text",
            missionId: chatInfo.value.missionId,
            isPosition: message.type === "location",
            isSelfDestruct: chatInfo.value.isBurnAfterReadingMode
          };
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:34", "准备发送消息数据:", messageData);
          if (chatInfo.value.type === "group") {
            formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:37", "发送群聊消息");
            response = await sendGroupMessage({
              ...messageData,
              isGroupAnnouncement: false
            });
          } else {
            formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:43", "发送私聊消息");
            response = await sendMessageToUser(messageData);
          }
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:47", "消息发送响应:", response);
          if (response.code === 200) {
            const sentMessage = {
              ...response.data,
              selfDestruct: response.data.selfDestruct,
              content: message.content,
              userType: "self",
              timestamp: /* @__PURE__ */ new Date(),
              type: message.type || "text",
              messageType: message.type === "text" ? "MESSAGE" : message.type.toUpperCase()
            };
            handleMessageSent(sentMessage);
            await updateMessageList();
            vue.nextTick(() => {
              scrollToBottom();
            });
          } else {
            throw new Error(response.msg || "发送消息失败");
          }
        } catch (error) {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:68", "发送消息失败:", error);
        }
      } else {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:71", "消息内容为空或 chatInfo 未正确初始化");
      }
    };
    const handleMessageSent = (sentMessage) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:76", "添加已发送消息到列表");
      list.value.push(sentMessage);
    };
    const handleMessageFailed = (failedMessage) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:81", "处理消息发送失败:", failedMessage);
    };
    const loadHistoryMessages = async (isLoadingMore = false, newFrom = null, newTo = null) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:86", "开始加载历史消息");
      const now2 = Date.now();
      if (isLoadingHistory || now2 - lastLoadTime < LOAD_COOLDOWN) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:89", "跳过加载历史消息：正在加载或冷却中");
        return;
      }
      isLoadingHistory = true;
      lastLoadTime = now2;
      if (!chatInfo.value || !chatInfo.value.id || !chatInfo.value.missionId) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:97", "聊天信息不完整，无法加载历史消息");
        hasMoreMessages.value = false;
        isLoadingHistory = false;
        return false;
      }
      const from = newFrom !== null ? newFrom : currentFrom.value;
      const to = newTo !== null ? newTo : currentTo.value;
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:106", "加载历史消息参数:", { from, to, isLoadingMore });
      try {
        let response;
        if (chatInfo.value.type === "group") {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:111", "加载群聊历史消息");
          response = await getGroupChatMessages({
            opponentId: chatInfo.value.id,
            from,
            to
          });
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:118", "加载私聊历史消息");
          response = await getHistoryChatMessages({
            opponentId: chatInfo.value.id,
            from,
            to,
            missionId: chatInfo.value.missionId
          });
        }
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:127", "历史消息加载响应:", response);
        if (response.code === 200) {
          let newMessages;
          if (chatInfo.value.type === "group") {
            newMessages = response.data.groupMessageVOS.reverse().map((msg) => mapGroupMessage(msg));
          } else {
            newMessages = response.data.messageVOList.reverse().map((msg) => mapPrivateMessage(msg));
          }
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:137", "新消息数量:", newMessages.length);
          if (isLoadingMore) {
            formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:140", "添加新消息到列表前端");
            list.value = [...newMessages, ...list.value];
          } else {
            formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:143", "替换整个消息列表");
            list.value = newMessages;
          }
          hasMoreMessages.value = newMessages.length === to - from + 1;
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:148", "是否有更多消息:", hasMoreMessages.value);
          currentFrom.value = from;
          currentTo.value = to;
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:153", "更新后的消息列表长度:", list.value.length);
          if (!isLoadingMore) {
            vue.nextTick(() => {
              scrollToBottom();
            });
          }
          return true;
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:163", "加载历史消息失败:", response.msg);
          hasMoreMessages.value = false;
          uni.showToast({
            title: "加载历史消息失败",
            icon: "none"
          });
          return false;
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:172", "加载历史消息出错:", error);
        hasMoreMessages.value = false;
        uni.showToast({
          title: "网络错误，请稍后重试",
          icon: "none"
        });
        return false;
      } finally {
        isLoadingHistory = false;
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:181", "历史消息加载完成，消息列表:", list.value);
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:182", "历史消息加载完成");
      }
    };
    const updateMessageList = async () => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:187", "开始更新消息列表");
      if (isLoadingHistory) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:189", "正在加载历史消息，跳过更新");
        return;
      }
      try {
        const latestMessageId = list.value.length > 0 ? list.value[list.value.length - 1].id : null;
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:195", "最新消息ID:", latestMessageId);
        let response;
        if (chatInfo.value.type === "group") {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:199", "更新群聊消息列表");
          response = await getGroupChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            // 增加获取的消息数量
            lastMessageId: latestMessageId
          });
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:207", "更新私聊消息列表");
          response = await getHistoryChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            // 增加获取的消息数量
            missionId: chatInfo.value.missionId,
            lastMessageId: latestMessageId
          });
        }
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:217", "更新消息列表响应:", response);
        if (response.code === 200) {
          let newMessages;
          if (chatInfo.value.type === "group") {
            newMessages = response.data.groupMessageVOS.reverse().map((msg) => mapGroupMessage(msg));
          } else {
            newMessages = response.data.messageVOList.reverse().map((msg) => mapPrivateMessage(msg));
          }
          const mergedMessages = [...list.value, ...newMessages];
          const uniqueMessages = Array.from(new Map(mergedMessages.map((item) => [item.id, item])).values());
          list.value = uniqueMessages.sort((a2, b2) => new Date(a2.timestamp) - new Date(b2.timestamp));
          vue.nextTick(() => {
            scrollToBottom();
          });
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:236", "没有新消息或获取失败");
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:239", "更新消息列表出错:", error);
      }
    };
    const mapPrivateMessage = (msg) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:244", "映射私聊消息:", msg);
      let content = msg.message;
      let type = msg.messageType.toLowerCase();
      if (content === null) {
        content = "";
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:250", "警告: 消息内容为空", msg);
      }
      if (type === "position") {
        try {
          content = JSON.parse(msg.message);
          type = "location";
        } catch (e2) {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:258", "解析位置数据失败:", e2);
        }
      } else if (type === "image") {
        content = msg.previewUrl || msg.message;
      } else if (type === "text" && msg.message.toLowerCase().endsWith(".txt")) {
        type = "file";
      } else if (type === "audio" || type === "voice_message") {
        content = msg.previewUrl || msg.message;
      }
      const mappedMessage = {
        id: msg.id,
        content,
        userType: msg.senderId === chatInfo.value.id ? "other" : "self",
        avatar: (() => {
          if (msg.senderId === chatInfo.value.id) {
            return chatInfo.value.avatar && chatInfo.value.avatar[0] ? chatInfo.value.avatar[0] : "";
          } else {
            const userInfo = userStore.state.userInfo;
            return userInfo && userInfo.avatarUrl ? userInfo.avatarUrl : chatInfo.value._selfAvatar || "";
          }
        })(),
        timestamp: new Date(msg.sendTime),
        type,
        isRead: msg.isRead,
        messageType: msg.messageType,
        selfDestruct: msg.selfDestruct
      };
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:287", "映射后的私聊消息:", mappedMessage);
      return mappedMessage;
    };
    const mapGroupMessage = (msg) => {
      let content = msg.message;
      let type = msg.messageType.toLowerCase();
      if (content === null) {
        content = "";
      }
      if (type === "position") {
        try {
          content = JSON.parse(msg.message);
          type = "location";
        } catch (e2) {
        }
      } else if (type === "image") {
        content = msg.previewUrl || msg.message;
      } else if (type === "text" && msg.message.toLowerCase().endsWith(".txt")) {
        type = "file";
      } else if (type === "audio" || type === "voice_message") {
        content = msg.previewUrl || msg.message;
      }
      const groupInfo = groupStore.state.groupInfo;
      let avatar = chatInfo.value._selfAvatar || "";
      let senderName = "未知用户";
      if (groupInfo && groupInfo.groupMembers) {
        const sender = groupInfo.groupMembers.find((member) => member.userId === msg.senderId);
        if (sender) {
          avatar = sender.avatarUrl || "";
          senderName = sender.userName || "未知用户";
        }
      }
      const mappedMessage = {
        id: msg.id,
        content,
        userType: userStore.state.id === msg.senderId ? "self" : "other",
        avatar,
        timestamp: new Date(msg.sendTime),
        type,
        isRead: Array.isArray(msg.groupMessageUserReadVO) && msg.groupMessageUserReadVO.some((user) => user.userId === chatInfo.value.id && user.isRead),
        messageType: msg.messageType,
        selfDestruct: msg.selfDestruct,
        senderName,
        senderId: msg.senderId,
        groupMessageUserReadVO: Array.isArray(msg.groupMessageUserReadVO) ? msg.groupMessageUserReadVO : []
      };
      return mappedMessage;
    };
    const handleFileSelected = async (fileInfo) => {
      var _a, _b;
      if (!fileInfo || typeof fileInfo !== "object") {
        uni.showToast({
          title: "文件信息无效，请重试",
          icon: "none"
        });
        return;
      }
      if (!fileInfo.path) {
        uni.showToast({
          title: "文件路径缺失，请重试",
          icon: "none"
        });
        return;
      }
      try {
        const response = await sendFilesToUser({
          files: [fileInfo.path],
          isGroup: chatInfo.value.type === "group",
          isSelfDestruct: chatInfo.value.isBurnAfterReadingMode || false,
          latitude: ((_a = chatInfo.value.currentLocation) == null ? void 0 : _a.latitude) || "0",
          longitude: ((_b = chatInfo.value.currentLocation) == null ? void 0 : _b.longitude) || "0",
          missionId: chatInfo.value.missionId,
          receptionId: chatInfo.value.id,
          voiceMessage: fileInfo.fromVoiceInput || false
        });
        if (response.code === 200) {
          await updateMessageList();
          vue.nextTick(() => {
            scrollToBottom();
          });
        } else {
          throw new Error(response.msg || "发送文件消息失败");
        }
      } catch (error) {
        uni.showToast({
          title: "发送失败，请重试",
          icon: "none"
        });
      }
    };
    const handleMessageDeleted = (messageId) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:392", "处理消息删除:", messageId);
      const index = list.value.findIndex((msg) => msg.id === messageId);
      if (index !== -1) {
        list.value.splice(index, 1);
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:396", "消息已从列表中删除");
      } else {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:398", "未找到要删除的消息");
      }
    };
    const getCurrentLocation = () => {
      return new Promise((resolve) => {
        uni.getLocation({
          type: "gcj02",
          success: (res) => {
            resolve({
              latitude: res.latitude.toString(),
              longitude: res.longitude.toString()
            });
          },
          fail: () => {
            Toast({
              message: "获取位置失败，使用默认位置",
              type: "fail"
            });
            resolve({
              latitude: "0",
              longitude: "0"
            });
          },
          timeout: 2e3
        });
      });
    };
    formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:425", "消息处理模块初始化完成");
    return {
      getCurrentLocation,
      sendMessage,
      handleMessageFailed,
      loadHistoryMessages,
      updateMessageList,
      handleFileSelected,
      handleMessageDeleted
    };
  }
  const throttle = (func, delay) => {
    let lastCall = 0;
    return function(...args) {
      const now2 = (/* @__PURE__ */ new Date()).getTime();
      if (now2 - lastCall < delay)
        return;
      lastCall = now2;
      return func.apply(this, args);
    };
  };
  function useUiInteractions({
    messageListRef,
    isScrolledToBottom,
    showScrollToBottom,
    showNewMessageTip,
    hasNewMessages,
    isLoading,
    currentFrom,
    currentTo,
    loadHistoryMessages,
    showAttachMenu,
    hasMoreMessages
  }) {
    const messageList = vue.ref([]);
    const isNearTop = vue.ref(false);
    const scrollThreshold = 100;
    const isInitialized = vue.ref(false);
    const loadMoreMessages = async () => {
      formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:33", "开始加载更多消息");
      if (!hasMoreMessages.value || !messageListRef.value || isLoading.value) {
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:35", "无法加载更多消息:", {
          hasMoreMessages: hasMoreMessages.value,
          messageListRef: !!messageListRef.value,
          isLoading: isLoading.value
        });
        return;
      }
      isLoading.value = true;
      try {
        const oldScrollHeight = messageListRef.value.scrollHeight;
        await loadHistoryMessages(true, currentFrom.value - 10, currentFrom.value);
        await vue.nextTick();
        const newScrollHeight = messageListRef.value.scrollHeight;
        const heightDifference = newScrollHeight - oldScrollHeight;
        if (heightDifference > 0) {
          messageListRef.value.scrollTop = heightDifference;
        }
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:55", "加载更多消息完成:", { 高度差: heightDifference });
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:57", "加载更多消息时出错:", error);
      } finally {
        isLoading.value = false;
      }
    };
    const onScroll = throttle(() => {
      if (!messageListRef.value || !isInitialized.value)
        return;
      const { scrollTop, scrollHeight, clientHeight } = messageListRef.value;
      const isNearTopNow = scrollTop < scrollThreshold;
      const isNearBottomNow = scrollTop + clientHeight >= scrollHeight - 20;
      formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:71", "滚动详情:", {
        滚动位置: scrollTop,
        内容高度: scrollHeight,
        可视区域高度: clientHeight,
        距离顶部阈值: scrollThreshold,
        是否接近顶部: isNearTopNow,
        是否接近底部: isNearBottomNow,
        之前是否接近顶部: isNearTop.value,
        之前是否滚动到底部: isScrolledToBottom.value
      });
      if (isNearTopNow !== isNearTop.value) {
        isNearTop.value = isNearTopNow;
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:84", "接近顶部状态改变:", isNearTopNow);
        if (isNearTopNow && hasMoreMessages.value && !isLoading.value) {
          formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:86", "触发加载更多消息");
          loadMoreMessages();
        }
      }
      if (isNearBottomNow !== isScrolledToBottom.value) {
        isScrolledToBottom.value = isNearBottomNow;
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:93", "接近底部状态改变:", isNearBottomNow);
        if (isNearBottomNow) {
          showScrollToBottom.value = false;
          showNewMessageTip.value = false;
          hasNewMessages.value = false;
        }
      }
    }, 200);
    const scrollToBottom = () => {
      if (messageListRef.value) {
        messageListRef.value.scrollTop = messageListRef.value.scrollHeight;
        showScrollToBottom.value = false;
        showNewMessageTip.value = false;
        hasNewMessages.value = false;
        isScrolledToBottom.value = true;
      }
    };
    const initialize = () => {
      if (messageListRef.value) {
        isInitialized.value = true;
        messageListRef.value.addEventListener("scroll", onScroll);
        scrollToBottom();
      }
    };
    const cleanup = () => {
      if (messageListRef.value) {
        messageListRef.value.removeEventListener("scroll", onScroll);
      }
    };
    vue.onMounted(() => {
      vue.nextTick(() => {
        initialize();
      });
    });
    vue.watch(messageList, () => {
      vue.nextTick(() => {
        if (isScrolledToBottom.value) {
          scrollToBottom();
        }
      });
    });
    return {
      messageList,
      loadMoreMessages,
      scrollToBottom,
      onScroll,
      isNearTop,
      initialize,
      cleanup
    };
  }
  function useVideoCallHandling(vm) {
    return {
      // 打开视频通话页面
      openVideoPage(action) {
        uni.navigateTo({
          url: `/pages/message/video-call?calleePeerId=${vm.chatInfo.id}`
        });
      },
      // 拒绝视频通话
      rejectVideoCall() {
        formatAppLog("log", "at pages/message/ChatComposables/useVideoCallHandling.js:13", "拒绝视频通话，peerStore 状态:", vm.peerStore);
        vm.peerStore.dataConnection.send({
          instruction: vm.peerStore.instruction.reject
        });
        vm.peerStore.dataConnection = void 0;
        vm.peerStore.activateNotification = false;
      },
      // 接受视频通话
      acceptVideoCall() {
        formatAppLog("log", "at pages/message/ChatComposables/useVideoCallHandling.js:23", "接受视频通话，peerStore 状态:", vm.peerStore);
        vm.peerStore.activateNotification = false;
        uni.showLoading({
          title: "等待对方连接...",
          mask: true
        });
        let cancel = watch(() => vm.peerStore.mediaConnection, (newValue) => {
          if (newValue) {
            uni.hideLoading();
            cancel();
            uni.navigateTo({
              url: "/pages/message/video-answer"
            });
          }
        }, { immediate: true });
        vm.peerStore.dataConnection.send({
          instruction: vm.peerStore.instruction.accept
        });
      }
    };
  }
  function useSelfDestructMessageHandling(vm) {
    const deleteMessage = (messageId) => {
      const index = vm.list.findIndex((msg) => msg.id === messageId);
      if (index !== -1) {
        vm.list.splice(index, 1);
      }
    };
    const handleSelfDestructMessage = async (message) => {
      try {
        const decryptedMessage = decryptMessage(message);
        await processMessage(decryptedMessage);
        if (message.userType === "other" && message.selfDestruct) {
          await readSelfDestructMessage({
            isGroup: vm.chatInfo.type === "group",
            messageId: message.id,
            messageType: message.messageType
          });
          setTimeout(() => {
            deleteMessage(message.id);
          }, 1e4);
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useSelfDestructMessageHandling.js:35", "自毁消息处理错误:", { 消息ID: message.id, 错误: error.message });
      }
    };
    const decryptMessage = (message) => {
      return "已解密的消息";
    };
    const processMessage = async (decryptedMessage) => {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    };
    return {
      handleSelfDestructMessage
    };
  }
  function useChatDataManagement(chatInfo, list) {
    const userStore = useUserStore();
    const groupStore = useGroupStore();
    useWebSocket();
    vue.ref(false);
    vue.ref(false);
    const isLoadingGroupInfo = vue.ref(false);
    const missionId = vue.ref(userStore.state.missionId[0]);
    const getCacheKey = () => `chat_${chatInfo.value.type}_${chatInfo.value.id}`;
    const loadCachedData = () => {
      const cacheKey = getCacheKey();
      const cachedData = uni.getStorageSync(cacheKey);
      return cachedData ? JSON.parse(cachedData) : null;
    };
    const saveCachedData = (data) => {
      const cacheKey = getCacheKey();
      uni.setStorageSync(cacheKey, JSON.stringify(data));
    };
    const fetchAndUpdateData = async () => {
      formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:40", "开始获取并更新数据:", {
        聊天类型: chatInfo.value.type,
        群组信息: groupStore.state.groupInfo,
        任务ID: missionId.value
      });
      try {
        if (chatInfo.value.type === "group") {
          await loadAndCacheGroupMembers(chatInfo.value.id);
        }
        let response;
        if (chatInfo.value.type === "group") {
          response = await getGroupChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            missionId: missionId.value
          });
        } else {
          response = await getHistoryChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            missionId: chatInfo.value.missionId,
            relatedMissionId: missionId.value
          });
        }
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:69", "获取消息响应:", response);
        if (response.code === 200) {
          let newMessages;
          if (chatInfo.value.type === "group") {
            newMessages = await Promise.all(response.data.groupMessageVOS.reverse().map((msg) => mapGroupMessage(msg)));
          } else {
            newMessages = await Promise.all(response.data.messageVOList.reverse().map((msg) => mapPrivateMessage(msg)));
          }
          formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:79", "新消息列表:", newMessages);
          list.value = newMessages;
          saveCachedData(newMessages);
          return newMessages;
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:84", "获取消息失败:", response.msg);
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:87", "获取新消息出错:", error);
      }
    };
    const mapPrivateMessage = async (msg) => {
      let content = msg.content || msg.message;
      let type = (msg.type || msg.messageType || "").toLowerCase();
      if (!type) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:98", "警告: 消息类型未定义", msg);
        type = "unknown";
      }
      if (type === "position") {
        try {
          content = JSON.parse(content);
          type = "location";
        } catch (e2) {
          formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:107", "解析位置数据失败:", e2);
        }
      } else if (type === "image") {
        content = msg.previewUrl || content;
      } else if (type === "text" && (content || "").toLowerCase().endsWith(".txt")) {
        type = "file";
      } else if (type === "audio" || type === "video" || type === "voice_message") {
        content = msg.previewUrl || content;
      }
      const userInfo = await loadAndCacheUserInfo(msg.senderId);
      const avatarUrl = userInfo ? userInfo.avatarUrl : msg.senderId === chatInfo.value.id ? chatInfo.value.avatar && chatInfo.value.avatar[0] ? chatInfo.value.avatar[0] : "" : chatInfo.value._selfAvatar || "";
      const mappedMessage = {
        id: msg.id,
        content,
        userType: msg.senderId === chatInfo.value.id ? "other" : "self",
        avatar: avatarUrl,
        timestamp: new Date(msg.date || msg.sendTime),
        type,
        isRead: msg.isRead,
        messageType: msg.type || msg.messageType,
        selfDestruct: msg.selfDestruct
      };
      return mappedMessage;
    };
    const mapGroupMessage = (msg) => {
      formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:144", "开始映射群聊消息:", msg);
      let content = msg.message || msg.content;
      let type = (msg.messageType || msg.type || "").toLowerCase();
      if (!type) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:149", "警告: 群聊消息类型未定义", msg);
        type = "unknown";
      }
      if (type === "position") {
        try {
          content = JSON.parse(content);
          type = "location";
        } catch (e2) {
          formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:158", "解析位置数据失败:", e2);
        }
      } else if (type === "image") {
        content = msg.previewUrl || content;
      } else if (type === "text" && (content || "").toLowerCase().endsWith(".txt")) {
        type = "file";
      } else if (type === "audio" || type === "video" || type === "voice_message") {
        content = msg.previewUrl || content;
      }
      const groupInfo = groupStore.state.groupInfo;
      let avatar = chatInfo.value._selfAvatar;
      let senderName = "未知用户";
      if (groupInfo && groupInfo.groupMembers) {
        const sender = groupInfo.groupMembers.find((member) => member.userId === msg.senderId);
        if (sender) {
          avatar = sender.avatarUrl || "";
          senderName = sender.userName || "未知用户";
        }
      } else {
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:180", "群组信息不完整或未找到发送者");
      }
      const mappedMessage = {
        id: msg.id,
        content,
        userType: userStore.state.id === msg.senderId ? "self" : "other",
        avatar,
        timestamp: new Date(msg.sendTime || msg.date),
        type,
        isRead: Array.isArray(msg.groupMessageUserReadVO) && msg.groupMessageUserReadVO.some((user) => user.userId === chatInfo.value.id && user.isRead),
        messageType: msg.messageType || msg.type,
        selfDestruct: msg.selfDestruct || msg.isSelfDestruct,
        senderName,
        senderId: msg.senderId,
        groupMessageUserReadVO: Array.isArray(msg.groupMessageUserReadVO) ? msg.groupMessageUserReadVO : []
      };
      formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:200", "群聊消息映射结果:", mappedMessage);
      return mappedMessage;
    };
    const loadAndCacheGroupMembers = async (groupId) => {
      if (isLoadingGroupInfo.value) {
        return;
      }
      isLoadingGroupInfo.value = true;
      const cacheKey = `group_members_${groupId}`;
      const cachedMembers = uni.getStorageSync(cacheKey);
      if (cachedMembers) {
        groupStore.setGroupInfo(JSON.parse(cachedMembers));
      }
      try {
        const response = await getGroupBasicInfo(groupId);
        if (response.code === 200) {
          const groupInfo = {
            id: response.data.id,
            groupName: response.data.groupName,
            groupMembers: response.data.groupMembers
          };
          groupStore.setGroupInfo(groupInfo);
          uni.setStorageSync(cacheKey, JSON.stringify(groupInfo));
          return groupInfo;
        } else {
          return cachedMembers ? JSON.parse(cachedMembers) : null;
        }
      } catch (error) {
        formatAppLog("error", "at pages/message/ChatComposables/useChatDataManagement.js:233", "加载群组成员信息失败:", error);
        return cachedMembers ? JSON.parse(cachedMembers) : null;
      } finally {
        isLoadingGroupInfo.value = false;
      }
    };
    const loadAndCacheUserInfo = async (userId) => {
      const cacheKey = `user_info_${userId}`;
      const cachedUserInfo = uni.getStorageSync(cacheKey);
      if (cachedUserInfo) {
        return JSON.parse(cachedUserInfo);
      }
      try {
        const response = await getUserBasicInfo(userId);
        if (response.code === 200) {
          const userInfo = response.data;
          uni.setStorageSync(cacheKey, JSON.stringify(userInfo));
          return userInfo;
        } else {
          return null;
        }
      } catch (error) {
        formatAppLog("error", "at pages/message/ChatComposables/useChatDataManagement.js:259", "加载用户信息失败:", error);
        return null;
      }
    };
    const insertNewMessage = (newMessage) => {
      list.value.push(newMessage);
      saveCachedData(list.value);
    };
    const handleWebSocketMessage = async (message) => {
      if (message.sessionId === chatInfo.value.id || message.senderId === chatInfo.value.id) {
        if (!message.type) {
          return;
        }
        const isGroupMessage = chatInfo.value.type === "group";
        let mappedMessage;
        if (isGroupMessage) {
          const messageWithReadInfo = {
            ...message,
            groupMessageUserReadVO: message.groupMessageUserReadVO || [],
            messageType: message.type,
            sendTime: message.date
          };
          mappedMessage = mapGroupMessage(messageWithReadInfo);
        } else {
          mappedMessage = await mapPrivateMessage(message);
        }
        if (mappedMessage) {
          list.value.push(mappedMessage);
          saveCachedData(list.value);
        }
      }
    };
    const initWebSocketListener = () => {
      uni.$on("newChatMessage", handleWebSocketMessage);
    };
    const cleanupWebSocketListener = () => {
      uni.$off("newChatMessage", handleWebSocketMessage);
    };
    const updateMessageReadStatus = (messageId, isRead) => {
      const messageIndex = list.value.findIndex((msg) => msg.id === messageId);
      if (messageIndex !== -1) {
        list.value[messageIndex].isRead = isRead;
        saveCachedData(list.value);
      }
    };
    const deleteMessage = (messageId) => {
      const messageIndex = list.value.findIndex((msg) => msg.id === messageId);
      if (messageIndex !== -1) {
        list.value.splice(messageIndex, 1);
        saveCachedData(list.value);
      }
    };
    const updateMessageContent = (messageId, newContent) => {
      const messageIndex = list.value.findIndex((msg) => msg.id === messageId);
      if (messageIndex !== -1) {
        list.value[messageIndex].content = newContent;
        saveCachedData(list.value);
      }
    };
    const loadMoreHistoryMessages = async (oldestMessageId) => {
      try {
        let response;
        if (chatInfo.value.type === "group") {
          response = await getGroupChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            lastMessageId: oldestMessageId
          });
        } else {
          response = await getHistoryChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            missionId: chatInfo.value.missionId,
            lastMessageId: oldestMessageId,
            relatedMissionId: missionId.value
          });
        }
        if (response.code === 200) {
          let olderMessages;
          if (chatInfo.value.type === "group") {
            olderMessages = await Promise.all(response.data.groupMessageVOS.reverse().map((msg) => mapGroupMessage(msg)));
          } else {
            olderMessages = await Promise.all(response.data.messageVOList.reverse().map((msg) => mapPrivateMessage(msg)));
          }
          list.value = [...olderMessages, ...list.value];
          saveCachedData(list.value);
          return olderMessages;
        }
      } catch (error) {
        formatAppLog("error", "at pages/message/ChatComposables/useChatDataManagement.js:372", "加载更多历史消息失败:", error);
      }
    };
    return {
      loadCachedData,
      saveCachedData,
      fetchAndUpdateData,
      loadAndCacheGroupMembers,
      isLoadingGroupInfo,
      insertNewMessage,
      handleWebSocketMessage,
      initWebSocketListener,
      cleanupWebSocketListener,
      loadAndCacheUserInfo,
      updateMessageReadStatus,
      deleteMessage,
      updateMessageContent,
      loadMoreHistoryMessages
    };
  }
  const _sfc_main$h = {
    name: "Chat",
    components: {
      ChatHeader,
      MessageList,
      ChatInputArea,
      ScrollToBottomButton,
      LoadingAnimation: LoadingAnimation$1
    },
    setup() {
      const chatInfo = vue.ref({
        id: "",
        name: "",
        avatar: "",
        type: "single",
        missionId: "",
        isBurnAfterReadingMode: false
      });
      const list = vue.ref([]);
      const showAttachMenu = vue.ref(false);
      const showScrollToBottom = vue.ref(false);
      const showNewMessageTip = vue.ref(false);
      const hasNewMessages = vue.ref(false);
      const isScrolledToBottom = vue.ref(true);
      const currentFrom = vue.ref(0);
      const currentTo = vue.ref(10);
      const hasMoreMessages = vue.ref(true);
      const isLoading = vue.ref(false);
      const peerStore = usePeerStore();
      const friendStore = useFriendStore();
      useUserStore();
      const isBurnAfterReadingMode = vue.ref(false);
      const messageListRef = vue.ref(null);
      const chatInputAreaRef = vue.ref(null);
      const {
        goBack,
        setupChatInfo
      } = useChatInitialization();
      const {
        sendMessage,
        handleMessageFailed,
        loadHistoryMessages,
        updateMessageList,
        handleFileSelected,
        handleMessageDeleted
      } = useMessageHandling(chatInfo, list, currentFrom, currentTo, hasMoreMessages, () => scrollToBottom());
      const {
        handleAttachment,
        handleOverlayClick,
        scrollToBottom: originalScrollToBottom,
        // Rename to avoid conflict
        onScroll,
        loadMoreMessages,
        toggleBurnAfterReadingMode
      } = useUiInteractions({
        messageListRef,
        isScrolledToBottom,
        showScrollToBottom,
        showNewMessageTip,
        hasNewMessages,
        isLoading,
        currentFrom,
        currentTo,
        loadHistoryMessages,
        showAttachMenu,
        hasMoreMessages
      });
      const {
        openVideoPage,
        acceptVideoCall,
        rejectVideoCall
      } = useVideoCallHandling();
      const {
        handleSelfDestructMessage
      } = useSelfDestructMessageHandling();
      const {
        loadCachedData,
        saveCachedData,
        fetchAndUpdateData,
        loadAndCacheGroupMembers,
        initWebSocketListener,
        cleanupWebSocketListener
      } = useChatDataManagement(chatInfo, list);
      const isInitialLoading = vue.ref(true);
      const hasCachedMessages = vue.ref(false);
      const initializeChat = async () => {
        formatAppLog("log", "at pages/message/chat.vue:199", "开始初始化聊天");
        if (chatInfo.value && chatInfo.value.id) {
          isInitialLoading.value = true;
          formatAppLog("log", "at pages/message/chat.vue:202", "尝试加载缓存数据");
          const cachedData = await loadCachedData();
          if (cachedData) {
            formatAppLog("log", "at pages/message/chat.vue:206", "找到缓存数据，长度:", cachedData.length);
            hasCachedMessages.value = true;
            list.value = cachedData;
            vue.nextTick(() => {
              scrollToBottom();
              formatAppLog("log", "at pages/message/chat.vue:211", "使用缓存数据后滚动到底部");
            });
          } else {
            formatAppLog("log", "at pages/message/chat.vue:214", "没有找到缓存数据");
            hasCachedMessages.value = false;
          }
          if (chatInfo.value.type === "group") {
            formatAppLog("log", "at pages/message/chat.vue:219", "获取群基本信息");
            await loadAndCacheGroupMembers(chatInfo.value.id);
          }
          formatAppLog("log", "at pages/message/chat.vue:223", "开始获取最新消息");
          try {
            const newMessages = await fetchAndUpdateData();
            if (newMessages) {
              list.value = newMessages;
              vue.nextTick(() => {
                scrollToBottom();
                formatAppLog("log", "at pages/message/chat.vue:230", "加载新消息后滚动到底部");
              });
            }
          } catch (error) {
            formatAppLog("log", "at pages/message/chat.vue:234", "获取最新消息失败:", error);
            uni.showToast({
              title: "加载消息失败，请重试",
              icon: "none"
            });
          }
          isInitialLoading.value = false;
          formatAppLog("log", "at pages/message/chat.vue:242", "初始加载完成，isInitialLoading 设置为 false");
          formatAppLog("log", "at pages/message/chat.vue:244", "聊天初始化完成:", {
            缓存数据: !!cachedData,
            缓存数据长度: cachedData ? cachedData.length : 0,
            历史消息长度: list.value.length
          });
        } else {
          formatAppLog("log", "at pages/message/chat.vue:250", "聊天信息无效，无法初始化");
          isInitialLoading.value = false;
        }
      };
      const fetchLocation = () => {
        uni.getLocation({
          type: "gcj02",
          success: (res) => {
            currentLocation.value = {
              latitude: res.latitude.toString(),
              longitude: res.longitude.toString()
            };
          },
          fail: () => {
            currentLocation.value = { latitude: "0", longitude: "0" };
          },
          timeout: 1e3
        });
      };
      const handleBurnAfterReadingToggle = (isActive) => {
        chatInfo.value.isBurnAfterReadingMode = isActive;
        formatAppLog("log", "at pages/message/chat.vue:274", "阅后即焚模式切换:", isActive);
      };
      vue.watch(chatInfo, async (newChatInfo) => {
        formatAppLog("log", "at pages/message/chat.vue:279", "聊天信息变化:", newChatInfo);
        if (newChatInfo && newChatInfo.id) {
          await initializeChat();
        }
      }, { deep: true, immediate: true });
      vue.onMounted(() => {
        formatAppLog("log", "at pages/message/chat.vue:286", "聊天组件挂载");
        const pages2 = getCurrentPages();
        const currentPage = pages2[pages2.length - 1];
        let eventChannel;
        const query = uni.getStorageSync("chatQuery");
        if (currentPage && currentPage.$getAppWebview) {
          eventChannel = currentPage.$getAppWebview().eventChannel;
        } else if (currentPage && currentPage.getOpenerEventChannel) {
          eventChannel = currentPage.getOpenerEventChannel();
        } else if (uni && uni.getEnterOptionsSync) {
          const enterOptions = uni.getEnterOptionsSync();
          eventChannel = enterOptions.eventChannel;
        }
        const initializeChatFromData = (data) => {
          formatAppLog("log", "at pages/message/chat.vue:303", "初始化聊天数据:", data);
          if (data && data.chatInfo) {
            chatInfo.value = {
              ...chatInfo.value,
              ...data.chatInfo
            };
            formatAppLog("log", "at pages/message/chat.vue:309", "使用接收到的聊天信息初始化聊天");
            initializeChat();
          } else {
            formatAppLog("log", "at pages/message/chat.vue:312", "接收到的聊天信息无效");
            isInitialLoading.value = false;
            uni.showToast({
              title: "无法加载聊天信息",
              icon: "none"
            });
            setTimeout(() => {
              formatAppLog("log", "at pages/message/chat.vue:319", "无法加���聊天信息，返回上一页");
              uni.navigateBack();
            }, 2e3);
          }
        };
        if (eventChannel) {
          formatAppLog("log", "at pages/message/chat.vue:326", "找到事件通道，设置聊天信息");
          eventChannel.on("chatInfo", initializeChatFromData);
        } else if (query) {
          formatAppLog("log", "at pages/message/chat.vue:329", "从存储中找到聊天信息");
          const parsedQuery = JSON.parse(query);
          initializeChatFromData({ chatInfo: parsedQuery });
        } else {
          formatAppLog("log", "at pages/message/chat.vue:333", "无法加载聊天信息");
          isInitialLoading.value = false;
          uni.showToast({
            title: "无法加载聊天信息",
            icon: "none"
          });
          setTimeout(() => {
            formatAppLog("log", "at pages/message/chat.vue:340", "无法加载聊天信息，返回上一页");
            uni.navigateBack();
          }, 2e3);
        }
        formatAppLog("log", "at pages/message/chat.vue:344", "聊天组件挂载完成:", {
          有事件通道: !!eventChannel,
          存储中有聊天信息: !!query
        });
        fetchLocation();
        initWebSocketListener();
      });
      vue.onUnmounted(() => {
        cleanupWebSocketListener();
      });
      const handleMessageListClick = (event) => {
        formatAppLog("log", "at pages/message/chat.vue:359", "消息列表被点击");
        event.stopPropagation();
        showAttachMenu.value = false;
      };
      const handlePageClick = (event) => {
        const chatInputArea = chatInputAreaRef.value;
        if (chatInputArea && chatInputArea.$el && event.target instanceof Node) {
          if (!chatInputArea.$el.contains(event.target)) {
            showAttachMenu.value = false;
          }
        }
      };
      const handleMessageSent = () => {
        formatAppLog("log", "at pages/message/chat.vue:376", "消息已发送，准备滚动到底部");
        vue.nextTick(() => {
          if (messageListRef.value) {
            messageListRef.value.scrollToBottom(true);
          }
        });
      };
      const toggleAttachMenu = (value) => {
        formatAppLog("log", "at pages/message/chat.vue:385", "切换附件菜单状态:", value);
        showAttachMenu.value = value;
      };
      const currentLocation = vue.ref({ latitude: "0", longitude: "0" });
      const scrollToBottom = () => {
        vue.nextTick(() => {
          if (messageListRef.value && messageListRef.value.scrollToBottom) {
            messageListRef.value.scrollToBottom();
          }
        });
      };
      return {
        chatInfo,
        list,
        showAttachMenu,
        showScrollToBottom,
        showNewMessageTip,
        hasNewMessages,
        isScrolledToBottom,
        currentFrom,
        currentTo,
        hasMoreMessages,
        isLoading,
        peerStore,
        friendStore,
        isBurnAfterReadingMode,
        messageListRef,
        goBack,
        sendMessage,
        handleMessageFailed,
        loadHistoryMessages,
        updateMessageList,
        handleFileSelected,
        handleAttachment,
        handleOverlayClick,
        scrollToBottom,
        onScroll,
        loadMoreMessages,
        toggleBurnAfterReadingMode,
        openVideoPage,
        acceptVideoCall,
        rejectVideoCall,
        handleSelfDestructMessage,
        initializeChat,
        handleBurnAfterReadingToggle,
        handleMessageDeleted,
        loadCachedData,
        saveCachedData,
        fetchAndUpdateData,
        loadAndCacheGroupMembers,
        isInitialLoading,
        hasCachedMessages,
        handleMessageListClick,
        handleMessageSent,
        handlePageClick,
        toggleAttachMenu,
        currentLocation,
        chatInputAreaRef
      };
    }
  };
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_ChatHeader = vue.resolveComponent("ChatHeader");
    const _component_MessageList = vue.resolveComponent("MessageList");
    const _component_LoadingAnimation = vue.resolveComponent("LoadingAnimation");
    const _component_ChatInputArea = vue.resolveComponent("ChatInputArea");
    const _component_ScrollToBottomButton = vue.resolveComponent("ScrollToBottomButton");
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "chat-page",
      onClick: _cache[4] || (_cache[4] = vue.withModifiers((...args) => $setup.handlePageClick && $setup.handlePageClick(...args), ["stop"]))
    }, [
      vue.createCommentVNode(" 聊天头部 "),
      vue.createVNode(_component_ChatHeader, {
        "chat-info": $setup.chatInfo,
        onGoBack: $setup.goBack
      }, null, 8, ["chat-info", "onGoBack"]),
      vue.createCommentVNode(" 消息列表 - 添加点击处理 "),
      !$setup.isInitialLoading || $setup.hasCachedMessages ? (vue.openBlock(), vue.createBlock(_component_MessageList, {
        key: 0,
        ref: "messageListRef",
        messages: $setup.list,
        "is-group": $setup.chatInfo.type === "group",
        onLoadMore: $setup.loadMoreMessages,
        onScroll: $setup.onScroll,
        onMessageDeleted: $setup.handleMessageDeleted,
        onClick: $setup.handleMessageListClick,
        class: "message-list"
      }, null, 8, ["messages", "is-group", "onLoadMore", "onScroll", "onMessageDeleted", "onClick"])) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" 加载动画 "),
      $setup.isInitialLoading && !$setup.hasCachedMessages ? (vue.openBlock(), vue.createBlock(_component_LoadingAnimation, { key: 1 })) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" 聊天输入区域 "),
      vue.createVNode(_component_ChatInputArea, {
        modelValue: $setup.showAttachMenu,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.showAttachMenu = $event),
        onSendMessage: $setup.sendMessage,
        onMessageFailed: $setup.handleMessageFailed,
        onAttach: $setup.handleAttachment,
        onVideoCall: $setup.openVideoPage,
        onFileSelected: $setup.handleFileSelected,
        onToggleBurnAfterReading: $setup.handleBurnAfterReadingToggle,
        onMessageSent: $setup.handleMessageSent,
        recipientId: $setup.chatInfo && $setup.chatInfo.id || "",
        missionId: $setup.chatInfo && $setup.chatInfo.missionId,
        "initial-burn-after-reading-mode": $setup.chatInfo && $setup.chatInfo.isBurnAfterReadingMode,
        onToggleAttachMenu: $setup.toggleAttachMenu,
        ref: "chatInputAreaRef"
      }, null, 8, ["modelValue", "onSendMessage", "onMessageFailed", "onAttach", "onVideoCall", "onFileSelected", "onToggleBurnAfterReading", "onMessageSent", "recipientId", "missionId", "initial-burn-after-reading-mode", "onToggleAttachMenu"]),
      vue.createCommentVNode(" 滚动到底部按钮 "),
      vue.createVNode(_component_ScrollToBottomButton, {
        show: $setup.showScrollToBottom,
        onClick: vue.withModifiers($setup.scrollToBottom, ["stop"])
      }, null, 8, ["show", "onClick"]),
      vue.createCommentVNode(" 新消息提示 "),
      $setup.showNewMessageTip ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 2,
        class: "new-message-tip",
        onClick: _cache[1] || (_cache[1] = vue.withModifiers((...args) => $setup.scrollToBottom && $setup.scrollToBottom(...args), ["stop"]))
      }, " 新消息 ")) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" 来电提醒 "),
      $setup.peerStore.activateNotification ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 3,
        class: "modal"
      }, [
        vue.createElementVNode("view", null, [
          vue.createElementVNode(
            "text",
            null,
            vue.toDisplayString((_a = $setup.peerStore.dataConnection) == null ? void 0 : _a.peer) + " 邀请你视频通话",
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode("view", { class: "modal-content" }, [
          vue.createElementVNode("button", {
            onClick: _cache[2] || (_cache[2] = (...args) => $setup.acceptVideoCall && $setup.acceptVideoCall(...args)),
            type: "default"
          }, "接听"),
          vue.createElementVNode("button", {
            onClick: _cache[3] || (_cache[3] = (...args) => $setup.rejectVideoCall && $setup.rejectVideoCall(...args)),
            type: "warn"
          }, "拒绝")
        ])
      ])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const PagesMessageChat = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$g], ["__scopeId", "data-v-013fa921"], ["__file", "E:/代码/new/zk_uniapp/pages/message/chat.vue"]]);
  const useContactsStore = defineStore("contacts", {
    state: () => ({
      groupVOList: [],
      // 群组列表
      userInformationVOList: [],
      // 用户信息列表
      selectedContact: null,
      // 当前选中的联系人
      isInitialized: false,
      // 是否已初始化
      contactsUpdateCounter: 0
      // 联系人更新计数器
    }),
    actions: {
      // 设置群组列表
      setGroupVOList(groupVOList) {
        this.groupVOList = groupVOList;
      },
      // 设置用户信息列表
      setUserInformationVOList(userInformationVOList) {
        this.userInformationVOList = userInformationVOList;
      },
      // 设置选中的联系人
      setSelectedContact(contact) {
        this.selectedContact = contact;
      },
      // 设置初始化状态
      setInitialized(value) {
        this.isInitialized = value;
      },
      // 增加联系人更新计数器
      incrementContactsUpdateCounter() {
        this.contactsUpdateCounter++;
        formatAppLog("log", "at pages/contacts/store/contactsStore.js:32", "联系人更新计数器已增加");
      }
    }
  });
  const _sfc_main$g = {
    name: "GroupChatList",
    props: {
      // 群聊列表数据
      groupVOList: {
        type: Array,
        required: true
      }
    },
    setup(props, { emit }) {
      const groupList = vue.ref(props.groupVOList);
      const expanded = vue.ref(true);
      const toggleGroup = () => {
        expanded.value = !expanded.value;
      };
      const enterGroupChat = (group) => {
        emit("enter-group-chat", group);
      };
      return {
        groupList,
        expanded,
        toggleGroup,
        enterGroupChat
      };
    }
  };
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "group-chat-list" }, [
      vue.createElementVNode("view", { class: "group" }, [
        vue.createElementVNode("view", {
          class: "group-header",
          onClick: _cache[0] || (_cache[0] = (...args) => $setup.toggleGroup && $setup.toggleGroup(...args))
        }, [
          vue.createElementVNode(
            "text",
            { class: "group-title" },
            "群聊 (" + vue.toDisplayString($setup.groupList.length) + "个)",
            1
            /* TEXT */
          ),
          vue.createElementVNode(
            "text",
            {
              class: vue.normalizeClass(["group-arrow", { "expanded": $setup.expanded }])
            },
            "›",
            2
            /* CLASS */
          )
        ]),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["group-content", { "expanded": $setup.expanded }])
          },
          [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.groupList, (group) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  key: group.id,
                  class: "contact-item",
                  onClick: ($event) => $setup.enterGroupChat(group)
                }, [
                  vue.createElementVNode("image", {
                    src: group.avatar || "/static/default-group-avatar.png",
                    class: "avatar",
                    mode: "aspectFill"
                  }, null, 8, ["src"]),
                  vue.createElementVNode("view", { class: "contact-info" }, [
                    vue.createElementVNode(
                      "text",
                      { class: "contact-name" },
                      vue.toDisplayString(group.groupName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "text",
                      { class: "contact-title" },
                      vue.toDisplayString(group.groupMembers.length) + "人",
                      1
                      /* TEXT */
                    )
                  ])
                ], 8, ["onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        )
      ])
    ]);
  }
  const GroupChatList = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f], ["__scopeId", "data-v-382e9af6"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/components/Contacts/GroupChatList.vue"]]);
  const _sfc_main$f = {
    name: "UserList",
    props: {
      // 用户列表数据
      userInformationVOList: {
        type: Array,
        required: true
      }
    },
    setup(props, { emit }) {
      const departmentList = vue.ref([]);
      const initDepartmentList = () => {
        const departments = {};
        props.userInformationVOList.forEach((user) => {
          if (!departments[user.departmentName]) {
            departments[user.departmentName] = {
              name: user.departmentName,
              users: [],
              expanded: true
              // 默认展开
            };
          }
          departments[user.departmentName].users.push(user);
        });
        departmentList.value = Object.values(departments);
      };
      initDepartmentList();
      const toggleGroup = (department) => {
        department.expanded = !department.expanded;
      };
      const selectUser = (user) => {
        emit("select-user", user);
      };
      return {
        departmentList,
        toggleGroup,
        selectUser
      };
    }
  };
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "user-list" }, [
      (vue.openBlock(true), vue.createElementBlock(
        vue.Fragment,
        null,
        vue.renderList($setup.departmentList, (department) => {
          return vue.openBlock(), vue.createElementBlock("view", {
            key: department.name,
            class: "group"
          }, [
            vue.createElementVNode("view", {
              class: "group-header",
              onClick: ($event) => $setup.toggleGroup(department)
            }, [
              vue.createElementVNode(
                "text",
                { class: "group-title" },
                vue.toDisplayString(department.name) + " (" + vue.toDisplayString(department.users.length) + "人)",
                1
                /* TEXT */
              ),
              vue.createElementVNode(
                "text",
                {
                  class: vue.normalizeClass(["group-arrow", { "expanded": department.expanded }])
                },
                "›",
                2
                /* CLASS */
              )
            ], 8, ["onClick"]),
            vue.createElementVNode(
              "view",
              {
                class: vue.normalizeClass(["group-content", { "expanded": department.expanded }])
              },
              [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(department.users, (user) => {
                    return vue.openBlock(), vue.createElementBlock("view", {
                      key: user.id,
                      class: "contact-item",
                      onClick: ($event) => $setup.selectUser(user)
                    }, [
                      vue.createElementVNode("image", {
                        src: user.avatarUrl || "/static/default-avatar.png",
                        class: "avatar",
                        mode: "aspectFill"
                      }, null, 8, ["src"]),
                      vue.createElementVNode("view", { class: "contact-info" }, [
                        vue.createElementVNode(
                          "text",
                          { class: "contact-name" },
                          vue.toDisplayString(user.name),
                          1
                          /* TEXT */
                        ),
                        vue.createElementVNode(
                          "text",
                          { class: "contact-title" },
                          vue.toDisplayString(user.departmentName || "成员"),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createCommentVNode(" 在线状态指示器 "),
                      vue.createElementVNode(
                        "view",
                        {
                          class: vue.normalizeClass(["status-indicator", user.online ? "online" : "offline"])
                        },
                        null,
                        2
                        /* CLASS */
                      )
                    ], 8, ["onClick"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              2
              /* CLASS */
            )
          ]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]);
  }
  const UserList = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e], ["__scopeId", "data-v-e47a5fe3"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/components/Contacts/UserList.vue"]]);
  const _sfc_main$e = {
    name: "Avatar",
    props: {
      src: {
        type: String,
        default: "/static/message/默认头像.png"
      },
      size: {
        type: Number,
        default: 40
      }
    }
  };
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("image", {
      class: "avatar",
      src: $props.src,
      style: vue.normalizeStyle({ width: `${$props.size}px`, height: `${$props.size}px` }),
      mode: "aspectFill"
    }, null, 12, ["src"]);
  }
  const Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d], ["__scopeId", "data-v-148945a0"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/components/shared/Avatar.vue"]]);
  const _sfc_main$d = {
    name: "ContactInfo",
    components: {
      Avatar
    },
    props: {
      contact: {
        type: Object,
        required: true
      }
    }
  };
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_avatar = vue.resolveComponent("avatar");
    return vue.openBlock(), vue.createElementBlock("view", { class: "main-info" }, [
      vue.createElementVNode("view", { class: "profile-section" }, [
        vue.createVNode(_component_avatar, {
          src: $props.contact.avatarUrl,
          size: 65
        }, null, 8, ["src"]),
        vue.createElementVNode("view", { class: "info-section" }, [
          vue.createElementVNode("view", { class: "name-section" }, [
            vue.createElementVNode(
              "text",
              { class: "name" },
              vue.toDisplayString($props.contact.name),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", { class: "badge-section" }, [
              vue.createElementVNode(
                "text",
                { class: "badge" },
                vue.toDisplayString($props.contact.title),
                1
                /* TEXT */
              )
            ])
          ]),
          vue.createElementVNode("view", { class: "details-section" }, [
            vue.createElementVNode("view", { class: "detail-item" }, [
              vue.createElementVNode("text", { class: "detail-label" }, "用户名"),
              vue.createElementVNode(
                "text",
                { class: "detail-value" },
                vue.toDisplayString($props.contact.username),
                1
                /* TEXT */
              )
            ]),
            vue.createElementVNode("view", { class: "detail-item" }, [
              vue.createElementVNode("text", { class: "detail-label" }, "设备IP"),
              vue.createElementVNode(
                "text",
                { class: "detail-value" },
                vue.toDisplayString($props.contact.ip),
                1
                /* TEXT */
              )
            ])
          ])
        ])
      ])
    ]);
  }
  const ContactInfo = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c], ["__scopeId", "data-v-e72bb083"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/components/ContactDetail/ContactInfo.vue"]]);
  const _sfc_main$c = {
    __name: "ContactDetailView",
    setup(__props, { expose: __expose }) {
      __expose();
      const userStore = useUserStore();
      const contact = vue.ref({
        id: "",
        name: "",
        avatarUrl: "",
        departmentName: "",
        online: false,
        missionId: ""
      });
      vue.onMounted(() => {
        const pages2 = getCurrentPages();
        const currentPage = pages2[pages2.length - 1];
        const options = currentPage.$page ? currentPage.$page.options : currentPage.options;
        const { user, missionId: pageMissionId } = options;
        if (user) {
          try {
            const decodedUser = JSON.parse(decodeURIComponent(user));
            contact.value = {
              ...decodedUser,
              missionId: pageMissionId || userStore.state.missionId[0]
            };
            formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:54", "联系人详情:", contact.value);
          } catch (error) {
            formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:56", "解析用户数据失败:", error);
          }
        } else {
          formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:59", "未接收到用户数据");
        }
        formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:62", "联系人详情页面已加载");
      });
      const handleMessage = () => {
        formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:67", "正在跳转到聊天界面");
        const chatInfo = {
          id: contact.value.id,
          name: contact.value.name,
          avatar: contact.value.avatarUrl,
          type: "single",
          missionId: contact.value.missionId,
          isBurnAfterReadingMode: false
        };
        uni.navigateTo({
          url: "/pages/message/chat",
          success: (res) => {
            if (res.eventChannel && res.eventChannel.emit) {
              res.eventChannel.emit("chatInfo", { chatInfo });
              formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:82", "通过 eventChannel 发送 chatInfo");
            } else {
              formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:84", "eventChannel 不可用，将使用本地存储的数据");
              uni.setStorageSync("chatQuery", JSON.stringify(chatInfo));
            }
          },
          fail: (error) => {
            formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:89", "跳转到聊天界面失败:", error);
          }
        });
      };
      const handleClearHistory = () => {
        formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:96", "正在处理清除历史");
      };
      const handleDelete = () => {
        formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:102", "正在处理删除联系人");
      };
      const __returned__ = { userStore, contact, handleMessage, handleClearHistory, handleDelete, ref: vue.ref, onMounted: vue.onMounted, ContactInfo, get useUserStore() {
        return useUserStore;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "contact-detail-view" }, [
      vue.createCommentVNode(" 显示联系人信息 "),
      vue.createVNode($setup["ContactInfo"], { contact: $setup.contact }, null, 8, ["contact"]),
      vue.createCommentVNode(" 显示部门和在线状态 "),
      vue.createElementVNode("view", { class: "additional-info" }, [
        vue.createElementVNode(
          "text",
          null,
          "部门：" + vue.toDisplayString($setup.contact.departmentName),
          1
          /* TEXT */
        ),
        vue.createElementVNode(
          "text",
          null,
          "状态：" + vue.toDisplayString($setup.contact.online ? "在线" : "离线"),
          1
          /* TEXT */
        )
      ]),
      vue.createCommentVNode(" 操作按钮 "),
      vue.createElementVNode("view", { class: "action-buttons" }, [
        vue.createElementVNode("button", { onClick: $setup.handleMessage }, "发送消息"),
        vue.createElementVNode("button", { onClick: $setup.handleClearHistory }, "清除历史"),
        vue.createElementVNode("button", {
          onClick: $setup.handleDelete,
          class: "delete-button"
        }, "删除联系人")
      ])
    ]);
  }
  const PagesContactsComponentsContactDetailContactDetailView = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b], ["__scopeId", "data-v-e5781576"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/components/ContactDetail/ContactDetailView.vue"]]);
  const _imports_0$2 = "/static/message/群聊.png";
  const _sfc_main$b = {
    name: "DropdownMenu",
    props: {
      visible: {
        type: Boolean,
        default: false
      }
    },
    emits: ["group-chat", "add-friend"],
    setup(props, { emit }) {
      const handleGroupChat = () => {
        emit("group-chat");
      };
      const handleAddFriend = () => {
        emit("add-friend");
      };
      return {
        handleGroupChat,
        handleAddFriend
      };
    }
  };
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
      "div",
      { class: "dropdown-container" },
      [
        vue.createElementVNode("div", { class: "dropdown-menu" }, [
          vue.createElementVNode("div", {
            class: "dropdown-item",
            onClick: _cache[0] || (_cache[0] = (...args) => $setup.handleGroupChat && $setup.handleGroupChat(...args))
          }, [
            vue.createElementVNode("image", {
              src: _imports_0$2,
              class: "item-icon",
              mode: "aspectFit"
            }),
            vue.createElementVNode("text", { class: "item-text" }, "发起群聊")
          ]),
          vue.createCommentVNode(' <div class="dropdown-item" @click="handleAddFriend">\r\n        <image src="/static/message/添加好友.png" class="item-icon" mode="aspectFit"></image>\r\n        <text class="item-text">添加朋友</text>\r\n      </div> ')
        ])
      ],
      512
      /* NEED_PATCH */
    )), [
      [vue.vShow, $props.visible]
    ]);
  }
  const DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a], ["__scopeId", "data-v-805b46fa"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/components/shared/DropdownMenu.vue"]]);
  const _sfc_main$a = {
    name: "LoadingAnimation"
  };
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "loading-animation" }, [
      vue.createElementVNode("view", { class: "dot" }),
      vue.createElementVNode("view", { class: "dot" }),
      vue.createElementVNode("view", { class: "dot" })
    ]);
  }
  const LoadingAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$9], ["__scopeId", "data-v-a646be00"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/components/shared/LoadingAnimation.vue"]]);
  function useContacts() {
    formatAppLog("log", "at pages/contacts/composables/useContacts.js:8", "useContacts 组合式函数被调用");
    const contactsStore = useContactsStore();
    const userStore = useUserStore();
    const loading = vue.ref(false);
    const isUpdating = vue.ref(false);
    const showDropdown = vue.ref(false);
    const missionId = vue.computed(() => userStore.state.missionId[0]);
    const groupVOList = vue.computed(() => contactsStore.groupVOList);
    const userInformationVOList = vue.computed(() => contactsStore.userInformationVOList);
    const computedMissionId = vue.computed(() => {
      return Array.isArray(userStore.state.missionId) ? userStore.state.missionId.join(",") : userStore.state.missionId || "";
    });
    async function initContacts() {
      formatAppLog("log", "at pages/contacts/composables/useContacts.js:31", "initContacts 函数被调用");
      if (loading.value)
        return;
      loading.value = true;
      try {
        loadCachedData();
        fetchLatestData();
      } catch (error) {
        formatAppLog("log", "at pages/contacts/composables/useContacts.js:42", "初始化联系人数据出错:", error);
      } finally {
        loading.value = false;
      }
    }
    function loadCachedData() {
      const cachedData = uni.getStorageSync("contactsData");
      if (cachedData) {
        const parsedData = JSON.parse(cachedData);
        contactsStore.setGroupVOList(parsedData.groupVOList);
        contactsStore.setUserInformationVOList(parsedData.userInformationVOList);
        formatAppLog("log", "at pages/contacts/composables/useContacts.js:55", "已加载缓存的联系人数据");
      }
    }
    async function fetchLatestData() {
      if (!missionId.value) {
        formatAppLog("log", "at pages/contacts/composables/useContacts.js:62", "等待 missionId 被设置");
        return;
      }
      try {
        isUpdating.value = true;
        const response = await getMissionAddressBook(missionId.value);
        if (response.code === 200) {
          const newData = response.data;
          const hasChanges = compareData(newData);
          if (hasChanges) {
            updateData(newData);
            formatAppLog("log", "at pages/contacts/composables/useContacts.js:74", "联系人数据已更新");
          } else {
            formatAppLog("log", "at pages/contacts/composables/useContacts.js:76", "联系人数据无变化");
          }
        } else {
          throw new Error(response.msg || "获取通讯录失败");
        }
      } catch (error) {
        formatAppLog("log", "at pages/contacts/composables/useContacts.js:82", "获取最新联系人数据出错:", error);
      } finally {
        isUpdating.value = false;
      }
    }
    function compareData(newData) {
      const oldGroupVOList = contactsStore.groupVOList;
      const oldUserInformationVOList = contactsStore.userInformationVOList;
      return JSON.stringify(newData.groupVOList) !== JSON.stringify(oldGroupVOList) || JSON.stringify(newData.userInformationVOList) !== JSON.stringify(oldUserInformationVOList);
    }
    function updateData(newData) {
      contactsStore.setGroupVOList(newData.groupVOList);
      contactsStore.setUserInformationVOList(newData.userInformationVOList);
      uni.setStorageSync("contactsData", JSON.stringify(newData));
    }
    const toggleDropdown = () => {
      showDropdown.value = !showDropdown.value;
    };
    const handleContainerClick = () => {
      if (showDropdown.value) {
        showDropdown.value = false;
      }
    };
    return {
      loading,
      isUpdating,
      missionId,
      groupVOList,
      userInformationVOList,
      computedMissionId,
      showDropdown,
      initContacts,
      toggleDropdown,
      handleContainerClick
    };
  }
  function useContactNavigation() {
    useUserStore();
    const handleSearch = () => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:7", "搜索按钮被点击");
    };
    const handleGroupChat = () => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:11", "发起群聊被点击");
      uni.navigateTo({
        url: "/pages/contacts/pages/contacts/create-group-chat/index"
      });
    };
    const handleAddFriend = () => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:18", "添加朋友被点击");
    };
    const enterGroupChat = (group, missionId) => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:22", "正在跳转到群聊界面:", group);
      const chatInfo = {
        id: group.id,
        name: group.groupName,
        avatar: group.avatar || "/static/default-group-avatar.png",
        type: "group",
        missionId,
        isBurnAfterReadingMode: false
      };
      uni.navigateTo({
        url: "/pages/message/chat",
        success: (res) => {
          if (res.eventChannel && res.eventChannel.emit) {
            res.eventChannel.emit("chatInfo", { chatInfo });
            formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:37", "通过 eventChannel 发送 chatInfo");
          } else {
            formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:39", "eventChannel 不可用，将使用本地存储的数据");
            uni.setStorageSync("chatQuery", JSON.stringify(chatInfo));
          }
        },
        fail: (err) => {
          formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:44", "导航到聊天页面失败:", err);
        }
      });
    };
    const selectUser = (user, missionId) => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:50", "选择用户:", user);
      const userString = encodeURIComponent(JSON.stringify(user));
      uni.navigateTo({
        url: `/pages/contacts/components/ContactDetail/ContactDetailView?user=${userString}&missionId=${missionId}`,
        fail: (error) => {
          formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:55", "导航到联系人详情页面失败:", error);
        }
      });
    };
    return {
      handleSearch,
      handleGroupChat,
      handleAddFriend,
      enterGroupChat,
      selectUser
    };
  }
  const _imports_0$1 = "/static/message/搜索.png";
  const _imports_1 = "/static/message/展开对话工具.png";
  const _sfc_main$9 = {
    name: "Contacts",
    components: {
      GroupChatList,
      UserList,
      ContactDetailView: PagesContactsComponentsContactDetailContactDetailView,
      DropdownMenu,
      LoadingAnimation
    },
    setup() {
      formatAppLog("log", "at pages/contacts/pages/contacts.vue:89", "联系人组件设置函数被调用");
      const contactsStore = useContactsStore();
      const {
        initContacts,
        loading,
        isUpdating,
        missionId,
        groupVOList,
        userInformationVOList,
        computedMissionId,
        showDropdown,
        toggleDropdown,
        handleContainerClick
      } = useContacts();
      const {
        handleSearch,
        handleGroupChat,
        handleAddFriend,
        enterGroupChat,
        selectUser
      } = useContactNavigation();
      const selectedContact = vue.ref(null);
      vue.onMounted(() => {
        formatAppLog("log", "at pages/contacts/pages/contacts.vue:114", "联系人组件挂载钩子被调用");
        initContacts();
      });
      vue.onActivated(() => {
        formatAppLog("log", "at pages/contacts/pages/contacts.vue:119", "联系人页面被激活");
        initContacts();
      });
      vue.watch(() => missionId.value, (newMissionId) => {
        if (newMissionId) {
          formatAppLog("log", "at pages/contacts/pages/contacts.vue:125", "任务ID已更改，重新初始化联系人");
          initContacts();
        }
      });
      vue.watch(() => contactsStore.contactsUpdateCounter, () => {
        formatAppLog("log", "at pages/contacts/pages/contacts.vue:131", "联系人数据已更新，重新初始化联系人");
        initContacts();
      });
      const closeContactDetail = () => {
        selectedContact.value = null;
      };
      return {
        groupVOList,
        userInformationVOList,
        selectedContact,
        showDropdown,
        loading,
        isUpdating,
        missionId,
        computedMissionId,
        closeContactDetail,
        handleSearch,
        toggleDropdown,
        handleContainerClick,
        handleGroupChat,
        handleAddFriend,
        enterGroupChat,
        selectUser
      };
    }
  };
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    const _component_dropdown_menu = vue.resolveComponent("dropdown-menu");
    const _component_loading_animation = vue.resolveComponent("loading-animation");
    const _component_group_chat_list = vue.resolveComponent("group-chat-list");
    const _component_user_list = vue.resolveComponent("user-list");
    const _component_contact_detail_view = vue.resolveComponent("contact-detail-view");
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "contacts-container",
      onClick: _cache[4] || (_cache[4] = (...args) => $setup.handleContainerClick && $setup.handleContainerClick(...args))
    }, [
      vue.createCommentVNode(" 顶部导航栏 "),
      vue.createVNode(_component_uni_nav_bar, {
        fixed: true,
        "status-bar": "",
        "right-icon": "search",
        onClickRight: $setup.handleSearch,
        title: "通讯录"
      }, {
        right: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "nav-right" }, [
            vue.createElementVNode("image", {
              class: "nav-icon",
              src: _imports_0$1,
              mode: "aspectFit",
              onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $setup.handleSearch && $setup.handleSearch(...args), ["stop"]))
            }),
            vue.createElementVNode("image", {
              class: "nav-icon",
              src: _imports_1,
              mode: "aspectFit",
              onClick: _cache[1] || (_cache[1] = vue.withModifiers((...args) => $setup.toggleDropdown && $setup.toggleDropdown(...args), ["stop"]))
            })
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["onClickRight"]),
      vue.createCommentVNode(" 下拉菜单 "),
      vue.createVNode(_component_dropdown_menu, {
        visible: $setup.showDropdown,
        onGroupChat: $setup.handleGroupChat,
        onAddFriend: $setup.handleAddFriend
      }, null, 8, ["visible", "onGroupChat", "onAddFriend"]),
      vue.createElementVNode("view", { class: "content-wrapper" }, [
        vue.createCommentVNode(" 加载动画 "),
        $setup.loading ? (vue.openBlock(), vue.createBlock(_component_loading_animation, { key: 0 })) : (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          { key: 1 },
          [
            vue.createCommentVNode(" 群聊列表组件 "),
            $setup.groupVOList.length > 0 ? (vue.openBlock(), vue.createBlock(_component_group_chat_list, {
              key: 0,
              groupVOList: $setup.groupVOList,
              onEnterGroupChat: _cache[2] || (_cache[2] = (group) => $setup.enterGroupChat(group, $setup.computedMissionId))
            }, null, 8, ["groupVOList"])) : (vue.openBlock(), vue.createElementBlock("view", {
              key: 1,
              class: "empty-state"
            }, "暂无群聊")),
            vue.createCommentVNode(" 用户列表组件 "),
            $setup.userInformationVOList.length > 0 ? (vue.openBlock(), vue.createBlock(_component_user_list, {
              key: 2,
              userInformationVOList: $setup.userInformationVOList,
              onSelectUser: _cache[3] || (_cache[3] = (user) => $setup.selectUser(user, $setup.missionId))
            }, null, 8, ["userInformationVOList"])) : (vue.openBlock(), vue.createElementBlock("view", {
              key: 3,
              class: "empty-state"
            }, "暂无联系人"))
          ],
          64
          /* STABLE_FRAGMENT */
        ))
      ]),
      vue.createCommentVNode(" 联系人详情组件 "),
      $setup.selectedContact ? (vue.openBlock(), vue.createBlock(_component_contact_detail_view, {
        key: 0,
        contact: $setup.selectedContact,
        onClose: $setup.closeContactDetail
      }, null, 8, ["contact", "onClose"])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const PagesContactsPagesContacts = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8], ["__scopeId", "data-v-15b516a0"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/pages/contacts.vue"]]);
  const _sfc_main$8 = {
    name: "TabBar",
    components: {
      MainPage: PagesProfileProfile,
      Messages: PagesMessageMain,
      Contacts: PagesContactsPagesContacts,
      TaskDetail: PagesTaskTaskDetailTaskDetail
    },
    data() {
      return {
        currentTab: 0,
        tabs: [
          {
            icon_nochoice: "../../static/tabBar/首页-未选中.png",
            icon_choice: "../../static/tabBar/首页-选中.png",
            label: "首页"
          },
          {
            icon_nochoice: "../../static/tabBar/通讯录-未选中.png",
            icon_choice: "../../static/tabBar/通讯录-选中.png",
            label: "通讯录"
          },
          {
            icon_nochoice: "../../static/tabBar/任务-未选中.png",
            icon_choice: "../../static/tabBar/任务-选中.png",
            label: "任务"
          },
          {
            icon_nochoice: "../../static/tabBar/我的-未选中.png",
            icon_choice: "../../static/tabBar/我的-选中.png",
            label: "我的"
          }
        ]
      };
    },
    methods: {
      onTabClick(index) {
        this.currentTab = index;
      },
      hideTabBar() {
        if (this.$refs.tabBar) {
          this.$refs.tabBar.style.display = "none";
        }
      },
      showTabBar() {
        if (this.$refs.tabBar) {
          this.$refs.tabBar.style.display = "flex";
        }
      }
    }
  };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TaskDetail = vue.resolveComponent("TaskDetail");
    const _component_messages = vue.resolveComponent("messages");
    const _component_main_page = vue.resolveComponent("main-page");
    const _component_contacts = vue.resolveComponent("contacts");
    return vue.openBlock(), vue.createElementBlock("view", { class: "main-container" }, [
      vue.createCommentVNode(" 主要内容区域 "),
      vue.createElementVNode("view", { class: "content-area" }, [
        $data.currentTab === 2 ? (vue.openBlock(), vue.createBlock(_component_TaskDetail, { key: 0 })) : $data.currentTab === 0 ? (vue.openBlock(), vue.createBlock(_component_messages, { key: 1 })) : $data.currentTab === 3 ? (vue.openBlock(), vue.createBlock(_component_main_page, { key: 2 })) : $data.currentTab === 1 ? (vue.openBlock(), vue.createBlock(_component_contacts, { key: 3 })) : (vue.openBlock(), vue.createElementBlock("view", {
          key: 4,
          class: "placeholder-content"
        }, [
          vue.createElementVNode(
            "text",
            null,
            "这是" + vue.toDisplayString(["首页", "", "", ""][$data.currentTab]) + "的内容",
            1
            /* TEXT */
          )
        ]))
      ]),
      vue.createCommentVNode(" 底部导航栏 "),
      vue.createElementVNode(
        "view",
        {
          class: "tab-bar",
          ref: "tabBar"
        },
        [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($data.tabs, (tab, index) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                key: index,
                class: "tab-item",
                onClick: ($event) => $options.onTabClick(index)
              }, [
                vue.createElementVNode("image", {
                  src: $data.currentTab === index ? tab.icon_choice : tab.icon_nochoice,
                  class: "tab-icon",
                  mode: "aspectFit"
                }, null, 8, ["src"]),
                vue.createElementVNode(
                  "text",
                  {
                    class: vue.normalizeClass(["tab-text", { "active": $data.currentTab === index }])
                  },
                  vue.toDisplayString(tab.label),
                  3
                  /* TEXT, CLASS */
                )
              ], 8, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        512
        /* NEED_PATCH */
      )
    ]);
  }
  const PagesTabBarTabBar = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7], ["__file", "E:/代码/new/zk_uniapp/pages/tabBar/tabBar.vue"]]);
  const poster = "/static/icon/poster.gif";
  const _sfc_main$7 = {
    __name: "video-call",
    setup(__props, { expose: __expose }) {
      __expose();
      let mainVideo = vue.ref();
      let secondaryVideo = vue.ref();
      let localUserMedia = vue.ref();
      let peerStore = usePeerStore();
      let isConnected = vue.ref(false);
      vue.onMounted((options) => {
        getLocalUserMedia({ audio: true, video: true }).then(
          (userMedia) => {
            let videoElement = document.getElementsByTagName("video")[0];
            videoElement.srcObject = userMedia;
            localUserMedia.value = userMedia;
            peerStore.dataConnection = peerStore.localPeer.connect(options.calleePeerId);
            peerStore.dataConnection.on("data", (data) => {
              var _a, _b, _c;
              if (data.instruction === peerStore.instruction.accept) {
                peerStore.mediaConnection = peerStore.localPeer.call(options.calleePeerId, localUserMedia.value);
                peerStore.mediaConnection.on("stream", (userMedia2) => {
                  mainVideo.value.srcObject = userMedia2;
                  mainVideo.value.muted = false;
                  secondaryVideo.value.srcObject = localUserMedia.value;
                  secondaryVideo.value.muted = true;
                  isConnected.value = true;
                  uni.showToast({
                    title: "connected"
                  });
                });
              } else if (data.instruction === peerStore.instruction.busy) {
                peerStore.dataConnection.close();
                peerStore.dataConnection = void 0;
                for (let track of (_a = localUserMedia.value) == null ? void 0 : _a.getTracks()) {
                  track.stop();
                }
                uni.showToast({
                  title: "the other party is busy on the line",
                  icon: "none"
                });
                uni.navigateBack();
              } else if (data.instruction === peerStore.instruction.reject) {
                peerStore.dataConnection.close();
                peerStore.dataConnection = void 0;
                for (let track of (_b = localUserMedia.value) == null ? void 0 : _b.getTracks()) {
                  track.stop();
                }
                uni.showToast({
                  title: "the other party refused",
                  icon: "none"
                });
                uni.navigateBack();
              } else if (data.instruction === peerStore.instruction.ringOff) {
                peerStore.dataConnection.close();
                peerStore.dataConnection = void 0;
                peerStore.mediaConnection.close();
                peerStore.mediaConnection = void 0;
                for (let track of (_c = localUserMedia.value) == null ? void 0 : _c.getTracks()) {
                  track.stop();
                }
                uni.showToast({
                  title: "the other party has hung up",
                  icon: "none"
                });
                uni.navigateBack();
              }
            });
            peerStore.dataConnection.on("open", () => {
              peerStore.dataConnection.send({
                instruction: peerStore.instruction.request
              });
            });
          }
        ).catch((e2) => {
          uni.showToast({
            title: "获取摄像头失败！",
            icon: "none"
          });
          formatAppLog("log", "at pages/message/video-call.vue:120", e2);
        });
      });
      function getLocalUserMedia(constrains) {
        if (navigator.mediaDevices.getUserMedia) {
          return navigator.mediaDevices.getUserMedia(constrains);
        } else if (navigator.webkitGetUserMedia) {
          return navigator.webkitGetUserMedia(constrains);
        } else if (navigator.mozGetUserMedia) {
          return navigator.mozGetUserMedia(constrains);
        } else if (navigator.getUserMedia) {
          return navigator.getUserMedia(constrains);
        }
        throw new Error("unable to get user media");
      }
      function cancelVideoCall() {
        var _a, _b;
        for (let track of (_a = localUserMedia.value) == null ? void 0 : _a.getTracks()) {
          track.stop();
        }
        (_b = peerStore.dataConnection) == null ? void 0 : _b.send({
          instruction: peerStore.instruction.cancel
        });
        peerStore.dataConnection = void 0;
        uni.navigateBack();
      }
      function ringOffVideoCall() {
        var _a;
        for (let track of (_a = localUserMedia.value) == null ? void 0 : _a.getTracks()) {
          track.stop();
        }
        peerStore.dataConnection.send({
          instruction: peerStore.instruction.ringOff
        });
        peerStore.dataConnection = void 0;
        peerStore.mediaConnection = void 0;
        uni.navigateBack();
      }
      const __returned__ = { get mainVideo() {
        return mainVideo;
      }, set mainVideo(v2) {
        mainVideo = v2;
      }, get secondaryVideo() {
        return secondaryVideo;
      }, set secondaryVideo(v2) {
        secondaryVideo = v2;
      }, get localUserMedia() {
        return localUserMedia;
      }, set localUserMedia(v2) {
        localUserMedia = v2;
      }, get peerStore() {
        return peerStore;
      }, set peerStore(v2) {
        peerStore = v2;
      }, get isConnected() {
        return isConnected;
      }, set isConnected(v2) {
        isConnected = v2;
      }, getLocalUserMedia, cancelVideoCall, ringOffVideoCall, get poster() {
        return poster;
      }, get usePeerStore() {
        return usePeerStore;
      }, onMounted: vue.onMounted, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createCommentVNode(" 视频画面 "),
      vue.createElementVNode("video", {
        class: "main-video",
        ref: "mainVideo",
        poster: $setup.poster,
        autoplay: ""
      }, null, 8, ["poster"]),
      vue.createElementVNode("video", {
        class: "secondary-video",
        ref: "secondaryVideo",
        poster: $setup.poster,
        autoplay: ""
      }, null, 8, ["poster"]),
      vue.createElementVNode("section", { class: "buttom-bar" }, [
        $setup.isConnected ? (vue.openBlock(), vue.createElementBlock("button", {
          key: 0,
          type: "warn",
          onClick: $setup.ringOffVideoCall
        })) : (vue.openBlock(), vue.createElementBlock("button", {
          key: 1,
          type: "warn",
          onClick: $setup.cancelVideoCall
        }))
      ])
    ]);
  }
  const PagesMessageVideoCall = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6], ["__file", "E:/代码/new/zk_uniapp/pages/message/video-call.vue"]]);
  const _sfc_main$6 = {
    data() {
      return {};
    },
    methods: {}
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view");
  }
  const PagesMessageChatComponentCallReminder = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$5], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/CallReminder.vue"]]);
  const _sfc_main$5 = {
    __name: "video-answer",
    setup(__props, { expose: __expose }) {
      __expose();
      let mainVideo = vue.ref();
      let secondaryVideo = vue.ref();
      let localUserMedia = vue.ref();
      let peerStore = usePeerStore();
      let router = useRouter();
      let isConnected = vue.ref(false);
      vue.onMounted(() => {
        getLocalUserMedia({ audio: true, video: true }).then((userMedia) => {
          mainVideo.value.srcObject = userMedia;
          localUserMedia.value = userMedia;
          peerStore.mediaConnection.answer(localUserMedia.value);
          peerStore.mediaConnection.on("stream", (remoteUserMedia) => {
            mainVideo.value.srcObject = remoteUserMedia;
            secondaryVideo.value.srcObject = localUserMedia.value;
            isConnected.value = true;
            uni.showToast({
              title: "connected"
            });
          });
        }).catch(() => {
          uni.showToast({
            title: "failed to obtain local video media",
            icon: "none"
          });
          uni.navigateBack();
        });
      });
      let cancel = vue.watch(() => [peerStore.dataConnection, peerStore.mediaConnection], ([dataConnection, mediaConnection]) => {
        if (dataConnection === void 0 && mediaConnection === void 0) {
          cancel();
          if (localUserMedia.value) {
            for (let track of localUserMedia.value.getTracks()) {
              track.stop();
            }
          }
          uni.showToast({
            title: "the other party has hung up"
          });
          uni.navigateBack();
        }
      }, { immediate: true });
      function getLocalUserMedia(constrains) {
        if (navigator.mediaDevices.getUserMedia) {
          return navigator.mediaDevices.getUserMedia(constrains);
        } else if (navigator.webkitGetUserMedia) {
          return navigator.webkitGetUserMedia(constrains);
        } else if (navigator.mozGetUserMedia) {
          return navigator.mozGetUserMedia(constrains);
        } else if (navigator.getUserMedia) {
          return navigator.getUserMedia(constrains);
        }
        throw new Error("unable to get user media");
      }
      function ringOffVideoCall() {
        var _a;
        cancel();
        for (let track of (_a = localUserMedia.value) == null ? void 0 : _a.getTracks()) {
          track.stop();
        }
        peerStore.dataConnection.send({
          instruction: peerStore.instruction.ringOff
        });
        peerStore.dataConnection = void 0;
        peerStore.mediaConnection = void 0;
        uni.navigateBack();
      }
      const __returned__ = { get mainVideo() {
        return mainVideo;
      }, set mainVideo(v2) {
        mainVideo = v2;
      }, get secondaryVideo() {
        return secondaryVideo;
      }, set secondaryVideo(v2) {
        secondaryVideo = v2;
      }, get localUserMedia() {
        return localUserMedia;
      }, set localUserMedia(v2) {
        localUserMedia = v2;
      }, get peerStore() {
        return peerStore;
      }, set peerStore(v2) {
        peerStore = v2;
      }, get router() {
        return router;
      }, set router(v2) {
        router = v2;
      }, get isConnected() {
        return isConnected;
      }, set isConnected(v2) {
        isConnected = v2;
      }, get cancel() {
        return cancel;
      }, set cancel(v2) {
        cancel = v2;
      }, getLocalUserMedia, ringOffVideoCall, get poster() {
        return poster;
      }, get usePeerStore() {
        return usePeerStore;
      }, onMounted: vue.onMounted, ref: vue.ref, watch: vue.watch };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_button = vue.resolveComponent("van-button");
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createElementVNode("section", { class: "container" }, [
        vue.createElementVNode("video", {
          class: "main-video",
          ref: "mainVideo",
          poster: $setup.poster,
          autoplay: ""
        }, null, 8, ["poster"]),
        vue.createElementVNode("video", {
          class: "secondary-video",
          ref: "secondaryVideo",
          poster: $setup.poster,
          autoplay: ""
        }, null, 8, ["poster"]),
        vue.createElementVNode("section", { class: "bottom-bar" }, [
          $setup.isConnected ? (vue.openBlock(), vue.createBlock(_component_van_button, {
            key: 0,
            type: "danger",
            block: "",
            onClick: $setup.ringOffVideoCall
          }, {
            default: vue.withCtx(() => [
              vue.createTextVNode(" 挂断视频通话 ")
            ]),
            _: 1
            /* STABLE */
          })) : vue.createCommentVNode("v-if", true)
        ])
      ])
    ]);
  }
  const PagesMessageVideoAnswer = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__file", "E:/代码/new/zk_uniapp/pages/message/video-answer.vue"]]);
  const _imports_0 = "/static/icon/关闭.png";
  const _sfc_main$4 = {
    __name: "inputAccount",
    setup(__props, { expose: __expose }) {
      __expose();
      const { connect } = useWebSocket();
      const userStore = useUserStore();
      const autoLogin = vue.ref(false);
      const statusBarHeight = uni.getSystemInfoSync().statusBarHeight;
      const username = vue.ref("liuyuqi");
      const password = vue.ref("iecas.123");
      const backToFirstPage = () => {
        uni.navigateBack();
      };
      const goToTask = () => {
        uni.reLaunch({
          url: "/pages/tabBar/tabBar"
        });
      };
      const checkLogin = () => {
        uni.showLoading({
          title: "正在登录",
          mask: true
        });
        login({
          account: username.value,
          password: password.value
        }).then((res) => {
          if (res.code === 200) {
            uni.setStorageSync("username", username.value);
            uni.setStorageSync("password", password.value);
            uni.setStorageSync("token", res.data.token);
            formatAppLog("log", "at pages/login/camouflageLogin/inputAccount/inputAccount.vue:61", res.data.missionId, "res.data.missionId");
            const userData = {
              id: res.data.id,
              account: res.data.account,
              name: res.data.name,
              department: res.data.department,
              role: res.data.role,
              phone: res.data.phone,
              created: res.data.created,
              avatar: res.data.avatar,
              avatarUrl: res.data.avatarUrl,
              token: res.data.token,
              status: res.data.status,
              missionId: res.data.missionId || ""
              // 添加 missionId，如果不存在则设为空字符串
            };
            userStore.setUserData(userData);
            connect(res.data.id, res.data.token);
            uni.setStorageSync("userInfo", userData);
            formatAppLog("log", "at pages/login/camouflageLogin/inputAccount/inputAccount.vue:85", "登录成功。用户数据:", userData);
            formatAppLog("log", "at pages/login/camouflageLogin/inputAccount/inputAccount.vue:86", "保存的 missionId:", userData.missionId);
            uni.hideLoading();
            uni.showToast({
              title: "登录成功",
              duration: 2e3
            }).then(() => {
              goToTask();
            });
          } else {
            throw new Error(res.message || "登录失败");
          }
        }).catch((error) => {
          formatAppLog("error", "at pages/login/camouflageLogin/inputAccount/inputAccount.vue:99", "登录失败:", error);
          uni.hideLoading();
          uni.showToast({
            title: error.message || "登录失败",
            icon: "none",
            duration: 2e3
          });
        });
      };
      const __returned__ = { connect, userStore, autoLogin, statusBarHeight, username, password, backToFirstPage, goToTask, checkLogin, ref: vue.ref, onMounted: vue.onMounted, get login() {
        return login;
      }, get useUserStore() {
        return useUserStore;
      }, useWebSocket };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_easyinput = resolveEasycom(vue.resolveDynamicComponent("uni-easyinput"), __easycom_0$1);
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "inputAccountPage",
      style: { "padding": "0 15px 0 15px" }
    }, [
      vue.createElementVNode("view", { class: "inputAccountContent" }, [
        vue.createElementVNode("view", { class: "statusBarInput" }),
        vue.createElementVNode("view", { class: "inputAccountHeader" }, [
          vue.createCommentVNode(" 推特logo "),
          vue.createElementVNode("view", { class: "inputAccountHeaderLeft" }, [
            vue.createElementVNode("image", {
              onClick: $setup.backToFirstPage,
              src: _imports_0,
              style: { "width": "20px", "height": "20px" }
            })
          ]),
          vue.createElementVNode("view", { class: "inputAccountHeaderMiddle" }, [
            vue.createElementVNode("image", {
              src: _imports_1$6,
              style: { "width": "25px", "height": "25px" }
            })
          ])
        ]),
        vue.createElementVNode("view", null, [
          vue.createElementVNode("view", { style: { "text-align": "left", "margin-top": "30px" } }, [
            vue.createElementVNode("text", { style: { "letter-spacing": "3px", "font-size": "50rpx", "font-family": "fantasy", "font-weight": "550", "width": "75%" } }, "要开始使用，请先输入你的手机号码、邮箱地址或@用户名。")
          ]),
          vue.createElementVNode("view", { style: { "margin-top": "20px" } }, [
            vue.createVNode(_component_uni_easyinput, {
              class: "inputValue",
              trim: "all",
              modelValue: $setup.username,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.username = $event),
              placeholder: "手机号码/邮件地址或用户名"
            }, null, 8, ["modelValue"])
          ]),
          vue.createElementVNode("view", { style: { "margin-top": "20px" } }, [
            vue.createVNode(_component_uni_easyinput, {
              class: "inputValue",
              type: "password",
              trim: "all",
              modelValue: $setup.password,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.password = $event),
              placeholder: "密码"
            }, null, 8, ["modelValue"])
          ])
        ])
      ]),
      vue.createElementVNode("view", { class: "inputAccountFooter" }, [
        vue.createElementVNode("button", {
          onClick: $setup.checkLogin,
          style: { "background": "black", "border-radius": "30px", "color": "white" }
        }, "下一步")
      ])
    ]);
  }
  const PagesLoginCamouflageLoginInputAccountInputAccount = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3], ["__file", "E:/代码/new/zk_uniapp/pages/login/camouflageLogin/inputAccount/inputAccount.vue"]]);
  const popup = {
    data() {
      return {};
    },
    created() {
      this.popup = this.getParent();
    },
    methods: {
      /**
       * 获取父元素实例
       */
      getParent(name = "uniPopup") {
        let parent = this.$parent;
        let parentName = parent.$options.name;
        while (parentName !== name) {
          parent = parent.$parent;
          if (!parent)
            return false;
          parentName = parent.$options.name;
        }
        return parent;
      }
    }
  };
  const en = {
    "uni-popup.cancel": "cancel",
    "uni-popup.ok": "ok",
    "uni-popup.placeholder": "pleace enter",
    "uni-popup.title": "Hint",
    "uni-popup.shareTitle": "Share to"
  };
  const zhHans = {
    "uni-popup.cancel": "取消",
    "uni-popup.ok": "确定",
    "uni-popup.placeholder": "请输入",
    "uni-popup.title": "提示",
    "uni-popup.shareTitle": "分享到"
  };
  const zhHant = {
    "uni-popup.cancel": "取消",
    "uni-popup.ok": "確定",
    "uni-popup.placeholder": "請輸入",
    "uni-popup.title": "提示",
    "uni-popup.shareTitle": "分享到"
  };
  const messages = {
    en,
    "zh-Hans": zhHans,
    "zh-Hant": zhHant
  };
  const {
    t
  } = initVueI18n(messages);
  const _sfc_main$3 = {
    name: "uniPopupDialog",
    mixins: [popup],
    emits: ["confirm", "close", "update:modelValue", "input"],
    props: {
      inputType: {
        type: String,
        default: "text"
      },
      showClose: {
        type: Boolean,
        default: true
      },
      modelValue: {
        type: [Number, String],
        default: ""
      },
      placeholder: {
        type: [String, Number],
        default: ""
      },
      type: {
        type: String,
        default: "error"
      },
      mode: {
        type: String,
        default: "base"
      },
      title: {
        type: String,
        default: ""
      },
      content: {
        type: String,
        default: ""
      },
      beforeClose: {
        type: Boolean,
        default: false
      },
      cancelText: {
        type: String,
        default: ""
      },
      confirmText: {
        type: String,
        default: ""
      },
      maxlength: {
        type: Number,
        default: -1
      },
      focus: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        dialogType: "error",
        val: ""
      };
    },
    computed: {
      okText() {
        return this.confirmText || t("uni-popup.ok");
      },
      closeText() {
        return this.cancelText || t("uni-popup.cancel");
      },
      placeholderText() {
        return this.placeholder || t("uni-popup.placeholder");
      },
      titleText() {
        return this.title || t("uni-popup.title");
      }
    },
    watch: {
      type(val) {
        this.dialogType = val;
      },
      mode(val) {
        if (val === "input") {
          this.dialogType = "info";
        }
      },
      value(val) {
        if (this.maxlength != -1 && this.mode === "input") {
          this.val = val.slice(0, this.maxlength);
        } else {
          this.val = val;
        }
      },
      val(val) {
        this.$emit("update:modelValue", val);
      }
    },
    created() {
      this.popup.disableMask();
      if (this.mode === "input") {
        this.dialogType = "info";
        this.val = this.value;
        this.val = this.modelValue;
      } else {
        this.dialogType = this.type;
      }
    },
    methods: {
      /**
       * 点击确认按钮
       */
      onOk() {
        if (this.mode === "input") {
          this.$emit("confirm", this.val);
        } else {
          this.$emit("confirm");
        }
        if (this.beforeClose)
          return;
        this.popup.close();
      },
      /**
       * 点击取消按钮
       */
      closeDialog() {
        this.$emit("close");
        if (this.beforeClose)
          return;
        this.popup.close();
      },
      close() {
        this.popup.close();
      }
    }
  };
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-popup-dialog" }, [
      vue.createElementVNode("view", { class: "uni-dialog-title" }, [
        vue.createElementVNode(
          "text",
          {
            class: vue.normalizeClass(["uni-dialog-title-text", ["uni-popup__" + $data.dialogType]])
          },
          vue.toDisplayString($options.titleText),
          3
          /* TEXT, CLASS */
        )
      ]),
      $props.mode === "base" ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "uni-dialog-content"
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, () => [
          vue.createElementVNode(
            "text",
            { class: "uni-dialog-content-text" },
            vue.toDisplayString($props.content),
            1
            /* TEXT */
          )
        ], true)
      ])) : (vue.openBlock(), vue.createElementBlock("view", {
        key: 1,
        class: "uni-dialog-content"
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, () => [
          vue.withDirectives(vue.createElementVNode("input", {
            class: "uni-dialog-input",
            maxlength: $props.maxlength,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.val = $event),
            type: $props.inputType,
            placeholder: $options.placeholderText,
            focus: $props.focus
          }, null, 8, ["maxlength", "type", "placeholder", "focus"]), [
            [vue.vModelDynamic, $data.val]
          ])
        ], true)
      ])),
      vue.createElementVNode("view", { class: "uni-dialog-button-group" }, [
        $props.showClose ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "uni-dialog-button",
          onClick: _cache[1] || (_cache[1] = (...args) => $options.closeDialog && $options.closeDialog(...args))
        }, [
          vue.createElementVNode(
            "text",
            { class: "uni-dialog-button-text" },
            vue.toDisplayString($options.closeText),
            1
            /* TEXT */
          )
        ])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["uni-dialog-button", $props.showClose ? "uni-border-left" : ""]),
            onClick: _cache[2] || (_cache[2] = (...args) => $options.onOk && $options.onOk(...args))
          },
          [
            vue.createElementVNode(
              "text",
              { class: "uni-dialog-button-text uni-button-color" },
              vue.toDisplayString($options.okText),
              1
              /* TEXT */
            )
          ],
          2
          /* CLASS */
        )
      ])
    ]);
  }
  const __easycom_1 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2], ["__scopeId", "data-v-d78c88b7"], ["__file", "E:/代码/new/zk_uniapp/uni_modules/uni-popup/components/uni-popup-dialog/uni-popup-dialog.vue"]]);
  const DoubleUnicodePrefixReg = /^[\uD800-\uDBFF]$/;
  const DoubleUnicodeSuffixReg = /^[\uDC00-\uDFFF]$/;
  const DoubleUnicodeReg = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var Probability;
  (function(Probability2) {
    Probability2[Probability2["Unknown"] = 1e-13] = "Unknown";
    Probability2[Probability2["Rule"] = 1e-12] = "Rule";
    Probability2[Probability2["DICT"] = 2e-8] = "DICT";
    Probability2[Probability2["Surname"] = 1] = "Surname";
    Probability2[Probability2["Custom"] = 1] = "Custom";
  })(Probability || (Probability = {}));
  const Priority = {
    Normal: 1,
    Surname: 10,
    Custom: 100
  };
  function stringLength(text) {
    var _a;
    return text.length - (((_a = text.match(DoubleUnicodeReg)) === null || _a === void 0 ? void 0 : _a.length) || 0);
  }
  function splitString(text) {
    const result = [];
    let i2 = 0;
    while (i2 < text.length) {
      const char = text[i2];
      if (DoubleUnicodePrefixReg.test(char) && DoubleUnicodeSuffixReg.test(text[i2 + 1])) {
        result.push(text.substring(i2, i2 + 2));
        i2 += 2;
      } else {
        result.push(char);
        i2 += 1;
      }
    }
    return result;
  }
  class FastDictFactory {
    constructor() {
      this.NumberDICT = [];
      this.StringDICT = /* @__PURE__ */ new Map();
    }
    get(word) {
      if (word.length > 1) {
        return this.StringDICT.get(word);
      } else {
        const code = word.charCodeAt(0);
        return this.NumberDICT[code];
      }
    }
    set(word, pinyin2) {
      if (word.length > 1) {
        this.StringDICT.set(word, pinyin2);
      } else {
        const code = word.charCodeAt(0);
        this.NumberDICT[code] = pinyin2;
      }
    }
    clear() {
      this.NumberDICT = [];
      this.StringDICT.clear();
    }
  }
  const map = {
    "bǎng páng pāng": ["膀"],
    líng: [
      "〇",
      "伶",
      "凌",
      "刢",
      "囹",
      "坽",
      "夌",
      "姈",
      "婈",
      "孁",
      "岺",
      "彾",
      "掕",
      "昤",
      "朎",
      "柃",
      "棂",
      "櫺",
      "欞",
      "泠",
      "淩",
      "澪",
      "灵",
      "燯",
      "爧",
      "狑",
      "玲",
      "琌",
      "瓴",
      "皊",
      "砱",
      "祾",
      "秢",
      "竛",
      "笭",
      "紷",
      "綾",
      "绫",
      "羐",
      "羚",
      "翎",
      "聆",
      "舲",
      "苓",
      "菱",
      "蓤",
      "蔆",
      "蕶",
      "蛉",
      "衑",
      "裬",
      "詅",
      "跉",
      "軨",
      "輘",
      "酃",
      "醽",
      "鈴",
      "錂",
      "铃",
      "閝",
      "陵",
      "零",
      "霊",
      "霗",
      "霛",
      "霝",
      "靈",
      "駖",
      "魿",
      "鯪",
      "鲮",
      "鴒",
      "鸰",
      "鹷",
      "麢",
      "齡",
      "齢",
      "龄",
      "龗",
      "㥄"
    ],
    yī: [
      "一",
      "乊",
      "伊",
      "依",
      "医",
      "吚",
      "咿",
      "噫",
      "壱",
      "壹",
      "夁",
      "嫛",
      "嬄",
      "弌",
      "揖",
      "撎",
      "檹",
      "毉",
      "洢",
      "渏",
      "漪",
      "瑿",
      "畩",
      "祎",
      "禕",
      "稦",
      "繄",
      "蛜",
      "衤",
      "譩",
      "辷",
      "郼",
      "醫",
      "銥",
      "铱",
      "鷖",
      "鹥",
      "黟",
      "黳"
    ],
    "dīng zhēng": ["丁"],
    "kǎo qiǎo yú": ["丂"],
    qī: [
      "七",
      "倛",
      "僛",
      "凄",
      "嘁",
      "墄",
      "娸",
      "悽",
      "慼",
      "慽",
      "戚",
      "捿",
      "柒",
      "桤",
      "桼",
      "棲",
      "榿",
      "欺",
      "沏",
      "淒",
      "漆",
      "紪",
      "緀",
      "萋",
      "褄",
      "諆",
      "迉",
      "郪",
      "鏚",
      "霋",
      "魌",
      "鶈"
    ],
    shàng: ["丄", "尙", "尚", "恦", "緔", "绱"],
    xià: [
      "丅",
      "下",
      "乤",
      "圷",
      "夏",
      "夓",
      "懗",
      "梺",
      "疜",
      "睱",
      "罅",
      "鎼",
      "鏬"
    ],
    hǎn: ["丆", "喊", "浫", "罕", "豃", "㘎"],
    "wàn mò": ["万"],
    zhàng: [
      "丈",
      "仗",
      "墇",
      "嶂",
      "帐",
      "帳",
      "幛",
      "扙",
      "杖",
      "涱",
      "痮",
      "瘬",
      "瘴",
      "瞕",
      "粀",
      "胀",
      "脹",
      "賬",
      "账",
      "障"
    ],
    sān: ["三", "厁", "叁", "弎", "毵", "毶", "毿", "犙", "鬖"],
    "shàng shǎng shang": ["上"],
    "qí jī": ["丌", "其", "奇"],
    "bù fǒu": ["不"],
    "yǔ yù yú": ["与"],
    miǎn: [
      "丏",
      "偭",
      "免",
      "冕",
      "勉",
      "勔",
      "喕",
      "娩",
      "愐",
      "汅",
      "沔",
      "湎",
      "睌",
      "緬",
      "缅",
      "腼",
      "葂",
      "靦",
      "鮸",
      "𩾃"
    ],
    gài: [
      "丐",
      "乢",
      "匃",
      "匄",
      "戤",
      "概",
      "槩",
      "槪",
      "溉",
      "漑",
      "瓂",
      "葢",
      "鈣",
      "钙",
      "𬮿"
    ],
    chǒu: ["丑", "丒", "侴", "吜", "杽", "瞅", "矁", "醜", "魗"],
    zhuān: [
      "专",
      "叀",
      "嫥",
      "専",
      "專",
      "瑼",
      "甎",
      "砖",
      "磗",
      "磚",
      "蟤",
      "諯",
      "鄟",
      "顓",
      "颛",
      "鱄",
      "䏝"
    ],
    "qiě jū": ["且"],
    pī: [
      "丕",
      "伓",
      "伾",
      "噼",
      "坯",
      "岯",
      "憵",
      "批",
      "披",
      "炋",
      "狉",
      "狓",
      "砒",
      "磇",
      "礔",
      "礕",
      "秛",
      "秠",
      "耚",
      "豾",
      "邳",
      "鈚",
      "鉟",
      "銔",
      "錃",
      "錍",
      "霹",
      "駓",
      "髬",
      "魾",
      "𬳵"
    ],
    shì: [
      "世",
      "丗",
      "亊",
      "事",
      "仕",
      "侍",
      "冟",
      "势",
      "勢",
      "卋",
      "呩",
      "嗜",
      "噬",
      "士",
      "奭",
      "嬕",
      "室",
      "市",
      "式",
      "弑",
      "弒",
      "恀",
      "恃",
      "戺",
      "拭",
      "揓",
      "是",
      "昰",
      "枾",
      "柿",
      "栻",
      "澨",
      "烒",
      "煶",
      "眂",
      "眎",
      "眡",
      "睗",
      "示",
      "礻",
      "筮",
      "簭",
      "舐",
      "舓",
      "襫",
      "視",
      "视",
      "觢",
      "試",
      "誓",
      "諡",
      "謚",
      "试",
      "谥",
      "貰",
      "贳",
      "軾",
      "轼",
      "逝",
      "遾",
      "釈",
      "释",
      "釋",
      "鈰",
      "鉃",
      "鉽",
      "铈",
      "飾",
      "餙",
      "餝",
      "饰",
      "鰘",
      "䏡",
      "𬤊"
    ],
    qiū: [
      "丘",
      "丠",
      "坵",
      "媝",
      "恘",
      "恷",
      "楸",
      "秋",
      "秌",
      "穐",
      "篍",
      "緧",
      "萩",
      "蘒",
      "蚯",
      "蝵",
      "蟗",
      "蠤",
      "趥",
      "邱",
      "鞦",
      "鞧",
      "鰌",
      "鰍",
      "鳅",
      "鶖",
      "鹙",
      "龝"
    ],
    bǐng: [
      "丙",
      "屛",
      "怲",
      "抦",
      "昞",
      "昺",
      "柄",
      "棅",
      "炳",
      "禀",
      "秉",
      "稟",
      "苪",
      "蛃",
      "邴",
      "鈵",
      "陃",
      "鞆",
      "餅",
      "餠",
      "饼"
    ],
    yè: [
      "业",
      "亱",
      "僷",
      "墷",
      "夜",
      "嶪",
      "嶫",
      "抴",
      "捙",
      "擛",
      "擪",
      "擫",
      "晔",
      "曄",
      "曅",
      "曗",
      "曳",
      "曵",
      "枼",
      "枽",
      "業",
      "洂",
      "液",
      "澲",
      "烨",
      "燁",
      "爗",
      "璍",
      "皣",
      "瞱",
      "瞸",
      "礏",
      "腋",
      "葉",
      "謁",
      "谒",
      "邺",
      "鄴",
      "鍱",
      "鐷",
      "靥",
      "靨",
      "頁",
      "页",
      "餣",
      "饁",
      "馌",
      "驜",
      "鵺",
      "鸈"
    ],
    cóng: [
      "丛",
      "从",
      "叢",
      "婃",
      "孮",
      "従",
      "徔",
      "徖",
      "悰",
      "樷",
      "欉",
      "淙",
      "灇",
      "爜",
      "琮",
      "藂",
      "誴",
      "賨",
      "賩",
      "錝"
    ],
    dōng: [
      "东",
      "倲",
      "冬",
      "咚",
      "埬",
      "岽",
      "崬",
      "徚",
      "昸",
      "東",
      "氡",
      "氭",
      "涷",
      "笗",
      "苳",
      "菄",
      "蝀",
      "鮗",
      "鯟",
      "鶇",
      "鶫",
      "鸫",
      "鼕",
      "𬟽"
    ],
    sī: [
      "丝",
      "俬",
      "凘",
      "厮",
      "司",
      "咝",
      "嘶",
      "噝",
      "媤",
      "廝",
      "恖",
      "撕",
      "斯",
      "楒",
      "泀",
      "澌",
      "燍",
      "禗",
      "禠",
      "私",
      "糹",
      "絲",
      "緦",
      "纟",
      "缌",
      "罳",
      "蕬",
      "虒",
      "蛳",
      "蜤",
      "螄",
      "蟖",
      "蟴",
      "鉰",
      "銯",
      "鍶",
      "鐁",
      "锶",
      "颸",
      "飔",
      "騦",
      "鷥",
      "鸶",
      "鼶",
      "㟃"
    ],
    chéng: [
      "丞",
      "呈",
      "城",
      "埕",
      "堘",
      "塍",
      "塖",
      "宬",
      "峸",
      "惩",
      "懲",
      "成",
      "承",
      "挰",
      "掁",
      "揨",
      "枨",
      "棖",
      "橙",
      "檙",
      "洆",
      "溗",
      "澂",
      "珵",
      "珹",
      "畻",
      "程",
      "窚",
      "筬",
      "絾",
      "脭",
      "荿",
      "誠",
      "诚",
      "郕",
      "酲",
      "鋮",
      "铖",
      "騬",
      "鯎"
    ],
    diū: ["丟", "丢", "銩", "铥"],
    liǎng: [
      "両",
      "两",
      "兩",
      "唡",
      "啢",
      "掚",
      "緉",
      "脼",
      "蜽",
      "裲",
      "魉",
      "魎",
      "𬜯"
    ],
    yǒu: [
      "丣",
      "卣",
      "友",
      "梄",
      "湵",
      "牖",
      "禉",
      "羑",
      "聈",
      "苃",
      "莠",
      "蜏",
      "酉",
      "銪",
      "铕",
      "黝"
    ],
    yán: [
      "严",
      "厳",
      "啱",
      "喦",
      "嚴",
      "塩",
      "壛",
      "壧",
      "妍",
      "姸",
      "娫",
      "娮",
      "岩",
      "嵒",
      "嵓",
      "巌",
      "巖",
      "巗",
      "延",
      "揅",
      "昖",
      "楌",
      "檐",
      "櫩",
      "欕",
      "沿",
      "炎",
      "炏",
      "狿",
      "琂",
      "盐",
      "碞",
      "筵",
      "簷",
      "莚",
      "蔅",
      "虤",
      "蜒",
      "言",
      "訁",
      "訮",
      "詽",
      "讠",
      "郔",
      "閆",
      "閻",
      "闫",
      "阎",
      "顏",
      "顔",
      "颜",
      "鹽",
      "麣",
      "𫄧"
    ],
    bìng: [
      "並",
      "併",
      "倂",
      "傡",
      "垪",
      "摒",
      "栤",
      "病",
      "窉",
      "竝",
      "誁",
      "靐",
      "鮩"
    ],
    "sàng sāng": ["丧"],
    gǔn: [
      "丨",
      "惃",
      "滚",
      "滾",
      "磙",
      "緄",
      "绲",
      "蓘",
      "蔉",
      "衮",
      "袞",
      "輥",
      "辊",
      "鮌",
      "鯀",
      "鲧"
    ],
    jiū: [
      "丩",
      "勼",
      "啾",
      "揪",
      "揫",
      "朻",
      "究",
      "糾",
      "纠",
      "萛",
      "赳",
      "阄",
      "鬏",
      "鬮",
      "鳩",
      "鸠"
    ],
    "gè gě": ["个", "個", "各"],
    yā: [
      "丫",
      "圧",
      "孲",
      "庘",
      "押",
      "枒",
      "桠",
      "椏",
      "錏",
      "鐚",
      "鴉",
      "鴨",
      "鵶",
      "鸦",
      "鸭"
    ],
    pán: [
      "丬",
      "媻",
      "幋",
      "槃",
      "洀",
      "瀊",
      "爿",
      "盘",
      "盤",
      "磐",
      "縏",
      "蒰",
      "蟠",
      "蹒",
      "蹣",
      "鎜",
      "鞶"
    ],
    "zhōng zhòng": ["中"],
    jǐ: [
      "丮",
      "妀",
      "己",
      "戟",
      "挤",
      "掎",
      "撠",
      "擠",
      "橶",
      "泲",
      "犱",
      "脊",
      "虮",
      "蟣",
      "魢",
      "鱾",
      "麂"
    ],
    jiè: [
      "丯",
      "介",
      "借",
      "唶",
      "堺",
      "屆",
      "届",
      "岕",
      "庎",
      "徣",
      "戒",
      "楐",
      "犗",
      "玠",
      "琾",
      "界",
      "畍",
      "疥",
      "砎",
      "蚧",
      "蛶",
      "衸",
      "褯",
      "誡",
      "诫",
      "鎅",
      "骱",
      "魪"
    ],
    fēng: [
      "丰",
      "仹",
      "偑",
      "僼",
      "凨",
      "凬",
      "凮",
      "妦",
      "寷",
      "封",
      "峯",
      "峰",
      "崶",
      "枫",
      "楓",
      "檒",
      "沣",
      "沨",
      "渢",
      "灃",
      "烽",
      "犎",
      "猦",
      "琒",
      "疯",
      "瘋",
      "盽",
      "砜",
      "碸",
      "篈",
      "蘴",
      "蜂",
      "蠭",
      "豐",
      "鄷",
      "酆",
      "鋒",
      "鎽",
      "鏠",
      "锋",
      "霻",
      "靊",
      "飌",
      "麷"
    ],
    "guàn kuàng": ["丱"],
    chuàn: ["串", "汌", "玔", "賗", "釧", "钏"],
    chǎn: [
      "丳",
      "产",
      "冁",
      "剷",
      "囅",
      "嵼",
      "旵",
      "浐",
      "滻",
      "灛",
      "產",
      "産",
      "簅",
      "蒇",
      "蕆",
      "諂",
      "譂",
      "讇",
      "谄",
      "鏟",
      "铲",
      "閳",
      "闡",
      "阐",
      "骣",
      "𬊤"
    ],
    lín: [
      "临",
      "冧",
      "壣",
      "崊",
      "嶙",
      "斴",
      "晽",
      "暽",
      "林",
      "潾",
      "瀶",
      "燐",
      "琳",
      "璘",
      "瞵",
      "碄",
      "磷",
      "粦",
      "粼",
      "繗",
      "翷",
      "臨",
      "轔",
      "辚",
      "遴",
      "邻",
      "鄰",
      "鏻",
      "阾",
      "隣",
      "霖",
      "驎",
      "鱗",
      "鳞",
      "麐",
      "麟",
      "𬴊",
      "𬭸"
    ],
    zhuó: [
      "丵",
      "劅",
      "卓",
      "啄",
      "圴",
      "妰",
      "娺",
      "撯",
      "擆",
      "擢",
      "斫",
      "斮",
      "斱",
      "斲",
      "斵",
      "晫",
      "椓",
      "浊",
      "浞",
      "濁",
      "灼",
      "烵",
      "琸",
      "硺",
      "禚",
      "窡",
      "籗",
      "籱",
      "罬",
      "茁",
      "蠗",
      "蠿",
      "諁",
      "諑",
      "謶",
      "诼",
      "酌",
      "鐲",
      "镯",
      "鵫",
      "鷟",
      "䓬",
      "𬸦"
    ],
    zhǔ: [
      "丶",
      "主",
      "劯",
      "嘱",
      "囑",
      "宔",
      "帾",
      "拄",
      "渚",
      "濐",
      "煑",
      "煮",
      "燝",
      "瞩",
      "矚",
      "罜",
      "詝",
      "陼",
      "鸀",
      "麈",
      "𬣞"
    ],
    bā: [
      "丷",
      "仈",
      "八",
      "叭",
      "哵",
      "夿",
      "岜",
      "巴",
      "捌",
      "朳",
      "玐",
      "疤",
      "笆",
      "粑",
      "羓",
      "芭",
      "蚆",
      "豝",
      "釟"
    ],
    wán: [
      "丸",
      "刓",
      "完",
      "岏",
      "抏",
      "捖",
      "汍",
      "烷",
      "玩",
      "琓",
      "笂",
      "紈",
      "纨",
      "翫",
      "芄",
      "貦",
      "頑",
      "顽"
    ],
    dān: [
      "丹",
      "勯",
      "匰",
      "単",
      "妉",
      "媅",
      "殚",
      "殫",
      "甔",
      "眈",
      "砃",
      "箪",
      "簞",
      "耼",
      "耽",
      "聃",
      "聸",
      "褝",
      "襌",
      "躭",
      "郸",
      "鄲",
      "酖",
      "頕"
    ],
    "wèi wéi": ["为"],
    "jǐng dǎn": ["丼"],
    "lì lí": ["丽"],
    jǔ: [
      "举",
      "弆",
      "挙",
      "擧",
      "椇",
      "榉",
      "榘",
      "櫸",
      "欅",
      "矩",
      "筥",
      "聥",
      "舉",
      "莒",
      "蒟",
      "襷",
      "踽",
      "齟",
      "龃"
    ],
    piě: ["丿", "苤", "鐅", "𬭯"],
    fú: [
      "乀",
      "伏",
      "俘",
      "凫",
      "刜",
      "匐",
      "咈",
      "哹",
      "垘",
      "孚",
      "岪",
      "巿",
      "帗",
      "幅",
      "幞",
      "弗",
      "彿",
      "怫",
      "扶",
      "柫",
      "栿",
      "桴",
      "氟",
      "泭",
      "浮",
      "涪",
      "澓",
      "炥",
      "玸",
      "甶",
      "畉",
      "癁",
      "祓",
      "福",
      "稪",
      "符",
      "箙",
      "紱",
      "紼",
      "絥",
      "綍",
      "绂",
      "绋",
      "罘",
      "罦",
      "翇",
      "艀",
      "芙",
      "芣",
      "苻",
      "茀",
      "茯",
      "菔",
      "葍",
      "虙",
      "蚨",
      "蜉",
      "蝠",
      "袚",
      "袱",
      "襆",
      "襥",
      "諨",
      "豧",
      "踾",
      "輻",
      "辐",
      "郛",
      "鉘",
      "鉜",
      "韍",
      "韨",
      "颫",
      "髴",
      "鮄",
      "鮲",
      "鳧",
      "鳬",
      "鴔",
      "鵩",
      "黻"
    ],
    "yí jí": ["乁"],
    yì: [
      "乂",
      "义",
      "亄",
      "亦",
      "亿",
      "伇",
      "伿",
      "佾",
      "俋",
      "億",
      "兿",
      "刈",
      "劓",
      "劮",
      "勚",
      "勩",
      "匇",
      "呓",
      "呭",
      "呹",
      "唈",
      "囈",
      "圛",
      "坄",
      "垼",
      "埸",
      "奕",
      "嫕",
      "嬑",
      "寱",
      "屹",
      "峄",
      "嶧",
      "帟",
      "帠",
      "幆",
      "廙",
      "异",
      "弈",
      "弋",
      "役",
      "忆",
      "怈",
      "怿",
      "悒",
      "意",
      "憶",
      "懌",
      "懿",
      "抑",
      "挹",
      "敡",
      "易",
      "晹",
      "曀",
      "曎",
      "杙",
      "枍",
      "棭",
      "榏",
      "槸",
      "檍",
      "歝",
      "殔",
      "殪",
      "殹",
      "毅",
      "浂",
      "浥",
      "浳",
      "湙",
      "溢",
      "潩",
      "澺",
      "瀷",
      "炈",
      "焲",
      "熠",
      "熤",
      "熼",
      "燚",
      "燡",
      "燱",
      "獈",
      "玴",
      "異",
      "疫",
      "痬",
      "瘗",
      "瘞",
      "瘱",
      "癔",
      "益",
      "瞖",
      "穓",
      "竩",
      "篒",
      "縊",
      "繶",
      "繹",
      "绎",
      "缢",
      "義",
      "羿",
      "翊",
      "翌",
      "翳",
      "翼",
      "耴",
      "肄",
      "肊",
      "膉",
      "臆",
      "艗",
      "艺",
      "芅",
      "苅",
      "萟",
      "蓺",
      "薏",
      "藙",
      "藝",
      "蘙",
      "虉",
      "蜴",
      "螠",
      "衪",
      "袣",
      "裔",
      "裛",
      "褹",
      "襼",
      "訲",
      "訳",
      "詍",
      "詣",
      "誼",
      "譯",
      "議",
      "讛",
      "议",
      "译",
      "诣",
      "谊",
      "豙",
      "豛",
      "豷",
      "貖",
      "贀",
      "跇",
      "轶",
      "逸",
      "邑",
      "鄓",
      "醷",
      "釴",
      "鈠",
      "鎰",
      "鐿",
      "镒",
      "镱",
      "阣",
      "隿",
      "霬",
      "饐",
      "駅",
      "驛",
      "驿",
      "骮",
      "鮨",
      "鶂",
      "鶃",
      "鶍",
      "鷁",
      "鷊",
      "鷧",
      "鷾",
      "鸃",
      "鹝",
      "鹢",
      "黓",
      "齸",
      "𬬩",
      "㑊",
      "𫄷",
      "𬟁"
    ],
    nǎi: ["乃", "倷", "奶", "嬭", "廼", "氖", "疓", "艿", "迺", "釢"],
    wǔ: [
      "乄",
      "五",
      "仵",
      "伍",
      "侮",
      "倵",
      "儛",
      "午",
      "啎",
      "妩",
      "娬",
      "嫵",
      "庑",
      "廡",
      "忤",
      "怃",
      "憮",
      "摀",
      "武",
      "潕",
      "熓",
      "牾",
      "玝",
      "珷",
      "瑦",
      "甒",
      "碔",
      "舞",
      "躌",
      "迕",
      "逜",
      "陚",
      "鵡",
      "鹉",
      "𣲘"
    ],
    jiǔ: [
      "久",
      "乆",
      "九",
      "乣",
      "奺",
      "杦",
      "汣",
      "灸",
      "玖",
      "紤",
      "舏",
      "酒",
      "镹",
      "韭",
      "韮"
    ],
    "tuō zhé": ["乇", "杔", "馲"],
    "me mó ma yāo": ["么"],
    zhī: [
      "之",
      "倁",
      "卮",
      "巵",
      "搘",
      "支",
      "栀",
      "梔",
      "椥",
      "榰",
      "汁",
      "泜",
      "疷",
      "祗",
      "祬",
      "秓",
      "稙",
      "綕",
      "肢",
      "胑",
      "胝",
      "脂",
      "芝",
      "蘵",
      "蜘",
      "衼",
      "隻",
      "鳷",
      "鴲",
      "鼅",
      "𦭜"
    ],
    "wū wù": ["乌"],
    zhà: [
      "乍",
      "咤",
      "宱",
      "搾",
      "榨",
      "溠",
      "痄",
      "蚱",
      "詐",
      "诈",
      "醡",
      "霅",
      "䃎"
    ],
    hū: [
      "乎",
      "乯",
      "匢",
      "匫",
      "呼",
      "唿",
      "嘑",
      "垀",
      "寣",
      "幠",
      "忽",
      "惚",
      "昒",
      "歑",
      "泘",
      "淴",
      "滹",
      "烀",
      "苸",
      "虍",
      "虖",
      "謼",
      "軤",
      "轷",
      "雐"
    ],
    fá: [
      "乏",
      "伐",
      "傠",
      "坺",
      "垡",
      "墢",
      "姂",
      "栰",
      "浌",
      "瞂",
      "笩",
      "筏",
      "罚",
      "罰",
      "罸",
      "藅",
      "閥",
      "阀"
    ],
    "lè yuè yào lào": ["乐", "樂"],
    yín: [
      "乑",
      "吟",
      "噖",
      "嚚",
      "圁",
      "垠",
      "夤",
      "婬",
      "寅",
      "峾",
      "崟",
      "崯",
      "檭",
      "殥",
      "泿",
      "淫",
      "滛",
      "烎",
      "犾",
      "狺",
      "璌",
      "硍",
      "碒",
      "荶",
      "蔩",
      "訔",
      "訚",
      "訡",
      "誾",
      "鄞",
      "鈝",
      "銀",
      "银",
      "霪",
      "鷣",
      "齦"
    ],
    pīng: ["乒", "俜", "娉", "涄", "甹", "砯", "聠", "艵", "頩"],
    pāng: ["乓", "滂", "胮", "膖", "雱", "霶"],
    qiáo: [
      "乔",
      "侨",
      "僑",
      "嫶",
      "憔",
      "桥",
      "槗",
      "樵",
      "橋",
      "櫵",
      "犞",
      "瞧",
      "硚",
      "礄",
      "荍",
      "荞",
      "蕎",
      "藮",
      "譙",
      "趫",
      "鐈",
      "鞒",
      "鞽",
      "顦"
    ],
    hǔ: ["乕", "琥", "萀", "虎", "虝", "錿", "鯱"],
    guāi: ["乖"],
    "chéng shèng": ["乗", "乘", "娍"],
    yǐ: [
      "乙",
      "乛",
      "以",
      "倚",
      "偯",
      "嬟",
      "崺",
      "已",
      "庡",
      "扆",
      "攺",
      "敼",
      "旑",
      "旖",
      "檥",
      "矣",
      "礒",
      "笖",
      "舣",
      "艤",
      "苡",
      "苢",
      "蚁",
      "螘",
      "蟻",
      "裿",
      "踦",
      "輢",
      "轙",
      "逘",
      "酏",
      "釔",
      "鈘",
      "鉯",
      "钇",
      "顗",
      "鳦",
      "齮",
      "𫖮",
      "𬺈"
    ],
    "háo yǐ": ["乚"],
    "niè miē": ["乜"],
    qǐ: [
      "乞",
      "企",
      "启",
      "唘",
      "啓",
      "啔",
      "啟",
      "婍",
      "屺",
      "杞",
      "棨",
      "玘",
      "盀",
      "綺",
      "绮",
      "芑",
      "諬",
      "起",
      "邔",
      "闙"
    ],
    yě: ["也", "冶", "嘢", "埜", "壄", "漜", "野"],
    xí: [
      "习",
      "喺",
      "媳",
      "嶍",
      "席",
      "椺",
      "檄",
      "漝",
      "習",
      "蓆",
      "袭",
      "襲",
      "覡",
      "觋",
      "謵",
      "趘",
      "郋",
      "鎴",
      "隰",
      "霫",
      "飁",
      "騱",
      "騽",
      "驨",
      "鰼",
      "鳛",
      "𠅤",
      "𫘬"
    ],
    xiāng: [
      "乡",
      "厢",
      "廂",
      "忀",
      "楿",
      "欀",
      "湘",
      "瓖",
      "稥",
      "箱",
      "緗",
      "缃",
      "膷",
      "芗",
      "萫",
      "葙",
      "薌",
      "襄",
      "郷",
      "鄉",
      "鄊",
      "鄕",
      "鑲",
      "镶",
      "香",
      "驤",
      "骧",
      "鱜",
      "麘",
      "𬙋"
    ],
    shū: [
      "书",
      "倏",
      "倐",
      "儵",
      "叔",
      "姝",
      "尗",
      "抒",
      "掓",
      "摅",
      "攄",
      "書",
      "枢",
      "梳",
      "樞",
      "殊",
      "殳",
      "毹",
      "毺",
      "淑",
      "瀭",
      "焂",
      "疎",
      "疏",
      "紓",
      "綀",
      "纾",
      "舒",
      "菽",
      "蔬",
      "踈",
      "軗",
      "輸",
      "输",
      "鄃",
      "陎",
      "鮛",
      "鵨"
    ],
    dǒu: ["乧", "抖", "枓", "蚪", "鈄", "阧", "陡"],
    shǐ: [
      "乨",
      "使",
      "兘",
      "史",
      "始",
      "宩",
      "屎",
      "榁",
      "矢",
      "笶",
      "豕",
      "鉂",
      "駛",
      "驶"
    ],
    jī: [
      "乩",
      "僟",
      "击",
      "刉",
      "刏",
      "剞",
      "叽",
      "唧",
      "喞",
      "嗘",
      "嘰",
      "圾",
      "基",
      "墼",
      "姬",
      "屐",
      "嵆",
      "嵇",
      "撃",
      "擊",
      "朞",
      "机",
      "枅",
      "樭",
      "機",
      "毄",
      "激",
      "犄",
      "玑",
      "璣",
      "畸",
      "畿",
      "癪",
      "矶",
      "磯",
      "积",
      "積",
      "笄",
      "筓",
      "箕",
      "簊",
      "緁",
      "羁",
      "羇",
      "羈",
      "耭",
      "肌",
      "芨",
      "虀",
      "覉",
      "覊",
      "譏",
      "譤",
      "讥",
      "賫",
      "賷",
      "赍",
      "跻",
      "踑",
      "躋",
      "躸",
      "銈",
      "錤",
      "鐖",
      "鑇",
      "鑙",
      "隮",
      "雞",
      "鞿",
      "韲",
      "飢",
      "饑",
      "饥",
      "魕",
      "鳮",
      "鶏",
      "鶺",
      "鷄",
      "鸄",
      "鸡",
      "齎",
      "齏",
      "齑",
      "𬯀",
      "𫓯",
      "𫓹",
      "𫌀"
    ],
    náng: ["乪", "嚢", "欜", "蠰", "饢"],
    jiā: [
      "乫",
      "佳",
      "傢",
      "加",
      "嘉",
      "抸",
      "枷",
      "梜",
      "毠",
      "泇",
      "浃",
      "浹",
      "犌",
      "猳",
      "珈",
      "痂",
      "笳",
      "糘",
      "耞",
      "腵",
      "葭",
      "袈",
      "豭",
      "貑",
      "跏",
      "迦",
      "鉫",
      "鎵",
      "镓",
      "鴐",
      "麚",
      "𬂩"
    ],
    jù: [
      "乬",
      "倨",
      "倶",
      "具",
      "剧",
      "劇",
      "勮",
      "埧",
      "埾",
      "壉",
      "姖",
      "屦",
      "屨",
      "岠",
      "巨",
      "巪",
      "怇",
      "惧",
      "愳",
      "懅",
      "懼",
      "拒",
      "拠",
      "昛",
      "歫",
      "洰",
      "澽",
      "炬",
      "烥",
      "犋",
      "秬",
      "窭",
      "窶",
      "簴",
      "粔",
      "耟",
      "聚",
      "虡",
      "蚷",
      "詎",
      "讵",
      "豦",
      "距",
      "踞",
      "躆",
      "遽",
      "邭",
      "醵",
      "鉅",
      "鐻",
      "钜",
      "颶",
      "飓",
      "駏",
      "鮔"
    ],
    shí: [
      "乭",
      "十",
      "埘",
      "塒",
      "姼",
      "实",
      "実",
      "寔",
      "實",
      "峕",
      "嵵",
      "时",
      "旹",
      "時",
      "榯",
      "湜",
      "溡",
      "炻",
      "祏",
      "竍",
      "蚀",
      "蝕",
      "辻",
      "遈",
      "鉐",
      "飠",
      "饣",
      "鮖",
      "鰣",
      "鲥",
      "鼫",
      "鼭"
    ],
    mǎo: ["乮", "冇", "卯", "峁", "戼", "昴", "泖", "笷", "蓩", "鉚", "铆"],
    mǎi: ["买", "嘪", "荬", "蕒", "買", "鷶"],
    luàn: ["乱", "亂", "釠"],
    rǔ: ["乳", "擩", "汝", "肗", "辱", "鄏"],
    xué: [
      "乴",
      "学",
      "學",
      "峃",
      "嶨",
      "斈",
      "泶",
      "澩",
      "燢",
      "穴",
      "茓",
      "袕",
      "踅",
      "鷽",
      "鸴"
    ],
    yǎn: [
      "䶮",
      "乵",
      "俨",
      "偃",
      "儼",
      "兖",
      "兗",
      "厣",
      "厴",
      "噞",
      "孍",
      "嵃",
      "巘",
      "巚",
      "弇",
      "愝",
      "戭",
      "扊",
      "抁",
      "掩",
      "揜",
      "曮",
      "椼",
      "檿",
      "沇",
      "渷",
      "演",
      "琰",
      "甗",
      "眼",
      "罨",
      "萒",
      "蝘",
      "衍",
      "褗",
      "躽",
      "遃",
      "郾",
      "隒",
      "顩",
      "魇",
      "魘",
      "鰋",
      "鶠",
      "黡",
      "黤",
      "黬",
      "黭",
      "黶",
      "鼴",
      "鼹",
      "齴",
      "龑",
      "𬸘",
      "𬙂",
      "𪩘"
    ],
    fǔ: [
      "乶",
      "俌",
      "俛",
      "俯",
      "府",
      "弣",
      "抚",
      "拊",
      "撫",
      "斧",
      "椨",
      "滏",
      "焤",
      "甫",
      "盙",
      "簠",
      "腐",
      "腑",
      "蜅",
      "輔",
      "辅",
      "郙",
      "釜",
      "釡",
      "阝",
      "頫",
      "鬴",
      "黼",
      "㕮",
      "𫖯"
    ],
    shā: [
      "乷",
      "唦",
      "杀",
      "桬",
      "殺",
      "毮",
      "猀",
      "痧",
      "砂",
      "硰",
      "紗",
      "繺",
      "纱",
      "蔱",
      "裟",
      "鎩",
      "铩",
      "閷",
      "髿",
      "魦",
      "鯊",
      "鯋",
      "鲨"
    ],
    nǎ: ["乸", "雫"],
    qián: [
      "乹",
      "亁",
      "仱",
      "偂",
      "前",
      "墘",
      "媊",
      "岒",
      "拑",
      "掮",
      "榩",
      "橬",
      "歬",
      "潛",
      "潜",
      "濳",
      "灊",
      "箝",
      "葥",
      "虔",
      "軡",
      "鈐",
      "鉗",
      "銭",
      "錢",
      "鎆",
      "钤",
      "钱",
      "钳",
      "靬",
      "騚",
      "騝",
      "鰬",
      "黔",
      "黚"
    ],
    suǒ: [
      "乺",
      "唢",
      "嗩",
      "所",
      "暛",
      "溑",
      "溹",
      "琐",
      "琑",
      "瑣",
      "索",
      "褨",
      "鎖",
      "鎻",
      "鏁",
      "锁"
    ],
    yú: [
      "乻",
      "于",
      "亐",
      "伃",
      "余",
      "堣",
      "堬",
      "妤",
      "娛",
      "娯",
      "娱",
      "嬩",
      "崳",
      "嵎",
      "嵛",
      "愚",
      "扵",
      "揄",
      "旟",
      "楡",
      "楰",
      "榆",
      "欤",
      "歈",
      "歟",
      "歶",
      "渔",
      "渝",
      "湡",
      "漁",
      "澞",
      "牏",
      "狳",
      "玗",
      "玙",
      "瑜",
      "璵",
      "盂",
      "睮",
      "窬",
      "竽",
      "籅",
      "羭",
      "腴",
      "臾",
      "舁",
      "舆",
      "艅",
      "茰",
      "萮",
      "萸",
      "蕍",
      "蘛",
      "虞",
      "虶",
      "蝓",
      "螸",
      "衧",
      "褕",
      "覦",
      "觎",
      "諛",
      "謣",
      "谀",
      "踰",
      "輿",
      "轝",
      "逾",
      "邘",
      "酑",
      "鍝",
      "隅",
      "雓",
      "雩",
      "餘",
      "馀",
      "騟",
      "骬",
      "髃",
      "魚",
      "魣",
      "鮽",
      "鯲",
      "鰅",
      "鱼",
      "鷠",
      "鸆",
      "齵"
    ],
    zhù: [
      "乼",
      "伫",
      "佇",
      "住",
      "坾",
      "墸",
      "壴",
      "嵀",
      "拀",
      "杼",
      "柱",
      "樦",
      "殶",
      "注",
      "炷",
      "疰",
      "眝",
      "祝",
      "祩",
      "竚",
      "筯",
      "箸",
      "篫",
      "簗",
      "紵",
      "紸",
      "纻",
      "羜",
      "翥",
      "苎",
      "莇",
      "蛀",
      "註",
      "貯",
      "贮",
      "跓",
      "軴",
      "鉒",
      "鋳",
      "鑄",
      "铸",
      "馵",
      "駐",
      "驻"
    ],
    zhě: ["乽", "者", "褶", "襵", "赭", "踷", "鍺", "锗"],
    "qián gān": ["乾"],
    "zhì luàn": ["乿"],
    guī: [
      "亀",
      "圭",
      "妫",
      "媯",
      "嫢",
      "嬀",
      "帰",
      "归",
      "摫",
      "椝",
      "槻",
      "槼",
      "櫷",
      "歸",
      "珪",
      "瑰",
      "璝",
      "瓌",
      "皈",
      "瞡",
      "硅",
      "茥",
      "蘬",
      "規",
      "规",
      "邽",
      "郌",
      "閨",
      "闺",
      "騩",
      "鬶",
      "鬹"
    ],
    "lǐn lìn": ["亃"],
    jué: [
      "亅",
      "决",
      "刔",
      "劂",
      "匷",
      "厥",
      "噊",
      "孒",
      "孓",
      "崛",
      "崫",
      "嶥",
      "彏",
      "憠",
      "憰",
      "戄",
      "抉",
      "挗",
      "掘",
      "攫",
      "桷",
      "橛",
      "橜",
      "欮",
      "氒",
      "決",
      "灍",
      "焳",
      "熦",
      "爑",
      "爴",
      "爵",
      "獗",
      "玃",
      "玦",
      "玨",
      "珏",
      "瑴",
      "瘚",
      "矍",
      "矡",
      "砄",
      "絕",
      "絶",
      "绝",
      "臄",
      "芵",
      "蕝",
      "蕨",
      "虳",
      "蟨",
      "蟩",
      "觖",
      "觮",
      "觼",
      "訣",
      "譎",
      "诀",
      "谲",
      "貜",
      "赽",
      "趉",
      "蹷",
      "躩",
      "鈌",
      "鐍",
      "鐝",
      "钁",
      "镢",
      "鴂",
      "鴃",
      "鷢",
      "𫘝",
      "㵐",
      "𫔎"
    ],
    "le liǎo": ["了"],
    "gè mā": ["亇"],
    "yǔ yú": ["予", "懙"],
    zhēng: [
      "争",
      "佂",
      "凧",
      "姃",
      "媜",
      "峥",
      "崝",
      "崢",
      "征",
      "徰",
      "炡",
      "烝",
      "爭",
      "狰",
      "猙",
      "癥",
      "眐",
      "睁",
      "睜",
      "筝",
      "箏",
      "篜",
      "聇",
      "脀",
      "蒸",
      "踭",
      "鉦",
      "錚",
      "鏳",
      "鬇"
    ],
    èr: ["二", "刵", "咡", "弍", "弐", "樲", "誀", "貮", "貳", "贰", "髶"],
    chù: [
      "亍",
      "傗",
      "儊",
      "怵",
      "憷",
      "搐",
      "斶",
      "歜",
      "珿",
      "琡",
      "矗",
      "竌",
      "絀",
      "绌",
      "臅",
      "触",
      "觸",
      "豖",
      "鄐",
      "閦",
      "黜"
    ],
    kuī: ["亏", "刲", "岿", "巋", "盔", "窥", "窺", "聧", "虧", "闚", "顝"],
    yún: [
      "云",
      "伝",
      "勻",
      "匀",
      "囩",
      "妘",
      "愪",
      "抣",
      "昀",
      "橒",
      "沄",
      "涢",
      "溳",
      "澐",
      "熉",
      "畇",
      "秐",
      "筼",
      "篔",
      "紜",
      "縜",
      "纭",
      "耘",
      "芸",
      "蒷",
      "蕓",
      "郧",
      "鄖",
      "鋆",
      "雲"
    ],
    hù: [
      "互",
      "冱",
      "嗀",
      "嚛",
      "婟",
      "嫭",
      "嫮",
      "岵",
      "帍",
      "弖",
      "怙",
      "戶",
      "户",
      "戸",
      "戽",
      "扈",
      "护",
      "昈",
      "槴",
      "沍",
      "沪",
      "滬",
      "熩",
      "瓠",
      "祜",
      "笏",
      "簄",
      "粐",
      "綔",
      "蔰",
      "護",
      "豰",
      "鄠",
      "鍙",
      "頀",
      "鱯",
      "鳠",
      "鳸",
      "鸌",
      "鹱"
    ],
    qí: [
      "亓",
      "剘",
      "埼",
      "岐",
      "岓",
      "崎",
      "嵜",
      "愭",
      "掑",
      "斉",
      "斊",
      "旂",
      "旗",
      "棊",
      "棋",
      "檱",
      "櫀",
      "歧",
      "淇",
      "濝",
      "猉",
      "玂",
      "琦",
      "琪",
      "璂",
      "畦",
      "疧",
      "碁",
      "碕",
      "祁",
      "祈",
      "祺",
      "禥",
      "竒",
      "簯",
      "簱",
      "籏",
      "粸",
      "綥",
      "綦",
      "肵",
      "脐",
      "臍",
      "艩",
      "芪",
      "萁",
      "萕",
      "蕲",
      "藄",
      "蘄",
      "蚑",
      "蚚",
      "蛴",
      "蜝",
      "蜞",
      "螧",
      "蠐",
      "褀",
      "軝",
      "鄿",
      "釮",
      "錡",
      "锜",
      "陭",
      "頎",
      "颀",
      "騎",
      "騏",
      "騹",
      "骐",
      "骑",
      "鬐",
      "鬿",
      "鯕",
      "鰭",
      "鲯",
      "鳍",
      "鵸",
      "鶀",
      "麒",
      "麡",
      "𨙸",
      "𬨂",
      "䓫"
    ],
    jǐng: [
      "井",
      "儆",
      "刭",
      "剄",
      "坓",
      "宑",
      "幜",
      "憬",
      "暻",
      "殌",
      "汫",
      "汬",
      "澋",
      "璄",
      "璟",
      "璥",
      "穽",
      "肼",
      "蟼",
      "警",
      "阱",
      "頚",
      "頸"
    ],
    sì: [
      "亖",
      "佀",
      "価",
      "儩",
      "兕",
      "嗣",
      "四",
      "姒",
      "娰",
      "孠",
      "寺",
      "巳",
      "柶",
      "榹",
      "汜",
      "泗",
      "泤",
      "洍",
      "洠",
      "涘",
      "瀃",
      "牭",
      "祀",
      "禩",
      "竢",
      "笥",
      "耜",
      "肂",
      "肆",
      "蕼",
      "覗",
      "貄",
      "釲",
      "鈶",
      "鈻",
      "飤",
      "飼",
      "饲",
      "駟",
      "騃",
      "驷"
    ],
    suì: [
      "亗",
      "嬘",
      "岁",
      "嵗",
      "旞",
      "檖",
      "歲",
      "歳",
      "澻",
      "煫",
      "燧",
      "璲",
      "砕",
      "碎",
      "祟",
      "禭",
      "穂",
      "穗",
      "穟",
      "繀",
      "繐",
      "繸",
      "襚",
      "誶",
      "譢",
      "谇",
      "賥",
      "邃",
      "鐆",
      "鐩",
      "隧",
      "韢",
      "𫟦",
      "𬭼"
    ],
    gèn: ["亘", "亙", "揯", "搄", "茛"],
    yà: [
      "亚",
      "亜",
      "俹",
      "冴",
      "劜",
      "圔",
      "圠",
      "埡",
      "娅",
      "婭",
      "揠",
      "氩",
      "氬",
      "犽",
      "砑",
      "稏",
      "聐",
      "襾",
      "覀",
      "訝",
      "讶",
      "迓",
      "齾"
    ],
    "xiē suò": ["些"],
    "qí zhāi": ["亝", "齊"],
    "yā yà": ["亞", "压", "垭", "壓", "铔"],
    "jí qì": ["亟", "焏"],
    tóu: ["亠", "投", "頭", "骰"],
    "wáng wú": ["亡"],
    "kàng háng gāng": ["亢"],
    dà: ["亣", "眔"],
    jiāo: [
      "交",
      "僬",
      "娇",
      "嬌",
      "峧",
      "嶕",
      "嶣",
      "憍",
      "椒",
      "浇",
      "澆",
      "焦",
      "礁",
      "穚",
      "簥",
      "胶",
      "膠",
      "膲",
      "茭",
      "茮",
      "蕉",
      "虠",
      "蛟",
      "蟭",
      "跤",
      "轇",
      "郊",
      "鐎",
      "驕",
      "骄",
      "鮫",
      "鲛",
      "鵁",
      "鷦",
      "鷮",
      "鹪",
      "䴔"
    ],
    hài: ["亥", "嗐", "害", "氦", "餀", "饚", "駭", "駴", "骇"],
    "hēng pēng": ["亨"],
    mǔ: [
      "亩",
      "姆",
      "峔",
      "拇",
      "母",
      "牡",
      "牳",
      "畂",
      "畆",
      "畒",
      "畝",
      "畞",
      "畮",
      "砪",
      "胟",
      "踇",
      "鉧",
      "𬭁",
      "𧿹"
    ],
    ye: ["亪"],
    xiǎng: [
      "享",
      "亯",
      "响",
      "想",
      "晑",
      "蚃",
      "蠁",
      "響",
      "飨",
      "餉",
      "饗",
      "饷",
      "鮝",
      "鯗",
      "鱶",
      "鲞"
    ],
    jīng: [
      "京",
      "亰",
      "兢",
      "坕",
      "坙",
      "婛",
      "惊",
      "旌",
      "旍",
      "晶",
      "橸",
      "泾",
      "涇",
      "猄",
      "睛",
      "秔",
      "稉",
      "粳",
      "精",
      "経",
      "經",
      "綡",
      "聙",
      "腈",
      "茎",
      "荆",
      "荊",
      "菁",
      "葏",
      "驚",
      "鯨",
      "鲸",
      "鶁",
      "鶄",
      "麖",
      "麠",
      "鼱",
      "䴖"
    ],
    tíng: [
      "亭",
      "停",
      "婷",
      "嵉",
      "庭",
      "廷",
      "楟",
      "榳",
      "筳",
      "聤",
      "莛",
      "葶",
      "蜓",
      "蝏",
      "諪",
      "邒",
      "霆",
      "鼮",
      "䗴"
    ],
    liàng: ["亮", "喨", "悢", "晾", "湸", "諒", "谅", "輌", "輛", "辆", "鍄"],
    "qīn qìng": ["亲", "親"],
    bó: [
      "亳",
      "仢",
      "侼",
      "僰",
      "博",
      "帛",
      "愽",
      "懪",
      "挬",
      "搏",
      "欂",
      "浡",
      "淿",
      "渤",
      "煿",
      "牔",
      "狛",
      "瓝",
      "礴",
      "秡",
      "箔",
      "簙",
      "糪",
      "胉",
      "脖",
      "膊",
      "舶",
      "艊",
      "萡",
      "葧",
      "袯",
      "襏",
      "襮",
      "謈",
      "踣",
      "郣",
      "鈸",
      "鉑",
      "鋍",
      "鎛",
      "鑮",
      "钹",
      "铂",
      "镈",
      "餺",
      "馎",
      "馛",
      "馞",
      "駁",
      "駮",
      "驳",
      "髆",
      "鵓",
      "鹁"
    ],
    yòu: [
      "亴",
      "佑",
      "佦",
      "侑",
      "又",
      "右",
      "哊",
      "唀",
      "囿",
      "姷",
      "宥",
      "峟",
      "幼",
      "狖",
      "祐",
      "蚴",
      "誘",
      "诱",
      "貁",
      "迶",
      "酭",
      "釉",
      "鼬"
    ],
    xiè: [
      "亵",
      "伳",
      "偞",
      "偰",
      "僁",
      "卨",
      "卸",
      "噧",
      "塮",
      "夑",
      "媟",
      "屑",
      "屧",
      "廨",
      "徢",
      "懈",
      "暬",
      "械",
      "榍",
      "榭",
      "泻",
      "洩",
      "渫",
      "澥",
      "瀉",
      "瀣",
      "灺",
      "炧",
      "炨",
      "燮",
      "爕",
      "獬",
      "祄",
      "禼",
      "糏",
      "紲",
      "絏",
      "絬",
      "繲",
      "纈",
      "绁",
      "缷",
      "薢",
      "薤",
      "蟹",
      "蠏",
      "褉",
      "褻",
      "謝",
      "谢",
      "躞",
      "邂",
      "靾",
      "韰",
      "齂",
      "齘",
      "齛",
      "齥",
      "𬹼",
      "𤫉"
    ],
    "dǎn dàn": ["亶", "馾"],
    lián: [
      "亷",
      "劆",
      "匲",
      "匳",
      "嗹",
      "噒",
      "奁",
      "奩",
      "嫾",
      "帘",
      "廉",
      "怜",
      "憐",
      "涟",
      "漣",
      "濂",
      "濓",
      "瀮",
      "熑",
      "燫",
      "簾",
      "籢",
      "籨",
      "縺",
      "翴",
      "联",
      "聨",
      "聫",
      "聮",
      "聯",
      "臁",
      "莲",
      "蓮",
      "薕",
      "螊",
      "蠊",
      "裢",
      "褳",
      "覝",
      "謰",
      "蹥",
      "连",
      "連",
      "鎌",
      "鐮",
      "镰",
      "鬑",
      "鰱",
      "鲢"
    ],
    duǒ: [
      "亸",
      "哚",
      "嚲",
      "埵",
      "崜",
      "朵",
      "朶",
      "綞",
      "缍",
      "趓",
      "躱",
      "躲",
      "軃"
    ],
    "wěi mén": ["亹", "斖"],
    rén: ["人", "亻", "仁", "壬", "忈", "忎", "朲", "秂", "芢", "魜", "鵀"],
    jí: [
      "亼",
      "亽",
      "伋",
      "佶",
      "偮",
      "卙",
      "即",
      "卽",
      "及",
      "叝",
      "吉",
      "堲",
      "塉",
      "姞",
      "嫉",
      "岌",
      "嵴",
      "嶯",
      "彶",
      "忣",
      "急",
      "愱",
      "戢",
      "揤",
      "极",
      "棘",
      "楫",
      "極",
      "槉",
      "檝",
      "殛",
      "汲",
      "湒",
      "潗",
      "疾",
      "瘠",
      "皍",
      "笈",
      "箿",
      "籍",
      "級",
      "级",
      "膌",
      "艥",
      "蒺",
      "蕀",
      "蕺",
      "蝍",
      "螏",
      "襋",
      "觙",
      "谻",
      "踖",
      "蹐",
      "躤",
      "輯",
      "轚",
      "辑",
      "郆",
      "銡",
      "鍓",
      "鏶",
      "集",
      "雧",
      "霵",
      "鹡",
      "㴔"
    ],
    wáng: ["亾", "仼", "兦", "莣", "蚟"],
    "shén shí": ["什"],
    lè: [
      "仂",
      "叻",
      "忇",
      "氻",
      "泐",
      "玏",
      "砳",
      "簕",
      "艻",
      "阞",
      "韷",
      "餎",
      "鰳",
      "鱳",
      "鳓"
    ],
    dīng: ["仃", "叮", "帄", "玎", "疔", "盯", "耵", "虰", "靪"],
    zè: ["仄", "崱", "庂", "捑", "昃", "昗", "汄"],
    "jǐn jìn": ["仅", "僅", "嫤"],
    "pú pū": ["仆"],
    "chóu qiú": ["仇"],
    zhǎng: ["仉", "幥", "掌", "礃"],
    jīn: [
      "今",
      "堻",
      "巾",
      "惍",
      "斤",
      "津",
      "珒",
      "琻",
      "璡",
      "砛",
      "筋",
      "荕",
      "衿",
      "襟",
      "觔",
      "金",
      "釒",
      "釿",
      "钅",
      "鹶",
      "黅",
      "𬬱"
    ],
    bīng: ["仌", "仒", "兵", "冫", "冰", "掤", "氷", "鋲"],
    réng: ["仍", "礽", "芿", "辸", "陾"],
    fó: ["仏", "坲", "梻"],
    "jīn sǎn": ["仐"],
    lún: [
      "仑",
      "伦",
      "侖",
      "倫",
      "囵",
      "圇",
      "婨",
      "崘",
      "崙",
      "棆",
      "沦",
      "淪",
      "磮",
      "腀",
      "菕",
      "蜦",
      "踚",
      "輪",
      "轮",
      "錀",
      "陯",
      "鯩",
      "𬬭"
    ],
    cāng: [
      "仓",
      "仺",
      "倉",
      "凔",
      "嵢",
      "沧",
      "滄",
      "濸",
      "獊",
      "舱",
      "艙",
      "苍",
      "蒼",
      "螥",
      "鸧"
    ],
    "zǎi zǐ zī": ["仔"],
    tā: ["他", "塌", "它", "榙", "溻", "牠", "祂", "褟", "趿", "遢", "闧"],
    fù: [
      "付",
      "偩",
      "傅",
      "冨",
      "副",
      "咐",
      "坿",
      "复",
      "妇",
      "婦",
      "媍",
      "嬔",
      "富",
      "復",
      "椱",
      "祔",
      "禣",
      "竎",
      "緮",
      "縛",
      "缚",
      "腹",
      "萯",
      "蕧",
      "蚹",
      "蛗",
      "蝜",
      "蝮",
      "袝",
      "複",
      "覄",
      "覆",
      "訃",
      "詂",
      "讣",
      "負",
      "賦",
      "賻",
      "负",
      "赋",
      "赙",
      "赴",
      "輹",
      "鍑",
      "鍢",
      "阜",
      "附",
      "馥",
      "駙",
      "驸",
      "鮒",
      "鰒",
      "鲋",
      "鳆",
      "㳇"
    ],
    xiān: [
      "仙",
      "仚",
      "佡",
      "僊",
      "僲",
      "先",
      "嘕",
      "奾",
      "屳",
      "廯",
      "忺",
      "憸",
      "掀",
      "暹",
      "杴",
      "氙",
      "珗",
      "祆",
      "秈",
      "籼",
      "繊",
      "纎",
      "纖",
      "苮",
      "褼",
      "襳",
      "跹",
      "蹮",
      "躚",
      "酰",
      "鍁",
      "锨",
      "韯",
      "韱",
      "馦",
      "鱻",
      "鶱",
      "𬸣"
    ],
    "tuō chà duó": ["仛"],
    hóng: [
      "仜",
      "吰",
      "垬",
      "妅",
      "娂",
      "宏",
      "宖",
      "弘",
      "彋",
      "汯",
      "泓",
      "洪",
      "浤",
      "渱",
      "潂",
      "玒",
      "玜",
      "竑",
      "竤",
      "篊",
      "粠",
      "紘",
      "紭",
      "綋",
      "纮",
      "翃",
      "翝",
      "耾",
      "苰",
      "荭",
      "葒",
      "葓",
      "谹",
      "谼",
      "鈜",
      "鉷",
      "鋐",
      "閎",
      "闳",
      "霐",
      "霟",
      "鞃",
      "魟",
      "鴻",
      "鸿",
      "黉",
      "黌",
      "𫟹",
      "𬭎"
    ],
    tóng: [
      "仝",
      "佟",
      "哃",
      "峂",
      "峝",
      "庝",
      "彤",
      "晍",
      "曈",
      "桐",
      "氃",
      "浵",
      "潼",
      "犝",
      "獞",
      "眮",
      "瞳",
      "砼",
      "秱",
      "童",
      "粡",
      "膧",
      "茼",
      "蚒",
      "詷",
      "赨",
      "酮",
      "鉖",
      "鉵",
      "銅",
      "铜",
      "餇",
      "鮦",
      "鲖",
      "𫍣",
      "𦒍"
    ],
    rèn: [
      "仞",
      "仭",
      "刃",
      "刄",
      "妊",
      "姙",
      "屻",
      "岃",
      "扨",
      "牣",
      "祍",
      "紉",
      "紝",
      "絍",
      "纫",
      "纴",
      "肕",
      "腍",
      "衽",
      "袵",
      "訒",
      "認",
      "认",
      "讱",
      "軔",
      "轫",
      "鈓",
      "靭",
      "靱",
      "韌",
      "韧",
      "飪",
      "餁",
      "饪"
    ],
    qiān: [
      "仟",
      "佥",
      "僉",
      "千",
      "圲",
      "奷",
      "孯",
      "岍",
      "悭",
      "愆",
      "慳",
      "扦",
      "拪",
      "搴",
      "撁",
      "攐",
      "攑",
      "攓",
      "杄",
      "櫏",
      "汘",
      "汧",
      "牵",
      "牽",
      "竏",
      "签",
      "簽",
      "籖",
      "籤",
      "粁",
      "芊",
      "茾",
      "蚈",
      "褰",
      "諐",
      "謙",
      "谦",
      "谸",
      "迁",
      "遷",
      "釺",
      "鈆",
      "鉛",
      "鏲",
      "钎",
      "阡",
      "韆",
      "顅",
      "騫",
      "骞",
      "鬜",
      "鬝",
      "鵮",
      "鹐"
    ],
    "gǎn hàn": ["仠"],
    "yì gē": ["仡"],
    dài: [
      "代",
      "侢",
      "叇",
      "垈",
      "埭",
      "岱",
      "帒",
      "带",
      "帯",
      "帶",
      "廗",
      "怠",
      "戴",
      "曃",
      "柋",
      "殆",
      "瀻",
      "玳",
      "瑇",
      "甙",
      "簤",
      "紿",
      "緿",
      "绐",
      "艜",
      "蝳",
      "袋",
      "襶",
      "貣",
      "贷",
      "蹛",
      "軑",
      "軚",
      "軩",
      "轪",
      "迨",
      "霴",
      "靆",
      "鴏",
      "黛",
      "黱"
    ],
    "lìng líng lǐng": ["令"],
    chào: ["仦", "耖", "觘"],
    "cháng zhǎng": ["仧", "兏", "長", "长"],
    sā: ["仨"],
    cháng: [
      "仩",
      "偿",
      "償",
      "嘗",
      "嚐",
      "嫦",
      "尝",
      "常",
      "徜",
      "瑺",
      "瓺",
      "甞",
      "肠",
      "腸",
      "膓",
      "苌",
      "萇",
      "镸",
      "鱨",
      "鲿"
    ],
    yí: [
      "仪",
      "侇",
      "儀",
      "冝",
      "匜",
      "咦",
      "圯",
      "夷",
      "姨",
      "宐",
      "宜",
      "宧",
      "寲",
      "峓",
      "嶬",
      "嶷",
      "巸",
      "彛",
      "彜",
      "彝",
      "彞",
      "怡",
      "恞",
      "扅",
      "暆",
      "栘",
      "椬",
      "椸",
      "沂",
      "洟",
      "熪",
      "瓵",
      "痍",
      "移",
      "簃",
      "籎",
      "羠",
      "胰",
      "萓",
      "蛦",
      "螔",
      "觺",
      "謻",
      "貽",
      "贻",
      "跠",
      "迻",
      "遺",
      "鏔",
      "頉",
      "頤",
      "頥",
      "顊",
      "颐",
      "饴",
      "鮧",
      "鴺"
    ],
    mù: [
      "仫",
      "凩",
      "募",
      "墓",
      "幕",
      "幙",
      "慔",
      "慕",
      "暮",
      "暯",
      "木",
      "楘",
      "毣",
      "沐",
      "炑",
      "牧",
      "狇",
      "目",
      "睦",
      "穆",
      "艒",
      "苜",
      "莯",
      "蚞",
      "鉬",
      "钼",
      "雮",
      "霂"
    ],
    "men mén": ["们"],
    fǎn: ["仮", "反", "橎", "返"],
    "chào miǎo": ["仯"],
    "yǎng áng": ["仰"],
    zhòng: [
      "仲",
      "众",
      "堹",
      "妕",
      "媑",
      "狆",
      "眾",
      "祌",
      "筗",
      "茽",
      "蚛",
      "衆",
      "衶",
      "諥"
    ],
    "pǐ pí": ["仳"],
    wò: [
      "仴",
      "偓",
      "卧",
      "媉",
      "幄",
      "握",
      "楃",
      "沃",
      "渥",
      "濣",
      "瓁",
      "瞃",
      "硪",
      "肟",
      "腛",
      "臥",
      "齷",
      "龌"
    ],
    jiàn: [
      "件",
      "俴",
      "健",
      "僭",
      "剑",
      "剣",
      "剱",
      "劍",
      "劎",
      "劒",
      "劔",
      "墹",
      "寋",
      "建",
      "徤",
      "擶",
      "旔",
      "楗",
      "毽",
      "洊",
      "涧",
      "澗",
      "牮",
      "珔",
      "瞷",
      "磵",
      "礀",
      "箭",
      "糋",
      "繝",
      "腱",
      "臶",
      "舰",
      "艦",
      "荐",
      "薦",
      "覸",
      "諓",
      "諫",
      "譛",
      "谏",
      "賎",
      "賤",
      "贱",
      "趝",
      "践",
      "踐",
      "踺",
      "轞",
      "鉴",
      "鍳",
      "鍵",
      "鐱",
      "鑑",
      "鑒",
      "鑬",
      "鑳",
      "键",
      "間",
      "餞",
      "饯",
      "𬣡"
    ],
    "jià jiè jie": ["价"],
    "yǎo fó": ["仸"],
    "rèn rén": ["任"],
    "fèn bīn": ["份"],
    dī: [
      "仾",
      "低",
      "啲",
      "埞",
      "堤",
      "岻",
      "彽",
      "樀",
      "滴",
      "磾",
      "秪",
      "羝",
      "袛",
      "趆",
      "隄",
      "鞮",
      "䃅"
    ],
    fǎng: [
      "仿",
      "倣",
      "旊",
      "昉",
      "昘",
      "瓬",
      "眆",
      "紡",
      "纺",
      "舫",
      "訪",
      "访",
      "髣",
      "鶭"
    ],
    zhōng: [
      "伀",
      "刣",
      "妐",
      "幒",
      "彸",
      "忠",
      "柊",
      "汷",
      "泈",
      "炂",
      "盅",
      "籦",
      "終",
      "终",
      "舯",
      "蔠",
      "蜙",
      "螤",
      "螽",
      "衳",
      "衷",
      "蹱",
      "鈡",
      "鍾",
      "鐘",
      "钟",
      "锺",
      "鴤",
      "鼨"
    ],
    pèi: [
      "伂",
      "佩",
      "姵",
      "帔",
      "斾",
      "旆",
      "沛",
      "浿",
      "珮",
      "蓜",
      "轡",
      "辔",
      "配",
      "霈",
      "馷"
    ],
    diào: [
      "伄",
      "吊",
      "弔",
      "掉",
      "瘹",
      "盄",
      "窎",
      "窵",
      "竨",
      "訋",
      "釣",
      "鈟",
      "銱",
      "鋽",
      "鑃",
      "钓",
      "铞",
      "雿",
      "魡"
    ],
    dùn: [
      "伅",
      "潡",
      "炖",
      "燉",
      "盾",
      "砘",
      "碷",
      "踲",
      "逇",
      "遁",
      "遯",
      "鈍",
      "钝"
    ],
    wěn: ["伆", "刎", "吻", "呅", "抆", "桽", "稳", "穏", "穩", "紊", "肳", "脗"],
    xǐn: ["伈"],
    kàng: ["伉", "匟", "囥", "抗", "炕", "鈧", "钪"],
    ài: [
      "伌",
      "僾",
      "塧",
      "壒",
      "嫒",
      "嬡",
      "愛",
      "懓",
      "暧",
      "曖",
      "爱",
      "瑷",
      "璦",
      "皧",
      "瞹",
      "砹",
      "硋",
      "碍",
      "礙",
      "薆",
      "譺",
      "賹",
      "鑀",
      "隘",
      "靉",
      "餲",
      "馤",
      "鱫",
      "鴱"
    ],
    "jì qí": ["伎", "薺"],
    "xiū xǔ": ["休"],
    "jìn yín": ["伒"],
    dǎn: [
      "伔",
      "刐",
      "撢",
      "玬",
      "瓭",
      "紞",
      "胆",
      "膽",
      "衴",
      "賧",
      "赕",
      "黕",
      "𬘘"
    ],
    fū: [
      "伕",
      "呋",
      "娐",
      "孵",
      "尃",
      "怤",
      "懯",
      "敷",
      "旉",
      "玞",
      "砆",
      "稃",
      "筟",
      "糐",
      "綒",
      "肤",
      "膚",
      "荂",
      "荴",
      "衭",
      "趺",
      "跗",
      "邞",
      "鄜",
      "酜",
      "鈇",
      "麩",
      "麬",
      "麱",
      "麸",
      "𫓧"
    ],
    tǎng: [
      "伖",
      "傥",
      "儻",
      "埫",
      "戃",
      "曭",
      "爣",
      "矘",
      "躺",
      "鎲",
      "钂",
      "镋"
    ],
    yōu: [
      "优",
      "優",
      "呦",
      "嚘",
      "峳",
      "幽",
      "忧",
      "悠",
      "憂",
      "攸",
      "櫌",
      "滺",
      "瀀",
      "纋",
      "羪",
      "耰",
      "逌",
      "鄾",
      "麀"
    ],
    huǒ: ["伙", "夥", "火", "煷", "邩", "鈥", "钬"],
    "huì kuài": ["会", "會", "浍", "璯"],
    yǔ: [
      "伛",
      "俁",
      "俣",
      "偊",
      "傴",
      "匬",
      "噳",
      "圄",
      "圉",
      "宇",
      "寙",
      "屿",
      "嶼",
      "庾",
      "挧",
      "敔",
      "斞",
      "楀",
      "瑀",
      "瘐",
      "祤",
      "禹",
      "穥",
      "窳",
      "羽",
      "與",
      "萭",
      "貐",
      "鄅",
      "頨",
      "麌",
      "齬",
      "龉",
      "㺄"
    ],
    cuì: [
      "伜",
      "啛",
      "忰",
      "悴",
      "毳",
      "淬",
      "焠",
      "疩",
      "瘁",
      "竁",
      "粋",
      "粹",
      "紣",
      "綷",
      "翆",
      "翠",
      "脃",
      "脆",
      "脺",
      "膬",
      "膵",
      "臎",
      "萃",
      "襊",
      "顇"
    ],
    sǎn: ["伞", "傘", "糤", "繖", "饊", "馓"],
    wěi: [
      "伟",
      "伪",
      "偉",
      "偽",
      "僞",
      "儰",
      "娓",
      "寪",
      "屗",
      "崣",
      "嶉",
      "徫",
      "愇",
      "捤",
      "暐",
      "梶",
      "洧",
      "浘",
      "渨",
      "炜",
      "煒",
      "猥",
      "玮",
      "瑋",
      "痿",
      "緯",
      "纬",
      "腲",
      "艉",
      "芛",
      "苇",
      "荱",
      "萎",
      "葦",
      "蒍",
      "蔿",
      "蜼",
      "諉",
      "诿",
      "踓",
      "鍡",
      "韑",
      "韙",
      "韡",
      "韪",
      "頠",
      "颹",
      "骩",
      "骪",
      "骫",
      "鮪",
      "鲔",
      "𫇭",
      "𬀩",
      "𬱟"
    ],
    "chuán zhuàn": ["传", "傳"],
    "chē jū": ["伡", "俥", "车"],
    "jū chē": ["車"],
    yá: [
      "伢",
      "厑",
      "厓",
      "堐",
      "岈",
      "崕",
      "崖",
      "涯",
      "漄",
      "牙",
      "玡",
      "琊",
      "睚",
      "笌",
      "芽",
      "蚜",
      "衙",
      "齖"
    ],
    qiàn: [
      "伣",
      "俔",
      "倩",
      "儙",
      "刋",
      "壍",
      "嬱",
      "悓",
      "棈",
      "椠",
      "槧",
      "欠",
      "歉",
      "皘",
      "篏",
      "篟",
      "縴",
      "芡",
      "蒨",
      "蔳",
      "輤",
      "𬘬"
    ],
    shāng: [
      "伤",
      "傷",
      "商",
      "墒",
      "慯",
      "殇",
      "殤",
      "滳",
      "漡",
      "熵",
      "蔏",
      "螪",
      "觞",
      "觴",
      "謪",
      "鬺"
    ],
    chāng: [
      "伥",
      "倀",
      "娼",
      "昌",
      "椙",
      "淐",
      "猖",
      "琩",
      "菖",
      "裮",
      "錩",
      "锠",
      "閶",
      "阊",
      "鯧",
      "鲳",
      "鼚"
    ],
    "chen cāng": ["伧"],
    xùn: [
      "伨",
      "侚",
      "卂",
      "噀",
      "巺",
      "巽",
      "徇",
      "愻",
      "殉",
      "殾",
      "汛",
      "潠",
      "狥",
      "蕈",
      "訊",
      "訓",
      "訙",
      "训",
      "讯",
      "迅",
      "迿",
      "逊",
      "遜",
      "鑂",
      "顨",
      "馴",
      "驯"
    ],
    xìn: ["伩", "囟", "孞", "脪", "舋", "衅", "訫", "釁", "阠", "顖"],
    chǐ: [
      "伬",
      "侈",
      "卶",
      "叺",
      "呎",
      "垑",
      "恥",
      "歯",
      "耻",
      "肔",
      "胣",
      "蚇",
      "裭",
      "褫",
      "豉",
      "鉹",
      "齒",
      "齿"
    ],
    "xián xuán": ["伭"],
    "nú nǔ": ["伮"],
    "bó bǎi": ["伯"],
    "gū gù": ["估"],
    nǐ: ["伱", "你", "儞", "孴", "拟", "擬", "旎", "晲", "狔", "苨", "薿", "隬"],
    "nì ní": ["伲"],
    bàn: [
      "伴",
      "办",
      "半",
      "姅",
      "怑",
      "扮",
      "瓣",
      "秚",
      "絆",
      "绊",
      "辦",
      "鉡",
      "靽"
    ],
    xù: [
      "伵",
      "侐",
      "勖",
      "勗",
      "卹",
      "叙",
      "垿",
      "壻",
      "婿",
      "序",
      "恤",
      "敍",
      "敘",
      "旭",
      "昫",
      "朂",
      "槒",
      "欰",
      "殈",
      "汿",
      "沀",
      "洫",
      "溆",
      "漵",
      "潊",
      "烅",
      "烼",
      "煦",
      "獝",
      "珬",
      "盢",
      "瞁",
      "稸",
      "絮",
      "続",
      "緒",
      "緖",
      "續",
      "绪",
      "续",
      "聓",
      "聟",
      "蓄",
      "藚",
      "訹",
      "賉",
      "酗",
      "頊",
      "鱮",
      "㳚"
    ],
    zhòu: [
      "伷",
      "僽",
      "冑",
      "呪",
      "咒",
      "咮",
      "宙",
      "昼",
      "晝",
      "甃",
      "皱",
      "皺",
      "籀",
      "籒",
      "籕",
      "粙",
      "紂",
      "縐",
      "纣",
      "绉",
      "胄",
      "荮",
      "葤",
      "詋",
      "酎",
      "駎",
      "驟",
      "骤",
      "㤘",
      "㑇"
    ],
    shēn: [
      "伸",
      "侁",
      "兟",
      "呻",
      "堔",
      "妽",
      "娠",
      "屾",
      "峷",
      "扟",
      "敒",
      "曑",
      "柛",
      "氠",
      "深",
      "燊",
      "珅",
      "甡",
      "甧",
      "申",
      "眒",
      "砷",
      "穼",
      "籶",
      "籸",
      "糂",
      "紳",
      "绅",
      "罙",
      "罧",
      "葠",
      "蓡",
      "蔘",
      "薓",
      "裑",
      "訷",
      "詵",
      "诜",
      "身",
      "駪",
      "鯓",
      "鯵",
      "鰺",
      "鲹",
      "鵢",
      "𬳽"
    ],
    qū: [
      "伹",
      "佉",
      "匤",
      "呿",
      "坥",
      "屈",
      "岖",
      "岴",
      "嶇",
      "憈",
      "抾",
      "敺",
      "浀",
      "煀",
      "祛",
      "筁",
      "粬",
      "胠",
      "蛆",
      "蛐",
      "袪",
      "覻",
      "詘",
      "诎",
      "趍",
      "躯",
      "軀",
      "阹",
      "駆",
      "駈",
      "驅",
      "驱",
      "髷",
      "魼",
      "鰸",
      "鱋",
      "鶌",
      "麯",
      "麴",
      "麹",
      "黢",
      "㭕",
      "𪨰",
      "䓛"
    ],
    "sì cì": ["伺"],
    bēng: ["伻", "嘣", "奟", "崩", "嵭", "閍"],
    "sì shì": ["似"],
    "jiā qié gā": ["伽"],
    "yǐ chì": ["佁"],
    "diàn tián": ["佃", "钿"],
    "hān gàn": ["佄"],
    mài: [
      "佅",
      "劢",
      "勱",
      "卖",
      "唛",
      "売",
      "脈",
      "衇",
      "賣",
      "迈",
      "邁",
      "霡",
      "霢",
      "麥",
      "麦",
      "鿏"
    ],
    dàn: [
      "但",
      "僤",
      "啖",
      "啗",
      "啿",
      "噉",
      "嚪",
      "帎",
      "憺",
      "旦",
      "柦",
      "氮",
      "沊",
      "泹",
      "淡",
      "狚",
      "疍",
      "癚",
      "禫",
      "窞",
      "腅",
      "萏",
      "蓞",
      "蛋",
      "蜑",
      "觛",
      "訑",
      "誕",
      "诞",
      "贉",
      "霮",
      "餤",
      "饏",
      "駳",
      "髧",
      "鴠",
      "𫢸"
    ],
    bù: [
      "佈",
      "勏",
      "吥",
      "咘",
      "埗",
      "埠",
      "布",
      "廍",
      "怖",
      "悑",
      "步",
      "歨",
      "歩",
      "瓿",
      "篰",
      "荹",
      "蔀",
      "踄",
      "部",
      "郶",
      "鈈",
      "钚",
      "餢"
    ],
    bǐ: [
      "佊",
      "俾",
      "匕",
      "夶",
      "妣",
      "彼",
      "朼",
      "柀",
      "比",
      "毞",
      "沘",
      "疕",
      "秕",
      "笔",
      "筆",
      "粃",
      "聛",
      "舭",
      "貏",
      "鄙"
    ],
    "zhāo shào": ["佋"],
    cǐ: ["佌", "此", "泚", "皉", "𫚖"],
    wèi: [
      "位",
      "卫",
      "味",
      "喂",
      "墛",
      "媦",
      "慰",
      "懀",
      "未",
      "渭",
      "煟",
      "熭",
      "犚",
      "猬",
      "畏",
      "緭",
      "罻",
      "胃",
      "苿",
      "菋",
      "藯",
      "蘶",
      "蝟",
      "螱",
      "衛",
      "衞",
      "褽",
      "謂",
      "讆",
      "讏",
      "谓",
      "躗",
      "躛",
      "軎",
      "轊",
      "鏏",
      "霨",
      "餧",
      "餵",
      "饖",
      "魏",
      "鮇",
      "鳚"
    ],
    zuǒ: ["佐", "左", "繓"],
    yǎng: [
      "佒",
      "傟",
      "养",
      "坱",
      "岟",
      "慃",
      "懩",
      "攁",
      "氧",
      "氱",
      "炴",
      "痒",
      "癢",
      "礢",
      "紻",
      "蝆",
      "軮",
      "養",
      "駚"
    ],
    "tǐ tī": ["体", "體"],
    zhàn: [
      "佔",
      "偡",
      "嶘",
      "战",
      "戦",
      "戰",
      "栈",
      "桟",
      "棧",
      "湛",
      "站",
      "綻",
      "绽",
      "菚",
      "蘸",
      "虥",
      "虦",
      "譧",
      "轏",
      "驏"
    ],
    "hé hē hè": ["何"],
    bì: [
      "佖",
      "咇",
      "哔",
      "嗶",
      "坒",
      "堛",
      "壁",
      "奰",
      "妼",
      "婢",
      "嬖",
      "币",
      "幣",
      "幤",
      "庇",
      "庳",
      "廦",
      "弊",
      "弻",
      "弼",
      "彃",
      "必",
      "怭",
      "愊",
      "愎",
      "敝",
      "斃",
      "梐",
      "毕",
      "毖",
      "毙",
      "湢",
      "滗",
      "滭",
      "潷",
      "煏",
      "熚",
      "狴",
      "獘",
      "獙",
      "珌",
      "璧",
      "畀",
      "畢",
      "疪",
      "痹",
      "痺",
      "皕",
      "睤",
      "碧",
      "筚",
      "箅",
      "箆",
      "篦",
      "篳",
      "粊",
      "綼",
      "縪",
      "繴",
      "罼",
      "腷",
      "苾",
      "荜",
      "萆",
      "萞",
      "蓖",
      "蓽",
      "蔽",
      "薜",
      "蜌",
      "袐",
      "襅",
      "襞",
      "襣",
      "觱",
      "詖",
      "诐",
      "貱",
      "贔",
      "赑",
      "跸",
      "蹕",
      "躃",
      "躄",
      "避",
      "邲",
      "鄨",
      "鄪",
      "鉍",
      "鏎",
      "鐴",
      "铋",
      "閇",
      "閉",
      "閟",
      "闭",
      "陛",
      "韠",
      "飶",
      "饆",
      "馝",
      "駜",
      "驆",
      "髀",
      "魓",
      "鮅",
      "鷝",
      "鷩",
      "鼊"
    ],
    tuó: [
      "佗",
      "坨",
      "堶",
      "岮",
      "槖",
      "橐",
      "沱",
      "砣",
      "砤",
      "碢",
      "紽",
      "詑",
      "跎",
      "酡",
      "阤",
      "陀",
      "陁",
      "駝",
      "駞",
      "騨",
      "驒",
      "驝",
      "驼",
      "鮀",
      "鴕",
      "鸵",
      "鼉",
      "鼍",
      "鼧",
      "𬶍"
    ],
    shé: ["佘", "舌", "虵", "蛥"],
    "yì dié": ["佚", "昳", "泆", "軼"],
    "fó fú bì bó": ["佛"],
    "zuò zuō": ["作"],
    gōu: [
      "佝",
      "沟",
      "溝",
      "痀",
      "篝",
      "簼",
      "緱",
      "缑",
      "袧",
      "褠",
      "鈎",
      "鉤",
      "钩",
      "鞲",
      "韝"
    ],
    nìng: ["佞", "侫", "倿", "寕", "泞", "澝", "濘"],
    qú: [
      "佢",
      "劬",
      "戵",
      "斪",
      "欋",
      "欔",
      "氍",
      "淭",
      "灈",
      "爠",
      "璖",
      "璩",
      "癯",
      "磲",
      "籧",
      "絇",
      "胊",
      "臞",
      "菃",
      "葋",
      "蕖",
      "蘧",
      "蟝",
      "蠷",
      "蠼",
      "衐",
      "衢",
      "躣",
      "軥",
      "鑺",
      "鴝",
      "鸜",
      "鸲",
      "鼩"
    ],
    "yōng yòng": ["佣"],
    wǎ: ["佤", "咓", "砙", "邷"],
    kǎ: ["佧", "垰", "胩", "裃", "鉲"],
    bāo: [
      "佨",
      "勹",
      "包",
      "孢",
      "煲",
      "笣",
      "胞",
      "苞",
      "蕔",
      "裦",
      "褒",
      "襃",
      "闁",
      "齙",
      "龅"
    ],
    "huái huí": ["佪"],
    "gé hè": ["佫"],
    lǎo: [
      "佬",
      "咾",
      "恅",
      "栳",
      "狫",
      "珯",
      "硓",
      "老",
      "耂",
      "荖",
      "蛯",
      "轑",
      "銠",
      "铑",
      "鮱"
    ],
    xiáng: ["佭", "庠", "栙", "祥", "絴", "翔", "詳", "跭"],
    gé: [
      "佮",
      "匌",
      "呄",
      "嗝",
      "塥",
      "愅",
      "挌",
      "搿",
      "槅",
      "櫊",
      "滆",
      "膈",
      "臵",
      "茖",
      "觡",
      "諽",
      "輵",
      "轕",
      "閣",
      "阁",
      "隔",
      "鞷",
      "韐",
      "韚",
      "騔",
      "骼",
      "鮯"
    ],
    yáng: [
      "佯",
      "劷",
      "垟",
      "崸",
      "徉",
      "扬",
      "揚",
      "敭",
      "旸",
      "昜",
      "暘",
      "杨",
      "楊",
      "洋",
      "炀",
      "珜",
      "疡",
      "瘍",
      "眻",
      "蛘",
      "諹",
      "輰",
      "鍚",
      "钖",
      "阦",
      "阳",
      "陽",
      "霷",
      "颺",
      "飏",
      "鰑",
      "鴹",
      "鸉"
    ],
    bǎi: ["佰", "捭", "摆", "擺", "栢", "百", "竡", "粨", "襬"],
    fǎ: ["佱", "峜", "法", "灋", "砝", "鍅"],
    mǐng: ["佲", "凕", "姳", "慏", "酩"],
    "èr nài": ["佴"],
    hěn: ["佷", "很", "狠", "詪", "𬣳"],
    huó: ["佸", "活"],
    guǐ: [
      "佹",
      "匦",
      "匭",
      "厬",
      "垝",
      "姽",
      "宄",
      "庋",
      "庪",
      "恑",
      "晷",
      "湀",
      "癸",
      "祪",
      "簋",
      "蛫",
      "蟡",
      "觤",
      "詭",
      "诡",
      "軌",
      "轨",
      "陒",
      "鬼"
    ],
    quán: [
      "佺",
      "全",
      "啳",
      "埢",
      "姾",
      "峑",
      "巏",
      "拳",
      "搼",
      "权",
      "楾",
      "権",
      "權",
      "泉",
      "洤",
      "湶",
      "牷",
      "犈",
      "瑔",
      "痊",
      "硂",
      "筌",
      "縓",
      "荃",
      "葲",
      "蜷",
      "蠸",
      "觠",
      "詮",
      "诠",
      "跧",
      "踡",
      "輇",
      "辁",
      "醛",
      "銓",
      "铨",
      "闎",
      "顴",
      "颧",
      "駩",
      "騡",
      "鬈",
      "鰁",
      "鳈",
      "齤"
    ],
    tiāo: ["佻", "庣", "旫", "祧", "聎"],
    jiǎo: [
      "佼",
      "儌",
      "孂",
      "挢",
      "搅",
      "撟",
      "撹",
      "攪",
      "敫",
      "敽",
      "敿",
      "晈",
      "暞",
      "曒",
      "灚",
      "燞",
      "狡",
      "璬",
      "皎",
      "皦",
      "絞",
      "纐",
      "绞",
      "腳",
      "臫",
      "蟜",
      "譑",
      "賋",
      "踋",
      "鉸",
      "铰",
      "餃",
      "饺",
      "鱎",
      "龣"
    ],
    cì: [
      "佽",
      "刾",
      "庛",
      "朿",
      "栨",
      "次",
      "絘",
      "茦",
      "莿",
      "蛓",
      "螆",
      "賜",
      "赐"
    ],
    xíng: [
      "侀",
      "刑",
      "哘",
      "型",
      "娙",
      "形",
      "洐",
      "硎",
      "蛵",
      "邢",
      "郉",
      "鈃",
      "鉶",
      "銒",
      "钘",
      "铏",
      "陉",
      "陘",
      "餳",
      "𫰛"
    ],
    tuō: [
      "侂",
      "咃",
      "咜",
      "圫",
      "托",
      "拕",
      "拖",
      "汑",
      "脫",
      "脱",
      "莌",
      "袥",
      "託",
      "讬",
      "飥",
      "饦",
      "魠",
      "鮵"
    ],
    kǎn: ["侃", "偘", "冚", "坎", "惂", "砍", "莰", "輡", "轗", "顑"],
    zhí: [
      "侄",
      "値",
      "值",
      "埴",
      "執",
      "姪",
      "嬂",
      "戠",
      "执",
      "摭",
      "植",
      "樴",
      "淔",
      "漐",
      "直",
      "禃",
      "絷",
      "縶",
      "聀",
      "职",
      "職",
      "膱",
      "蟙",
      "跖",
      "踯",
      "蹠",
      "躑",
      "軄",
      "釞",
      "馽"
    ],
    gāi: [
      "侅",
      "垓",
      "姟",
      "峐",
      "晐",
      "畡",
      "祴",
      "荄",
      "該",
      "该",
      "豥",
      "賅",
      "賌",
      "赅",
      "陔"
    ],
    lái: [
      "來",
      "俫",
      "倈",
      "崃",
      "崍",
      "庲",
      "来",
      "梾",
      "棶",
      "涞",
      "淶",
      "猍",
      "琜",
      "筙",
      "箂",
      "莱",
      "萊",
      "逨",
      "郲",
      "錸",
      "铼",
      "騋",
      "鯠",
      "鶆",
      "麳"
    ],
    kuǎ: ["侉", "咵", "垮", "銙"],
    gōng: [
      "侊",
      "公",
      "功",
      "匑",
      "匔",
      "塨",
      "宫",
      "宮",
      "工",
      "幊",
      "弓",
      "恭",
      "攻",
      "杛",
      "碽",
      "糼",
      "糿",
      "肱",
      "觥",
      "觵",
      "躬",
      "躳",
      "髸",
      "龔",
      "龚",
      "䢼"
    ],
    lì: [
      "例",
      "俐",
      "俪",
      "傈",
      "儮",
      "儷",
      "凓",
      "利",
      "力",
      "励",
      "勵",
      "历",
      "厉",
      "厤",
      "厯",
      "厲",
      "叓",
      "吏",
      "呖",
      "唎",
      "唳",
      "嚦",
      "囇",
      "坜",
      "塛",
      "壢",
      "娳",
      "婯",
      "屴",
      "岦",
      "悧",
      "悷",
      "慄",
      "戾",
      "搮",
      "暦",
      "曆",
      "曞",
      "朸",
      "枥",
      "栃",
      "栗",
      "栛",
      "檪",
      "櫔",
      "櫪",
      "欐",
      "歴",
      "歷",
      "沥",
      "沴",
      "涖",
      "溧",
      "濿",
      "瀝",
      "爏",
      "犡",
      "猁",
      "珕",
      "瑮",
      "瓅",
      "瓑",
      "瓥",
      "疬",
      "痢",
      "癧",
      "盭",
      "睙",
      "砅",
      "砺",
      "砾",
      "磿",
      "礪",
      "礫",
      "礰",
      "禲",
      "秝",
      "立",
      "笠",
      "篥",
      "粒",
      "粝",
      "糲",
      "脷",
      "苈",
      "茘",
      "荔",
      "莅",
      "莉",
      "蒚",
      "蒞",
      "藶",
      "蚸",
      "蛎",
      "蛠",
      "蜧",
      "蝷",
      "蠇",
      "蠣",
      "詈",
      "讈",
      "赲",
      "轢",
      "轣",
      "轹",
      "酈",
      "鉝",
      "隶",
      "隷",
      "雳",
      "靂",
      "靋",
      "鬁",
      "鳨",
      "鴗",
      "鷅",
      "麜",
      "𫵷",
      "𬍛"
    ],
    yīn: [
      "侌",
      "凐",
      "喑",
      "噾",
      "囙",
      "因",
      "垔",
      "堙",
      "姻",
      "婣",
      "愔",
      "慇",
      "栶",
      "氤",
      "洇",
      "溵",
      "濦",
      "瘖",
      "禋",
      "秵",
      "筃",
      "絪",
      "緸",
      "茵",
      "蒑",
      "蔭",
      "裀",
      "諲",
      "銦",
      "铟",
      "闉",
      "阥",
      "阴",
      "陰",
      "陻",
      "隂",
      "霒",
      "霠",
      "鞇",
      "音",
      "韾",
      "駰",
      "骃",
      "齗",
      "𬘡",
      "𬤇",
      "𬮱"
    ],
    mǐ: [
      "侎",
      "孊",
      "弭",
      "敉",
      "洣",
      "渳",
      "灖",
      "米",
      "粎",
      "羋",
      "脒",
      "芈",
      "葞",
      "蔝",
      "銤"
    ],
    zhū: [
      "侏",
      "株",
      "槠",
      "橥",
      "櫧",
      "櫫",
      "洙",
      "潴",
      "瀦",
      "猪",
      "珠",
      "硃",
      "秼",
      "絑",
      "茱",
      "蕏",
      "蛛",
      "蝫",
      "蠩",
      "袾",
      "誅",
      "諸",
      "诛",
      "诸",
      "豬",
      "跦",
      "邾",
      "銖",
      "铢",
      "駯",
      "鮢",
      "鯺",
      "鴸",
      "鼄"
    ],
    ān: [
      "侒",
      "偣",
      "媕",
      "安",
      "峖",
      "庵",
      "桉",
      "氨",
      "盦",
      "盫",
      "腤",
      "菴",
      "萻",
      "葊",
      "蓭",
      "誝",
      "諳",
      "谙",
      "鞌",
      "鞍",
      "韽",
      "馣",
      "鮟",
      "鵪",
      "鶕",
      "鹌",
      "𩽾"
    ],
    lù: [
      "侓",
      "僇",
      "勎",
      "勠",
      "圥",
      "坴",
      "塶",
      "娽",
      "峍",
      "廘",
      "彔",
      "录",
      "戮",
      "摝",
      "椂",
      "樚",
      "淕",
      "淥",
      "渌",
      "漉",
      "潞",
      "琭",
      "璐",
      "甪",
      "盝",
      "睩",
      "硉",
      "祿",
      "禄",
      "稑",
      "穋",
      "箓",
      "簏",
      "簬",
      "簵",
      "簶",
      "籙",
      "粶",
      "蔍",
      "蕗",
      "虂",
      "螰",
      "賂",
      "赂",
      "趢",
      "路",
      "踛",
      "蹗",
      "輅",
      "轆",
      "辂",
      "辘",
      "逯",
      "醁",
      "錄",
      "録",
      "錴",
      "鏴",
      "陸",
      "騄",
      "騼",
      "鯥",
      "鴼",
      "鵦",
      "鵱",
      "鷺",
      "鹭",
      "鹿",
      "麓",
      "𫘧"
    ],
    móu: ["侔", "劺", "恈", "眸", "蛑", "謀", "谋", "踎", "鍪", "鴾", "麰"],
    ér: [
      "侕",
      "儿",
      "児",
      "兒",
      "峏",
      "栭",
      "洏",
      "粫",
      "而",
      "胹",
      "荋",
      "袻",
      "輀",
      "轜",
      "陑",
      "隭",
      "髵",
      "鮞",
      "鲕",
      "鴯",
      "鸸"
    ],
    "dòng tǒng tóng": ["侗"],
    chà: ["侘", "奼", "姹", "岔", "汊", "詫", "诧"],
    chì: [
      "侙",
      "傺",
      "勅",
      "勑",
      "叱",
      "啻",
      "彳",
      "恜",
      "慗",
      "憏",
      "懘",
      "抶",
      "敕",
      "斥",
      "杘",
      "湁",
      "灻",
      "炽",
      "烾",
      "熾",
      "痓",
      "痸",
      "瘛",
      "翄",
      "翅",
      "翤",
      "翨",
      "腟",
      "赤",
      "趩",
      "遫",
      "鉓",
      "雴",
      "飭",
      "饬",
      "鶒",
      "鷘"
    ],
    "gòng gōng": ["供", "共"],
    zhōu: [
      "侜",
      "周",
      "喌",
      "州",
      "徟",
      "洲",
      "淍",
      "炿",
      "烐",
      "珘",
      "矪",
      "舟",
      "謅",
      "譸",
      "诌",
      "賙",
      "赒",
      "輈",
      "輖",
      "辀",
      "週",
      "郮",
      "銂",
      "霌",
      "駲",
      "騆",
      "鵃",
      "鸼"
    ],
    rú: [
      "侞",
      "儒",
      "嚅",
      "如",
      "嬬",
      "孺",
      "帤",
      "曘",
      "桇",
      "渪",
      "濡",
      "筎",
      "茹",
      "蕠",
      "薷",
      "蝡",
      "蠕",
      "袽",
      "襦",
      "邚",
      "醹",
      "銣",
      "铷",
      "顬",
      "颥",
      "鱬",
      "鴑",
      "鴽"
    ],
    "jiàn cún": ["侟"],
    xiá: [
      "侠",
      "俠",
      "匣",
      "峡",
      "峽",
      "敮",
      "暇",
      "柙",
      "炠",
      "烚",
      "狎",
      "狭",
      "狹",
      "珨",
      "瑕",
      "硖",
      "硤",
      "碬",
      "祫",
      "筪",
      "縖",
      "翈",
      "舝",
      "舺",
      "蕸",
      "赮",
      "轄",
      "辖",
      "遐",
      "鍜",
      "鎋",
      "陜",
      "陿",
      "霞",
      "騢",
      "魻",
      "鶷",
      "黠"
    ],
    lǚ: [
      "侣",
      "侶",
      "儢",
      "吕",
      "呂",
      "屡",
      "屢",
      "履",
      "挔",
      "捛",
      "旅",
      "梠",
      "焒",
      "祣",
      "稆",
      "穭",
      "絽",
      "縷",
      "缕",
      "膂",
      "膐",
      "褛",
      "褸",
      "郘",
      "鋁",
      "铝"
    ],
    ta: ["侤"],
    "jiǎo yáo": ["侥", "僥", "徺"],
    zhēn: [
      "侦",
      "偵",
      "寊",
      "帧",
      "帪",
      "幀",
      "搸",
      "斟",
      "桢",
      "楨",
      "榛",
      "樼",
      "殝",
      "浈",
      "湞",
      "潧",
      "澵",
      "獉",
      "珍",
      "珎",
      "瑧",
      "甄",
      "眞",
      "真",
      "砧",
      "碪",
      "祯",
      "禎",
      "禛",
      "箴",
      "胗",
      "臻",
      "葴",
      "蒖",
      "蓁",
      "薽",
      "貞",
      "贞",
      "轃",
      "遉",
      "酙",
      "針",
      "鉁",
      "錱",
      "鍼",
      "针",
      "鱵"
    ],
    "cè zè zhāi": ["侧", "側"],
    kuài: [
      "侩",
      "儈",
      "凷",
      "哙",
      "噲",
      "圦",
      "块",
      "塊",
      "巜",
      "廥",
      "快",
      "旝",
      "欳",
      "狯",
      "獪",
      "筷",
      "糩",
      "脍",
      "膾",
      "郐",
      "鄶",
      "鱠",
      "鲙"
    ],
    chái: ["侪", "儕", "喍", "柴", "犲", "祡", "豺"],
    nóng: [
      "侬",
      "儂",
      "农",
      "哝",
      "噥",
      "檂",
      "欁",
      "浓",
      "濃",
      "燶",
      "禯",
      "秾",
      "穠",
      "脓",
      "膿",
      "蕽",
      "襛",
      "譨",
      "農",
      "辳",
      "醲",
      "鬞",
      "𬪩"
    ],
    jǐn: [
      "侭",
      "儘",
      "卺",
      "厪",
      "巹",
      "槿",
      "漌",
      "瑾",
      "紧",
      "緊",
      "菫",
      "蓳",
      "謹",
      "谨",
      "錦",
      "锦",
      "饉",
      "馑"
    ],
    "hóu hòu": ["侯", "矦"],
    jiǒng: [
      "侰",
      "僒",
      "冏",
      "囧",
      "泂",
      "澃",
      "炯",
      "烱",
      "煚",
      "煛",
      "熲",
      "燛",
      "窘",
      "綗",
      "褧",
      "迥",
      "逈",
      "顈",
      "颎",
      "䌹"
    ],
    "chěng tǐng": ["侱"],
    "zhèn zhēn": ["侲", "揕"],
    zuò: [
      "侳",
      "做",
      "唑",
      "坐",
      "岝",
      "岞",
      "座",
      "祚",
      "糳",
      "胙",
      "葃",
      "葄",
      "蓙",
      "袏",
      "阼"
    ],
    qīn: [
      "侵",
      "兓",
      "媇",
      "嵚",
      "嶔",
      "欽",
      "衾",
      "誛",
      "钦",
      "顉",
      "駸",
      "骎",
      "鮼"
    ],
    jú: [
      "侷",
      "啹",
      "婅",
      "局",
      "巈",
      "椈",
      "橘",
      "泦",
      "淗",
      "湨",
      "焗",
      "犑",
      "狊",
      "粷",
      "菊",
      "蘜",
      "趜",
      "跼",
      "蹫",
      "輂",
      "郹",
      "閰",
      "駶",
      "驧",
      "鵙",
      "鵴",
      "鶪",
      "鼰",
      "鼳",
      "䴗"
    ],
    "shù dōu": ["侸"],
    tǐng: [
      "侹",
      "圢",
      "娗",
      "挺",
      "涏",
      "烶",
      "珽",
      "脡",
      "艇",
      "誔",
      "頲",
      "颋"
    ],
    shèn: [
      "侺",
      "愼",
      "慎",
      "昚",
      "涁",
      "渗",
      "滲",
      "瘆",
      "瘮",
      "眘",
      "祳",
      "肾",
      "胂",
      "脤",
      "腎",
      "蜃",
      "蜄",
      "鋠"
    ],
    "tuì tuó": ["侻"],
    nán: [
      "侽",
      "喃",
      "娚",
      "抩",
      "暔",
      "枏",
      "柟",
      "楠",
      "男",
      "畘",
      "莮",
      "萳",
      "遖"
    ],
    xiāo: [
      "侾",
      "哓",
      "嘵",
      "嚻",
      "囂",
      "婋",
      "宯",
      "宵",
      "庨",
      "彇",
      "揱",
      "枭",
      "枵",
      "梟",
      "櫹",
      "歊",
      "毊",
      "消",
      "潇",
      "瀟",
      "灱",
      "灲",
      "烋",
      "焇",
      "猇",
      "獢",
      "痚",
      "痟",
      "硝",
      "硣",
      "窙",
      "箫",
      "簘",
      "簫",
      "綃",
      "绡",
      "翛",
      "膮",
      "萧",
      "蕭",
      "虈",
      "虓",
      "蟂",
      "蟏",
      "蟰",
      "蠨",
      "踃",
      "逍",
      "銷",
      "销",
      "霄",
      "颵",
      "驍",
      "骁",
      "髇",
      "髐",
      "魈",
      "鴞",
      "鴵",
      "鷍",
      "鸮"
    ],
    "biàn pián": ["便", "緶", "缏"],
    tuǐ: ["俀", "腿", "蹆", "骽"],
    xì: [
      "係",
      "匸",
      "卌",
      "呬",
      "墍",
      "屃",
      "屓",
      "屭",
      "忥",
      "怬",
      "恄",
      "椞",
      "潝",
      "潟",
      "澙",
      "熂",
      "犔",
      "磶",
      "禊",
      "細",
      "綌",
      "縘",
      "细",
      "绤",
      "舃",
      "舄",
      "蕮",
      "虩",
      "衋",
      "覤",
      "赩",
      "趇",
      "郤",
      "釳",
      "阋",
      "隙",
      "隟",
      "霼",
      "餼",
      "饩",
      "鬩",
      "黖"
    ],
    cù: [
      "促",
      "媨",
      "憱",
      "猝",
      "瘄",
      "瘯",
      "簇",
      "縬",
      "脨",
      "蔟",
      "誎",
      "趗",
      "踧",
      "踿",
      "蹙",
      "蹴",
      "蹵",
      "醋",
      "顣",
      "鼀"
    ],
    é: [
      "俄",
      "囮",
      "娥",
      "峉",
      "峨",
      "峩",
      "涐",
      "珴",
      "皒",
      "睋",
      "磀",
      "莪",
      "訛",
      "誐",
      "譌",
      "讹",
      "迗",
      "鈋",
      "鋨",
      "锇",
      "頟",
      "額",
      "额",
      "魤",
      "鵝",
      "鵞",
      "鹅"
    ],
    qiú: [
      "俅",
      "叴",
      "唒",
      "囚",
      "崷",
      "巯",
      "巰",
      "扏",
      "梂",
      "殏",
      "毬",
      "求",
      "汓",
      "泅",
      "浗",
      "湭",
      "煪",
      "犰",
      "玌",
      "球",
      "璆",
      "皳",
      "盚",
      "紌",
      "絿",
      "肍",
      "芁",
      "莍",
      "虬",
      "虯",
      "蛷",
      "裘",
      "觓",
      "觩",
      "訄",
      "訅",
      "賕",
      "赇",
      "逎",
      "逑",
      "遒",
      "酋",
      "釚",
      "釻",
      "銶",
      "頄",
      "鮂",
      "鯄",
      "鰽",
      "鼽",
      "𨱇"
    ],
    xú: ["俆", "徐", "禑"],
    "guàng kuāng": ["俇"],
    kù: [
      "俈",
      "喾",
      "嚳",
      "库",
      "庫",
      "廤",
      "瘔",
      "絝",
      "绔",
      "袴",
      "裤",
      "褲",
      "酷"
    ],
    wù: [
      "俉",
      "务",
      "務",
      "勿",
      "卼",
      "坞",
      "塢",
      "奦",
      "婺",
      "寤",
      "屼",
      "岉",
      "嵨",
      "忢",
      "悞",
      "悟",
      "悮",
      "戊",
      "扤",
      "晤",
      "杌",
      "溩",
      "焐",
      "熃",
      "物",
      "痦",
      "矹",
      "窹",
      "粅",
      "蘁",
      "誤",
      "误",
      "鋈",
      "阢",
      "隖",
      "雾",
      "霚",
      "霧",
      "靰",
      "騖",
      "骛",
      "鶩",
      "鹜",
      "鼿",
      "齀"
    ],
    jùn: [
      "俊",
      "儁",
      "呁",
      "埈",
      "寯",
      "峻",
      "懏",
      "捃",
      "攟",
      "晙",
      "棞",
      "燇",
      "珺",
      "畯",
      "竣",
      "箟",
      "蜠",
      "賐",
      "郡",
      "陖",
      "餕",
      "馂",
      "駿",
      "骏",
      "鵔",
      "鵕",
      "鵘",
      "䐃"
    ],
    liáng: [
      "俍",
      "墚",
      "梁",
      "椋",
      "樑",
      "粮",
      "粱",
      "糧",
      "良",
      "輬",
      "辌",
      "𫟅"
    ],
    zǔ: ["俎", "唨", "爼", "祖", "組", "组", "詛", "诅", "鎺", "阻", "靻"],
    "qiào xiào": ["俏"],
    yǒng: [
      "俑",
      "勇",
      "勈",
      "咏",
      "埇",
      "塎",
      "嵱",
      "彮",
      "怺",
      "恿",
      "悀",
      "惥",
      "愑",
      "愹",
      "慂",
      "柡",
      "栐",
      "永",
      "泳",
      "湧",
      "甬",
      "蛹",
      "詠",
      "踊",
      "踴",
      "鯒",
      "鲬"
    ],
    hùn: ["俒", "倱", "圂", "尡", "慁", "掍", "溷", "焝", "睴", "觨", "諢", "诨"],
    jìng: [
      "俓",
      "傹",
      "境",
      "妌",
      "婙",
      "婧",
      "弪",
      "弳",
      "径",
      "徑",
      "敬",
      "曔",
      "桱",
      "梷",
      "浄",
      "瀞",
      "獍",
      "痉",
      "痙",
      "竞",
      "竟",
      "竫",
      "競",
      "竸",
      "胫",
      "脛",
      "莖",
      "誩",
      "踁",
      "迳",
      "逕",
      "鏡",
      "镜",
      "靖",
      "静",
      "靜",
      "鵛"
    ],
    sàn: ["俕", "閐"],
    pěi: ["俖"],
    sú: ["俗"],
    xī: [
      "俙",
      "僖",
      "兮",
      "凞",
      "卥",
      "厀",
      "吸",
      "唏",
      "唽",
      "嘻",
      "噏",
      "嚱",
      "夕",
      "奚",
      "嬆",
      "嬉",
      "屖",
      "嵠",
      "巇",
      "希",
      "徆",
      "徯",
      "息",
      "悉",
      "悕",
      "惁",
      "惜",
      "昔",
      "晞",
      "晰",
      "晳",
      "曦",
      "析",
      "桸",
      "榽",
      "樨",
      "橀",
      "欷",
      "氥",
      "汐",
      "浠",
      "淅",
      "渓",
      "溪",
      "烯",
      "焁",
      "焈",
      "焟",
      "熄",
      "熈",
      "熙",
      "熹",
      "熺",
      "熻",
      "燨",
      "爔",
      "牺",
      "犀",
      "犠",
      "犧",
      "琋",
      "瘜",
      "皙",
      "睎",
      "瞦",
      "矽",
      "硒",
      "磎",
      "礂",
      "稀",
      "穸",
      "窸",
      "粞",
      "糦",
      "緆",
      "繥",
      "羲",
      "翕",
      "翖",
      "肸",
      "肹",
      "膝",
      "舾",
      "莃",
      "菥",
      "蒠",
      "蜥",
      "螅",
      "蟋",
      "蠵",
      "西",
      "觹",
      "觽",
      "觿",
      "譆",
      "谿",
      "豀",
      "豨",
      "豯",
      "貕",
      "赥",
      "邜",
      "鄎",
      "酅",
      "醯",
      "釸",
      "錫",
      "鏭",
      "鐊",
      "鑴",
      "锡",
      "隵",
      "餏",
      "饎",
      "饻",
      "鯑",
      "鵗",
      "鸂",
      "鼷"
    ],
    lǐ: [
      "俚",
      "娌",
      "峢",
      "峲",
      "李",
      "欚",
      "浬",
      "澧",
      "理",
      "礼",
      "禮",
      "粴",
      "裏",
      "裡",
      "豊",
      "逦",
      "邐",
      "醴",
      "鋰",
      "锂",
      "鯉",
      "鱧",
      "鱱",
      "鲤",
      "鳢"
    ],
    bǎo: [
      "保",
      "堢",
      "媬",
      "宝",
      "寚",
      "寳",
      "寶",
      "珤",
      "緥",
      "葆",
      "藵",
      "褓",
      "賲",
      "靌",
      "飹",
      "飽",
      "饱",
      "駂",
      "鳵",
      "鴇",
      "鸨"
    ],
    "yú shù yù": ["俞"],
    "sì qí": ["俟"],
    "xìn shēn": ["信"],
    xiū: [
      "俢",
      "修",
      "咻",
      "庥",
      "樇",
      "烌",
      "羞",
      "脙",
      "脩",
      "臹",
      "貅",
      "銝",
      "鎀",
      "飍",
      "饈",
      "馐",
      "髤",
      "髹",
      "鮴",
      "鱃",
      "鵂",
      "鸺",
      "䗛"
    ],
    dì: [
      "俤",
      "偙",
      "僀",
      "埊",
      "墑",
      "墬",
      "娣",
      "帝",
      "怟",
      "旳",
      "梊",
      "焍",
      "玓",
      "甋",
      "眱",
      "睇",
      "碲",
      "祶",
      "禘",
      "第",
      "締",
      "缔",
      "腣",
      "菂",
      "蒂",
      "蔕",
      "蝃",
      "蝭",
      "螮",
      "諦",
      "谛",
      "踶",
      "递",
      "逓",
      "遞",
      "遰",
      "鉪",
      "𤧛",
      "䗖"
    ],
    chóu: [
      "俦",
      "儔",
      "嬦",
      "惆",
      "愁",
      "懤",
      "栦",
      "燽",
      "畴",
      "疇",
      "皗",
      "稠",
      "筹",
      "籌",
      "絒",
      "綢",
      "绸",
      "菗",
      "詶",
      "讎",
      "讐",
      "踌",
      "躊",
      "酧",
      "酬",
      "醻",
      "雔",
      "雠",
      "雦"
    ],
    zhì: [
      "俧",
      "偫",
      "儨",
      "制",
      "劕",
      "垁",
      "娡",
      "寘",
      "帙",
      "帜",
      "幟",
      "庢",
      "庤",
      "廌",
      "彘",
      "徏",
      "徝",
      "志",
      "忮",
      "懥",
      "懫",
      "挃",
      "挚",
      "掷",
      "摯",
      "擲",
      "旘",
      "晊",
      "智",
      "栉",
      "桎",
      "梽",
      "櫍",
      "櫛",
      "治",
      "洷",
      "滍",
      "滞",
      "滯",
      "潌",
      "瀄",
      "炙",
      "熫",
      "狾",
      "猘",
      "璏",
      "瓆",
      "痔",
      "痣",
      "礩",
      "祑",
      "秩",
      "秷",
      "稚",
      "稺",
      "穉",
      "窒",
      "紩",
      "緻",
      "置",
      "翐",
      "膣",
      "至",
      "致",
      "芖",
      "蛭",
      "袟",
      "袠",
      "製",
      "覟",
      "觗",
      "觯",
      "觶",
      "誌",
      "豑",
      "豒",
      "貭",
      "質",
      "贄",
      "质",
      "贽",
      "跱",
      "踬",
      "躓",
      "輊",
      "轾",
      "郅",
      "銍",
      "鋕",
      "鑕",
      "铚",
      "锧",
      "陟",
      "隲",
      "雉",
      "駤",
      "騭",
      "騺",
      "驇",
      "骘",
      "鯯",
      "鴙",
      "鷙",
      "鸷",
      "𬃊"
    ],
    "liǎ liǎng": ["俩"],
    jiǎn: [
      "俭",
      "倹",
      "儉",
      "减",
      "剪",
      "堿",
      "弿",
      "彅",
      "戩",
      "戬",
      "拣",
      "挸",
      "捡",
      "揀",
      "撿",
      "枧",
      "柬",
      "梘",
      "检",
      "検",
      "檢",
      "減",
      "湕",
      "瀽",
      "瑐",
      "睑",
      "瞼",
      "硷",
      "碱",
      "礆",
      "笕",
      "筧",
      "简",
      "簡",
      "絸",
      "繭",
      "翦",
      "茧",
      "藆",
      "蠒",
      "裥",
      "襇",
      "襉",
      "襺",
      "詃",
      "謇",
      "謭",
      "譾",
      "谫",
      "趼",
      "蹇",
      "鐗",
      "鬋",
      "鰎",
      "鹸",
      "鹻",
      "鹼"
    ],
    huò: [
      "俰",
      "咟",
      "嚯",
      "嚿",
      "奯",
      "彠",
      "惑",
      "或",
      "擭",
      "旤",
      "曤",
      "檴",
      "沎",
      "湱",
      "瀖",
      "獲",
      "癨",
      "眓",
      "矐",
      "祸",
      "禍",
      "穫",
      "窢",
      "耯",
      "臛",
      "艧",
      "获",
      "蒦",
      "藿",
      "蠖",
      "謋",
      "貨",
      "货",
      "鍃",
      "鑊",
      "镬",
      "雘",
      "霍",
      "靃",
      "韄",
      "㸌"
    ],
    "jù jū": ["俱", "据", "鋸", "锯"],
    xiào: [
      "俲",
      "傚",
      "効",
      "咲",
      "哮",
      "啸",
      "嘋",
      "嘨",
      "嘯",
      "孝",
      "效",
      "斅",
      "斆",
      "歗",
      "涍",
      "熽",
      "笑",
      "詨",
      "誟"
    ],
    pái: ["俳", "徘", "牌", "犤", "猅", "簰", "簲", "輫"],
    biào: ["俵", "鰾", "鳔"],
    "chù tì": ["俶"],
    fèi: [
      "俷",
      "剕",
      "厞",
      "吠",
      "屝",
      "废",
      "廃",
      "廢",
      "昲",
      "曊",
      "櫠",
      "沸",
      "濷",
      "狒",
      "癈",
      "肺",
      "萉",
      "費",
      "费",
      "鐨",
      "镄",
      "陫",
      "靅",
      "鼣"
    ],
    fèng: ["俸", "凤", "奉", "湗", "焨", "煈", "賵", "赗", "鳯", "鳳", "鴌"],
    ǎn: ["俺", "唵", "埯", "揞", "罯", "銨", "铵"],
    bèi: [
      "俻",
      "倍",
      "偝",
      "偹",
      "備",
      "僃",
      "备",
      "悖",
      "惫",
      "愂",
      "憊",
      "昁",
      "梖",
      "焙",
      "牬",
      "犕",
      "狈",
      "狽",
      "珼",
      "琲",
      "碚",
      "禙",
      "糒",
      "苝",
      "蓓",
      "蛽",
      "褙",
      "貝",
      "贝",
      "軰",
      "輩",
      "辈",
      "邶",
      "郥",
      "鄁",
      "鋇",
      "鐾",
      "钡",
      "鞁",
      "鞴",
      "𬇙"
    ],
    yù: [
      "俼",
      "儥",
      "喅",
      "喩",
      "喻",
      "域",
      "堉",
      "妪",
      "嫗",
      "寓",
      "峪",
      "嶎",
      "庽",
      "彧",
      "御",
      "愈",
      "慾",
      "戫",
      "昱",
      "棛",
      "棜",
      "棫",
      "櫲",
      "欎",
      "欝",
      "欲",
      "毓",
      "浴",
      "淯",
      "滪",
      "潏",
      "澦",
      "灪",
      "焴",
      "煜",
      "燏",
      "燠",
      "爩",
      "狱",
      "獄",
      "玉",
      "琙",
      "瘉",
      "癒",
      "砡",
      "硢",
      "硲",
      "礇",
      "礖",
      "礜",
      "禦",
      "秗",
      "稢",
      "稶",
      "篽",
      "籞",
      "籲",
      "粖",
      "緎",
      "罭",
      "聿",
      "肀",
      "艈",
      "芋",
      "芌",
      "茟",
      "蒮",
      "蓣",
      "蓹",
      "蕷",
      "蘌",
      "蜟",
      "蜮",
      "袬",
      "裕",
      "誉",
      "諭",
      "譽",
      "谕",
      "豫",
      "軉",
      "輍",
      "逳",
      "遇",
      "遹",
      "郁",
      "醧",
      "鈺",
      "鋊",
      "錥",
      "鐭",
      "钰",
      "閾",
      "阈",
      "雤",
      "霱",
      "預",
      "预",
      "飫",
      "饇",
      "饫",
      "馭",
      "驈",
      "驭",
      "鬰",
      "鬱",
      "鬻",
      "魊",
      "鱊",
      "鳿",
      "鴥",
      "鴧",
      "鴪",
      "鵒",
      "鷸",
      "鸒",
      "鹆",
      "鹬"
    ],
    xīn: [
      "俽",
      "噺",
      "妡",
      "嬜",
      "廞",
      "心",
      "忄",
      "忻",
      "惞",
      "新",
      "昕",
      "杺",
      "欣",
      "歆",
      "炘",
      "盺",
      "薪",
      "訢",
      "辛",
      "邤",
      "鈊",
      "鋅",
      "鑫",
      "锌",
      "馨",
      "馫",
      "䜣",
      "𫷷"
    ],
    "hǔ chí": ["俿"],
    jiù: [
      "倃",
      "僦",
      "匓",
      "匛",
      "匶",
      "厩",
      "咎",
      "就",
      "廄",
      "廏",
      "廐",
      "慦",
      "捄",
      "救",
      "旧",
      "柩",
      "柾",
      "桕",
      "欍",
      "殧",
      "疚",
      "臼",
      "舅",
      "舊",
      "鯦",
      "鷲",
      "鹫",
      "麔",
      "齨",
      "㠇"
    ],
    yáo: [
      "倄",
      "傜",
      "嗂",
      "垚",
      "堯",
      "姚",
      "媱",
      "尧",
      "尭",
      "峣",
      "嶢",
      "嶤",
      "徭",
      "揺",
      "搖",
      "摇",
      "摿",
      "暚",
      "榣",
      "烑",
      "爻",
      "猺",
      "珧",
      "瑤",
      "瑶",
      "磘",
      "窑",
      "窯",
      "窰",
      "肴",
      "蘨",
      "謠",
      "謡",
      "谣",
      "軺",
      "轺",
      "遙",
      "遥",
      "邎",
      "顤",
      "颻",
      "飖",
      "餆",
      "餚",
      "鰩",
      "鱙",
      "鳐"
    ],
    "cuì zú": ["倅"],
    "liǎng liǎ": ["倆"],
    wǎn: [
      "倇",
      "唍",
      "婉",
      "惋",
      "挽",
      "晚",
      "晥",
      "晩",
      "晼",
      "梚",
      "椀",
      "琬",
      "畹",
      "皖",
      "盌",
      "碗",
      "綩",
      "綰",
      "绾",
      "脘",
      "萖",
      "踠",
      "輓",
      "鋔"
    ],
    zǒng: [
      "倊",
      "偬",
      "傯",
      "嵸",
      "总",
      "惣",
      "捴",
      "搃",
      "摠",
      "燪",
      "総",
      "緫",
      "縂",
      "總",
      "蓗"
    ],
    guān: [
      "倌",
      "关",
      "官",
      "棺",
      "瘝",
      "癏",
      "窤",
      "蒄",
      "関",
      "闗",
      "關",
      "鰥",
      "鱞",
      "鳏"
    ],
    tiǎn: [
      "倎",
      "唺",
      "忝",
      "悿",
      "晪",
      "殄",
      "淟",
      "睓",
      "腆",
      "舔",
      "覥",
      "觍",
      "賟",
      "錪",
      "餂"
    ],
    mén: ["們", "扪", "捫", "璊", "菛", "虋", "鍆", "钔", "門", "閅", "门", "𫞩"],
    "dǎo dào": ["倒"],
    "tán tàn": ["倓", "埮"],
    "juè jué": ["倔"],
    chuí: [
      "倕",
      "垂",
      "埀",
      "捶",
      "搥",
      "桘",
      "棰",
      "槌",
      "箠",
      "腄",
      "菙",
      "錘",
      "鎚",
      "锤",
      "陲",
      "顀"
    ],
    xìng: [
      "倖",
      "姓",
      "婞",
      "嬹",
      "幸",
      "性",
      "悻",
      "杏",
      "涬",
      "緈",
      "臖",
      "荇",
      "莕",
      "葕"
    ],
    péng: [
      "倗",
      "傰",
      "塜",
      "塳",
      "弸",
      "憉",
      "捀",
      "朋",
      "棚",
      "椖",
      "樥",
      "硼",
      "稝",
      "竼",
      "篷",
      "纄",
      "膨",
      "芃",
      "蓬",
      "蘕",
      "蟚",
      "蟛",
      "袶",
      "輣",
      "錋",
      "鑝",
      "韸",
      "韼",
      "騯",
      "髼",
      "鬅",
      "鬔",
      "鵬",
      "鹏"
    ],
    "tǎng cháng": ["倘"],
    hòu: [
      "候",
      "厚",
      "后",
      "垕",
      "堠",
      "後",
      "洉",
      "茩",
      "豞",
      "逅",
      "郈",
      "鮜",
      "鱟",
      "鲎",
      "鲘"
    ],
    tì: [
      "倜",
      "剃",
      "嚏",
      "嚔",
      "屉",
      "屜",
      "悌",
      "悐",
      "惕",
      "惖",
      "戻",
      "掦",
      "替",
      "朑",
      "歒",
      "殢",
      "涕",
      "瓋",
      "笹",
      "籊",
      "薙",
      "褅",
      "逖",
      "逷",
      "髰",
      "鬀",
      "鬄"
    ],
    gàn: [
      "倝",
      "凎",
      "幹",
      "榦",
      "檊",
      "淦",
      "灨",
      "盰",
      "紺",
      "绀",
      "詌",
      "贑",
      "赣",
      "骭",
      "㽏"
    ],
    "liàng jìng": ["倞", "靓"],
    suī: [
      "倠",
      "哸",
      "夊",
      "滖",
      "濉",
      "眭",
      "睢",
      "芕",
      "荽",
      "荾",
      "虽",
      "雖",
      "鞖"
    ],
    "chàng chāng": ["倡"],
    jié: [
      "倢",
      "偼",
      "傑",
      "刦",
      "刧",
      "刼",
      "劫",
      "劼",
      "卩",
      "卪",
      "婕",
      "媫",
      "孑",
      "岊",
      "崨",
      "嵥",
      "嶻",
      "巀",
      "幯",
      "截",
      "捷",
      "掶",
      "擮",
      "昅",
      "杢",
      "杰",
      "桀",
      "桝",
      "楬",
      "楶",
      "榤",
      "洁",
      "滐",
      "潔",
      "狤",
      "睫",
      "礍",
      "竭",
      "節",
      "羯",
      "莭",
      "蓵",
      "蛣",
      "蜐",
      "蠘",
      "蠞",
      "蠽",
      "衱",
      "袺",
      "訐",
      "詰",
      "誱",
      "讦",
      "踕",
      "迼",
      "鉣",
      "鍻",
      "镼",
      "頡",
      "鮚",
      "鲒",
      "㛃"
    ],
    "kǒng kōng": ["倥"],
    juàn: [
      "倦",
      "劵",
      "奆",
      "慻",
      "桊",
      "淃",
      "狷",
      "獧",
      "眷",
      "睊",
      "睠",
      "絭",
      "絹",
      "绢",
      "罥",
      "羂",
      "腃",
      "蔨",
      "鄄",
      "餋"
    ],
    zōng: [
      "倧",
      "堫",
      "宗",
      "嵏",
      "嵕",
      "惾",
      "朡",
      "棕",
      "椶",
      "熧",
      "猣",
      "磫",
      "緃",
      "翪",
      "腙",
      "葼",
      "蝬",
      "豵",
      "踨",
      "踪",
      "蹤",
      "鍐",
      "鑁",
      "騌",
      "騣",
      "骔",
      "鬃",
      "鬉",
      "鬷",
      "鯮",
      "鯼"
    ],
    ní: [
      "倪",
      "坭",
      "埿",
      "尼",
      "屔",
      "怩",
      "淣",
      "猊",
      "籾",
      "聣",
      "蚭",
      "蜺",
      "觬",
      "貎",
      "跜",
      "輗",
      "郳",
      "鈮",
      "铌",
      "霓",
      "馜",
      "鯢",
      "鲵",
      "麑",
      "齯",
      "𫐐",
      "𫠜"
    ],
    zhuō: [
      "倬",
      "拙",
      "捉",
      "桌",
      "梲",
      "棁",
      "棳",
      "槕",
      "涿",
      "窧",
      "鐯",
      "䦃"
    ],
    "wō wēi": ["倭"],
    luǒ: ["倮", "剆", "曪", "瘰", "癳", "臝", "蓏", "蠃", "裸", "躶"],
    sōng: [
      "倯",
      "凇",
      "娀",
      "崧",
      "嵩",
      "庺",
      "憽",
      "松",
      "枀",
      "枩",
      "柗",
      "梥",
      "檧",
      "淞",
      "濍",
      "硹",
      "菘",
      "鬆"
    ],
    lèng: ["倰", "堎", "愣", "睖", "踜"],
    zì: [
      "倳",
      "剚",
      "字",
      "恣",
      "渍",
      "漬",
      "牸",
      "眥",
      "眦",
      "胔",
      "胾",
      "自",
      "茡",
      "荢"
    ],
    bèn: ["倴", "坌", "捹", "撪", "渀", "笨", "逩"],
    cǎi: ["倸", "啋", "婇", "彩", "採", "棌", "毝", "睬", "綵", "跴", "踩"],
    zhài: ["债", "債", "寨", "瘵", "砦"],
    yē: ["倻", "吔", "噎", "擨", "暍", "椰", "歋", "潱", "蠮"],
    shà: ["倽", "唼", "喢", "歃", "箑", "翜", "翣", "萐", "閯", "霎"],
    qīng: [
      "倾",
      "傾",
      "卿",
      "圊",
      "寈",
      "氢",
      "氫",
      "淸",
      "清",
      "蜻",
      "軽",
      "輕",
      "轻",
      "郬",
      "錆",
      "鑋",
      "靑",
      "青",
      "鯖"
    ],
    yīng: [
      "偀",
      "嘤",
      "噟",
      "嚶",
      "婴",
      "媖",
      "嫈",
      "嬰",
      "孆",
      "孾",
      "愥",
      "撄",
      "攖",
      "朠",
      "桜",
      "樱",
      "櫻",
      "渶",
      "煐",
      "珱",
      "瑛",
      "璎",
      "瓔",
      "甇",
      "甖",
      "碤",
      "礯",
      "緓",
      "纓",
      "绬",
      "缨",
      "罂",
      "罃",
      "罌",
      "膺",
      "英",
      "莺",
      "蘡",
      "蝧",
      "蠳",
      "褮",
      "譻",
      "賏",
      "軈",
      "鑍",
      "锳",
      "霙",
      "韺",
      "鴬",
      "鶑",
      "鶧",
      "鶯",
      "鷪",
      "鷹",
      "鸎",
      "鸚",
      "鹦",
      "鹰",
      "䓨"
    ],
    "chēng chèn": ["偁", "爯"],
    ruǎn: ["偄", "朊", "瑌", "瓀", "碝", "礝", "腝", "軟", "輭", "软", "阮"],
    "zhòng tóng": ["偅"],
    chǔn: ["偆", "惷", "睶", "萶", "蠢", "賰"],
    "jiǎ jià": ["假"],
    "jì jié": ["偈"],
    "bǐng bìng": ["偋"],
    ruò: [
      "偌",
      "叒",
      "嵶",
      "弱",
      "楉",
      "焫",
      "爇",
      "箬",
      "篛",
      "蒻",
      "鄀",
      "鰙",
      "鰯",
      "鶸"
    ],
    tí: [
      "偍",
      "厗",
      "啼",
      "嗁",
      "崹",
      "漽",
      "瑅",
      "睼",
      "禵",
      "稊",
      "緹",
      "缇",
      "罤",
      "蕛",
      "褆",
      "謕",
      "趧",
      "蹄",
      "蹏",
      "醍",
      "鍗",
      "題",
      "题",
      "騠",
      "鮷",
      "鯷",
      "鳀",
      "鵜",
      "鷤",
      "鹈",
      "𫘨"
    ],
    wēi: [
      "偎",
      "危",
      "喴",
      "威",
      "媙",
      "嶶",
      "巍",
      "微",
      "愄",
      "揋",
      "揻",
      "椳",
      "楲",
      "溦",
      "烓",
      "煨",
      "燰",
      "癓",
      "縅",
      "葨",
      "葳",
      "薇",
      "蜲",
      "蝛",
      "覣",
      "詴",
      "逶",
      "隇",
      "隈",
      "霺",
      "鰃",
      "鰄",
      "鳂"
    ],
    piān: ["偏", "囨", "媥", "楄", "犏", "篇", "翩", "鍂"],
    yàn: [
      "偐",
      "厌",
      "厭",
      "唁",
      "喭",
      "嚈",
      "嚥",
      "堰",
      "妟",
      "姲",
      "嬊",
      "嬿",
      "宴",
      "彥",
      "彦",
      "敥",
      "晏",
      "暥",
      "曕",
      "曣",
      "滟",
      "灎",
      "灔",
      "灧",
      "灩",
      "焔",
      "焰",
      "焱",
      "熖",
      "燄",
      "牪",
      "猒",
      "砚",
      "硯",
      "艳",
      "艶",
      "艷",
      "覎",
      "觃",
      "觾",
      "諺",
      "讌",
      "讞",
      "谚",
      "谳",
      "豓",
      "豔",
      "贋",
      "贗",
      "赝",
      "軅",
      "酀",
      "酽",
      "醼",
      "釅",
      "雁",
      "餍",
      "饜",
      "騐",
      "験",
      "騴",
      "驗",
      "驠",
      "验",
      "鬳",
      "鳫",
      "鴈",
      "鴳",
      "鷃",
      "鷰",
      "齞"
    ],
    "tǎng dàng": ["偒"],
    è: [
      "偔",
      "匎",
      "卾",
      "厄",
      "呝",
      "咢",
      "噩",
      "垩",
      "堊",
      "堮",
      "岋",
      "崿",
      "廅",
      "悪",
      "愕",
      "戹",
      "扼",
      "搤",
      "搹",
      "擜",
      "櫮",
      "歞",
      "歺",
      "湂",
      "琧",
      "砈",
      "砐",
      "硆",
      "腭",
      "苊",
      "萼",
      "蕚",
      "蚅",
      "蝁",
      "覨",
      "諤",
      "讍",
      "谔",
      "豟",
      "軛",
      "軶",
      "轭",
      "遌",
      "遏",
      "遻",
      "鄂",
      "鈪",
      "鍔",
      "鑩",
      "锷",
      "阨",
      "阸",
      "頞",
      "顎",
      "颚",
      "餓",
      "餩",
      "饿",
      "鰐",
      "鰪",
      "鱷",
      "鳄",
      "鶚",
      "鹗",
      "齃",
      "齶",
      "𫫇",
      "𥔲"
    ],
    xié: [
      "偕",
      "勰",
      "协",
      "協",
      "嗋",
      "垥",
      "奊",
      "恊",
      "愶",
      "拹",
      "携",
      "撷",
      "擕",
      "擷",
      "攜",
      "斜",
      "旪",
      "熁",
      "燲",
      "綊",
      "緳",
      "縀",
      "缬",
      "翓",
      "胁",
      "脅",
      "脇",
      "脋",
      "膎",
      "蝢",
      "衺",
      "襭",
      "諧",
      "讗",
      "谐",
      "鞋",
      "鞵",
      "龤",
      "㙦"
    ],
    chě: ["偖", "扯", "撦"],
    shěng: ["偗", "渻", "眚"],
    chā: [
      "偛",
      "嗏",
      "扠",
      "挿",
      "插",
      "揷",
      "疀",
      "臿",
      "艖",
      "銟",
      "鍤",
      "锸",
      "餷"
    ],
    huáng: [
      "偟",
      "凰",
      "喤",
      "堭",
      "墴",
      "媓",
      "崲",
      "徨",
      "惶",
      "楻",
      "湟",
      "煌",
      "獚",
      "瑝",
      "璜",
      "癀",
      "皇",
      "磺",
      "穔",
      "篁",
      "簧",
      "艎",
      "葟",
      "蝗",
      "蟥",
      "諻",
      "趪",
      "遑",
      "鍠",
      "鐄",
      "锽",
      "隍",
      "韹",
      "餭",
      "騜",
      "鰉",
      "鱑",
      "鳇",
      "鷬",
      "黃",
      "黄",
      "𨱑"
    ],
    yǎo: [
      "偠",
      "咬",
      "婹",
      "宎",
      "岆",
      "杳",
      "柼",
      "榚",
      "溔",
      "狕",
      "窅",
      "窈",
      "舀",
      "苭",
      "闄",
      "騕",
      "鷕",
      "齩"
    ],
    "chǒu qiào": ["偢"],
    yóu: [
      "偤",
      "尤",
      "庮",
      "怣",
      "沋",
      "油",
      "浟",
      "游",
      "犹",
      "猶",
      "猷",
      "由",
      "疣",
      "秞",
      "肬",
      "莜",
      "莸",
      "蕕",
      "蚰",
      "蝣",
      "訧",
      "輏",
      "輶",
      "逰",
      "遊",
      "邮",
      "郵",
      "鈾",
      "铀",
      "駀",
      "魷",
      "鮋",
      "鱿",
      "鲉",
      "𬨎"
    ],
    xū: [
      "偦",
      "墟",
      "媭",
      "嬃",
      "楈",
      "欨",
      "歔",
      "燸",
      "疞",
      "盱",
      "綇",
      "縃",
      "繻",
      "胥",
      "蕦",
      "虗",
      "虚",
      "虛",
      "蝑",
      "裇",
      "訏",
      "許",
      "諝",
      "譃",
      "谞",
      "鑐",
      "需",
      "須",
      "须",
      "顼",
      "驉",
      "鬚",
      "魆",
      "魖",
      "𬣙",
      "𦈡"
    ],
    zhā: [
      "偧",
      "哳",
      "抯",
      "挓",
      "揸",
      "摣",
      "樝",
      "渣",
      "皶",
      "觰",
      "譇",
      "齄",
      "齇"
    ],
    cī: ["偨", "疵", "蠀", "趀", "骴", "髊", "齹"],
    bī: ["偪", "屄", "楅", "毴", "豍", "逼", "鰏", "鲾", "鵖"],
    xún: [
      "偱",
      "噚",
      "寻",
      "尋",
      "峋",
      "巡",
      "廵",
      "循",
      "恂",
      "揗",
      "攳",
      "旬",
      "杊",
      "栒",
      "桪",
      "樳",
      "洵",
      "浔",
      "潯",
      "燅",
      "燖",
      "珣",
      "璕",
      "畃",
      "紃",
      "荀",
      "蟳",
      "詢",
      "询",
      "鄩",
      "鱏",
      "鱘",
      "鲟",
      "𬘓",
      "𬩽",
      "𬍤",
      "𬊈"
    ],
    "cāi sī": ["偲"],
    duān: ["偳", "媏", "端", "褍", "鍴"],
    ǒu: ["偶", "吘", "嘔", "耦", "腢", "蕅", "藕", "𬉼", "𠙶"],
    tōu: ["偷", "偸", "鍮"],
    "zán zá zǎ": ["偺"],
    "lǚ lóu": ["偻", "僂"],
    fèn: [
      "偾",
      "僨",
      "奋",
      "奮",
      "弅",
      "忿",
      "愤",
      "憤",
      "瀵",
      "瞓",
      "秎",
      "粪",
      "糞",
      "膹",
      "鱝",
      "鲼"
    ],
    "kuǐ guī": ["傀"],
    sǒu: ["傁", "叜", "叟", "嗾", "櫢", "瞍", "薮", "藪"],
    "zhì sī tí": ["傂"],
    sù: [
      "傃",
      "僳",
      "嗉",
      "塐",
      "塑",
      "夙",
      "嫊",
      "愫",
      "憟",
      "榡",
      "樎",
      "樕",
      "殐",
      "泝",
      "涑",
      "溯",
      "溸",
      "潚",
      "潥",
      "玊",
      "珟",
      "璛",
      "簌",
      "粛",
      "粟",
      "素",
      "縤",
      "肃",
      "肅",
      "膆",
      "蔌",
      "藗",
      "觫",
      "訴",
      "謖",
      "诉",
      "谡",
      "趚",
      "蹜",
      "速",
      "遡",
      "遬",
      "鋉",
      "餗",
      "驌",
      "骕",
      "鱐",
      "鷫",
      "鹔",
      "𫗧"
    ],
    xiā: ["傄", "煆", "瞎", "虲", "谺", "颬", "鰕"],
    "yuàn yuán": ["傆", "媛"],
    rǒng: ["傇", "冗", "宂", "氄", "軵"],
    nù: ["傉", "怒"],
    yùn: [
      "傊",
      "孕",
      "恽",
      "惲",
      "愠",
      "慍",
      "枟",
      "腪",
      "蕴",
      "薀",
      "藴",
      "蘊",
      "褞",
      "貟",
      "运",
      "運",
      "郓",
      "鄆",
      "酝",
      "醖",
      "醞",
      "韗",
      "韞",
      "韵",
      "韻",
      "餫"
    ],
    "gòu jiǎng": ["傋"],
    mà: ["傌", "嘜", "榪", "睰", "祃", "禡", "罵", "閁", "駡", "骂", "鬕"],
    bàng: [
      "傍",
      "塝",
      "棒",
      "玤",
      "稖",
      "艕",
      "蒡",
      "蜯",
      "謗",
      "谤",
      "鎊",
      "镑"
    ],
    diān: [
      "傎",
      "厧",
      "嵮",
      "巅",
      "巓",
      "巔",
      "掂",
      "攧",
      "敁",
      "槇",
      "滇",
      "癫",
      "癲",
      "蹎",
      "顚",
      "顛",
      "颠",
      "齻"
    ],
    táng: [
      "傏",
      "唐",
      "啺",
      "坣",
      "堂",
      "塘",
      "搪",
      "棠",
      "榶",
      "溏",
      "漟",
      "煻",
      "瑭",
      "磄",
      "禟",
      "篖",
      "糃",
      "糖",
      "糛",
      "膅",
      "膛",
      "蓎",
      "螗",
      "螳",
      "赯",
      "踼",
      "鄌",
      "醣",
      "鎕",
      "隚",
      "餹",
      "饄",
      "鶶",
      "䣘"
    ],
    hào: [
      "傐",
      "哠",
      "恏",
      "昊",
      "昦",
      "晧",
      "暠",
      "暤",
      "暭",
      "曍",
      "浩",
      "淏",
      "澔",
      "灏",
      "灝",
      "皓",
      "皜",
      "皞",
      "皡",
      "皥",
      "耗",
      "聕",
      "薃",
      "號",
      "鄗",
      "顥",
      "颢",
      "鰝"
    ],
    "xī xì": ["傒"],
    shān: [
      "傓",
      "删",
      "刪",
      "剼",
      "圸",
      "山",
      "挻",
      "搧",
      "柵",
      "檆",
      "潸",
      "澘",
      "煽",
      "狦",
      "珊",
      "笘",
      "縿",
      "羴",
      "羶",
      "脠",
      "舢",
      "芟",
      "衫",
      "跚",
      "軕",
      "邖",
      "閊",
      "鯅"
    ],
    "qiàn jiān": ["傔"],
    "què jué": ["傕", "埆"],
    "cāng chen": ["傖"],
    róng: [
      "傛",
      "媶",
      "嫆",
      "嬫",
      "容",
      "峵",
      "嵘",
      "嶸",
      "戎",
      "搈",
      "曧",
      "栄",
      "榕",
      "榮",
      "榵",
      "毧",
      "溶",
      "瀜",
      "烿",
      "熔",
      "狨",
      "瑢",
      "穁",
      "絨",
      "绒",
      "羢",
      "肜",
      "茙",
      "茸",
      "荣",
      "蓉",
      "蝾",
      "融",
      "螎",
      "蠑",
      "褣",
      "鎔",
      "镕",
      "駥"
    ],
    "tà tàn": ["傝"],
    suō: [
      "傞",
      "唆",
      "嗍",
      "嗦",
      "娑",
      "摍",
      "桫",
      "梭",
      "睃",
      "簑",
      "簔",
      "羧",
      "莏",
      "蓑",
      "趖",
      "鮻"
    ],
    dǎi: ["傣", "歹"],
    zài: ["傤", "儎", "再", "在", "扗", "洅", "載", "酨"],
    gǔ: [
      "傦",
      "古",
      "啒",
      "尳",
      "愲",
      "榖",
      "榾",
      "汩",
      "淈",
      "濲",
      "瀔",
      "牯",
      "皷",
      "皼",
      "盬",
      "瞽",
      "穀",
      "罟",
      "羖",
      "股",
      "脵",
      "臌",
      "薣",
      "蛊",
      "蠱",
      "詁",
      "诂",
      "轂",
      "逧",
      "鈷",
      "钴",
      "餶",
      "馉",
      "鼓",
      "鼔",
      "𦙶"
    ],
    bīn: [
      "傧",
      "宾",
      "彬",
      "斌",
      "椕",
      "滨",
      "濒",
      "濱",
      "濵",
      "瀕",
      "繽",
      "缤",
      "虨",
      "豩",
      "豳",
      "賓",
      "賔",
      "邠",
      "鑌",
      "镔",
      "霦",
      "顮"
    ],
    chǔ: [
      "储",
      "儲",
      "杵",
      "椘",
      "楚",
      "楮",
      "檚",
      "濋",
      "璴",
      "础",
      "礎",
      "禇",
      "處",
      "齭",
      "齼",
      "𬺓"
    ],
    nuó: ["傩", "儺", "挪", "梛", "橠"],
    "cān càn": ["傪"],
    lěi: [
      "傫",
      "儡",
      "厽",
      "垒",
      "塁",
      "壘",
      "壨",
      "櫐",
      "灅",
      "癗",
      "矋",
      "磊",
      "礨",
      "耒",
      "蕌",
      "蕾",
      "藟",
      "蘽",
      "蠝",
      "誄",
      "讄",
      "诔",
      "鑸",
      "鸓"
    ],
    cuī: ["催", "凗", "墔", "崔", "嵟", "慛", "摧", "榱", "獕", "磪", "鏙"],
    yōng: [
      "傭",
      "嗈",
      "墉",
      "壅",
      "嫞",
      "庸",
      "廱",
      "慵",
      "拥",
      "擁",
      "滽",
      "灉",
      "牅",
      "痈",
      "癕",
      "癰",
      "臃",
      "邕",
      "郺",
      "鄘",
      "鏞",
      "镛",
      "雍",
      "雝",
      "饔",
      "鱅",
      "鳙",
      "鷛"
    ],
    "zāo cáo": ["傮"],
    sǒng: ["傱", "嵷", "怂", "悚", "愯", "慫", "竦", "耸", "聳", "駷", "㧐"],
    ào: [
      "傲",
      "坳",
      "垇",
      "墺",
      "奡",
      "嫯",
      "岙",
      "岰",
      "嶴",
      "懊",
      "擙",
      "澳",
      "鏊",
      "驁",
      "骜"
    ],
    "qī còu": ["傶"],
    chuǎng: ["傸", "磢", "闖", "闯"],
    shǎ: ["傻", "儍"],
    hàn: [
      "傼",
      "垾",
      "悍",
      "憾",
      "扞",
      "捍",
      "撖",
      "撼",
      "旱",
      "晘",
      "暵",
      "汉",
      "涆",
      "漢",
      "瀚",
      "焊",
      "猂",
      "皔",
      "睅",
      "翰",
      "莟",
      "菡",
      "蛿",
      "蜭",
      "螒",
      "譀",
      "輚",
      "釬",
      "銲",
      "鋎",
      "雗",
      "頷",
      "顄",
      "颔",
      "駻",
      "鶾"
    ],
    zhāng: [
      "傽",
      "嫜",
      "张",
      "張",
      "彰",
      "慞",
      "暲",
      "樟",
      "漳",
      "獐",
      "璋",
      "章",
      "粻",
      "蔁",
      "蟑",
      "遧",
      "鄣",
      "鏱",
      "餦",
      "騿",
      "鱆",
      "麞"
    ],
    "yān yàn": ["傿", "墕", "嬮"],
    "piào biāo": ["僄", "骠"],
    liàn: [
      "僆",
      "堜",
      "媡",
      "恋",
      "戀",
      "楝",
      "殓",
      "殮",
      "湅",
      "潋",
      "澰",
      "瀲",
      "炼",
      "煉",
      "瑓",
      "練",
      "纞",
      "练",
      "萰",
      "錬",
      "鍊",
      "鏈",
      "链",
      "鰊",
      "𬶠"
    ],
    màn: [
      "㵘",
      "僈",
      "墁",
      "幔",
      "慢",
      "曼",
      "漫",
      "澷",
      "熳",
      "獌",
      "縵",
      "缦",
      "蔄",
      "蘰",
      "鄤",
      "鏝",
      "镘",
      "𬜬"
    ],
    "tàn tǎn": ["僋"],
    yíng: [
      "僌",
      "営",
      "塋",
      "嬴",
      "攍",
      "楹",
      "櫿",
      "溁",
      "溋",
      "滢",
      "潆",
      "濙",
      "濚",
      "濴",
      "瀅",
      "瀛",
      "瀠",
      "瀯",
      "灐",
      "灜",
      "熒",
      "營",
      "瑩",
      "盁",
      "盈",
      "禜",
      "籝",
      "籯",
      "縈",
      "茔",
      "荧",
      "莹",
      "萤",
      "营",
      "萦",
      "萾",
      "蓥",
      "藀",
      "蛍",
      "蝇",
      "蝿",
      "螢",
      "蠅",
      "謍",
      "贏",
      "赢",
      "迎",
      "鎣"
    ],
    dòng: [
      "働",
      "冻",
      "凍",
      "动",
      "動",
      "姛",
      "戙",
      "挏",
      "栋",
      "棟",
      "湩",
      "硐",
      "胨",
      "胴",
      "腖",
      "迵",
      "霘",
      "駧"
    ],
    zhuàn: [
      "僎",
      "啭",
      "囀",
      "堟",
      "撰",
      "灷",
      "瑑",
      "篆",
      "腞",
      "蒃",
      "襈",
      "譔",
      "饌",
      "馔"
    ],
    xiàng: [
      "像",
      "勨",
      "向",
      "嚮",
      "姠",
      "嶑",
      "曏",
      "橡",
      "珦",
      "缿",
      "蟓",
      "衖",
      "襐",
      "象",
      "鐌",
      "項",
      "项",
      "鱌"
    ],
    shàn: [
      "僐",
      "善",
      "墠",
      "墡",
      "嬗",
      "擅",
      "敾",
      "椫",
      "樿",
      "歚",
      "汕",
      "灗",
      "疝",
      "磰",
      "繕",
      "缮",
      "膳",
      "蟮",
      "蟺",
      "訕",
      "謆",
      "譱",
      "讪",
      "贍",
      "赡",
      "赸",
      "鄯",
      "鐥",
      "饍",
      "騸",
      "骟",
      "鱓",
      "鱔",
      "鳝",
      "𫮃"
    ],
    "tuí tuǐ": ["僓"],
    zǔn: ["僔", "噂", "撙", "譐"],
    pú: [
      "僕",
      "匍",
      "圤",
      "墣",
      "濮",
      "獛",
      "璞",
      "瞨",
      "穙",
      "莆",
      "菐",
      "菩",
      "葡",
      "蒱",
      "蒲",
      "贌",
      "酺",
      "鏷",
      "镤"
    ],
    láo: [
      "僗",
      "劳",
      "労",
      "勞",
      "哰",
      "崂",
      "嶗",
      "憥",
      "朥",
      "浶",
      "牢",
      "痨",
      "癆",
      "窂",
      "簩",
      "醪",
      "鐒",
      "铹",
      "顟",
      "髝",
      "𫭼"
    ],
    chǎng: ["僘", "厰", "廠", "敞", "昶", "氅", "鋹", "𬬮"],
    guāng: [
      "僙",
      "光",
      "咣",
      "垙",
      "姯",
      "洸",
      "灮",
      "炗",
      "炚",
      "炛",
      "烡",
      "珖",
      "胱",
      "茪",
      "輄",
      "銧",
      "黆",
      "𨐈"
    ],
    liáo: [
      "僚",
      "嘹",
      "嫽",
      "寥",
      "寮",
      "尞",
      "屪",
      "嵺",
      "嶚",
      "嶛",
      "廫",
      "憀",
      "敹",
      "暸",
      "橑",
      "獠",
      "璙",
      "疗",
      "療",
      "竂",
      "簝",
      "繚",
      "缭",
      "聊",
      "膋",
      "膫",
      "藔",
      "蟟",
      "豂",
      "賿",
      "蹘",
      "辽",
      "遼",
      "飉",
      "髎",
      "鷯",
      "鹩"
    ],
    dèng: ["僜", "凳", "墱", "嶝", "櫈", "瞪", "磴", "覴", "邓", "鄧", "隥"],
    "chán zhàn zhuàn": ["僝"],
    bō: [
      "僠",
      "嶓",
      "拨",
      "撥",
      "播",
      "波",
      "溊",
      "玻",
      "癶",
      "盋",
      "砵",
      "碆",
      "礡",
      "缽",
      "菠",
      "袰",
      "蹳",
      "鉢",
      "钵",
      "餑",
      "饽",
      "驋",
      "鱍",
      "𬭛"
    ],
    huì: [
      "僡",
      "匯",
      "卉",
      "喙",
      "嘒",
      "嚖",
      "圚",
      "嬒",
      "寭",
      "屶",
      "屷",
      "彗",
      "彙",
      "彚",
      "徻",
      "恚",
      "恵",
      "惠",
      "慧",
      "憓",
      "懳",
      "晦",
      "暳",
      "槥",
      "橞",
      "檅",
      "櫘",
      "汇",
      "泋",
      "滙",
      "潓",
      "烩",
      "燴",
      "獩",
      "璤",
      "瞺",
      "硊",
      "秽",
      "穢",
      "篲",
      "絵",
      "繪",
      "绘",
      "翙",
      "翽",
      "荟",
      "蔧",
      "蕙",
      "薈",
      "薉",
      "蟪",
      "詯",
      "誨",
      "諱",
      "譓",
      "譿",
      "讳",
      "诲",
      "賄",
      "贿",
      "鐬",
      "闠",
      "阓",
      "靧",
      "頮",
      "顪",
      "颒",
      "餯",
      "𬤝",
      "𬭬"
    ],
    chuǎn: ["僢", "喘", "舛", "荈", "踳"],
    "tiě jiàn": ["僣"],
    sēng: ["僧", "鬙"],
    xiàn: [
      "僩",
      "僴",
      "哯",
      "垷",
      "塪",
      "姭",
      "娊",
      "宪",
      "岘",
      "峴",
      "憲",
      "撊",
      "晛",
      "橌",
      "橺",
      "涀",
      "瀗",
      "献",
      "獻",
      "现",
      "現",
      "県",
      "睍",
      "粯",
      "糮",
      "絤",
      "綫",
      "線",
      "线",
      "缐",
      "羡",
      "羨",
      "腺",
      "臔",
      "臽",
      "苋",
      "莧",
      "誢",
      "豏",
      "鋧",
      "錎",
      "限",
      "陥",
      "陷",
      "霰",
      "餡",
      "馅",
      "麲",
      "鼸",
      "𬀪",
      "𪾢"
    ],
    "yù jú": ["僪"],
    "è wū": ["僫"],
    "tóng zhuàng": ["僮"],
    lǐn: [
      "僯",
      "凛",
      "凜",
      "廩",
      "廪",
      "懍",
      "懔",
      "撛",
      "檁",
      "檩",
      "澟",
      "癛",
      "癝"
    ],
    gù: [
      "僱",
      "凅",
      "固",
      "堌",
      "崓",
      "崮",
      "故",
      "梏",
      "棝",
      "牿",
      "痼",
      "祻",
      "錮",
      "锢",
      "雇",
      "顧",
      "顾",
      "鯝",
      "鲴"
    ],
    jiāng: [
      "僵",
      "壃",
      "姜",
      "橿",
      "殭",
      "江",
      "畕",
      "疅",
      "礓",
      "繮",
      "缰",
      "翞",
      "茳",
      "葁",
      "薑",
      "螀",
      "螿",
      "豇",
      "韁",
      "鱂",
      "鳉"
    ],
    mǐn: [
      "僶",
      "冺",
      "刡",
      "勄",
      "悯",
      "惽",
      "愍",
      "慜",
      "憫",
      "抿",
      "敃",
      "敏",
      "敯",
      "泯",
      "潣",
      "皿",
      "笢",
      "笽",
      "簢",
      "蠠",
      "閔",
      "閩",
      "闵",
      "闽",
      "鰵",
      "鳘",
      "黽"
    ],
    jìn: [
      "僸",
      "凚",
      "噤",
      "嚍",
      "墐",
      "壗",
      "妗",
      "嬧",
      "搢",
      "晉",
      "晋",
      "枃",
      "殣",
      "浕",
      "浸",
      "溍",
      "濅",
      "濜",
      "烬",
      "煡",
      "燼",
      "琎",
      "瑨",
      "璶",
      "盡",
      "祲",
      "縉",
      "缙",
      "荩",
      "藎",
      "覲",
      "觐",
      "賮",
      "贐",
      "赆",
      "近",
      "进",
      "進",
      "靳",
      "齽"
    ],
    "jià jie": ["價"],
    qiào: [
      "僺",
      "峭",
      "帩",
      "撬",
      "殻",
      "窍",
      "竅",
      "誚",
      "诮",
      "躈",
      "陗",
      "鞩",
      "韒",
      "髚"
    ],
    pì: ["僻", "媲", "嫓", "屁", "澼", "甓", "疈", "譬", "闢", "鷿", "鸊", "䴙"],
    sài: ["僿", "簺", "賽", "赛"],
    "chán tǎn shàn": ["儃"],
    "dāng dàng": ["儅", "当", "闣"],
    xuān: [
      "儇",
      "喧",
      "塇",
      "媗",
      "宣",
      "愃",
      "愋",
      "揎",
      "昍",
      "暄",
      "煊",
      "煖",
      "瑄",
      "睻",
      "矎",
      "禤",
      "箮",
      "翧",
      "翾",
      "萱",
      "萲",
      "蓒",
      "蕿",
      "藼",
      "蘐",
      "蝖",
      "蠉",
      "諠",
      "諼",
      "譞",
      "谖",
      "軒",
      "轩",
      "鍹",
      "駽",
      "鰚",
      "𫓶",
      "𫍽"
    ],
    "dān dàn": ["儋", "擔", "瘅"],
    càn: ["儏", "澯", "灿", "燦", "璨", "粲", "薒", "謲"],
    "bīn bìn": ["儐"],
    "án àn": ["儑"],
    tái: [
      "儓",
      "坮",
      "嬯",
      "抬",
      "擡",
      "檯",
      "炱",
      "炲",
      "籉",
      "臺",
      "薹",
      "跆",
      "邰",
      "颱",
      "鮐",
      "鲐"
    ],
    lán: [
      "儖",
      "兰",
      "囒",
      "婪",
      "岚",
      "嵐",
      "幱",
      "拦",
      "攔",
      "斓",
      "斕",
      "栏",
      "欄",
      "欗",
      "澜",
      "瀾",
      "灆",
      "灡",
      "燣",
      "燷",
      "璼",
      "篮",
      "籃",
      "籣",
      "繿",
      "葻",
      "蓝",
      "藍",
      "蘫",
      "蘭",
      "褴",
      "襕",
      "襤",
      "襴",
      "襽",
      "譋",
      "讕",
      "谰",
      "躝",
      "鑭",
      "镧",
      "闌",
      "阑",
      "韊",
      "𬒗"
    ],
    "nǐ yì ài yí": ["儗"],
    méng: [
      "儚",
      "幪",
      "曚",
      "朦",
      "橗",
      "檬",
      "氋",
      "溕",
      "濛",
      "甍",
      "甿",
      "盟",
      "礞",
      "艨",
      "莔",
      "萌",
      "蕄",
      "虻",
      "蝱",
      "鄳",
      "鄸",
      "霿",
      "靀",
      "顭",
      "饛",
      "鯍",
      "鸏",
      "鹲",
      "𫑡",
      "㠓"
    ],
    níng: [
      "儜",
      "凝",
      "咛",
      "嚀",
      "嬣",
      "柠",
      "橣",
      "檸",
      "狞",
      "獰",
      "聍",
      "聹",
      "薴",
      "鑏",
      "鬡",
      "鸋"
    ],
    qióng: [
      "儝",
      "卭",
      "宆",
      "惸",
      "憌",
      "桏",
      "橩",
      "焪",
      "焭",
      "煢",
      "熍",
      "琼",
      "瓊",
      "睘",
      "穷",
      "穹",
      "窮",
      "竆",
      "笻",
      "筇",
      "舼",
      "茕",
      "藑",
      "藭",
      "蛩",
      "蛬",
      "赹",
      "跫",
      "邛",
      "銎",
      "䓖"
    ],
    liè: [
      "儠",
      "冽",
      "列",
      "劣",
      "劽",
      "埒",
      "埓",
      "姴",
      "峛",
      "巤",
      "挒",
      "捩",
      "栵",
      "洌",
      "浖",
      "烈",
      "烮",
      "煭",
      "犣",
      "猎",
      "猟",
      "獵",
      "聗",
      "脟",
      "茢",
      "蛚",
      "趔",
      "躐",
      "迾",
      "颲",
      "鬛",
      "鬣",
      "鮤",
      "鱲",
      "鴷",
      "䴕",
      "𫚭"
    ],
    kuǎng: ["儣", "夼", "懭"],
    bào: [
      "儤",
      "勽",
      "報",
      "忁",
      "报",
      "抱",
      "曓",
      "爆",
      "犦",
      "菢",
      "虣",
      "蚫",
      "豹",
      "鉋",
      "鑤",
      "铇",
      "骲",
      "髱",
      "鮑",
      "鲍"
    ],
    biāo: [
      "儦",
      "墂",
      "幖",
      "彪",
      "标",
      "標",
      "滮",
      "瀌",
      "熛",
      "爂",
      "猋",
      "瘭",
      "磦",
      "膘",
      "臕",
      "謤",
      "贆",
      "鏢",
      "鑣",
      "镖",
      "镳",
      "颮",
      "颷",
      "飆",
      "飇",
      "飈",
      "飊",
      "飑",
      "飙",
      "飚",
      "驫",
      "骉",
      "髟"
    ],
    zǎn: ["儧", "儹", "噆", "攅", "昝", "趱", "趲"],
    háo: [
      "儫",
      "嗥",
      "嘷",
      "噑",
      "嚎",
      "壕",
      "椃",
      "毜",
      "毫",
      "濠",
      "獆",
      "獔",
      "竓",
      "籇",
      "蚝",
      "蠔",
      "譹",
      "豪"
    ],
    qìng: ["儬", "凊", "庆", "慶", "櫦", "濪", "碃", "磬", "罄", "靘"],
    chèn: [
      "儭",
      "嚫",
      "榇",
      "櫬",
      "疢",
      "衬",
      "襯",
      "讖",
      "谶",
      "趁",
      "趂",
      "齓",
      "齔",
      "龀"
    ],
    téng: [
      "儯",
      "幐",
      "滕",
      "漛",
      "疼",
      "籐",
      "籘",
      "縢",
      "腾",
      "藤",
      "虅",
      "螣",
      "誊",
      "謄",
      "邆",
      "駦",
      "騰",
      "驣",
      "鰧",
      "䲢"
    ],
    "lǒng lóng lòng": ["儱"],
    "chán chàn": ["儳"],
    "ráng xiāng": ["儴", "勷"],
    "huì xié": ["儶"],
    luó: [
      "儸",
      "攞",
      "椤",
      "欏",
      "猡",
      "玀",
      "箩",
      "籮",
      "罗",
      "羅",
      "脶",
      "腡",
      "萝",
      "蘿",
      "螺",
      "覼",
      "逻",
      "邏",
      "鏍",
      "鑼",
      "锣",
      "镙",
      "饠",
      "騾",
      "驘",
      "骡",
      "鸁"
    ],
    léi: [
      "儽",
      "嫘",
      "檑",
      "欙",
      "瓃",
      "畾",
      "縲",
      "纍",
      "纝",
      "缧",
      "罍",
      "羸",
      "蔂",
      "蘲",
      "虆",
      "轠",
      "鐳",
      "鑘",
      "镭",
      "雷",
      "靁",
      "鱩",
      "鼺"
    ],
    "nàng nāng": ["儾"],
    "wù wū": ["兀"],
    yǔn: [
      "允",
      "喗",
      "夽",
      "抎",
      "殒",
      "殞",
      "狁",
      "磒",
      "荺",
      "賱",
      "鈗",
      "阭",
      "陨",
      "隕",
      "霣",
      "馻",
      "齫",
      "齳"
    ],
    zān: ["兂", "橵", "簪", "簮", "糌", "鐕", "鐟", "鵤"],
    yuán: [
      "元",
      "円",
      "原",
      "厡",
      "厵",
      "园",
      "圆",
      "圎",
      "園",
      "圓",
      "垣",
      "塬",
      "媴",
      "嫄",
      "援",
      "榞",
      "榬",
      "橼",
      "櫞",
      "沅",
      "湲",
      "源",
      "溒",
      "爰",
      "猨",
      "猿",
      "笎",
      "緣",
      "縁",
      "缘",
      "羱",
      "茒",
      "薗",
      "蝝",
      "蝯",
      "螈",
      "袁",
      "褤",
      "謜",
      "轅",
      "辕",
      "邍",
      "邧",
      "酛",
      "鈨",
      "鎱",
      "騵",
      "魭",
      "鶢",
      "鶰",
      "黿",
      "鼋",
      "𫘪"
    ],
    xiōng: [
      "兄",
      "兇",
      "凶",
      "匂",
      "匈",
      "哅",
      "忷",
      "恟",
      "汹",
      "洶",
      "胷",
      "胸",
      "芎",
      "訩",
      "詾",
      "讻"
    ],
    chōng: [
      "充",
      "嘃",
      "忡",
      "憃",
      "憧",
      "摏",
      "沖",
      "浺",
      "珫",
      "罿",
      "翀",
      "舂",
      "艟",
      "茺",
      "衝",
      "蹖",
      "㳘"
    ],
    zhào: [
      "兆",
      "垗",
      "旐",
      "曌",
      "枛",
      "櫂",
      "照",
      "燳",
      "狣",
      "瞾",
      "笊",
      "罀",
      "罩",
      "羄",
      "肁",
      "肇",
      "肈",
      "詔",
      "诏",
      "赵",
      "趙",
      "鮡",
      "𬶐"
    ],
    "duì ruì yuè": ["兊", "兌", "兑"],
    kè: [
      "克",
      "刻",
      "勀",
      "勊",
      "堁",
      "娔",
      "客",
      "恪",
      "愙",
      "氪",
      "溘",
      "碦",
      "緙",
      "缂",
      "艐",
      "衉",
      "課",
      "课",
      "錁",
      "锞",
      "騍",
      "骒"
    ],
    tù: ["兎", "兔", "堍", "迌", "鵵"],
    dǎng: ["党", "攩", "欓", "譡", "讜", "谠", "黨", "𣗋"],
    dōu: ["兜", "兠", "唗", "橷", "篼", "蔸"],
    huǎng: [
      "兤",
      "奛",
      "幌",
      "怳",
      "恍",
      "晄",
      "炾",
      "熀",
      "縨",
      "詤",
      "謊",
      "谎"
    ],
    rù: ["入", "嗕", "媷", "扖", "杁", "洳", "溽", "縟", "缛", "蓐", "褥", "鳰"],
    nèi: ["內", "氝", "氞", "錗"],
    "yú shù": ["兪"],
    "liù lù": ["六"],
    han: ["兯", "爳"],
    tiān: ["兲", "天", "婖", "添", "酟", "靔", "靝", "黇"],
    "xīng xìng": ["兴"],
    diǎn: [
      "典",
      "嚸",
      "奌",
      "婰",
      "敟",
      "椣",
      "点",
      "碘",
      "蒧",
      "蕇",
      "踮",
      "點"
    ],
    "zī cí": ["兹"],
    jiān: [
      "兼",
      "冿",
      "囏",
      "坚",
      "堅",
      "奸",
      "姦",
      "姧",
      "尖",
      "幵",
      "惤",
      "戋",
      "戔",
      "搛",
      "椾",
      "樫",
      "櫼",
      "歼",
      "殱",
      "殲",
      "湔",
      "瀐",
      "瀸",
      "煎",
      "熞",
      "熸",
      "牋",
      "瑊",
      "睷",
      "礛",
      "礷",
      "笺",
      "箋",
      "緘",
      "縑",
      "缄",
      "缣",
      "肩",
      "艰",
      "艱",
      "菅",
      "菺",
      "葌",
      "蒹",
      "蔪",
      "蕑",
      "蕳",
      "虃",
      "譼",
      "豜",
      "鑯",
      "雃",
      "鞯",
      "韀",
      "韉",
      "餰",
      "馢",
      "鰔",
      "鰜",
      "鰹",
      "鲣",
      "鳒",
      "鵑",
      "鵳",
      "鶼",
      "鹣",
      "麉"
    ],
    shòu: [
      "兽",
      "受",
      "售",
      "壽",
      "夀",
      "寿",
      "授",
      "狩",
      "獣",
      "獸",
      "痩",
      "瘦",
      "綬",
      "绶",
      "膄"
    ],
    jì: [
      "兾",
      "冀",
      "剂",
      "剤",
      "劑",
      "勣",
      "坖",
      "垍",
      "塈",
      "妓",
      "季",
      "寂",
      "寄",
      "廭",
      "彑",
      "徛",
      "忌",
      "悸",
      "惎",
      "懻",
      "技",
      "旡",
      "既",
      "旣",
      "暨",
      "暩",
      "曁",
      "梞",
      "檕",
      "檵",
      "洎",
      "漃",
      "漈",
      "瀱",
      "痵",
      "癠",
      "禝",
      "稩",
      "稷",
      "穄",
      "穊",
      "穧",
      "紀",
      "継",
      "績",
      "繋",
      "繼",
      "继",
      "绩",
      "罽",
      "臮",
      "芰",
      "茍",
      "茤",
      "葪",
      "蓟",
      "蔇",
      "薊",
      "蘎",
      "蘮",
      "蘻",
      "裚",
      "襀",
      "覬",
      "觊",
      "計",
      "記",
      "誋",
      "计",
      "记",
      "跡",
      "跽",
      "蹟",
      "迹",
      "际",
      "際",
      "霁",
      "霽",
      "驥",
      "骥",
      "髻",
      "鬾",
      "魝",
      "魥",
      "鯚",
      "鯽",
      "鰶",
      "鰿",
      "鱀",
      "鱭",
      "鲚",
      "鲫",
      "鵋",
      "鷑",
      "齌",
      "𪟝",
      "𬶨",
      "𬶭"
    ],
    jiōng: ["冂", "冋", "坰", "埛", "扃", "蘏", "蘔", "駉", "駫", "𬳶"],
    mào: [
      "冃",
      "冐",
      "媢",
      "帽",
      "愗",
      "懋",
      "暓",
      "柕",
      "楙",
      "毷",
      "瑁",
      "皃",
      "眊",
      "瞀",
      "耄",
      "茂",
      "萺",
      "蝐",
      "袤",
      "覒",
      "貌",
      "貿",
      "贸",
      "鄚",
      "鄮"
    ],
    rǎn: ["冄", "冉", "姌", "媣", "染", "珃", "苒", "蒅", "䎃"],
    "nèi nà": ["内"],
    gāng: [
      "冈",
      "冮",
      "刚",
      "剛",
      "堈",
      "堽",
      "岡",
      "掆",
      "摃",
      "棡",
      "牨",
      "犅",
      "疘",
      "綱",
      "纲",
      "缸",
      "罁",
      "罡",
      "肛",
      "釭",
      "鎠",
      "㭎"
    ],
    cè: [
      "冊",
      "册",
      "厕",
      "厠",
      "夨",
      "廁",
      "恻",
      "惻",
      "憡",
      "敇",
      "测",
      "測",
      "笧",
      "策",
      "筞",
      "筴",
      "箣",
      "荝",
      "萗",
      "萴",
      "蓛"
    ],
    guǎ: ["冎", "剐", "剮", "叧", "寡"],
    "mào mò": ["冒"],
    gòu: [
      "冓",
      "啂",
      "坸",
      "垢",
      "够",
      "夠",
      "媾",
      "彀",
      "搆",
      "撀",
      "构",
      "構",
      "煹",
      "覯",
      "觏",
      "訽",
      "詬",
      "诟",
      "購",
      "购",
      "遘",
      "雊"
    ],
    xǔ: ["冔", "喣", "暊", "栩", "珝", "盨", "糈", "詡", "諿", "诩", "鄦", "醑"],
    mì: [
      "冖",
      "冪",
      "嘧",
      "塓",
      "宻",
      "密",
      "峚",
      "幂",
      "幎",
      "幦",
      "怽",
      "榓",
      "樒",
      "櫁",
      "汨",
      "淧",
      "滵",
      "漞",
      "濗",
      "熐",
      "羃",
      "蔤",
      "蜜",
      "覓",
      "覔",
      "覛",
      "觅",
      "謐",
      "谧",
      "鼏"
    ],
    "yóu yín": ["冘"],
    xiě: ["写", "冩", "藛"],
    jūn: [
      "军",
      "君",
      "均",
      "桾",
      "汮",
      "皲",
      "皸",
      "皹",
      "碅",
      "莙",
      "蚐",
      "袀",
      "覠",
      "軍",
      "鈞",
      "銁",
      "銞",
      "鍕",
      "钧",
      "頵",
      "鮶",
      "鲪",
      "麏"
    ],
    mí: [
      "冞",
      "擟",
      "瀰",
      "爢",
      "猕",
      "獼",
      "祢",
      "禰",
      "縻",
      "蒾",
      "藌",
      "蘪",
      "蘼",
      "袮",
      "詸",
      "謎",
      "迷",
      "醚",
      "醾",
      "醿",
      "釄",
      "镾",
      "鸍",
      "麊",
      "麋",
      "麛"
    ],
    "guān guàn": ["冠", "覌", "観", "觀", "观"],
    měng: [
      "冡",
      "勐",
      "懵",
      "掹",
      "猛",
      "獴",
      "艋",
      "蜢",
      "蠓",
      "錳",
      "锰",
      "鯭",
      "鼆"
    ],
    zhǒng: ["冢", "塚", "尰", "歱", "煄", "瘇", "肿", "腫", "踵"],
    zuì: [
      "冣",
      "嶵",
      "晬",
      "最",
      "栬",
      "槜",
      "檇",
      "檌",
      "祽",
      "絊",
      "罪",
      "蕞",
      "辠",
      "酔",
      "酻",
      "醉",
      "錊"
    ],
    yuān: [
      "冤",
      "剈",
      "囦",
      "嬽",
      "寃",
      "棩",
      "淵",
      "渁",
      "渆",
      "渊",
      "渕",
      "灁",
      "眢",
      "肙",
      "葾",
      "蒬",
      "蜎",
      "蜵",
      "駌",
      "鳶",
      "鴛",
      "鵷",
      "鸢",
      "鸳",
      "鹓",
      "鼘",
      "鼝"
    ],
    míng: [
      "冥",
      "名",
      "明",
      "暝",
      "朙",
      "榠",
      "洺",
      "溟",
      "猽",
      "眀",
      "眳",
      "瞑",
      "茗",
      "螟",
      "覭",
      "詺",
      "鄍",
      "銘",
      "铭",
      "鳴",
      "鸣"
    ],
    kòu: [
      "冦",
      "叩",
      "宼",
      "寇",
      "扣",
      "敂",
      "滱",
      "窛",
      "筘",
      "簆",
      "蔲",
      "蔻",
      "釦",
      "鷇"
    ],
    tài: [
      "冭",
      "太",
      "夳",
      "忲",
      "态",
      "態",
      "汰",
      "汱",
      "泰",
      "溙",
      "肽",
      "舦",
      "酞",
      "鈦",
      "钛"
    ],
    "féng píng": ["冯", "馮"],
    "chōng chòng": ["冲"],
    kuàng: [
      "况",
      "圹",
      "壙",
      "岲",
      "懬",
      "旷",
      "昿",
      "曠",
      "框",
      "況",
      "爌",
      "眖",
      "眶",
      "矿",
      "砿",
      "礦",
      "穬",
      "絋",
      "絖",
      "纊",
      "纩",
      "貺",
      "贶",
      "軦",
      "邝",
      "鄺",
      "鉱",
      "鋛",
      "鑛",
      "黋"
    ],
    lěng: ["冷"],
    pàn: [
      "冸",
      "判",
      "叛",
      "沜",
      "泮",
      "溿",
      "炍",
      "牉",
      "畔",
      "盼",
      "聁",
      "袢",
      "襻",
      "詊",
      "鋬",
      "鑻",
      "頖",
      "鵥"
    ],
    fā: ["冹", "彂", "沷", "発", "發"],
    xiǎn: [
      "冼",
      "尟",
      "尠",
      "崄",
      "嶮",
      "幰",
      "攇",
      "显",
      "櫶",
      "毨",
      "灦",
      "烍",
      "燹",
      "狝",
      "猃",
      "獫",
      "獮",
      "玁",
      "禒",
      "筅",
      "箲",
      "藓",
      "蘚",
      "蚬",
      "蜆",
      "譣",
      "赻",
      "跣",
      "鍌",
      "险",
      "険",
      "險",
      "韅",
      "顕",
      "顯",
      "㬎"
    ],
    qià: ["冾", "圶", "帢", "恰", "殎", "洽", "硈", "胢", "髂"],
    "jìng chēng": ["净", "凈", "淨"],
    sōu: [
      "凁",
      "嗖",
      "廀",
      "廋",
      "捜",
      "搜",
      "摉",
      "溲",
      "獀",
      "艘",
      "蒐",
      "螋",
      "鄋",
      "醙",
      "鎪",
      "锼",
      "颼",
      "飕",
      "餿",
      "馊",
      "騪"
    ],
    měi: [
      "凂",
      "媄",
      "媺",
      "嬍",
      "嵄",
      "挴",
      "毎",
      "每",
      "浼",
      "渼",
      "燘",
      "美",
      "躾",
      "鎂",
      "镁",
      "黣"
    ],
    tú: [
      "凃",
      "図",
      "图",
      "圖",
      "圗",
      "塗",
      "屠",
      "峹",
      "嵞",
      "庩",
      "廜",
      "徒",
      "悇",
      "揬",
      "涂",
      "瘏",
      "筡",
      "腯",
      "荼",
      "蒤",
      "跿",
      "途",
      "酴",
      "鈯",
      "鍎",
      "馟",
      "駼",
      "鵌",
      "鶟",
      "鷋",
      "鷵",
      "𬳿"
    ],
    zhǔn: ["准", "凖", "埻", "準", "𬘯"],
    "liáng liàng": ["凉", "涼", "量"],
    diāo: [
      "凋",
      "刁",
      "刟",
      "叼",
      "奝",
      "弴",
      "彫",
      "汈",
      "琱",
      "碉",
      "簓",
      "虭",
      "蛁",
      "貂",
      "錭",
      "雕",
      "鮉",
      "鯛",
      "鲷",
      "鵰",
      "鼦"
    ],
    còu: ["凑", "湊", "腠", "輳", "辏"],
    ái: ["凒", "啀", "嘊", "捱", "溰", "癌", "皑", "皚"],
    duó: ["凙", "剫", "夺", "奪", "痥", "踱", "鈬", "鐸", "铎"],
    dú: [
      "凟",
      "匵",
      "嬻",
      "椟",
      "櫝",
      "殰",
      "涜",
      "牍",
      "牘",
      "犊",
      "犢",
      "独",
      "獨",
      "瓄",
      "皾",
      "裻",
      "読",
      "讀",
      "讟",
      "豄",
      "贕",
      "錖",
      "鑟",
      "韇",
      "韣",
      "韥",
      "騳",
      "髑",
      "黩",
      "黷"
    ],
    "jǐ jī": ["几"],
    fán: [
      "凡",
      "凢",
      "凣",
      "匥",
      "墦",
      "杋",
      "柉",
      "棥",
      "樊",
      "瀿",
      "烦",
      "煩",
      "燔",
      "璠",
      "矾",
      "礬",
      "笲",
      "籵",
      "緐",
      "羳",
      "舤",
      "舧",
      "薠",
      "蘩",
      "蠜",
      "襎",
      "蹯",
      "釩",
      "鐇",
      "鐢",
      "钒",
      "鷭",
      "𫔍",
      "𬸪"
    ],
    jū: [
      "凥",
      "匊",
      "娵",
      "婮",
      "居",
      "崌",
      "抅",
      "挶",
      "掬",
      "梮",
      "椐",
      "檋",
      "毩",
      "毱",
      "泃",
      "涺",
      "狙",
      "琚",
      "疽",
      "砠",
      "罝",
      "腒",
      "艍",
      "蜛",
      "裾",
      "諊",
      "跔",
      "踘",
      "躹",
      "陱",
      "雎",
      "鞠",
      "鞫",
      "駒",
      "驹",
      "鮈",
      "鴡",
      "鶋",
      "𬶋"
    ],
    "chù chǔ": ["処", "处"],
    zhǐ: [
      "凪",
      "劧",
      "咫",
      "址",
      "坧",
      "帋",
      "恉",
      "扺",
      "指",
      "旨",
      "枳",
      "止",
      "汦",
      "沚",
      "洔",
      "淽",
      "疻",
      "砋",
      "祉",
      "秖",
      "紙",
      "纸",
      "芷",
      "藢",
      "衹",
      "襧",
      "訨",
      "趾",
      "軹",
      "轵",
      "酯",
      "阯",
      "黹"
    ],
    píng: [
      "凭",
      "凴",
      "呯",
      "坪",
      "塀",
      "岼",
      "帡",
      "帲",
      "幈",
      "平",
      "慿",
      "憑",
      "枰",
      "洴",
      "焩",
      "玶",
      "瓶",
      "甁",
      "竮",
      "箳",
      "簈",
      "缾",
      "荓",
      "萍",
      "蓱",
      "蚲",
      "蛢",
      "評",
      "评",
      "軿",
      "輧",
      "郱",
      "鮃",
      "鲆"
    ],
    kǎi: [
      "凯",
      "凱",
      "剀",
      "剴",
      "垲",
      "塏",
      "恺",
      "愷",
      "慨",
      "暟",
      "蒈",
      "輆",
      "鍇",
      "鎧",
      "铠",
      "锴",
      "闓",
      "闿",
      "颽"
    ],
    gān: [
      "凲",
      "坩",
      "尲",
      "尴",
      "尶",
      "尷",
      "柑",
      "泔",
      "漧",
      "玕",
      "甘",
      "疳",
      "矸",
      "竿",
      "筸",
      "粓",
      "肝",
      "苷",
      "迀",
      "酐",
      "魐"
    ],
    "kǎn qiǎn": ["凵"],
    tū: [
      "凸",
      "堗",
      "嶀",
      "捸",
      "涋",
      "湥",
      "痜",
      "禿",
      "秃",
      "突",
      "葖",
      "鋵",
      "鵚",
      "鼵",
      "㻬"
    ],
    "āo wā": ["凹"],
    chū: ["出", "初", "岀", "摴", "榋", "樗", "貙", "齣", "䢺", "䝙"],
    dàng: [
      "凼",
      "圵",
      "垱",
      "壋",
      "档",
      "檔",
      "氹",
      "璗",
      "瓽",
      "盪",
      "瞊",
      "砀",
      "碭",
      "礑",
      "簜",
      "荡",
      "菪",
      "蕩",
      "蘯",
      "趤",
      "逿",
      "雼",
      "𬍡"
    ],
    hán: [
      "函",
      "凾",
      "含",
      "圅",
      "娢",
      "寒",
      "崡",
      "晗",
      "梒",
      "浛",
      "涵",
      "澏",
      "焓",
      "琀",
      "甝",
      "筨",
      "蜬",
      "邗",
      "邯",
      "鋡",
      "韓",
      "韩"
    ],
    záo: ["凿", "鑿"],
    dāo: ["刀", "刂", "忉", "氘", "舠", "螩", "釖", "魛", "鱽"],
    chuāng: ["刅", "摐", "牎", "牕", "疮", "瘡", "窓", "窗", "窻"],
    "fēn fèn": ["分"],
    "qiè qiē": ["切"],
    kān: ["刊", "勘", "堪", "戡", "栞", "龕", "龛"],
    cǔn: ["刌", "忖"],
    chú: [
      "刍",
      "厨",
      "幮",
      "廚",
      "橱",
      "櫉",
      "櫥",
      "滁",
      "犓",
      "篨",
      "耡",
      "芻",
      "蒢",
      "蒭",
      "蜍",
      "蟵",
      "豠",
      "趎",
      "蹰",
      "躇",
      "躕",
      "鉏",
      "鋤",
      "锄",
      "除",
      "雏",
      "雛",
      "鶵"
    ],
    "huà huá": ["划"],
    lí: [
      "刕",
      "剓",
      "剺",
      "劙",
      "厘",
      "喱",
      "嚟",
      "囄",
      "嫠",
      "孷",
      "廲",
      "悡",
      "梨",
      "梸",
      "棃",
      "漓",
      "灕",
      "犁",
      "犂",
      "狸",
      "琍",
      "璃",
      "瓈",
      "盠",
      "睝",
      "离",
      "穲",
      "竰",
      "筣",
      "篱",
      "籬",
      "糎",
      "縭",
      "缡",
      "罹",
      "艃",
      "荲",
      "菞",
      "蓠",
      "蔾",
      "藜",
      "蘺",
      "蜊",
      "蟍",
      "蟸",
      "蠫",
      "褵",
      "謧",
      "貍",
      "醨",
      "鋫",
      "錅",
      "鏫",
      "鑗",
      "離",
      "驪",
      "骊",
      "鯏",
      "鯬",
      "鱺",
      "鲡",
      "鵹",
      "鸝",
      "鹂",
      "黎",
      "黧",
      "㰀"
    ],
    yuè: [
      "刖",
      "嬳",
      "岄",
      "岳",
      "嶽",
      "恱",
      "悅",
      "悦",
      "戉",
      "抈",
      "捳",
      "月",
      "樾",
      "瀹",
      "爚",
      "玥",
      "礿",
      "禴",
      "篗",
      "籆",
      "籥",
      "籰",
      "粤",
      "粵",
      "蘥",
      "蚎",
      "蚏",
      "説",
      "越",
      "跀",
      "跃",
      "躍",
      "軏",
      "鈅",
      "鉞",
      "鑰",
      "钺",
      "閱",
      "閲",
      "阅",
      "鸑",
      "鸙",
      "黦",
      "龠",
      "𫐄",
      "𬸚"
    ],
    liú: [
      "刘",
      "劉",
      "嚠",
      "媹",
      "嵧",
      "旈",
      "旒",
      "榴",
      "橊",
      "流",
      "浏",
      "瀏",
      "琉",
      "瑠",
      "瑬",
      "璢",
      "畄",
      "留",
      "畱",
      "疁",
      "瘤",
      "癅",
      "硫",
      "蒥",
      "蓅",
      "蟉",
      "裗",
      "鎏",
      "鏐",
      "鐂",
      "镠",
      "飀",
      "飅",
      "飗",
      "駠",
      "駵",
      "騮",
      "驑",
      "骝",
      "鰡",
      "鶹",
      "鹠",
      "麍"
    ],
    zé: [
      "则",
      "則",
      "啧",
      "嘖",
      "嫧",
      "帻",
      "幘",
      "択",
      "樍",
      "歵",
      "沢",
      "泎",
      "溭",
      "皟",
      "瞔",
      "矠",
      "礋",
      "箦",
      "簀",
      "舴",
      "蔶",
      "蠌",
      "襗",
      "謮",
      "賾",
      "赜",
      "迮",
      "鸅",
      "齚",
      "齰"
    ],
    "chuàng chuāng": ["创", "創"],
    qù: ["刞", "厺", "去", "閴", "闃", "阒", "麮", "鼁"],
    "bié biè": ["別", "别"],
    "páo bào": ["刨"],
    "chǎn chàn": ["刬", "剗", "幝"],
    guā: [
      "刮",
      "劀",
      "桰",
      "歄",
      "煱",
      "瓜",
      "胍",
      "踻",
      "颪",
      "颳",
      "騧",
      "鴰",
      "鸹"
    ],
    gēng: [
      "刯",
      "庚",
      "椩",
      "浭",
      "焿",
      "畊",
      "絚",
      "羮",
      "羹",
      "耕",
      "菮",
      "賡",
      "赓",
      "鶊",
      "鹒"
    ],
    dào: [
      "到",
      "噵",
      "悼",
      "椡",
      "檤",
      "燾",
      "瓙",
      "盗",
      "盜",
      "稲",
      "稻",
      "纛",
      "翿",
      "艔",
      "菿",
      "衜",
      "衟",
      "軇",
      "道"
    ],
    chuàng: ["刱", "剏", "剙", "怆", "愴"],
    kū: ["刳", "哭", "圐", "堀", "枯", "桍", "矻", "窟", "跍", "郀", "骷", "鮬"],
    duò: [
      "刴",
      "剁",
      "墯",
      "尮",
      "惰",
      "憜",
      "挅",
      "桗",
      "舵",
      "跥",
      "跺",
      "陊",
      "陏",
      "飿",
      "饳",
      "鵽"
    ],
    "shuā shuà": ["刷"],
    "quàn xuàn": ["券"],
    "chà shā": ["刹", "剎"],
    "cì cī": ["刺"],
    guì: [
      "刽",
      "刿",
      "劊",
      "劌",
      "撌",
      "攰",
      "昋",
      "桂",
      "椢",
      "槶",
      "樻",
      "櫃",
      "猤",
      "禬",
      "筀",
      "蓕",
      "襘",
      "貴",
      "贵",
      "跪",
      "鐀",
      "鑎",
      "鞼",
      "鱖",
      "鱥"
    ],
    lóu: [
      "剅",
      "娄",
      "婁",
      "廔",
      "楼",
      "樓",
      "溇",
      "漊",
      "熡",
      "耧",
      "耬",
      "艛",
      "蒌",
      "蔞",
      "蝼",
      "螻",
      "謱",
      "軁",
      "遱",
      "鞻",
      "髅",
      "髏",
      "𪣻"
    ],
    cuò: [
      "剉",
      "剒",
      "厝",
      "夎",
      "挫",
      "措",
      "棤",
      "莝",
      "莡",
      "蓌",
      "逪",
      "銼",
      "錯",
      "锉",
      "错"
    ],
    "xiāo xuē": ["削"],
    "kēi kè": ["剋", "尅"],
    "là lá": ["剌"],
    tī: ["剔", "梯", "踢", "銻", "锑", "鷈", "鷉", "䏲", "䴘"],
    pōu: ["剖"],
    wān: ["剜", "塆", "壪", "帵", "弯", "彎", "湾", "潫", "灣", "睕", "蜿", "豌"],
    "bāo bō": ["剝", "剥"],
    duō: ["剟", "咄", "哆", "嚉", "多", "夛", "掇", "毲", "畓", "裰", "㙍"],
    qíng: [
      "剠",
      "勍",
      "夝",
      "情",
      "擎",
      "晴",
      "暒",
      "棾",
      "樈",
      "檠",
      "氰",
      "甠",
      "硘",
      "葝",
      "黥"
    ],
    "yǎn shàn": ["剡"],
    "dū zhuó": ["剢"],
    yān: [
      "剦",
      "嫣",
      "崦",
      "嶖",
      "恹",
      "懕",
      "懨",
      "樮",
      "淊",
      "淹",
      "漹",
      "烟",
      "焉",
      "焑",
      "煙",
      "珚",
      "篶",
      "胭",
      "臙",
      "菸",
      "鄢",
      "醃",
      "閹",
      "阉",
      "黫"
    ],
    huō: ["剨", "劐", "吙", "攉", "秴", "耠", "锪", "騞", "𬴃"],
    shèng: [
      "剩",
      "剰",
      "勝",
      "圣",
      "墭",
      "嵊",
      "晠",
      "榺",
      "橳",
      "琞",
      "聖",
      "蕂",
      "貹",
      "賸"
    ],
    "duān zhì": ["剬"],
    wū: [
      "剭",
      "呜",
      "嗚",
      "圬",
      "屋",
      "巫",
      "弙",
      "杇",
      "歍",
      "汙",
      "汚",
      "污",
      "洿",
      "烏",
      "窏",
      "箼",
      "螐",
      "誈",
      "誣",
      "诬",
      "邬",
      "鄔",
      "鎢",
      "钨",
      "鰞",
      "鴮"
    ],
    gē: [
      "割",
      "哥",
      "圪",
      "彁",
      "戈",
      "戓",
      "戨",
      "歌",
      "滒",
      "犵",
      "肐",
      "袼",
      "謌",
      "鎶",
      "鴚",
      "鴿",
      "鸽"
    ],
    "dá zhá": ["剳"],
    chuán: ["剶", "暷", "椽", "篅", "舡", "舩", "船", "輲", "遄"],
    "tuán zhuān": ["剸", "漙", "篿"],
    "lù jiū": ["剹"],
    pēng: ["剻", "匉", "嘭", "怦", "恲", "抨", "梈", "烹", "砰", "軯", "駍"],
    piāo: ["剽", "勡", "慓", "旚", "犥", "翲", "螵", "飃", "飄", "飘", "魒"],
    kōu: ["剾", "彄", "抠", "摳", "眍", "瞘", "芤", "𫸩"],
    "jiǎo chāo": ["剿", "劋", "勦", "摷"],
    qiāo: [
      "劁",
      "勪",
      "墝",
      "幧",
      "敲",
      "橇",
      "毃",
      "燆",
      "硗",
      "磽",
      "繑",
      "趬",
      "跷",
      "踍",
      "蹺",
      "蹻",
      "郻",
      "鄡",
      "鄥",
      "鍫",
      "鍬",
      "鐰",
      "锹",
      "頝"
    ],
    "huá huà": ["劃"],
    "zhā zhá": ["劄"],
    "pī pǐ": ["劈", "悂"],
    tāng: ["劏", "嘡", "羰", "薚", "蝪", "蹚", "鞺", "鼞"],
    chán: [
      "劖",
      "嚵",
      "壥",
      "婵",
      "嬋",
      "巉",
      "廛",
      "棎",
      "毚",
      "湹",
      "潹",
      "潺",
      "澶",
      "瀍",
      "瀺",
      "煘",
      "獑",
      "磛",
      "緾",
      "纏",
      "纒",
      "缠",
      "艬",
      "蝉",
      "蟐",
      "蟬",
      "蟾",
      "誗",
      "讒",
      "谗",
      "躔",
      "鄽",
      "酁",
      "鋋",
      "鑱",
      "镵",
      "饞",
      "馋"
    ],
    zuān: ["劗", "躜", "躦", "鉆", "鑚"],
    mó: [
      "劘",
      "嫫",
      "嬤",
      "嬷",
      "尛",
      "摹",
      "擵",
      "橅",
      "糢",
      "膜",
      "藦",
      "蘑",
      "謨",
      "謩",
      "谟",
      "饃",
      "饝",
      "馍",
      "髍",
      "魔",
      "魹"
    ],
    zhú: [
      "劚",
      "斸",
      "曯",
      "欘",
      "灟",
      "炢",
      "烛",
      "燭",
      "爥",
      "瘃",
      "竹",
      "笁",
      "笜",
      "舳",
      "茿",
      "蓫",
      "蠋",
      "蠾",
      "躅",
      "逐",
      "逫",
      "钃",
      "鱁"
    ],
    quàn: ["劝", "勧", "勸", "牶", "韏"],
    "jìn jìng": ["劤", "劲", "勁"],
    kēng: ["劥", "坑", "牼", "硁", "硜", "誙", "銵", "鍞", "鏗", "铿", "阬"],
    "xié liè": ["劦"],
    "zhù chú": ["助"],
    nǔ: ["努", "弩", "砮", "胬"],
    shào: ["劭", "卲", "哨", "潲", "紹", "綤", "绍", "袑", "邵"],
    miǎo: ["劰", "杪", "淼", "渺", "眇", "秒", "篎", "緲", "缈", "藐", "邈"],
    kǒu: ["劶", "口"],
    wā: [
      "劸",
      "娲",
      "媧",
      "屲",
      "挖",
      "攨",
      "洼",
      "溛",
      "漥",
      "瓾",
      "畖",
      "穵",
      "窊",
      "窪",
      "蛙",
      "韈",
      "鼃"
    ],
    kuāng: [
      "劻",
      "匡",
      "匩",
      "哐",
      "恇",
      "洭",
      "筐",
      "筺",
      "誆",
      "诓",
      "軭",
      "邼"
    ],
    hé: [
      "劾",
      "咊",
      "啝",
      "姀",
      "峆",
      "敆",
      "曷",
      "柇",
      "楁",
      "毼",
      "河",
      "涸",
      "渮",
      "澕",
      "熆",
      "皬",
      "盇",
      "盉",
      "盍",
      "盒",
      "禾",
      "篕",
      "籺",
      "粭",
      "翮",
      "菏",
      "萂",
      "覈",
      "訸",
      "詥",
      "郃",
      "釛",
      "鉌",
      "鑉",
      "閡",
      "闔",
      "阂",
      "阖",
      "鞨",
      "頜",
      "餄",
      "饸",
      "魺",
      "鹖",
      "麧",
      "齕",
      "龁",
      "龢",
      "𬌗"
    ],
    gào: [
      "勂",
      "吿",
      "告",
      "峼",
      "祮",
      "祰",
      "禞",
      "筶",
      "誥",
      "诰",
      "郜",
      "鋯",
      "锆"
    ],
    "bó bèi": ["勃"],
    láng: [
      "勆",
      "嫏",
      "廊",
      "斏",
      "桹",
      "榔",
      "樃",
      "欴",
      "狼",
      "琅",
      "瑯",
      "硠",
      "稂",
      "艆",
      "蓈",
      "蜋",
      "螂",
      "躴",
      "郒",
      "郞",
      "鋃",
      "鎯",
      "锒"
    ],
    xūn: [
      "勋",
      "勛",
      "勲",
      "勳",
      "嚑",
      "坃",
      "埙",
      "塤",
      "壎",
      "壦",
      "曛",
      "燻",
      "獯",
      "矄",
      "纁",
      "臐",
      "薫",
      "薰",
      "蘍",
      "醺",
      "𫄸"
    ],
    "juàn juān": ["勌", "瓹"],
    "lè lēi": ["勒"],
    kài: ["勓", "炌", "烗", "鎎"],
    "wěng yǎng": ["勜"],
    qín: [
      "勤",
      "嗪",
      "噙",
      "嶜",
      "庈",
      "懃",
      "懄",
      "捦",
      "擒",
      "斳",
      "檎",
      "澿",
      "珡",
      "琴",
      "琹",
      "瘽",
      "禽",
      "秦",
      "耹",
      "芩",
      "芹",
      "菦",
      "螓",
      "蠄",
      "鈙",
      "鈫",
      "雂",
      "靲",
      "鳹",
      "鵭"
    ],
    jiàng: [
      "勥",
      "匞",
      "匠",
      "嵹",
      "弜",
      "弶",
      "摾",
      "櫤",
      "洚",
      "滰",
      "犟",
      "糡",
      "糨",
      "絳",
      "绛",
      "謽",
      "酱",
      "醤",
      "醬"
    ],
    fān: [
      "勫",
      "嬏",
      "帆",
      "幡",
      "忛",
      "憣",
      "旙",
      "旛",
      "繙",
      "翻",
      "藩",
      "轓",
      "颿",
      "飜",
      "鱕"
    ],
    juān: ["勬", "姢", "娟", "捐", "涓", "蠲", "裐", "鎸", "鐫", "镌", "鹃"],
    "tóng dòng": ["勭", "烔", "燑", "狪"],
    lǜ: [
      "勴",
      "垏",
      "嵂",
      "律",
      "慮",
      "氯",
      "滤",
      "濾",
      "爈",
      "箻",
      "綠",
      "繂",
      "膟",
      "葎",
      "虑",
      "鑢"
    ],
    chè: [
      "勶",
      "坼",
      "彻",
      "徹",
      "掣",
      "撤",
      "澈",
      "烢",
      "爡",
      "瞮",
      "硩",
      "聅",
      "迠",
      "頙",
      "㬚"
    ],
    sháo: ["勺", "玿", "韶"],
    "gōu gòu": ["勾"],
    cōng: [
      "匆",
      "囪",
      "囱",
      "忩",
      "怱",
      "悤",
      "暰",
      "樬",
      "漗",
      "瑽",
      "璁",
      "瞛",
      "篵",
      "繱",
      "聡",
      "聦",
      "聪",
      "聰",
      "苁",
      "茐",
      "葱",
      "蓯",
      "蔥",
      "蟌",
      "鍯",
      "鏓",
      "鏦",
      "騘",
      "驄",
      "骢"
    ],
    "táo yáo": ["匋", "陶"],
    páo: ["匏", "咆", "垉", "庖", "爮", "狍", "袍", "褜", "軳", "鞄", "麅"],
    dá: [
      "匒",
      "妲",
      "怛",
      "炟",
      "燵",
      "畣",
      "笪",
      "羍",
      "荙",
      "薘",
      "蟽",
      "詚",
      "达",
      "迏",
      "迖",
      "迚",
      "逹",
      "達",
      "鐽",
      "靼",
      "鞑",
      "韃",
      "龖",
      "龘",
      "𫟼"
    ],
    "huà huā": ["化"],
    "běi bèi": ["北"],
    nǎo: ["匘", "垴", "堖", "嫐", "恼", "悩", "惱", "瑙", "碯", "脑", "脳", "腦"],
    "chí shi": ["匙"],
    fāng: ["匚", "堏", "方", "淓", "牥", "芳", "邡", "鈁", "錺", "钫", "鴋"],
    zā: ["匝", "咂", "帀", "沞", "臜", "臢", "迊", "鉔", "魳"],
    qiè: [
      "匧",
      "厒",
      "妾",
      "怯",
      "悏",
      "惬",
      "愜",
      "挈",
      "穕",
      "窃",
      "竊",
      "笡",
      "箧",
      "篋",
      "籡",
      "踥",
      "鍥",
      "锲",
      "鯜"
    ],
    "zāng cáng": ["匨"],
    fěi: ["匪", "奜", "悱", "棐", "榧", "篚", "翡", "蕜", "誹", "诽"],
    "kuì guì": ["匮", "匱"],
    suǎn: ["匴"],
    pǐ: ["匹", "噽", "嚭", "圮", "庀", "痞", "癖", "脴", "苉", "銢", "鴄"],
    "qū ōu": ["区", "區"],
    "kē qià": ["匼"],
    "yǎn yàn": ["匽", "棪"],
    biǎn: ["匾", "惼", "揙", "碥", "稨", "窆", "藊", "褊", "貶", "贬", "鴘"],
    nì: [
      "匿",
      "堄",
      "嫟",
      "嬺",
      "惄",
      "愵",
      "昵",
      "暱",
      "氼",
      "眤",
      "睨",
      "縌",
      "胒",
      "腻",
      "膩",
      "逆",
      "𨺙"
    ],
    niàn: ["卄", "唸", "埝", "廿", "念", "惗", "艌"],
    sà: ["卅", "櫒", "脎", "萨", "蕯", "薩", "鈒", "隡", "颯", "飒", "馺"],
    zú: ["卆", "哫", "崪", "族", "箤", "足", "踤", "镞"],
    shēng: [
      "升",
      "呏",
      "声",
      "斘",
      "昇",
      "曻",
      "枡",
      "殅",
      "泩",
      "湦",
      "焺",
      "牲",
      "珄",
      "生",
      "甥",
      "竔",
      "笙",
      "聲",
      "鉎",
      "鍟",
      "阩",
      "陞",
      "陹",
      "鵿",
      "鼪"
    ],
    wàn: [
      "卍",
      "卐",
      "忨",
      "杤",
      "瞣",
      "脕",
      "腕",
      "萬",
      "蟃",
      "贎",
      "輐",
      "錽",
      "𬇕"
    ],
    "huá huà huā": ["华", "華"],
    bēi: ["卑", "悲", "揹", "杯", "桮", "盃", "碑", "藣", "鵯", "鹎"],
    "zú cù": ["卒"],
    "dān shàn chán": ["单", "單"],
    "nán nā": ["南"],
    "shuài lǜ": ["卛"],
    "bǔ bo pú": ["卜"],
    "kuàng guàn": ["卝"],
    biàn: [
      "卞",
      "变",
      "変",
      "峅",
      "弁",
      "徧",
      "忭",
      "抃",
      "昪",
      "汳",
      "汴",
      "玣",
      "艑",
      "苄",
      "覍",
      "諚",
      "變",
      "辡",
      "辧",
      "辨",
      "辩",
      "辫",
      "辮",
      "辯",
      "遍",
      "釆",
      "𨚕"
    ],
    bǔ: ["卟", "哺", "捕", "补", "補", "鸔", "𬷕"],
    "zhàn zhān": ["占", "覱"],
    "kǎ qiǎ": ["卡"],
    lú: [
      "卢",
      "嚧",
      "垆",
      "壚",
      "庐",
      "廬",
      "曥",
      "枦",
      "栌",
      "櫨",
      "泸",
      "瀘",
      "炉",
      "爐",
      "獹",
      "玈",
      "瓐",
      "盧",
      "矑",
      "籚",
      "纑",
      "罏",
      "胪",
      "臚",
      "舮",
      "舻",
      "艫",
      "芦",
      "蘆",
      "蠦",
      "轤",
      "轳",
      "鈩",
      "鑪",
      "顱",
      "颅",
      "馿",
      "髗",
      "魲",
      "鱸",
      "鲈",
      "鸕",
      "鸬",
      "黸",
      "𬬻"
    ],
    lǔ: [
      "卤",
      "塷",
      "掳",
      "擄",
      "樐",
      "橹",
      "櫓",
      "氌",
      "滷",
      "澛",
      "瀂",
      "硵",
      "磠",
      "穞",
      "艣",
      "艪",
      "蓾",
      "虏",
      "虜",
      "鏀",
      "鐪",
      "鑥",
      "镥",
      "魯",
      "鲁",
      "鹵"
    ],
    guà: ["卦", "啩", "挂", "掛", "罣", "褂", "詿", "诖"],
    "áng yǎng": ["卬"],
    yìn: [
      "印",
      "垽",
      "堷",
      "廕",
      "慭",
      "憖",
      "憗",
      "懚",
      "洕",
      "湚",
      "猌",
      "癊",
      "胤",
      "茚",
      "酳",
      "鮣",
      "䲟"
    ],
    què: [
      "却",
      "卻",
      "塙",
      "崅",
      "悫",
      "愨",
      "慤",
      "搉",
      "榷",
      "燩",
      "琷",
      "皵",
      "确",
      "確",
      "礭",
      "闋",
      "阕",
      "鵲",
      "鹊",
      "𬒈"
    ],
    luǎn: ["卵"],
    "juàn juǎn": ["卷", "巻"],
    "chǎng ān hàn": ["厂"],
    "wěi yán": ["厃"],
    tīng: [
      "厅",
      "厛",
      "听",
      "庁",
      "廰",
      "廳",
      "汀",
      "烃",
      "烴",
      "綎",
      "耓",
      "聴",
      "聼",
      "聽",
      "鞓",
      "𬘩"
    ],
    "zhé zhái": ["厇"],
    "hàn àn": ["厈", "屽"],
    yǎ: ["厊", "唖", "庌", "痖", "瘂", "蕥"],
    shè: [
      "厍",
      "厙",
      "弽",
      "慑",
      "慴",
      "懾",
      "摂",
      "欇",
      "涉",
      "涻",
      "渉",
      "滠",
      "灄",
      "社",
      "舎",
      "蔎",
      "蠂",
      "設",
      "设",
      "赦",
      "騇",
      "麝"
    ],
    dǐ: [
      "厎",
      "呧",
      "坘",
      "弤",
      "抵",
      "拞",
      "掋",
      "牴",
      "砥",
      "菧",
      "觝",
      "詆",
      "诋",
      "軧",
      "邸",
      "阺",
      "骶",
      "鯳"
    ],
    "zhǎ zhǎi": ["厏"],
    páng: ["厐", "嫎", "庞", "徬", "舽", "螃", "逄", "鰟", "鳑", "龎", "龐"],
    "zhì shī": ["厔"],
    máng: [
      "厖",
      "吂",
      "哤",
      "娏",
      "忙",
      "恾",
      "杗",
      "杧",
      "汒",
      "浝",
      "牻",
      "痝",
      "盲",
      "硭",
      "笀",
      "芒",
      "茫",
      "蘉",
      "邙",
      "釯",
      "鋩",
      "铓",
      "駹"
    ],
    zuī: ["厜", "樶", "纗", "蟕"],
    "shà xià": ["厦", "廈"],
    áo: [
      "厫",
      "嗷",
      "嗸",
      "廒",
      "敖",
      "滶",
      "獒",
      "獓",
      "璈",
      "翱",
      "翶",
      "翺",
      "聱",
      "蔜",
      "螯",
      "謷",
      "謸",
      "遨",
      "鏖",
      "隞",
      "鰲",
      "鳌",
      "鷔",
      "鼇"
    ],
    "lán qiān": ["厱"],
    "sī mǒu": ["厶"],
    "gōng hóng": ["厷"],
    "lín miǎo": ["厸"],
    "qiú róu": ["厹"],
    dū: ["厾", "嘟", "督", "醏"],
    "xiàn xuán": ["县", "縣"],
    "cān shēn cēn sān": ["参", "參", "叄", "叅"],
    "ài yǐ": ["叆"],
    "chā chà chǎ chá": ["叉"],
    shuāng: [
      "双",
      "孀",
      "孇",
      "欆",
      "礵",
      "艭",
      "雙",
      "霜",
      "騻",
      "驦",
      "骦",
      "鷞",
      "鸘",
      "鹴"
    ],
    shōu: ["収", "收"],
    guái: ["叏"],
    bá: [
      "叐",
      "妭",
      "抜",
      "拔",
      "炦",
      "癹",
      "胈",
      "茇",
      "菝",
      "詙",
      "跋",
      "軷",
      "魃",
      "鼥"
    ],
    "fā fà": ["发"],
    "zhuó yǐ lì jué": ["叕"],
    qǔ: ["取", "娶", "竬", "蝺", "詓", "齲", "龋"],
    "jiǎ xiá": ["叚", "徦"],
    "wèi yù": ["叞", "尉", "蔚"],
    dié: [
      "叠",
      "垤",
      "堞",
      "峌",
      "幉",
      "恎",
      "惵",
      "戜",
      "曡",
      "殜",
      "氎",
      "牃",
      "牒",
      "瓞",
      "畳",
      "疂",
      "疉",
      "疊",
      "碟",
      "絰",
      "绖",
      "耊",
      "耋",
      "胅",
      "艓",
      "苵",
      "蜨",
      "蝶",
      "褋",
      "詄",
      "諜",
      "谍",
      "跮",
      "蹀",
      "迭",
      "镻",
      "鰈",
      "鲽",
      "鴩",
      "𫶇"
    ],
    ruì: ["叡", "枘", "汭", "瑞", "睿", "芮", "蚋", "蜹", "銳", "鋭", "锐"],
    "jù gōu": ["句"],
    lìng: ["另", "呤", "炩", "蘦"],
    "dāo dáo tāo": ["叨"],
    "zhī zhǐ": ["只"],
    jiào: [
      "叫",
      "呌",
      "嘂",
      "嘦",
      "噍",
      "嬓",
      "斍",
      "斠",
      "滘",
      "漖",
      "獥",
      "珓",
      "皭",
      "窖",
      "藠",
      "訆",
      "譥",
      "趭",
      "較",
      "轎",
      "轿",
      "较",
      "酵",
      "醮",
      "釂"
    ],
    "zhào shào": ["召"],
    "kě kè": ["可"],
    "tái tāi": ["台", "苔"],
    pǒ: ["叵", "尀", "笸", "箥", "鉕", "钷", "駊"],
    "yè xié": ["叶"],
    "hào háo": ["号"],
    tàn: ["叹", "嘆", "探", "歎", "湠", "炭", "碳", "舕"],
    "hōng hóng": ["叿"],
    miē: ["吀", "咩", "哶", "孭"],
    "xū yū yù": ["吁"],
    chī: [
      "吃",
      "哧",
      "喫",
      "嗤",
      "噄",
      "妛",
      "媸",
      "彨",
      "彲",
      "摛",
      "攡",
      "殦",
      "瓻",
      "痴",
      "癡",
      "眵",
      "瞝",
      "笞",
      "粚",
      "胵",
      "蚩",
      "螭",
      "訵",
      "魑",
      "鴟",
      "鵄",
      "鸱",
      "黐",
      "齝",
      "𫄨"
    ],
    "xuān sòng": ["吅"],
    yāo: [
      "吆",
      "喓",
      "夭",
      "妖",
      "幺",
      "楆",
      "殀",
      "祅",
      "腰",
      "葽",
      "訞",
      "邀",
      "鴁",
      "鴢",
      "㙘"
    ],
    zǐ: [
      "吇",
      "姉",
      "姊",
      "子",
      "杍",
      "梓",
      "榟",
      "橴",
      "滓",
      "矷",
      "秭",
      "笫",
      "籽",
      "紫",
      "耔",
      "虸",
      "訿",
      "釨"
    ],
    "hé gě": ["合", "鲄"],
    "cùn dòu": ["吋"],
    "tóng tòng": ["同"],
    "tǔ tù": ["吐", "唋"],
    "zhà zhā": ["吒", "奓"],
    "xià hè": ["吓"],
    "ā yā": ["吖"],
    "ma má mǎ": ["吗"],
    lìn: [
      "吝",
      "恡",
      "悋",
      "橉",
      "焛",
      "甐",
      "膦",
      "蔺",
      "藺",
      "賃",
      "赁",
      "蹸",
      "躏",
      "躙",
      "躪",
      "轥",
      "閵"
    ],
    tūn: ["吞", "暾", "朜", "焞"],
    "bǐ pǐ": ["吡"],
    qìn: ["吢", "吣", "唚", "抋", "揿", "搇", "撳", "沁", "瀙", "菣", "藽"],
    "jiè gè": ["吤"],
    "fǒu pǐ": ["否"],
    "ba bā": ["吧"],
    dūn: [
      "吨",
      "噸",
      "墩",
      "墪",
      "惇",
      "撉",
      "撴",
      "犜",
      "獤",
      "礅",
      "蜳",
      "蹾",
      "驐"
    ],
    fēn: [
      "吩",
      "帉",
      "昐",
      "朆",
      "梤",
      "棻",
      "氛",
      "竕",
      "紛",
      "纷",
      "翂",
      "芬",
      "衯",
      "訜",
      "躮",
      "酚",
      "鈖",
      "雰",
      "餴",
      "饙",
      "馚"
    ],
    "é huā": ["吪"],
    "kēng háng": ["吭", "妔"],
    shǔn: ["吮"],
    "zhī zī": ["吱"],
    "yǐn shěn": ["吲"],
    wú: [
      "吳",
      "吴",
      "呉",
      "墲",
      "峿",
      "梧",
      "橆",
      "毋",
      "洖",
      "浯",
      "無",
      "珸",
      "璑",
      "祦",
      "芜",
      "茣",
      "莁",
      "蕪",
      "蜈",
      "蟱",
      "譕",
      "郚",
      "鋙",
      "铻",
      "鯃",
      "鵐",
      "鷡",
      "鹀",
      "鼯"
    ],
    "chǎo chāo": ["吵"],
    "nà nè": ["吶"],
    "xuè chuò jué": ["吷"],
    chuī: ["吹", "炊", "龡"],
    "dōu rú": ["吺"],
    hǒu: ["吼", "犼"],
    "hōng hǒu ōu": ["吽"],
    "wú yù": ["吾"],
    "ya yā": ["呀"],
    "è e": ["呃"],
    dāi: ["呆", "懛", "獃"],
    "mèn qǐ": ["呇"],
    hōng: [
      "呍",
      "嚝",
      "揈",
      "灴",
      "烘",
      "焢",
      "硡",
      "薨",
      "訇",
      "谾",
      "軣",
      "輷",
      "轟",
      "轰",
      "鍧"
    ],
    nà: [
      "呐",
      "捺",
      "笝",
      "納",
      "纳",
      "肭",
      "蒳",
      "衲",
      "豽",
      "貀",
      "軜",
      "郍",
      "鈉",
      "钠",
      "靹",
      "魶"
    ],
    "tūn tiān": ["呑"],
    "fǔ ḿ": ["呒", "嘸"],
    "dāi tǎi": ["呔"],
    "ǒu ōu òu": ["呕"],
    "bài bei": ["呗"],
    "yuán yún yùn": ["员", "員"],
    guō: [
      "呙",
      "啯",
      "嘓",
      "埚",
      "堝",
      "墎",
      "崞",
      "彉",
      "彍",
      "懖",
      "猓",
      "瘑",
      "聒",
      "蝈",
      "蟈",
      "郭",
      "鈛",
      "鍋",
      "锅"
    ],
    "huá qì": ["呚"],
    "qiàng qiāng": ["呛", "跄"],
    shī: [
      "呞",
      "失",
      "尸",
      "屍",
      "师",
      "師",
      "施",
      "浉",
      "湤",
      "湿",
      "溮",
      "溼",
      "濕",
      "狮",
      "獅",
      "瑡",
      "絁",
      "葹",
      "蒒",
      "蓍",
      "虱",
      "蝨",
      "褷",
      "襹",
      "詩",
      "诗",
      "邿",
      "釃",
      "鉇",
      "鍦",
      "鯴",
      "鰤",
      "鲺",
      "鳲",
      "鳾",
      "鶳",
      "鸤",
      "䴓",
      "𫚕"
    ],
    juǎn: ["呟", "埍", "臇", "菤", "錈", "锩"],
    pěn: ["呠", "翸"],
    "wěn mǐn": ["呡"],
    "ne ní": ["呢"],
    "ḿ m̀ móu": ["呣"],
    rán: [
      "呥",
      "嘫",
      "然",
      "燃",
      "繎",
      "肰",
      "蚦",
      "蚺",
      "衻",
      "袇",
      "袡",
      "髥",
      "髯"
    ],
    "tiè chè": ["呫"],
    "qì zhī": ["呮"],
    "zǐ cī": ["呰"],
    "guā gū guǎ": ["呱"],
    "cī zī": ["呲"],
    "hǒu xǔ gòu": ["呴"],
    "hē ā á ǎ à a": ["呵"],
    náo: [
      "呶",
      "夒",
      "峱",
      "嶩",
      "巎",
      "挠",
      "撓",
      "猱",
      "硇",
      "蛲",
      "蟯",
      "詉",
      "譊",
      "鐃",
      "铙"
    ],
    "xiā gā": ["呷"],
    pēi: ["呸", "怌", "肧", "胚", "衃", "醅"],
    "háo xiāo": ["呺"],
    mìng: ["命", "掵"],
    "dá dàn": ["呾"],
    "zuǐ jǔ": ["咀"],
    "xián gān": ["咁"],
    pǒu: ["咅", "哣", "犃"],
    "yǎng yāng": ["咉"],
    "zǎ zé zhā": ["咋"],
    "hé hè huó huò hú": ["和"],
    hāi: ["咍"],
    dā: ["咑", "哒", "噠", "墶", "搭", "撘", "耷", "褡", "鎝", "𨱏"],
    "kǎ kā": ["咔"],
    gū: [
      "咕",
      "唂",
      "唃",
      "姑",
      "嫴",
      "孤",
      "巬",
      "巭",
      "柧",
      "橭",
      "沽",
      "泒",
      "稒",
      "笟",
      "箍",
      "箛",
      "篐",
      "罛",
      "苽",
      "菇",
      "菰",
      "蓇",
      "觚",
      "軱",
      "軲",
      "轱",
      "辜",
      "酤",
      "鈲",
      "鮕",
      "鴣",
      "鸪"
    ],
    "kā gā": ["咖"],
    zuo: ["咗"],
    lóng: [
      "咙",
      "嚨",
      "嶐",
      "巃",
      "巄",
      "昽",
      "曨",
      "朧",
      "栊",
      "槞",
      "櫳",
      "湰",
      "滝",
      "漋",
      "爖",
      "珑",
      "瓏",
      "癃",
      "眬",
      "矓",
      "砻",
      "礱",
      "礲",
      "窿",
      "竜",
      "聋",
      "聾",
      "胧",
      "茏",
      "蘢",
      "蠪",
      "蠬",
      "襱",
      "豅",
      "鏧",
      "鑨",
      "霳",
      "靇",
      "驡",
      "鸗",
      "龍",
      "龒",
      "龙"
    ],
    "xiàn xián": ["咞"],
    qì: [
      "咠",
      "唭",
      "噐",
      "器",
      "夡",
      "弃",
      "憇",
      "憩",
      "暣",
      "棄",
      "欫",
      "气",
      "気",
      "氣",
      "汔",
      "汽",
      "泣",
      "湆",
      "湇",
      "炁",
      "甈",
      "盵",
      "矵",
      "碛",
      "碶",
      "磜",
      "磧",
      "罊",
      "芞",
      "葺",
      "藒",
      "蟿",
      "訖",
      "讫",
      "迄",
      "鐑"
    ],
    "xì dié": ["咥"],
    "liē liě lié lie": ["咧"],
    zī: [
      "咨",
      "嗞",
      "姕",
      "姿",
      "孜",
      "孳",
      "孶",
      "崰",
      "嵫",
      "栥",
      "椔",
      "淄",
      "湽",
      "滋",
      "澬",
      "玆",
      "禌",
      "秶",
      "粢",
      "紎",
      "緇",
      "緕",
      "纃",
      "缁",
      "茊",
      "茲",
      "葘",
      "諮",
      "谘",
      "貲",
      "資",
      "赀",
      "资",
      "赼",
      "趑",
      "趦",
      "輜",
      "輺",
      "辎",
      "鄑",
      "鈭",
      "錙",
      "鍿",
      "鎡",
      "锱",
      "镃",
      "頾",
      "頿",
      "髭",
      "鯔",
      "鰦",
      "鲻",
      "鶅",
      "鼒",
      "齍",
      "齜",
      "龇"
    ],
    mī: ["咪"],
    "jī xī qià": ["咭"],
    "gē luò kǎ lo": ["咯"],
    "shù xún": ["咰"],
    "zán zá zǎ zan": ["咱"],
    "hāi ké": ["咳"],
    huī: [
      "咴",
      "噅",
      "噕",
      "婎",
      "媈",
      "幑",
      "徽",
      "恢",
      "拻",
      "挥",
      "揮",
      "晖",
      "暉",
      "楎",
      "洃",
      "瀈",
      "灰",
      "灳",
      "烣",
      "睳",
      "禈",
      "翚",
      "翬",
      "蘳",
      "袆",
      "褘",
      "詼",
      "诙",
      "豗",
      "輝",
      "辉",
      "鰴",
      "麾",
      "㧑"
    ],
    "huài shì": ["咶"],
    táo: [
      "咷",
      "啕",
      "桃",
      "檮",
      "洮",
      "淘",
      "祹",
      "綯",
      "绹",
      "萄",
      "蜪",
      "裪",
      "迯",
      "逃",
      "醄",
      "鋾",
      "鞀",
      "鞉",
      "饀",
      "駣",
      "騊",
      "鼗",
      "𫘦"
    ],
    xián: [
      "咸",
      "啣",
      "娴",
      "娹",
      "婱",
      "嫌",
      "嫺",
      "嫻",
      "弦",
      "挦",
      "撏",
      "涎",
      "湺",
      "澖",
      "甉",
      "痫",
      "癇",
      "癎",
      "絃",
      "胘",
      "舷",
      "藖",
      "蚿",
      "蛝",
      "衔",
      "衘",
      "誸",
      "諴",
      "賢",
      "贒",
      "贤",
      "輱",
      "醎",
      "銜",
      "鑦",
      "閑",
      "闲",
      "鷳",
      "鷴",
      "鷼",
      "鹇",
      "鹹",
      "麙",
      "𫍯"
    ],
    "è àn": ["咹"],
    "xuān xuǎn": ["咺", "烜"],
    "wāi hé wǒ guǎ guō": ["咼"],
    "yàn yè yān": ["咽"],
    āi: ["哀", "哎", "埃", "溾", "銰", "鎄", "锿"],
    pǐn: ["品", "榀"],
    shěn: [
      "哂",
      "婶",
      "嬸",
      "审",
      "宷",
      "審",
      "弞",
      "曋",
      "渖",
      "瀋",
      "瞫",
      "矤",
      "矧",
      "覾",
      "訠",
      "諗",
      "讅",
      "谂",
      "谉",
      "邥",
      "頣",
      "魫"
    ],
    "hǒng hōng hòng": ["哄"],
    "wā wa": ["哇"],
    "hā hǎ hà": ["哈"],
    zāi: ["哉", "栽", "渽", "溨", "災", "灾", "烖", "睵", "賳"],
    "dì diè": ["哋"],
    pài: ["哌", "沠", "派", "渒", "湃", "蒎", "鎃"],
    "gén hěn": ["哏"],
    "yǎ yā": ["哑", "雅"],
    "yuě huì": ["哕", "噦"],
    nián: ["哖", "年", "秊", "秥", "鮎", "鯰", "鲇", "鲶", "鵇", "黏"],
    "huá huā": ["哗", "嘩"],
    "jì jiē zhāi": ["哜", "嚌"],
    mōu: ["哞"],
    "yō yo": ["哟", "喲"],
    lòng: ["哢", "梇", "贚"],
    "ò ó é": ["哦"],
    "lī lǐ li": ["哩"],
    "nǎ na nǎi né něi": ["哪"],
    hè: [
      "哬",
      "垎",
      "壑",
      "寉",
      "惒",
      "焃",
      "煂",
      "燺",
      "爀",
      "癋",
      "碋",
      "翯",
      "褐",
      "謞",
      "賀",
      "贺",
      "赫",
      "靍",
      "靎",
      "靏",
      "鶴",
      "鸖",
      "鹤"
    ],
    "bō pò bā": ["哱"],
    zhé: [
      "哲",
      "啠",
      "喆",
      "嚞",
      "埑",
      "悊",
      "摺",
      "晢",
      "晣",
      "歽",
      "矺",
      "砓",
      "磔",
      "籷",
      "粍",
      "虴",
      "蛰",
      "蟄",
      "袩",
      "詟",
      "謫",
      "謺",
      "讁",
      "讋",
      "谪",
      "輒",
      "輙",
      "轍",
      "辄",
      "辙",
      "鮿"
    ],
    "liàng láng": ["哴"],
    "liè lǜ": ["哷"],
    hān: ["哻", "憨", "蚶", "谽", "酣", "頇", "顸", "馠", "魽", "鼾"],
    "hēng hng": ["哼"],
    gěng: [
      "哽",
      "埂",
      "峺",
      "挭",
      "梗",
      "綆",
      "绠",
      "耿",
      "莄",
      "郠",
      "骾",
      "鯁",
      "鲠",
      "𬒔"
    ],
    "chuò yuè": ["哾"],
    "gě jiā": ["哿"],
    "bei bài": ["唄"],
    "hán hàn": ["唅"],
    chún: [
      "唇",
      "浱",
      "湻",
      "滣",
      "漘",
      "犉",
      "純",
      "纯",
      "脣",
      "莼",
      "蒓",
      "蓴",
      "醇",
      "醕",
      "錞",
      "陙",
      "鯙",
      "鶉",
      "鹑",
      "𬭚"
    ],
    "ài āi": ["唉"],
    "jiá qiǎn": ["唊"],
    "yán dàn xián": ["唌"],
    chē: ["唓", "砗", "硨", "莗", "蛼"],
    "wú ńg ń": ["唔"],
    zào: [
      "唕",
      "唣",
      "噪",
      "慥",
      "梍",
      "灶",
      "煰",
      "燥",
      "皁",
      "皂",
      "竃",
      "竈",
      "簉",
      "艁",
      "譟",
      "趮",
      "躁",
      "造",
      "𥖨"
    ],
    dí: [
      "唙",
      "啇",
      "嘀",
      "嚁",
      "嫡",
      "廸",
      "敌",
      "敵",
      "梑",
      "涤",
      "滌",
      "狄",
      "笛",
      "籴",
      "糴",
      "苖",
      "荻",
      "蔋",
      "蔐",
      "藡",
      "覿",
      "觌",
      "豴",
      "迪",
      "靮",
      "頔",
      "馰",
      "髢",
      "鸐",
      "𬱖"
    ],
    "gòng hǒng gǒng": ["唝", "嗊"],
    dóu: ["唞"],
    "lào láo": ["唠", "嘮", "憦"],
    huàn: [
      "唤",
      "喚",
      "奂",
      "奐",
      "宦",
      "嵈",
      "幻",
      "患",
      "愌",
      "换",
      "換",
      "擐",
      "攌",
      "梙",
      "槵",
      "浣",
      "涣",
      "渙",
      "漶",
      "澣",
      "烉",
      "焕",
      "煥",
      "瑍",
      "痪",
      "瘓",
      "睆",
      "肒",
      "藧",
      "豢",
      "轘",
      "逭",
      "鯇",
      "鯶",
      "鰀",
      "鲩"
    ],
    léng: ["唥", "塄", "楞", "碐", "薐"],
    "wō wěi": ["唩"],
    fěng: ["唪", "覂", "諷", "讽"],
    "yín jìn": ["唫"],
    "hǔ xià": ["唬"],
    wéi: [
      "唯",
      "围",
      "圍",
      "壝",
      "峗",
      "峞",
      "嵬",
      "帏",
      "帷",
      "幃",
      "惟",
      "桅",
      "沩",
      "洈",
      "涠",
      "湋",
      "溈",
      "潍",
      "潙",
      "潿",
      "濰",
      "犩",
      "矀",
      "維",
      "维",
      "蓶",
      "覹",
      "违",
      "違",
      "鄬",
      "醀",
      "鍏",
      "闈",
      "闱",
      "韋",
      "韦",
      "鮠",
      "𣲗",
      "𬶏"
    ],
    shuā: ["唰"],
    chàng: ["唱", "怅", "悵", "暢", "焻", "畅", "畼", "誯", "韔", "鬯"],
    "ér wā": ["唲"],
    qiàng: ["唴", "炝", "熗", "羻"],
    yō: ["唷"],
    yū: ["唹", "淤", "瘀", "盓", "箊", "紆", "纡", "込", "迂", "迃", "陓"],
    lài: [
      "唻",
      "濑",
      "瀨",
      "瀬",
      "癞",
      "癩",
      "睐",
      "睞",
      "籁",
      "籟",
      "藾",
      "賚",
      "賴",
      "赉",
      "赖",
      "頼",
      "顂",
      "鵣"
    ],
    tuò: ["唾", "嶞", "柝", "毤", "毻", "箨", "籜", "萚", "蘀", "跅"],
    "zhōu zhāo tiào": ["啁"],
    kěn: ["啃", "垦", "墾", "恳", "懇", "肎", "肯", "肻", "豤", "錹"],
    "zhuó zhào": ["啅", "濯"],
    "hēng hèng": ["啈", "悙"],
    "lín lán": ["啉"],
    "a ā á ǎ à": ["啊"],
    qiāng: [
      "啌",
      "嗴",
      "嶈",
      "戕",
      "摤",
      "斨",
      "枪",
      "槍",
      "溬",
      "牄",
      "猐",
      "獇",
      "羌",
      "羗",
      "腔",
      "蜣",
      "謒",
      "鏘",
      "锖",
      "锵"
    ],
    "tūn zhūn xiāng duǐ": ["啍"],
    wèn: ["問", "妏", "揾", "搵", "璺", "问", "顐"],
    "cuì qi": ["啐"],
    "dié shà jié tì": ["啑"],
    "yuē wā": ["啘"],
    "zǐ cǐ": ["啙"],
    "bǐ tú": ["啚"],
    "chuò chuài": ["啜"],
    "yǎ yā è": ["啞"],
    fēi: [
      "啡",
      "婓",
      "婔",
      "扉",
      "暃",
      "渄",
      "猆",
      "緋",
      "绯",
      "裶",
      "霏",
      "非",
      "靟",
      "飛",
      "飝",
      "飞",
      "餥",
      "馡",
      "騑",
      "騛",
      "鯡",
      "鲱",
      "𬴂"
    ],
    pí: [
      "啤",
      "壀",
      "枇",
      "毗",
      "毘",
      "焷",
      "琵",
      "疲",
      "皮",
      "篺",
      "罴",
      "羆",
      "脾",
      "腗",
      "膍",
      "蚍",
      "蚽",
      "蜱",
      "螷",
      "蠯",
      "豼",
      "貔",
      "郫",
      "鈹",
      "阰",
      "陴",
      "隦",
      "魮",
      "鮍",
      "鲏",
      "鵧",
      "鼙"
    ],
    shá: ["啥"],
    "lā la": ["啦"],
    "yīng qíng": ["啨"],
    pā: ["啪", "妑", "舥", "葩", "趴"],
    "zhě shì": ["啫"],
    sè: [
      "啬",
      "嗇",
      "懎",
      "擌",
      "栜",
      "歮",
      "涩",
      "渋",
      "澀",
      "澁",
      "濇",
      "濏",
      "瀒",
      "瑟",
      "璱",
      "瘷",
      "穑",
      "穡",
      "穯",
      "繬",
      "譅",
      "轖",
      "銫",
      "鏼",
      "铯",
      "飋"
    ],
    niè: [
      "啮",
      "嗫",
      "噛",
      "嚙",
      "囁",
      "囓",
      "圼",
      "孼",
      "孽",
      "嵲",
      "嶭",
      "巕",
      "帇",
      "敜",
      "枿",
      "槷",
      "櫱",
      "涅",
      "湼",
      "痆",
      "篞",
      "籋",
      "糱",
      "糵",
      "聂",
      "聶",
      "臬",
      "臲",
      "蘖",
      "蠥",
      "讘",
      "踂",
      "踗",
      "踙",
      "蹑",
      "躡",
      "錜",
      "鎳",
      "鑈",
      "鑷",
      "钀",
      "镊",
      "镍",
      "闑",
      "陧",
      "隉",
      "顳",
      "颞",
      "齧",
      "𫔶"
    ],
    "luō luó luo": ["啰", "囉"],
    "tān chǎn tuō": ["啴"],
    bo: ["啵", "蔔"],
    dìng: [
      "啶",
      "定",
      "椗",
      "矴",
      "碇",
      "碠",
      "磸",
      "聢",
      "腚",
      "萣",
      "蝊",
      "訂",
      "订",
      "錠",
      "锭",
      "顁",
      "飣",
      "饤"
    ],
    lāng: ["啷"],
    "án ān": ["啽"],
    kā: ["喀", "擖"],
    "yóng yú": ["喁"],
    "lā lá lǎ": ["喇"],
    jiē: [
      "喈",
      "喼",
      "嗟",
      "堦",
      "媘",
      "接",
      "掲",
      "擑",
      "湝",
      "煯",
      "疖",
      "痎",
      "癤",
      "皆",
      "秸",
      "稭",
      "脻",
      "蝔",
      "街",
      "謯",
      "阶",
      "階",
      "鞂",
      "鶛"
    ],
    hóu: [
      "喉",
      "帿",
      "猴",
      "瘊",
      "睺",
      "篌",
      "糇",
      "翭",
      "葔",
      "鄇",
      "鍭",
      "餱",
      "骺",
      "鯸",
      "𬭤"
    ],
    "dié zhá": ["喋"],
    wāi: ["喎", "歪", "竵"],
    "nuò rě": ["喏"],
    "xù huò guó": ["喐"],
    zán: ["喒"],
    "wō ō": ["喔"],
    hú: [
      "喖",
      "嘝",
      "囫",
      "壶",
      "壷",
      "壺",
      "媩",
      "弧",
      "搰",
      "斛",
      "楜",
      "槲",
      "湖",
      "瀫",
      "焀",
      "煳",
      "狐",
      "猢",
      "瑚",
      "瓳",
      "箶",
      "絗",
      "縠",
      "胡",
      "葫",
      "蔛",
      "蝴",
      "螜",
      "衚",
      "觳",
      "醐",
      "鍸",
      "頶",
      "餬",
      "鬍",
      "魱",
      "鰗",
      "鵠",
      "鶘",
      "鶦",
      "鹕"
    ],
    "huàn yuán xuǎn hé": ["喛"],
    xǐ: [
      "喜",
      "囍",
      "壐",
      "屣",
      "徙",
      "憙",
      "枲",
      "橲",
      "歖",
      "漇",
      "玺",
      "璽",
      "矖",
      "禧",
      "縰",
      "葈",
      "葸",
      "蓰",
      "蟢",
      "謑",
      "蹝",
      "躧",
      "鈢",
      "鉨",
      "鉩",
      "鱚",
      "𬭳",
      "𬶮"
    ],
    "hē hè yè": ["喝"],
    kuì: [
      "喟",
      "嘳",
      "媿",
      "嬇",
      "愦",
      "愧",
      "憒",
      "篑",
      "簣",
      "籄",
      "聩",
      "聭",
      "聵",
      "膭",
      "蕢",
      "謉",
      "餽",
      "饋",
      "馈"
    ],
    "zhǒng chuáng": ["喠"],
    "wéi wèi": ["喡", "為", "爲"],
    "duó zhà": ["喥"],
    "sāng sàng": ["喪"],
    "qiáo jiāo": ["喬"],
    "pèn bēn": ["喯"],
    "cān sūn qī": ["喰"],
    "zhā chā": ["喳"],
    miāo: ["喵"],
    "pēn pèn": ["喷"],
    kuí: [
      "喹",
      "夔",
      "奎",
      "巙",
      "戣",
      "揆",
      "晆",
      "暌",
      "楏",
      "楑",
      "櫆",
      "犪",
      "睽",
      "葵",
      "藈",
      "蘷",
      "虁",
      "蝰",
      "躨",
      "逵",
      "鄈",
      "鍨",
      "鍷",
      "頯",
      "馗",
      "騤",
      "骙",
      "魁"
    ],
    "lou lóu": ["喽"],
    "zào qiāo": ["喿"],
    "hè xiāo xiào hù": ["嗃"],
    "á shà": ["嗄"],
    xiù: [
      "嗅",
      "岫",
      "峀",
      "溴",
      "珛",
      "琇",
      "璓",
      "秀",
      "綉",
      "繍",
      "繡",
      "绣",
      "螑",
      "袖",
      "褎",
      "褏",
      "銹",
      "鏥",
      "鏽",
      "锈",
      "齅"
    ],
    "qiāng qiàng": ["嗆", "戗", "戧", "蹌", "蹡"],
    "ài yì": ["嗌", "艾"],
    "má mǎ ma": ["嗎"],
    "kè kē": ["嗑"],
    "dā tà": ["嗒", "鎉"],
    sǎng: ["嗓", "搡", "磉", "褬", "鎟", "顙", "颡"],
    chēn: ["嗔", "抻", "琛", "瞋", "諃", "謓", "賝", "郴", "𬘭"],
    "wā gǔ": ["嗗"],
    "pǎng bēng": ["嗙"],
    "xián qiǎn qiān": ["嗛"],
    lào: ["嗠", "嫪", "橯", "涝", "澇", "耢", "耮", "躼", "軂", "酪"],
    wēng: ["嗡", "翁", "聬", "螉", "鎓", "鶲", "鹟", "𬭩"],
    wà: ["嗢", "腽", "膃", "袜", "襪", "韤"],
    "hēi hāi": ["嗨"],
    hē: ["嗬", "欱", "蠚", "訶", "诃"],
    zi: ["嗭"],
    sǎi: ["嗮"],
    "ǹg ńg ňg": ["嗯"],
    gě: ["嗰", "舸"],
    ná: ["嗱", "拏", "拿", "鎿", "镎"],
    diǎ: ["嗲"],
    "ài ǎi āi": ["嗳"],
    tōng: ["嗵", "樋", "炵", "蓪"],
    "zuī suī": ["嗺"],
    "zhē zhè zhù zhe": ["嗻"],
    mò: [
      "嗼",
      "圽",
      "塻",
      "墨",
      "妺",
      "嫼",
      "寞",
      "帞",
      "昩",
      "末",
      "枺",
      "歿",
      "殁",
      "沫",
      "漠",
      "爅",
      "獏",
      "瘼",
      "皌",
      "眽",
      "眿",
      "瞐",
      "瞙",
      "砞",
      "礳",
      "秣",
      "絈",
      "纆",
      "耱",
      "茉",
      "莈",
      "蓦",
      "蛨",
      "蟔",
      "貃",
      "貊",
      "貘",
      "銆",
      "鏌",
      "镆",
      "陌",
      "靺",
      "驀",
      "魩",
      "默",
      "黙",
      "𬙊"
    ],
    sòu: ["嗽", "瘶"],
    tǎn: [
      "嗿",
      "坦",
      "忐",
      "憳",
      "憻",
      "暺",
      "毯",
      "璮",
      "菼",
      "袒",
      "襢",
      "醓",
      "鉭",
      "钽"
    ],
    "jiào dǎo": ["嘄"],
    "kǎi gě": ["嘅"],
    "shān càn": ["嘇"],
    cáo: ["嘈", "嶆", "曹", "曺", "槽", "漕", "艚", "蓸", "螬", "褿", "鏪", "𥕢"],
    piào: ["嘌", "徱", "蔈", "驃"],
    "lóu lou": ["嘍"],
    gǎ: ["尕", "玍"],
    "gǔ jiǎ": ["嘏"],
    "jiāo xiāo": ["嘐"],
    "xū shī": ["嘘", "噓"],
    pó: ["嘙", "嚩", "婆", "櫇", "皤", "鄱"],
    "dē dēi": ["嘚"],
    "ma má": ["嘛"],
    "lē lei": ["嘞"],
    "gā gá gǎ": ["嘠"],
    sāi: ["嘥", "噻", "毢", "腮", "顋", "鰓"],
    "zuō chuài": ["嘬"],
    "cháo zhāo": ["嘲", "朝", "鼂"],
    zuǐ: ["嘴", "噿", "嶊", "璻"],
    "qiáo qiào": ["嘺", "翹", "谯"],
    "chù xù shòu": ["嘼"],
    "tān chǎn": ["嘽"],
    "dàn tán": ["嘾", "弾", "彈", "惔", "澹"],
    "hēi mò": ["嘿"],
    ě: ["噁", "砨", "頋", "騀", "鵈"],
    "fān bo": ["噃"],
    chuáng: ["噇", "床", "牀"],
    "cù zā hé": ["噈"],
    "tūn kuò": ["噋"],
    "cēng chēng": ["噌"],
    dēng: ["噔", "嬁", "灯", "燈", "璒", "登", "竳", "簦", "艠", "豋"],
    pū: ["噗", "扑", "撲", "攴", "攵", "潽", "炇", "陠"],
    juē: ["噘", "屩", "屫", "撧"],
    lū: ["噜", "嚕", "撸", "擼", "謢"],
    zhān: [
      "噡",
      "岾",
      "惉",
      "旃",
      "旜",
      "枬",
      "栴",
      "毡",
      "氈",
      "氊",
      "沾",
      "瞻",
      "薝",
      "蛅",
      "詀",
      "詹",
      "譫",
      "谵",
      "趈",
      "邅",
      "閚",
      "霑",
      "飦",
      "饘",
      "驙",
      "魙",
      "鱣",
      "鸇",
      "鹯",
      "𫗴"
    ],
    ō: ["噢"],
    "zhòu zhuó": ["噣"],
    "jiào qiào chī": ["噭"],
    yuàn: [
      "噮",
      "妴",
      "怨",
      "愿",
      "掾",
      "瑗",
      "禐",
      "苑",
      "衏",
      "裫",
      "褑",
      "院",
      "願"
    ],
    "ǎi ài āi": ["噯"],
    "yōng yǒng": ["噰", "澭"],
    "jué xué": ["噱"],
    "pēn pèn fèn": ["噴"],
    gá: ["噶", "尜", "釓", "錷", "钆"],
    "xīn hěn hèn": ["噷"],
    dāng: ["噹", "澢", "珰", "璫", "筜", "簹", "艡", "蟷", "裆", "襠"],
    làn: ["嚂", "滥", "濫", "烂", "燗", "爁", "爛", "爤", "瓓", "糷", "钄"],
    tà: [
      "嚃",
      "嚺",
      "崉",
      "挞",
      "搨",
      "撻",
      "榻",
      "橽",
      "毾",
      "涾",
      "澾",
      "濌",
      "禢",
      "粏",
      "誻",
      "譶",
      "蹋",
      "蹹",
      "躂",
      "躢",
      "遝",
      "錔",
      "闒",
      "闥",
      "闼",
      "阘",
      "鞜",
      "鞳"
    ],
    "huō huò ǒ": ["嚄"],
    hāo: ["嚆", "茠", "蒿", "薅"],
    "hè xià": ["嚇"],
    "xiù pì": ["嚊"],
    "zhōu chóu": ["嚋", "盩", "诪"],
    mē: ["嚒"],
    "chā cā": ["嚓"],
    "bó pào bào": ["嚗"],
    "me mèi mò": ["嚜"],
    "xié hái": ["嚡"],
    "áo xiāo": ["嚣"],
    mō: ["嚤", "摸"],
    pín: [
      "嚬",
      "娦",
      "嫔",
      "嬪",
      "玭",
      "矉",
      "薲",
      "蠙",
      "貧",
      "贫",
      "顰",
      "颦",
      "𬞟"
    ],
    mè: ["嚰", "濹"],
    "rǎng rāng": ["嚷"],
    lá: ["嚹", "旯"],
    "jiáo jué jiào": ["嚼"],
    chuò: [
      "嚽",
      "娖",
      "擉",
      "歠",
      "涰",
      "磭",
      "踀",
      "輟",
      "辍",
      "辵",
      "辶",
      "酫",
      "鑡",
      "餟",
      "齪",
      "龊"
    ],
    "huān huàn": ["嚾"],
    "zá cà": ["囃"],
    chài: ["囆", "虿", "蠆", "袃", "訍"],
    "náng nāng": ["囊"],
    "zá zàn cān": ["囋"],
    sū: ["囌", "櫯", "甦", "稣", "穌", "窣", "蘇", "蘓", "酥", "鯂"],
    zèng: ["囎", "熷", "甑", "贈", "赠", "鋥", "锃"],
    "zá niè yàn": ["囐"],
    nāng: ["囔"],
    "luó luō luo": ["囖"],
    "wéi guó": ["囗"],
    huí: [
      "囘",
      "回",
      "囬",
      "廻",
      "廽",
      "恛",
      "洄",
      "痐",
      "茴",
      "蚘",
      "蛔",
      "蛕",
      "蜖",
      "迴",
      "逥",
      "鮰"
    ],
    nín: ["囜", "您", "脌"],
    "jiǎn nān": ["囝"],
    nān: ["囡"],
    tuán: ["团", "団", "團", "慱", "抟", "摶", "檲", "糰", "鏄", "鷒", "鷻"],
    "tún dùn": ["囤", "坉"],
    guó: [
      "囯",
      "囶",
      "囻",
      "国",
      "圀",
      "國",
      "帼",
      "幗",
      "慖",
      "摑",
      "漍",
      "聝",
      "腘",
      "膕",
      "蔮",
      "虢",
      "馘",
      "𬇹"
    ],
    kùn: ["困", "涃", "睏"],
    "wéi tōng": ["囲"],
    qūn: ["囷", "夋", "逡"],
    rì: ["囸", "日", "衵", "鈤", "馹", "驲"],
    tāi: ["囼", "孡", "胎"],
    pǔ: [
      "圃",
      "圑",
      "擈",
      "普",
      "暜",
      "樸",
      "檏",
      "氆",
      "浦",
      "溥",
      "烳",
      "諩",
      "譜",
      "谱",
      "蹼",
      "鐠",
      "镨"
    ],
    "quān juàn juān": ["圈", "圏"],
    "chuí chuán": ["圌"],
    tuǎn: ["圕", "畽", "疃"],
    lüè: ["圙", "掠", "略", "畧", "稤", "鋝", "鋢", "锊", "䂮"],
    "huán yuán": ["圜"],
    luán: [
      "圝",
      "圞",
      "奱",
      "娈",
      "孌",
      "孪",
      "孿",
      "峦",
      "巒",
      "挛",
      "攣",
      "曫",
      "栾",
      "欒",
      "滦",
      "灤",
      "癴",
      "癵",
      "羉",
      "脔",
      "臠",
      "虊",
      "銮",
      "鑾",
      "鵉",
      "鸞",
      "鸾"
    ],
    tǔ: ["土", "圡", "釷", "钍"],
    "xū wéi": ["圩"],
    "dì de": ["地", "嶳"],
    "qiān sú": ["圱"],
    zhèn: [
      "圳",
      "塦",
      "挋",
      "振",
      "朕",
      "栚",
      "甽",
      "眹",
      "紖",
      "絼",
      "纼",
      "誫",
      "賑",
      "赈",
      "鋴",
      "鎭",
      "鎮",
      "镇",
      "阵",
      "陣",
      "震",
      "鴆",
      "鸩"
    ],
    "chǎng cháng": ["场", "場", "塲"],
    "qí yín": ["圻"],
    jiá: [
      "圿",
      "忦",
      "恝",
      "戞",
      "扴",
      "脥",
      "荚",
      "莢",
      "蛱",
      "蛺",
      "裌",
      "跲",
      "郏",
      "郟",
      "鋏",
      "铗",
      "頬",
      "頰",
      "颊",
      "鴶",
      "鵊"
    ],
    "zhǐ zhì": ["坁"],
    bǎn: [
      "坂",
      "岅",
      "昄",
      "板",
      "版",
      "瓪",
      "粄",
      "舨",
      "蝂",
      "鈑",
      "钣",
      "阪",
      "魬"
    ],
    qǐn: ["坅", "寑", "寝", "寢", "昑", "梫", "笉", "螼", "赾", "鋟", "锓"],
    "méi fén": ["坆"],
    "rǒng kēng": ["坈"],
    "fāng fáng": ["坊"],
    "fèn bèn": ["坋"],
    tān: ["坍", "怹", "摊", "擹", "攤", "滩", "灘", "瘫", "癱", "舑", "貪", "贪"],
    "huài pēi pī péi": ["坏"],
    "dì làn": ["坔"],
    tán: [
      "坛",
      "墰",
      "墵",
      "壇",
      "壜",
      "婒",
      "憛",
      "昙",
      "曇",
      "榃",
      "檀",
      "潭",
      "燂",
      "痰",
      "磹",
      "罈",
      "罎",
      "藫",
      "談",
      "譚",
      "譠",
      "谈",
      "谭",
      "貚",
      "郯",
      "醰",
      "錟",
      "顃"
    ],
    bà: ["坝", "垻", "壩", "弝", "欛", "灞", "爸", "矲", "覇", "霸", "鮁", "鲅"],
    fén: [
      "坟",
      "墳",
      "妢",
      "岎",
      "幩",
      "枌",
      "棼",
      "汾",
      "焚",
      "燌",
      "燓",
      "羒",
      "羵",
      "蒶",
      "蕡",
      "蚠",
      "蚡",
      "豮",
      "豶",
      "轒",
      "鐼",
      "隫",
      "馩",
      "魵",
      "黂",
      "鼖",
      "鼢",
      "𣸣"
    ],
    zhuì: [
      "坠",
      "墜",
      "惴",
      "甀",
      "畷",
      "礈",
      "綴",
      "縋",
      "缀",
      "缒",
      "腏",
      "膇",
      "諈",
      "贅",
      "赘",
      "醊",
      "錣",
      "鑆"
    ],
    pō: ["坡", "岥", "泼", "溌", "潑", "釙", "鏺", "钋", "頗", "颇", "䥽"],
    "pǎn bàn": ["坢"],
    kūn: [
      "坤",
      "堃",
      "堒",
      "崐",
      "崑",
      "昆",
      "晜",
      "潉",
      "焜",
      "熴",
      "猑",
      "琨",
      "瑻",
      "菎",
      "蜫",
      "裈",
      "裩",
      "褌",
      "醌",
      "錕",
      "锟",
      "騉",
      "髠",
      "髡",
      "髨",
      "鯤",
      "鲲",
      "鵾",
      "鶤",
      "鹍"
    ],
    diàn: [
      "坫",
      "垫",
      "墊",
      "壂",
      "奠",
      "婝",
      "店",
      "惦",
      "扂",
      "橂",
      "殿",
      "淀",
      "澱",
      "玷",
      "琔",
      "电",
      "癜",
      "簟",
      "蜔",
      "鈿",
      "電",
      "靛",
      "驔"
    ],
    "mù mǔ": ["坶"],
    "kē kě": ["坷", "軻"],
    xuè: ["坹", "岤", "桖", "瀥", "狘", "瞲", "謔", "谑", "趐"],
    "dǐ chí": ["坻", "柢"],
    lā: ["垃", "柆", "菈", "邋"],
    lǒng: ["垄", "垅", "壟", "壠", "拢", "攏", "竉", "陇", "隴", "𬕂"],
    mín: [
      "垊",
      "姄",
      "岷",
      "崏",
      "捪",
      "旻",
      "旼",
      "民",
      "珉",
      "琘",
      "琝",
      "瑉",
      "痻",
      "盿",
      "砇",
      "緍",
      "緡",
      "缗",
      "罠",
      "苠",
      "鈱",
      "錉",
      "鍲",
      "鴖"
    ],
    "dòng tóng": ["垌", "峒", "洞"],
    cí: [
      "垐",
      "嬨",
      "慈",
      "柌",
      "濨",
      "珁",
      "瓷",
      "甆",
      "磁",
      "礠",
      "祠",
      "糍",
      "茨",
      "詞",
      "词",
      "辝",
      "辞",
      "辤",
      "辭",
      "雌",
      "飺",
      "餈",
      "鴜",
      "鶿",
      "鷀",
      "鹚"
    ],
    duī: ["垖", "堆", "塠", "痽", "磓", "鐓", "鐜", "鴭"],
    "duò duǒ": ["垛"],
    "duǒ duò": ["垜", "挆"],
    chá: ["垞", "察", "嵖", "搽", "槎", "檫", "猹", "茬", "茶", "詧", "靫", "𥻗"],
    shǎng: ["垧", "晌", "樉", "賞", "贘", "赏", "鋿", "鏛", "鑜"],
    shǒu: ["垨", "守", "手", "扌", "艏", "首"],
    da: ["垯", "繨", "跶"],
    háng: [
      "垳",
      "斻",
      "杭",
      "筕",
      "絎",
      "绗",
      "航",
      "苀",
      "蚢",
      "裄",
      "貥",
      "迒",
      "頏",
      "颃",
      "魧"
    ],
    "ān ǎn": ["垵"],
    xīng: [
      "垶",
      "惺",
      "星",
      "曐",
      "煋",
      "猩",
      "瑆",
      "皨",
      "篂",
      "腥",
      "興",
      "觪",
      "觲",
      "謃",
      "騂",
      "骍",
      "鮏",
      "鯹"
    ],
    "yuàn huán": ["垸"],
    bāng: [
      "垹",
      "帮",
      "幇",
      "幚",
      "幫",
      "捠",
      "梆",
      "浜",
      "邦",
      "邫",
      "鞤",
      "𠳐"
    ],
    "póu fú": ["垺"],
    cén: ["埁", "岑", "涔"],
    "běng fēng": ["埄"],
    "dì fáng": ["埅"],
    "xiá jiā": ["埉"],
    "mái mán": ["埋"],
    làng: ["埌", "崀", "浪", "蒗", "閬", "㫰"],
    "shān yán": ["埏"],
    "qín jīn": ["埐"],
    "pǔ bù": ["埔"],
    huā: ["埖", "婲", "椛", "硴", "糀", "花", "蒊", "蘤", "誮", "錵"],
    "suì sù": ["埣"],
    "pí pì": ["埤"],
    "qīng zhēng": ["埥", "鲭"],
    "wǎn wān": ["埦"],
    lǔn: ["埨", "稐", "𫭢"],
    "zhēng chéng": ["埩"],
    kōng: ["埪", "崆", "箜", "躻", "錓", "鵼"],
    "cǎi cài": ["埰", "寀", "采"],
    "chù tòu": ["埱"],
    běng: ["埲", "琫", "菶", "鞛"],
    "kǎn xiàn": ["埳"],
    "yì shì": ["埶", "醳"],
    péi: ["培", "毰", "裴", "裵", "賠", "赔", "錇", "锫", "阫", "陪"],
    "sào sǎo": ["埽"],
    "jǐn qīn jìn": ["堇"],
    "péng bèng": ["堋"],
    "qiàn zàn jiàn": ["堑"],
    àn: [
      "堓",
      "屵",
      "岸",
      "按",
      "暗",
      "案",
      "胺",
      "荌",
      "豻",
      "貋",
      "錌",
      "闇",
      "隌",
      "黯"
    ],
    "duò huī": ["堕", "墮"],
    huán: [
      "堚",
      "寏",
      "寰",
      "峘",
      "桓",
      "洹",
      "澴",
      "獂",
      "环",
      "環",
      "糫",
      "繯",
      "缳",
      "羦",
      "荁",
      "萈",
      "萑",
      "豲",
      "鍰",
      "鐶",
      "锾",
      "镮",
      "闤",
      "阛",
      "雈",
      "鬟",
      "鹮",
      "𬘫",
      "𤩽"
    ],
    "bǎo bǔ pù": ["堡"],
    "máo móu wǔ": ["堥"],
    ruán: ["堧", "壖", "撋"],
    "ài è yè": ["堨"],
    gèng: ["堩", "暅"],
    méi: [
      "堳",
      "塺",
      "媒",
      "嵋",
      "徾",
      "攗",
      "枚",
      "栂",
      "梅",
      "楣",
      "楳",
      "槑",
      "湄",
      "湈",
      "煤",
      "猸",
      "玫",
      "珻",
      "瑂",
      "眉",
      "睂",
      "禖",
      "脄",
      "脢",
      "腜",
      "苺",
      "莓",
      "葿",
      "郿",
      "酶",
      "鎇",
      "镅",
      "霉",
      "鶥",
      "鹛",
      "黴"
    ],
    dǔ: ["堵", "琽", "睹", "笃", "篤", "覩", "賭", "赌"],
    féng: ["堸", "綘", "艂", "逢"],
    hèng: ["堼"],
    chūn: [
      "堾",
      "媋",
      "旾",
      "春",
      "暙",
      "杶",
      "椿",
      "槆",
      "橁",
      "櫄",
      "瑃",
      "箺",
      "萅",
      "蝽",
      "輴",
      "鰆",
      "鶞",
      "䲠"
    ],
    jiǎng: [
      "塂",
      "奖",
      "奨",
      "奬",
      "桨",
      "槳",
      "獎",
      "耩",
      "膙",
      "蒋",
      "蔣",
      "講",
      "讲",
      "顜"
    ],
    huāng: ["塃", "巟", "慌", "肓", "荒", "衁"],
    duàn: [
      "塅",
      "断",
      "斷",
      "椴",
      "段",
      "毈",
      "煅",
      "瑖",
      "碫",
      "簖",
      "籪",
      "緞",
      "缎",
      "腶",
      "葮",
      "躖",
      "鍛",
      "锻"
    ],
    tǎ: ["塔", "墖", "獭", "獺", "鮙", "鰨", "鳎"],
    wěng: ["塕", "奣", "嵡", "攚", "暡", "瞈", "蓊"],
    "sāi sài sè": ["塞"],
    zàng: ["塟", "弉", "臓", "臟", "葬", "蔵", "銺"],
    tián: [
      "塡",
      "屇",
      "恬",
      "沺",
      "湉",
      "璳",
      "甛",
      "甜",
      "田",
      "畋",
      "畑",
      "碵",
      "磌",
      "胋",
      "闐",
      "阗",
      "鴫",
      "鷆",
      "鷏"
    ],
    zhèng: [
      "塣",
      "幁",
      "政",
      "証",
      "諍",
      "證",
      "证",
      "诤",
      "郑",
      "鄭",
      "靕",
      "鴊"
    ],
    "tián zhèn": ["填"],
    wēn: [
      "塭",
      "昷",
      "榲",
      "殟",
      "温",
      "溫",
      "瑥",
      "瘟",
      "蕰",
      "豱",
      "輼",
      "轀",
      "辒",
      "鎾",
      "饂",
      "鰛",
      "鰮",
      "鳁"
    ],
    liù: ["塯", "廇", "磟", "翏", "雡", "霤", "餾", "鬸", "鷚", "鹨"],
    hǎi: ["塰", "海", "烸", "酼", "醢"],
    lǎng: ["塱", "朖", "朗", "朤", "烺", "蓢", "㮾"],
    bèng: ["塴", "揼", "泵", "甏", "綳", "蹦", "迸", "逬", "鏰", "镚"],
    chén: [
      "塵",
      "宸",
      "尘",
      "忱",
      "敐",
      "敶",
      "晨",
      "曟",
      "栕",
      "樄",
      "沉",
      "煁",
      "瘎",
      "臣",
      "茞",
      "莀",
      "莐",
      "蔯",
      "薼",
      "螴",
      "訦",
      "諶",
      "軙",
      "辰",
      "迧",
      "鈂",
      "陈",
      "陳",
      "霃",
      "鷐",
      "麎"
    ],
    "ōu qiū": ["塸"],
    "qiàn jiàn": ["塹"],
    "zhuān tuán": ["塼"],
    shuǎng: ["塽", "慡", "漺", "爽", "縔", "鏯"],
    shú: ["塾", "婌", "孰", "璹", "秫", "贖", "赎"],
    lǒu: ["塿", "嵝", "嶁", "甊", "篓", "簍"],
    chí: [
      "墀",
      "弛",
      "持",
      "池",
      "漦",
      "竾",
      "筂",
      "箎",
      "篪",
      "茌",
      "荎",
      "蚳",
      "謘",
      "貾",
      "赿",
      "踟",
      "迟",
      "迡",
      "遅",
      "遟",
      "遲",
      "鍉",
      "馳",
      "驰"
    ],
    shù: [
      "墅",
      "庶",
      "庻",
      "怷",
      "恕",
      "戍",
      "束",
      "树",
      "樹",
      "沭",
      "漱",
      "潄",
      "濖",
      "竖",
      "竪",
      "絉",
      "腧",
      "荗",
      "蒁",
      "虪",
      "術",
      "裋",
      "豎",
      "述",
      "鉥",
      "錰",
      "鏣",
      "霔",
      "鶐",
      "𬬸"
    ],
    "dì zhì": ["墆", "疐"],
    kàn: ["墈", "崁", "瞰", "矙", "磡", "衎", "鬫"],
    chěn: ["墋", "夦", "硶", "碜", "磣", "贂", "趻", "踸", "鍖"],
    "zhǐ zhuó": ["墌"],
    qiǎng: ["墏", "繈", "繦", "羥", "襁"],
    zēng: ["増", "增", "憎", "璔", "矰", "磳", "罾", "譄", "鄫", "鱛", "䎖"],
    qiáng: [
      "墙",
      "墻",
      "嫱",
      "嬙",
      "樯",
      "檣",
      "漒",
      "牆",
      "艢",
      "蔃",
      "蔷",
      "蘠"
    ],
    "kuài tuí": ["墤"],
    "tuǎn dǒng": ["墥"],
    "qiáo què": ["墧"],
    "zūn dūn": ["墫"],
    "qiāo áo": ["墽"],
    "yì tú": ["墿"],
    "xué bó jué": ["壆"],
    lǎn: [
      "壈",
      "嬾",
      "孄",
      "孏",
      "懒",
      "懶",
      "揽",
      "擥",
      "攬",
      "榄",
      "欖",
      "浨",
      "漤",
      "灠",
      "纜",
      "缆",
      "罱",
      "覧",
      "覽",
      "览",
      "醂",
      "顲"
    ],
    huài: ["壊", "壞", "蘾"],
    rǎng: ["壌", "壤", "攘", "爙"],
    "làn xiàn": ["壏"],
    dǎo: [
      "壔",
      "导",
      "導",
      "岛",
      "島",
      "嶋",
      "嶌",
      "嶹",
      "捣",
      "搗",
      "擣",
      "槝",
      "祷",
      "禂",
      "禱",
      "蹈",
      "陦",
      "隝",
      "隯"
    ],
    ruǐ: ["壡", "桵", "橤", "繠", "蕊", "蕋", "蘂", "蘃"],
    san: ["壭"],
    zhuàng: ["壮", "壯", "壵", "撞", "焋", "状", "狀"],
    "ké qiào": ["壳", "殼"],
    kǔn: [
      "壸",
      "壼",
      "悃",
      "捆",
      "梱",
      "硱",
      "祵",
      "稇",
      "稛",
      "綑",
      "裍",
      "閫",
      "閸",
      "阃"
    ],
    mǎng: ["壾", "漭", "茻", "莽", "莾", "蠎"],
    cún: ["壿", "存"],
    "zhǐ zhōng": ["夂"],
    "gǔ yíng": ["夃"],
    "jiàng xiáng": ["夅", "降"],
    "páng féng fēng": ["夆"],
    zhāi: ["夈", "捚", "摘", "斋", "斎", "榸", "粂", "齋"],
    "xuàn xiòng": ["夐"],
    wài: ["外", "顡"],
    "wǎn yuàn wān yuān": ["夗"],
    "mǎo wǎn": ["夘"],
    mèng: ["夢", "夣", "孟", "梦", "癦", "霥"],
    "dà dài": ["大"],
    "fū fú": ["夫", "姇", "枎", "粰"],
    guài: ["夬", "怪", "恠"],
    yāng: [
      "央",
      "姎",
      "抰",
      "殃",
      "泱",
      "秧",
      "胦",
      "鉠",
      "鍈",
      "雵",
      "鴦",
      "鸯"
    ],
    "hāng bèn": ["夯"],
    gǎo: [
      "夰",
      "搞",
      "杲",
      "槀",
      "槁",
      "檺",
      "稁",
      "稾",
      "稿",
      "縞",
      "缟",
      "菒",
      "藁",
      "藳"
    ],
    "tāo běn": ["夲"],
    "tóu tou": ["头"],
    "yǎn tāo": ["夵"],
    "kuā kuà": ["夸", "誇"],
    "jiá jiā gā xiá": ["夹"],
    huà: [
      "夻",
      "婳",
      "嫿",
      "嬅",
      "崋",
      "摦",
      "杹",
      "枠",
      "桦",
      "槬",
      "樺",
      "澅",
      "画",
      "畫",
      "畵",
      "繣",
      "舙",
      "話",
      "諙",
      "譮",
      "话",
      "黊"
    ],
    "jiā jiá gā xiá": ["夾"],
    ēn: ["奀", "恩", "蒽"],
    "dī tì": ["奃"],
    "yǎn yān": ["奄", "渰"],
    pào: ["奅", "疱", "皰", "砲", "礟", "礮", "靤", "麭"],
    nài: ["奈", "柰", "渿", "耐", "萘", "褦", "錼", "鼐"],
    "quān juàn": ["奍", "弮", "棬"],
    zòu: ["奏", "揍"],
    "qì qiè xiè": ["契"],
    kāi: ["奒", "开", "揩", "鐦", "锎", "開"],
    "bēn bèn": ["奔", "泍"],
    tào: ["套"],
    "zàng zhuǎng": ["奘"],
    běn: ["奙", "本", "楍", "畚", "翉", "苯"],
    "xùn zhuì": ["奞"],
    shē: ["奢", "檨", "猞", "畭", "畲", "賒", "賖", "赊", "輋", "𪨶"],
    "hǎ pò tǎi": ["奤"],
    "ào yù": ["奥", "奧", "澚"],
    yūn: ["奫", "氲", "氳", "蒀", "蒕", "蝹", "贇", "赟", "𫖳"],
    "duǒ chě": ["奲"],
    "nǚ rǔ": ["女"],
    nú: ["奴", "孥", "笯", "駑", "驽"],
    "dīng dǐng tiǎn": ["奵"],
    "tā jiě": ["她"],
    nuán: ["奻"],
    "hǎo hào": ["好"],
    fàn: [
      "奿",
      "嬎",
      "梵",
      "汎",
      "泛",
      "滼",
      "瀪",
      "犯",
      "畈",
      "盕",
      "笵",
      "範",
      "范",
      "訉",
      "販",
      "贩",
      "軬",
      "輽",
      "飯",
      "飰",
      "饭"
    ],
    shuò: ["妁", "搠", "朔", "槊", "烁", "爍", "矟", "蒴", "鎙", "鑠", "铄"],
    "fēi pèi": ["妃"],
    wàng: ["妄", "忘", "旺", "望", "朢"],
    zhuāng: [
      "妆",
      "妝",
      "娤",
      "庄",
      "庒",
      "桩",
      "梉",
      "樁",
      "粧",
      "糚",
      "荘",
      "莊",
      "装",
      "裝"
    ],
    mā: ["妈", "媽"],
    "fū yōu": ["妋"],
    "hài jiè": ["妎"],
    dù: [
      "妒",
      "妬",
      "杜",
      "殬",
      "渡",
      "秺",
      "芏",
      "荰",
      "螙",
      "蠧",
      "蠹",
      "鍍",
      "镀",
      "靯",
      "𬭊"
    ],
    miào: ["妙", "庙", "庿", "廟", "玅", "竗"],
    "fǒu pēi pī": ["妚"],
    "yuè jué": ["妜"],
    niū: ["妞"],
    "nà nàn": ["妠"],
    tuǒ: ["妥", "嫷", "庹", "椭", "楕", "橢", "鬌", "鰖", "鵎"],
    "wàn yuán": ["妧"],
    fáng: ["妨", "房", "肪", "防", "魴", "鲂"],
    nī: ["妮"],
    zhóu: ["妯", "碡"],
    zhāo: ["妱", "巶", "招", "昭", "釗", "鉊", "鍣", "钊", "駋", "𬬿"],
    "nǎi nǐ": ["妳"],
    tǒu: ["妵", "敨", "紏", "蘣", "黈"],
    "xián xuán xù": ["妶"],
    "zhí yì": ["妷", "秇"],
    ē: ["妸", "妿", "婀", "屙"],
    mèi: [
      "妹",
      "媚",
      "寐",
      "抺",
      "旀",
      "昧",
      "沬",
      "煝",
      "痗",
      "眛",
      "睸",
      "祙",
      "篃",
      "蝞",
      "袂",
      "跊",
      "鬽",
      "魅"
    ],
    "qī qì": ["妻"],
    "xū xǔ": ["姁", "稰"],
    "shān shàn": ["姍", "姗", "苫", "釤", "钐"],
    mán: ["姏", "慲", "樠", "蛮", "蠻", "謾", "饅", "馒", "鬗", "鬘", "鰻", "鳗"],
    jiě: ["姐", "媎", "檞", "毑", "飷"],
    "wěi wēi": ["委"],
    pīn: ["姘", "拼", "礗", "穦", "馪", "驞"],
    "huá huó": ["姡"],
    "jiāo xiáo": ["姣"],
    "gòu dù": ["姤"],
    "lǎo mǔ": ["姥"],
    "nián niàn": ["姩"],
    zhěn: [
      "姫",
      "屒",
      "弫",
      "抮",
      "昣",
      "枕",
      "畛",
      "疹",
      "眕",
      "稹",
      "縝",
      "縥",
      "缜",
      "聄",
      "萙",
      "袗",
      "裖",
      "覙",
      "診",
      "诊",
      "軫",
      "轸",
      "辴",
      "駗",
      "鬒"
    ],
    héng: [
      "姮",
      "恆",
      "恒",
      "烆",
      "珩",
      "胻",
      "蘅",
      "衡",
      "鑅",
      "鴴",
      "鵆",
      "鸻"
    ],
    "jūn xún": ["姰"],
    "kuā hù": ["姱"],
    "è yà": ["姶"],
    "xiān shēn": ["姺"],
    wá: ["娃"],
    "ráo rǎo": ["娆", "嬈"],
    "shào shāo": ["娋"],
    xiē: ["娎", "揳", "楔", "歇", "蝎", "蠍"],
    "wǔ méi mǔ": ["娒"],
    "chuò lài": ["娕"],
    niáng: ["娘", "嬢", "孃"],
    "nà nuó": ["娜", "𦰡"],
    "pōu bǐ": ["娝"],
    "něi suī": ["娞"],
    tuì: ["娧", "煺", "蛻", "蜕", "退", "駾"],
    mǎn: ["娨", "屘", "満", "满", "滿", "螨", "蟎", "襔", "鏋"],
    "wú wù yú": ["娪"],
    "xī āi": ["娭"],
    "zhuì shuì": ["娷"],
    "dōng dòng": ["娻"],
    "ǎi ái è": ["娾"],
    "ē ě": ["娿"],
    mián: [
      "婂",
      "嬵",
      "宀",
      "杣",
      "棉",
      "檰",
      "櫋",
      "眠",
      "矈",
      "矊",
      "矏",
      "綿",
      "緜",
      "绵",
      "芇",
      "蝒"
    ],
    "pǒu péi bù": ["婄"],
    biǎo: ["婊", "脿", "表", "裱", "褾", "諘", "錶"],
    "fù fàn": ["婏"],
    wǒ: ["婐", "婑", "我"],
    "ní nǐ": ["婗", "棿"],
    "quán juàn": ["婘", "惓"],
    hūn: [
      "婚",
      "昏",
      "昬",
      "棔",
      "涽",
      "睧",
      "睯",
      "碈",
      "荤",
      "葷",
      "蔒",
      "轋",
      "閽",
      "阍"
    ],
    "qiān jǐn": ["婜"],
    "wān wà": ["婠"],
    "lái lài": ["婡", "徕", "徠"],
    "zhōu chōu": ["婤"],
    "chuò nào": ["婥"],
    "nüè àn": ["婩"],
    "hùn kūn": ["婫"],
    "dàng yáng": ["婸"],
    nàn: ["婻"],
    "ruò chuò": ["婼"],
    jiǎ: ["婽", "岬", "斚", "斝", "榎", "槚", "檟", "玾", "甲", "胛", "鉀", "钾"],
    "tōu yú": ["婾", "媮"],
    "yù yú": ["媀"],
    "wéi wěi": ["媁"],
    "dì tí": ["媂", "珶", "苐"],
    róu: [
      "媃",
      "揉",
      "柔",
      "渘",
      "煣",
      "瑈",
      "瓇",
      "禸",
      "粈",
      "糅",
      "脜",
      "腬",
      "葇",
      "蝚",
      "蹂",
      "輮",
      "鍒",
      "鞣",
      "騥",
      "鰇",
      "鶔",
      "𫐓"
    ],
    "ruǎn nèn": ["媆"],
    miáo: ["媌", "嫹", "描", "瞄", "苗", "鶓", "鹋"],
    "yí pèi": ["媐"],
    "mián miǎn": ["媔"],
    "tí shì": ["媞", "惿"],
    "duò tuó": ["媠", "沲"],
    ǎo: ["媪", "媼", "艹", "芺", "袄", "襖", "镺"],
    "chú zòu": ["媰"],
    yìng: ["媵", "映", "暎", "硬", "膡", "鱦"],
    "qín shēn": ["嫀"],
    jià: ["嫁", "幏", "架", "榢", "稼", "駕", "驾"],
    sǎo: ["嫂"],
    "zhēn zhěn": ["嫃"],
    "jiē suǒ": ["嫅"],
    "míng mǐng": ["嫇"],
    niǎo: ["嫋", "嬝", "嬲", "茑", "蔦", "袅", "裊", "褭", "鸟"],
    tāo: [
      "嫍",
      "幍",
      "弢",
      "慆",
      "掏",
      "搯",
      "槄",
      "涛",
      "滔",
      "濤",
      "瑫",
      "絛",
      "縚",
      "縧",
      "绦",
      "詜",
      "謟",
      "轁",
      "鞱",
      "韜",
      "韬",
      "飸",
      "饕"
    ],
    biáo: ["嫑"],
    "piáo piāo": ["嫖", "薸"],
    xuán: [
      "嫙",
      "悬",
      "懸",
      "暶",
      "檈",
      "漩",
      "玄",
      "璇",
      "璿",
      "痃",
      "蜁",
      "𫠊"
    ],
    "màn mān": ["嫚"],
    kāng: [
      "嫝",
      "嵻",
      "康",
      "慷",
      "槺",
      "漮",
      "砊",
      "穅",
      "糠",
      "躿",
      "鏮",
      "鱇",
      "𡐓",
      "𩾌"
    ],
    "hān nǎn": ["嫨"],
    nèn: ["嫩", "嫰"],
    zhē: ["嫬", "遮"],
    "mā má": ["嫲"],
    piè: ["嫳"],
    zhǎn: [
      "嫸",
      "展",
      "搌",
      "斩",
      "斬",
      "琖",
      "盏",
      "盞",
      "輾",
      "醆",
      "颭",
      "飐"
    ],
    "xiān yǎn jìn": ["嬐"],
    liǎn: [
      "嬚",
      "敛",
      "斂",
      "琏",
      "璉",
      "羷",
      "脸",
      "臉",
      "蔹",
      "蘝",
      "蘞",
      "裣",
      "襝",
      "鄻"
    ],
    "qióng huán xuān": ["嬛"],
    dǒng: ["嬞", "懂", "箽", "董", "蕫", "諌"],
    cān: ["嬠", "湌", "爘", "飡", "餐", "驂", "骖"],
    tiǎo: ["嬥", "宨", "晀", "朓", "窱", "脁"],
    bí: ["嬶", "荸", "鼻"],
    liǔ: [
      "嬼",
      "柳",
      "栁",
      "桞",
      "桺",
      "橮",
      "熮",
      "珋",
      "綹",
      "绺",
      "罶",
      "羀",
      "鋶",
      "锍"
    ],
    "qiān xiān": ["孅", "欦"],
    "xié huī": ["孈"],
    "huān quán": ["孉"],
    "lí lì": ["孋", "麗"],
    "zhú chuò": ["孎"],
    kǒng: ["孔", "恐"],
    "mā zī": ["孖"],
    "sūn xùn": ["孙", "孫"],
    "bèi bó": ["孛", "誖"],
    "yòu niū": ["孧"],
    zhuǎn: ["孨", "竱", "轉"],
    hái: ["孩", "骸"],
    nāo: ["孬"],
    "chán càn": ["孱"],
    bò: ["孹", "檗", "蘗", "譒"],
    nái: ["孻", "腉"],
    "níng nìng": ["宁", "寍", "寗", "寜", "寧", "甯"],
    zhái: ["宅"],
    "tū jiā": ["宊"],
    sòng: ["宋", "訟", "誦", "讼", "诵", "送", "鎹", "頌", "颂", "餸"],
    ròu: ["宍", "肉", "譳"],
    zhūn: ["宒", "窀", "衠", "諄", "谆", "迍"],
    "mì fú": ["宓"],
    "dàng tàn": ["宕"],
    "wǎn yuān": ["宛"],
    chǒng: ["宠", "寵"],
    qún: ["宭", "峮", "帬", "羣", "群", "裙", "裠"],
    zǎi: ["宰", "崽"],
    "bǎo shí": ["宲"],
    "jiā jia jie": ["家"],
    "huāng huǎng": ["宺"],
    kuān: ["宽", "寛", "寬", "臗", "鑧", "髋", "髖"],
    "sù xiǔ xiù": ["宿"],
    "jié zǎn": ["寁"],
    "bìng bǐng": ["寎"],
    "jìn qǐn": ["寖"],
    "lóu jù": ["寠"],
    "xiě xiè": ["寫"],
    "qīn qìn": ["寴"],
    cùn: ["寸", "籿"],
    duì: [
      "对",
      "対",
      "對",
      "怼",
      "憝",
      "懟",
      "濧",
      "瀩",
      "碓",
      "祋",
      "綐",
      "薱",
      "譈",
      "譵",
      "轛",
      "队",
      "陮"
    ],
    "lüè luó": ["寽"],
    "shè yè yì": ["射"],
    "jiāng jiàng qiāng": ["将"],
    "jiāng jiàng": ["將", "浆", "漿", "畺"],
    zūn: ["尊", "嶟", "樽", "罇", "遵", "鐏", "鱒", "鳟", "鶎", "鷷", "𨱔"],
    "shù zhù": ["尌", "澍"],
    xiǎo: ["小", "晓", "暁", "曉", "皛", "皢", "筱", "筿", "篠", "謏", "𫍲"],
    "jié jí": ["尐", "诘", "鞊"],
    "shǎo shào": ["少"],
    ěr: [
      "尒",
      "尓",
      "尔",
      "栮",
      "毦",
      "洱",
      "爾",
      "珥",
      "耳",
      "薾",
      "衈",
      "趰",
      "迩",
      "邇",
      "鉺",
      "铒",
      "餌",
      "饵",
      "駬"
    ],
    "wāng yóu": ["尢"],
    wāng: ["尣", "尩", "尪", "尫", "汪"],
    liào: ["尥", "尦", "廖", "撂", "料", "炓", "窷", "鐐", "镣", "𪤗"],
    "méng máng lóng páng": ["尨"],
    gà: ["尬", "魀"],
    "kuì kuǐ": ["尯"],
    tuí: ["尵", "弚", "穨", "蘈", "蹪", "隤", "頹", "頺", "頽", "颓", "魋", "𬯎"],
    yǐn: [
      "尹",
      "嶾",
      "引",
      "朄",
      "檃",
      "檼",
      "櫽",
      "淾",
      "濥",
      "瘾",
      "癮",
      "粌",
      "蘟",
      "蚓",
      "螾",
      "讔",
      "赺",
      "趛",
      "輑",
      "鈏",
      "靷"
    ],
    "chǐ chě": ["尺"],
    kāo: ["尻", "髛"],
    "jìn jǐn": ["尽"],
    "wěi yǐ": ["尾"],
    "niào suī": ["尿"],
    céng: ["层", "層", "嶒", "驓"],
    diǎo: ["屌"],
    "píng bǐng bīng": ["屏"],
    lòu: ["屚", "漏", "瘘", "瘺", "瘻", "鏤", "镂", "陋"],
    "shǔ zhǔ": ["属", "屬"],
    "xiè tì": ["屟"],
    "chè cǎo": ["屮"],
    "tún zhūn": ["屯"],
    "nì jǐ": ["屰"],
    "hóng lóng": ["屸"],
    "qǐ kǎi": ["岂", "豈"],
    áng: ["岇", "昂", "昻"],
    "gǎng gāng": ["岗", "崗"],
    kě: ["岢", "敤", "渇", "渴", "炣"],
    gǒu: ["岣", "狗", "玽", "笱", "耇", "耈", "耉", "苟", "豿"],
    tiáo: [
      "岧",
      "岹",
      "樤",
      "祒",
      "笤",
      "芀",
      "萔",
      "蓚",
      "蓨",
      "蜩",
      "迢",
      "鋚",
      "鎥",
      "鞗",
      "髫",
      "鯈",
      "鰷",
      "鲦",
      "齠",
      "龆"
    ],
    "qū jū": ["岨"],
    lǐng: ["岭", "嶺", "領", "领"],
    pò: ["岶", "敀", "洦", "湐", "烞", "珀", "破", "砶", "粕", "蒪", "魄"],
    "bā kè": ["峇"],
    luò: [
      "峈",
      "摞",
      "洛",
      "洜",
      "犖",
      "珞",
      "笿",
      "纙",
      "荦",
      "詻",
      "雒",
      "駱",
      "骆",
      "鵅"
    ],
    "fù niè": ["峊"],
    ěn: ["峎"],
    "zhì shì": ["峙", "崻"],
    qiǎ: ["峠", "跒", "酠", "鞐"],
    "qiáo jiào": ["峤", "癄"],
    "xié yé": ["峫"],
    bū: ["峬", "庯", "晡", "誧", "逋", "鈽", "錻", "钸", "餔", "鵏"],
    chóng: ["崇", "崈", "爞", "虫", "蝩", "蟲", "褈", "隀"],
    "zú cuì": ["崒", "椊"],
    "líng léng": ["崚"],
    "dòng dōng": ["崠"],
    xiáo: ["崤", "洨", "淆", "訤", "誵"],
    "pí bǐ": ["崥", "芘"],
    "zhǎn chán": ["崭", "嶃", "嶄"],
    "wǎi wēi": ["崴"],
    "yáng dàng": ["崵"],
    "shì dié": ["崼"],
    yào: [
      "崾",
      "曜",
      "熎",
      "燿",
      "矅",
      "穾",
      "窔",
      "筄",
      "耀",
      "艞",
      "药",
      "葯",
      "薬",
      "藥",
      "袎",
      "覞",
      "詏",
      "讑",
      "靿",
      "鷂",
      "鹞",
      "鼼"
    ],
    "kān zhàn": ["嵁"],
    "hán dǎng": ["嵅"],
    "qiàn kàn": ["嵌"],
    "wù máo": ["嵍"],
    "kě jié": ["嵑", "嶱"],
    "wēi wěi": ["嵔"],
    kē: [
      "嵙",
      "柯",
      "棵",
      "榼",
      "樖",
      "牁",
      "牱",
      "犐",
      "珂",
      "疴",
      "瞌",
      "磕",
      "礚",
      "科",
      "稞",
      "窠",
      "萪",
      "薖",
      "蚵",
      "蝌",
      "趷",
      "轲",
      "醘",
      "鈳",
      "钶",
      "頦",
      "顆",
      "颗",
      "髁"
    ],
    "dàng táng": ["嵣"],
    "róng yíng": ["嵤", "爃"],
    "ái kǎi": ["嵦"],
    "kāo qiāo": ["嵪"],
    cuó: ["嵯", "嵳", "痤", "矬", "蒫", "蔖", "虘", "鹺", "鹾"],
    "qiǎn qīn": ["嵰"],
    "dì dié": ["嵽"],
    cēn: ["嵾"],
    dǐng: ["嵿", "艼", "薡", "鐤", "頂", "顶", "鼎", "鼑"],
    "áo ào": ["嶅"],
    "pǐ pèi": ["嶏"],
    "jiào qiáo": ["嶠", "潐"],
    "jué guì": ["嶡", "鳜"],
    "zhān shàn": ["嶦", "鳣"],
    "xiè jiè": ["嶰"],
    "guī xī juàn": ["嶲"],
    rū: ["嶿"],
    "lì liè": ["巁", "棙", "爄", "綟"],
    "xī guī juàn": ["巂"],
    "yíng hōng": ["巆"],
    yǐng: [
      "巊",
      "廮",
      "影",
      "摬",
      "梬",
      "潁",
      "瘿",
      "癭",
      "矨",
      "穎",
      "郢",
      "鐛",
      "頴",
      "颍",
      "颕",
      "颖"
    ],
    chǎo: ["巐", "炒", "煼", "眧", "麨"],
    cuán: ["巑", "櫕", "欑"],
    chuān: ["巛", "川", "氚", "瑏", "穿"],
    "jīng xíng": ["巠"],
    cháo: [
      "巢",
      "巣",
      "晁",
      "漅",
      "潮",
      "牊",
      "窲",
      "罺",
      "謿",
      "轈",
      "鄛",
      "鼌"
    ],
    qiǎo: ["巧", "愀", "髜"],
    gǒng: ["巩", "廾", "拱", "拲", "栱", "汞", "珙", "輁", "鞏"],
    "chà chā chāi cī": ["差"],
    "xiàng hàng": ["巷"],
    shuài: ["帅", "帥", "蟀"],
    pà: ["帊", "帕", "怕", "袙"],
    "tǎng nú": ["帑"],
    "mò wà": ["帓"],
    "tiē tiě tiè": ["帖"],
    zhǒu: ["帚", "晭", "疛", "睭", "箒", "肘", "菷", "鯞"],
    "juǎn juàn": ["帣"],
    shuì: ["帨", "涗", "涚", "睡", "稅", "税", "裞"],
    "chóu dào": ["帱", "幬"],
    "jiǎn jiān sàn": ["帴"],
    "shà qiè": ["帹"],
    "qí jì": ["帺", "荠"],
    "shān qiāo shēn": ["幓"],
    "zhuàng chuáng": ["幢"],
    "chān chàn": ["幨"],
    miè: [
      "幭",
      "懱",
      "搣",
      "滅",
      "灭",
      "烕",
      "礣",
      "篾",
      "蔑",
      "薎",
      "蠛",
      "衊",
      "鑖",
      "鱴",
      "鴓"
    ],
    "gān gàn": ["干"],
    "bìng bīng": ["并", "幷"],
    "jī jǐ": ["幾"],
    "guǎng ān": ["广"],
    guǎng: ["広", "廣", "犷", "獷"],
    me: ["庅"],
    "dùn tún": ["庉"],
    "bài tīng": ["庍"],
    "yìng yīng": ["应"],
    "dǐ de": ["底"],
    "dù duó": ["度"],
    "máng méng páng": ["庬"],
    "bìng píng": ["庰"],
    chěng: ["庱", "悜", "睈", "逞", "騁", "骋"],
    "jī cuò": ["庴"],
    qǐng: ["庼", "廎", "檾", "漀", "苘", "請", "謦", "请", "頃", "顷"],
    "guī wěi huì": ["廆"],
    "jǐn qín": ["廑"],
    kuò: [
      "廓",
      "扩",
      "拡",
      "擴",
      "濶",
      "筈",
      "萿",
      "葀",
      "蛞",
      "闊",
      "阔",
      "霩",
      "鞟",
      "鞹",
      "韕",
      "頢",
      "鬠"
    ],
    "qiáng sè": ["廧", "薔"],
    "yǐn yìn": ["廴", "隐", "隠", "隱", "飮", "飲", "饮"],
    "pò pǎi": ["廹", "迫"],
    "nòng lòng": ["弄"],
    "dì tì tuí": ["弟"],
    "jué zhāng": ["弡"],
    "mí mǐ": ["弥", "彌", "靡"],
    chāo: ["弨", "怊", "抄", "欩", "訬", "超", "鈔", "钞"],
    yi: ["弬"],
    shāo: [
      "弰",
      "旓",
      "烧",
      "焼",
      "燒",
      "筲",
      "艄",
      "萷",
      "蕱",
      "輎",
      "髾",
      "鮹"
    ],
    "xuān yuān": ["弲"],
    "qiáng qiǎng jiàng": ["強", "强"],
    "tán dàn": ["弹", "醈"],
    biè: ["彆"],
    "qiáng jiàng qiǎng": ["彊"],
    "jì xuě": ["彐"],
    tuàn: ["彖", "褖"],
    yuē: ["彟", "曰", "曱", "矱"],
    "shān xiǎn": ["彡"],
    wén: [
      "彣",
      "文",
      "炆",
      "珳",
      "瘒",
      "繧",
      "聞",
      "芠",
      "蚉",
      "蚊",
      "螡",
      "蟁",
      "閺",
      "閿",
      "闅",
      "闦",
      "闻",
      "阌",
      "雯",
      "馼",
      "駇",
      "魰",
      "鳼",
      "鴍",
      "鼤",
      "𫘜"
    ],
    "péng bāng": ["彭"],
    "piāo piào": ["彯"],
    "zhuó bó": ["彴"],
    "tuǒ yí": ["彵"],
    "páng fǎng": ["彷"],
    wǎng: [
      "彺",
      "往",
      "徃",
      "惘",
      "枉",
      "棢",
      "網",
      "网",
      "罒",
      "罓",
      "罔",
      "罖",
      "菵",
      "蛧",
      "蝄",
      "誷",
      "輞",
      "辋",
      "魍"
    ],
    cú: ["徂", "殂"],
    "dài dāi": ["待"],
    huái: ["徊", "怀", "懐", "懷", "槐", "淮", "耲", "蘹", "褢", "褱", "踝"],
    "wā wàng jiā": ["徍"],
    "chěng zhèng": ["徎"],
    "dé děi de": ["得"],
    "cóng zòng": ["從"],
    "shì tǐ": ["徥"],
    "tí chí": ["徲", "鶗", "鶙"],
    dé: ["徳", "德", "恴", "悳", "惪", "淂", "鍀", "锝"],
    "zhǐ zhēng": ["徴", "徵"],
    bié: ["徶", "癿", "莂", "蛂", "襒", "蹩"],
    "chōng zhǒng": ["徸"],
    "jiǎo jiào": ["徼", "笅", "筊"],
    "lòng lǒng": ["徿"],
    "qú jù": ["忂", "渠", "瞿", "螶"],
    "dìng tìng": ["忊"],
    gǎi: ["忋", "改"],
    rěn: ["忍", "栠", "栣", "秹", "稔", "綛", "荏", "荵", "躵"],
    chàn: ["忏", "懴", "懺", "硟", "羼", "韂", "顫"],
    tè: ["忑", "慝", "特", "蟘", "鋱", "铽"],
    "tè tēi tuī": ["忒"],
    "gān hàn": ["忓", "攼"],
    "yì qì": ["忔"],
    "tài shì": ["忕"],
    "xī liě": ["忚"],
    "yīng yìng": ["応", "應", "譍"],
    "mǐn wěn mín": ["忞", "忟"],
    "sōng zhōng": ["忪"],
    "yù shū": ["忬", "悆"],
    "qí shì": ["忯", "耆"],
    "tún zhūn dùn": ["忳"],
    "qián qín": ["忴", "扲"],
    hún: ["忶", "浑", "渾", "餛", "馄", "魂", "鼲"],
    niǔ: ["忸", "扭", "炄", "狃", "紐", "纽", "莥", "鈕", "钮", "靵"],
    "kuáng wǎng": ["忹"],
    "kāng hàng": ["忼"],
    "kài xì": ["忾", "愾"],
    òu: ["怄", "慪"],
    "bǎo bào": ["怉"],
    "mín mén": ["怋"],
    "zuò zhà": ["怍"],
    zěn: ["怎"],
    yàng: ["怏", "恙", "样", "様", "樣", "漾", "羕", "詇"],
    "kòu jù": ["怐"],
    "náo niú": ["怓"],
    "zhēng zhèng": ["怔", "掙", "钲", "铮"],
    "tiē zhān": ["怗"],
    "hù gù": ["怘"],
    "cū jù zū": ["怚"],
    "sī sāi": ["思"],
    "yóu chóu": ["怞"],
    "tū dié": ["怢"],
    "yōu yào": ["怮"],
    xuàn: [
      "怰",
      "昡",
      "楦",
      "泫",
      "渲",
      "炫",
      "琄",
      "眩",
      "碹",
      "絢",
      "縼",
      "繏",
      "绚",
      "蔙",
      "衒",
      "袨",
      "贙",
      "鉉",
      "鏇",
      "铉",
      "镟",
      "颴"
    ],
    "xù xuè": ["怴"],
    "bì pī": ["怶"],
    "xī shù": ["怸"],
    "nèn nín": ["恁"],
    "tiāo yáo": ["恌"],
    "xī qī xù": ["恓"],
    "xiào jiǎo": ["恔"],
    "hū kuā": ["恗"],
    nǜ: ["恧", "朒", "衂", "衄"],
    hèn: ["恨"],
    "dòng tōng": ["恫"],
    "quán zhuān": ["恮"],
    "è wù ě wū": ["恶", "惡"],
    tòng: ["恸", "慟", "憅", "痛", "衕"],
    "yuān juàn": ["悁"],
    "qiāo qiǎo": ["悄"],
    "jiè kè": ["悈"],
    "hào jiào": ["悎"],
    huǐ: ["悔", "檓", "毀", "毁", "毇", "燬", "譭"],
    "mán mèn": ["悗", "鞔"],
    "yī yì": ["悘", "衣"],
    quān: ["悛", "箞", "鐉", "𨟠"],
    "kuī lǐ": ["悝"],
    "yì niàn": ["悥"],
    "mèn mēn": ["悶"],
    guàn: [
      "悹",
      "悺",
      "惯",
      "慣",
      "掼",
      "摜",
      "樌",
      "欟",
      "泴",
      "涫",
      "潅",
      "灌",
      "爟",
      "瓘",
      "盥",
      "礶",
      "祼",
      "罆",
      "罐",
      "貫",
      "贯",
      "躀",
      "遦",
      "鏆",
      "鑵",
      "鱹",
      "鸛",
      "鹳"
    ],
    "kōng kǒng": ["悾"],
    "lǔn lùn": ["惀"],
    guǒ: [
      "惈",
      "果",
      "椁",
      "槨",
      "粿",
      "綶",
      "菓",
      "蜾",
      "裹",
      "褁",
      "輠",
      "餜",
      "馃"
    ],
    "yuān wǎn": ["惌", "箢"],
    "lán lín": ["惏"],
    "yù xù": ["惐", "淢"],
    "chuò chuì": ["惙"],
    "hūn mèn": ["惛"],
    "chǎng tǎng": ["惝"],
    "suǒ ruǐ": ["惢"],
    cǎn: ["惨", "慘", "憯", "黪", "黲", "䅟"],
    cán: ["惭", "慙", "慚", "残", "殘", "蚕", "蝅", "蠶", "蠺"],
    "dàn dá": ["惮", "憚"],
    rě: ["惹"],
    "yú tōu": ["愉"],
    "kài qì": ["愒"],
    "dàng táng shāng yáng": ["愓"],
    "chén xìn dān": ["愖"],
    "kè qià": ["愘"],
    nuò: [
      "愞",
      "懦",
      "懧",
      "掿",
      "搦",
      "榒",
      "稬",
      "穤",
      "糑",
      "糥",
      "糯",
      "諾",
      "诺",
      "蹃",
      "逽",
      "鍩",
      "锘"
    ],
    gǎn: [
      "感",
      "擀",
      "敢",
      "桿",
      "橄",
      "澉",
      "澸",
      "皯",
      "秆",
      "稈",
      "笴",
      "芉",
      "衦",
      "赶",
      "趕",
      "鱤",
      "鳡"
    ],
    "còng sōng": ["愡"],
    "sāi sī sǐ": ["愢"],
    "gōng gòng hǒng": ["愩", "慐"],
    "shuò sù": ["愬", "洬"],
    "yáo yào": ["愮"],
    huàng: ["愰", "曂", "榥", "滉", "皝", "皩", "鎤", "㿠"],
    zhěng: ["愸", "抍", "拯", "整", "晸"],
    cǎo: ["愺", "艸", "草", "騲"],
    "xì xié": ["慀"],
    "cǎo sāo": ["慅"],
    "xù chù": ["慉"],
    "qiè qiàn": ["慊"],
    "cáo cóng": ["慒"],
    "ào áo": ["慠"],
    "lián liǎn": ["慩", "梿", "槤", "櫣"],
    "jìn qín jǐn": ["慬"],
    "dì chì": ["慸"],
    "zhí zhé": ["慹"],
    "lóu lǚ": ["慺", "鷜"],
    còng: ["憁", "謥"],
    "zhī zhì": ["憄", "知", "織", "织"],
    chēng: [
      "憆",
      "摚",
      "撐",
      "撑",
      "晿",
      "柽",
      "棦",
      "橕",
      "檉",
      "泟",
      "浾",
      "琤",
      "瞠",
      "碀",
      "緽",
      "罉",
      "蛏",
      "蟶",
      "赪",
      "赬",
      "鏿",
      "鐣",
      "阷",
      "靗",
      "頳",
      "饓"
    ],
    biē: ["憋", "虌", "鱉", "鳖", "鼈", "龞"],
    "chéng dèng zhèng": ["憕"],
    "xǐ xī": ["憘"],
    "duì dùn tūn": ["憞"],
    "xiāo jiāo": ["憢"],
    "xián xiàn": ["憪"],
    "liáo liǎo": ["憭", "燎", "爎", "爒"],
    shéng: ["憴", "縄", "繉", "繩", "绳", "譝"],
    "náo nǎo náng": ["憹"],
    "jǐng jìng": ["憼"],
    "jǐ jiǎo": ["憿"],
    "xuān huān": ["懁"],
    "cǎo sāo sào": ["懆"],
    mèn: ["懑", "懣", "暪", "焖", "燜"],
    "mèng méng měng": ["懜"],
    "ài yì nǐ": ["懝"],
    "méng měng": ["懞", "瞢", "矒"],
    "qí jī jì": ["懠"],
    mǒ: ["懡"],
    "lán xiàn": ["懢"],
    "yōu yǒu": ["懮"],
    "liú liǔ": ["懰", "藰"],
    ràng: ["懹", "譲", "讓", "让"],
    huān: ["懽", "欢", "歓", "歡", "獾", "讙", "貛", "酄", "驩", "鴅", "鵍"],
    nǎn: ["戁", "揇", "湳", "煵", "腩", "蝻", "赧"],
    "mí mó": ["戂"],
    "gàng zhuàng": ["戅", "戆"],
    "zhuàng gàng": ["戇"],
    "xū qu": ["戌"],
    "xì hū": ["戏", "戯", "戲"],
    "jiá gā": ["戛"],
    zéi: ["戝", "蠈", "賊", "贼", "鰂", "鱡", "鲗"],
    děng: ["戥", "等"],
    "hū xì": ["戱"],
    chuō: ["戳", "踔", "逴"],
    "biǎn piān": ["扁"],
    "shǎng jiōng": ["扄"],
    "shàn shān": ["扇"],
    cái: ["才", "材", "纔", "裁", "財", "财"],
    "zhā zā zhá": ["扎"],
    "lè lì cái": ["扐"],
    "bā pá": ["扒"],
    "dǎ dá": ["打"],
    rēng: ["扔"],
    "fǎn fú": ["払"],
    "diǎo dí yuē lì": ["扚"],
    "káng gāng": ["扛"],
    "yū wū": ["扜"],
    "yū wū kū": ["扝"],
    "tuō chǐ yǐ": ["扡"],
    "gǔ jié xì gē": ["扢"],
    dèn: ["扥", "扽"],
    "sǎo sào": ["扫", "掃"],
    rǎo: ["扰", "擾", "隢"],
    "xī chā qì": ["扱"],
    "bān pān": ["扳"],
    "bā ào": ["扷"],
    "xī zhé": ["扸"],
    "zhì sǔn kǎn": ["扻"],
    zhǎo: ["找", "沼", "瑵"],
    "kuáng wǎng zài": ["抂"],
    "hú gǔ": ["抇", "鹄", "鹘"],
    "bǎ bà": ["把"],
    "dǎn shěn": ["抌"],
    "nè nì ruì nà": ["抐"],
    zhuā: ["抓", "檛", "簻", "膼", "髽"],
    póu: ["抔", "裒"],
    "zhé shé zhē": ["折"],
    "póu pōu fū": ["抙", "捊"],
    pāo: ["抛", "拋", "脬", "萢"],
    "ǎo ào niù": ["抝"],
    "lūn lún": ["抡", "掄"],
    "qiǎng qiāng chēng": ["抢"],
    "zhǐ zhǎi": ["抧"],
    "bù pū": ["抪", "柨"],
    "yǎo tāo": ["抭"],
    "hē hè qiā": ["抲"],
    "nǐ ní": ["抳"],
    "pī pēi": ["抷"],
    "mǒ mò mā": ["抹"],
    chōu: ["抽", "犨", "犫", "瘳", "篘"],
    "jiā yá": ["拁"],
    "fú bì": ["拂", "畐", "鶝"],
    zhǎ: ["拃", "眨", "砟", "鮺", "鲝"],
    "dān dàn dǎn": ["担"],
    "chāi cā": ["拆"],
    niān: ["拈", "蔫"],
    "lā lá lǎ là": ["拉"],
    "bàn pàn": ["拌"],
    pāi: ["拍"],
    līn: ["拎"],
    guǎi: ["拐", "枴", "柺"],
    "tuò tà zhí": ["拓"],
    "ào ǎo niù": ["拗"],
    "jū gōu": ["拘"],
    "pīn pàn fān": ["拚"],
    "bài bái": ["拜"],
    bài: ["拝", "敗", "稗", "粺", "薭", "贁", "败", "韛"],
    qiá: ["拤"],
    "nǐng níng nìng": ["拧"],
    "zé zhái": ["择", "擇"],
    hén: ["拫", "痕", "鞎"],
    "kuò guā": ["括"],
    "jié jiá": ["拮"],
    nǐn: ["拰"],
    shuān: ["拴", "栓", "閂", "闩"],
    "cún zùn": ["拵"],
    "zā zǎn": ["拶", "桚"],
    kǎo: ["拷", "攷", "栲", "烤", "考"],
    "yí chǐ hài": ["拸"],
    "cè sè chuò": ["拺"],
    "zhuài zhuāi yè": ["拽"],
    "shí shè": ["拾"],
    bāi: ["挀", "掰"],
    "kuò guāng": ["挄"],
    nòng: ["挊", "挵", "齈"],
    "jiào jiāo": ["挍", "敎", "教"],
    "kuà kū": ["挎"],
    "ná rú": ["挐"],
    "tiāo tiǎo": ["挑"],
    "dié shè": ["挕"],
    liě: ["挘", "毟"],
    "yà yǎ": ["挜", "掗"],
    "wō zhuā": ["挝"],
    "xié jiā": ["挟", "挾"],
    "dǎng dàng": ["挡", "擋"],
    "zhèng zhēng": ["挣", "正", "症"],
    "āi ái": ["挨"],
    "tuō shuì": ["挩", "捝"],
    "tǐ tì": ["挮"],
    "suō shā": ["挱"],
    "sā shā suō": ["挲"],
    "kēng qiān": ["挳", "摼"],
    "bàng péng": ["挷"],
    "ruó ruá": ["挼"],
    "jiǎo kù": ["捁"],
    "wǔ wú": ["捂"],
    tǒng: ["捅", "桶", "筒", "筩", "統", "綂", "统", "㛚"],
    "huò chì": ["捇"],
    "tú shū chá": ["捈"],
    "lǚ luō": ["捋"],
    "shāo shào": ["捎", "稍"],
    niē: ["捏", "揑"],
    "shù sǒng sōu": ["捒"],
    "yé yú": ["捓"],
    "jué zhuó": ["捔"],
    "bù pú zhì": ["捗"],
    zùn: ["捘", "銌"],
    lāo: ["捞", "撈", "粩"],
    sǔn: ["损", "損", "榫", "笋", "筍", "箰", "鎨", "隼"],
    "wàn wǎn wān yù": ["捥"],
    pěng: ["捧", "淎", "皏"],
    shě: ["捨"],
    "fǔ fù bǔ": ["捬"],
    dáo: ["捯"],
    "luò luǒ wǒ": ["捰"],
    "juǎn quán": ["捲"],
    "chēn tiǎn": ["捵"],
    "niǎn niē": ["捻"],
    "ruó wěi ré": ["捼"],
    zuó: ["捽", "昨", "秨", "稓", "筰", "莋", "鈼"],
    "wò xiá": ["捾"],
    "qìng qiàn": ["掅"],
    "póu pǒu": ["掊"],
    qiā: ["掐", "葜"],
    "pái pǎi": ["排"],
    "qiān wàn": ["掔"],
    "yè yē": ["掖"],
    "niè nǐ yì": ["掜"],
    "huò xù": ["掝"],
    "yàn shàn yǎn": ["掞"],
    "zhěng dìng": ["掟"],
    kòng: ["控", "鞚"],
    tuī: ["推", "蓷", "藬"],
    "zōu zhōu chōu": ["掫"],
    tiàn: ["掭", "舚"],
    kèn: ["掯", "裉", "褃"],
    pá: ["掱", "杷", "潖", "爬", "琶", "筢"],
    "guó guāi": ["掴"],
    "dǎn shàn": ["掸", "撣"],
    "chān xiān càn shǎn": ["掺"],
    sāo: ["掻", "搔", "溞", "繅", "缫", "螦", "騒", "騷", "鰠", "鱢", "鳋"],
    pèng: ["掽", "椪", "槰", "碰", "踫"],
    "zhēng kēng": ["揁"],
    "jiū yóu": ["揂"],
    "jiān jiǎn": ["揃", "籛"],
    "pì chè": ["揊"],
    "sāi zǒng cāi": ["揌"],
    "tí dī dǐ": ["提"],
    "zǒng sōng": ["揔"],
    "huáng yóng": ["揘"],
    "zǎn zuàn": ["揝"],
    "xū jū": ["揟"],
    "ké qiā": ["揢"],
    "chuāi chuǎi chuài tuán zhuī": ["揣"],
    "dì tì": ["揥"],
    "lá là": ["揦"],
    là: [
      "揧",
      "楋",
      "溂",
      "瓎",
      "瘌",
      "翋",
      "臘",
      "蝋",
      "蝲",
      "蠟",
      "辢",
      "辣",
      "鑞",
      "镴",
      "鬎",
      "鯻",
      "𬶟"
    ],
    "jiē qì": ["揭"],
    "chòng dǒng": ["揰"],
    "dié shé yè": ["揲"],
    "jiàn qián jiǎn": ["揵"],
    yé: ["揶", "爷", "爺", "瑘", "鋣", "鎁", "铘"],
    chān: ["搀", "摻", "攙", "裧", "襜", "覘", "觇", "辿", "鋓"],
    "gē gé": ["搁", "擱"],
    "lǒu lōu": ["搂", "摟"],
    "chōu zǒu": ["搊"],
    chuāi: ["搋"],
    sūn: ["搎", "槂", "狲", "猻", "荪", "蓀", "蕵", "薞", "飧", "飱"],
    "róng náng nǎng": ["搑"],
    "péng bàng": ["搒"],
    cuō: ["搓", "瑳", "磋", "蹉", "遳", "醝"],
    "kē è": ["搕"],
    "nù nuò nòu": ["搙"],
    "lā xié xiàn": ["搚"],
    qiǔ: ["搝", "糗"],
    "xiǎn xiān": ["搟"],
    "jié zhé": ["搩"],
    "pán bān pó": ["搫"],
    bān: [
      "搬",
      "攽",
      "斑",
      "斒",
      "班",
      "瘢",
      "癍",
      "肦",
      "螁",
      "螌",
      "褩",
      "辬",
      "頒",
      "颁",
      "𨭉"
    ],
    "zhì nái": ["搱"],
    "wā wǎ wà": ["搲"],
    huá: ["搳", "撶", "滑", "猾", "蕐", "螖", "譁", "鏵", "铧", "驊", "骅", "鷨"],
    "qiāng qiǎng chēng": ["搶"],
    "tián shēn": ["搷"],
    "ná nuò": ["搻"],
    èn: ["摁"],
    "shè niè": ["摄", "攝"],
    bìn: ["摈", "擯", "殡", "殯", "膑", "臏", "髌", "髕", "髩", "鬂", "鬓", "鬢"],
    "shā sà shǎi": ["摋"],
    "chǎn sùn": ["摌"],
    "jiū liú liáo jiǎo náo": ["摎"],
    "féng pěng": ["摓"],
    shuāi: ["摔"],
    "dì tú zhí": ["摕"],
    "qì jì chá": ["摖"],
    "sōu sǒng": ["摗"],
    "liǎn liàn": ["摙"],
    "gài xì": ["摡"],
    "hù chū": ["摢"],
    tàng: ["摥", "烫", "燙", "鐋"],
    "nái zhì": ["摨"],
    "mó mā": ["摩"],
    "jiāng qiàng": ["摪"],
    "áo qiáo": ["摮"],
    "niè chè": ["摰"],
    "mán màn": ["摱"],
    "chàn cán": ["摲"],
    "sè mí sù": ["摵"],
    "biāo biào": ["摽"],
    "juē jué": ["撅"],
    piē: ["撆", "暼", "氕", "瞥"],
    "piě piē": ["撇"],
    "zǎn zān zēn qián": ["撍"],
    "sā sǎ": ["撒"],
    hòng: ["撔", "訌", "讧", "闀", "鬨"],
    "héng guàng": ["撗"],
    niǎn: [
      "撚",
      "撵",
      "攆",
      "涊",
      "焾",
      "碾",
      "簐",
      "蹍",
      "蹨",
      "躎",
      "輦",
      "辇"
    ],
    "chéng zhěng": ["撜"],
    "huī wéi": ["撝"],
    cāo: ["撡", "操", "糙"],
    "xiāo sōu": ["撨"],
    "liáo liāo": ["撩"],
    "cuō zuǒ": ["撮"],
    "wěi tuǒ": ["撱"],
    cuān: ["撺", "攛", "汆", "蹿", "躥", "鑹", "镩"],
    "qiào yāo jī": ["撽"],
    "zhuā wō": ["撾"],
    "lèi léi": ["擂"],
    nǎng: ["擃", "攮", "曩", "灢"],
    "qíng jǐng": ["擏"],
    kuǎi: ["擓", "蒯", "㧟"],
    "pǐ bò": ["擗"],
    "bò bāi": ["擘"],
    "jù jǐ": ["據"],
    mēng: ["擝"],
    "sǒu sòu": ["擞"],
    xǐng: ["擤", "箵", "醒"],
    cā: ["擦"],
    "níng nǐng nìng": ["擰"],
    "zhì jié": ["擳"],
    "là liè": ["擸", "爉"],
    "sòu sǒu": ["擻"],
    "lì luò yuè": ["擽"],
    "tī zhāi zhì": ["擿"],
    pān: ["攀", "潘", "眅", "萠"],
    lèi: [
      "攂",
      "泪",
      "涙",
      "淚",
      "禷",
      "类",
      "纇",
      "蘱",
      "酹",
      "銇",
      "錑",
      "頛",
      "頪",
      "類",
      "颣"
    ],
    "cā sǎ": ["攃"],
    "jùn pèi": ["攈"],
    "lì luò": ["攊", "躒"],
    "là lài": ["攋", "櫴"],
    "lú luó": ["攎"],
    "zǎn cuán": ["攒"],
    "xiān jiān": ["攕"],
    "mí mǐ mó": ["攠"],
    "zǎn cuán zàn zuān": ["攢"],
    zuàn: ["攥"],
    "lì shài": ["攦"],
    "lì luǒ": ["攭"],
    "guǐ guì": ["攱"],
    "jī qī yǐ": ["攲"],
    fàng: ["放"],
    "wù móu": ["敄"],
    "chù shōu": ["敊"],
    "gé guó è": ["敋"],
    "duó duì": ["敓", "敚"],
    "duō què": ["敠", "敪"],
    "sàn sǎn": ["散"],
    "dūn duì": ["敦", "镦"],
    "qī yǐ jī": ["敧"],
    "xiào xué": ["敩"],
    "shù shǔ shuò": ["数", "數"],
    "ái zhú": ["敱", "敳"],
    "xiòng xuàn": ["敻"],
    "zhuó zhú": ["斀"],
    "yì dù": ["斁"],
    "lí tái": ["斄"],
    "fěi fēi": ["斐"],
    "yǔ zhōng": ["斔"],
    "dòu dǒu": ["斗"],
    "wò guǎn": ["斡"],
    "tǒu tiǎo": ["斢"],
    dòu: [
      "斣",
      "梪",
      "浢",
      "痘",
      "窦",
      "竇",
      "脰",
      "荳",
      "豆",
      "逗",
      "郖",
      "酘",
      "閗",
      "闘",
      "餖",
      "饾",
      "鬥",
      "鬦",
      "鬪",
      "鬬",
      "鬭"
    ],
    "yín zhì": ["斦"],
    "chǎn jiè": ["斺"],
    "wū yū yú": ["於"],
    "yóu liú": ["斿"],
    "páng bàng": ["旁"],
    "máo mào": ["旄"],
    "pī bì": ["旇"],
    "xuán xuàn": ["旋"],
    "wú mó": ["无"],
    zǎo: ["早", "枣", "栆", "棗", "澡", "璪", "薻", "藻", "蚤"],
    gā: ["旮"],
    "gàn hàn": ["旰"],
    "tái yīng": ["旲"],
    "xū xù": ["旴"],
    "tūn zhùn": ["旽"],
    "wù wǔ": ["旿"],
    "pò pèi": ["昢"],
    zòng: ["昮", "猔", "疭", "瘲", "粽", "糉", "糭", "縦"],
    ǎi: ["昹", "毐", "矮", "蔼", "藹", "譪", "躷", "霭", "靄"],
    "huàng huǎng": ["晃"],
    xuǎn: ["晅", "癣", "癬", "选", "選"],
    "xù kuā": ["晇"],
    hǒng: ["晎"],
    shài: ["晒", "曬"],
    "yūn yùn": ["晕", "煴"],
    "shèng chéng": ["晟", "椉", "盛"],
    "jǐng yǐng": ["景"],
    shǎn: ["晱", "熌", "睒", "覢", "閃", "闪", "陕", "陝"],
    "qǐ dù": ["晵"],
    "ǎn àn yǎn": ["晻"],
    "wǎng wàng": ["暀"],
    zàn: [
      "暂",
      "暫",
      "瓉",
      "瓒",
      "瓚",
      "禶",
      "襸",
      "讃",
      "讚",
      "賛",
      "贊",
      "赞",
      "蹔",
      "鄼",
      "錾",
      "鏨",
      "饡"
    ],
    "yùn yūn": ["暈"],
    "mín mǐn": ["暋"],
    "dǔ shǔ": ["暏"],
    shǔ: [
      "暑",
      "曙",
      "潻",
      "癙",
      "糬",
      "署",
      "薥",
      "薯",
      "藷",
      "蜀",
      "蠴",
      "襡",
      "襩",
      "鱪",
      "鱰",
      "黍",
      "鼠",
      "鼡"
    ],
    "jiǎn lán": ["暕"],
    nuǎn: ["暖", "煗", "餪"],
    "bào pù": ["暴"],
    "xī xǐ": ["暿"],
    "pù bào": ["曝", "瀑"],
    "qū qǔ": ["紶"],
    "qǔ qū": ["曲"],
    "gèng gēng": ["更"],
    "hū hù": ["曶", "雽"],
    "zēng céng": ["曽", "橧"],
    "céng zēng": ["曾", "竲"],
    "cǎn qián jiàn": ["朁"],
    "qiè hé": ["朅"],
    "bì pí": ["朇", "禆", "笓", "裨"],
    "yǒu yòu": ["有"],
    "bān fén": ["朌", "鳻"],
    "fú fù": ["服", "洑"],
    "fěi kū": ["朏", "胐"],
    "qú xù chǔn": ["朐"],
    "juān zuī": ["朘"],
    "huāng máng wáng": ["朚"],
    "qī jī": ["期"],
    "tóng chuáng": ["朣", "橦"],
    zhá: ["札", "牐", "箚", "蚻", "譗", "鍘", "铡", "閘", "闸"],
    "zhú shù shú": ["朮"],
    "shù shú zhú": ["术"],
    "zhū shú": ["朱"],
    "pǔ pò pō piáo": ["朴"],
    "dāo tiáo mù": ["朷"],
    "guǐ qiú": ["朹"],
    xiǔ: ["朽", "滫", "潃", "糔"],
    "chéng chēng": ["朾"],
    zá: ["杂", "沯", "砸", "襍", "雑", "雜", "雥", "韴"],
    "yú wū": ["杅"],
    "gān gǎn": ["杆"],
    "chā chà": ["杈"],
    "shān shā": ["杉"],
    cūn: ["村", "皴", "竴", "膥", "踆", "邨"],
    "rèn ér": ["杒", "梕"],
    "sháo biāo": ["杓"],
    "dì duò": ["杕", "枤"],
    "gū gài": ["杚"],
    "yí zhì lí duò": ["杝"],
    "gàng gāng": ["杠"],
    "tiáo tiāo": ["条", "條"],
    "mà mǎ": ["杩"],
    "sì zhǐ xǐ": ["杫"],
    "yuán wán": ["杬", "蚖"],
    "bèi fèi": ["杮"],
    "shū duì": ["杸"],
    "niǔ chǒu": ["杻"],
    "wò yuè": ["枂", "臒"],
    máo: [
      "枆",
      "毛",
      "氂",
      "渵",
      "牦",
      "矛",
      "罞",
      "茅",
      "茆",
      "蝥",
      "蟊",
      "軞",
      "酕",
      "鉾",
      "錨",
      "锚",
      "髦",
      "鶜"
    ],
    "pī mì": ["枈"],
    àng: ["枊", "盎", "醠"],
    "fāng bìng": ["枋"],
    "hù dǐ": ["枑"],
    xín: ["枔", "襑", "鐔", "鬵"],
    "yāo yǎo": ["枖"],
    "ě è": ["枙"],
    "zhī qí": ["枝"],
    "cōng zōng": ["枞", "樅"],
    "xiān zhēn": ["枮"],
    "tái sì": ["枱"],
    "gǒu jǔ gōu": ["枸"],
    "bāo fú": ["枹"],
    "yì xiè": ["枻", "栧"],
    "tuó duò": ["柁", "馱", "駄", "驮"],
    "yí duò lí": ["柂"],
    "nǐ chì": ["柅"],
    "pán bàn": ["柈", "跘"],
    "yǎng yàng yāng yīng": ["柍"],
    "fù fū fǔ": ["柎"],
    "bǎi bó bò": ["柏"],
    mǒu: ["某"],
    "sháo shào": ["柖"],
    zhè: ["柘", "樜", "浙", "淛", "蔗", "蟅", "這", "鷓", "鹧", "䗪"],
    "yòu yóu": ["柚", "櫾"],
    "guì jǔ": ["柜"],
    "zhà zuò": ["柞"],
    "dié zhì": ["柣", "眰"],
    "zhā zǔ zū": ["柤"],
    "chá zhā": ["查", "査"],
    "āo ào": ["柪", "軪"],
    "bā fú pèi bó biē": ["柭"],
    "duò zuó wù": ["柮"],
    "bì bié": ["柲"],
    "zhù chù": ["柷"],
    "bēi pēi": ["柸"],
    "shì fèi": ["柹"],
    "shān zhà shi cè": ["栅"],
    "lì yuè": ["栎", "櫟"],
    "qì qiè": ["栔", "砌"],
    "qī xī": ["栖", "蹊"],
    "guā kuò": ["栝"],
    "bīng bēn": ["栟"],
    "xiào jiào": ["校"],
    "jiàn zùn": ["栫", "袸"],
    "yǒu yù": ["栯"],
    "hé hú": ["核"],
    gēn: ["根", "跟"],
    "zhī yì": ["栺"],
    "gé gē": ["格"],
    "héng háng": ["桁"],
    "guàng guāng": ["桄"],
    "yí tí": ["桋", "荑"],
    sāng: ["桑", "桒", "槡"],
    "jú jié": ["桔"],
    "yú móu": ["桙"],
    "ráo náo": ["桡", "橈"],
    "guì huì": ["桧", "檜"],
    "chén zhèn": ["桭"],
    "tīng yíng": ["桯"],
    "bó po": ["桲"],
    "bèn fàn": ["桳"],
    "fēng fèng": ["桻", "葑"],
    "sù yìn": ["梀"],
    "tǐng tìng": ["梃"],
    "xuān juān xié": ["梋"],
    "tú chá": ["梌"],
    "āo yòu": ["梎"],
    kuǎn: ["梡", "欵", "款", "歀"],
    "shāo sào": ["梢"],
    "qín chén cén": ["梣"],
    "lí sì qǐ": ["梩"],
    "chān yán": ["梴"],
    "bīn bīng": ["梹", "槟", "檳"],
    "táo chóu dào": ["梼"],
    "cōng sōng": ["棇"],
    "gùn hùn": ["棍"],
    "dé zhé": ["棏"],
    "pái bèi pèi": ["棑"],
    "bàng pǒu bèi bēi": ["棓"],
    "dì dài tì": ["棣"],
    sēn: ["森", "椮", "槮", "襂"],
    "rěn shěn": ["棯"],
    "léng lēng líng": ["棱"],
    "fú sù": ["棴"],
    "zōu sǒu": ["棷"],
    zōu: [
      "棸",
      "箃",
      "緅",
      "諏",
      "诹",
      "邹",
      "郰",
      "鄒",
      "鄹",
      "陬",
      "騶",
      "驺",
      "鯫",
      "鲰",
      "黀",
      "齱",
      "齺"
    ],
    "zhào zhuō": ["棹"],
    "chēn shēn": ["棽"],
    "jiē qiè": ["椄"],
    "yǐ yī": ["椅"],
    "chóu zhòu diāo": ["椆"],
    "qiāng kōng": ["椌"],
    "zhuī chuí": ["椎"],
    "bēi pí": ["椑"],
    mēn: ["椚"],
    "quān juàn quán": ["椦"],
    "duǒ chuán": ["椯"],
    "wěi huī": ["椲"],
    "jiǎ jiā": ["椵"],
    "hán jiān": ["椷"],
    "shèn zhēn": ["椹"],
    "yàn yà": ["椻"],
    "zhā chá": ["楂"],
    "guō kuǎ": ["楇"],
    "jí zhì": ["楖"],
    "kǔ hù": ["楛"],
    "yóu yǒu": ["楢"],
    "sǒng cōng": ["楤"],
    "yuán xuàn": ["楥"],
    "yǎng yàng yīng": ["楧"],
    pián: ["楩", "胼", "腁", "賆", "蹁", "駢", "騈", "骈", "骿", "㛹"],
    "dié yè": ["楪"],
    "dùn shǔn": ["楯"],
    "còu zòu": ["楱"],
    "dì dǐ shì": ["楴"],
    "kǎi jiē": ["楷"],
    "róu ròu": ["楺"],
    "lè yuè": ["楽"],
    "wēn yùn": ["榅", "鞰"],
    lǘ: ["榈", "櫚", "氀", "膢", "藘", "閭", "闾", "驢", "驴"],
    shén: ["榊", "神", "鉮", "鰰", "𬬹"],
    "bī pi": ["榌"],
    "zhǎn niǎn zhèn": ["榐"],
    "fú fù bó": ["榑"],
    "jiàn jìn": ["榗"],
    "bǎng bàng": ["榜"],
    "shā xiè": ["榝", "樧"],
    nòu: ["槈", "耨", "鎒", "鐞"],
    "qiǎn lián xiàn": ["槏"],
    gàng: ["槓", "焵", "焹", "筻", "鿍"],
    gāo: [
      "槔",
      "槹",
      "橰",
      "櫜",
      "睾",
      "篙",
      "糕",
      "羔",
      "臯",
      "韟",
      "餻",
      "高",
      "髙",
      "鷎",
      "鷱",
      "鼛"
    ],
    "diān zhěn zhēn": ["槙"],
    "kǎn jiàn": ["槛"],
    "xí dié": ["槢"],
    "jī guī": ["槣"],
    "róng yōng": ["槦"],
    "tuán shuàn quán": ["槫"],
    "qì sè": ["槭"],
    "cuī zhǐ": ["槯"],
    "yǒu chǎo": ["槱"],
    "màn wàn": ["槾"],
    "lí chī": ["樆"],
    "léi lěi": ["樏", "櫑", "礌"],
    "cháo jiǎo chāo": ["樔"],
    "chēng táng": ["樘"],
    "jiū liáo": ["樛"],
    "mó mú": ["模"],
    "niǎo mù": ["樢"],
    "héng hèng": ["横", "橫"],
    xuě: ["樰", "膤", "艝", "轌", "雪", "鱈", "鳕"],
    "fá fèi": ["橃"],
    rùn: ["橍", "润", "潤", "膶", "閏", "閠", "闰"],
    "zhǎn jiǎn": ["橏"],
    shùn: ["橓", "瞚", "瞬", "舜", "蕣", "順", "顺", "鬊"],
    "tuí dūn": ["橔"],
    "táng chēng": ["橖"],
    "sù qiū": ["橚"],
    "tán diàn": ["橝"],
    "fén fèn fèi": ["橨"],
    "rǎn yān": ["橪"],
    "cū chu": ["橻"],
    "shū qiāo": ["橾"],
    "píng bò": ["檘"],
    "zhái shì tú": ["檡"],
    "biǎo biāo": ["檦"],
    "qiān lián": ["檶"],
    "nǐ mí": ["檷"],
    "jiàn kǎn": ["檻"],
    "nòu ruǎn rú": ["檽"],
    "jī jì": ["櫅", "禨"],
    "huǎng guǒ gǔ": ["櫎"],
    "lǜ chū": ["櫖"],
    "miè mèi": ["櫗"],
    ōu: [
      "櫙",
      "欧",
      "歐",
      "殴",
      "毆",
      "瓯",
      "甌",
      "膒",
      "藲",
      "謳",
      "讴",
      "鏂",
      "鴎",
      "鷗",
      "鸥"
    ],
    "zhù zhuó": ["櫡"],
    "jué jì": ["櫭"],
    "huái guī": ["櫰"],
    "chán zhàn": ["欃"],
    "wéi zuì": ["欈"],
    cáng: ["欌", "鑶"],
    "yù yì": ["欥"],
    "chù qù xì": ["欪"],
    "kài ài": ["欬"],
    "yì yīn": ["欭"],
    "xì kài": ["欯"],
    "shuò sòu": ["欶"],
    "ǎi ēi éi ěi èi ê̄ ế ê̌ ề": ["欸"],
    "qī yī": ["欹"],
    "chuā xū": ["欻"],
    "chǐ chuài": ["欼"],
    "kǎn qiàn": ["欿"],
    "kǎn kè": ["歁"],
    "chuǎn chuán": ["歂"],
    "yīn yān": ["歅"],
    "jìn qūn": ["歏"],
    pēn: ["歕"],
    "xū chuā": ["歘"],
    "xī shè": ["歙"],
    "liǎn hān": ["歛"],
    "zhì chí": ["歭"],
    "sè shà": ["歰"],
    sǐ: ["死"],
    "wěn mò": ["歾"],
    piǎo: ["殍", "皫", "瞟", "醥", "顠"],
    "qíng jìng": ["殑"],
    "fǒu bó": ["殕"],
    "zhí shi": ["殖"],
    "yè yān yàn": ["殗"],
    "hūn mèi": ["殙"],
    chòu: ["殠", "臰", "遚"],
    "kuì huì": ["殨", "溃", "潰"],
    cuàn: ["殩", "熶", "爨", "窜", "竄", "篡", "簒"],
    "yīn yān yǐn": ["殷"],
    "qìng kēng shēng": ["殸"],
    "yáo xiáo xiào": ["殽"],
    "gū gǔ": ["毂", "蛄"],
    "guàn wān": ["毌"],
    "dú dài": ["毒"],
    "xún xùn": ["毥"],
    mú: ["毪", "氁"],
    "dòu nuò": ["毭"],
    "sāi suī": ["毸"],
    lu: ["氇"],
    sào: ["氉", "瘙", "矂", "髞"],
    "shì zhī": ["氏"],
    "dī dǐ": ["氐"],
    "máng méng": ["氓"],
    "yáng rì": ["氜"],
    shuǐ: ["水", "氵", "氺", "閖"],
    "zhěng chéng zhèng": ["氶"],
    tǔn: ["氽"],
    "fán fàn": ["氾"],
    "guǐ jiǔ": ["氿"],
    "bīn pà pā": ["汃"],
    "zhuó què": ["汋"],
    "dà tài": ["汏"],
    pìn: ["汖", "牝", "聘"],
    "hàn hán": ["汗", "馯"],
    tu: ["汢"],
    "tāng shāng": ["汤", "湯"],
    "zhī jì": ["汥"],
    "gàn hán cén": ["汵"],
    "wèn mén": ["汶"],
    "fāng pāng": ["汸"],
    "hǔ huǎng": ["汻"],
    "niú yóu": ["汼"],
    hàng: ["沆"],
    "shěn chén": ["沈"],
    "dùn zhuàn": ["沌"],
    "nǜ niǔ": ["沑"],
    "méi mò": ["沒", "没"],
    "tà dá": ["沓"],
    "mì wù": ["沕"],
    "hóng pāng": ["沗"],
    "shā shà": ["沙"],
    "zhuǐ zǐ": ["沝"],
    "ōu òu": ["沤", "漚"],
    "jǔ jù": ["沮"],
    "tuō duó": ["沰"],
    "mǐ lì": ["沵"],
    "yí chí": ["沶"],
    "xiè yì": ["泄"],
    "bó pō": ["泊"],
    "mì bì": ["泌", "秘"],
    "chù shè": ["泏"],
    "yōu yòu āo": ["泑"],
    "pēng píng": ["泙", "硑"],
    "pào pāo": ["泡"],
    "ní nì": ["泥", "秜"],
    "yuè sà": ["泧"],
    "jué xuè": ["泬", "疦"],
    "lóng shuāng": ["泷", "瀧"],
    "luò pō": ["泺", "濼"],
    "zé shì": ["泽", "澤"],
    "sǎ xǐ": ["洒"],
    "sè qì zì": ["洓"],
    "xǐ xiǎn": ["洗"],
    "kǎo kào": ["洘"],
    "àn yàn è": ["洝"],
    "lěi lèi": ["洡"],
    "qiè jié": ["洯"],
    "qiǎn jiān": ["浅"],
    "jì jǐ": ["济", "済", "濟", "纪"],
    "hǔ xǔ": ["浒", "滸"],
    "jùn xùn": ["浚", "濬"],
    "yǐng chéng yíng": ["浧"],
    "liàn lì": ["浰"],
    "féng hóng": ["浲", "溄"],
    "jiǒng jiōng": ["浻"],
    "suī něi": ["浽"],
    "yǒng chōng": ["涌"],
    "tūn yūn": ["涒"],
    "wō guō": ["涡", "渦"],
    hēng: ["涥", "脝"],
    "zhǎng zhàng": ["涨", "漲"],
    "shòu tāo": ["涭"],
    shuàn: ["涮", "腨"],
    "kōng náng": ["涳"],
    "wò wǎn yuān": ["涴"],
    "tuō tuò": ["涶"],
    wō: ["涹", "猧", "窝", "窩", "莴", "萵", "蜗", "蝸", "踒"],
    "qiè jí": ["淁"],
    "guǒ guàn": ["淉"],
    "lín lìn": ["淋", "獜", "疄"],
    "tǎng chǎng": ["淌"],
    "nào chuò zhuō": ["淖"],
    "péng píng": ["淜"],
    féi: ["淝", "肥", "腓", "蜰"],
    "pì pèi": ["淠"],
    "niǎn shěn": ["淰"],
    "biāo hǔ": ["淲"],
    "chún zhūn": ["淳"],
    "hùn hún": ["混"],
    qiǎn: ["淺", "繾", "缱", "肷", "膁", "蜸", "譴", "谴", "遣", "鑓"],
    "wèn mín": ["渂"],
    "rè ruò luò": ["渃"],
    "dú dòu": ["渎", "瀆", "读"],
    "jiàn jiān": ["渐", "溅", "漸", "濺"],
    "miǎn shéng": ["渑", "澠"],
    "nuǎn nuán": ["渜"],
    "qiú wù": ["渞"],
    "tíng tīng": ["渟"],
    "dì tí dī": ["渧"],
    "gǎng jiǎng": ["港"],
    "hōng qìng": ["渹"],
    tuān: ["湍", "煓"],
    "huì mǐn xū": ["湏"],
    "xǔ xù": ["湑"],
    pén: ["湓", "瓫", "盆", "葐"],
    "mǐn hūn": ["湣"],
    "tuàn nuǎn": ["湪"],
    "qiū jiǎo": ["湫", "湬"],
    "yān yīn": ["湮"],
    "bàn pán": ["湴"],
    "zhuāng hún": ["湷"],
    "yàn guì": ["溎"],
    "lián liǎn nián xián xiàn": ["溓"],
    "dá tǎ": ["溚", "鿎"],
    "liū liù": ["溜", "澑", "蹓"],
    lùn: ["溣"],
    mǎ: [
      "溤",
      "犸",
      "獁",
      "玛",
      "瑪",
      "码",
      "碼",
      "遤",
      "鎷",
      "馬",
      "马",
      "鰢",
      "鷌"
    ],
    "zhēn qín": ["溱"],
    "nì niào": ["溺"],
    "chù xù": ["滀", "畜"],
    "wěng wēng": ["滃"],
    "hào xuè": ["滈"],
    "qì xì xiē": ["滊"],
    "xíng yíng": ["滎"],
    "zé hào": ["滜"],
    "piāo piào piǎo": ["漂"],
    "cóng sǒng": ["漎"],
    "féng péng": ["漨"],
    "luò tà": ["漯"],
    "pēng bēn": ["漰"],
    "chóng shuāng": ["漴"],
    "huǒ kuò huò": ["漷"],
    "liáo liú": ["漻"],
    "cuǐ cuī": ["漼"],
    "cóng zǒng": ["潀"],
    "cóng zōng": ["潈"],
    "pì piē": ["潎"],
    "dàng xiàng": ["潒"],
    "huáng guāng": ["潢"],
    "liáo lào lǎo": ["潦"],
    "cōng zòng": ["潨"],
    "zhí zhì": ["潪"],
    "tān shàn": ["潬"],
    "tú zhā": ["潳"],
    "sàn sǎ": ["潵"],
    hēi: ["潶", "黑", "黒", "𬭶"],
    "chéng dèng": ["澄", "瀓"],
    "cūn cún": ["澊"],
    "péng pēng": ["澎"],
    "hòng gǒng": ["澒", "銾"],
    "wàn màn": ["澫"],
    "kuài huì": ["澮"],
    "guō wō": ["濄"],
    "pēn fén": ["濆"],
    "jí shà": ["濈"],
    "huì huò": ["濊"],
    "dǐng tìng": ["濎"],
    "mǐ nǐ": ["濔"],
    "bì pì": ["濞"],
    "cuì zuǐ": ["濢"],
    "hù huò": ["濩"],
    "ǎi kài kè": ["濭"],
    "wěi duì": ["濻", "瀢"],
    "zàn cuán": ["濽", "灒"],
    "yǎng yàng": ["瀁"],
    "wǎng wāng": ["瀇"],
    "mò miè": ["瀎", "眜"],
    suǐ: ["瀡", "膸", "髓"],
    "huái wāi": ["瀤"],
    "zùn jiàn": ["瀳"],
    "yīng yǐng yìng": ["瀴"],
    "ráng ràng": ["瀼"],
    shuàng: ["灀"],
    "zhuó jiào zé": ["灂"],
    sǎ: ["灑", "訯", "靸"],
    "luán luàn": ["灓"],
    "dǎng tǎng": ["灙"],
    "xún quán quàn": ["灥"],
    "huǒ biāo": ["灬"],
    "zhà yù": ["灹"],
    "fén bèn": ["炃"],
    "jiǒng guì": ["炅"],
    "pàng fēng": ["炐"],
    quē: ["炔", "缺", "缼", "蒛"],
    biān: [
      "炞",
      "煸",
      "甂",
      "砭",
      "笾",
      "箯",
      "籩",
      "編",
      "编",
      "蝙",
      "邉",
      "邊",
      "鍽",
      "鞭",
      "鯾",
      "鯿",
      "鳊"
    ],
    "zhāo zhào": ["炤"],
    "zhuō chù": ["炪"],
    "pào páo bāo": ["炮"],
    "páo fǒu": ["炰"],
    "shǎn qián shān": ["炶"],
    "zhà zhá": ["炸"],
    "jiǎo yào": ["烄"],
    quǎn: ["烇", "犬", "犭", "畎", "綣", "绻", "虇"],
    "yàng yáng": ["烊"],
    "lào luò": ["烙"],
    "huí huǐ": ["烠"],
    rè: ["热", "熱"],
    "fú páo": ["烰"],
    "xiè chè": ["烲", "焎"],
    "yàn shān": ["烻"],
    "hūn xūn": ["焄"],
    kào: ["焅", "犒", "銬", "铐", "靠", "鮳", "鯌", "鲓", "㸆"],
    "juān yè": ["焆"],
    "jùn qū": ["焌"],
    "tāo dào": ["焘"],
    "chǎo jù": ["焣"],
    "wò ài": ["焥"],
    "zǒng cōng": ["焧"],
    "xī yì": ["焬"],
    "xìn xīn": ["焮"],
    "chāo zhuō": ["焯"],
    "xiǒng yīng": ["焸", "焽"],
    kuǐ: ["煃", "跬", "蹞", "頍", "𫠆"],
    "huī yùn xūn": ["煇"],
    "jiǎo qiāo": ["煍"],
    "qián shǎn shān": ["煔"],
    "xī yí": ["煕"],
    "shà shā": ["煞"],
    "yè zhá": ["煠"],
    "yáng yàng": ["煬"],
    "ēn yūn": ["煾"],
    "yūn yǔn": ["熅"],
    "hè xiāo": ["熇"],
    xióng: ["熊", "熋", "雄"],
    "xūn xùn": ["熏", "爋"],
    gòng: ["熕", "貢", "贡"],
    liū: ["熘"],
    "cōng zǒng": ["熜"],
    "lù āo": ["熝"],
    "shú shóu": ["熟"],
    "fēng péng": ["熢"],
    "cuǐ suī": ["熣"],
    tēng: ["熥", "膯", "鼟"],
    "yùn yù": ["熨"],
    "áo āo": ["熬"],
    "hàn rǎn": ["熯"],
    "ōu ǒu": ["熰"],
    "huáng huǎng": ["熿"],
    "chǎn dǎn chàn": ["燀"],
    "jiāo zhuó qiáo jué": ["燋"],
    "yàn yān": ["燕"],
    "tài liè": ["燤"],
    āo: ["爊"],
    "yàn xún": ["爓"],
    "jué jiào": ["爝", "覐", "覚", "覺", "觉"],
    "lǎn làn": ["爦"],
    "zhuǎ zhǎo": ["爪"],
    "zhǎo zhuǎ": ["爫"],
    "fù fǔ": ["父"],
    diē: ["爹", "褺", "跌"],
    zāng: ["牂", "羘", "臧", "賍", "賘", "贓", "贜", "赃", "髒"],
    "piàn piān": ["片"],
    "biān miàn": ["牑"],
    bǎng: ["牓", "綁", "绑"],
    "yǒu yōng": ["牗"],
    "chēng chèng": ["牚", "竀"],
    niú: ["牛", "牜"],
    "jiū lè": ["牞"],
    "mù móu": ["牟"],
    māng: ["牤"],
    "gē qiú": ["牫"],
    "yòu chōu": ["牰"],
    "tè zhí": ["犆"],
    bēn: ["犇", "錛", "锛"],
    "jiān qián": ["犍", "玪"],
    má: ["犘", "痲", "蔴", "蟇", "麻"],
    "máo lí": ["犛"],
    "bá quǎn": ["犮"],
    "zhuó bào": ["犳"],
    "àn hān": ["犴"],
    "kàng gǎng": ["犺"],
    "pèi fèi": ["犻"],
    "fān huān": ["犿"],
    kuáng: ["狂", "狅", "誑", "诳", "軖", "軠", "鵟", "𫛭"],
    "yí quán chí": ["狋"],
    "xīng shēng": ["狌"],
    "tuó yí": ["狏"],
    kǔ: ["狜", "苦"],
    "huán huān": ["狟"],
    "hé mò": ["狢"],
    "tà shì": ["狧"],
    "máng dòu": ["狵"],
    "xī shǐ": ["狶"],
    suān: ["狻", "痠", "酸"],
    "bài pí": ["猈"],
    "jiān yàn": ["猏", "豣"],
    "yī yǐ": ["猗"],
    "yá wèi": ["猚"],
    cāi: ["猜"],
    "māo máo": ["猫", "貓"],
    "chuàn chuān": ["猭"],
    "tuān tuàn": ["猯", "貒"],
    "yà jiá qiè": ["猰"],
    "hè xiē gé hài": ["猲"],
    "biān piàn": ["猵", "獱"],
    "bó pò": ["猼"],
    "háo gāo": ["獋"],
    "fén fèn": ["獖"],
    "yào xiāo": ["獟"],
    "shuò xī": ["獡"],
    "gé liè xiē": ["獦"],
    "nòu rú": ["獳"],
    "náo nǎo yōu": ["獶"],
    ráng: ["獽", "瓤", "禳", "穣", "穰", "蘘", "躟", "鬤"],
    "náo yōu": ["獿"],
    "lǜ shuài": ["率"],
    "wáng wàng": ["王"],
    "yáng chàng": ["玚"],
    "mín wén": ["玟"],
    "bīn fēn": ["玢"],
    "mén yǔn": ["玧"],
    "qiāng cāng": ["玱", "瑲", "篬"],
    "án gān": ["玵"],
    "xuán xián": ["玹"],
    "cī cǐ": ["玼", "跐"],
    "yí tāi": ["珆"],
    "zǔ jù": ["珇"],
    fà: ["珐", "琺", "蕟", "髪", "髮"],
    "yín kèn": ["珢"],
    "huī hún": ["珲"],
    "xuán qióng": ["琁"],
    "fú fū": ["琈"],
    "bǐng pín": ["琕"],
    "cuì sè": ["琗"],
    "yù wéi": ["琟"],
    "tiǎn tiàn": ["琠"],
    "zhuó zuó": ["琢"],
    "běng pěi": ["琣"],
    guǎn: ["琯", "璭", "痯", "筦", "管", "舘", "輨", "錧", "館", "馆", "鳤"],
    "hún huī": ["琿"],
    "xié jiē": ["瑎"],
    "chàng dàng yáng": ["瑒"],
    "tiàn zhèn": ["瑱"],
    "bīn pián": ["瑸", "璸"],
    "tú shū": ["瑹"],
    cuǐ: ["璀", "皠", "趡"],
    "zǎo suǒ": ["璅"],
    "jué qióng": ["璚"],
    "lú fū": ["璷"],
    "jì zī": ["璾"],
    suí: ["瓍", "綏", "绥", "遀", "随", "隨", "髄"],
    "mí xǐ": ["瓕"],
    "qióng wěi wèi": ["瓗"],
    "huán yè yà": ["瓛"],
    "bó páo": ["瓟"],
    "zhí hú": ["瓡"],
    piáo: ["瓢", "闝"],
    "wǎ wà": ["瓦"],
    "xiáng hóng": ["瓨"],
    wèng: ["瓮", "甕", "罋", "蕹", "齆"],
    "shèn shén": ["甚"],
    ruí: ["甤", "緌", "蕤"],
    yòng: ["用", "砽", "苚", "蒏", "醟", "㶲"],
    shuǎi: ["甩"],
    béng: ["甭", "甮"],
    "yóu zhá": ["甴"],
    "diàn tián shèng": ["甸"],
    "tǐng dīng": ["町", "甼"],
    "zāi zī": ["甾"],
    "bì qí": ["畁"],
    "dá fú": ["畗"],
    "cè jì": ["畟"],
    "zāi zī tián": ["畠"],
    "zhì chóu shì": ["畤"],
    "fān pān": ["畨", "番"],
    "shē yú": ["畬"],
    "dāng dàng dǎng": ["當"],
    "jiāng qiáng": ["疆"],
    "pǐ yǎ shū": ["疋"],
    "jié qiè": ["疌"],
    "yí nǐ": ["疑"],
    nè: ["疒", "眲", "訥", "讷"],
    "gē yì": ["疙"],
    "nüè yào": ["疟", "瘧"],
    "lì lài": ["疠", "癘"],
    "yǎ xiā": ["疨"],
    xuē: ["疶", "蒆", "薛", "辥", "辪", "靴", "鞾"],
    "dǎn da": ["疸"],
    "fá biǎn": ["疺"],
    "fèi féi": ["疿", "痱"],
    "shān diàn": ["痁"],
    "téng chóng": ["痋"],
    "tōng tóng": ["痌"],
    "wěi yòu yù": ["痏"],
    "tān shǐ": ["痑"],
    "pū pù": ["痡", "鋪"],
    "bēng péng": ["痭"],
    "má lìn": ["痳"],
    "tiǎn diàn": ["痶"],
    "ān yè è": ["痷"],
    "kē ē": ["痾"],
    "zhì chì": ["瘈"],
    "jiǎ xiá xiā": ["瘕"],
    "lěi huì": ["瘣"],
    "chài cuó": ["瘥"],
    "diān chēn": ["瘨"],
    "da dá": ["瘩"],
    "biě biē": ["瘪"],
    qué: ["瘸"],
    "dàn dān": ["癉"],
    "guì wēi": ["癐"],
    "nòng nóng": ["癑"],
    "biē biě": ["癟"],
    "bō bǒ": ["癷"],
    bái: ["白"],
    "jí bī": ["皀"],
    "de dì dí dī": ["的"],
    "pā bà": ["皅"],
    "gāo háo": ["皋"],
    "gāo yáo": ["皐"],
    "lì luò bō": ["皪"],
    "zhā cǔ": ["皻"],
    "zhāo zhǎn dǎn": ["皽"],
    "jiān jiàn": ["监", "監", "鋻", "间", "鞬"],
    "gài gě hé": ["盖"],
    "máng wàng": ["盳"],
    yuǎn: ["盶", "逺", "遠"],
    "tián xián": ["盷"],
    "xiāng xiàng": ["相"],
    dǔn: ["盹", "趸", "躉"],
    "xì pǎn": ["盻"],
    "shěng xǐng": ["省"],
    "yún hùn": ["眃"],
    "miǎn miàn": ["眄"],
    "kàn kān": ["看"],
    "yìng yāng yǎng": ["眏"],
    "yǎo āo ǎo": ["眑"],
    "jū xū kōu": ["眗"],
    "yí chì": ["眙"],
    "dié tì": ["眣"],
    "bǐng fǎng": ["眪"],
    "pàng pán": ["眫"],
    "mī mí": ["眯", "瞇"],
    "xuàn shùn xún": ["眴"],
    tiào: ["眺", "粜", "糶", "覜", "趒"],
    "zhe zhuó zháo zhāo": ["着"],
    "qiáo shào xiāo": ["睄"],
    "cuó zhuài": ["睉"],
    gùn: ["睔", "謴"],
    "suì zuì": ["睟"],
    "pì bì": ["睥", "稫", "辟"],
    "yì zé gāo": ["睪"],
    "xǐng xìng": ["睲"],
    "guì wèi kuì": ["瞆"],
    "kòu jì": ["瞉"],
    "qióng huán": ["瞏"],
    "mán mén": ["瞒", "瞞"],
    "diāo dōu": ["瞗"],
    "lou lóu lǘ": ["瞜"],
    "shùn rún": ["瞤"],
    "liào liǎo": ["瞭", "钌"],
    "jiàn xián": ["瞯"],
    "wǔ mí": ["瞴"],
    "guì kuì": ["瞶"],
    "nǐng chēng": ["矃"],
    "huò yuè": ["矆"],
    "mēng méng": ["矇"],
    "kuàng guō": ["矌"],
    "guàn quán": ["矔"],
    "mǎn mán": ["矕"],
    "jīn guān qín": ["矜"],
    "jīn qín guān": ["矝"],
    "yù xù jué": ["矞"],
    "jiǎo jiáo": ["矫", "矯"],
    duǎn: ["短"],
    "shí dàn": ["石"],
    "gāng qiāng kòng": ["矼"],
    "huā xū": ["砉"],
    "pīn bīn fēn": ["砏"],
    "yán yàn": ["研", "硏"],
    "luǒ kē": ["砢"],
    "fú fèi": ["砩", "笰"],
    "zhǔ zhù": ["砫"],
    "lá lì lā": ["砬"],
    "kuāng guāng": ["硄"],
    "gè luò": ["硌"],
    "shuò shí": ["硕", "碩"],
    "wèi wéi ái": ["硙"],
    "què kè kù": ["硞"],
    "mǎng bàng": ["硥"],
    "luò lòng": ["硦"],
    "yǒng tóng": ["硧"],
    nüè: ["硸", "虐"],
    "kēng kěng": ["硻"],
    "yān yǎn": ["硽"],
    "zhuì chuí duǒ": ["硾"],
    "kōng kòng": ["硿"],
    "zòng cóng": ["碂"],
    "jiān zhàn": ["碊"],
    "lù liù": ["碌", "陆"],
    "què xī": ["碏"],
    "lún lǔn lùn": ["碖"],
    "náo gāng": ["碙"],
    "jié yà": ["碣"],
    "wèi wěi": ["碨"],
    "tí dī": ["碮"],
    "chá chā": ["碴"],
    "qiāo què": ["碻"],
    "sù xiè": ["碿"],
    "liú liù": ["磂", "遛", "鎦", "馏"],
    "sī tí": ["磃"],
    "bàng páng": ["磅"],
    "huá kě gū": ["磆"],
    "wěi kuǐ": ["磈"],
    "xiá qià yà": ["磍"],
    "lián qiān": ["磏"],
    "wèi ái gài": ["磑"],
    "lá lā": ["磖"],
    "áo qiāo": ["磝"],
    "pēng pèng": ["磞", "閛"],
    "yīn yǐn": ["磤"],
    "lěi léi": ["磥"],
    "mó mò": ["磨"],
    "qì zhú": ["磩"],
    "láo luò": ["磱"],
    "pán bō": ["磻"],
    "jí shé": ["磼"],
    "hé qiāo qiào": ["礉"],
    "kè huò": ["礊"],
    "què hú": ["礐"],
    "è qì": ["礘"],
    cǎ: ["礤", "礸"],
    "xián xín": ["礥"],
    "léi lěi lèi": ["礧"],
    "yán yǎn": ["礹"],
    "qí zhǐ": ["祇", "蚔"],
    "bēng fāng": ["祊"],
    "bì mì": ["祕"],
    suàn: ["祘", "笇", "筭", "算", "蒜"],
    "piào piāo": ["票"],
    "jì zhài": ["祭"],
    "shuì lèi": ["祱"],
    "jìn jīn": ["禁"],
    "chán shàn": ["禅"],
    "yáng shāng": ["禓"],
    "zhī zhǐ tí": ["禔"],
    "shàn chán": ["禪"],
    "yú yù ǒu": ["禺"],
    "zǐ zì": ["秄"],
    "chá ná": ["秅"],
    "zhǒng zhòng chóng": ["种"],
    "hào mào": ["秏"],
    "kù kū": ["秙"],
    zū: ["租", "葅"],
    chèng: ["秤", "穪"],
    "huó kuò": ["秮", "秳"],
    "chēng chèn chèng": ["称", "稱"],
    "shì zhì": ["秲", "銴"],
    "fù pū": ["秿"],
    "xùn zè": ["稄"],
    "tú shǔ": ["稌"],
    "zhùn zhǔn": ["稕"],
    "jī qí": ["稘", "綨", "觭"],
    "léng líng": ["稜"],
    "zuì zú sū": ["稡"],
    "xì qiè": ["稧", "郄"],
    "zhǒng zhòng": ["種"],
    "zōng zǒng": ["稯"],
    "xián jiān liàn": ["稴"],
    "zī jiū": ["稵"],
    "jī qǐ": ["稽"],
    ròng: ["穃"],
    "shān cǎn cēn": ["穇"],
    "mén méi": ["穈"],
    "jǐ jì": ["穖"],
    "xiāo rào": ["穘"],
    "zhuō bó": ["穛"],
    "tóng zhǒng zhòng": ["穜"],
    zuō: ["穝"],
    "biāo pāo": ["穮", "藨"],
    "zhuō jué": ["穱"],
    "cuán zàn": ["穳"],
    "kōng kòng kǒng": ["空"],
    "yū yǔ": ["穻"],
    zhǎi: ["窄", "鉙"],
    báo: ["窇", "雹"],
    "kū zhú": ["窋"],
    "jiào liáo liù": ["窌"],
    "wā guī": ["窐"],
    "tiǎo yáo": ["窕"],
    "xūn yìn": ["窨"],
    "yà yē": ["窫"],
    "tián diān yǎn": ["窴"],
    "chāo kē": ["窼"],
    "kuǎn cuàn": ["窽", "窾"],
    "chù qì": ["竐"],
    "qǔ kǒu": ["竘"],
    "jìng zhěn": ["竧"],
    "kǎn kàn": ["竷"],
    "zhú dǔ": ["竺"],
    "lè jīn": ["竻"],
    "zhuì ruì": ["笍"],
    "háng hàng": ["笐"],
    "cén jìn hán": ["笒"],
    "dā xiá nà": ["笚"],
    "zé zuó": ["笮"],
    "lóng lǒng": ["笼", "篭", "籠", "躘", "龓"],
    "zhù zhú": ["筑", "築"],
    "dá dā": ["答", "荅"],
    shāi: ["筛", "篩", "簁", "籭"],
    "yún jūn": ["筠"],
    "láng làng": ["筤", "郎", "阆"],
    "zhì zhǐ": ["筫"],
    o: ["筽"],
    "póu bù fú pú": ["箁"],
    "pái bēi": ["箄"],
    gè: ["箇", "虼", "鉻", "铬"],
    "tái chí": ["箈"],
    "guǎi dài": ["箉"],
    "zhào dào": ["箌"],
    "jīng qìng": ["箐"],
    "lín lǐn": ["箖"],
    "jùn qūn": ["箘"],
    "shī yí": ["箷", "釶"],
    "yuē yào chuò": ["箹"],
    "xiāo shuò qiào": ["箾"],
    "gōng gǎn lǒng": ["篢"],
    "páng péng": ["篣"],
    "zhuó huò": ["篧"],
    "jiǎn jiān": ["篯"],
    "dí zhú": ["篴"],
    "zān cēn cǎn": ["篸"],
    "zhuàn suǎn zuàn": ["篹"],
    "piǎo biāo": ["篻"],
    "guó guì": ["簂"],
    "cè jí": ["簎"],
    "mì miè": ["簚"],
    "shāi sī": ["簛"],
    "sǔn zhuàn": ["簨"],
    "gàn gǎn": ["簳"],
    "bò bǒ": ["簸"],
    "bó bù": ["簿"],
    shi: ["籂"],
    "zhēn jiān": ["籈"],
    "zhuàn zuǎn": ["籑"],
    "fān pān biān": ["籓"],
    "sǒu shǔ": ["籔"],
    zuǎn: ["籫", "繤", "纂", "纉", "纘", "缵"],
    nǚ: ["籹", "釹", "钕"],
    "shā chǎo": ["粆"],
    "kāng jīng": ["粇"],
    fěn: ["粉", "黺"],
    cū: ["粗", "觕", "麁", "麄", "麤"],
    "nián zhān": ["粘"],
    "cè sè": ["粣"],
    "zhōu yù": ["粥"],
    "shēn sǎn": ["糁"],
    "biān biǎn": ["糄", "萹"],
    miàn: ["糆", "面", "靣", "麪", "麫", "麵", "麺"],
    "hú hū hù": ["糊"],
    "gǔ gòu": ["糓"],
    "mí méi": ["糜"],
    "sǎn shēn": ["糝", "糣"],
    zāo: ["糟", "蹧", "遭", "醩"],
    "mì sī": ["糸"],
    "jiū jiǔ": ["糺"],
    "xì jì": ["系", "繫"],
    "zhēng zhěng": ["糽"],
    "chà chǎ": ["紁", "衩"],
    "yuē yāo": ["約", "约"],
    "hóng gōng": ["紅", "红"],
    "hé gē": ["紇", "纥"],
    "wén wèn": ["紋", "纹"],
    fóu: ["紑"],
    "jì jié jiè": ["紒"],
    "pī pí bǐ": ["紕", "纰"],
    "jīn jìn": ["紟"],
    "zhā zā": ["紥", "紮"],
    hā: ["紦"],
    "fū fù": ["紨"],
    "chōu chóu": ["紬"],
    "lèi léi lěi": ["累"],
    "bō bì": ["紴"],
    "tiǎn zhěn": ["紾"],
    "jiōng jiǒng": ["絅"],
    "jié jiē": ["結", "结", "节"],
    "guà kuā": ["絓"],
    "bǎi mò": ["絔"],
    "gēng huán": ["絙"],
    "jié xié": ["絜"],
    "quán shuān": ["絟"],
    "gǎi ǎi": ["絠"],
    "luò lào": ["絡", "络"],
    "bīng bēng pēng": ["絣"],
    "gěi jǐ": ["給", "给"],
    "tóng tōng dòng": ["絧"],
    "tiào diào dào": ["絩"],
    "lěi lèi léi": ["絫"],
    "gāi hài": ["絯"],
    "chī zhǐ": ["絺"],
    "wèn miǎn mán wàn": ["絻"],
    "huán huàn wàn": ["綄"],
    "qīn xiān": ["綅"],
    "tì tí": ["綈"],
    "yán xiàn": ["綖"],
    "zōng zèng zòng": ["綜"],
    "chēn lín": ["綝"],
    "zhǔn zhùn": ["綧"],
    "qiàn qīng zhēng": ["綪"],
    "qìng qǐ": ["綮"],
    "lún guān": ["綸", "纶"],
    "chuò chāo": ["綽", "绰"],
    "tián tǎn chān": ["緂"],
    "lǜ lù": ["緑", "绿"],
    "ruǎn ruàn": ["緛"],
    "jí qī": ["緝"],
    "zhòng chóng": ["緟", "重"],
    "miáo máo": ["緢"],
    "xiè yè": ["緤"],
    huǎn: ["緩", "缓", "㬊"],
    "gēng gèng": ["緪", "縆"],
    "tōu xū shū": ["緰"],
    "zōng zòng": ["緵", "繌"],
    "yùn gǔn": ["緷"],
    "guā wō": ["緺"],
    "yùn yūn wēn": ["緼", "縕"],
    "bāng bàng": ["縍"],
    "gǔ hú": ["縎", "鶻"],
    "cī cuò suǒ": ["縒"],
    "cuī shuāi": ["縗"],
    "róng rǒng ròng": ["縙"],
    "zài zēng": ["縡"],
    cài: ["縩", "菜", "蔡"],
    "féng fèng": ["縫"],
    "suō sù": ["縮", "缩"],
    "yǎn yǐn": ["縯", "酓"],
    "zòng zǒng": ["縱", "纵"],
    "zhuàn juàn": ["縳"],
    "mò mù": ["縸", "莫"],
    "piǎo piāo": ["縹", "缥"],
    "fán pó": ["繁"],
    "bēng bèng": ["繃"],
    "móu miù miào liǎo": ["繆"],
    "yáo yóu zhòu": ["繇"],
    "zēng zèng": ["繒", "缯"],
    "jú jué": ["繘"],
    "chuō chuò": ["繛"],
    "zūn zǔn": ["繜"],
    rào: ["繞", "绕", "遶"],
    "chǎn chán": ["繟"],
    "huì huí": ["繢", "缋", "藱"],
    "qiāo sāo zǎo": ["繰"],
    "jiǎo zhuó": ["繳", "缴"],
    "dàn tán chán": ["繵"],
    nǒng: ["繷"],
    "pú fú": ["纀"],
    "yào lì": ["纅"],
    "rǎng xiāng": ["纕"],
    "lí sǎ xǐ lǐ": ["纚"],
    "xiān qiàn": ["纤"],
    "jīng jìng": ["经"],
    "tí tì": ["绨"],
    "bēng běng bèng": ["绷"],
    "zōng zèng": ["综"],
    "jī qī": ["缉"],
    "wēn yùn yūn": ["缊"],
    "fèng féng": ["缝"],
    "shuāi cuī suī": ["缞"],
    "miù móu liáo miào mù": ["缪"],
    "qiāo sāo": ["缲"],
    fǒu: ["缶", "缹", "缻", "雬", "鴀"],
    "bà ba pí": ["罢", "罷"],
    "guà guǎi": ["罫"],
    "yáng xiáng": ["羊", "羏"],
    "měi gāo": ["羙"],
    "yì xī": ["羛"],
    "qiǎng qiān": ["羟"],
    "qiāng kòng": ["羫"],
    "qián xián yán": ["羬"],
    nóu: ["羺"],
    "hóng gòng": ["羾"],
    "pī bì pō": ["翍"],
    "qú yù": ["翑"],
    ké: ["翗"],
    "qiào qiáo": ["翘"],
    "zhái dí": ["翟"],
    "dào zhōu": ["翢"],
    "hóu qú": ["翵"],
    shuǎ: ["耍"],
    "ruǎn nuò": ["耎"],
    "ér nài": ["耏"],
    "zhuān duān": ["耑"],
    "pá bà": ["耙"],
    "chí sì": ["耛"],
    "qù chú": ["耝"],
    "lún lǔn": ["耣"],
    "jí jiè": ["耤"],
    "tāng tǎng": ["耥"],
    pǎng: ["耪", "覫"],
    "zhá zé": ["耫"],
    "yē yé": ["耶"],
    "yún yíng": ["耺"],
    "wà tuǐ zhuó": ["聉"],
    "ér nǜ": ["聏"],
    "tiē zhé": ["聑"],
    "dǐ zhì": ["聜"],
    qié: ["聺"],
    "nǐ jiàn": ["聻"],
    "lèi lē": ["肋"],
    cào: ["肏", "襙", "鄵", "鼜"],
    "bó dí": ["肑"],
    "xiào xiāo": ["肖"],
    "dù dǔ": ["肚"],
    chāi: ["肞", "釵", "钗"],
    "hán qín hàn": ["肣"],
    "pàng pán pàn": ["肨", "胖"],
    "zhūn chún": ["肫"],
    āng: ["肮", "骯"],
    "yù yō": ["育"],
    "pí bǐ bì": ["肶"],
    "fèi bì": ["胇"],
    "bèi bēi": ["背"],
    "fèi zǐ": ["胏"],
    "píng pēng": ["胓", "苹"],
    "fū fú zhǒu": ["胕"],
    "shèng shēng": ["胜"],
    kuà: ["胯", "跨", "骻"],
    "gǎi hǎi": ["胲"],
    "gē gé gā": ["胳"],
    "néng nài": ["能"],
    "guī kuì": ["胿"],
    "mài mò": ["脉"],
    "zāng zàng": ["脏"],
    "jiǎo jué": ["脚", "角"],
    cuǒ: ["脞"],
    "de te": ["脦"],
    "zuī juān": ["脧"],
    něi: ["脮", "腇", "餒", "馁", "鮾", "鯘"],
    "pú fǔ": ["脯"],
    niào: ["脲"],
    shuí: ["脽"],
    guò: ["腂", "過", "鐹"],
    "là xī": ["腊"],
    "yān ā": ["腌"],
    "gāo gào": ["膏"],
    "lù biāo": ["膔"],
    chuái: ["膗"],
    "zhuān chuán chún zhuǎn": ["膞"],
    chuài: ["膪", "踹"],
    "fán pán": ["膰"],
    "wǔ hū": ["膴"],
    "shān dàn": ["膻"],
    tún: ["臀", "臋", "蛌", "豘", "豚", "軘", "霕", "飩", "饨", "魨", "鲀", "黗"],
    "bì bei": ["臂"],
    "là gé": ["臈"],
    "sào sāo": ["臊"],
    nào: ["臑", "閙", "闹", "鬧"],
    "ní luán": ["臡"],
    "qiān xián": ["臤"],
    "guàng jiǒng": ["臦"],
    "guǎng jiǒng": ["臩"],
    "chòu xiù": ["臭"],
    "mián biān": ["臱"],
    "dié zhí": ["臷"],
    "zhī jìn": ["臸"],
    "shè shě": ["舍"],
    pù: ["舖", "舗"],
    "bān bō pán": ["般"],
    kuā: ["舿"],
    "gèn gěn": ["艮"],
    "sè shǎi": ["色"],
    "fú bó": ["艴"],
    "jiāo qiú": ["艽"],
    "chāi chā": ["芆"],
    "sháo què": ["芍"],
    "hù xià": ["芐"],
    "zì zǐ": ["芓"],
    "huì hū": ["芔"],
    "tún chūn": ["芚"],
    "jiè gài": ["芥"],
    "xù zhù": ["芧"],
    "yuán yán": ["芫"],
    "xīn xìn": ["芯"],
    "lún huā": ["芲"],
    "wù hū": ["芴"],
    "gōu gǒu": ["芶"],
    "mào máo": ["芼"],
    "fèi fú": ["芾"],
    "chán yín": ["苂"],
    qiē: ["苆"],
    "sū sù": ["苏"],
    "tiáo sháo": ["苕"],
    "lì jī": ["苙"],
    "kē hē": ["苛"],
    "jù qǔ": ["苣"],
    "ruò rě": ["若"],
    "zhù níng": ["苧"],
    "pā bó": ["苩"],
    xiú: ["苬"],
    "zhǎ zuó": ["苲"],
    "jū chá": ["苴"],
    nié: ["苶"],
    "shēng ruí": ["苼"],
    "qié jiā": ["茄"],
    "zǐ cí": ["茈"],
    "qiàn xī": ["茜"],
    chǎi: ["茝"],
    "fá pèi": ["茷"],
    ráo: ["荛", "蕘", "襓", "饒", "饶"],
    "yíng xíng": ["荥"],
    "qián xún": ["荨", "蕁"],
    "yìn yīn": ["荫"],
    "hé hè": ["荷"],
    "shā suō": ["莎"],
    "péng fēng": ["莑"],
    "shēn xīn": ["莘"],
    "wǎn guān guǎn": ["莞"],
    "yóu sù": ["莤"],
    "shāo xiāo": ["莦", "蛸"],
    "làng liáng": ["莨"],
    "piǎo fú": ["莩"],
    "wèn wǎn miǎn": ["莬"],
    "shì shí": ["莳", "蒔"],
    "tù tú": ["莵"],
    "xiān liǎn": ["莶", "薟"],
    "wǎn yù": ["菀"],
    "zōu chù": ["菆"],
    "lù lǜ": ["菉"],
    "jūn jùn": ["菌"],
    "niè rěn": ["菍"],
    "zī zì zāi": ["菑"],
    "tú tù": ["菟"],
    "jiē shà": ["菨"],
    "qiáo zhǎo": ["菬"],
    "tái zhī chí": ["菭"],
    "fēi fěi": ["菲", "蜚"],
    "qín qīn jīn": ["菳"],
    "zū jù": ["菹", "蒩"],
    "lǐn má": ["菻"],
    "tián tiàn": ["菾"],
    tiē: ["萜", "貼", "贴"],
    "luò là lào luō": ["落"],
    "zhù zhuó zhe": ["著"],
    "shèn rèn": ["葚"],
    "gě gé": ["葛"],
    "jùn suǒ": ["葰"],
    "kuì kuài": ["蒉"],
    "rú ná": ["蒘"],
    "méng mēng měng": ["蒙"],
    "yuán huán": ["蒝"],
    "xú shú": ["蒣"],
    "xí xì": ["蒵"],
    "mì míng": ["蓂"],
    "sōu sǒu": ["蓃"],
    "gài gě hé hài": ["蓋"],
    "yǎo zhuó": ["蓔"],
    "diào tiáo dí": ["蓧"],
    "xū qiū fū": ["蓲"],
    "zí jú": ["蓻"],
    "liǎo lù": ["蓼"],
    xu: ["蓿"],
    "hàn hǎn": ["蔊"],
    "màn wàn mán": ["蔓"],
    "pó bò": ["蔢"],
    "fān fán bō": ["蕃"],
    "hóng hòng": ["蕻"],
    "yù ào": ["薁", "隩"],
    "xí xiào": ["薂"],
    "báo bó bò": ["薄"],
    "cí zī": ["薋"],
    "wàn luàn": ["薍"],
    "kǎo hāo": ["薧"],
    "yuǎn wěi": ["薳"],
    "zhòu chóu": ["薵"],
    "wō mái": ["薶"],
    "xiāo hào": ["藃"],
    "yù xù xū": ["藇"],
    "jiè jí": ["藉"],
    "diào zhuó": ["藋"],
    "cáng zàng": ["藏"],
    lǎ: ["藞"],
    "chú zhū": ["藸"],
    "pín píng": ["蘋"],
    "gān hán": ["虷"],
    "hóng jiàng": ["虹"],
    "huī huǐ": ["虺"],
    "xiā há": ["虾"],
    "mǎ mà mā": ["蚂"],
    "fāng bàng": ["蚄"],
    "bàng bèng": ["蚌"],
    "jué quē": ["蚗"],
    "qín qián": ["蚙"],
    "gōng zhōng": ["蚣"],
    "fǔ fù": ["蚥"],
    "dài dé": ["蚮"],
    "gǒu qú xù": ["蚼"],
    "bǒ pí": ["蚾"],
    "shé yí": ["蛇"],
    tiě: ["蛈", "鉄", "銕", "鐡", "鐵", "铁", "驖"],
    "gé luò": ["蛒"],
    "máng bàng": ["蛖"],
    "yì xǔ": ["蛡"],
    "há gé": ["蛤"],
    "qiè ní": ["蛪"],
    "é yǐ": ["蛾"],
    "zhē zhé": ["蜇"],
    "là zhà": ["蜡"],
    suò: ["蜶", "逤"],
    "yóu qiú": ["蝤"],
    "xiā hā": ["蝦"],
    "xī qī": ["螇"],
    "bī pí": ["螕"],
    "nài něng": ["螚"],
    "hé xiá": ["螛"],
    "guì huǐ": ["螝"],
    "mǎ mā mà": ["螞"],
    "shì zhē": ["螫"],
    "zhì dié": ["螲"],
    "jiàn chán": ["螹"],
    "ma má mò": ["蟆"],
    "mǎng měng": ["蟒"],
    "biē bié": ["蟞"],
    "bēn fèi": ["蟦"],
    "láo liáo": ["蟧"],
    "yín xún": ["蟫"],
    "lí lǐ": ["蠡"],
    "xuè xiě": ["血"],
    "xíng háng hàng héng": ["行"],
    "shuāi cuī": ["衰"],
    "tuó tuō": ["袉"],
    "lǐng líng": ["袊"],
    "bào páo pào": ["袌"],
    "jù jiē": ["袓"],
    "hè kè": ["袔"],
    "yí yì": ["袘", "貤"],
    "nà jué": ["袦"],
    "bèi pī": ["被"],
    "chǐ nuǒ": ["袲"],
    "chǐ qǐ duǒ nuǒ": ["袳"],
    "jiá qiā jié": ["袷"],
    "bó mò": ["袹"],
    "guī guà": ["袿"],
    "liè liě": ["裂"],
    "chéng chěng": ["裎"],
    "jiē gé": ["裓"],
    "dāo chóu": ["裯"],
    "shang cháng": ["裳"],
    "yuān gǔn": ["裷"],
    "yǎn ān": ["裺"],
    "tì xī": ["裼"],
    "fù fú": ["褔"],
    "chǔ zhǔ": ["褚"],
    "tuì tùn": ["褪"],
    lǎi: ["襰"],
    "yào yāo": ["要"],
    "qín tán": ["覃"],
    "jiàn xiàn": ["見", "见"],
    piǎn: ["覑", "諞", "谝", "貵", "𡎚"],
    "piē miè": ["覕"],
    "yíng yǐng": ["覮"],
    "qù qū": ["覰", "覷", "觑"],
    "jiàn biǎn": ["覵"],
    "luó luǎn": ["覶"],
    "zī zuǐ": ["觜"],
    "huà xiè": ["觟"],
    "jiě jiè xiè": ["解", "觧"],
    "xué hù": ["觷"],
    "lì lù": ["觻"],
    tǎo: ["討", "讨"],
    zhùn: ["訰"],
    "zī zǐ": ["訾"],
    "yí dài": ["詒", "诒"],
    xiòng: ["詗", "诇"],
    "diào tiǎo": ["誂"],
    "yí chǐ chì": ["誃"],
    "lǎng làng": ["誏"],
    "ēi éi ěi èi xī": ["誒", "诶"],
    shuà: ["誜"],
    "yǔ yù": ["語", "语", "雨"],
    "shuō shuì yuè": ["說", "说"],
    "shuí shéi": ["誰", "谁"],
    "qū juè": ["誳"],
    "chī lài": ["誺"],
    "nì ná": ["誽"],
    "diào tiáo": ["調"],
    "pǐ bēi": ["諀"],
    "jì jī": ["諅"],
    "zé zuò zhǎ cuò": ["諎"],
    "chù jí": ["諔"],
    "háo xià": ["諕"],
    "lùn lún": ["論", "论"],
    "shì dì": ["諟"],
    "huà guā": ["諣"],
    "xǐ shāi āi": ["諰"],
    "nán nàn": ["諵", "難"],
    miù: ["謬", "谬"],
    zèn: ["譖", "谮"],
    "shí zhì": ["識", "识"],
    "juàn xuān": ["讂"],
    "yí tuī": ["讉"],
    zhán: ["讝"],
    "xǔ hǔ": ["许"],
    "xiáng yáng": ["详"],
    "tiáo diào zhōu": ["调"],
    "chén shèn": ["谌"],
    "mí mèi": ["谜"],
    "màn mán": ["谩"],
    "gǔ yù": ["谷"],
    "huō huò huá": ["豁"],
    "zhì zhài": ["豸"],
    "huān huán": ["貆"],
    "kěn kūn": ["貇"],
    "mò hé": ["貈"],
    "mò hé háo": ["貉"],
    "jù lóu": ["貗"],
    "zé zhài": ["責", "责"],
    "dài tè": ["貸"],
    "bì bēn": ["賁"],
    "jiǎ gǔ jià": ["賈"],
    "xiōng mín": ["賯"],
    càng: ["賶"],
    "zhuàn zuàn": ["賺", "赚"],
    "wàn zhuàn": ["贃"],
    "gàn gòng zhuàng": ["贛"],
    "yuán yùn": ["贠"],
    "bēn bì": ["贲"],
    "jiǎ gǔ": ["贾"],
    zǒu: ["走", "赱", "鯐"],
    "dié tú": ["趃"],
    "jū qiè": ["趄"],
    "qū cù": ["趋", "趨"],
    "jí jié": ["趌"],
    "guā huó": ["趏"],
    "què qì jí": ["趞"],
    "tàng tāng": ["趟"],
    "chuō zhuó": ["趠"],
    "qù cù": ["趣"],
    "yuè tì": ["趯"],
    "bō bào": ["趵"],
    "kuà wù": ["趶"],
    "guì jué": ["趹"],
    "fāng fàng páng": ["趽"],
    "páo bà": ["跁"],
    "qí qǐ": ["跂"],
    "jiàn chén": ["跈"],
    "pǎo páo": ["跑"],
    "diǎn diē tiē": ["跕"],
    "jū jù qiè": ["跙"],
    bǒ: ["跛"],
    "luò lì": ["跞"],
    "dài duò duō chí": ["跢"],
    zhuǎi: ["跩"],
    "bèng pián": ["跰"],
    "tiào táo": ["跳"],
    "shū chōu": ["跾"],
    "liàng liáng": ["踉"],
    "tà tā": ["踏"],
    chǎ: ["蹅", "鑔", "镲"],
    "dí zhí": ["蹢"],
    "dēng dèng": ["蹬", "鐙", "镫"],
    cèng: ["蹭"],
    "dūn cún": ["蹲"],
    "juě jué": ["蹶"],
    liāo: ["蹽"],
    "xiè sǎ": ["躠"],
    tǐ: ["躰", "軆", "骵"],
    "yà zhá gá": ["轧", "軋"],
    "xìn xiàn": ["軐"],
    "fàn guǐ": ["軓"],
    "zhuàn zhuǎn": ["転"],
    "zhóu zhòu": ["軸", "轴"],
    bú: ["轐", "醭", "鳪"],
    "zhuǎn zhuàn zhuǎi": ["转"],
    "zǎi zài": ["载"],
    "niǎn zhǎn": ["辗"],
    "biān bian": ["边"],
    "dào biān": ["辺"],
    "yǐ yí": ["迆", "迤", "迱"],
    "guò guo guō": ["过"],
    "wàng kuāng": ["迋"],
    "hái huán": ["还"],
    "zhè zhèi": ["这"],
    "yuǎn yuàn": ["远"],
    "zhì lì": ["迣"],
    "zhù wǎng": ["迬"],
    "zhuī duī": ["追"],
    "shì kuò": ["适"],
    tòu: ["透"],
    "tōng tòng": ["通"],
    guàng: ["逛"],
    "dǎi dài": ["逮"],
    "suì suí": ["遂"],
    "tí dì": ["遆"],
    "yí wèi": ["遗"],
    "shì dí zhé": ["適"],
    cà: ["遪"],
    "huán hái": ["還"],
    "lí chí": ["邌"],
    "kàng háng": ["邟"],
    "nà nèi nā": ["那"],
    "xié yá yé yú xú": ["邪"],
    "gāi hái": ["郂"],
    "huán xún": ["郇"],
    "chī xī": ["郗"],
    hǎo: ["郝"],
    "lì zhí": ["郦"],
    "xiáo ǎo": ["郩"],
    "dōu dū": ["都"],
    liǎo: ["曢", "鄝", "镽"],
    "zàn cuán cuó": ["酂", "酇"],
    "dīng dǐng": ["酊"],
    "cù zuò": ["酢"],
    "fā pō": ["酦"],
    "shāi shī": ["酾"],
    niàng: ["酿", "醸"],
    "qiú chōu": ["醔"],
    "pō fā": ["醗", "醱"],
    "chǎn chěn": ["醦"],
    "yàn liǎn xiān": ["醶"],
    "niàng niáng": ["釀"],
    "lǐ li": ["里"],
    "lí xǐ xī": ["釐"],
    "liǎo liào": ["釕"],
    "dīng dìng": ["釘", "钉"],
    "qiǎo jiǎo": ["釥"],
    "yú huá": ["釪"],
    "huá wū": ["釫"],
    "rì rèn jiàn": ["釰", "釼"],
    "dì dài": ["釱"],
    "pī zhāo": ["釽"],
    "yá yé": ["釾"],
    "bǎ pá": ["鈀", "钯"],
    "tā tuó": ["鉈", "铊"],
    běi: ["鉳"],
    "bǐng píng": ["鉼"],
    "hā kē": ["鉿", "铪"],
    chòng: ["銃", "铳"],
    "xiǎng jiōng": ["銄"],
    "yù sì": ["銉"],
    "xù huì": ["銊"],
    "rén rěn": ["銋"],
    "shàn shuò": ["銏"],
    "chì lì": ["銐"],
    "xiǎn xǐ": ["銑", "铣"],
    "hóu xiàng": ["銗"],
    "diào tiáo yáo": ["銚"],
    "xiān kuò tiǎn guā": ["銛", "銽", "铦"],
    "zhé niè": ["銸"],
    "zhōng yōng": ["銿"],
    "tōu tù dòu": ["鋀"],
    "méi méng": ["鋂"],
    "wàn jiǎn": ["鋄", "鎫"],
    "tǐng dìng": ["鋌", "铤"],
    "juān jiān cuān": ["鋑"],
    "sī tuó": ["鋖"],
    "juān xuān juàn": ["鋗"],
    "wú huá wū": ["鋘"],
    "zhuó chuò": ["鋜"],
    "xíng xìng jīng": ["鋞"],
    "jū jú": ["鋦", "锔"],
    "zuì niè": ["鋷"],
    "yuān yuǎn wǎn wān": ["鋺"],
    "gāng gàng": ["鋼", "钢"],
    zhuī: ["錐", "锥", "騅", "骓", "鵻"],
    ā: ["錒", "锕"],
    "cuō chā": ["鎈"],
    "suǒ sè": ["鎍"],
    "yáo zú": ["鎐"],
    "yè tà gé": ["鎑"],
    "qiāng chēng": ["鎗"],
    "gé lì": ["鎘", "镉", "鬲"],
    "bī pī bì": ["鎞"],
    "gǎo hào": ["鎬"],
    "zú chuò": ["鏃"],
    "xiū xiù": ["鏅"],
    "shòu sōu": ["鏉"],
    "dí dī": ["鏑", "镝"],
    "qiāo sǎn càn": ["鏒"],
    "lù áo": ["鏕"],
    "tāng táng": ["鏜"],
    "jiàn zàn": ["鏩"],
    "huì suì ruì": ["鏸"],
    "qiǎng qiāng": ["鏹", "镪"],
    "sǎn xiàn sà": ["鏾"],
    "jiǎn jiàn": ["鐧", "锏"],
    "dāng chēng": ["鐺", "铛"],
    "zuān zuàn": ["鑽"],
    "sà xì": ["钑"],
    "yào yuè": ["钥"],
    "tǒu dǒu": ["钭"],
    "zuàn zuān": ["钻"],
    "qiān yán": ["铅"],
    "pí pī": ["铍"],
    "yáo diào tiáo": ["铫"],
    "tāng tàng": ["铴"],
    "pù pū": ["铺"],
    "tán xiān": ["锬"],
    "liù liú": ["镏"],
    "hào gǎo": ["镐"],
    "táng tāng": ["镗"],
    "tán chán xín": ["镡"],
    "huò shǎn": ["閄"],
    "hàn bì": ["閈", "闬"],
    "kāng kàng": ["閌", "闶"],
    "xián jiàn jiān jiǎn": ["閒"],
    "xiā xiǎ": ["閕"],
    "xiǎ kě": ["閜"],
    "biàn guān": ["閞"],
    "hé gé": ["閤", "颌"],
    "hòng xiàng": ["閧"],
    "sē xī": ["閪"],
    "tíng tǐng": ["閮"],
    "è yān": ["閼", "阏"],
    "hòng juǎn xiàng": ["闂"],
    "bǎn pàn": ["闆"],
    "dū shé": ["闍", "阇"],
    "què quē": ["闕"],
    "tāng táng chāng": ["闛"],
    "kàn hǎn": ["闞", "阚"],
    "xì sè tà": ["闟"],
    "mēn mèn": ["闷"],
    "quē què": ["阙"],
    "yán diàn": ["阽"],
    "ā ē": ["阿"],
    "bēi pō pí": ["陂"],
    "yàn yǎn": ["隁"],
    "yú yáo shù": ["隃"],
    "lóng lōng": ["隆"],
    "duì zhuì": ["隊"],
    "suí duò": ["隋"],
    "gāi qí ái": ["隑"],
    "huī duò": ["隓", "隳"],
    "wěi kuí": ["隗"],
    "lì dài": ["隸"],
    "zhuī cuī wéi": ["隹"],
    "hè hú": ["隺", "鶮"],
    "jùn juàn": ["隽", "雋"],
    "nán nàn nuó": ["难"],
    "què qiāo qiǎo": ["雀"],
    "guàn huán": ["雚"],
    "guī xī": ["雟"],
    "sè xí": ["雭"],
    án: ["雸"],
    "wù méng": ["雺"],
    tèng: ["霯"],
    "lù lòu": ["露"],
    mái: ["霾"],
    "jìng liàng": ["靚"],
    "gé jí": ["革"],
    bǎ: ["靶"],
    "yāng yàng": ["鞅"],
    "gé tà sǎ": ["鞈"],
    "biān yìng": ["鞕"],
    "qiào shāo": ["鞘"],
    "juān xuān": ["鞙"],
    "shàng zhǎng": ["鞝"],
    "pí bǐng bì bēi": ["鞞"],
    la: ["鞡"],
    "xiè dié": ["鞢"],
    ēng: ["鞥"],
    "móu mù": ["鞪"],
    "bì bǐng": ["鞸"],
    "mèi wà": ["韎"],
    rǒu: ["韖"],
    "shè xiè": ["韘"],
    "yùn wēn": ["韫"],
    "dùn dú": ["頓", "顿"],
    duǐ: ["頧"],
    luō: ["頱"],
    "bīn pín": ["頻"],
    yóng: ["顒", "颙", "鰫"],
    mān: ["顢", "颟"],
    "jǐng gěng": ["颈"],
    "jié xié jiá": ["颉"],
    "kē ké": ["颏"],
    "pín bīn": ["频"],
    "chàn zhàn": ["颤"],
    "fēng fěng": ["風", "风"],
    "biāo diū": ["颩"],
    "bá fú": ["颰"],
    "sāo sōu": ["颾"],
    "liù liáo": ["飂"],
    "shí sì yì": ["食"],
    "yǎng juàn": ["飬"],
    "zhù tǒu": ["飳"],
    "yí sì": ["飴"],
    "zuò zé zhā": ["飵"],
    tiè: ["飻", "餮"],
    "xiǎng náng": ["饟"],
    "táng xíng": ["饧"],
    "gē le": ["饹"],
    "chā zha": ["馇"],
    "náng nǎng": ["馕"],
    "yūn wò": ["馧"],
    "zhī shì": ["馶"],
    "xìn jìn": ["馸"],
    "kuài jué": ["駃"],
    zǎng: ["駔", "驵"],
    "tái dài": ["駘"],
    "xún xuān": ["駨"],
    "liáng láng": ["駺"],
    piàn: ["騗", "騙", "骗", "魸"],
    "dài tái": ["骀"],
    "sāo sǎo": ["骚"],
    "gǔ gū": ["骨"],
    "bèi mó": ["骳"],
    "xiāo qiāo": ["骹"],
    "bǎng pǎng": ["髈"],
    "bó jué": ["髉"],
    "bì pǒ": ["髲"],
    "máo méng": ["髳"],
    "kuò yuè": ["髺"],
    "bā bà": ["魞", "鲃"],
    "jì cǐ": ["鮆"],
    "bó bà": ["鮊"],
    "zhǎ zhà": ["鮓", "鲊"],
    "chóu dài": ["鮘"],
    "luò gé": ["鮥"],
    "guī xié wā kuí": ["鮭"],
    "xiān xiǎn": ["鮮", "鲜"],
    "pū bū": ["鯆"],
    "yì sī": ["鯣"],
    "bà bó": ["鲌"],
    "guī xié": ["鲑"],
    "sāi xǐ": ["鳃"],
    "niǎo diǎo": ["鳥"],
    "diāo zhāo": ["鳭"],
    "gān hàn yàn": ["鳱"],
    "fū guī": ["鳺"],
    "jiān qiān zhān": ["鳽"],
    "hé jiè": ["鶡"],
    "piān biǎn": ["鶣"],
    "chuàn zhì": ["鶨"],
    "cāng qiāng": ["鶬"],
    "sǔn xùn": ["鶽"],
    "biāo páo": ["麃"],
    "zhù cū": ["麆"],
    "jūn qún": ["麇", "麕"],
    chi: ["麶"],
    "mó me": ["麼"],
    "mó me ma": ["麽"],
    "mí mǒ": ["麿"],
    "dàn shèn": ["黮"],
    "zhěn yān": ["黰"],
    "dǎn zhǎn": ["黵"],
    "miǎn mǐn měng": ["黾"],
    hōu: ["齁"],
    nàng: ["齉"],
    "qí jì zī zhāi": ["齐"],
    "yín kěn yǎn": ["龂"],
    "yín kěn": ["龈"],
    "gōng wò": ["龏"],
    "guī jūn qiū": ["龜", "龟"],
    "kuí wā": ["䖯"],
    lōu: ["䁖"],
    "ōu qū": ["𫭟"],
    "lóu lǘ": ["𦝼"],
    "gǎ gā gá": ["嘎"],
    "wā guà": ["坬"],
    "zhǐ dǐ": ["茋"],
    "gǒng hóng": ["硔"],
    "yáo xiào": ["滧"]
  };
  const DICT1 = new FastDictFactory();
  Object.keys(map).forEach((key) => {
    const chars = map[key];
    for (let char of chars) {
      DICT1.set(char, key);
    }
  });
  const InitialList = [
    "zh",
    "ch",
    "sh",
    "z",
    "c",
    "s",
    "b",
    "p",
    "m",
    "f",
    "d",
    "t",
    "n",
    "l",
    "g",
    "k",
    "h",
    "j",
    "q",
    "x",
    "r",
    "y",
    "w",
    ""
  ];
  const SpecialInitialList = ["j", "q", "x"];
  const SpecialFinalList = [
    "uān",
    "uán",
    "uǎn",
    "uàn",
    "uan",
    "uē",
    "ué",
    "uě",
    "uè",
    "ue",
    "ūn",
    "ún",
    "ǔn",
    "ùn",
    "un",
    "ū",
    "ú",
    "ǔ",
    "ù",
    "u"
  ];
  const SpecialFinalMap = {
    uān: "üān",
    uán: "üán",
    uǎn: "üǎn",
    uàn: "üàn",
    uan: "üan",
    uē: "üē",
    ué: "üé",
    uě: "üě",
    uè: "üè",
    ue: "üe",
    ūn: "ǖn",
    ún: "ǘn",
    ǔn: "ǚn",
    ùn: "ǜn",
    un: "ün",
    ū: "ǖ",
    ú: "ǘ",
    ǔ: "ǚ",
    ù: "ǜ",
    u: "ü"
  };
  const doubleFinalList = [
    "ia",
    "ian",
    "iang",
    "iao",
    "ie",
    "iu",
    "iong",
    "ua",
    "uai",
    "uan",
    "uang",
    "ue",
    "ui",
    "uo",
    "üan",
    "üe",
    "van",
    "ve"
  ];
  const Numbers = {
    一: "yì",
    二: "èr",
    三: "sān",
    四: "sì",
    五: "wǔ",
    六: "liù",
    七: "qī",
    八: "bā",
    九: "jiǔ",
    十: "shí",
    百: "bǎi",
    千: "qiān",
    万: "wàn",
    亿: "yì",
    单: "dān",
    两: "liǎng",
    双: "shuāng",
    多: "duō",
    几: "jǐ",
    十一: "shí yī",
    零一: "líng yī",
    第一: "dì yī",
    一十: "yī shí",
    一十一: "yī shí yī"
  };
  const NumberWordMap = {
    重: "chóng",
    行: "háng",
    斗: "dǒu",
    更: "gēng"
  };
  function genNumberDict() {
    const dict = {
      零一: "líng yī",
      "〇一": "líng yī",
      十一: "shí yī",
      一十: "yī shí",
      第一: "dì yī",
      一十一: "yī shí yī"
    };
    for (let number in Numbers) {
      for (let key in NumberWordMap) {
        const word = `${number}${key}`;
        const pinyin2 = `${Numbers[number]} ${NumberWordMap[key]}`;
        dict[word] = pinyin2;
      }
    }
    return dict;
  }
  const NumberDict = genNumberDict();
  const PatternNumberDict = Object.keys(NumberDict).map((key) => ({
    zh: key,
    pinyin: NumberDict[key],
    probability: 1e-12,
    length: stringLength(key),
    priority: Priority.Normal,
    dict: Symbol("rule")
  }));
  const toneSandhiMap = {
    // 说不说，说一说，叠词之间发音为轻声
    不: {
      bú: [4]
      // "不" 后面跟 4 声时，变调为 2 声
    },
    一: {
      yí: [4],
      yì: [1, 2, 3]
    }
  };
  const toneSandhiIgnoreSuffix = {
    不: ["的", "而", "之", "后", "也", "还", "地"],
    一: ["的", "而", "之", "后", "也", "还", "是"]
  };
  const toneSandhiList = Object.keys(toneSandhiMap);
  function processToneSandhi(cur, pre, next) {
    if (toneSandhiList.indexOf(cur) === -1) {
      return getSingleWordPinyin(cur);
    }
    if (pre === next && pre && getSingleWordPinyin(pre) !== pre) {
      return getPinyinWithoutTone(getSingleWordPinyin(cur));
    }
    if (next && !toneSandhiIgnoreSuffix[cur].includes(next)) {
      const nextPinyin = getSingleWordPinyin(next);
      if (nextPinyin !== next) {
        const nextTone = getNumOfTone(nextPinyin);
        const pinyinMap = toneSandhiMap[cur];
        for (let pinyin2 in pinyinMap) {
          const tones = pinyinMap[pinyin2];
          if (tones.indexOf(Number(nextTone)) !== -1) {
            return pinyin2;
          }
        }
      }
    }
  }
  function processToneSandhiLiao(cur, pre) {
    if (cur === "了" && (!pre || !DICT1.get(pre))) {
      return "liǎo";
    }
  }
  function processReduplicationChar(cur, pre) {
    if (cur === "々") {
      if (!pre || !DICT1.get(pre)) {
        return "tóng";
      } else {
        return DICT1.get(pre).split(" ")[0];
      }
    }
  }
  function processSepecialPinyin(cur, pre, next) {
    return processReduplicationChar(cur, pre) || processToneSandhiLiao(cur, pre) || processToneSandhi(cur, pre, next) || getSingleWordPinyin(cur);
  }
  const Surnames = {
    南宫: "nán gōng",
    第五: "dì wǔ",
    万俟: "mò qí",
    司马: "sī mǎ",
    上官: "shàng guān",
    欧阳: "ōu yáng",
    夏侯: "xià hóu",
    诸葛: "zhū gě",
    闻人: "wén rén",
    东方: "dōng fāng",
    赫连: "hè lián",
    皇甫: "huáng fǔ",
    尉迟: "yù chí",
    公羊: "gōng yáng",
    澹台: "tán tái",
    公冶: "gōng yě",
    宗政: "zōng zhèng",
    濮阳: "pú yáng",
    淳于: "chún yú",
    太叔: "tài shū",
    申屠: "shēn tú",
    公孙: "gōng sūn",
    仲孙: "zhòng sūn",
    轩辕: "xuān yuán",
    令狐: "líng hú",
    钟离: "zhōng lí",
    宇文: "yǔ wén",
    长孙: "zhǎng sūn",
    慕容: "mù róng",
    鲜于: "xiān yú",
    闾丘: "lǘ qiū",
    司徒: "sī tú",
    司空: "sī kōng",
    亓官: "qí guān",
    司寇: "sī kòu",
    仉督: "zhǎng dū",
    子车: "zǐ jū",
    颛孙: "zhuān sūn",
    端木: "duān mù",
    巫马: "wū mǎ",
    公西: "gōng xī",
    漆雕: "qī diāo",
    乐正: "yuè zhèng",
    壤驷: "rǎng sì",
    公良: "gōng liáng",
    拓跋: "tuò bá",
    夹谷: "jiá gǔ",
    宰父: "zǎi fǔ",
    榖梁: "gǔ liáng",
    段干: "duàn gān",
    百里: "bǎi lǐ",
    东郭: "dōng guō",
    南门: "nán mén",
    呼延: "hū yán",
    羊舌: "yáng shé",
    梁丘: "liáng qiū",
    左丘: "zuǒ qiū",
    东门: "dōng mén",
    西门: "xī mén",
    句龙: "gōu lóng",
    毌丘: "guàn qiū",
    赵: "zhào",
    钱: "qián",
    孙: "sūn",
    李: "lǐ",
    周: "zhōu",
    吴: "wú",
    郑: "zhèng",
    王: "wáng",
    冯: "féng",
    陈: "chén",
    褚: "chǔ",
    卫: "wèi",
    蒋: "jiǎng",
    沈: "shěn",
    韩: "hán",
    杨: "yáng",
    朱: "zhū",
    秦: "qín",
    尤: "yóu",
    许: "xǔ",
    何: "hé",
    吕: "lǚ",
    施: "shī",
    张: "zhāng",
    孔: "kǒng",
    曹: "cáo",
    严: "yán",
    华: "huà",
    金: "jīn",
    魏: "wèi",
    陶: "táo",
    姜: "jiāng",
    戚: "qī",
    谢: "xiè",
    邹: "zōu",
    喻: "yù",
    柏: "bǎi",
    水: "shuǐ",
    窦: "dòu",
    章: "zhāng",
    云: "yún",
    苏: "sū",
    潘: "pān",
    葛: "gě",
    奚: "xī",
    范: "fàn",
    彭: "péng",
    郎: "láng",
    鲁: "lǔ",
    韦: "wéi",
    昌: "chāng",
    马: "mǎ",
    苗: "miáo",
    凤: "fèng",
    花: "huā",
    方: "fāng",
    俞: "yú",
    任: "rén",
    袁: "yuán",
    柳: "liǔ",
    酆: "fēng",
    鲍: "bào",
    史: "shǐ",
    唐: "táng",
    费: "fèi",
    廉: "lián",
    岑: "cén",
    薛: "xuē",
    雷: "léi",
    贺: "hè",
    倪: "ní",
    汤: "tāng",
    滕: "téng",
    殷: "yīn",
    罗: "luó",
    毕: "bì",
    郝: "hǎo",
    邬: "wū",
    安: "ān",
    常: "cháng",
    乐: "yuè",
    于: "yú",
    时: "shí",
    傅: "fù",
    皮: "pí",
    卞: "biàn",
    齐: "qí",
    康: "kāng",
    伍: "wǔ",
    余: "yú",
    元: "yuán",
    卜: "bǔ",
    顾: "gù",
    孟: "mèng",
    平: "píng",
    黄: "huáng",
    和: "hé",
    穆: "mù",
    萧: "xiāo",
    尹: "yǐn",
    姚: "yáo",
    邵: "shào",
    湛: "zhàn",
    汪: "wāng",
    祁: "qí",
    毛: "máo",
    禹: "yǔ",
    狄: "dí",
    米: "mǐ",
    贝: "bèi",
    明: "míng",
    臧: "zāng",
    计: "jì",
    伏: "fú",
    成: "chéng",
    戴: "dài",
    谈: "tán",
    宋: "sòng",
    茅: "máo",
    庞: "páng",
    熊: "xióng",
    纪: "jǐ",
    舒: "shū",
    屈: "qū",
    项: "xiàng",
    祝: "zhù",
    董: "dǒng",
    梁: "liáng",
    杜: "dù",
    阮: "ruǎn",
    蓝: "lán",
    闵: "mǐn",
    席: "xí",
    季: "jì",
    麻: "má",
    强: "qiáng",
    贾: "jiǎ",
    路: "lù",
    娄: "lóu",
    危: "wēi",
    江: "jiāng",
    童: "tóng",
    颜: "yán",
    郭: "guō",
    梅: "méi",
    盛: "shèng",
    林: "lín",
    刁: "diāo",
    钟: "zhōng",
    徐: "xú",
    邱: "qiū",
    骆: "luò",
    高: "gāo",
    夏: "xià",
    蔡: "cài",
    田: "tián",
    樊: "fán",
    胡: "hú",
    凌: "líng",
    霍: "huò",
    虞: "yú",
    万: "wàn",
    支: "zhī",
    柯: "kē",
    昝: "zǎn",
    管: "guǎn",
    卢: "lú",
    莫: "mò",
    经: "jīng",
    房: "fáng",
    裘: "qiú",
    缪: "miào",
    干: "gān",
    解: "xiè",
    应: "yīng",
    宗: "zōng",
    丁: "dīng",
    宣: "xuān",
    贲: "bēn",
    邓: "dèng",
    郁: "yù",
    单: "shàn",
    杭: "háng",
    洪: "hóng",
    包: "bāo",
    诸: "zhū",
    左: "zuǒ",
    石: "shí",
    崔: "cuī",
    吉: "jí",
    钮: "niǔ",
    龚: "gōng",
    程: "chéng",
    嵇: "jī",
    邢: "xíng",
    滑: "huá",
    裴: "péi",
    陆: "lù",
    荣: "róng",
    翁: "wēng",
    荀: "xún",
    羊: "yáng",
    於: "yū",
    惠: "huì",
    甄: "zhēn",
    曲: "qū",
    家: "jiā",
    封: "fēng",
    芮: "ruì",
    羿: "yì",
    储: "chǔ",
    靳: "jìn",
    汲: "jí",
    邴: "bǐng",
    糜: "mí",
    松: "sōng",
    井: "jǐng",
    段: "duàn",
    富: "fù",
    巫: "wū",
    乌: "wū",
    焦: "jiāo",
    巴: "bā",
    弓: "gōng",
    牧: "mù",
    隗: "wěi",
    山: "shān",
    谷: "gǔ",
    车: "chē",
    侯: "hóu",
    宓: "mì",
    蓬: "péng",
    全: "quán",
    郗: "xī",
    班: "bān",
    仰: "yǎng",
    秋: "qiū",
    仲: "zhòng",
    伊: "yī",
    宫: "gōng",
    宁: "nìng",
    仇: "qiú",
    栾: "luán",
    暴: "bào",
    甘: "gān",
    钭: "tǒu",
    厉: "lì",
    戎: "róng",
    祖: "zǔ",
    武: "wǔ",
    符: "fú",
    刘: "liú",
    景: "jǐng",
    詹: "zhān",
    束: "shù",
    龙: "lóng",
    叶: "yè",
    幸: "xìng",
    司: "sī",
    韶: "sháo",
    郜: "gào",
    黎: "lí",
    蓟: "jì",
    薄: "bó",
    印: "yìn",
    宿: "sù",
    白: "bái",
    怀: "huái",
    蒲: "pú",
    邰: "tái",
    从: "cóng",
    鄂: "è",
    索: "suǒ",
    咸: "xián",
    籍: "jí",
    赖: "lài",
    卓: "zhuó",
    蔺: "lìn",
    屠: "tú",
    蒙: "méng",
    池: "chí",
    乔: "qiáo",
    阴: "yīn",
    鬱: "yù",
    胥: "xū",
    能: "nài",
    苍: "cāng",
    双: "shuāng",
    闻: "wén",
    莘: "shēn",
    党: "dǎng",
    翟: "zhái",
    谭: "tán",
    贡: "gòng",
    劳: "láo",
    逄: "páng",
    姬: "jī",
    申: "shēn",
    扶: "fú",
    堵: "dǔ",
    冉: "rǎn",
    宰: "zǎi",
    郦: "lì",
    雍: "yōng",
    郤: "xì",
    璩: "qú",
    桑: "sāng",
    桂: "guì",
    濮: "pú",
    牛: "niú",
    寿: "shòu",
    通: "tōng",
    边: "biān",
    扈: "hù",
    燕: "yān",
    冀: "jì",
    郏: "jiá",
    浦: "pǔ",
    尚: "shàng",
    农: "nóng",
    温: "wēn",
    别: "bié",
    庄: "zhuāng",
    晏: "yàn",
    柴: "chái",
    瞿: "qú",
    阎: "yán",
    充: "chōng",
    慕: "mù",
    连: "lián",
    茹: "rú",
    习: "xí",
    宦: "huàn",
    艾: "ài",
    鱼: "yú",
    容: "róng",
    向: "xiàng",
    古: "gǔ",
    易: "yì",
    慎: "shèn",
    戈: "gē",
    廖: "liào",
    庾: "yǔ",
    终: "zhōng",
    暨: "jì",
    居: "jū",
    衡: "héng",
    步: "bù",
    都: "dū",
    耿: "gěng",
    满: "mǎn",
    弘: "hóng",
    匡: "kuāng",
    国: "guó",
    文: "wén",
    寇: "kòu",
    广: "guǎng",
    禄: "lù",
    阙: "quē",
    东: "dōng",
    欧: "ōu",
    殳: "shū",
    沃: "wò",
    利: "lì",
    蔚: "wèi",
    越: "yuè",
    夔: "kuí",
    隆: "lóng",
    师: "shī",
    巩: "gǒng",
    厍: "shè",
    聂: "niè",
    晁: "cháo",
    勾: "gōu",
    敖: "áo",
    融: "róng",
    冷: "lěng",
    訾: "zī",
    辛: "xīn",
    阚: "kàn",
    那: "nā",
    简: "jiǎn",
    饶: "ráo",
    空: "kōng",
    曾: "zēng",
    母: "mǔ",
    沙: "shā",
    乜: "niè",
    养: "yǎng",
    鞠: "jū",
    须: "xū",
    丰: "fēng",
    巢: "cháo",
    关: "guān",
    蒯: "kuǎi",
    相: "xiàng",
    查: "zhā",
    后: "hòu",
    荆: "jīng",
    红: "hóng",
    游: "yóu",
    竺: "zhú",
    权: "quán",
    逯: "lù",
    盖: "gě",
    益: "yì",
    桓: "huán",
    公: "gōng",
    牟: "móu",
    哈: "hǎ",
    言: "yán",
    福: "fú",
    肖: "xiāo",
    区: "ōu",
    覃: "qín",
    朴: "piáo",
    繁: "pó",
    员: "yùn",
    句: "gōu",
    要: "yāo",
    过: "guō",
    钻: "zuān",
    谌: "chén",
    折: "shé",
    召: "shào",
    郄: "qiè",
    撒: "sǎ",
    甯: "nìng",
    六: "lù",
    啜: "chuài",
    行: "xíng"
  };
  const PatternSurname = Object.keys(Surnames).map((key) => ({
    zh: key,
    pinyin: Surnames[key],
    probability: 1 + stringLength(key),
    length: stringLength(key),
    priority: Priority.Surname,
    dict: Symbol("surname")
  }));
  const DICT2 = {
    这个: "zhè ge",
    成为: "chéng wéi",
    认为: "rèn wéi",
    作为: "zuò wéi",
    部分: "bù fen",
    要求: "yāo qiú",
    应该: "yīng gāi",
    增长: "zēng zhǎng",
    提供: "tí gōng",
    觉得: "jué de",
    任务: "rèn wu",
    那个: "nà ge",
    称为: "chēng wéi",
    为主: "wéi zhǔ",
    了解: "liǎo jiě",
    处理: "chǔ lǐ",
    皇上: "huáng shang",
    只要: "zhǐ yào",
    大量: "dà liàng",
    力量: "lì liàng",
    几乎: "jī hū",
    干部: "gàn bù",
    目的: "mù dì",
    行为: "xíng wéi",
    只见: "zhǐ jiàn",
    认识: "rèn shi",
    市长: "shì zhǎng",
    师父: "shī fu",
    调查: "diào chá",
    重新: "chóng xīn",
    分为: "fēn wéi",
    知识: "zhī shi",
    导弹: "dǎo dàn",
    质量: "zhì liàng",
    行款: "háng kuǎn",
    行列: "háng liè",
    行话: "háng huà",
    行业: "háng yè",
    隔行: "gé háng",
    在行: "zài háng",
    行家: "háng jia",
    内行: "nèi háng",
    外行: "wài háng",
    同行: "tóng háng",
    本行: "běn háng",
    行伍: "háng wǔ",
    洋行: "yáng háng",
    银行: "yín háng",
    商行: "shāng háng",
    支行: "zhī háng",
    总行: "zǒng háng",
    行情: "háng qíng",
    懂行: "dǒng háng",
    行规: "háng guī",
    行当: "háng dang",
    行货: "háng huò",
    太行: "tài háng",
    入行: "rù háng",
    中行: "zhōng háng",
    农行: "nóng háng",
    工行: "gōng háng",
    建行: "jiàn háng",
    各行: "gè háng",
    行号: "háng hào",
    行高: "háng gāo",
    行首: "háng shǒu",
    行尾: "háng wěi",
    行末: "háng mò",
    行长: "háng cháng",
    行距: "háng jù",
    换行: "huàn háng",
    行会: "háng huì",
    行辈: "háng bèi",
    行道: "háng dào",
    道行: "dào heng",
    参与: "cān yù",
    充分: "chōng fèn",
    尽管: "jǐn guǎn",
    生长: "shēng zhǎng",
    数量: "shù liàng",
    应当: "yīng dāng",
    院长: "yuàn zhǎng",
    强调: "qiáng diào",
    只能: "zhǐ néng",
    音乐: "yīn yuè",
    以为: "yǐ wéi",
    处于: "chǔ yú",
    部长: "bù zhǎng",
    蒙古: "měng gǔ",
    只有: "zhǐ yǒu",
    适当: "shì dàng",
    只好: "zhǐ hǎo",
    成长: "chéng zhǎng",
    高兴: "gāo xìng",
    不了: "bù liǎo",
    产量: "chǎn liàng",
    胖子: "pàng zi",
    显得: "xiǎn de",
    只是: "zhǐ shì",
    似的: "shì de",
    率领: "shuài lǐng",
    改为: "gǎi wéi",
    不禁: "bù jīn",
    成分: "chéng fèn",
    答应: "dā ying",
    少年: "shào nián",
    兴趣: "xìng qù",
    太监: "tài jian",
    休息: "xiū xi",
    校长: "xiào zhǎng",
    更新: "gēng xīn",
    合同: "hé tong",
    喝道: "hè dào",
    重庆: "chóng qìng",
    重建: "chóng jiàn",
    使得: "shǐ de",
    审查: "shěn chá",
    累计: "lěi jì",
    给予: "jǐ yǔ",
    极为: "jí wéi",
    冠军: "guàn jūn",
    仿佛: "fǎng fú",
    头发: "tóu fa",
    投降: "tóu xiáng",
    家长: "jiā zhǎng",
    仔细: "zǐ xì",
    要是: "yào shi",
    将领: "jiàng lǐng",
    含量: "hán liàng",
    更为: "gèng wéi",
    积累: "jī lěi",
    地处: "dì chǔ",
    县长: "xiàn zhǎng",
    少女: "shào nǚ",
    路上: "lù shang",
    只怕: "zhǐ pà",
    能量: "néng liàng",
    储量: "chǔ liàng",
    供应: "gōng yìng",
    挑战: "tiǎo zhàn",
    西藏: "xī zàng",
    记得: "jì de",
    总量: "zǒng liàng",
    当真: "dàng zhēn",
    将士: "jiàng shì",
    差别: "chā bié",
    较为: "jiào wéi",
    长老: "zhǎng lǎo",
    大夫: "dài fu",
    差异: "chā yì",
    懂得: "dǒng de",
    尽量: "jǐn liàng",
    模样: "mú yàng",
    的确: "dí què",
    为首: "wéi shǒu",
    便宜: "pián yi",
    更名: "gēng míng",
    石头: "shí tou",
    州长: "zhōu zhǎng",
    为止: "wéi zhǐ",
    漂亮: "piào liang",
    炮弹: "pào dàn",
    藏族: "zàng zú",
    角色: "jué sè",
    当作: "dàng zuò",
    尽快: "jǐn kuài",
    人为: "rén wéi",
    重复: "chóng fù",
    胡同: "hú tòng",
    差距: "chā jù",
    弟兄: "dì xiong",
    大将: "dà jiàng",
    睡觉: "shuì jiào",
    一觉: "yí jiào",
    团长: "tuán zhǎng",
    队长: "duì zhǎng",
    区长: "qū zhǎng",
    难得: "nán dé",
    丫头: "yā tou",
    会长: "huì zhǎng",
    弟弟: "dì di",
    王爷: "wáng ye",
    重量: "zhòng liàng",
    誉为: "yù wéi",
    家伙: "jiā huo",
    华山: "huà shān",
    椅子: "yǐ zi",
    流量: "liú liàng",
    长大: "zhǎng dà",
    勉强: "miǎn qiǎng",
    会计: "kuài jì",
    过分: "guò fèn",
    济南: "jǐ nán",
    调动: "diào dòng",
    燕京: "yān jīng",
    少将: "shào jiàng",
    中毒: "zhòng dú",
    晓得: "xiǎo de",
    变更: "biàn gēng",
    打更: "dǎ gēng",
    认得: "rèn de",
    苹果: "píng guǒ",
    念头: "niàn tou",
    挣扎: "zhēng zhá",
    三藏: "sān zàng",
    剥削: "bō xuē",
    丞相: "chéng xiàng",
    少量: "shǎo liàng",
    寻思: "xún si",
    夺得: "duó dé",
    干线: "gàn xiàn",
    呼吁: "hū yù",
    处罚: "chǔ fá",
    长官: "zhǎng guān",
    柏林: "bó lín",
    亲戚: "qīn qi",
    身分: "shēn fèn",
    胳膊: "gē bo",
    着手: "zhuó shǒu",
    炸弹: "zhà dàn",
    咳嗽: "ké sou",
    叶子: "yè zi",
    外长: "wài zhǎng",
    供给: "gōng jǐ",
    师长: "shī zhǎng",
    变量: "biàn liàng",
    应有: "yīng yǒu",
    下载: "xià zài",
    乐器: "yuè qì",
    间接: "jiàn jiē",
    底下: "dǐ xià",
    打扮: "dǎ bàn",
    子弹: "zǐ dàn",
    弹药: "dàn yào",
    热量: "rè liàng",
    削弱: "xuē ruò",
    骨干: "gǔ gàn",
    容量: "róng liàng",
    模糊: "mó hu",
    转动: "zhuàn dòng",
    称呼: "chēng hu",
    科长: "kē zhǎng",
    处置: "chǔ zhì",
    着重: "zhuó zhòng",
    着急: "zháo jí",
    强迫: "qiǎng pò",
    庭长: "tíng zhǎng",
    首相: "shǒu xiàng",
    喇嘛: "lǎ ma",
    镇长: "zhèn zhǎng",
    只管: "zhǐ guǎn",
    重重: "chóng chóng",
    免得: "miǎn de",
    着实: "zhuó shí",
    度假: "dù jià",
    真相: "zhēn xiàng",
    相貌: "xiàng mào",
    处分: "chǔ fèn",
    委屈: "wěi qu",
    为期: "wéi qī",
    伯伯: "bó bo",
    伯子: "bǎi zi",
    圈子: "quān zi",
    见识: "jiàn shi",
    笼罩: "lǒng zhào",
    与会: "yù huì",
    都督: "dū du",
    都市: "dū shì",
    成都: "chéng dū",
    首都: "shǒu dū",
    帝都: "dì dū",
    王都: "wáng dū",
    东都: "dōng dū",
    都护: "dū hù",
    都城: "dū chéng",
    建都: "jiàn dū",
    迁都: "qiān dū",
    故都: "gù dū",
    定都: "dìng dū",
    中都: "zhōng dū",
    六安: "lù ān",
    宰相: "zǎi xiàng",
    较量: "jiào liàng",
    对称: "duì chèn",
    总长: "zǒng zhǎng",
    相公: "xiàng gong",
    空白: "kòng bái",
    打量: "dǎ liang",
    水分: "shuǐ fèn",
    舌头: "shé tou",
    没收: "mò shōu",
    行李: "xíng li",
    判处: "pàn chǔ",
    散文: "sǎn wén",
    处境: "chǔ jìng",
    孙子: "sūn zi",
    拳头: "quán tou",
    打发: "dǎ fā",
    组长: "zǔ zhǎng",
    骨头: "gǔ tou",
    宁可: "nìng kě",
    更换: "gēng huàn",
    薄弱: "bó ruò",
    还原: "huán yuán",
    重修: "chóng xiū",
    重来: "chóng lái",
    只顾: "zhǐ gù",
    爱好: "ài hào",
    馒头: "mán tou",
    军长: "jūn zhǎng",
    首长: "shǒu zhǎng",
    厂长: "chǎng zhǎng",
    司长: "sī zhǎng",
    长子: "zhǎng zǐ",
    强劲: "qiáng jìng",
    恰当: "qià dàng",
    头儿: "tóu er",
    站长: "zhàn zhǎng",
    折腾: "zhē teng",
    相处: "xiāng chǔ",
    统率: "tǒng shuài",
    中将: "zhōng jiàng",
    命中: "mìng zhòng",
    名将: "míng jiàng",
    木头: "mù tou",
    动弹: "dòng tan",
    地壳: "dì qiào",
    干活: "gàn huó",
    少爷: "shào ye",
    水量: "shuǐ liàng",
    补给: "bǔ jǐ",
    尾巴: "wěi ba",
    来得: "lái de",
    好奇: "hào qí",
    钥匙: "yào shi",
    当做: "dàng zuò",
    沉着: "chén zhuó",
    哑巴: "yǎ ba",
    车子: "chē zi",
    上将: "shàng jiàng",
    恶心: "ě xīn",
    担子: "dàn zi",
    应届: "yīng jiè",
    主角: "zhǔ jué",
    运转: "yùn zhuǎn",
    兄长: "xiōng zhǎng",
    格式: "gé shì",
    正月: "zhēng yuè",
    营长: "yíng zhǎng",
    当成: "dàng chéng",
    女婿: "nǚ xu",
    咽喉: "yān hóu",
    重阳: "chóng yáng",
    化为: "huà wéi",
    吐蕃: "tǔ bō",
    钻进: "zuān jìn",
    乐队: "yuè duì",
    亮相: "liàng xiàng",
    被子: "bèi zi",
    舍得: "shě de",
    杉木: "shā mù",
    击中: "jī zhòng",
    排长: "pái zhǎng",
    假期: "jià qī",
    分量: "fèn liàng",
    数次: "shù cì",
    提防: "dī fáng",
    吆喝: "yāo he",
    查处: "chá chǔ",
    量子: "liàng zǐ",
    里头: "lǐ tou",
    调研: "diào yán",
    伺候: "cì hou",
    重申: "chóng shēn",
    枕头: "zhěn tou",
    拚命: "pīn mìng",
    社长: "shè zhǎng",
    归还: "guī huán",
    批量: "pī liàng",
    畜牧: "xù mù",
    点着: "diǎn zháo",
    甚为: "shèn wéi",
    小将: "xiǎo jiàng",
    着眼: "zhuó yǎn",
    处死: "chǔ sǐ",
    厌恶: "yàn wù",
    鼓乐: "gǔ yuè",
    树干: "shù gàn",
    秘鲁: "bì lǔ",
    大方: "dà fāng",
    外头: "wài tou",
    班长: "bān zhǎng",
    星宿: "xīng xiù",
    宁愿: "nìng yuàn",
    钦差: "qīn chāi",
    为数: "wéi shù",
    勾当: "gòu dàng",
    削减: "xuē jiǎn",
    间谍: "jiàn dié",
    埋怨: "mán yuàn",
    结实: "jiē shi",
    计量: "jì liáng",
    淹没: "yān mò",
    村长: "cūn zhǎng",
    连长: "lián zhǎng",
    自给: "zì jǐ",
    武将: "wǔ jiàng",
    温差: "wēn chā",
    直奔: "zhí bèn",
    供求: "gōng qiú",
    剂量: "jì liàng",
    道长: "dào zhǎng",
    泄露: "xiè lòu",
    王八: "wáng ba",
    切割: "qiē gē",
    间隔: "jiàn gé",
    一晃: "yì huǎng",
    长假: "cháng jià",
    令狐: "líng hú",
    为害: "wéi hài",
    句子: "jù zi",
    偿还: "cháng huán",
    疙瘩: "gē da",
    燕山: "yān shān",
    堵塞: "dǔ sè",
    夺冠: "duó guàn",
    扎实: "zhā shi",
    电荷: "diàn hè",
    看守: "kān shǒu",
    复辟: "fù bì",
    郁闷: "yù mèn",
    尽早: "jǐn zǎo",
    切断: "qiē duàn",
    指头: "zhǐ tou",
    为生: "wéi shēng",
    畜生: "chù sheng",
    切除: "qiē chú",
    着力: "zhuó lì",
    着想: "zhuó xiǎng",
    级差: "jí chā",
    投奔: "tóu bèn",
    棍子: "gùn zi",
    含糊: "hán hu",
    少妇: "shào fù",
    兴致: "xìng zhì",
    纳闷: "nà mèn",
    干流: "gàn liú",
    卷起: "juǎn qǐ",
    扇子: "shàn zi",
    更改: "gēng gǎi",
    笼络: "lǒng luò",
    喇叭: "lǎ ba",
    载荷: "zài hè",
    妥当: "tuǒ dàng",
    为难: "wéi nán",
    着陆: "zhuó lù",
    燕子: "yàn zi",
    干吗: "gàn má",
    白发: "bái fà",
    总得: "zǒng děi",
    夹击: "jiā jī",
    曝光: "bào guāng",
    曲调: "qǔ diào",
    相机: "xiàng jī",
    叫化: "jiào huà",
    角逐: "jué zhú",
    啊哟: "ā yō",
    载重: "zài zhòng",
    长辈: "zhǎng bèi",
    出差: "chū chāi",
    垛口: "duǒ kǒu",
    撇开: "piē kāi",
    厅长: "tīng zhǎng",
    组分: "zǔ fèn",
    误差: "wù chā",
    家当: "jiā dàng",
    传记: "zhuàn jì",
    个子: "gè zi",
    铺设: "pū shè",
    干事: "gàn shì",
    杆菌: "gǎn jūn",
    定量: "dìng liàng",
    运载: "yùn zài",
    会儿: "huì er",
    酋长: "qiú zhǎng",
    重返: "chóng fǎn",
    差额: "chā é",
    露面: "lòu miàn",
    钻研: "zuān yán",
    大城: "dài chéng",
    上当: "shàng dàng",
    销量: "xiāo liàng",
    作坊: "zuō fang",
    照相: "zhào xiàng",
    哎呀: "āi yā",
    调集: "diào jí",
    看中: "kàn zhòng",
    议长: "yì zhǎng",
    风筝: "fēng zheng",
    辟邪: "bì xié",
    空隙: "kòng xì",
    更迭: "gēng dié",
    偏差: "piān chā",
    声调: "shēng diào",
    适量: "shì liàng",
    屯子: "tún zi",
    无量: "wú liàng",
    空地: "kòng dì",
    调度: "diào dù",
    散射: "sǎn shè",
    创伤: "chuāng shāng",
    海参: "hǎi shēn",
    满载: "mǎn zài",
    重叠: "chóng dié",
    落差: "luò chā",
    单调: "dān diào",
    老将: "lǎo jiàng",
    人参: "rén shēn",
    间断: "jiàn duàn",
    重现: "chóng xiàn",
    夹杂: "jiā zá",
    调用: "diào yòng",
    萝卜: "luó bo",
    附着: "fù zhuó",
    应声: "yìng shēng",
    主将: "zhǔ jiàng",
    罪过: "zuì guo",
    咀嚼: "jǔ jué",
    为政: "wéi zhèng",
    过量: "guò liàng",
    乐曲: "yuè qǔ",
    负荷: "fù hè",
    枪弹: "qiāng dàn",
    悄然: "qiǎo rán",
    处方: "chǔ fāng",
    悄声: "qiǎo shēng",
    曲子: "qǔ zi",
    情调: "qíng diào",
    挑衅: "tiǎo xìn",
    代为: "dài wéi",
    了结: "liǎo jié",
    打中: "dǎ zhòng",
    酒吧: "jiǔ bā",
    懒得: "lǎn de",
    增量: "zēng liàng",
    衣着: "yī zhuó",
    部将: "bù jiàng",
    要塞: "yào sài",
    茶几: "chá jī",
    杠杆: "gàng gǎn",
    出没: "chū mò",
    鲜有: "xiǎn yǒu",
    间隙: "jiàn xì",
    重担: "zhòng dàn",
    重演: "chóng yǎn",
    重试: "chóng shì",
    应酬: "yìng chou",
    只当: "zhǐ dāng",
    毋宁: "wú nìng",
    包扎: "bāo zā",
    前头: "qián tou",
    卷烟: "juǎn yān",
    非得: "fēi děi",
    弹道: "dàn dào",
    杆子: "gān zi",
    门将: "mén jiàng",
    后头: "hòu tou",
    喝彩: "hè cǎi",
    暖和: "nuǎn huo",
    累积: "lěi jī",
    调遣: "diào qiǎn",
    倔强: "jué jiàng",
    宝藏: "bǎo zàng",
    丧事: "sāng shì",
    约莫: "yuē mo",
    纤夫: "qiàn fū",
    更替: "gēng tì",
    装载: "zhuāng zài",
    背包: "bēi bāo",
    帖子: "tiě zi",
    松散: "sōng sǎn",
    呼喝: "hū hè",
    可恶: "kě wù",
    自转: "zì zhuàn",
    供电: "gōng diàn",
    反省: "fǎn xǐng",
    坦率: "tǎn shuài",
    苏打: "sū dá",
    本分: "běn fèn",
    落得: "luò de",
    鄙薄: "bǐ bó",
    相间: "xiāng jiàn",
    单薄: "dān bó",
    混蛋: "hún dàn",
    贞观: "zhēn guān",
    附和: "fù hè",
    能耐: "néng nài",
    吓唬: "xià hu",
    未了: "wèi liǎo",
    引着: "yǐn zháo",
    抽调: "chōu diào",
    沙子: "shā zi",
    席卷: "xí juǎn",
    标的: "biāo dì",
    别扭: "biè niu",
    思量: "sī liang",
    喝采: "hè cǎi",
    论语: "lún yǔ",
    盖子: "gài zi",
    分外: "fèn wài",
    弄堂: "lòng táng",
    乐舞: "yuè wǔ",
    雨量: "yǔ liàng",
    毛发: "máo fà",
    差遣: "chāi qiǎn",
    背负: "bēi fù",
    转速: "zhuàn sù",
    声乐: "shēng yuè",
    夹攻: "jiā gōng",
    供水: "gōng shuǐ",
    主干: "zhǔ gàn",
    惩处: "chéng chǔ",
    长相: "zhǎng xiàng",
    公差: "gōng chāi",
    榴弹: "liú dàn",
    省得: "shěng de",
    条子: "tiáo zi",
    重围: "chóng wéi",
    阻塞: "zǔ sè",
    劲风: "jìng fēng",
    纠葛: "jiū gé",
    颠簸: "diān bǒ",
    点中: "diǎn zhòng",
    重创: "zhòng chuāng",
    姥姥: "lǎo lao",
    迷糊: "mí hu",
    公家: "gōng jia",
    几率: "jī lǜ",
    苦闷: "kǔ mèn",
    度量: "dù liàng",
    差错: "chā cuò",
    暑假: "shǔ jià",
    参差: "cēn cī",
    搭载: "dā zài",
    助长: "zhù zhǎng",
    相称: "xiāng chèn",
    红晕: "hóng yùn",
    舍命: "shě mìng",
    喜好: "xǐ hào",
    列传: "liè zhuàn",
    劲敌: "jìng dí",
    蛤蟆: "há ma",
    请假: "qǐng jià",
    钉子: "dīng zi",
    沉没: "chén mò",
    高丽: "gāo lí",
    休假: "xiū jià",
    无为: "wú wéi",
    巴结: "bā jie",
    了得: "liǎo dé",
    变相: "biàn xiàng",
    核弹: "hé dàn",
    亲家: "qìng jia",
    承载: "chéng zài",
    喝问: "hè wèn",
    还击: "huán jī",
    交还: "jiāo huán",
    将令: "jiàng lìng",
    单于: "chán yú",
    空缺: "kòng quē",
    绿林: "lù lín",
    胆量: "dǎn liàng",
    执着: "zhí zhuó",
    低调: "dī diào",
    闭塞: "bì sè",
    轻薄: "qīng bó",
    得当: "dé dàng",
    占卜: "zhān bǔ",
    扫帚: "sào zhou",
    龟兹: "qiū cí",
    年长: "nián zhǎng",
    外传: "wài zhuàn",
    头子: "tóu zi",
    裁缝: "cái feng",
    礼乐: "lǐ yuè",
    血泊: "xuè pō",
    散乱: "sǎn luàn",
    动量: "dòng liàng",
    倒腾: "dǎo teng",
    取舍: "qǔ shě",
    咱家: "zán jiā",
    长发: "cháng fà",
    爪哇: "zhǎo wā",
    弹壳: "dàn ké",
    省悟: "xǐng wù",
    嚷嚷: "rāng rang",
    连累: "lián lèi",
    应得: "yīng dé",
    族长: "zú zhǎng",
    柜子: "guì zi",
    擂鼓: "léi gǔ",
    眩晕: "xuàn yùn",
    调配: "tiáo pèi",
    躯干: "qū gàn",
    差役: "chāi yì",
    坎坷: "kǎn kě",
    少儿: "shào ér",
    乐团: "yuè tuán",
    养分: "yǎng fèn",
    退还: "tuì huán",
    格调: "gé diào",
    语调: "yǔ diào",
    音调: "yīn diào",
    乐府: "yuè fǔ",
    古朴: "gǔ pǔ",
    打点: "dǎ diǎn",
    差使: "chāi shǐ",
    匀称: "yún chèn",
    瘦削: "shòu xuē",
    膏药: "gāo yao",
    吞没: "tūn mò",
    调任: "diào rèn",
    散居: "sǎn jū",
    上头: "shàng tóu",
    风靡: "fēng mǐ",
    放假: "fàng jià",
    估量: "gū liang",
    失当: "shī dàng",
    中弹: "zhòng dàn",
    妄为: "wàng wéi",
    长者: "zhǎng zhě",
    起哄: "qǐ hòng",
    末了: "mò liǎo",
    相声: "xiàng sheng",
    校正: "jiào zhèng",
    劝降: "quàn xiáng",
    矢量: "shǐ liàng",
    沉闷: "chén mèn",
    给与: "jǐ yǔ",
    解法: "jiě fǎ",
    塞外: "sài wài",
    将校: "jiàng xiào",
    嗜好: "shì hào",
    没落: "mò luò",
    朴刀: "pō dāo",
    片子: "piān zi",
    切削: "qiē xiāo",
    弹丸: "dàn wán",
    稀薄: "xī bó",
    亏得: "kuī dé",
    间歇: "jiàn xiē",
    翘首: "qiáo shǒu",
    色调: "sè diào",
    处决: "chǔ jué",
    表率: "biǎo shuài",
    尺子: "chǐ zi",
    招降: "zhāo xiáng",
    称职: "chèn zhí",
    斗篷: "dǒu peng",
    铺子: "pù zi",
    底子: "dǐ zi",
    负载: "fù zài",
    干警: "gàn jǐng",
    倒数: "dào shǔ",
    将官: "jiàng guān",
    锄头: "chú tou",
    归降: "guī xiáng",
    疟疾: "nüè ji",
    唠叨: "láo dao",
    限量: "xiàn liàng",
    屏息: "bǐng xī",
    重逢: "chóng féng",
    器乐: "qì yuè",
    氢弹: "qīng dàn",
    脖颈: "bó gěng",
    妃子: "fēi zi",
    处事: "chǔ shì",
    参量: "cān liàng",
    轻率: "qīng shuài",
    缥缈: "piāo miǎo",
    中奖: "zhòng jiǎng",
    才干: "cái gàn",
    施舍: "shī shě",
    卷子: "juàn zi",
    游说: "yóu shuì",
    巷子: "xiàng zi",
    膀胱: "páng guāng",
    切勿: "qiè wù",
    看管: "kān guǎn",
    风头: "fēng tou",
    精干: "jīng gàn",
    高差: "gāo chā",
    恐吓: "kǒng hè",
    扁担: "biǎn dàn",
    给养: "jǐ yǎng",
    格子: "gé zi",
    供需: "gōng xū",
    反差: "fǎn chā",
    飞弹: "fēi dàn",
    微薄: "wēi bó",
    发型: "fà xíng",
    即兴: "jí xìng",
    攒动: "cuán dòng",
    间或: "jiàn huò",
    浅薄: "qiǎn bó",
    乐章: "yuè zhāng",
    顺差: "shùn chā",
    调子: "diào zi",
    相位: "xiàng wèi",
    转子: "zhuàn zǐ",
    劲旅: "jìng lǚ",
    咔嚓: "kā chā",
    了事: "liǎo shì",
    转悠: "zhuàn you",
    当铺: "dàng pù",
    爪子: "zhuǎ zi",
    单子: "dān zi",
    好战: "hào zhàn",
    燕麦: "yàn mài",
    只许: "zhǐ xǔ",
    干练: "gàn liàn",
    女将: "nǚ jiàng",
    酒量: "jiǔ liàng",
    划船: "huá chuán",
    伎俩: "jì liǎng",
    挑拨: "tiǎo bō",
    少校: "shào xiào",
    着落: "zhuó luò",
    憎恶: "zēng wù",
    刻薄: "kè bó",
    要挟: "yāo xié",
    用处: "yòng chu",
    还手: "huán shǒu",
    模具: "mú jù",
    执著: "zhí zhuó",
    喝令: "hè lìng",
    保长: "bǎo zhǎng",
    吸着: "xī zhe",
    症结: "zhēng jié",
    公转: "gōng zhuàn",
    校勘: "jiào kān",
    重提: "chóng tí",
    扫兴: "sǎo xìng",
    铺盖: "pū gài",
    长史: "zhǎng shǐ",
    差价: "chā jià",
    压根: "yà gēn",
    怔住: "zhèng zhù",
    应允: "yīng yǔn",
    切入: "qiē rù",
    战将: "zhàn jiàng",
    年少: "nián shào",
    舍身: "shě shēn",
    执拗: "zhí niù",
    处世: "chǔ shì",
    中风: "zhòng fēng",
    等量: "děng liàng",
    放量: "fàng liàng",
    腔调: "qiāng diào",
    老少: "lǎo shào",
    没入: "mò rù",
    瓜葛: "guā gé",
    将帅: "jiàng shuài",
    车载: "chē zài",
    窝囊: "wō nang",
    长进: "zhǎng jìn",
    可汗: "kè hán",
    并州: "bīng zhōu",
    供销: "gōng xiāo",
    切片: "qiē piàn",
    差事: "chāi shì",
    知会: "zhī hui",
    鹰爪: "yīng zhǎo",
    处女: "chǔ nǚ",
    切磋: "qiē cuō",
    日头: "rì tou",
    押解: "yā jiè",
    滋长: "zī zhǎng",
    道观: "dào guàn",
    脚色: "jué sè",
    当量: "dāng liàng",
    婆家: "pó jia",
    缘分: "yuán fèn",
    空闲: "kòng xián",
    好色: "hào sè",
    怒喝: "nù hè",
    笼统: "lǒng tǒng",
    边塞: "biān sài",
    何曾: "hé céng",
    重合: "chóng hé",
    零散: "líng sǎn",
    轰隆: "hōng lōng",
    化子: "huà zi",
    内蒙: "nèi měng",
    数落: "shǔ luò",
    逆差: "nì chā",
    牟利: "móu lì",
    栅栏: "zhà lan",
    中标: "zhòng biāo",
    调档: "diào dàng",
    佝偻: "gōu lóu",
    场子: "chǎng zi",
    甲壳: "jiǎ qiào",
    重温: "chóng wēn",
    炮制: "páo zhì",
    返还: "fǎn huán",
    自传: "zì zhuàn",
    高调: "gāo diào",
    殷红: "yān hóng",
    固着: "gù zhuó",
    强求: "qiǎng qiú",
    本相: "běn xiàng",
    骄横: "jiāo hèng",
    草率: "cǎo shuài",
    气闷: "qì mèn",
    着色: "zhuó sè",
    宁肯: "nìng kěn",
    兴头: "xìng tou",
    拘泥: "jū nì",
    夹角: "jiā jiǎo",
    发髻: "fà jì",
    猛将: "měng jiàng",
    约摸: "yuē mo",
    拖累: "tuō lěi",
    呢绒: "ní róng",
    钻探: "zuān tàn",
    夹层: "jiā céng",
    落魄: "luò pò",
    巷道: "hàng dào",
    运量: "yùn liàng",
    解闷: "jiě mèn",
    空儿: "kòng er",
    估摸: "gū mo",
    好客: "hào kè",
    钻孔: "zuān kǒng",
    糊弄: "hù nòng",
    荥阳: "xíng yáng",
    烦闷: "fán mèn",
    仓卒: "cāng cù",
    分叉: "fēn chà",
    厂子: "chǎng zi",
    小调: "xiǎo diào",
    少阳: "shào yáng",
    受降: "shòu xiáng",
    染坊: "rǎn fáng",
    胳臂: "gē bei",
    将门: "jiàng mén",
    模板: "mú bǎn",
    配给: "pèi jǐ",
    为伍: "wéi wǔ",
    跟头: "gēn tou",
    划算: "huá suàn",
    累赘: "léi zhui",
    哄笑: "hōng xiào",
    晕眩: "yūn xuàn",
    干掉: "gàn diào",
    缝制: "féng zhì",
    难处: "nán chù",
    着意: "zhuó yì",
    蛮横: "mán hèng",
    奇数: "jī shù",
    短发: "duǎn fà",
    生还: "shēng huán",
    还清: "huán qīng",
    看护: "kān hù",
    直率: "zhí shuài",
    奏乐: "zòu yuè",
    载客: "zài kè",
    专横: "zhuān hèng",
    湮没: "yān mò",
    空格: "kòng gé",
    铺垫: "pū diàn",
    良将: "liáng jiàng",
    哗啦: "huā lā",
    散漫: "sǎn màn",
    脱发: "tuō fà",
    送还: "sòng huán",
    埋没: "mái mò",
    累及: "lěi jí",
    薄雾: "bó wù",
    调离: "diào lí",
    舌苔: "shé tāi",
    机长: "jī zhǎng",
    栓塞: "shuān sè",
    配角: "pèi jué",
    切口: "qiē kǒu",
    创口: "chuāng kǒu",
    哈欠: "hā qian",
    实弹: "shí dàn",
    铺平: "pū píng",
    哈达: "hǎ dá",
    懒散: "lǎn sǎn",
    实干: "shí gàn",
    填空: "tián kòng",
    刁钻: "diāo zuān",
    乐师: "yuè shī",
    量变: "liàng biàn",
    诱降: "yòu xiáng",
    搪塞: "táng sè",
    征调: "zhēng diào",
    夹道: "jiā dào",
    干咳: "gān ké",
    止咳: "zhǐ ké",
    乐工: "yuè gōng",
    划过: "huá guò",
    着火: "zháo huǒ",
    更正: "gēng zhèng",
    给付: "jǐ fù",
    空子: "kòng zi",
    哪吒: "né zhā",
    正着: "zhèng zháo",
    刷子: "shuā zi",
    丧葬: "sāng zàng",
    夹带: "jiā dài",
    安分: "ān fèn",
    中意: "zhòng yì",
    长孙: "zhǎng sūn",
    校订: "jiào dìng",
    卷曲: "juǎn qū",
    载运: "zài yùn",
    投弹: "tóu dàn",
    柞蚕: "zuò cán",
    份量: "fèn liàng",
    调换: "diào huàn",
    了然: "liǎo rán",
    咧嘴: "liě zuǐ",
    典当: "diǎn dàng",
    寒假: "hán jià",
    长兄: "zhǎng xiōng",
    给水: "jǐ shuǐ",
    须发: "xū fà",
    枝干: "zhī gàn",
    属相: "shǔ xiàng",
    哄抢: "hōng qiǎng",
    刻划: "kè huà",
    塞子: "sāi zi",
    单干: "dān gàn",
    还乡: "huán xiāng",
    兆头: "zhào tou",
    寺观: "sì guàn",
    督率: "dū shuài",
    啊哈: "ā ha",
    割舍: "gē shě",
    抹布: "mā bù",
    好恶: "hào wù",
    下处: "xià chǔ",
    消长: "xiāo zhǎng",
    离间: "lí jiàn",
    准头: "zhǔn tou",
    校对: "jiào duì",
    什物: "shí wù",
    番禺: "pān yú",
    佛爷: "fó ye",
    吗啡: "mǎ fēi",
    盐分: "yán fèn",
    虎将: "hǔ jiàng",
    薄荷: "bò he",
    独处: "dú chǔ",
    空位: "kòng wèi",
    铺路: "pū lù",
    乌拉: "wū lā",
    调回: "diào huí",
    来头: "lái tou",
    闲散: "xián sǎn",
    胶卷: "jiāo juǎn",
    冒失: "mào shi",
    干劲: "gàn jìn",
    弦乐: "xián yuè",
    相国: "xiàng guó",
    丹参: "dān shēn",
    助兴: "zhù xìng",
    铺开: "pū kāi",
    次长: "cì zhǎng",
    发卡: "fà qiǎ",
    拮据: "jié jū",
    刹车: "shā chē",
    生发: "shēng fà",
    重播: "chóng bō",
    缝合: "féng hé",
    音量: "yīn liàng",
    少尉: "shào wèi",
    冲压: "chòng yā",
    苍劲: "cāng jìng",
    厚薄: "hòu báo",
    威吓: "wēi hè",
    外相: "wài xiàng",
    呼号: "hū háo",
    着迷: "zháo mí",
    挑担: "tiāo dàn",
    纹路: "wén lù",
    还俗: "huán sú",
    强横: "qiáng hèng",
    着数: "zhāo shù",
    降顺: "xiáng shùn",
    挑明: "tiǎo míng",
    眯缝: "mī feng",
    分内: "fèn nèi",
    更衣: "gēng yī",
    软和: "ruǎn huo",
    尽兴: "jìn xìng",
    号子: "hào zi",
    爪牙: "zhǎo yá",
    败将: "bài jiàng",
    猜中: "cāi zhòng",
    结扎: "jié zā",
    没空: "méi kòng",
    夹缝: "jiā fèng",
    拾掇: "shí duo",
    掺和: "chān huo",
    簸箕: "bò ji",
    电量: "diàn liàng",
    荷载: "hè zǎi",
    调式: "diào shì",
    处身: "chǔ shēn",
    打手: "dǎ shǒu",
    弹弓: "dàn gōng",
    横蛮: "hèng mán",
    能干: "néng gàn",
    校点: "jiào diǎn",
    加载: "jiā zài",
    干校: "gàn xiào",
    哄传: "hōng chuán",
    校注: "jiào zhù",
    淤塞: "yū sè",
    马扎: "mǎ zhá",
    月氏: "yuè zhī",
    高干: "gāo gàn",
    经传: "jīng zhuàn",
    曾孙: "zēng sūn",
    好斗: "hào dòu",
    关卡: "guān qiǎ",
    逃奔: "táo bèn",
    磨蹭: "mó ceng",
    牟取: "móu qǔ",
    颤栗: "zhàn lì",
    蚂蚱: "mà zha",
    撮合: "cuō he",
    趔趄: "liè qie",
    摔打: "shuāi dǎ",
    台子: "tái zi",
    分得: "fēn de",
    粘着: "nián zhuó",
    采邑: "cài yì",
    散装: "sǎn zhuāng",
    婀娜: "ē nuó",
    兴味: "xìng wèi",
    行头: "xíng tou",
    气量: "qì liàng",
    调运: "diào yùn",
    处治: "chǔ zhì",
    乐音: "yuè yīn",
    充塞: "chōng sè",
    恫吓: "dòng hè",
    论调: "lùn diào",
    相中: "xiāng zhòng",
    民乐: "mín yuè",
    炮仗: "pào zhang",
    丧服: "sāng fú",
    骁将: "xiāo jiàng",
    量刑: "liàng xíng",
    缝补: "féng bǔ",
    财会: "cái kuài",
    大干: "dà gàn",
    历数: "lì shǔ",
    校场: "jiào chǎng",
    塞北: "sài běi",
    识相: "shí xiàng",
    辱没: "rǔ mò",
    鲜亮: "xiān liàng",
    语塞: "yǔ sè",
    露脸: "lòu liǎn",
    凉快: "liáng kuai",
    腰杆: "yāo gǎn",
    溜达: "liū da",
    嘎嘎: "gā gā",
    公干: "gōng gàn",
    桔梗: "jié gěng",
    挑逗: "tiǎo dòu",
    看门: "kān mén",
    乐歌: "yuè gē",
    拓片: "tà piàn",
    挑动: "tiǎo dòng",
    准将: "zhǔn jiàng",
    遒劲: "qiú jìng",
    磨坊: "mò fáng",
    逶迤: "wēi yí",
    搅和: "jiǎo huo",
    摩挲: "mó suō",
    作弄: "zuò nòng",
    苗头: "miáo tou",
    打颤: "dǎ zhàn",
    大藏: "dà zàng",
    畜牲: "chù shēng",
    勾搭: "gōu da",
    树荫: "shù yīn",
    树杈: "shù chà",
    铁杆: "tiě gǎn",
    将相: "jiàng xiàng",
    份子: "fèn zi",
    视差: "shì chā",
    绿荫: "lǜ yīn",
    枪杆: "qiāng gǎn",
    缝纫: "féng rèn",
    愁闷: "chóu mèn",
    点将: "diǎn jiàng",
    华佗: "huà tuó",
    劲射: "jìng shè",
    箱笼: "xiāng lǒng",
    终了: "zhōng liǎo",
    鬓发: "bìn fà",
    结巴: "jiē ba",
    苦干: "kǔ gàn",
    看家: "kān jiā",
    正旦: "zhēng dàn",
    中肯: "zhòng kěn",
    厦门: "xià mén",
    东莞: "dōng guǎn",
    食量: "shí liàng",
    宫调: "gōng diào",
    间作: "jiàn zuò",
    弹片: "dàn piàn",
    差池: "chā chí",
    漂白: "piǎo bái",
    杠子: "gàng zi",
    调处: "tiáo chǔ",
    好动: "hào dòng",
    转炉: "zhuàn lú",
    屏气: "bǐng qì",
    夹板: "jiā bǎn",
    哀乐: "āi yuè",
    干道: "gàn dào",
    苦处: "kǔ chù",
    劈柴: "pǐ chái",
    长势: "zhǎng shì",
    天华: "tiān huá",
    共处: "gòng chǔ",
    校验: "jiào yàn",
    出塞: "chū sài",
    磨盘: "mò pán",
    萎靡: "wěi mǐ",
    奔丧: "bēn sāng",
    唱和: "chàng hè",
    大调: "dà diào",
    非分: "fēi fèn",
    钻营: "zuān yíng",
    夹子: "jiā zi",
    超载: "chāo zài",
    更始: "gēng shǐ",
    铃铛: "líng dang",
    披散: "pī sàn",
    发还: "fā huán",
    转轮: "zhuàn lún",
    横财: "hèng cái",
    泡桐: "pāo tóng",
    抛撒: "pāo sǎ",
    天呀: "tiān yā",
    糊糊: "hū hu",
    躯壳: "qū qiào",
    通量: "tōng liàng",
    奉还: "fèng huán",
    午觉: "wǔ jiào",
    闷棍: "mèn gùn",
    浪头: "làng tou",
    砚台: "yàn tái",
    油坊: "yóu fáng",
    学长: "xué zhǎng",
    过载: "guò zài",
    笔调: "bǐ diào",
    衣被: "yī bèi",
    畜产: "xù chǎn",
    调阅: "diào yuè",
    蛮干: "mán gàn",
    曾祖: "zēng zǔ",
    提干: "tí gàn",
    变调: "biàn diào",
    覆没: "fù mò",
    模子: "mú zi",
    乐律: "yuè lǜ",
    称心: "chèn xīn",
    木杆: "mù gān",
    重印: "chóng yìn",
    自省: "zì xǐng",
    提调: "tí diào",
    看相: "kàn xiàng",
    芋头: "yù tou",
    下切: "xià qiē",
    塞上: "sài shàng",
    铺张: "pū zhāng",
    藤蔓: "téng wàn",
    薄幸: "bó xìng",
    解数: "xiè shù",
    褪去: "tuì qù",
    霰弹: "xiàn dàn",
    柚木: "yóu mù",
    痕量: "hén liàng",
    雅乐: "yǎ yuè",
    号哭: "háo kū",
    诈降: "zhà xiáng",
    猪圈: "zhū juàn",
    咋舌: "zé shé",
    铣床: "xǐ chuáng",
    防弹: "fáng dàn",
    健将: "jiàn jiàng",
    丽水: "lí shuǐ",
    削发: "xuē fà",
    空当: "kòng dāng",
    多相: "duō xiàng",
    鲜见: "xiǎn jiàn",
    划桨: "huá jiǎng",
    载波: "zài bō",
    跳蚤: "tiào zao",
    俏皮: "qiào pí",
    吧嗒: "bā dā",
    结发: "jié fà",
    了断: "liǎo duàn",
    同调: "tóng diào",
    石磨: "shí mò",
    时差: "shí chā",
    鼻塞: "bí sè",
    挑子: "tiāo zi",
    推磨: "tuī mò",
    武侯: "wǔ hóu",
    抹煞: "mǒ shā",
    调转: "diào zhuǎn",
    籍没: "jí mò",
    还债: "huán zhài",
    调演: "diào yǎn",
    分划: "fēn huá",
    奇偶: "jī ǒu",
    断喝: "duàn hè",
    闷雷: "mèn léi",
    狼藉: "láng jí",
    饭量: "fàn liàng",
    还礼: "huán lǐ",
    转调: "zhuǎn diào",
    星相: "xīng xiàng",
    手相: "shǒu xiàng",
    配乐: "pèi yuè",
    盖头: "gài tou",
    连杆: "lián gǎn",
    簿记: "bù jì",
    刀把: "dāo bà",
    量词: "liàng cí",
    名角: "míng jué",
    步调: "bù diào",
    校本: "jiào běn",
    账簿: "zhàng bù",
    隽永: "juàn yǒng",
    稍为: "shāo wéi",
    易传: "yì zhuàn",
    乐谱: "yuè pǔ",
    牵累: "qiān lěi",
    答理: "dā li",
    喝斥: "hè chì",
    吟哦: "yín é",
    干渠: "gàn qú",
    海量: "hǎi liàng",
    精当: "jīng dàng",
    着床: "zhuó chuáng",
    月相: "yuè xiàng",
    庶几: "shù jī",
    宫观: "gōng guàn",
    论处: "lùn chǔ",
    征辟: "zhēng bì",
    厚朴: "hòu pò",
    介壳: "jiè qiào",
    吭哧: "kēng chī",
    咯血: "kǎ xiě",
    铺陈: "pū chén",
    重生: "chóng shēng",
    乐理: "yuè lǐ",
    哀号: "āi háo",
    藏历: "zàng lì",
    刚劲: "gāng jìng",
    削平: "xuē píng",
    浓荫: "nóng yīn",
    城垛: "chéng duǒ",
    当差: "dāng chāi",
    正传: "zhèng zhuàn",
    并处: "bìng chǔ",
    创面: "chuāng miàn",
    旦角: "dàn jué",
    薄礼: "bó lǐ",
    晃荡: "huàng dang",
    臊子: "sào zi",
    家什: "jiā shí",
    闷头: "mēn tóu",
    美发: "měi fà",
    度数: "dù shu",
    着凉: "zháo liáng",
    闯将: "chuǎng jiàng",
    几案: "jī àn",
    姘头: "pīn tou",
    差数: "chā shù",
    散碎: "sǎn suì",
    壅塞: "yōng sè",
    寒颤: "hán zhàn",
    牵强: "qiān qiǎng",
    无间: "wú jiàn",
    轮转: "lún zhuàn",
    号叫: "háo jiào",
    铺排: "pū pái",
    降伏: "xiáng fú",
    轧钢: "zhá gāng",
    东阿: "dōng ē",
    病假: "bìng jià",
    累加: "lěi jiā",
    梗塞: "gěng sè",
    弹夹: "dàn jiā",
    钻心: "zuān xīn",
    晃眼: "huǎng yǎn",
    魔爪: "mó zhǎo",
    标量: "biāo liàng",
    憋闷: "biē mèn",
    猜度: "cāi duó",
    处士: "chǔ shì",
    官差: "guān chāi",
    讨还: "tǎo huán",
    长门: "cháng mén",
    馏分: "liú fēn",
    里弄: "lǐ lòng",
    色相: "sè xiàng",
    雅兴: "yǎ xìng",
    角力: "jué lì",
    弹坑: "dàn kēng",
    枝杈: "zhī chà",
    夹具: "jiā jù",
    处刑: "chǔ xíng",
    悍将: "hàn jiàng",
    好学: "hào xué",
    好好: "hǎo hǎo",
    银发: "yín fà",
    扫把: "sào bǎ",
    法相: "fǎ xiàng",
    贵干: "guì gàn",
    供气: "gōng qì",
    空余: "kòng yú",
    捆扎: "kǔn zā",
    瘠薄: "jí bó",
    浆糊: "jiàng hu",
    嘎吱: "gā zhī",
    调令: "diào lìng",
    法帖: "fǎ tiè",
    淋病: "lìn bìng",
    调派: "diào pài",
    转盘: "zhuàn pán",
    供稿: "gōng gǎo",
    差官: "chāi guān",
    忧闷: "yōu mèn",
    教长: "jiào zhǎng",
    重唱: "chóng chàng",
    酒兴: "jiǔ xìng",
    乐坛: "yuè tán",
    花呢: "huā ní",
    叱喝: "chì hè",
    膀臂: "bǎng bì",
    得空: "dé kòng",
    转圈: "zhuàn quān",
    横暴: "hèng bào",
    哄抬: "hōng tái",
    引吭: "yǐn háng",
    载货: "zài huò",
    中计: "zhòng jì",
    官长: "guān zhǎng",
    相面: "xiàng miàn",
    看头: "kàn tou",
    盼头: "pàn tou",
    意兴: "yì xìng",
    军乐: "jūn yuè",
    累次: "lěi cì",
    骨嘟: "gǔ dū",
    燕赵: "yān zhào",
    报丧: "bào sāng",
    弥撒: "mí sa",
    挨斗: "ái dòu",
    扁舟: "piān zhōu",
    丑角: "chǒu jué",
    吊丧: "diào sāng",
    强将: "qiáng jiàng",
    重奏: "chóng zòu",
    发辫: "fà biàn",
    着魔: "zháo mó",
    着法: "zhāo fǎ",
    盛放: "shèng fàng",
    填塞: "tián sè",
    凶横: "xiōng hèng",
    稽首: "qǐ shǒu",
    碑帖: "bēi tiè",
    冲量: "chōng liàng",
    发菜: "fà cài",
    假发: "jiǎ fà",
    翻卷: "fān juǎn",
    小量: "xiǎo liàng",
    胶着: "jiāo zhuó",
    里子: "lǐ zi",
    调调: "diào diao",
    散兵: "sǎn bīng",
    高挑: "gāo tiǎo",
    播撒: "bō sǎ",
    夹心: "jiā xīn",
    扇动: "shān dòng",
    叨扰: "tāo rǎo",
    霓裳: "ní cháng",
    捻子: "niǎn zi",
    弥缝: "mí féng",
    撒布: "sǎ bù",
    场院: "cháng yuàn",
    省亲: "xǐng qīn",
    提拉: "tí lā",
    惯量: "guàn liàng",
    强逼: "qiáng bī",
    强征: "qiáng zhēng",
    晕车: "yùn chē",
    数道: "shù dào",
    带累: "dài lèi",
    拓本: "tà běn",
    嫌恶: "xián wù",
    宿将: "sù jiàng",
    龟裂: "jūn liè",
    缠夹: "chán jiā",
    发式: "fà shì",
    隔扇: "gé shàn",
    天分: "tiān fèn",
    癖好: "pǐ hào",
    四通: "sì tōng",
    白术: "bái zhú",
    划伤: "huá shāng",
    角斗: "jué dòu",
    听差: "tīng chāi",
    岁差: "suì chā",
    丧礼: "sāng lǐ",
    脉脉: "mò mò",
    削瘦: "xuē shòu",
    撒播: "sǎ bō",
    莎草: "suō cǎo",
    犍为: "qián wéi",
    调头: "diào tóu",
    龙卷: "lóng juǎn",
    外调: "wài diào",
    字帖: "zì tiè",
    卷发: "juǎn fà",
    揣度: "chuǎi duó",
    洋相: "yáng xiàng",
    散光: "sǎn guāng",
    骨碌: "gū lu",
    薄命: "bó mìng",
    笼头: "lóng tóu",
    咽炎: "yān yán",
    碌碡: "liù zhou",
    片儿: "piàn er",
    纤手: "qiàn shǒu",
    散体: "sǎn tǐ",
    内省: "nèi xǐng",
    强留: "qiáng liú",
    解送: "jiè sòng",
    反间: "fǎn jiàn",
    少壮: "shào zhuàng",
    留空: "liú kōng",
    告假: "gào jià",
    咳血: "ké xuè",
    薄暮: "bó mù",
    铺轨: "pū guǐ",
    磨削: "mó xuē",
    治丧: "zhì sāng",
    叉子: "chā zi",
    哄动: "hōng dòng",
    蛾子: "é zi",
    出落: "chū luò",
    股长: "gǔ zhǎng",
    贵处: "guì chù",
    还魂: "huán hún",
    例假: "lì jià",
    刹住: "shā zhù",
    身量: "shēn liàng",
    同好: "tóng hào",
    模量: "mó liàng",
    更生: "gēng shēng",
    服丧: "fú sāng",
    率直: "shuài zhí",
    字模: "zì mú",
    散架: "sǎn jià",
    答腔: "dā qiāng",
    交恶: "jiāo wù",
    薄情: "bó qíng",
    眼泡: "yǎn pāo",
    袅娜: "niǎo nuó",
    草垛: "cǎo duò",
    冲劲: "chòng jìn",
    呢喃: "ní nán",
    切中: "qiè zhòng",
    挑灯: "tiǎo dēng",
    还愿: "huán yuàn",
    激将: "jī jiàng",
    更鼓: "gēng gǔ",
    没药: "mò yào",
    败兴: "bài xìng",
    切面: "qiē miàn",
    散户: "sǎn hù",
    累进: "lěi jìn",
    背带: "bēi dài",
    秤杆: "chèng gǎn",
    碾坊: "niǎn fáng",
    簿子: "bù zi",
    扳手: "bān shǒu",
    铅山: "yán shān",
    儒将: "rú jiàng",
    重光: "chóng guāng",
    剪发: "jiǎn fà",
    长上: "zhǎng shàng",
    小传: "xiǎo zhuàn",
    压轴: "yā zhòu",
    弱冠: "ruò guàn",
    花卷: "huā juǎn",
    横祸: "hèng huò",
    夹克: "jiā kè",
    光晕: "guāng yùn",
    披靡: "pī mǐ",
    对调: "duì diào",
    夹持: "jiā chí",
    空额: "kòng é",
    平调: "píng diào",
    铺床: "pū chuáng",
    丧钟: "sāng zhōng",
    作乐: "zuò lè",
    少府: "shào fǔ",
    数数: "shuò shuò",
    奔头: "bèn tou",
    进给: "jìn jǐ",
    率性: "shuài xìng",
    乐子: "lè zi",
    绑扎: "bǎng zā",
    挑唆: "tiǎo suō",
    漂洗: "piǎo xǐ",
    夹墙: "jiā qiáng",
    咳喘: "ké chuǎn",
    乜斜: "miē xie",
    错处: "cuò chù",
    闷酒: "mèn jiǔ",
    时调: "shí diào",
    重孙: "chóng sūn",
    经幢: "jīng chuáng",
    圩场: "xū chǎng",
    调门: "diào mén",
    花头: "huā tóu",
    划拉: "huá la",
    套色: "tào shǎi",
    粗率: "cū shuài",
    相率: "xiāng shuài",
    款识: "kuǎn zhì",
    吁请: "yù qǐng",
    荫蔽: "yīn bì",
    文蛤: "wén gé",
    嘀嗒: "dī dā",
    调取: "diào qǔ",
    交差: "jiāo chāi",
    落子: "luò zǐ",
    相册: "xiàng cè",
    絮叨: "xù dao",
    落发: "luò fà",
    异相: "yì xiàng",
    浸没: "jìn mò",
    角抵: "jué dǐ",
    卸载: "xiè zài",
    春卷: "chūn juǎn",
    扎挣: "zhá zheng",
    畜养: "xù yǎng",
    吡咯: "bǐ luò",
    垛子: "duò zi",
    恶少: "è shào",
    发际: "fà jì",
    红苕: "hóng sháo",
    糨糊: "jiàng hu",
    哭丧: "kū sāng",
    稍息: "shào xī",
    晕船: "yùn chuán",
    校样: "jiào yàng",
    外差: "wài chā",
    脚爪: "jiǎo zhǎo",
    铺展: "pū zhǎn",
    芫荽: "yán sui",
    夹紧: "jiā jǐn",
    尿泡: "suī pào",
    丧乱: "sāng luàn",
    凶相: "xiōng xiàng",
    华发: "huá fà",
    打场: "dǎ cháng",
    云量: "yún liàng",
    正切: "zhèng qiē",
    划拳: "huá quán",
    划艇: "huá tǐng",
    评传: "píng zhuàn",
    拉纤: "lā qiàn",
    句读: "jù dòu",
    散剂: "sǎn jì",
    骨殖: "gǔ shi",
    塞音: "sè yīn",
    铺叙: "pū xù",
    阏氏: "yān zhī",
    冷颤: "lěng zhàn",
    煞住: "shā zhù",
    少男: "shào nán",
    管乐: "guǎn yuè",
    号啕: "háo táo",
    纳降: "nà xiáng",
    拥塞: "yōng sè",
    万乘: "wàn shèng",
    杆儿: "gǎn ér",
    葛藤: "gé téng",
    簿籍: "bù jí",
    皮夹: "pí jiā",
    校准: "jiào zhǔn",
    允当: "yǔn dàng",
    器量: "qì liàng",
    选调: "xuǎn diào",
    扮相: "bàn xiàng",
    干才: "gàn cái",
    基干: "jī gàn",
    割切: "gē qiē",
    国乐: "guó yuè",
    卡壳: "qiǎ ké",
    辟谷: "bì gǔ",
    磨房: "mò fáng",
    咿呀: "yī yā",
    芥末: "jiè mo",
    薄技: "bó jì",
    产假: "chǎn jià",
    诗兴: "shī xìng",
    重出: "chóng chū",
    转椅: "zhuàn yǐ",
    酌量: "zhuó liang",
    簿册: "bù cè",
    藏青: "zàng qīng",
    的士: "dī shì",
    调人: "diào rén",
    解元: "jiè yuán",
    茎干: "jīng gàn",
    巨量: "jù liàng",
    榔头: "láng tou",
    率真: "shuài zhēn",
    喷香: "pèn xiāng",
    锁钥: "suǒ yuè",
    虾蟆: "há má",
    相图: "xiàng tú",
    兴会: "xìng huì",
    灶头: "zào tóu",
    重婚: "chóng hūn",
    钻洞: "zuān dòng",
    忖度: "cǔn duó",
    党参: "dǎng shēn",
    调温: "diào wēn",
    杆塔: "gān tǎ",
    葛布: "gé bù",
    拱券: "gǒng xuàn",
    夹生: "jiā shēng",
    露馅: "lòu xiàn",
    恰切: "qià qiè",
    散见: "sǎn jiàn",
    哨卡: "shào qiǎ",
    烫发: "tàng fà",
    体量: "tǐ liàng",
    挺括: "tǐng kuò",
    系带: "jì dài",
    相士: "xiàng shì",
    羊圈: "yáng juàn",
    转矩: "zhuàn jǔ",
    吧台: "bā tái",
    苍术: "cāng zhú",
    菲薄: "fěi bó",
    蛤蚧: "gé jiè",
    蛤蜊: "gé lí",
    瓜蔓: "guā wàn",
    怪相: "guài xiàng",
    临帖: "lín tiè",
    女红: "nǚ gōng",
    刨床: "bào chuáng",
    翘楚: "qiáo chǔ",
    数九: "shǔ jiǔ",
    谈兴: "tán xìng",
    雄劲: "xióng jìng",
    扎染: "zā rǎn",
    遮荫: "zhē yīn",
    周正: "zhōu zhèng",
    赚头: "zhuàn tou",
    扒手: "pá shǒu",
    搀和: "chān huo",
    诚朴: "chéng pǔ",
    肚量: "dù liàng",
    干结: "gān jié",
    工尺: "gōng chě",
    家累: "jiā lěi",
    曲水: "qū shuǐ",
    沙参: "shā shēn",
    挑花: "tiǎo huā",
    阿门: "ā mén",
    背篓: "bēi lǒu",
    瘪三: "biē sān",
    裁处: "cái chǔ",
    创痛: "chuāng tòng",
    福相: "fú xiàng",
    更动: "gēng dòng",
    豪兴: "háo xìng",
    还阳: "huán yáng",
    还嘴: "huán zuǐ",
    借调: "jiè diào",
    卷云: "juǎn yún",
    流弹: "liú dàn",
    想头: "xiǎng tou",
    削价: "xuē jià",
    校阅: "jiào yuè",
    雅量: "yǎ liàng",
    别传: "bié zhuàn",
    薄酒: "bó jiǔ",
    春假: "chūn jià",
    发妻: "fà qī",
    哗哗: "huā huā",
    宽绰: "kuān chuo",
    了悟: "liǎo wù",
    切花: "qiē huā",
    审度: "shěn duó",
    应许: "yīng xǔ",
    转台: "zhuàn tái",
    仔猪: "zǐ zhū",
    裁量: "cái liáng",
    藏戏: "zàng xì",
    乘兴: "chéng xìng",
    绸缪: "chóu móu",
    摧折: "cuī zhé",
    调经: "tiáo jīng",
    调职: "diào zhí",
    缝缀: "féng zhuì",
    骨朵: "gū duǒ",
    核儿: "hú er",
    恒量: "héng liàng",
    还价: "huán jià",
    浑朴: "hún pǔ",
    苦差: "kǔ chāi",
    面糊: "miàn hù",
    煞车: "shā chē",
    省视: "xǐng shì",
    什锦: "shí jǐn",
    信差: "xìn chāi",
    余切: "yú qiē",
    攒眉: "cuán méi",
    炸糕: "zhá gāo",
    钻杆: "zuàn gǎn",
    扒灰: "pá huī",
    拌和: "bàn huò",
    长调: "cháng diào",
    大溜: "dà liù",
    抖搂: "dǒu lōu",
    飞转: "fēi zhuàn",
    干仗: "gàn zhàng",
    好胜: "hào shèng",
    画片: "huà piàn",
    搅混: "jiǎo hún",
    螺杆: "luó gǎn",
    木模: "mù mú",
    怒号: "nù háo",
    频数: "pín shù",
    无宁: "wú níng",
    遗少: "yí shào",
    邮差: "yóu chāi",
    占卦: "zhān guà",
    占星: "zhān xīng",
    重审: "chóng shěn",
    自量: "zì liàng",
    调防: "diào fáng",
    发廊: "fà láng",
    反调: "fǎn diào",
    缝子: "fèng zi",
    更夫: "gēng fū",
    骨子: "gǔ zi",
    光杆: "guāng gǎn",
    夹棍: "jiā gùn",
    居丧: "jū sāng",
    巨贾: "jù gǔ",
    看押: "kān yā",
    空转: "kōng zhuàn",
    量力: "liàng lì",
    炮烙: "páo luò",
    赔还: "péi huán",
    扑扇: "pū shān",
    散记: "sǎn jì",
    散件: "sǎn jiàn",
    删削: "shān xuē",
    射干: "shè gàn",
    条几: "tiáo jī",
    偷空: "tōu kòng",
    削壁: "xuē bì",
    校核: "jiào hé",
    阴干: "yīn gān",
    择菜: "zhái cài",
    重九: "chóng jiǔ",
    主调: "zhǔ diào",
    自禁: "zì jīn",
    吧唧: "bā jī",
    便溺: "biàn niào",
    词调: "cí diào",
    叨咕: "dáo gu",
    落枕: "lào zhěn",
    铺砌: "pū qì",
    刷白: "shuà bái",
    委靡: "wěi mǐ",
    系泊: "xì bó",
    相马: "xiàng mǎ",
    熨帖: "yù tiē",
    转筋: "zhuàn jīn",
    棒喝: "bàng hè",
    傧相: "bīn xiàng",
    镐头: "gǎo tóu",
    间苗: "jiàn miáo",
    乐池: "yuè chí",
    卖相: "mài xiàng",
    屏弃: "bǐng qì",
    铅弹: "qiān dàn",
    切变: "qiē biàn",
    请调: "qǐng diào",
    群氓: "qún méng",
    散板: "sǎn bǎn",
    省察: "xǐng chá",
    事假: "shì jià",
    纤绳: "qiàn shéng",
    重影: "chóng yǐng",
    耕种: "gēng zhòng",
    种地: "zhòng dì",
    种菜: "zhòng cài",
    栽种: "zāi zhòng",
    接种: "jiē zhòng",
    垦种: "kěn zhòng",
    种殖: "zhòng zhí",
    种瓜: "zhòng guā",
    种豆: "zhòng dòu",
    种树: "zhòng shù",
    睡着: "shuì zháo",
    笼子: "lóng zi",
    重启: "chóng qǐ",
    重整: "chóng zhěng",
    重弹: "chóng tán",
    重足: "chóng zú",
    重山: "chóng shān",
    重游: "chóng yóu",
    重峦: "chóng luán",
    爷爷: "yé ye",
    奶奶: "nǎi nai",
    姥爷: "lǎo ye",
    爸爸: "bà ba",
    妈妈: "mā ma",
    婶婶: "shěn shen",
    舅舅: "jiù jiu",
    姑姑: "gū gu",
    叔叔: "shū shu",
    姨夫: "yí fu",
    舅母: "jiù mu",
    姑父: "gū fu",
    姐夫: "jiě fu",
    婆婆: "pó po",
    公公: "gōng gong",
    舅子: "jiù zi",
    姐姐: "jiě jie",
    哥哥: "gē ge",
    妹妹: "mèi mei",
    妹夫: "mèi fu",
    姨子: "yí zi",
    宝宝: "bǎo bao",
    娃娃: "wá wa",
    孩子: "hái zi",
    日子: "rì zi",
    样子: "yàng zi",
    狮子: "shī zi",
    身子: "shēn zi",
    架子: "jià zi",
    嫂子: "sǎo zi",
    鼻子: "bí zi",
    亭子: "tíng zi",
    折子: "zhé zi",
    面子: "miàn zi",
    脖子: "bó zi",
    辈子: "bèi zi",
    帽子: "mào zi",
    拍子: "pāi zi",
    柱子: "zhù zi",
    辫子: "biàn zi",
    鸽子: "gē zi",
    房子: "fáng zi",
    丸子: "wán zi",
    摊子: "tān zi",
    牌子: "pái zi",
    胡子: "hú zi",
    鬼子: "guǐ zi",
    矮子: "ǎi zi",
    鸭子: "yā zi",
    小子: "xiǎo zi",
    影子: "yǐng zi",
    屋子: "wū zi",
    对子: "duì zi",
    点子: "diǎn zi",
    本子: "běn zi",
    种子: "zhǒng zi",
    儿子: "ér zi",
    兔子: "tù zi",
    骗子: "piàn zi",
    院子: "yuàn zi",
    猴子: "hóu zi",
    嗓子: "sǎng zi",
    侄子: "zhí zi",
    柿子: "shì zi",
    钳子: "qián zi",
    虱子: "shī zi",
    瓶子: "píng zi",
    豹子: "bào zi",
    筷子: "kuài zi",
    篮子: "lán zi",
    绳子: "shéng zi",
    嘴巴: "zuǐ ba",
    耳朵: "ěr duo",
    茄子: "qié zi",
    蚌埠: "bèng bù",
    崆峒: "kōng tóng",
    琵琶: "pí pa",
    蘑菇: "mó gu",
    葫芦: "hú lu",
    狐狸: "hú li",
    桔子: "jú zi",
    盒子: "hé zi",
    桌子: "zhuō zi",
    竹子: "zhú zi",
    师傅: "shī fu",
    衣服: "yī fu",
    袜子: "wà zi",
    杯子: "bēi zi",
    刺猬: "cì wei",
    麦子: "mài zi",
    队伍: "duì wu",
    知了: "zhī liǎo",
    鱼儿: "yú er",
    馄饨: "hún tun",
    灯笼: "dēng long",
    庄稼: "zhuāng jia",
    聪明: "cōng ming",
    镜子: "jìng zi",
    银子: "yín zi",
    盘子: "pán zi",
    了却: "liǎo què",
    力气: "lì qi",
    席子: "xí zi",
    林子: "lín zi",
    朝霞: "zhāo xiá",
    朝夕: "zhāo xī",
    朝气: "zhāo qì",
    翅膀: "chì bǎng",
    省长: "shěng zhǎng",
    臧否: "zāng pǐ",
    否泰: "pǐ tài",
    变得: "biàn de",
    丈夫: "zhàng fu",
    豆腐: "dòu fu",
    笔杆: "bǐ gǎn",
    枞阳: "zōng yáng",
    行人: "xíng rén",
    打着: "dǎ zhe",
    // 一字不变调的词语（需要增补更多）
    // 有歧义的词：一楼、一栋、一层、一排、一连
    // “一楼”这个词，上下文语意是“一整栋楼”时，需要变调成四声；我住一楼时，则是一声
    第一: "dì yī",
    万一: "wàn yī",
    之一: "zhī yī",
    得之: "dé zhī",
    统一: "tǒng yī",
    唯一: "wéi yī",
    专一: "zhuān yī",
    单一: "dān yī",
    如一: "rú yī",
    其一: "qí yī",
    合一: "hé yī",
    逐一: "zhú yī",
    周一: "zhōu yī",
    初一: "chū yī",
    研一: "yán yī",
    归一: "guī yī",
    假一: "jiǎ yī",
    闻一: "wén yī",
    了了: "liǎo liǎo",
    公了: "gōng liǎo",
    私了: "sī liǎo",
    // 一 发音
    一月: "yī yuè",
    一号: "yī hào",
    一级: "yī jí",
    一等: "yī děng",
    一哥: "yī gē",
    月一: "yuè yī",
    一一: "yī yī",
    二一: "èr yī",
    三一: "sān yī",
    四一: "sì yī",
    五一: "wǔ yī",
    六一: "liù yī",
    七一: "qī yī",
    八一: "bā yī",
    九一: "jiǔ yī",
    "一〇": "yī líng",
    一零: "yī líng",
    一二: "yī èr",
    一三: "yī sān",
    一四: "yī sì",
    一五: "yī wǔ",
    一六: "yī liù",
    一七: "yī qī",
    一八: "yī bā",
    一九: "yī jiǔ",
    一又: "yī yòu",
    一饼: "yī bǐng",
    一楼: "yī lóu",
    为例: "wéi lì",
    为准: "wéi zhǔn",
    沧海: "cāng hǎi",
    难为: "nán wéi",
    责难: "zé nàn",
    患难: "huàn nàn",
    磨难: "mó nàn",
    大难: "dà nàn",
    刁难: "diāo nàn",
    殉难: "xùn nàn",
    落难: "luò nàn",
    罹难: "lí nàn",
    灾难: "zāi nàn",
    难民: "nàn mín",
    苦难: "kǔ nàn",
    危难: "wēi nàn",
    发难: "fā nàn",
    逃难: "táo nàn",
    避难: "bì nàn",
    遇难: "yù nàn",
    阻难: "zǔ nàn",
    厄难: "è nàn",
    徇难: "xùn nàn",
    空难: "kōng nàn",
    喜欢: "xǐ huan",
    朝朝: "zhāo zhāo",
    不行: "bù xíng",
    轧轧: "yà yà",
    弯曲: "wān qū",
    扭曲: "niǔ qū",
    曲直: "qū zhí",
    委曲: "wěi qū",
    酒曲: "jiǔ qū",
    曲径: "qū jìng",
    曲解: "qū jiě",
    歪曲: "wāi qū",
    曲线: "qū xiàn",
    曲阜: "qū fù",
    九曲: "jiǔ qū",
    曲折: "qū zhé",
    曲肱: "qū gōng",
    曲意: "qū yì",
    仡佬: "gē lǎo"
  };
  const Pattern2 = Object.keys(DICT2).map((key) => ({
    zh: key,
    pinyin: DICT2[key],
    probability: 2e-8,
    length: 2,
    priority: Priority.Normal,
    dict: Symbol("dict2")
  }));
  const DICT3 = {
    为什么: "wèi shén me",
    实际上: "shí jì shang",
    检察长: "jiǎn chá zhǎng",
    干什么: "gàn shén me",
    这会儿: "zhè huì er",
    尽可能: "jǐn kě néng",
    董事长: "dǒng shì zhǎng",
    了不起: "liǎo bù qǐ",
    参谋长: "cān móu zhǎng",
    朝鲜族: "cháo xiǎn zú",
    海内外: "hǎi nèi wài",
    禁不住: "jīn bú zhù",
    柏拉图: "bó lā tú",
    不在乎: "bú zài hu",
    洛杉矶: "luò shān jī",
    有点儿: "yǒu diǎn er",
    迫击炮: "pǎi jī pào",
    不得了: "bù dé liǎo",
    马尾松: "mǎ wěi sōng",
    运输量: "yùn shū liàng",
    发脾气: "fā pí qi",
    士大夫: "shì dà fū",
    鸭绿江: "yā lù jiāng",
    压根儿: "yà gēn er",
    对得起: "duì de qǐ",
    那会儿: "nà huì er",
    自个儿: "zì gě er",
    物理量: "wù lǐ liàng",
    怎么着: "zěn me zhāo",
    明晃晃: "míng huǎng huǎng",
    节假日: "jié jià rì",
    心里话: "xīn lǐ huà",
    发行量: "fā xíng liàng",
    兴冲冲: "xìng chōng chōng",
    分子量: "fēn zǐ liàng",
    国子监: "guó zǐ jiàn",
    老大难: "lǎo dà nán",
    党内外: "dǎng nèi wài",
    这么着: "zhè me zhāo",
    少奶奶: "shào nǎi nai",
    暗地里: "àn dì lǐ",
    更年期: "gēng nián qī",
    工作量: "gōng zuò liàng",
    背地里: "bèi dì lǐ",
    山里红: "shān li hóng",
    好好儿: "hǎo hāo er",
    交响乐: "jiāo xiǎng yuè",
    好意思: "hǎo yì si",
    吐谷浑: "tǔ yù hún",
    没意思: "méi yì si",
    理发师: "lǐ fà shī",
    塔什干: "tǎ shí gān",
    充其量: "chōng qí liàng",
    靠得住: "kào de zhù",
    车行道: "chē xíng dào",
    人行道: "rén xíng dào",
    中郎将: "zhōng láng jiàng",
    照明弹: "zhào míng dàn",
    烟幕弹: "yān mù dàn",
    没奈何: "mò nài hé",
    乱哄哄: "luàn hōng hōng",
    惠更斯: "huì gēng sī",
    载重量: "zài zhòng liàng",
    瞧得起: "qiáo de qǐ",
    纪传体: "jì zhuàn tǐ",
    阿房宫: "ē páng gōng",
    卷心菜: "juǎn xīn cài",
    戏班子: "xì bān zi",
    过得去: "guò de qù",
    花岗石: "huā gāng shí",
    外甥女: "wài sheng nǚ",
    团团转: "tuán tuán zhuàn",
    大堡礁: "dà bǎo jiāo",
    燃烧弹: "rán shāo dàn",
    劳什子: "láo shí zi",
    摇滚乐: "yáo gǔn yuè",
    夹竹桃: "jiā zhú táo",
    闹哄哄: "nào hōng hōng",
    三连冠: "sān lián guàn",
    重头戏: "zhòng tóu xì",
    二人转: "èr rén zhuàn",
    节骨眼: "jiē gǔ yǎn",
    知识面: "zhī shi miàn",
    护士长: "hù shi zhǎng",
    信号弹: "xìn hào dàn",
    干电池: "gān diàn chí",
    枪杆子: "qiāng gǎn zi",
    哭丧棒: "kū sāng bàng",
    鼻咽癌: "bí yān ái",
    瓦岗军: "wǎ gāng jūn",
    买得起: "mǎi de qǐ",
    癞蛤蟆: "lài há ma",
    脊梁骨: "jǐ liang gǔ",
    子母弹: "zǐ mǔ dàn",
    开小差: "kāi xiǎo chāi",
    女强人: "nǚ qiáng rén",
    英雄传: "yīng xióng zhuàn",
    爵士乐: "jué shì yuè",
    说笑话: "shuō xiào hua",
    碰头会: "pèng tóu huì",
    玻璃钢: "bō li gāng",
    曳光弹: "yè guāng dàn",
    少林拳: "shào lín quán",
    咏叹调: "yǒng tàn diào",
    少先队: "shào xiān duì",
    灵长目: "líng zhǎng mù",
    对着干: "duì zhe gàn",
    蒙蒙亮: "méng méng liàng",
    软骨头: "ruǎn gǔ tou",
    铺盖卷: "pū gài juǎn",
    和稀泥: "huò xī ní",
    背黑锅: "bēi hēi guō",
    红彤彤: "hóng tōng tōng",
    武侯祠: "wǔ hóu cí",
    打哆嗦: "dǎ duō suo",
    户口簿: "hù kǒu bù",
    马尾藻: "mǎ wěi zǎo",
    夜猫子: "yè māo zi",
    打手势: "dǎ shǒu shì",
    龙王爷: "lóng wáng yé",
    气头上: "qì tóu shang",
    糊涂虫: "hú tu chóng",
    笔杆子: "bǐ gǎn zi",
    占便宜: "zhàn pián yi",
    打主意: "dǎ zhǔ yì",
    多弹头: "duō dàn tóu",
    露一手: "lòu yì shǒu",
    堰塞湖: "yàn sè hú",
    保得住: "bǎo de zhù",
    趵突泉: "bào tū quán",
    奥得河: "ào de hé",
    司务长: "sī wù zhǎng",
    禁不起: "jīn bù qǐ",
    什刹海: "shí chà hǎi",
    莲花落: "lián huā lào",
    见世面: "jiàn shì miàn",
    豁出去: "huō chū qù",
    电位差: "diàn wèi chā",
    挨个儿: "āi gè er",
    那阵儿: "nà zhèn er",
    肺活量: "fèi huó liàng",
    大师傅: "dà shī fu",
    掷弹筒: "zhì dàn tǒng",
    打呼噜: "dǎ hū lu",
    广渠门: "ān qú mén",
    未见得: "wèi jiàn dé",
    大婶儿: "dà shěn er",
    谈得来: "tán de lái",
    脚丫子: "jiǎo yā zi",
    空包弹: "kōng bāo dàn",
    窝里斗: "wō li dòu",
    弹着点: "dàn zhuó diǎn",
    个头儿: "gè tóu er",
    看得起: "kàn de qǐ",
    糊涂账: "hú tu zhàng",
    大猩猩: "dà xīng xing",
    禁得起: "jīn de qǐ",
    法相宗: "fǎ xiàng zōng",
    可怜相: "kě lián xiàng",
    吃得下: "chī de xià",
    汉堡包: "hàn bǎo bāo",
    闹嚷嚷: "nào rāng rāng",
    数来宝: "shǔ lái bǎo",
    合得来: "hé de lái",
    干性油: "gān xìng yóu",
    闷葫芦: "mèn hú lu",
    呱呱叫: "guā guā jiào",
    西洋参: "xī yáng shēn",
    林荫道: "lín yīn dào",
    拉家常: "lā jiā cháng",
    卷铺盖: "juǎn pū gài",
    过得硬: "guò de yìng",
    飞将军: "fēi jiāng jūn",
    挑大梁: "tiǎo dà liáng",
    哈巴狗: "hǎ ba gǒu",
    过家家: "guò jiā jiā",
    催泪弹: "cuī lèi dàn",
    雨夹雪: "yǔ jiā xuě",
    敲竹杠: "qiāo zhú gàng",
    列车长: "liè chē zhǎng",
    华达呢: "huá dá ní",
    犯得着: "fàn de zháo",
    土疙瘩: "tǔ gē da",
    煞风景: "shā fēng jǐng",
    轻量级: "qīng liàng jí",
    羞答答: "xiū dā dā",
    石子儿: "shí zǐ er",
    达姆弹: "dá mǔ dàn",
    科教片: "kē jiào piān",
    侃大山: "kǎn dà shān",
    丁点儿: "dīng diǎn er",
    吃得消: "chī de xiāo",
    捋虎须: "luō hǔ xū",
    高丽参: "gāo lí shēn",
    众生相: "zhòng shēng xiàng",
    咽峡炎: "yān xiá yán",
    禁得住: "jīn de zhù",
    吃得开: "chī de kāi",
    柞丝绸: "zuò sī chóu",
    应声虫: "yìng shēng chóng",
    数得着: "shǔ de zháo",
    傻劲儿: "shǎ jìn er",
    铅玻璃: "qiān bō li",
    可的松: "kě dì sōng",
    划得来: "huá de lái",
    晕乎乎: "yūn hū hū",
    屎壳郎: "shǐ ke làng",
    尥蹶子: "liào juě zi",
    藏红花: "zàng hóng huā",
    闷罐车: "mèn guàn chē",
    卡脖子: "qiǎ bó zi",
    红澄澄: "hóng deng deng",
    赶得及: "gǎn de jí",
    当间儿: "dāng jiàn er",
    露马脚: "lòu mǎ jiǎo",
    鸡内金: "jī nèi jīn",
    犯得上: "fàn de shàng",
    钉齿耙: "dīng chǐ bà",
    饱和点: "bǎo hé diǎn",
    龙爪槐: "lóng zhǎo huái",
    喝倒彩: "hè dào cǎi",
    定冠词: "dìng guàn cí",
    担担面: "dàn dan miàn",
    吃得住: "chī de zhù",
    爪尖儿: "zhuǎ jiān er",
    支着儿: "zhī zhāo er",
    折跟头: "zhē gēn tou",
    阴着儿: "yīn zhāo er",
    烟卷儿: "yān juǎn er",
    宣传弹: "xuān chuán dàn",
    信皮儿: "xìn pí er",
    弦切角: "xián qiē jiǎo",
    缩砂密: "sù shā mì",
    说得来: "shuō de lái",
    水漂儿: "shuǐ piāo er",
    耍笔杆: "shuǎ bǐ gǎn",
    数得上: "shǔ de shàng",
    数不着: "shǔ bù zháo",
    数不清: "shǔ bù qīng",
    什件儿: "shí jiàn er",
    生死簿: "shēng sǐ bù",
    扇风机: "shān fēng jī",
    撒呓挣: "sā yì zheng",
    日记簿: "rì jì bù",
    热得快: "rè de kuài",
    亲家公: "qìng jia gōng",
    奇函数: "jī hán shù",
    拍纸簿: "pāi zhǐ bù",
    努劲儿: "nǔ jìn er",
    泥娃娃: "ní wá wa",
    内切圆: "nèi qiē yuán",
    哪会儿: "nǎ huì er",
    闷头儿: "mēn tóu er",
    没谱儿: "méi pǔ er",
    铆劲儿: "mǎo jìn er",
    溜肩膀: "liū jiān bǎng",
    了望台: "liào wàng tái",
    老来少: "lǎo lái shào",
    坤角儿: "kūn jué er",
    考勤簿: "kǎo qín bù",
    卷笔刀: "juǎn bǐ dāo",
    进给量: "jìn jǐ liàng",
    划不来: "huá bù lái",
    汗褂儿: "hàn guà er",
    鼓囊囊: "gǔ nāng nāng",
    够劲儿: "gòu jìn er",
    公切线: "gōng qiē xiàn",
    搁得住: "gé de zhù",
    赶浪头: "gǎn làng tóu",
    赶得上: "gǎn de shàng",
    干酵母: "gān jiào mǔ",
    嘎渣儿: "gā zhā er",
    嘎嘣脆: "gā bēng cuì",
    对得住: "duì de zhù",
    逗闷子: "dòu mèn zi",
    顶呱呱: "dǐng guā guā",
    滴溜儿: "dī liù er",
    大轴子: "dà zhòu zi",
    打板子: "dǎ bǎn zi",
    寸劲儿: "cùn jìn er",
    醋劲儿: "cù jìn er",
    揣手儿: "chuāi shǒu er",
    冲劲儿: "chòng jìn er",
    吃得来: "chī de lái",
    不更事: "bù gēng shì",
    奔头儿: "bèn tou er",
    百夫长: "bǎi fū zhǎng",
    娃娃亲: "wá wa qīn",
    死劲儿: "sǐ jìn er",
    骨朵儿: "gū duǒ er",
    功劳簿: "gōng láo bù",
    都江堰: "dū jiāng yàn",
    一担水: "yí dàn shuǐ",
    否极泰: "pǐ jí tài",
    泰来否: "tài lái pǐ",
    咳特灵: "ké tè líng",
    开户行: "kāi hù háng",
    郦食其: "lì yì jī",
    花事了: "huā shì liǎo",
    // 一字变调的词语（与两个字的字典冲突，故需要重新定义）
    一更更: "yì gēng gēng",
    一重山: "yì chóng shān",
    风一更: "fēng yì gēng",
    雪一更: "xuě yì gēng",
    归一码: "guī yì mǎ",
    // 一字不变调的词语（需要增补更多）
    星期一: "xīng qī yī",
    礼拜一: "lǐ bài yī",
    一季度: "yī jì dù",
    一月一: "yī yuè yī",
    一字马: "yī zì mǎ",
    一是一: "yī shì yī",
    一次方: "yī cì fāng",
    一阳指: "yī yáng zhǐ",
    一字决: "yī zì jué",
    一年级: "yī nián jí",
    一不做: "yī bú zuò",
    屈戌儿: "qū qu ér",
    难为水: "nán wéi shuǐ",
    难为情: "nán wéi qíng",
    行一行: "xíng yì háng",
    别别的: "biè bié de",
    干哪行: "gàn nǎ háng",
    干一行: "gàn yì háng",
    曲别针: "qū bié zhēn"
  };
  const Pattern3 = Object.keys(DICT3).map((key) => ({
    zh: key,
    pinyin: DICT3[key],
    probability: 2e-8,
    length: 3,
    priority: Priority.Normal,
    dict: Symbol("dict3")
  }));
  const DICT4 = {
    成吉思汗: "chéng jí sī hán",
    四通八达: "sì tōng bā dá",
    一模一样: "yì mú yí yàng",
    青藏高原: "qīng zàng gāo yuán",
    阿弥陀佛: "ē mí tuó fó",
    解放思想: "jiè fàng sī xiǎng",
    所作所为: "suǒ zuò suǒ wéi",
    迷迷糊糊: "mí mí hu hū",
    荷枪实弹: "hè qiāng shí dàn",
    兴高采烈: "xìng gāo cǎi liè",
    无能为力: "wú néng wéi lì",
    布鲁塞尔: "bù lǔ sài ěr",
    为所欲为: "wéi suǒ yù wéi",
    克什米尔: "kè shí mǐ ěr",
    没完没了: "méi wán méi liǎo",
    不为人知: "bù wéi rén zhī",
    结结巴巴: "jiē jiē bā bā",
    前仆后继: "qián pū hòu jì",
    铺天盖地: "pū tiān gài dì",
    直截了当: "zhí jié liǎo dàng",
    供不应求: "gōng bú yìng qiú",
    御史大夫: "yù shǐ dà fū",
    不为瓦全: "bù wéi wǎ quán",
    不可收拾: "bù kě shōu shi",
    胡作非为: "hú zuò fēi wéi",
    分毫不差: "fēn háo bú chà",
    模模糊糊: "mó mó hu hū",
    不足为奇: "bù zú wéi qí",
    悄无声息: "qiǎo wú shēng xī",
    了如指掌: "liǎo rú zhǐ zhǎng",
    深恶痛绝: "shēn wù tòng jué",
    高高兴兴: "gāo gāo xìng xìng",
    唉声叹气: "āi shēng tàn qì",
    汉藏语系: "hàn zàng yǔ xì",
    处心积虑: "chǔ xīn jī lǜ",
    泣不成声: "qì bù chéng shēng",
    半夜三更: "bàn yè sān gēng",
    失魂落魄: "shī hún luò pò",
    二十八宿: "èr shí bā xiù",
    转来转去: "zhuàn lái zhuàn qù",
    数以万计: "shǔ yǐ wàn jì",
    相依为命: "xiāng yī wéi mìng",
    恋恋不舍: "liàn liàn bù shě",
    屈指可数: "qū zhǐ kě shǔ",
    神出鬼没: "shén chū guǐ mò",
    结结实实: "jiē jiē shí shí",
    有的放矢: "yǒu dì fàng shǐ",
    叽哩咕噜: "jī lǐ gū lū",
    调兵遣将: "diào bīng qiǎn jiàng",
    载歌载舞: "zài gē zài wǔ",
    转危为安: "zhuǎn wēi wéi ān",
    踏踏实实: "tā tā shi shí",
    桑给巴尔: "sāng jǐ bā ěr",
    装模作样: "zhuāng mú zuò yàng",
    见义勇为: "jiàn yì yǒng wéi",
    相差无几: "xiāng chā wú jǐ",
    叹为观止: "tàn wéi guān zhǐ",
    闷闷不乐: "mèn mèn bú lè",
    喜怒哀乐: "xǐ nù āi lè",
    鲜为人知: "xiǎn wéi rén zhī",
    张牙舞爪: "zhāng yá wǔ zhǎo",
    为非作歹: "wéi fēi zuò dǎi",
    含糊其辞: "hán hú qí cí",
    疲于奔命: "pí yú bēn mìng",
    勉为其难: "miǎn wéi qí nán",
    依依不舍: "yī yī bù shě",
    顶头上司: "dǐng tóu shàng si",
    不着边际: "bù zhuó biān jì",
    大模大样: "dà mú dà yàng",
    寻欢作乐: "xún huān zuò lè",
    一走了之: "yì zǒu liǎo zhī",
    字里行间: "zì lǐ háng jiān",
    含含糊糊: "hán hán hu hū",
    恰如其分: "qià rú qí fèn",
    破涕为笑: "pò tì wéi xiào",
    深更半夜: "shēn gēng bàn yè",
    千差万别: "qiān chā wàn bié",
    数不胜数: "shǔ bú shèng shǔ",
    据为己有: "jù wéi jǐ yǒu",
    天旋地转: "tiān xuán dì zhuàn",
    养尊处优: "yǎng zūn chǔ yōu",
    玻璃纤维: "bō li xiān wéi",
    吵吵闹闹: "chāo chao nào nào",
    晕头转向: "yūn tóu zhuàn xiàng",
    土生土长: "tǔ shēng tǔ zhǎng",
    宁死不屈: "nìng sǐ bù qū",
    不省人事: "bù xǐng rén shì",
    尽力而为: "jìn lì ér wéi",
    精明强干: "jīng míng qiáng gàn",
    唠唠叨叨: "láo lao dāo dāo",
    叽叽喳喳: "jī ji zhā zhā",
    功不可没: "gōng bù kě mò",
    锲而不舍: "qiè ér bù shě",
    排忧解难: "pái yōu jiě nàn",
    稀里糊涂: "xī li hú tú",
    各有所长: "gè yǒu suǒ cháng",
    的的确确: "dí dí què què",
    哄堂大笑: "hōng táng dà xiào",
    听而不闻: "tīng ér bù wén",
    刀耕火种: "dāo gēng huǒ zhòng",
    内分泌腺: "nèi fèn mì xiàn",
    化险为夷: "huà xiǎn wéi yí",
    百发百中: "bǎi fā bǎi zhòng",
    重见天日: "chóng jiàn tiān rì",
    反败为胜: "fǎn bài wéi shèng",
    一了百了: "yì liǎo bǎi liǎo",
    大大咧咧: "dà da liē liē",
    心急火燎: "xīn jí huǒ liǎo",
    粗心大意: "cū xīn dà yi",
    鸡皮疙瘩: "jī pí gē da",
    夷为平地: "yí wéi píng dì",
    日积月累: "rì jī yuè lěi",
    设身处地: "shè shēn chǔ dì",
    投其所好: "tóu qí suǒ hào",
    间不容发: "jiān bù róng fà",
    人满为患: "rén mǎn wéi huàn",
    穷追不舍: "qióng zhuī bù shě",
    为时已晚: "wéi shí yǐ wǎn",
    如数家珍: "rú shǔ jiā zhēn",
    心里有数: "xīn lǐ yǒu shù",
    以牙还牙: "yǐ yá huán yá",
    神不守舍: "shén bù shǒu shě",
    孟什维克: "mèng shí wéi kè",
    各自为战: "gè zì wéi zhàn",
    怨声载道: "yuàn shēng zài dào",
    救苦救难: "jiù kǔ jiù nàn",
    好好先生: "hǎo hǎo xiān sheng",
    怪模怪样: "guài mú guài yàng",
    抛头露面: "pāo tóu lù miàn",
    游手好闲: "yóu shǒu hào xián",
    无所不为: "wú suǒ bù wéi",
    调虎离山: "diào hǔ lí shān",
    步步为营: "bù bù wéi yíng",
    好大喜功: "hào dà xǐ gōng",
    众矢之的: "zhòng shǐ zhī dì",
    长生不死: "cháng shēng bù sǐ",
    蔚为壮观: "wèi wéi zhuàng guān",
    不可胜数: "bù kě shèng shǔ",
    鬼使神差: "guǐ shǐ shén chāi",
    洁身自好: "jié shēn zì hào",
    敢作敢为: "gǎn zuò gǎn wéi",
    茅塞顿开: "máo sè dùn kāi",
    走马换将: "zǒu mǎ huàn jiàng",
    为时过早: "wéi shí guò zǎo",
    为人师表: "wéi rén shī biǎo",
    阴差阳错: "yīn chā yáng cuò",
    油腔滑调: "yóu qiāng huá diào",
    重蹈覆辙: "chóng dǎo fù zhé",
    骂骂咧咧: "mà ma liē liē",
    絮絮叨叨: "xù xù dāo dāo",
    如履薄冰: "rú lǚ bó bīng",
    损兵折将: "sǔn bīng zhé jiàng",
    拐弯抹角: "guǎi wān mò jiǎo",
    像模像样: "xiàng mú xiàng yàng",
    供过于求: "gōng guò yú qiú",
    开花结果: "kāi huā jiē guǒ",
    仔仔细细: "zǐ zǐ xì xì",
    川藏公路: "chuān zàng gōng lù",
    河北梆子: "hé běi bāng zi",
    长年累月: "cháng nián lěi yuè",
    正儿八经: "zhèng er bā jīng",
    不识抬举: "bù shí tái ju",
    重振旗鼓: "chóng zhèn qí gǔ",
    气息奄奄: "qì xī yān yān",
    紧追不舍: "jǐn zhuī bù shě",
    服服帖帖: "fú fu tiē tiē",
    强词夺理: "qiǎng cí duó lǐ",
    噼里啪啦: "pī li pā lā",
    人才济济: "rén cái jǐ jǐ",
    发人深省: "fā rén shēn xǐng",
    不足为凭: "bù zú wéi píng",
    为富不仁: "wéi fù bù rén",
    连篇累牍: "lián piān lěi dú",
    呼天抢地: "hū tiān qiāng dì",
    落落大方: "luò luò dà fāng",
    自吹自擂: "zì chuī zì léi",
    乐善好施: "lè shàn hào shī",
    以攻为守: "yǐ gōng wéi shǒu",
    磨磨蹭蹭: "mó mó cèng cèng",
    削铁如泥: "xuē tiě rú ní",
    助纣为虐: "zhù zhòu wéi nüè",
    以退为进: "yǐ tuì wéi jìn",
    嘁嘁喳喳: "qī qī chā chā",
    枪林弹雨: "qiāng lín dàn yǔ",
    令人发指: "lìng rén fà zhǐ",
    转败为胜: "zhuǎn bài wéi shèng",
    转弯抹角: "zhuǎn wān mò jiǎo",
    在劫难逃: "zài jié nán táo",
    正当防卫: "zhèng dàng fáng wèi",
    不足为怪: "bù zú wéi guài",
    难兄难弟: "nàn xiōng nàn dì",
    咿咿呀呀: "yī yī yā yā",
    弹尽粮绝: "dàn jìn liáng jué",
    阿谀奉承: "ē yú fèng chéng",
    稀里哗啦: "xī li huā lā",
    返老还童: "fǎn lǎo huán tóng",
    好高骛远: "hào gāo wù yuǎn",
    鹿死谁手: "lù sǐ shéi shǒu",
    差强人意: "chā qiáng rén yì",
    大吹大擂: "dà chuī dà léi",
    成家立业: "chéng jiā lì yè",
    自怨自艾: "zì yuàn zì yì",
    负债累累: "fù zhài lěi lěi",
    古为今用: "gǔ wéi jīn yòng",
    入土为安: "rù tǔ wéi ān",
    下不为例: "xià bù wéi lì",
    一哄而上: "yì hōng ér shàng",
    没头苍蝇: "méi tóu cāng ying",
    天差地远: "tiān chā dì yuǎn",
    风卷残云: "fēng juǎn cán yún",
    多灾多难: "duō zāi duō nàn",
    乳臭未干: "rǔ xiù wèi gān",
    行家里手: "háng jiā lǐ shǒu",
    狼狈为奸: "láng bèi wéi jiān",
    处变不惊: "chǔ biàn bù jīng",
    一唱一和: "yí chàng yí hè",
    一念之差: "yí niàn zhī chā",
    金蝉脱壳: "jīn chán tuō qiào",
    滴滴答答: "dī dī dā dā",
    硕果累累: "shuò guǒ léi léi",
    好整以暇: "hào zhěng yǐ xiá",
    红得发紫: "hóng de fā zǐ",
    传为美谈: "chuán wéi měi tán",
    富商大贾: "fù shāng dà gǔ",
    四海为家: "sì hǎi wéi jiā",
    了若指掌: "liǎo ruò zhǐ zhǎng",
    大有可为: "dà yǒu kě wéi",
    出头露面: "chū tóu lù miàn",
    鼓鼓囊囊: "gǔ gu nāng nāng",
    窗明几净: "chuāng míng jī jìng",
    泰然处之: "tài rán chǔ zhī",
    怒发冲冠: "nù fà chōng guān",
    有机玻璃: "yǒu jī bō li",
    骨头架子: "gǔ tou jià zi",
    义薄云天: "yì bó yún tiān",
    一丁点儿: "yī dīng diǎn er",
    时来运转: "shí lái yùn zhuǎn",
    陈词滥调: "chén cí làn diào",
    化整为零: "huà zhěng wéi líng",
    火烧火燎: "huǒ shāo huǒ liǎo",
    干脆利索: "gàn cuì lì suǒ",
    吊儿郎当: "diào er láng dāng",
    广种薄收: "guǎng zhòng bó shōu",
    种瓜得瓜: "zhòng guā dé guā",
    种豆得豆: "zhòng dòu dé dòu",
    难舍难分: "nán shě nán fēn",
    歃血为盟: "shà xuè wéi méng",
    奋发有为: "fèn fā yǒu wéi",
    阴错阳差: "yīn cuò yáng chā",
    东躲西藏: "dōng duǒ xī cáng",
    烟熏火燎: "yān xūn huǒ liǎo",
    钻牛角尖: "zuān niú jiǎo jiān",
    乔装打扮: "qiáo zhuāng dǎ bàn",
    改弦更张: "gǎi xián gēng zhāng",
    河南梆子: "hé nán bāng zi",
    好吃懒做: "hào chī lǎn zuò",
    何乐不为: "hé lè bù wéi",
    大出风头: "dà chū fēng tóu",
    攻城掠地: "gōng chéng lüè dì",
    漂漂亮亮: "piào piào liang liang",
    折衷主义: "zhé zhōng zhǔ yì",
    大马哈鱼: "dà mǎ hǎ yú",
    绿树成荫: "lǜ shù chéng yīn",
    率先垂范: "shuài xiān chuí fàn",
    家长里短: "jiā cháng lǐ duǎn",
    宽大为怀: "kuān dà wéi huái",
    左膀右臂: "zuǒ bǎng yòu bì",
    一笑了之: "yí xiào liǎo zhī",
    天下为公: "tiān xià wéi gōng",
    还我河山: "huán wǒ hé shān",
    何足为奇: "hé zú wéi qí",
    好自为之: "hǎo zì wéi zhī",
    风姿绰约: "fēng zī chuò yuē",
    大雨滂沱: "dà yǔ pāng tuó",
    传为佳话: "chuán wéi jiā huà",
    吃里扒外: "chī lǐ pá wài",
    重操旧业: "chóng cāo jiù yè",
    小家子气: "xiǎo jiā zi qì",
    少不更事: "shào bù gēng shì",
    难分难舍: "nán fēn nán shě",
    添砖加瓦: "tiān zhuān jiā wǎ",
    是非分明: "shì fēi fēn míng",
    舍我其谁: "shě wǒ qí shuí",
    偏听偏信: "piān tīng piān xìn",
    量入为出: "liàng rù wéi chū",
    降龙伏虎: "xiáng lóng fú hǔ",
    钢化玻璃: "gāng huà bō li",
    正中下怀: "zhèng zhòng xià huái",
    以身许国: "yǐ shēn xǔ guó",
    一语中的: "yì yǔ zhòng dì",
    丧魂落魄: "sàng hún luò pò",
    三座大山: "sān zuò dà shān",
    济济一堂: "jǐ jǐ yì táng",
    好事之徒: "hào shì zhī tú",
    干净利索: "gàn jìng lì suǒ",
    出将入相: "chū jiàng rù xiàng",
    袅袅娜娜: "niǎo niǎo nuó nuó",
    狐狸尾巴: "hú li wěi ba",
    好逸恶劳: "hào yì wù láo",
    大而无当: "dà ér wú dàng",
    打马虎眼: "dǎ mǎ hu yǎn",
    板上钉钉: "bǎn shàng dìng dīng",
    吆五喝六: "yāo wǔ hè liù",
    虾兵蟹将: "xiā bīng xiè jiàng",
    水调歌头: "shuǐ diào gē tóu",
    数典忘祖: "shǔ diǎn wàng zǔ",
    人事不省: "rén shì bù xǐng",
    曲高和寡: "qǔ gāo hè guǎ",
    屡教不改: "lǚ jiào bù gǎi",
    互为因果: "hù wéi yīn guǒ",
    互为表里: "hù wéi biǎo lǐ",
    厚此薄彼: "hòu cǐ bó bǐ",
    过关斩将: "guò guān zhǎn jiàng",
    疙疙瘩瘩: "gē ge dā dā",
    大腹便便: "dà fù pián pián",
    走为上策: "zǒu wéi shàng cè",
    冤家对头: "yuān jia duì tóu",
    有隙可乘: "yǒu xì kě chèng",
    一鳞半爪: "yì lín bàn zhǎo",
    片言只语: "piàn yán zhǐ yǔ",
    开花结实: "kāi huā jié shí",
    经年累月: "jīng nián lěi yuè",
    含糊其词: "hán hú qí cí",
    寡廉鲜耻: "guǎ lián xiǎn chǐ",
    成年累月: "chéng nián lěi yuè",
    不徇私情: "bú xùn sī qíng",
    不当人子: "bù dāng rén zǐ",
    膀大腰圆: "bǎng dà yāo yuán",
    指腹为婚: "zhǐ fù wéi hūn",
    这么点儿: "zhè me diǎn er",
    意兴索然: "yì xīng suǒ rán",
    绣花枕头: "xiù huā zhěn tou",
    无的放矢: "wú dì fàng shǐ",
    望闻问切: "wàng wén wèn qiè",
    舍己为人: "shě jǐ wèi rén",
    穷年累月: "qióng nián lěi yuè",
    排难解纷: "pái nàn jiě fēn",
    处之泰然: "chǔ zhī tài rán",
    指鹿为马: "zhǐ lù wéi mǎ",
    危如累卵: "wēi rú lěi luǎn",
    天兵天将: "tiān bīng tiān jiàng",
    舍近求远: "shě jìn qiú yuǎn",
    南腔北调: "nán qiāng běi diào",
    苦中作乐: "kǔ zhōng zuò lè",
    厚积薄发: "hòu jī bó fā",
    臭味相投: "xiù wèi xiāng tóu",
    长幼有序: "zhǎng yòu yǒu xù",
    逼良为娼: "bī liáng wéi chāng",
    悲悲切切: "bēi bēi qiè qiē",
    败军之将: "bài jūn zhī jiàng",
    欺行霸市: "qī háng bà shì",
    削足适履: "xuē zú shì lǚ",
    先睹为快: "xiān dǔ wéi kuài",
    啼饥号寒: "tí jī háo hán",
    疏不间亲: "shū bú jiàn qīn",
    神差鬼使: "shén chāi guǐ shǐ",
    敲敲打打: "qiāo qiāo dǎ dǎ",
    平铺直叙: "píng pū zhí xù",
    没头没尾: "méi tóu mò wěi",
    寥寥可数: "liáo liáo kě shǔ",
    哼哈二将: "hēng hā èr jiàng",
    鹤发童颜: "hè fà tóng yán",
    各奔前程: "gè bèn qián chéng",
    弹无虚发: "dàn wú xū fā",
    大人先生: "dà rén xiān sheng",
    与民更始: "yǔ mín gēng shǐ",
    树碑立传: "shù bēi lì zhuàn",
    是非得失: "shì fēi dé shī",
    实逼处此: "shí bī chǔ cǐ",
    塞翁失马: "sài wēng shī mǎ",
    日薄西山: "rì bó xī shān",
    切身体会: "qiè shēn tǐ huì",
    片言只字: "piàn yán zhǐ zì",
    跑马卖解: "pǎo mǎ mài xiè",
    宁折不弯: "nìng zhé bù wān",
    零零散散: "líng líng sǎn sǎn",
    量体裁衣: "liàng tǐ cái yī",
    连中三元: "lián zhòng sān yuán",
    礼崩乐坏: "lǐ bēng yuè huài",
    不为已甚: "bù wéi yǐ shèn",
    转悲为喜: "zhuǎn bēi wéi xǐ",
    以眼还眼: "yǐ yǎn huán yǎn",
    蔚为大观: "wèi wéi dà guān",
    未为不可: "wèi wéi bù kě",
    童颜鹤发: "tóng yán hè fà",
    朋比为奸: "péng bǐ wéi jiān",
    莫此为甚: "mò cǐ wéi shèn",
    夹枪带棒: "jiā qiāng dài bàng",
    富商巨贾: "fù shāng jù jiǎ",
    淡然处之: "dàn rán chǔ zhī",
    箪食壶浆: "dān shí hú jiāng",
    创巨痛深: "chuāng jù tòng shēn",
    草长莺飞: "cǎo zhǎng yīng fēi",
    坐视不救: "zuò shī bú jiù",
    以己度人: "yǐ jǐ duó rén",
    随行就市: "suí háng jiù shì",
    文以载道: "wén yǐ zài dào",
    文不对题: "wén bú duì tí",
    铁板钉钉: "tiě bǎn dìng dīng",
    身体发肤: "shēn tǐ fà fū",
    缺吃少穿: "quē chī shǎo chuān",
    目无尊长: "mù wú zūn zhǎng",
    吉人天相: "jí rén tiān xiàng",
    毁家纾难: "huǐ jiā shū nàn",
    钢筋铁骨: "gāng jīn tiě gǔ",
    丢卒保车: "diū zú bǎo jū",
    丢三落四: "diū sān là sì",
    闭目塞听: "bì mù sè tīng",
    削尖脑袋: "xuē jiān nǎo dài",
    为非作恶: "wéi fēi zuò è",
    人才难得: "rén cái nán dé",
    情非得已: "qíng fēi dé yǐ",
    切中要害: "qiè zhòng yào hài",
    火急火燎: "huǒ jí huǒ liǎo",
    画地为牢: "huà dì wéi láo",
    好酒贪杯: "hào jiǔ tān bēi",
    长歌当哭: "cháng gē dàng kū",
    载沉载浮: "zài chén zài fú",
    遇难呈祥: "yù nàn chéng xiáng",
    榆木疙瘩: "yú mù gē da",
    以邻为壑: "yǐ lín wéi hè",
    洋为中用: "yáng wéi zhōng yòng",
    言为心声: "yán wéi xīn shēng",
    言必有中: "yán bì yǒu zhòng",
    图穷匕见: "tú qióng bǐ xiàn",
    滂沱大雨: "páng tuó dà yǔ",
    目不暇给: "mù bù xiá jǐ",
    量才录用: "liàng cái lù yòng",
    教学相长: "jiào xué xiāng zhǎng",
    悔不当初: "huǐ bù dāng chū",
    呼幺喝六: "hū yāo hè liù",
    不足为训: "bù zú wéi xùn",
    不拘形迹: "bù jū xíng jī",
    傍若无人: "páng ruò wú rén",
    罪责难逃: "zuì zé nán táo",
    自我吹嘘: "zì wǒ chuī xū",
    转祸为福: "zhuǎn huò wéi fú",
    勇冠三军: "yǒng guàn sān jūn",
    易地而处: "yì dì ér chǔ",
    卸磨杀驴: "xiè mò shā lǘ",
    玩儿不转: "wán ér bú zhuàn",
    天道好还: "tiān dào hǎo huán",
    身单力薄: "shēn dān lì bó",
    撒豆成兵: "sǎ dòu chéng bīng",
    片纸只字: "piàn zhǐ zhī zì",
    宁缺毋滥: "nìng quē wú làn",
    没没无闻: "mò mò wú wén",
    量力而为: "liàng lì ér wéi",
    历历可数: "lì lì kě shǔ",
    口碑载道: "kǒu bēi zài dào",
    君子好逑: "jūn zǐ hǎo qiú",
    好为人师: "hào wéi rén shī",
    豪商巨贾: "háo shāng jù jiǎ",
    各有所好: "gè yǒu suǒ hào",
    度德量力: "duó dé liàng lì",
    指天为誓: "zhǐ tiān wéi shì",
    逸兴遄飞: "yì xìng chuán fēi",
    心宽体胖: "xīn kuān tǐ pán",
    为德不卒: "wéi dé bù zú",
    天下为家: "tiān xià wéi jiā",
    视为畏途: "shì wéi wèi tú",
    三灾八难: "sān zāi bā nàn",
    沐猴而冠: "mù hóu ér guàn",
    哩哩啦啦: "lī li lā lā",
    见缝就钻: "jiàn fèng jiù zuān",
    夹层玻璃: "jiā céng bō li",
    急公好义: "jí gōng hào yì",
    积年累月: "jī nián lěi yuè",
    划地为牢: "huá dì wéi láo",
    更名改姓: "gēng míng gǎi xìng",
    奉为圭臬: "fèng wéi guī niè",
    多难兴邦: "duō nàn xīng bāng",
    不破不立: "bú pò bú lì",
    坐地自划: "zuò dì zì huá",
    坐不重席: "zuò bù chóng xí",
    坐不窥堂: "zuò bù kuī táng",
    作嫁衣裳: "zuò jià yī shang",
    左枝右梧: "zuǒ zhī yòu wú",
    左宜右有: "zuǒ yí yòu yǒu",
    钻头觅缝: "zuān tóu mì fèng",
    钻天打洞: "zuān tiān dǎ dòng",
    钻皮出羽: "zuān pí chū yǔ",
    钻火得冰: "zuān huǒ dé bīng",
    钻洞觅缝: "zuàn dòng mì féng",
    钻冰求火: "zuān bīng qiú huǒ",
    子为父隐: "zǐ wéi fù yǐn",
    擢发难数: "zhuó fà nán shǔ",
    着人先鞭: "zhuó rén xiān biān",
    斫雕为朴: "zhuó diāo wéi pǔ",
    锥处囊中: "zhuī chǔ náng zhōng",
    椎心饮泣: "chuí xīn yǐn qì",
    椎心泣血: "chuí xīn qì xuè",
    椎牛飨士: "chuí niú xiǎng shì",
    椎牛歃血: "chuí niú shà xuè",
    椎牛发冢: "chuí niú fà zhǒng",
    椎埋屠狗: "chuí mái tú gǒu",
    椎埋狗窃: "chuí mái gǒu qiè",
    壮发冲冠: "zhuàng fā chōng guàn",
    庄严宝相: "zhuāng yán bǎo xiàng",
    转愁为喜: "zhuǎn chóu wéi xǐ",
    转嗔为喜: "zhuǎn chēn wéi xǐ",
    拽巷啰街: "zhuài xiàng luó jiē",
    拽耙扶犁: "zhuāi pá fú lí",
    拽布拖麻: "zhuài bù tuō má",
    箸长碗短: "zhù cháng wǎn duǎn",
    铸剑为犁: "zhù jiàn wéi lí",
    杼柚其空: "zhù yòu qí kōng",
    杼柚空虚: "zhù yòu kōng xū",
    助天为虐: "zhù tiān wéi nüè",
    属垣有耳: "zhǔ yuán yǒu ěr",
    属毛离里: "zhǔ máo lí lǐ",
    属辞比事: "zhǔ cí bǐ shì",
    逐物不还: "zhú wù bù huán",
    铢量寸度: "zhū liáng cùn duó",
    铢两悉称: "zhū liǎng xī chèn",
    侏儒观戏: "zhū rú guān xì",
    朱轓皁盖: "zhū fān zào gài",
    昼度夜思: "zhòu duó yè sī",
    诪张为幻: "zhōu zhāng wéi huàn",
    重明继焰: "chóng míng jì yàn",
    众啄同音: "zhòng zhuó tóng yīn",
    众毛攒裘: "zhòng máo cuán qiú",
    众好众恶: "zhòng hào zhòng wù",
    擿埴索涂: "zhāi zhí suǒ tú",
    稚齿婑媠: "zhì chǐ wǒ tuó",
    至当不易: "zhì dàng bú yì",
    指皂为白: "zhǐ zào wéi bái",
    指雁为羹: "zhǐ yàn wéi gēng",
    指树为姓: "zhǐ shù wéi xìng",
    指山说磨: "zhǐ shān shuō mò",
    止戈为武: "zhǐ gē wéi wǔ",
    枝干相持: "zhī gàn xiāng chí",
    枝大于本: "zh dà yú běn",
    支吾其词: "zhī wú qí cí",
    正身率下: "zhèng shēn shuài xià",
    正冠李下: "zhèng guàn lǐ xià",
    整冠纳履: "zhěng guān nà lǚ",
    整躬率物: "zhěng gōng shuài wù",
    整顿干坤: "zhěng dùn gàn kūn",
    针头削铁: "zhēn tóu xuē tiě",
    贞松劲柏: "zhēn sōng jìng bǎi",
    赭衣塞路: "zhě yī sè lù",
    折箭为誓: "shé jiàn wéi shì",
    折而族之: "zhé ér zú zhī",
    昭德塞违: "zhāo dé sè wéi",
    章句小儒: "zhāng jù xiǎo rú",
    湛恩汪濊: "zhàn ēn wāng huì",
    占风望气: "zhān fēng wàng qì",
    斩将搴旗: "zhǎn jiàng qiān qí",
    曾母投杼: "zēng mǔ tóu zhù",
    曾参杀人: "zēng shēn shā rén",
    造谣中伤: "zào yáo zhòng shāng",
    早占勿药: "zǎo zhān wù yào",
    凿龟数策: "záo guī shǔ cè",
    攒三聚五: "cuán sān jù wǔ",
    攒眉蹙额: "cuán mei cù é",
    攒零合整: "cuán líng hé zhěng",
    攒锋聚镝: "cuán fēng jù dí",
    载笑载言: "zài xiào zài yán",
    载酒问字: "zài jiǔ wèn zì",
    殒身不恤: "yǔn shēn bú xù",
    云舒霞卷: "yún shū xiá juǎn",
    月中折桂: "yuè zhōng shé guì",
    月落参横: "yuè luò shēn héng",
    鬻驽窃价: "yù nú qiè jià",
    鬻鸡为凤: "yù jī wéi fèng",
    遇难成祥: "yù nàn chéng xiáng",
    郁郁累累: "yù yù lěi lěi",
    玉卮无当: "yù zhī wú dàng",
    语笑喧阗: "yǔ xiào xuān tián",
    与世沉浮: "yǔ shì chén fú",
    与时消息: "yǔ shí xiāo xi",
    逾墙钻隙: "yú qiáng zuān xì",
    渔夺侵牟: "yú duó qīn móu",
    杅穿皮蠹: "yú chuān pí dù",
    余勇可贾: "yú yǒng kě gǔ",
    予智予雄: "yú zhì yú xióng",
    予取予求: "yú qǔ yú qiú",
    于家为国: "yú jiā wéi guó",
    有借无还: "yǒu jiè wú huán",
    有加无已: "yǒu jiā wú yǐ",
    有国难投: "yǒu guó nán tóu",
    游必有方: "yóu bì yǒu fāng",
    油干灯尽: "yóu gàn dēng jìn",
    尤云殢雨: "yóu yún tì yǔ",
    庸中皦皦: "yōng zhōng jiǎo jiǎo",
    郢书燕说: "yǐng shū yān shuō",
    营蝇斐锦: "yíng yíng fēi jǐn",
    鹰心雁爪: "yīng xīn yàn zhǎo",
    莺吟燕儛: "yīng yín yàn wǔ",
    应天顺时: "yīng tiān shùn shí",
    印累绶若: "yìn léi shòu ruò",
    隐占身体: "yǐn zhàn shēn tǐ",
    饮犊上流: "yìn dú shàng liú",
    引绳切墨: "yǐn shéng qiē mò",
    龈齿弹舌: "yín chǐ dàn shé",
    因缘为市: "yīn yuán wéi shì",
    因树为屋: "yīn shù wéi wū",
    溢美溢恶: "yì měi yì wù",
    抑塞磊落: "yì sè lěi luò",
    倚闾望切: "yǐ lǘ wàng qiē",
    以意为之: "yǐ yì wéi zhī",
    以言为讳: "yǐ yán wéi huì",
    以疏间亲: "yǐ shū jiàn qīn",
    以水济水: "yǐ shuǐ jǐ shuǐ",
    以书为御: "yǐ shū wéi yù",
    以守为攻: "yǐ shǒu wéi gōng",
    以升量石: "yǐ shēng liáng dàn",
    以慎为键: "yǐ shèn wéi jiàn",
    以筌为鱼: "yǐ quán wéi yú",
    以利累形: "yǐ lì lěi xíng",
    以毁为罚: "yǐ huǐ wéi fá",
    以黑为白: "yǐ hēi wéi bái",
    以规为瑱: "yǐ guī wéi tiàn",
    以古为鉴: "yǐ gǔ wéi jiàn",
    以宫笑角: "yǐ gōng xiào jué",
    以法为教: "yǐ fǎ wéi jiào",
    以大恶细: "yǐ dà wù xì",
    遗世忘累: "yí shì wàng lěi",
    遗寝载怀: "yí qǐn zài huái",
    移的就箭: "yí dì jiù jiàn",
    依头缕当: "yī tóu lǚ dàng",
    衣租食税: "yì zū shí shuì",
    衣轻乘肥: "yì qīng chéng féi",
    衣裳之会: "yī shang zhī huì",
    衣单食薄: "yī dān shí bó",
    一还一报: "yì huán yí bào",
    叶公好龙: "yè gōng hào lóng",
    野调无腔: "yě diào wú qiāng",
    瑶池女使: "yáo chí nǚ shǐ",
    幺麽小丑: "yāo mó xiǎo chǒu",
    养精畜锐: "yǎng jīng xù ruì",
    卬首信眉: "áng shǒu shēn méi",
    洋洋纚纚: "yáng yáng sǎ sǎ",
    羊羔美酒: "yáng gāo měi jiǔ",
    扬风扢雅: "yáng fēng jié yǎ",
    燕昭市骏: "yān zhāo shì jùn",
    燕昭好马: "yān zhāo hǎo mǎ",
    燕石妄珍: "yān shí wàng zhēn",
    燕骏千金: "yān jùn qiān jīn",
    燕金募秀: "yān jīn mù xiù",
    燕驾越毂: "yān jià yuè gǔ",
    燕歌赵舞: "yān gē zhào wǔ",
    燕岱之石: "yān dài zhī shí",
    燕处危巢: "yàn chǔ wēi cháo",
    掞藻飞声: "shàn zǎo fēi shēng",
    偃革为轩: "yǎn gé wéi xuān",
    妍蚩好恶: "yán chī hǎo è",
    压良为贱: "yā liáng wéi jiàn",
    搀行夺市: "chān háng duó shì",
    泣数行下: "qì shù háng xià",
    当行出色: "dāng háng chū sè",
    秀出班行: "xiù chū bān háng",
    儿女成行: "ér nǚ chéng háng",
    大行大市: "dà háng dà shì",
    寻行数墨: "xún háng shǔ mò",
    埙篪相和: "xūn chí xiāng hè",
    血债累累: "xuè zhài lěi lěi",
    炫玉贾石: "xuàn yù gǔ shí",
    炫石为玉: "xuàn shí wéi yù",
    悬石程书: "xuán dàn chéng shū",
    悬狟素飡: "xuán huán sù cān",
    悬龟系鱼: "xuán guī xì yú",
    揎拳捋袖: "xuān quán luō xiù",
    轩鹤冠猴: "xuān hè guàn hóu",
    畜妻养子: "xù qī yǎng zǐ",
    羞人答答: "xiū rén dā dā",
    修鳞养爪: "xiū lín yǎng zhǎo",
    熊据虎跱: "xióng jù hǔ zhì",
    兄死弟及: "xiōng sǐ dì jí",
    腥闻在上: "xīng wén zài shàng",
    兴文匽武: "xīng wén yǎn wǔ",
    兴观群怨: "xìng guān qún yuàn",
    兴高彩烈: "xìng gāo cǎi liè",
    心手相应: "xīn shǒu xiāng yìng",
    心口相应: "xīn kǒu xiāng yīng",
    挟势弄权: "xié shì nòng quán",
    胁肩累足: "xié jiān lěi zú",
    校短量长: "jiào duǎn liáng cháng",
    小眼薄皮: "xiǎo yǎn bó pí",
    硝云弹雨: "xiāo yún dàn yǔ",
    鸮鸣鼠暴: "xiāo míng shǔ bào",
    削株掘根: "xuē zhū jué gēn",
    削铁无声: "xuē tiě wú shēng",
    削职为民: "xuē zhí wéi mín",
    削木为吏: "xuē mù wéi lì",
    想望风褱: "xiǎng wàng fēng huái",
    香培玉琢: "xiang pei yu zhuó",
    相鼠有皮: "xiàng shǔ yǒu pí",
    相时而动: "xiàng shí ér dòng",
    相切相磋: "xiāng qiē xiāng cuō",
    相女配夫: "xiàng nǚ pèi fū",
    相门有相: "xiàng mén yǒu xiàng",
    挦章撦句: "xián zhāng chě jù",
    先我着鞭: "xiān wǒ zhuó biān",
    习焉不察: "xí yān bù chá",
    歙漆阿胶: "shè qī ē jiāo",
    晰毛辨发: "xī máo biàn fà",
    悉索薄赋: "xī suǒ bó fù",
    雾鳞云爪: "wù lín yún zhǎo",
    物稀为贵: "wù xī wéi guì",
    碔砆混玉: "wǔ fū hùn yù",
    武断专横: "wǔ duàn zhuān héng",
    五石六鹢: "wǔ shí liù yì",
    五色相宣: "wǔ sè xiāng xuān",
    五侯七贵: "wǔ hóu qī guì",
    五侯蜡烛: "wǔ hòu là zhú",
    五羖大夫: "wǔ gǔ dà fū",
    吾自有处: "wú zì yǒu chǔ",
    无下箸处: "wú xià zhù chǔ",
    无伤无臭: "wú shāng wú xiù",
    无能为役: "wú néng wéi yì",
    无寇暴死: "wú kòu bào sǐ",
    无孔不钻: "wú kǒng bú zuàn",
    无间可乘: "wú jiān kě chéng",
    无间冬夏: "wú jiān dōng xià",
    无恶不为: "wú è bù wéi",
    无动为大: "wú dòng wéi dà",
    诬良为盗: "wū liáng wéi dào",
    握拳透爪: "wò quán tòu zhǎo",
    文武差事: "wén wǔ chāi shì",
    委委佗佗: "wēi wēi tuó tuó",
    惟日为岁: "wéi rì wéi suì",
    帷薄不修: "wéi bó bù xiū",
    为善最乐: "wéi shàn zuì lè",
    为山止篑: "wéi shān zhǐ kuì",
    为仁不富: "wéi rén bú fù",
    为裘为箕: "wéi qiú wéi jī",
    为民父母: "wéi mín fù mǔ",
    为虺弗摧: "wéi huǐ fú cuī",
    为好成歉: "wéi hǎo chéng qiàn",
    为鬼为蜮: "wéi guǐ wéi yù",
    望风响应: "wàng fēng xiǎng yīng",
    望尘僄声: "wàng chén piào shēng",
    往渚还汀: "wǎng zhǔ huán tīng",
    王贡弹冠: "wáng gòng dàn guàn",
    亡国大夫: "wáng guó dà fū",
    万贯家私: "wàn guàn jiā sī",
    晚食当肉: "wǎn shí dàng ròu",
    晚节不保: "wǎn jié bù bǎo",
    玩岁愒时: "wán suì kài shí",
    蛙蟆胜负: "wā má shèng fù",
    吞言咽理: "tūn yán yàn lǐ",
    颓垣断堑: "tuí yuán duàn qiàn",
    推干就湿: "tuī gàn jiù shī",
    剸繁决剧: "tuán fán jué jù",
    团头聚面: "tuán tóu jù miàn",
    兔丝燕麦: "tù sī yàn mài",
    兔头麞脑: "tù tóu zhāng nǎo",
    兔葵燕麦: "tù kuí yàn mài",
    吐哺握发: "tǔ bǔ wò fà",
    投传而去: "tóu zhuàn ér qù",
    头没杯案: "tóu mò bēi àn",
    头昏脑闷: "tóu hūn nǎo mèn",
    头会箕敛: "tóu kuài jī liǎn",
    头出头没: "tóu chū tóu mò",
    痛自创艾: "tòng zì chuāng yì",
    同恶相助: "tóng wù xiāng zhù",
    同恶相恤: "tóng wù xiāng xù",
    痌瘝在抱: "tōng guān zài bào",
    通文调武: "tōng wén diào wǔ",
    停留长智: "tíng liú zhǎng zhì",
    铁树开华: "tiě shù kāi huā",
    条贯部分: "tiáo guàn bù fēn",
    挑牙料唇: "tiǎo yá liào chún",
    挑么挑六: "tiāo yāo tiāo liù",
    挑唇料嘴: "tiǎo chún liào zuǐ",
    恬不为意: "tián bù wéi yì",
    恬不为怪: "tián bù wéi guài",
    天下为笼: "tiān xià wéi lóng",
    天台路迷: "tiān tái lù mí",
    天年不遂: "tiān nián bú suì",
    探囊胠箧: "tàn náng qū qiè",
    谭言微中: "tán yán wēi zhòng",
    谈言微中: "tán yán wēi zhòng",
    狧穅及米: "shì kāng jí mǐ",
    随物应机: "suí wù yīng jī",
    搜岩采干: "sōu yán cǎi gàn",
    宋斤鲁削: "sòng jīn lǔ xuē",
    松筠之节: "sōng yún zhī jié",
    四亭八当: "sì tíng bā dàng",
    四马攒蹄: "sì mǎ cuán tí",
    四不拗六: "sì bú niù liù",
    思所逐之: "sī suǒ zhú zhī",
    丝恩发怨: "sī ēn fà yuàn",
    硕望宿德: "shuò wàng xiǔ dé",
    铄古切今: "shuò gǔ qiē jīn",
    顺风而呼: "shùn fēng ér hū",
    顺风吹火: "shùn fēng chuī huǒ",
    水中著盐: "shuǐ zhōng zhuó yán",
    双柑斗酒: "shuāng gān dǒu jiǔ",
    数米而炊: "shǔ mǐ ér chuī",
    数米量柴: "shǔ mǐ liáng chái",
    数理逻辑: "shù lǐ luó ji",
    数黑论黄: "shǔ hēi lùn huáng",
    数白论黄: "shǔ bái lùn huáng",
    束缊还妇: "shù yūn huán fù",
    束蒲为脯: "shù pú wéi pú",
    束椽为柱: "shù chuán wéi zhù",
    书缺有间: "shū quē yǒu jiàn",
    手足重茧: "shǒu zú chóng jiǎn",
    手足异处: "shǒu zú yì chǔ",
    手脚干净: "shǒu jiǎo gàn jìng",
    手不应心: "shǒu bù yīng xīn",
    螫手解腕: "shì shǒu jiě wàn",
    释知遗形: "shì zhī yí xíng",
    适时应务: "shì shí yīng wù",
    适情率意: "shì qíng shuài yì",
    适当其冲: "shì dāng qí chōng",
    视为知己: "shì wéi zhī jǐ",
    使羊将狼: "shǐ yáng jiàng láng",
    食为民天: "shí wéi mín tiān",
    拾掇无遗: "shí duō wú yí",
    实与有力: "shí yù yǒu lì",
    石英玻璃: "shí yīng bō li",
    石室金匮: "shí shì jīn guì",
    什袭珍藏: "shí xí zhēn cáng",
    什伍东西: "shí wǔ dōng xī",
    什围伍攻: "shí wéi wǔ gōng",
    十魔九难: "shí mó jiǔ nàn",
    诗书发冢: "shī shū fà zhǒng",
    虱处裈中: "shī chǔ kūn zhōng",
    师直为壮: "shī zhí wéi zhuàng",
    尸居龙见: "shī jū lóng xiàn",
    圣经贤传: "shèng jīng xián zhuàn",
    圣君贤相: "shèng jūn xián xiàng",
    生拖死拽: "shēng tuō sǐ zhuài",
    审己度人: "shěn jǐ duó rén",
    神武挂冠: "shén wǔ guà guàn",
    神龙失埶: "shén lóng shī shì",
    深文曲折: "shēn wén qǔ shé",
    深厉浅揭: "shēn lì qiǎn qì",
    深谷为陵: "shēn gǔ wéi líng",
    深恶痛疾: "shēn wù tòng jí",
    深仇宿怨: "shēn chóu xiǔ yuàn",
    舍己为公: "shě jǐ wèi gōng",
    舍短取长: "shě duǎn qǔ cháng",
    舍策追羊: "shě cè zhuī yáng",
    蛇蝎为心: "shé xiē wéi xīn",
    少成若性: "shào chéng ruò xìng",
    上当学乖: "shàng dàng xué guāi",
    赏不当功: "shǎng bù dāng gōng",
    善自为谋: "shàn zì wéi móu",
    善为说辞: "shàn wéi shuō cí",
    善善恶恶: "shàn shàn wù è",
    善财难舍: "shàn cái nán shě",
    苫眼铺眉: "shān yǎn pū méi",
    讪牙闲嗑: "shàn yá xián kē",
    山阴乘兴: "shān yīn chéng xīng",
    山殽野湋: "shān yáo yě wéi",
    山溜穿石: "shān liù chuān shí",
    山节藻棁: "shān jié zǎo zhuō",
    杀鸡为黍: "shā jī wéi shǔ",
    色厉胆薄: "sè lì dǎn bó",
    桑荫未移: "sāng yīn wèi yí",
    桑荫不徙: "sāng yīn bù xǐ",
    桑土绸缪: "sāng tǔ chóu miù",
    桑户棬枢: "sāng hù juàn shū",
    三战三北: "sān zhàn sān běi",
    三瓦两舍: "sān wǎ liǎng shě",
    三人为众: "sān rén wèi zhòng",
    三差两错: "sān chā liǎng cuò",
    塞井焚舍: "sāi jǐng fén shě",
    洒心更始: "sǎ xīn gèng shǐ",
    洒扫应对: "sǎ sǎo yìng duì",
    软红香土: "ruǎn hóng xiāng tǔ",
    入吾彀中: "rù wú gòu zhōng",
    入铁主簿: "rù tiě zhǔ bù",
    入理切情: "rù lǐ qiē qíng",
    汝成人耶: "rǔ chéng rén yé",
    如水投石: "rú shuǐ tóu shí",
    如切如磋: "rú qiē rú cuō",
    如登春台: "rú dēng chūn tái",
    肉薄骨并: "ròu bó gǔ bìng",
    柔情绰态: "róu qíng chuò tài",
    戎马劻勷: "róng mǎ kuāng ráng",
    日中为市: "rì zhōng wéi shì",
    日月参辰: "rì yuè shēn chén",
    日省月修: "rì xǐng yuè xiū",
    日削月割: "rì xuē yuè gē",
    日省月试: "rì xǐng yuè shì",
    任达不拘: "rèn dá bù jū",
    人言藉藉: "rén yán jí jí",
    人模狗样: "rén mú gǒu yàng",
    人莫予毒: "rén mò yú dú",
    热熬翻饼: "rè áo fān bǐng",
    圈牢养物: "juàn láo yǎng wù",
    取予有节: "qǔ yǔ yǒu jié",
    诎要桡腘: "qū yāo ráo guó",
    穷形尽相: "qióng xíng jìn xiàng",
    情凄意切: "qíng qī yì qiè",
    情见势屈: "qíng xiàn shì qū",
    情见乎辞: "qíng xiàn hū cí",
    清都绛阙: "qīng dōu jiàng què",
    倾肠倒肚: "qīng cháng dào dǔ",
    青紫被体: "qīng zǐ pī tǐ",
    青林黑塞: "qīng lín hēi sài",
    螓首蛾眉: "qín shǒu é méi",
    琴瑟之好: "qín sè zhī hào",
    且住为佳: "qiě zhù wéi jiā",
    切树倒根: "qiē shù dǎo gēn",
    切理餍心: "qiē lǐ yàn xīn",
    切近的当: "qiē jìn de dāng",
    翘足引领: "qiáo zú yǐn lǐng",
    巧发奇中: "qiǎo fā qí zhòng",
    强嘴拗舌: "jiàng zuǐ niù shé",
    强直自遂: "qiáng zhí zì suí",
    强死强活: "qiǎng sǐ qiǎng huó",
    强食自爱: "qiǎng shí zì ài",
    强食靡角: "qiǎng shí mí jiǎo",
    强弓劲弩: "qiáng gōng jìng nǔ",
    强聒不舍: "qiǎng guō bù shě",
    强凫变鹤: "qiáng fú biàn hè",
    强而后可: "qiǎng ér hòu kě",
    强得易贫: "qiǎng dé yì pín",
    遣兴陶情: "qiǎn xìng táo qíng",
    牵羊担酒: "qiān yáng dān jiǔ",
    千了百当: "qiān liǎo bǎi dàng",
    泣下如雨: "qì xià rú yǔ",
    起偃为竖: "qǐ yǎn wéi shù",
    岂弟君子: "kǎi tì jūn zǐ",
    綦溪利跂: "qí xī lì qí",
    棋输先著: "qí shū xiān zhuó",
    齐王舍牛: "qí wáng shě niú",
    欺天诳地: "qī tiān kuáng dì",
    普天率土: "pǔ tiān shuài tǔ",
    铺胸纳地: "pū xiōng nà dì",
    铺锦列绣: "pū jǐn liè xiù",
    破家为国: "pò jiā wèi guó",
    破觚为圜: "pò gū wéi yuán",
    萍飘蓬转: "píng piāo péng zhuàn",
    帡天极地: "píng tiān jí dì",
    屏声息气: "bǐng shēng xī qì",
    凭几据杖: "píng jī jù zhàng",
    贫嘴薄舌: "pín zuǐ bó shé",
    片语只辞: "piàn yǔ zhī cí",
    披发文身: "pī fà wén shēn",
    烹龙炮凤: "pēng lóng páo fèng",
    炰鳖脍鲤: "fǒu biē kuài lǐ",
    庞眉皓发: "páng méi hào fà",
    攀花折柳: "pān huā zhé liǔ",
    攀蟾折桂: "pān chán shé guì",
    女大难留: "nǚ dà nán liú",
    弄玉吹箫: "nòng yù chuī xiāo",
    弄管调弦: "nòng guǎn tiáo xián",
    弄粉调朱: "nòng fěn diào zhū",
    浓抹淡妆: "nóng mò dàn zhuāng",
    捻土为香: "niǎn tǔ wéi xiāng",
    年谊世好: "nián yì shì hǎo",
    年华垂暮: "nián huá chuí mù",
    儗不于伦: "nǐ bù yú lún",
    泥而不滓: "ní ér bù zǐ",
    能者为师: "néng zhě wéi shī",
    能不称官: "néng bú chèn guān",
    挠直为曲: "náo zhí wéi qū",
    难进易退: "nán jìn yì tuì",
    难得糊涂: "nán dé hú tú",
    南蛮鴂舌: "nán mán jué shé",
    南贩北贾: "nán fàn běi gǔ",
    牧猪奴戏: "mù zhū nú xì",
    目眢心忳: "mù yuān xīn tún",
    目挑心招: "mù tiǎo xīn zhāo",
    目量意营: "mù liàng yì yíng",
    木头木脑: "mù tóu mù nǎo",
    木干鸟栖: "mù gàn niǎo qī",
    侔色揣称: "móu sè chuǎi chèn",
    莫予毒也: "mò yú dú yě",
    抹粉施脂: "mò fěn shī zhī",
    磨砻镌切: "mó lóng juān qiē",
    磨棱刓角: "mó léng wán jiǎo",
    摸门不着: "mō mén bù zháo",
    摸不着边: "mō bù zhuó biān",
    命中注定: "mìng zhōng zhù dìng",
    鸣鹤之应: "míng hè zhī yìng",
    明效大验: "míng xiào dà yàn",
    名我固当: "míng wǒ gù dāng",
    邈处欿视: "miǎo chǔ kǎn shì",
    黾穴鸲巢: "měng xué qú cháo",
    绵里薄材: "mián lǐ bó cái",
    靡有孑遗: "mǐ yǒu jié yí",
    靡衣偷食: "mǐ yī tōu shí",
    迷恋骸骨: "mí liàn hái gǔ",
    扪参历井: "mén shēn lì jǐng",
    门单户薄: "mén dān hù bó",
    昧旦晨兴: "mèi dàn chén xīng",
    冒名接脚: "mào míng jiē jiǎo",
    毛遂堕井: "máo suí duò jǐng",
    毛发倒竖: "máo fā dǎo shù",
    卖文为生: "mài wén wéi shēng",
    卖李钻核: "mài lǐ zuān hé",
    买椟还珠: "mǎi dú huán zhū",
    埋三怨四: "mán sān yuàn sì",
    马入华山: "mǎ rù huá shān",
    落魄江湖: "luò pò jiāng hú",
    落落难合: "luò luò nán hé",
    落草为寇: "luò cǎo wéi kòu",
    罗织构陷: "luó zhī gòu xiàn",
    鸾凤和鸣: "luán fèng hè míng",
    率由旧章: "shuài yóu jiù zhāng",
    率土同庆: "shuài tǔ tóng qìng",
    率兽食人: "shuài shòu shí rén",
    率土归心: "shuài tǔ guī xīn",
    率马以骥: "shuài mǎ yǐ jì",
    率尔成章: "shuài ěr chéng zhāng",
    鲁斤燕削: "lǔ jīn yàn xuē",
    漏尽更阑: "lòu jìn gēng lán",
    笼鸟槛猿: "lóng niǎo jiàn yuán",
    笼鸟池鱼: "lóng niǎo chí yú",
    龙游曲沼: "lóng yóu qū zhǎo",
    龙血玄黄: "lóng xuè xuán huáng",
    龙雕凤咀: "lóng diāo fèng jǔ",
    六尺之讬: "liù chǐ zhī tuō",
    令原之戚: "líng yuán zhī qī",
    令人捧腹: "lìng rén pěng fù",
    陵劲淬砺: "líng jìng cuì lì",
    临敌易将: "lín dí yì jiàng",
    裂裳衣疮: "liè shang yī chuāng",
    裂冠毁冕: "liè guàn huǐ miǎn",
    了无惧色: "liǎo wú jù sè",
    了身达命: "liǎo shēn dá mìng",
    了然无闻: "liǎo rán wú wén",
    了不可见: "liǎo bù kě jiàn",
    了不长进: "liǎo bù zhǎng jìn",
    燎发摧枯: "liǎo fà cuī kū",
    审时度势: "shěn shí duó shì",
    量小力微: "liàng xiǎo lì wēi",
    相时度力: "xiāng shí duó lì",
    量枘制凿: "liàng ruì zhì záo",
    量如江海: "liàng rú jiāng hǎi",
    量金买赋: "liàng jīn mǎi fù",
    量己审分: "liàng jǐ shěn fēn",
    敛骨吹魂: "liǎn gǔ chuī hún",
    詈夷为跖: "lì yí wéi zhí",
    利令志惛: "lì lìng zhì hūn",
    李广不侯: "lǐ guǎng bú hòu",
    礼为情貌: "lǐ wéi qíng mào",
    礼让为国: "lǐ ràng wéi guó",
    犁生骍角: "lí shēng xīng jiǎo",
    离本徼末: "lí běn jiǎo mò",
    楞眉横眼: "léng méi hèng yǎn",
    擂天倒地: "léi tiān dǎo dì",
    累足成步: "lěi zú chéng bù",
    累瓦结绳: "lěi wǎ jié shéng",
    累土至山: "lěi tǔ zhì shān",
    累土聚沙: "lěi tǔ jù shā",
    累卵之危: "lěi luǎn zhī wēi",
    累累如珠: "lěi lěi rú zhū",
    累块积苏: "lěi kuài jī sū",
    乐山乐水: "lè shān lè shuǐ",
    潦原浸天: "lǎo yuán jìn tiān",
    老师宿儒: "lǎo shī xiǔ rú",
    牢什古子: "láo shí gǔ zi",
    琅嬛福地: "láng huán fú dì",
    揆情度理: "kuí qíng duó lǐ",
    旷日累时: "kuàng rì lěi shí",
    匡救弥缝: "kuāng jiù mí fèng",
    枯树生华: "kū shù shēng huā",
    口轻舌薄: "kǒu qīng shé bó",
    口角生风: "kǒu jiǎo shēng fēng",
    口角春风: "kǒu jiǎo chūn fēng",
    口角风情: "kǒu jiǎo fēng qíng",
    口干舌焦: "kǒu gān shé jiāo",
    口腹之累: "kǒu fù zhī lěi",
    空腹便便: "kōng fù pián pián",
    嗑牙料嘴: "kē yá liào zuǐ",
    刻木为鹄: "kè mù wéi hú",
    咳珠唾玉: "ké zhū tuò yù",
    咳唾成珠: "ké tuò chéng zhū",
    抗颜为师: "kàng yán wéi shī",
    开华结果: "kāi huā jié guǒ",
    峻阪盐车: "jùn bǎn yán chē",
    嚼铁咀金: "jiáo tiě jǔ jīn",
    嚼墨喷纸: "jué mò pēn zhǐ",
    倔头强脑: "juè tóu jiàng nǎo",
    倔头倔脑: "juè tóu juè nǎo",
    倦鸟知还: "juàn niǎo zhī huán",
    卷席而葬: "juǎn xí ér zàng",
    卷甲倍道: "juǎn jiǎ bèi dào",
    聚米为山: "jù mǐ wéi shān",
    举手相庆: "jǔ shǒu xiāng qìng",
    举世混浊: "jǔ shì hún zhuó",
    鞠为茂草: "jū wéi mào cǎo",
    拘神遣将: "jū shén qiǎn jiàng",
    居下讪上: "jū xià shàn shàng",
    久要不忘: "jiǔ yāo bú wàng",
    九转功成: "jiǔ zhuǎn gōng chéng",
    九蒸三熯: "jiǔ zhēng sān hàn",
    敬业乐群: "jìng yè lè qún",
    井底虾蟆: "jǐng dǐ xiā má",
    旌旗卷舒: "jīng qí juǎn shū",
    荆棘载途: "jīng jí zài tú",
    禁舍开塞: "jìn shě kāi sāi",
    祲威盛容: "jìn wēi shèng róng",
    进退消长: "jìn tuì xiāo cháng",
    进退应矩: "jìn tuì yīng jǔ",
    进退触籓: "jìn tuì chù fān",
    进退跋疐: "jìn tuì bá zhì",
    尽多尽少: "jǐn duō jǐn shǎo",
    锦囊还矢: "jǐn náng huán shǐ",
    矜己自饰: "jīn jǐ zì shì",
    矜功负气: "jīn gōng fù qì",
    津关险塞: "jīn guān xiǎn sài",
    金吾不禁: "jīn wú bú jìn",
    金翅擘海: "jīn chì bāi hǎi",
    解衣衣人: "jiě yī yī rén",
    解人难得: "jiě rén nán dé",
    解铃系铃: "jiě líng xì líng",
    解发佯狂: "jiě fà yáng kuáng",
    诘屈磝碻: "jié qū áo qiāo",
    教猱升木: "jiāo náo shēng mù",
    较瘦量肥: "jiào shòu liàng féi",
    角立杰出: "jiǎo lì jié chū",
    焦沙烂石: "jiāo shā làn shí",
    骄儿騃女: "jiāo ér sì nǚ",
    浇风薄俗: "jiāo fēng bó sú",
    降妖捉怪: "xiáng yāo zhuō guài",
    将取固予: "jiāng qǔ gù yǔ",
    将门有将: "jiàng mén yǒu jiàng",
    将夺固与: "jiāng duó gù yǔ",
    槛花笼鹤: "jiàn huā lóng hè",
    鉴影度形: "jiàn yǐng duó xíng",
    渐不可长: "jiàn bù kě zhǎng",
    见素抱朴: "xiàn sù bào pǔ",
    见弃于人: "jiàn qì yú rén",
    简丝数米: "jiǎn sī shǔ mǐ",
    俭不中礼: "jiǎn bú zhòng lǐ",
    间见层出: "jiàn xiàn céng chū",
    尖嘴薄舌: "jiān zuǐ bó shé",
    甲冠天下: "jiǎ guàn tiān xià",
    葭莩之亲: "jiā fú zhī qīn",
    家累千金: "jiā lèi qiān jīn",
    家给人足: "jiā jǐ rén zú",
    家道从容: "jiā dào cóng róng",
    夹袋人物: "jiā dài rén wù",
    霁风朗月: "jì fēng lǎng yuè",
    寄兴寓情: "jì xìng yù qíng",
    计深虑远: "jì shēn lǜ yuǎn",
    计功量罪: "jì gōng liàng zuì",
    掎裳连襼: "jǐ shang lián yì",
    虮虱相吊: "jǐ shī xiāng diào",
    疾不可为: "jí bù kě wéi",
    极深研几: "jí shēn yán jī",
    及宾有鱼: "jí bīn yǒu yú",
    激薄停浇: "jī bó tíng jiāo",
    积素累旧: "jī sù lěi jiù",
    积时累日: "jī shí lěi rì",
    积露为波: "jī lù wéi bō",
    积德累功: "jī dé lěi gōng",
    积谗糜骨: "jī chán méi gǔ",
    击排冒没: "jī pái mào mò",
    祸为福先: "huò wéi fú xiān",
    祸福相依: "huò fú xiāng yī",
    获隽公车: "huò jùn gōng chē",
    混应滥应: "hùn yīng làn yīng",
    毁舟为杕: "huǐ zhōu wéi duò",
    毁钟为铎: "huǐ zhōng wéi duó",
    毁冠裂裳: "huǐ guān liè cháng",
    晦盲否塞: "huì máng pǐ sè",
    回船转舵: "huí chuán zhuàn duò",
    潢池盗弄: "huáng chí dào nòng",
    黄冠草履: "huáng guàn cǎo lǚ",
    黄发儿齿: "huáng fà ér chǐ",
    黄发垂髫: "huáng fà chuí tiáo",
    还珠返璧: "huán zhū fǎn bì",
    还年驻色: "huán nián zhù sè",
    还年却老: "huán nián què lǎo",
    坏裳为裤: "huài shang wéi kù",
    画荻和丸: "huà dí huò wán",
    化枭为鸠: "huà xiāo wéi jiū",
    化腐为奇: "huà fǔ wéi qí",
    化鸱为凤: "huà chī wéi fèng",
    花不棱登: "huā bu lēng dēng",
    户限为穿: "hù xiàn wéi chuān",
    呼卢喝雉: "hū lú hè zhì",
    呼来喝去: "hū lái hè qù",
    呼不给吸: "hū bù jǐ xī",
    厚味腊毒: "hòu wèi xī dú",
    厚德载物: "hòu dé zài wù",
    鸿渐于干: "hóng jiàn yú gàn",
    洪炉燎发: "hóng lú liáo fà",
    红绳系足: "hóng shéng jì zú",
    红不棱登: "hóng bu lēng dēng",
    横抢硬夺: "hèng qiǎng yìng duó",
    横恩滥赏: "hèng ēn làn shǎng",
    恨海难填: "hèn hǎi nán tián",
    鹤发鸡皮: "hè fà jī pí",
    涸思干虑: "hé sī gān lǜ",
    河涸海干: "hé hé hǎi gān",
    和颜说色: "hé yán yuè sè",
    合从连衡: "hé zòng lián héng",
    浩浩汤汤: "hào hào shāng shāng",
    好勇斗狠: "hào yǒng dòu hěn",
    好问则裕: "hào wèn zé yù",
    好为事端: "hào wéi shì duān",
    好问决疑: "hào wèn jué yí",
    好生之德: "hào shēng zhī dé",
    好奇尚异: "hǎo qí shàng yì",
    好恶不同: "hǎo è bù tóng",
    好丹非素: "hào dān fēi sù",
    豪干暴取: "háo gàn bào qǔ",
    毫发不爽: "háo fà bù shuǎng",
    寒酸落魄: "hán suān luò pò",
    含英咀华: "hán yīng jǔ huá",
    含糊不明: "hán hú bù míng",
    过为已甚: "guò wéi yǐ shèn",
    桂折兰摧: "guì shé lán cuī",
    规旋矩折: "guī xuán jǔ shé",
    广文先生: "guǎng wén xiān sheng",
    广陵散绝: "guǎng líng sǎn jué",
    冠山戴粒: "guàn shān dài lì",
    冠屦倒施: "guàn jù dǎo shī",
    挂席为门: "guà xí wéi mén",
    寡见鲜闻: "guǎ jiàn xiǎn wén",
    瓜葛相连: "guā gé xiāng lián",
    鼓吻奋爪: "gǔ wěn fèn zhǎo",
    古调单弹: "gǔ diào dān tán",
    古调不弹: "gǔ diào bù tán",
    姑射神人: "gū yè shén rén",
    苟合取容: "gǒu hé qǔ róng",
    狗续侯冠: "gǒu xù hòu guàn",
    钩爪锯牙: "gōu zhǎo jù yá",
    共枝别干: "gòng zhī bié gàn",
    共为唇齿: "gòng wéi chún chǐ",
    拱手而降: "gǒng shǒu ér xiáng",
    拱肩缩背: "gǒng jiān suō bèi",
    功薄蝉翼: "gōng bó chán yì",
    弓调马服: "gōng diào mǎ fú",
    更姓改物: "gēng xìng gǎi wù",
    更仆难数: "gēng pú nán shǔ",
    更令明号: "gēng lìng míng hào",
    更待干罢: "gèng dài gàn bà",
    更唱迭和: "gēng chàng dié hé",
    更长梦短: "gēng cháng mèng duǎn",
    各色名样: "gè sè míng yàng",
    格格不纳: "gé gé bú nà",
    格格不吐: "gé gé bù tǔ",
    告朔饩羊: "gù shuò xì yáng",
    膏车秣马: "gào chē mò mǎ",
    高义薄云: "gāo yì bó yún",
    岗头泽底: "gāng tóu zé dǐ",
    敢为敢做: "gǎn wéi gǎn zuò",
    甘分随时: "gān fèn suí shí",
    甘处下流: "gān chǔ xià liú",
    干啼湿哭: "gàn tí shī kū",
    干名犯义: "gàn míng fàn yì",
    干将莫邪: "gān jiāng mò yé",
    干城之将: "gān chéng zhī jiàng",
    腹载五车: "fù zài wǔ chē",
    父债子还: "fù zhài zǐ huán",
    父为子隐: "fù wéi zǐ yǐn",
    辅世长民: "fǔ shì zhǎng mín",
    福为祸始: "fú wéi huò shǐ",
    符号逻辑: "fú hào luó jí",
    浮收勒折: "fú shōu lè shé",
    肤受之愬: "fū shòu zhī sù",
    否终则泰: "pǐ zhōng zé tài",
    佛头著粪: "fó tóu zhuó fèn",
    奉为楷模: "fèng wéi kǎi mó",
    凤靡鸾吪: "fèng mǐ luán é",
    封豨修蛇: "fēng xī xiū shé",
    风影敷衍: "fēng yǐng fū yǎn",
    丰屋蔀家: "fēng wū bù jiā",
    粪土不如: "fèn tǔ bù rú",
    分风劈流: "fēn fēng pǐ liú",
    沸沸汤汤: "fèi fèi shāng shāng",
    菲食薄衣: "fěi shí bó yī",
    飞将数奇: "fēi jiàng shù qí",
    放辟邪侈: "fàng pì xié chǐ",
    方领圆冠: "fāng lǐng yuán guàn",
    犯而不校: "fàn ér bú jiào",
    返本还源: "fǎn běn huán yuán",
    反劳为逸: "fǎn láo wéi yì",
    法轮常转: "fǎ lún cháng zhuàn",
    罚不当罪: "fá bù dāng zuì",
    发引千钧: "fà yǐn qiān jūn",
    发奸擿伏: "fā jiān tī fú",
    发短心长: "fà duǎn xīn cháng",
    二竖为虐: "èr shù wéi nüè",
    儿女心肠: "ér nǚ xīn cháng",
    儿女亲家: "ér nǚ qìng jiā",
    遏恶扬善: "è wù yáng shàn",
    饿殍枕藉: "è piǎo zhěn jí",
    饿殍载道: "è piǎo zài dào",
    恶醉强酒: "wù zuì qiǎng jiǔ",
    恶意中伤: "è yì zhòng shāng",
    恶湿居下: "wù shī jū xià",
    恶居下流: "wù jū xià liú",
    恶不去善: "wù bú qù shàn",
    扼吭夺食: "è háng duó shí",
    扼襟控咽: "è jīn kòng yān",
    峨峨汤汤: "é é shāng shāng",
    屙金溺银: "ē jīn niào yín",
    朵颐大嚼: "duǒ yí dà jiáo",
    夺人所好: "duó rén suǒ hào",
    多言数穷: "duō yán shuò qióng",
    多文为富: "duō wén wéi fù",
    多端寡要: "duō duān guǎ yào",
    多财善贾: "duō cái shàn gǔ",
    遁世无闷: "dùn shì wú mèn",
    遁迹黄冠: "dùn jì huáng guàn",
    堆案盈几: "duī àn yíng jī",
    断还归宗: "duàn huán guī zōng",
    短见薄识: "duǎn jiàn bó shí",
    蠹居棊处: "dù jū qí chǔ",
    度己以绳: "duó jǐ yǐ shéng",
    杜默为诗: "dù mò wéi shī",
    杜鹃啼血: "dù juān tí xuè",
    笃近举远: "dǔ jìn jǔ yuǎn",
    独有千秋: "dú yǒu qiān qiū",
    读书得间: "dú shū dé jiàn",
    斗转参横: "dǒu zhuǎn shēn héng",
    兜肚连肠: "dōu dǔ lián cháng",
    洞见症结: "dòng jiàn zhèng jié",
    恫疑虚喝: "dòng yí xū hè",
    动中窾要: "dòng zhōng kuǎn yào",
    东鸣西应: "dōng míng xī yīng",
    东鳞西爪: "dōng lín xī zhǎo",
    东量西折: "dōng liàng xī shé",
    东家西舍: "dōng jiā xī shè",
    东扯西拽: "dōng chě xī zhuāi",
    鼎铛有耳: "dǐng chēng yǒu ěr",
    鼎铛玉石: "dǐng chēng yù shí",
    钉头磷磷: "dīng tóu lín lín",
    跌宕不羁: "diē dàng bù jī",
    跌弹斑鸠: "diē dàn bān jiū",
    雕心雁爪: "diāo xīn yàn zhǎo",
    颠倒衣裳: "diān dǎo yī cháng",
    德薄能鲜: "dé bó néng xiǎn",
    得马折足: "dé mǎ shé zú",
    蹈其覆辙: "dǎo qí fù zhé",
    捣虚撇抗: "dǎo xū piē kàng",
    倒载干戈: "dào zài gān gē",
    倒裳索领: "dào cháng suǒ lǐng",
    倒果为因: "dào guǒ wéi yīn",
    叨在知己: "tāo zài zhī jǐ",
    叨陪末座: "tāo péi mò zuò",
    党豺为虐: "dǎng chái wéi nüè",
    当轴处中: "dāng zhóu chǔ zhōng",
    当着不着: "dāng zhuó bù zhuó",
    当务始终: "dāng wù shǐ zhōng",
    淡汝浓抹: "dàn rǔ nóng mǒ",
    弹丸脱手: "tán wán tuō shǒu",
    弹铗无鱼: "dàn jiá wú yú",
    箪食瓢饮: "dān sì piáo yǐn",
    大璞不完: "dà pú bù wán",
    大明法度: "dà míng fǎ dù",
    大车以载: "dà chē yǐ zài",
    打闷葫芦: "dǎ mèn hú lu",
    沓来踵至: "tà lái zhǒng zhì",
    厝火燎原: "cuò huǒ liǎo yuán",
    撮科打哄: "cuō kē dǎ hòng",
    寸积铢累: "cùn jī zhū lěi",
    啛啛喳喳: "cuì cuì chā chā",
    摧折豪强: "cuī zhé háo qiáng",
    摧刚为柔: "cuī gāng wéi róu",
    从俗就简: "cóng sú jiù jiǎn",
    此发彼应: "cǐ fā bǐ yīng",
    此唱彼和: "cǐ chàng bǐ hè",
    慈悲为本: "cí bēi wéi běn",
    纯属骗局: "chún shǔ piàn jú",
    春笋怒发: "chūn sǔn nù fā",
    垂头搨翼: "chuí tóu tà yì",
    传为笑谈: "chuán wéi xiào tán",
    传风扇火: "chuán fēng shān huǒ",
    穿红着绿: "chuān hóng zhuó lǜ",
    触处机来: "chù chǔ jī lái",
    处尊居显: "chǔ zūn jū xiǎn",
    处堂燕雀: "chǔ táng yàn què",
    处实效功: "chǔ shí xiào gōng",
    处高临深: "chǔ gāo lín shēn",
    出入无间: "chū rù wú jiān",
    出门应辙: "chū mén yīng zhé",
    出处语默: "chū chǔ yǔ mò",
    出处殊途: "chū chǔ shū tú",
    出处进退: "chū chǔ jìn tuì",
    愁山闷海: "chóu shān mèn hǎi",
    冲冠眦裂: "chōng guàn zì liè",
    齿牙为祸: "chǐ yá wéi huò",
    尺二冤家: "chǐ èr yuān jia",
    尺短寸长: "chǐ duǎn cùn cháng",
    尺寸之功: "chǐ cùn zhī gōng",
    城北徐公: "chéng běi xú gōng",
    成败兴废: "chéng bài xīng fèi",
    趁水和泥: "chèn shuǐ huò ní",
    称雨道晴: "chēng yǔ dào qíng",
    称体载衣: "chēng tǐ zài yī",
    称体裁衣: "chèn tǐ cái yī",
    称家有无: "chèn jiā yǒu wú",
    称德度功: "chēng dé duó gōng",
    沉吟章句: "chén yín zhāng jù",
    沉吟不决: "chén yín bù jué",
    沉疴宿疾: "chén kē sù jí",
    扯纤拉烟: "chě qiàn lā yān",
    扯顺风旗: "chě shùn fēng qí",
    车载船装: "chē zǎi chuán zhuāng",
    朝升暮合: "zhāo shēng mù gě",
    朝攀暮折: "zhāo pān mù shé",
    超今冠古: "chāo jīn guàn gǔ",
    倡而不和: "chàng ér bú hè",
    畅所欲为: "chàng suǒ yù wéi",
    苌弘碧血: "cháng hóng bì xiě",
    长幼尊卑: "zhǎng yòu zūn bēi",
    长绳系日: "cháng shéng jì rì",
    长年三老: "zhǎng nián sān lǎo",
    长春不老: "cháng chūn bù lǎo",
    长傲饰非: "zhǎng ào shì fēi",
    昌亭旅食: "chāng tíng lǚ shí",
    禅絮沾泥: "chán xù zhān ní",
    差三错四: "chā sān cuò sì",
    层台累榭: "céng tái lěi xiè",
    层见迭出: "céng xiàn dié chū",
    藏踪蹑迹: "cáng zōng niè jì",
    苍蝇见血: "cāng yíng jiàn xiě",
    餐松啖柏: "cān sōng dàn bó",
    骖风驷霞: "cān fēng sì xiá",
    参伍错综: "cēn wǔ cuò zōng",
    参辰卯酉: "shēn chén mǎo yǒu",
    材优干济: "cái yōu gān jǐ",
    材薄质衰: "cái bó zhì shuāi",
    才大难用: "cái dà nán yòng",
    才薄智浅: "cái bó zhì qiǎn",
    不足为意: "bù zú wéi yì",
    不足为据: "bù zú wéi jù",
    不足为法: "bù zú wéi fǎ",
    不足齿数: "bù zú chǐ shǔ",
    不着疼热: "bù zhuó téng rè",
    不知薡蕫: "bù zhī dǐng dǒng",
    不越雷池: "bú yuè léi chí",
    不相为谋: "bù xiāng wéi móu",
    不贪为宝: "bù tān wéi bǎo",
    不了而了: "bù liǎo ér liǎo",
    不可揆度: "bù kě kuí duó",
    不遑启处: "bù huáng qǐ chǔ",
    不当不正: "bù dāng bú zhèng",
    不差什么: "bú chà shén me",
    不差累黍: "bù chā lěi shǔ",
    擘两分星: "bò liǎng fēn xīng",
    簸土扬沙: "bǒ tǔ yáng shā",
    薄物细故: "bó wù xì gù",
    薄寒中人: "bó hán zhòng rén",
    博文约礼: "bó wén yuē lǐ",
    播糠眯目: "bō kāng mí mù",
    剥皮抽筋: "bō pí chōu jīn",
    剥肤椎髓: "bō fū chuí suǐ",
    波属云委: "bō zhǔ yún wěi",
    波骇云属: "bō hài yún zhǔ",
    兵微将寡: "bīng wēi jiàng guǎ",
    兵强将勇: "bīng qiáng jiàng yǒng",
    兵多将广: "bīng duō jiàng guǎng",
    兵不由将: "bīng bù yóu jiàng",
    冰解的破: "bīng jiě dì pò",
    彬彬济济: "bīn bīn jǐ jǐ",
    摽梅之年: "biào méi zhī nián",
    表里为奸: "biǎo lǐ wéi jiān",
    飙发电举: "biāo fā diàn jǔ",
    变贪厉薄: "biàn tān lì bó",
    敝盖不弃: "bì gài bú qì",
    秕言谬说: "bǐ yán miù shuō",
    比物属事: "bǐ wù zhǔ shì",
    被山带河: "pī shān dài hé",
    被甲枕戈: "pī jiǎ zhěn gē",
    被甲据鞍: "pī jiǎ jù ān",
    被褐怀玉: "pī hè huái yù",
    被发缨冠: "pī fà yīng guàn",
    背曲腰躬: "bèi qǔ yāo gōng",
    北窗高卧: "běi chuāng gāo wò",
    北辰星拱: "běi chén xīng gǒng",
    北鄙之音: "běi bǐ zhī yīn",
    卑宫菲食: "bēi gōng fěi shí",
    暴衣露冠: "pù yī lù guàn",
    暴腮龙门: "pù sāi lóng mén",
    暴露文学: "bào lù wén xué",
    暴虎冯河: "bào hǔ píng hé",
    抱蔓摘瓜: "bào wàn zhāi guā",
    抱法处势: "bào fǎ chǔ shì",
    褒贬与夺: "bāo biǎn yǔ duó",
    帮闲钻懒: "bāng xián zuān lǎn",
    拜将封侯: "bài jiàng fēng hóu",
    百兽率舞: "bǎi shòu shuài wǔ",
    百孔千创: "bǎi kǒng qiān chuāng",
    白衣卿相: "bái yī qīng xiàng",
    白首为郎: "bái shǒu wéi láng",
    白首相知: "bái shǒu xiāng zhī",
    把玩无厌: "bǎ wán wú yàn",
    拔锅卷席: "bá guō juǎn xí",
    拔本塞源: "bá běn sè yuán",
    傲不可长: "ào bù kě zhǎng",
    熬更守夜: "áo gēng shǒu yè",
    安时处顺: "ān shí chǔ shùn",
    安身为乐: "ān shēn wéi lè",
    安老怀少: "ān lǎo huái shào",
    安步当车: "ān bù dàng chē",
    爱人好士: "ài rén hào shì",
    矮人观场: "ǎi rén guān chǎng",
    捱风缉缝: "ái fēng jī fèng",
    挨山塞海: "āi shān sè hǎi",
    阿家阿翁: "ā jiā ā wēng",
    阿党相为: "ē dǎng xiāng wéi",
    追亡逐北: "zhuī wáng zhú běi",
    竹篮打水: "zhú lán dá shuǐ",
    知疼着热: "zhī téng zháo rè",
    语不惊人: "yǔ bù jīng rén",
    于今为烈: "yú jīn wéi liè",
    一日三省: "yí rì sān xǐng",
    穴居野处: "xué jū yě chǔ",
    五脊六兽: "wǔ jǐ liù shòu",
    无声无臭: "wú shēng wú xiù",
    谓予不信: "wèi yú bú xìn",
    舍身为国: "shě shēn wéi guó",
    杀妻求将: "shā qī qiú jiàng",
    强作解人: "qiǎng zuò jiě rén",
    气冲斗牛: "qì chōng dǒu niú",
    临深履薄: "lín shēn lǚ bó",
    钧天广乐: "jūn tiān guǎng yuè",
    艰难竭蹶: "jiān nán jié jué",
    夹七夹八: "jiā qī jiā bā",
    混混噩噩: "hún hún è è",
    厚古薄今: "hòu gǔ bó jīn",
    鬼怕恶人: "guǐ pà è rén",
    伽马射线: "gā mǎ shè xiàn",
    佛头着粪: "fó tóu zhuó fèn",
    奉为至宝: "fèng wéi zhì bǎo",
    登坛拜将: "dēng tán bài jiàng",
    晨昏定省: "chén hūn dìng xǐng",
    察察为明: "chá chá wéi míng",
    博闻强识: "bó wén qiáng zhì",
    避难就易: "bì nán jiù yì",
    了无生机: "liǎo wú shēng jī",
    // 一字不变调的词语，如果词语仅有单个一且一字在结尾的无需添加（需要增补更多）
    有一说一: "yǒu yī shuō yī",
    独一无二: "dú yī wú èr",
    说一不二: "shuō yī bù èr",
    举一反三: "jǔ yī fǎn sān",
    数一数二: "shǔ yī shǔ èr",
    杀一儆百: "shā yī jǐng bǎi",
    丁一卯二: "dīng yī mǎo èr",
    丁一确二: "dīng yī què èr",
    不一而止: "bù yī ér zhǐ",
    无一幸免: "wú yī xìng miǎn",
    // 来源：https://m.gushici.com/cyxy_4e00_4
    表里不一: "biǎo lǐ bù yī",
    良莠不一: "liáng yǒu bù yī",
    心口不一: "xīn kǒu bù yī",
    言行不一: "yán xíng bù yī",
    政令不一: "zhèng lìng bù yī",
    参差不一: "cēn cī bù yī",
    纷纷不一: "fēn fēn bù yī",
    毁誉不一: "huǐ yù bù yī",
    不一而三: "bù yī ér sān",
    百不一遇: "bǎi bù yī yù",
    言行抱一: "yán xíng bào yī",
    瑜百瑕一: "yú bǎi xiá yī",
    背城借一: "bèi chéng jiè yī",
    凭城借一: "píng chéng jiè yī",
    劝百讽一: "quàn bǎi fěng yī",
    群居和一: "qún jū hé yī",
    百不获一: "bǎi bù huò yī",
    百不失一: "bǎi bù shī yī",
    百无失一: "bǎi wú shī yī",
    万不失一: "wàn bù shī yī",
    万无失一: "wàn wú shī yī",
    合而为一: "hé ér wéi yī",
    合两为一: "hé liǎng wéi yī",
    合二为一: "hé èr wéi yī",
    天下为一: "tiān xià wéi yī",
    相与为一: "xiāng yǔ wéi yī",
    较若画一: "jiào ruò huà yī",
    较如画一: "jiào rú huà yī",
    斠若画一: "jiào ruò huà yī",
    言行若一: "yán xíng ruò yī",
    始终若一: "shǐ zhōng ruò yī",
    终始若一: "zhōng shǐ ruò yī",
    惟精惟一: "wéi jīng wéi yī",
    众多非一: "zhòng duō fēi yī",
    不能赞一: "bù néng zàn yī",
    问一答十: "wèn yī dá shí",
    一不扭众: "yī bù niǔ zhòng",
    一以贯之: "yī yǐ guàn zhī",
    一以当百: "yī yǐ dāng bǎi",
    百不当一: "bǎi bù dāng yī",
    十不当一: "shí bù dāng yī",
    以一警百: "yǐ yī jǐng bǎi",
    以一奉百: "yǐ yī fèng bǎi",
    以一持万: "yǐ yī chí wàn",
    以一知万: "yǐ yī zhī wàn",
    百里挑一: "bǎi lǐ tiāo yī",
    整齐划一: "zhěng qí huà yī",
    一来二去: "yī lái èr qù",
    一路公交: "yī lù gōng jiāo",
    一路汽车: "yī lù qì chē",
    一路巴士: "yī lù bā shì",
    朝朝朝落: "zhāo cháo zhāo luò",
    曲意逢迎: "qū yì féng yíng",
    一行不行: "yì háng bù xíng",
    行行不行: "háng háng bù xíng"
  };
  const Pattern4 = Object.keys(DICT4).map((key) => ({
    zh: key,
    pinyin: DICT4[key],
    probability: 2e-8,
    length: 4,
    priority: Priority.Normal,
    dict: Symbol("dict4")
  }));
  const DICT5 = {
    巴尔干半岛: "bā ěr gàn bàn dǎo",
    巴尔喀什湖: "bā ěr kā shí hú",
    不幸而言中: "bú xìng ér yán zhòng",
    布尔什维克: "bù ěr shí wéi kè",
    何乐而不为: "hé lè ér bù wéi",
    苛政猛于虎: "kē zhèng měng yú hǔ",
    蒙得维的亚: "méng dé wéi dì yà",
    民以食为天: "mín yǐ shí wéi tiān",
    事后诸葛亮: "shì hòu zhū gě liàng",
    物以稀为贵: "wù yǐ xī wéi guì",
    先下手为强: "xiān xià shǒu wéi qiáng",
    行行出状元: "háng háng chū zhuàng yuan",
    亚得里亚海: "yà dé lǐ yà hǎi",
    眼不见为净: "yǎn bú jiàn wéi jìng",
    竹筒倒豆子: "zhú tǒng dào dòu zi"
  };
  const Pattern5 = Object.keys(DICT5).map((key) => ({
    zh: key,
    pinyin: DICT5[key],
    probability: 2e-8,
    length: 5,
    priority: Priority.Normal,
    dict: Symbol("dict5")
  }));
  function getMaxProbability(a2, b2) {
    if (!a2) {
      return b2;
    }
    if (a2.decimal < b2.decimal) {
      return a2;
    } else if (a2.decimal === b2.decimal) {
      return a2.probability > b2.probability ? a2 : b2;
    } else {
      return b2;
    }
  }
  function checkDecimal(prob) {
    if (prob.probability < 1e-300) {
      prob.probability *= 1e300;
      prob.decimal += 1;
    }
  }
  function getPatternDecimal(pattern2) {
    if (pattern2.priority === Priority.Custom) {
      return -(pattern2.length * pattern2.length * 100);
    }
    if (pattern2.priority === Priority.Surname) {
      return -(pattern2.length * pattern2.length * 10);
    }
    return 0;
  }
  function maxProbability(patterns, length) {
    const dp = [];
    let patternIndex = patterns.length - 1;
    let pattern2 = patterns[patternIndex];
    for (let i2 = length - 1; i2 >= 0; i2--) {
      const suffixDP = i2 + 1 >= length ? { probability: 1, decimal: 0, patterns: [] } : dp[i2 + 1];
      while (pattern2 && pattern2.index + pattern2.length - 1 === i2) {
        const startIndex = pattern2.index;
        const curDP = {
          probability: pattern2.probability * suffixDP.probability,
          decimal: suffixDP.decimal + getPatternDecimal(pattern2),
          patterns: suffixDP.patterns,
          concatPattern: pattern2
        };
        checkDecimal(curDP);
        dp[startIndex] = getMaxProbability(dp[startIndex], curDP);
        pattern2 = patterns[--patternIndex];
      }
      const iDP = {
        probability: 1e-13 * suffixDP.probability,
        decimal: 0,
        patterns: suffixDP.patterns
      };
      checkDecimal(iDP);
      dp[i2] = getMaxProbability(dp[i2], iDP);
      if (dp[i2].concatPattern) {
        dp[i2].patterns = dp[i2].patterns.concat(dp[i2].concatPattern);
        dp[i2].concatPattern = void 0;
        delete dp[i2 + 1];
      }
    }
    return dp[0].patterns.reverse();
  }
  function getMinCount(a2, b2) {
    if (!a2) {
      return b2;
    }
    return a2.count <= b2.count ? a2 : b2;
  }
  function getPatternCount(pattern2) {
    if (pattern2.priority === Priority.Custom) {
      return -(pattern2.length * pattern2.length * 1e5);
    }
    if (pattern2.priority === Priority.Surname) {
      return -(pattern2.length * pattern2.length * 100);
    }
    return 1;
  }
  function minTokenization(patterns, length) {
    const dp = [];
    let patternIndex = patterns.length - 1;
    let pattern2 = patterns[patternIndex];
    for (let i2 = length - 1; i2 >= 0; i2--) {
      const suffixDP = i2 + 1 >= length ? { count: 0, patterns: [] } : dp[i2 + 1];
      while (pattern2 && pattern2.index + pattern2.length - 1 === i2) {
        const startIndex = pattern2.index;
        const curDP = {
          count: getPatternCount(pattern2) + suffixDP.count,
          patterns: suffixDP.patterns,
          concatPattern: pattern2
        };
        dp[startIndex] = getMinCount(dp[startIndex], curDP);
        pattern2 = patterns[--patternIndex];
      }
      const iDP = {
        count: 1 + suffixDP.count,
        patterns: suffixDP.patterns
      };
      dp[i2] = getMinCount(dp[i2], iDP);
      if (dp[i2].concatPattern) {
        dp[i2].patterns = dp[i2].patterns.concat(dp[i2].concatPattern);
        dp[i2].concatPattern = void 0;
        delete dp[i2 + 1];
      }
    }
    return dp[0].patterns.reverse();
  }
  function isIgnorablePattern(cur, pre) {
    if (pre.index + pre.length <= cur.index) {
      return false;
    }
    if (pre.priority > cur.priority) {
      return false;
    }
    if (pre.priority === cur.priority && pre.length > cur.length) {
      return false;
    }
    return true;
  }
  function reverseMaxMatch(patterns) {
    const filteredArr = [];
    for (let i2 = patterns.length - 1; i2 >= 0; ) {
      const { index } = patterns[i2];
      let j2 = i2 - 1;
      while (j2 >= 0 && isIgnorablePattern(patterns[i2], patterns[j2])) {
        j2--;
      }
      if (j2 < 0 || patterns[j2].index + patterns[j2].length <= index) {
        filteredArr.push(patterns[i2]);
      }
      i2 = j2;
    }
    return filteredArr.reverse();
  }
  var TokenizationAlgorithm;
  (function(TokenizationAlgorithm2) {
    TokenizationAlgorithm2[TokenizationAlgorithm2["ReverseMaxMatch"] = 1] = "ReverseMaxMatch";
    TokenizationAlgorithm2[TokenizationAlgorithm2["MaxProbability"] = 2] = "MaxProbability";
    TokenizationAlgorithm2[TokenizationAlgorithm2["MinTokenization"] = 3] = "MinTokenization";
  })(TokenizationAlgorithm || (TokenizationAlgorithm = {}));
  class TrieNode {
    constructor(parent, prefix = "", key = "") {
      this.children = /* @__PURE__ */ new Map();
      this.fail = null;
      this.patterns = [];
      this.parent = parent;
      this.prefix = prefix;
      this.key = key;
    }
  }
  class AC {
    constructor() {
      this.dictMap = /* @__PURE__ */ new Map();
      this.queues = [];
      this.root = new TrieNode(null);
    }
    build(patternList) {
      this.buildTrie(patternList);
      this.buildFailPointer();
    }
    // 构建 trie 树
    buildTrie(patternList) {
      for (let pattern2 of patternList) {
        const zhChars = splitString(pattern2.zh);
        let cur = this.root;
        for (let i2 = 0; i2 < zhChars.length; i2++) {
          let c2 = zhChars[i2];
          if (!cur.children.has(c2)) {
            const trieNode = new TrieNode(cur, zhChars.slice(0, i2).join(""), c2);
            cur.children.set(c2, trieNode);
            this.addNodeToQueues(trieNode);
          }
          cur = cur.children.get(c2);
        }
        this.insertPattern(cur.patterns, pattern2);
        pattern2.node = cur;
        this.addPatternToDictMap(pattern2);
      }
    }
    // 构建失败指针
    buildFailPointer() {
      let queue = [];
      let queueIndex = 0;
      this.queues.forEach((_queue) => {
        queue = queue.concat(_queue);
      });
      this.queues = [];
      while (queue.length > queueIndex) {
        let node = queue[queueIndex++];
        let failNode = node.parent && node.parent.fail;
        let key = node.key;
        while (failNode && !failNode.children.has(key)) {
          failNode = failNode.fail;
        }
        if (!failNode) {
          node.fail = this.root;
        } else {
          node.fail = failNode.children.get(key);
        }
      }
    }
    // 将 pattern 添加到 dictMap 中
    addPatternToDictMap(pattern2) {
      if (!this.dictMap.has(pattern2.dict)) {
        this.dictMap.set(pattern2.dict, /* @__PURE__ */ new Set());
      }
      this.dictMap.get(pattern2.dict).add(pattern2);
    }
    addNodeToQueues(trieNode) {
      if (!this.queues[stringLength(trieNode.prefix)]) {
        this.queues[stringLength(trieNode.prefix)] = [];
      }
      this.queues[stringLength(trieNode.prefix)].push(trieNode);
    }
    // 按照优先级插入 pattern
    insertPattern(patterns, pattern2) {
      for (let i2 = patterns.length - 1; i2 >= 0; i2--) {
        const _pattern = patterns[i2];
        if (pattern2.priority === _pattern.priority && pattern2.probability >= _pattern.probability) {
          patterns[i2 + 1] = _pattern;
        } else if (pattern2.priority > _pattern.priority) {
          patterns[i2 + 1] = _pattern;
        } else {
          patterns[i2 + 1] = pattern2;
          return;
        }
      }
      patterns[0] = pattern2;
    }
    removeDict(dictName) {
      if (this.dictMap.has(dictName)) {
        const set2 = this.dictMap.get(dictName);
        set2.forEach((pattern2) => {
          pattern2.node.patterns = pattern2.node.patterns.filter((_pattern) => _pattern !== pattern2);
        });
        this.dictMap.delete(dictName);
      }
    }
    // 搜索字符串返回匹配的模式串
    match(text, surname) {
      let cur = this.root;
      let result = [];
      const zhChars = splitString(text);
      for (let i2 = 0; i2 < zhChars.length; i2++) {
        let c2 = zhChars[i2];
        while (cur !== null && !cur.children.has(c2)) {
          cur = cur.fail;
        }
        if (cur === null) {
          cur = this.root;
        } else {
          cur = cur.children.get(c2);
          const pattern2 = cur.patterns.find((item) => {
            if (surname === "off") {
              return item.priority !== Priority.Surname;
            } else if (surname === "head") {
              return item.length - 1 - i2 === 0;
            } else {
              return true;
            }
          });
          if (pattern2) {
            result.push(Object.assign(Object.assign({}, pattern2), { index: i2 - pattern2.length + 1 }));
          }
          let failNode = cur.fail;
          while (failNode !== null) {
            const pattern3 = failNode.patterns.find((item) => {
              if (surname === "off") {
                return item.priority !== Priority.Surname;
              } else if (surname === "head") {
                return item.length - 1 - i2 === 0;
              } else {
                return true;
              }
            });
            if (pattern3) {
              result.push(Object.assign(Object.assign({}, pattern3), { index: i2 - pattern3.length + 1 }));
            }
            failNode = failNode.fail;
          }
        }
      }
      return result;
    }
    search(text, surname, algorithm = 2) {
      const patterns = this.match(text, surname);
      if (algorithm === 1) {
        return reverseMaxMatch(patterns);
      } else if (algorithm === 3) {
        return minTokenization(patterns, stringLength(text));
      }
      return maxProbability(patterns, stringLength(text));
    }
  }
  const PatternsNormal = [
    ...Pattern5,
    ...Pattern4,
    ...Pattern3,
    ...Pattern2,
    ...PatternNumberDict,
    ...PatternSurname
  ];
  const acTree = new AC();
  acTree.build(PatternsNormal);
  const customMultipleDict = new FastDictFactory();
  const getCustomMultpileDict = () => {
    return customMultipleDict;
  };
  const getSingleWordPinyin = (char) => {
    const pinyin2 = DICT1.get(char);
    return pinyin2 ? pinyin2.split(" ")[0] : char;
  };
  const getPinyin = (word, list, surname, segmentit) => {
    const matches = acTree.search(word, surname, segmentit);
    let matchIndex = 0;
    const zhChars = splitString(word);
    for (let i2 = 0; i2 < zhChars.length; ) {
      const match = matches[matchIndex];
      if (match && i2 === match.index) {
        if (match.length === 1 && match.priority <= Priority.Normal) {
          const char = zhChars[i2];
          let pinyin2 = "";
          pinyin2 = processSepecialPinyin(char, zhChars[i2 - 1], zhChars[i2 + 1]);
          list[i2] = {
            origin: char,
            result: pinyin2,
            isZh: pinyin2 !== char,
            originPinyin: pinyin2
          };
          i2++;
          matchIndex++;
          continue;
        }
        const pinyins = match.pinyin.split(" ");
        let pinyinIndex = 0;
        for (let j2 = 0; j2 < match.length; j2++) {
          const zhChars2 = splitString(match.zh);
          list[i2 + j2] = {
            origin: zhChars2[j2],
            result: pinyins[pinyinIndex],
            isZh: true,
            originPinyin: pinyins[pinyinIndex]
          };
          pinyinIndex++;
        }
        i2 += match.length;
        matchIndex++;
      } else {
        const char = zhChars[i2];
        let pinyin2 = "";
        pinyin2 = processSepecialPinyin(char, zhChars[i2 - 1], zhChars[i2 + 1]);
        list[i2] = {
          origin: char,
          result: pinyin2,
          isZh: pinyin2 !== char,
          originPinyin: pinyin2
        };
        i2++;
      }
    }
    return { list, matches };
  };
  const getPinyinWithoutTone = (pinyin2) => {
    return pinyin2.replace(/(ā|á|ǎ|à)/g, "a").replace(/(ō|ó|ǒ|ò)/g, "o").replace(/(ē|é|ě|è)/g, "e").replace(/(ī|í|ǐ|ì)/g, "i").replace(/(ū|ú|ǔ|ù)/g, "u").replace(/(ǖ|ǘ|ǚ|ǜ)/g, "ü").replace(/(n̄|ń|ň|ǹ)/g, "n").replace(/(m̄|ḿ|m̌|m̀)/g, "m").replace(/(ê̄|ế|ê̌|ề)/g, "ê");
  };
  const getAllPinyin = (char, surname = "off") => {
    const customMultpileDict = getCustomMultpileDict();
    let pinyin2 = DICT1.get(char) ? DICT1.get(char).split(" ") : [];
    if (customMultpileDict.get(char)) {
      pinyin2 = customMultpileDict.get(char).split(" ");
    } else if (surname !== "off") {
      const surnamePinyin = Surnames[char];
      if (surnamePinyin) {
        pinyin2 = [surnamePinyin].concat(pinyin2.filter((py) => py !== surnamePinyin));
      }
    }
    return pinyin2;
  };
  const getMultiplePinyin = (word, surname = "off") => {
    let pinyin2 = getAllPinyin(word, surname);
    if (pinyin2.length > 0) {
      return pinyin2.map((value) => ({
        origin: word,
        result: value,
        isZh: true,
        originPinyin: value
      }));
    } else {
      return [
        {
          origin: word,
          result: word,
          isZh: false,
          originPinyin: word
        }
      ];
    }
  };
  const getInitialAndFinal = (pinyin2) => {
    const pinyin_arr = pinyin2.split(" ");
    const initial_arr = [];
    const final_arr = [];
    for (let _pinyin of pinyin_arr) {
      for (let _initial of InitialList) {
        if (_pinyin.startsWith(_initial)) {
          let _final = _pinyin.slice(_initial.length);
          if (SpecialInitialList.indexOf(_initial) !== -1 && SpecialFinalList.indexOf(_final) !== -1) {
            _final = SpecialFinalMap[_final];
          }
          initial_arr.push(_initial);
          final_arr.push(_final);
          break;
        }
      }
    }
    return {
      final: final_arr.join(" "),
      initial: initial_arr.join(" ")
      // 声母
    };
  };
  const getFinalParts = (pinyin2) => {
    const { final } = getInitialAndFinal(pinyin2);
    let head = "", body = "", tail = "";
    if (doubleFinalList.indexOf(getPinyinWithoutTone(final)) !== -1) {
      head = final[0];
      body = final[1];
      tail = final.slice(2);
    } else {
      body = final[0] || "";
      tail = final.slice(1) || "";
    }
    return { head, body, tail };
  };
  const getNumOfTone = (pinyin2) => {
    const reg_tone1 = /(ā|ō|ē|ī|ū|ǖ|n̄|m̄|ê̄)/;
    const reg_tone2 = /(á|ó|é|í|ú|ǘ|ń|ḿ|ế)/;
    const reg_tone3 = /(ǎ|ǒ|ě|ǐ|ǔ|ǚ|ň|m̌|ê̌)/;
    const reg_tone4 = /(à|ò|è|ì|ù|ǜ|ǹ|m̀|ề)/;
    const reg_tone0 = /(a|o|e|i|u|ü|ê)/;
    const special_tone = /(n|m)$/;
    const tone_num_arr = [];
    const pinyin_arr = pinyin2.split(" ");
    pinyin_arr.forEach((_pinyin) => {
      if (reg_tone1.test(_pinyin)) {
        tone_num_arr.push("1");
      } else if (reg_tone2.test(_pinyin)) {
        tone_num_arr.push("2");
      } else if (reg_tone3.test(_pinyin)) {
        tone_num_arr.push("3");
      } else if (reg_tone4.test(_pinyin)) {
        tone_num_arr.push("4");
      } else if (reg_tone0.test(_pinyin)) {
        tone_num_arr.push("0");
      } else if (special_tone.test(_pinyin)) {
        tone_num_arr.push("0");
      } else {
        tone_num_arr.push("");
      }
    });
    return tone_num_arr.join(" ");
  };
  const getPinyinWithNum = (pinyin2, originPinyin) => {
    const pinyin_arr = getPinyinWithoutTone(pinyin2).split(" ");
    const tone_num_arr = getNumOfTone(originPinyin).split(" ");
    const res_arr = [];
    pinyin_arr.forEach((item, index) => {
      res_arr.push(`${item}${tone_num_arr[index]}`);
    });
    return res_arr.join(" ");
  };
  const getFirstLetter = (pinyin2, isZh) => {
    const first_letter_arr = [];
    const pinyin_arr = pinyin2.split(" ");
    pinyin_arr.forEach((pinyin3) => {
      first_letter_arr.push(isZh ? pinyin3[0] : pinyin3);
    });
    return first_letter_arr.join(" ");
  };
  const validateType = (word) => {
    if (typeof word !== "string") {
      formatAppLog("error", "at node_modules/pinyin-pro/dist/index.mjs:24201", "The first param of pinyin is error: " + word + ' is not assignable to type "string".');
      return false;
    } else {
      return true;
    }
  };
  function isNonZhScope(char, scope) {
    if (scope instanceof RegExp) {
      return scope.test(char);
    }
    return true;
  }
  const middleWareNonZh = (list, options) => {
    let nonZh = options.nonZh;
    if (nonZh === "removed") {
      return list.filter((item) => item.isZh || !isNonZhScope(item.origin, options.nonZhScope));
    } else if (nonZh === "consecutive") {
      for (let i2 = list.length - 2; i2 >= 0; i2--) {
        const cur = list[i2];
        const pre = list[i2 + 1];
        if (!cur.isZh && !pre.isZh && isNonZhScope(cur.origin, options.nonZhScope) && isNonZhScope(pre.origin, options.nonZhScope)) {
          cur.origin += pre.origin;
          cur.result += pre.result;
          pre.delete = true;
        }
      }
      return list.filter((item) => !item.delete);
    } else {
      return list;
    }
  };
  const middlewareMultiple = (word, options) => {
    if (stringLength(word) === 1 && options.multiple) {
      return getMultiplePinyin(word, options.surname);
    } else {
      return false;
    }
  };
  const middlewarePattern = (list, options) => {
    switch (options.pattern) {
      case "pinyin":
        break;
      case "num":
        list.forEach((item) => {
          item.result = item.isZh ? getNumOfTone(item.result) : "";
        });
        break;
      case "initial":
        list.forEach((item) => {
          item.result = item.isZh ? getInitialAndFinal(item.result).initial : "";
        });
        break;
      case "final":
        list.forEach((item) => {
          item.result = item.isZh ? getInitialAndFinal(item.result).final : "";
        });
        break;
      case "first":
        list.forEach((item) => {
          item.result = getFirstLetter(item.result, item.isZh);
        });
        break;
      case "finalHead":
        list.forEach((item) => {
          item.result = item.isZh ? getFinalParts(item.result).head : "";
        });
        break;
      case "finalBody":
        list.forEach((item) => {
          item.result = item.isZh ? getFinalParts(item.result).body : "";
        });
        break;
      case "finalTail":
        list.forEach((item) => {
          item.result = item.isZh ? getFinalParts(item.result).tail : "";
        });
        break;
    }
  };
  const middlewareToneType = (list, options) => {
    switch (options.toneType) {
      case "symbol":
        break;
      case "none":
        list.forEach((item) => {
          if (item.isZh) {
            item.result = getPinyinWithoutTone(item.result);
          }
        });
        break;
      case "num": {
        list.forEach((item) => {
          if (item.isZh) {
            item.result = getPinyinWithNum(item.result, item.originPinyin);
          }
        });
        break;
      }
    }
  };
  const middlewareV = (list, options) => {
    if (options.v) {
      list.forEach((item) => {
        if (item.isZh) {
          item.result = item.result.replace(/ü/g, "v");
        }
      });
    }
  };
  const middlewareType = (list, options, word) => {
    if (options.multiple && stringLength(word) === 1) {
      let last = "";
      list = list.filter((item) => {
        const res = item.result !== last;
        last = item.result;
        return res;
      });
    }
    if (options.type === "array") {
      return list.map((item) => item.result);
    }
    if (options.type === "all") {
      return list.map((item) => {
        const pinyin2 = item.isZh ? item.result : "";
        const { initial, final } = getInitialAndFinal(pinyin2);
        const { head, body, tail } = getFinalParts(pinyin2);
        let polyphonic = [];
        if (pinyin2 !== "") {
          polyphonic = [pinyin2].concat(getAllPinyin(item.origin, options.surname).filter((item2) => item2 !== pinyin2));
        }
        return {
          origin: item.origin,
          pinyin: pinyin2,
          initial,
          final,
          first: getFirstLetter(item.result, item.isZh),
          finalHead: head,
          finalBody: body,
          finalTail: tail,
          num: Number(getNumOfTone(item.originPinyin)),
          isZh: item.isZh,
          polyphonic,
          inZhRange: !!DICT1.get(item.origin),
          result: item.result
        };
      });
    }
    return list.map((item) => item.result).join(options.separator);
  };
  const middlewareToneSandhi = (list, toneSandhi) => {
    if (toneSandhi === false) {
      list.forEach((item) => {
        if (item.origin === "一") {
          item.result = item.originPinyin = "yī";
        } else if (item.origin === "不") {
          item.result = item.originPinyin = "bù";
        }
      });
    }
    return list;
  };
  const DEFAULT_OPTIONS$2 = {
    pattern: "pinyin",
    toneType: "symbol",
    type: "string",
    multiple: false,
    mode: "normal",
    removeNonZh: false,
    nonZh: "spaced",
    v: false,
    separator: " ",
    toneSandhi: true,
    segmentit: 2
  };
  function pinyin(word, options) {
    options = Object.assign(Object.assign({}, DEFAULT_OPTIONS$2), options || {});
    const legal = validateType(word);
    if (!legal) {
      return word;
    }
    if (word === "") {
      return options.type === "array" || options.type === "all" ? [] : "";
    }
    if (options.surname === void 0) {
      if (options.mode === "surname") {
        options.surname = "all";
      } else {
        options.surname = "off";
      }
    }
    if (options.type === "all") {
      options.pattern = "pinyin";
    }
    if (options.pattern === "num") {
      options.toneType = "none";
    }
    if (options.removeNonZh) {
      options.nonZh = "removed";
    }
    let _list = Array(stringLength(word));
    let { list } = getPinyin(word, _list, options.surname, options.segmentit);
    list = middlewareToneSandhi(list, options.toneSandhi);
    list = middleWareNonZh(list, options);
    if (middlewareMultiple(word, options)) {
      list = middlewareMultiple(word, options);
    }
    middlewarePattern(list, options);
    middlewareToneType(list, options);
    middlewareV(list, options);
    return middlewareType(list, options, word);
  }
  var OutputFormat;
  (function(OutputFormat2) {
    OutputFormat2[OutputFormat2["AllSegment"] = 1] = "AllSegment";
    OutputFormat2[OutputFormat2["AllArray"] = 2] = "AllArray";
    OutputFormat2[OutputFormat2["AllString"] = 3] = "AllString";
    OutputFormat2[OutputFormat2["PinyinSegment"] = 4] = "PinyinSegment";
    OutputFormat2[OutputFormat2["PinyinArray"] = 5] = "PinyinArray";
    OutputFormat2[OutputFormat2["PinyinString"] = 6] = "PinyinString";
    OutputFormat2[OutputFormat2["ZhSegment"] = 7] = "ZhSegment";
    OutputFormat2[OutputFormat2["ZhArray"] = 8] = "ZhArray";
    OutputFormat2[OutputFormat2["ZhString"] = 9] = "ZhString";
  })(OutputFormat || (OutputFormat = {}));
  ({
    toneType: "symbol",
    mode: "normal",
    nonZh: "spaced",
    v: false,
    separator: " ",
    toneSandhi: true,
    segmentit: 2,
    format: OutputFormat.AllSegment
  });
  const createGroup = (params, missionid) => {
    return request({
      url: "/group/create",
      method: "post",
      data: params,
      missionId: missionid
    });
  };
  const _sfc_main$2 = {
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const contactsStore = useContactsStore();
      const userStore = useUserStore();
      const searchKeyword = vue.ref("");
      const selectedContacts = vue.ref([]);
      const popup2 = vue.ref(null);
      const isLoading = vue.ref(true);
      vue.onMounted(async () => {
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:106", "创建群聊组件已挂载");
        isLoading.value = true;
        await loadCachedContacts();
        await fetchContacts();
        isLoading.value = false;
        vue.nextTick(() => {
          const scrollView = document.querySelector(".contacts-list");
          if (scrollView) {
            scrollView.scrollTop = 0;
          }
        });
      });
      const filteredContacts = vue.computed(() => {
        const contacts = contactsStore.userInformationVOList || [];
        if (!searchKeyword.value)
          return contacts;
        return contacts.filter(
          (contact) => contact.name.toLowerCase().includes(searchKeyword.value.toLowerCase())
        );
      });
      const getFirstLetter2 = (name) => {
        const pinyinResult = pinyin(name, { pattern: "first", toneType: "none" });
        return pinyinResult.charAt(0).toUpperCase();
      };
      const groupedContacts = vue.computed(() => {
        const groups = {};
        filteredContacts.value.forEach((contact) => {
          const firstLetter = getFirstLetter2(contact.name);
          if (!groups[firstLetter]) {
            groups[firstLetter] = [];
          }
          groups[firstLetter].push(contact);
        });
        return groups;
      });
      const sortedLetters = vue.computed(() => {
        return Object.keys(groupedContacts.value).sort();
      });
      const handleBack = () => {
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:155", "返回按钮被点击");
        navigateToContacts();
      };
      const handleSearch = () => {
      };
      const toggleSelect = (contact) => {
        const index = selectedContacts.value.findIndex((c2) => c2.id === contact.id);
        if (index === -1) {
          selectedContacts.value.push(contact);
        } else {
          selectedContacts.value.splice(index, 1);
        }
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:172", "已选择的联系人:", selectedContacts.value);
      };
      const isSelected = (contactId) => {
        return selectedContacts.value.some((contact) => contact.id === contactId);
      };
      const handleComplete = () => {
        if (selectedContacts.value.length === 0)
          return;
        popup2.value.open();
      };
      const confirmGroupName = (name) => {
        if (!name) {
          uni.showToast({
            title: "群聊名称不能为空",
            icon: "none"
          });
          return;
        }
        const groupData = {
          groupMemberIds: [...selectedContacts.value.map((contact) => contact.id)],
          groupName: name,
          missionId: userStore.state.missionId[0]
        };
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:204", groupData, "groupData");
        createGroup(groupData, groupData.missionId).then((response) => {
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:208", "群聊创建成功:", response);
          uni.showToast({
            title: "群聊创建成功",
            icon: "success"
          });
          contactsStore.incrementContactsUpdateCounter();
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:215", "群聊创建成功，准备返回");
          setTimeout(() => {
            navigateToContacts();
          }, 100);
        }).catch((error) => {
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:221", "创建群聊失败:", error);
          uni.showToast({
            title: "创建群聊失败",
            icon: "none"
          });
        });
      };
      const closePopup = () => {
        popup2.value.close();
      };
      const loadCachedContacts = async () => {
        const cachedContacts = uni.getStorageSync("cachedContacts");
        if (cachedContacts) {
          contactsStore.setUserInformationVOList(JSON.parse(cachedContacts));
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:239", "已加载缓存的联系人数据");
        }
      };
      const fetchContacts = async () => {
        try {
          const response = await getMissionAddressBook(userStore.state.missionId[0]);
          if (response.code === 200) {
            contactsStore.setUserInformationVOList(response.data.userInformationVOList);
            uni.setStorageSync("cachedContacts", JSON.stringify(response.data.userInformationVOList));
            formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:250", "已更新联系人数据");
          } else {
            throw new Error(response.msg || "获取联系人失败");
          }
        } catch (error) {
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:255", "获取联系人出错:", error);
        }
      };
      const navigateToContacts = () => {
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:265", "准备导航到联系人页面");
        const pages2 = getCurrentPages();
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:267", "当前页面栈:", pages2.map((page) => page.route));
        if (pages2.length > 1) {
          uni.navigateBack({
            delta: 1,
            success: () => {
              formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:273", "成功返回到联系人页面");
            },
            fail: (error) => {
              formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:276", "返回失败:", error);
              fallbackToRedirect();
            }
          });
        } else {
          fallbackToRedirect();
        }
      };
      const fallbackToRedirect = () => {
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:287", "尝试重定向到联系人页面");
        uni.redirectTo({
          url: "/pages/tabBar/tabBar",
          success: () => {
            formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:291", "成功重定向到联系人页面");
          },
          fail: (redirectError) => {
            formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:294", "重定向失败:", redirectError);
            formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:295", "尝试重新启动到联系人页面");
            uni.reLaunch({
              url: "/pages/tabBar/tabBar",
              success: () => {
                formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:299", "成功重新启动到联系人页面");
              },
              fail: (reLaunchError) => {
                formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:302", "重新启动失败:", reLaunchError);
              }
            });
          }
        });
      };
      const __returned__ = { contactsStore, userStore, searchKeyword, selectedContacts, popup: popup2, isLoading, filteredContacts, getFirstLetter: getFirstLetter2, groupedContacts, sortedLetters, handleBack, handleSearch, toggleSelect, isSelected, handleComplete, confirmGroupName, closePopup, loadCachedContacts, fetchContacts, navigateToContacts, fallbackToRedirect, ref: vue.ref, computed: vue.computed, onMounted: vue.onMounted, nextTick: vue.nextTick, get useContactsStore() {
        return useContactsStore;
      }, get useUserStore() {
        return useUserStore;
      }, get pinyin() {
        return pinyin;
      }, get createGroup() {
        return createGroup;
      }, get getMissionAddressBook() {
        return getMissionAddressBook;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    const _component_uni_popup_dialog = resolveEasycom(vue.resolveDynamicComponent("uni-popup-dialog"), __easycom_1);
    const _component_uni_popup = resolveEasycom(vue.resolveDynamicComponent("uni-popup"), __easycom_2$1);
    return vue.openBlock(), vue.createElementBlock("view", { class: "group-chat-container" }, [
      vue.createCommentVNode(" 顶部导航栏 "),
      vue.createVNode(_component_uni_nav_bar, {
        fixed: true,
        "status-bar": "",
        "left-icon": "left",
        onClickLeft: $setup.handleBack,
        title: "发起群聊"
      }, {
        right: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "nav-right" }, [
            vue.createElementVNode("button", {
              class: vue.normalizeClass(["complete-btn", { "active": $setup.selectedContacts.length > 0 }]),
              disabled: $setup.selectedContacts.length === 0,
              onClick: $setup.handleComplete
            }, " 完成 ", 10, ["disabled"])
          ])
        ]),
        _: 1
        /* STABLE */
      }),
      vue.createCommentVNode(" 搜索框 "),
      vue.createElementVNode("view", { class: "search-container" }, [
        vue.createElementVNode("view", { class: "search-box" }, [
          vue.createElementVNode("image", {
            class: "search-icon",
            src: _imports_0$1,
            mode: "aspectFit"
          }),
          vue.withDirectives(vue.createElementVNode(
            "input",
            {
              class: "search-input",
              type: "text",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.searchKeyword = $event),
              placeholder: "搜索",
              onInput: $setup.handleSearch
            },
            null,
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vue.vModelText, $setup.searchKeyword]
          ])
        ])
      ]),
      vue.createCommentVNode(" 加载状态 "),
      $setup.isLoading ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "loading"
      }, "加载中...")) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" 联系人列表 "),
      !$setup.isLoading ? (vue.openBlock(), vue.createElementBlock("scroll-view", {
        key: 1,
        class: "contacts-list",
        "scroll-y": ""
      }, [
        $setup.filteredContacts.length > 0 ? (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          { key: 0 },
          vue.renderList($setup.sortedLetters, (letter) => {
            return vue.openBlock(), vue.createElementBlock("view", { key: letter }, [
              vue.createElementVNode(
                "view",
                { class: "letter-index" },
                vue.toDisplayString(letter),
                1
                /* TEXT */
              ),
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList($setup.groupedContacts[letter], (contact) => {
                  return vue.openBlock(), vue.createElementBlock("view", {
                    key: contact.id,
                    class: "contact-item",
                    onClick: ($event) => $setup.toggleSelect(contact)
                  }, [
                    vue.createElementVNode("checkbox", {
                      checked: $setup.isSelected(contact.id),
                      value: contact.id,
                      class: "checkbox"
                    }, null, 8, ["checked", "value"]),
                    vue.createElementVNode("image", {
                      class: "avatar",
                      src: contact.avatarUrl || "/static/message/默认头像.png",
                      mode: "aspectFill"
                    }, null, 8, ["src"]),
                    vue.createElementVNode(
                      "text",
                      { class: "contact-name" },
                      vue.toDisplayString(contact.name),
                      1
                      /* TEXT */
                    )
                  ], 8, ["onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]);
          }),
          128
          /* KEYED_FRAGMENT */
        )) : (vue.openBlock(), vue.createElementBlock("view", {
          key: 1,
          class: "no-results"
        }, [
          vue.createElementVNode("text", null, "无搜索结果")
        ]))
      ])) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" 群聊名称输入弹窗 "),
      vue.createVNode(
        _component_uni_popup,
        {
          ref: "popup",
          type: "dialog"
        },
        {
          default: vue.withCtx(() => [
            vue.createVNode(_component_uni_popup_dialog, {
              title: "设置群聊名称",
              mode: "input",
              placeholder: "请输入群聊名称",
              "before-close": true,
              onConfirm: $setup.confirmGroupName,
              onClose: $setup.closePopup
            })
          ]),
          _: 1
          /* STABLE */
        },
        512
        /* NEED_PATCH */
      )
    ]);
  }
  const PagesContactsPagesContactsCreateGroupChatIndex = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1], ["__scopeId", "data-v-9480d38a"], ["__file", "E:/代码/new/zk_uniapp/pages/contacts/pages/contacts/create-group-chat/index.vue"]]);
  const _sfc_main$1 = {
    name: "MessageReadStatus",
    components: {
      LocationMessage,
      ImageMessage,
      FileMessage,
      VoiceMessageBubble,
      BurnAfterReadingMessage,
      AudioMessage,
      BurnAfterReadingTextMessage
    },
    setup() {
      formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:114", "消息已读状态组件设置开始");
      const messageData = vue.ref(null);
      const activeTab = vue.ref("read");
      const readUsers = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = messageData.value) == null ? void 0 : _a.groupMessageUserReadVO) == null ? void 0 : _b.filter((user) => user.isRead)) || [];
      });
      const unreadUsers = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = messageData.value) == null ? void 0 : _a.groupMessageUserReadVO) == null ? void 0 : _b.filter((user) => !user.isRead)) || [];
      });
      const displayUsers = vue.computed(() => {
        return activeTab.value === "read" ? readUsers.value : unreadUsers.value;
      });
      const setActiveTab = (tab) => {
        activeTab.value = tab;
      };
      vue.onMounted(() => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:135", "消息已读状态组件挂载");
        const cachedData = uni.getStorageSync("messageReadStatusData");
        if (cachedData) {
          try {
            const parsedData = JSON.parse(cachedData);
            formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:142", "从缓存中读取的消息数据:", parsedData);
            messageData.value = {
              ...parsedData,
              type: parsedData.type || "text",
              messageType: parsedData.messageType || "MESSAGE",
              selfDestruct: parsedData.selfDestruct || false,
              id: parsedData.id
            };
            formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:150", "设置的消息数据:", messageData.value);
            uni.removeStorageSync("messageReadStatusData");
            formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:153", "已清除缓存的消息数据");
          } catch (error) {
            formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:155", "解析缓存数据失败:", error);
            handleDataLoadError();
          }
        } else {
          formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:159", "缓存中没有找到消息数据");
          handleDataLoadError();
        }
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:163", "消息已读状态组件挂载完成");
      });
      const handleDataLoadError = () => {
        uni.showToast({
          title: "无法加载消息数据",
          icon: "none"
        });
        setTimeout(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:172", "无法加载消息数据，返回上一页");
          uni.navigateBack();
        }, 2e3);
      };
      const formatTime2 = (timestamp) => {
        if (!timestamp)
          return "";
        const date = new Date(timestamp);
        const month = (date.getMonth() + 1).toString().padStart(2, "0");
        const day = date.getDate().toString().padStart(2, "0");
        const hours = date.getHours().toString().padStart(2, "0");
        const minutes = date.getMinutes().toString().padStart(2, "0");
        return `${month}-${day} ${hours}:${minutes}`;
      };
      const handleBack = () => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:188", "返回上一页");
        uni.navigateBack();
      };
      const viewBurnAfterReading = (message) => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:193", "查看阅后即焚消息", message);
      };
      const handleMessageDeleted = (messageId) => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:197", "消息已删除", messageId);
      };
      formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:200", "消息已读状态组件设置完成");
      return {
        messageData,
        activeTab,
        readUsers,
        unreadUsers,
        displayUsers,
        formatTime: formatTime2,
        handleBack,
        setActiveTab,
        viewBurnAfterReading,
        handleMessageDeleted
      };
    }
  };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_LocationMessage = vue.resolveComponent("LocationMessage");
    const _component_ImageMessage = vue.resolveComponent("ImageMessage");
    const _component_FileMessage = vue.resolveComponent("FileMessage");
    const _component_VoiceMessageBubble = vue.resolveComponent("VoiceMessageBubble");
    const _component_AudioMessage = vue.resolveComponent("AudioMessage");
    const _component_BurnAfterReadingMessage = vue.resolveComponent("BurnAfterReadingMessage");
    const _component_BurnAfterReadingTextMessage = vue.resolveComponent("BurnAfterReadingTextMessage");
    return vue.openBlock(), vue.createElementBlock("view", { class: "message-read-status" }, [
      vue.createElementVNode("view", { class: "nav-bar" }, [
        vue.createElementVNode("view", {
          class: "back-button",
          onClick: _cache[0] || (_cache[0] = (...args) => $setup.handleBack && $setup.handleBack(...args))
        }, [
          vue.createElementVNode("text", { class: "back-icon" }, "＜")
        ]),
        vue.createElementVNode("view", { class: "title" }, "消息详情")
      ]),
      $setup.messageData ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "message-info"
      }, [
        vue.createElementVNode("view", { class: "sender-info" }, [
          vue.createElementVNode(
            "text",
            { class: "sender-name" },
            vue.toDisplayString($setup.messageData.senderName),
            1
            /* TEXT */
          ),
          vue.createElementVNode(
            "text",
            { class: "message-time" },
            vue.toDisplayString($setup.formatTime($setup.messageData.timestamp)),
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["message-content", {
              "location-content": $setup.messageData.type === "location",
              "file-message": $setup.messageData.type === "file",
              "message-image": $setup.messageData.type === "image",
              "voice-message": $setup.messageData.type === "voice_message",
              "audio-message": $setup.messageData.type === "audio"
            }])
          },
          [
            $setup.messageData.type === "location" ? (vue.openBlock(), vue.createBlock(_component_LocationMessage, {
              key: 0,
              content: $setup.messageData.content
            }, null, 8, ["content"])) : $setup.messageData.type === "image" ? (vue.openBlock(), vue.createBlock(_component_ImageMessage, {
              key: 1,
              content: $setup.messageData.content
            }, null, 8, ["content"])) : $setup.messageData.type === "file" ? (vue.openBlock(), vue.createBlock(_component_FileMessage, {
              key: 2,
              content: $setup.messageData.content,
              messageType: $setup.messageData.messageType
            }, null, 8, ["content", "messageType"])) : $setup.messageData.type === "voice_message" ? (vue.openBlock(), vue.createBlock(_component_VoiceMessageBubble, {
              key: 3,
              content: {
                url: $setup.messageData.content,
                duration: $setup.messageData.duration,
                isSelf: false
              }
            }, null, 8, ["content"])) : $setup.messageData.type === "audio" ? (vue.openBlock(), vue.createBlock(_component_AudioMessage, {
              key: 4,
              content: $setup.messageData.content,
              messageType: $setup.messageData.messageType
            }, null, 8, ["content", "messageType"])) : $setup.messageData.type === "burn-after-reading" ? (vue.openBlock(), vue.createBlock(_component_BurnAfterReadingMessage, {
              key: 5,
              content: $setup.messageData.content,
              onViewBurnAfterReading: $setup.viewBurnAfterReading
            }, null, 8, ["content", "onViewBurnAfterReading"])) : $setup.messageData.selfDestruct && $setup.messageData.messageType === "MESSAGE" ? (vue.openBlock(), vue.createBlock(_component_BurnAfterReadingTextMessage, {
              key: 6,
              messageId: $setup.messageData.id,
              isGroup: true,
              onMessageDeleted: $setup.handleMessageDeleted
            }, null, 8, ["messageId", "onMessageDeleted"])) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 7 },
              [
                vue.createTextVNode(
                  vue.toDisplayString($setup.messageData.content || ""),
                  1
                  /* TEXT */
                )
              ],
              64
              /* STABLE_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        )
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("view", { class: "read-status-container" }, [
        vue.createElementVNode("view", { class: "read-status-tabs" }, [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["tab", { active: $setup.activeTab === "read" }]),
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.setActiveTab("read"))
            },
            [
              vue.createElementVNode(
                "text",
                { class: "tab-number" },
                vue.toDisplayString($setup.readUsers.length),
                1
                /* TEXT */
              ),
              vue.createElementVNode("text", { class: "tab-text" }, "人已读")
            ],
            2
            /* CLASS */
          ),
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["tab", { active: $setup.activeTab === "unread" }]),
              onClick: _cache[2] || (_cache[2] = ($event) => $setup.setActiveTab("unread"))
            },
            [
              vue.createElementVNode(
                "text",
                { class: "tab-number" },
                vue.toDisplayString($setup.unreadUsers.length),
                1
                /* TEXT */
              ),
              vue.createElementVNode("text", { class: "tab-text" }, "人未读")
            ],
            2
            /* CLASS */
          )
        ]),
        vue.createElementVNode("scroll-view", {
          class: "user-list",
          "scroll-y": ""
        }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.displayUsers, (user) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                key: user.userId,
                class: "user-item"
              }, [
                vue.createElementVNode("image", {
                  src: user.avatarUrl || "/static/message/默认头像.png",
                  class: "user-avatar",
                  mode: "aspectFill"
                }, null, 8, ["src"]),
                vue.createElementVNode(
                  "text",
                  { class: "user-name" },
                  vue.toDisplayString(user.userName),
                  1
                  /* TEXT */
                ),
                $setup.activeTab === "read" && user.readTime ? (vue.openBlock(), vue.createElementBlock(
                  "text",
                  {
                    key: 0,
                    class: "read-time"
                  },
                  vue.toDisplayString($setup.formatTime(user.readTime)),
                  1
                  /* TEXT */
                )) : vue.createCommentVNode("v-if", true)
              ]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])
    ]);
  }
  const PagesMessageChatComponentMessageReadStatus = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-c9a2ebe1"], ["__file", "E:/代码/new/zk_uniapp/pages/message/ChatComponent/MessageReadStatus.vue"]]);
  __definePage("pages/login/camouflageLogin/camouflageLogin", PagesLoginCamouflageLoginCamouflageLogin);
  __definePage("pages/login/login", PagesLoginLogin);
  __definePage("pages/register/register", PagesRegisterRegister);
  __definePage("pages/forgetPassword/forgetPassword", PagesForgetPasswordForgetPassword);
  __definePage("pages/fingerLogin/fingerLogin", PagesFingerLoginFingerLogin);
  __definePage("pages/task/task", PagesTaskTask);
  __definePage("pages/task/task_detail/task_detail", PagesTaskTaskDetailTaskDetail);
  __definePage("pages/task/task_detail/document/document", PagesTaskTaskDetailDocumentDocument);
  __definePage("pages/task/task_detail/baidu_map/baidu_map", PagesTaskTaskDetailBaiduMapBaiduMap);
  __definePage("pages/profile/profile", PagesProfileProfile);
  __definePage("pages/message/main", PagesMessageMain);
  __definePage("pages/message/chat", PagesMessageChat);
  __definePage("pages/tabBar/tabBar", PagesTabBarTabBar);
  __definePage("pages/message/video-call", PagesMessageVideoCall);
  __definePage("pages/message/ChatComponent/CallReminder", PagesMessageChatComponentCallReminder);
  __definePage("pages/message/video-answer", PagesMessageVideoAnswer);
  __definePage("pages/login/camouflageLogin/inputAccount/inputAccount", PagesLoginCamouflageLoginInputAccountInputAccount);
  __definePage("pages/contacts/pages/contacts", PagesContactsPagesContacts);
  __definePage("pages/contacts/pages/contacts/create-group-chat/index", PagesContactsPagesContactsCreateGroupChatIndex);
  __definePage("pages/contacts/components/ContactDetail/ContactDetailView", PagesContactsComponentsContactDetailContactDetailView);
  __definePage("pages/message/ChatComponent/MessageReadStatus", PagesMessageChatComponentMessageReadStatus);
  const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
  const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
  function jsonParseTransform(key, value) {
    if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
      warnKeyDropped(key);
      return;
    }
    return value;
  }
  function warnKeyDropped(key) {
    formatAppLog("warn", "at node_modules/destr/dist/index.mjs:12", `[destr] Dropping "${key}" key to prevent prototype pollution.`);
  }
  function destr(value, options = {}) {
    if (typeof value !== "string") {
      return value;
    }
    const _value = value.trim();
    if (
      // eslint-disable-next-line unicorn/prefer-at
      value[0] === '"' && value.endsWith('"') && !value.includes("\\")
    ) {
      return _value.slice(1, -1);
    }
    if (_value.length <= 9) {
      const _lval = _value.toLowerCase();
      if (_lval === "true") {
        return true;
      }
      if (_lval === "false") {
        return false;
      }
      if (_lval === "undefined") {
        return void 0;
      }
      if (_lval === "null") {
        return null;
      }
      if (_lval === "nan") {
        return Number.NaN;
      }
      if (_lval === "infinity") {
        return Number.POSITIVE_INFINITY;
      }
      if (_lval === "-infinity") {
        return Number.NEGATIVE_INFINITY;
      }
    }
    if (!JsonSigRx.test(value)) {
      if (options.strict) {
        throw new SyntaxError("[destr] Invalid JSON");
      }
      return value;
    }
    try {
      if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
        if (options.strict) {
          throw new Error("[destr] Possible prototype pollution");
        }
        return JSON.parse(value, jsonParseTransform);
      }
      return JSON.parse(value);
    } catch (error) {
      if (options.strict) {
        throw error;
      }
      return value;
    }
  }
  function get(obj, path) {
    if (obj == null)
      return void 0;
    let value = obj;
    for (let i2 = 0; i2 < path.length; i2++) {
      if (value == null || value[path[i2]] == null)
        return void 0;
      value = value[path[i2]];
    }
    return value;
  }
  function set(obj, value, path) {
    if (path.length === 0)
      return value;
    const idx = path[0];
    if (path.length > 1) {
      value = set(
        typeof obj !== "object" || obj === null || !Object.prototype.hasOwnProperty.call(obj, idx) ? Number.isInteger(Number(path[1])) ? [] : {} : obj[idx],
        value,
        Array.prototype.slice.call(path, 1)
      );
    }
    if (Number.isInteger(Number(idx)) && Array.isArray(obj))
      return obj.slice()[idx];
    return Object.assign({}, obj, { [idx]: value });
  }
  function unset(obj, path) {
    if (obj == null || path.length === 0)
      return obj;
    if (path.length === 1) {
      if (obj == null)
        return obj;
      if (Number.isInteger(path[0]) && Array.isArray(obj))
        return Array.prototype.slice.call(obj, 0).splice(path[0], 1);
      const result = {};
      for (const p2 in obj)
        result[p2] = obj[p2];
      delete result[path[0]];
      return result;
    }
    if (obj[path[0]] == null) {
      if (Number.isInteger(path[0]) && Array.isArray(obj))
        return Array.prototype.concat.call([], obj);
      const result = {};
      for (const p2 in obj)
        result[p2] = obj[p2];
      return result;
    }
    return set(
      obj,
      unset(
        obj[path[0]],
        Array.prototype.slice.call(path, 1)
      ),
      [path[0]]
    );
  }
  function deepPickUnsafe(obj, paths) {
    return paths.map((p2) => p2.split(".")).map((p2) => [p2, get(obj, p2)]).filter((t2) => t2[1] !== void 0).reduce((acc, cur) => set(acc, cur[1], cur[0]), {});
  }
  function deepOmitUnsafe(obj, paths) {
    return paths.map((p2) => p2.split(".")).reduce((acc, cur) => unset(acc, cur), obj);
  }
  function hydrateStore(store2, {
    storage,
    serializer,
    key,
    debug,
    pick,
    omit,
    beforeHydrate,
    afterHydrate
  }, context, runHooks = true) {
    try {
      if (runHooks)
        beforeHydrate == null ? void 0 : beforeHydrate(context);
      const fromStorage = storage.getItem(key);
      if (fromStorage) {
        const deserialized = serializer.deserialize(fromStorage);
        const picked = pick ? deepPickUnsafe(deserialized, pick) : deserialized;
        const omitted = omit ? deepOmitUnsafe(picked, omit) : picked;
        store2.$patch(omitted);
      }
      if (runHooks)
        afterHydrate == null ? void 0 : afterHydrate(context);
    } catch (error) {
      if (debug)
        formatAppLog("error", "at node_modules/pinia-plugin-persistedstate/dist/index.js:30", "[pinia-plugin-persistedstate]", error);
    }
  }
  function persistState(state, {
    storage,
    serializer,
    key,
    debug,
    pick,
    omit
  }) {
    try {
      const picked = pick ? deepPickUnsafe(state, pick) : state;
      const omitted = omit ? deepOmitUnsafe(picked, omit) : picked;
      const toStorage = serializer.serialize(omitted);
      storage.setItem(key, toStorage);
    } catch (error) {
      if (debug)
        formatAppLog("error", "at node_modules/pinia-plugin-persistedstate/dist/index.js:48", "[pinia-plugin-persistedstate]", error);
    }
  }
  function createPersistence(context, optionsParser, auto) {
    const { pinia, store: store2, options: { persist = auto } } = context;
    if (!persist)
      return;
    if (!(store2.$id in pinia.state.value)) {
      const originalStore = pinia._s.get(store2.$id.replace("__hot:", ""));
      if (originalStore)
        Promise.resolve().then(() => originalStore.$persist());
      return;
    }
    const persistenceOptions = Array.isArray(persist) ? persist : persist === true ? [{}] : [persist];
    const persistences = persistenceOptions.map(optionsParser);
    store2.$hydrate = ({ runHooks = true } = {}) => {
      persistences.forEach((p2) => {
        hydrateStore(store2, p2, context, runHooks);
      });
    };
    store2.$persist = () => {
      persistences.forEach((p2) => {
        persistState(store2.$state, p2);
      });
    };
    persistences.forEach((p2) => {
      hydrateStore(store2, p2, context);
      store2.$subscribe(
        (_mutation, state) => persistState(state, p2),
        { detached: true }
      );
    });
  }
  function createPersistedState(options = {}) {
    return function(context) {
      createPersistence(
        context,
        (p2) => ({
          key: (options.key ? options.key : (x) => x)(p2.key ?? context.store.$id),
          debug: p2.debug ?? options.debug ?? false,
          serializer: p2.serializer ?? options.serializer ?? {
            serialize: (data) => JSON.stringify(data),
            deserialize: (data) => destr(data)
          },
          storage: p2.storage ?? options.storage ?? window.localStorage,
          beforeHydrate: p2.beforeHydrate,
          afterHydrate: p2.afterHydrate,
          pick: p2.pick,
          omit: p2.omit
        }),
        options.auto ?? false
      );
    };
  }
  var src_default = createPersistedState();
  let store = createPinia();
  store.use(src_default);
  const _sfc_main = {
    onLaunch: function() {
      formatAppLog("warn", "at App.vue:4", "当前组件仅支持 uni_modules 目录结构 ，请升级 HBuilderX 到 3.1.0 版本以上！");
      formatAppLog("log", "at App.vue:5", "App Launch"), plus.screen.lockOrientation("portrait-primary");
    },
    onShow: function() {
      formatAppLog("log", "at App.vue:9", "App Show");
    },
    onHide: function() {
      formatAppLog("log", "at App.vue:12", "App Hide");
    }
  };
  const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "E:/代码/new/zk_uniapp/App.vue"]]);
  function createApp() {
    const app = vue.createVueApp(App);
    const pinia = createPinia();
    app.use(pinia);
    app.use(store);
    return {
      app,
      pinia
    };
  }
  let main = plus.android.runtimeMainActivity();
  plus.runtime.quit = function() {
    uni.showModal({
      title: "提示",
      content: "是否退出应用？",
      success: function(res) {
        if (res.confirm) {
          if (uni.getStorageSync("token") != "") {
            logout().then((res2) => {
              uni.removeStorageSync("token");
              uni.removeStorageSync("userInfo");
            });
          }
          main.finish();
        } else if (res.cancel)
          ;
      }
    });
  };
  const { app: __app__, Vuex: __Vuex__, Pinia: __Pinia__ } = createApp();
  uni.Vuex = __Vuex__;
  uni.Pinia = __Pinia__;
  __app__.provide("__globalStyles", __uniConfig.styles);
  __app__._component.mpType = "app";
  __app__._component.render = () => {
  };
  __app__.mount("#app");
})(Vue);
