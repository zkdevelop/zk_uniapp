if (typeof Promise !== "undefined" && !Promise.prototype.finally) {
  Promise.prototype.finally = function(callback) {
    const promise = this.constructor;
    return this.then(
      (value) => promise.resolve(callback()).then(() => value),
      (reason) => promise.resolve(callback()).then(() => {
        throw reason;
      })
    );
  };
}
;
if (typeof uni !== "undefined" && uni && uni.requireGlobal) {
  const global2 = uni.requireGlobal();
  ArrayBuffer = global2.ArrayBuffer;
  Int8Array = global2.Int8Array;
  Uint8Array = global2.Uint8Array;
  Uint8ClampedArray = global2.Uint8ClampedArray;
  Int16Array = global2.Int16Array;
  Uint16Array = global2.Uint16Array;
  Int32Array = global2.Int32Array;
  Uint32Array = global2.Uint32Array;
  Float32Array = global2.Float32Array;
  Float64Array = global2.Float64Array;
  BigInt64Array = global2.BigInt64Array;
  BigUint64Array = global2.BigUint64Array;
}
;
if (uni.restoreGlobal) {
  uni.restoreGlobal(Vue, weex, plus, setTimeout, clearTimeout, setInterval, clearInterval);
}
(function(vue) {
  "use strict";
  const _imports_1$6 = "/static/icon/X.png";
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$1a = {
    data() {
      return {
        statusBarHeight: 0
      };
    },
    onLoad: function() {
      const systemInfo = uni.getSystemInfoSync();
      this.statusBarHeight = systemInfo.statusBarHeight;
    },
    methods: {
      goToLogin() {
        uni.navigateTo({
          url: "/pages/login/camouflageLogin/inputAccount/inputAccount"
        });
      },
      goToFingerLogin() {
        uni.navigateTo({
          url: "/pages/fingerLogin/fingerLogin"
        });
      },
      goToRegister() {
        uni.navigateTo({
          url: "/pages/register/register"
        });
      }
    }
  };
  function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "camouflagePage" }, [
      vue.createElementVNode("view", { class: "statusBar" }),
      vue.createElementVNode("view", { class: "camouflageLayout" }, [
        vue.createCommentVNode(" æŽ¨ç‰¹logo "),
        vue.createElementVNode("view", { style: { "text-align": "center", "margin-top": "10px" } }, [
          vue.createElementVNode("image", {
            src: _imports_1$6,
            style: { "width": "25px", "height": "25px" }
          })
        ]),
        vue.createElementVNode("view", { style: { "margin-top": "250px", "text-align": "left" } }, [
          vue.createElementVNode("text", { style: { "letter-spacing": "3px", "font-size": "65rpx", "font-family": "fantasy", "font-weight": "550", "width": "75%" } }, "æŸ¥çœ‹ä¸–ç•Œå„åœ°çš„æ–°é²œäº‹ã€‚")
        ]),
        vue.createElementVNode("view", { class: "createAccount" }, [
          vue.createElementVNode("button", {
            onClick: _cache[0] || (_cache[0] = (...args) => $options.goToRegister && $options.goToRegister(...args)),
            type: "primary",
            style: { "border-radius": "20px", "background": "#1d9bf0" }
          }, "åˆ›å»ºè´¦å·")
        ])
      ]),
      vue.createElementVNode("view", { class: "camouflageFooter" }, [
        vue.createElementVNode("view", null, [
          vue.createElementVNode("text", null, "å·²ç»æœ‰è´¦å·äº†ï¼Ÿ"),
          vue.createElementVNode("text", {
            onClick: _cache[1] || (_cache[1] = (...args) => $options.goToLogin && $options.goToLogin(...args)),
            style: { "color": "#1d9bf0" }
          }, "ç™»å½•")
        ]),
        vue.createElementVNode("view", null, [
          vue.createElementVNode("text", {
            onClick: _cache[2] || (_cache[2] = (...args) => $options.goToFingerLogin && $options.goToFingerLogin(...args)),
            style: { "color": "#1d9bf0" }
          }, "æŒ‡çº¹ç™»å½•")
        ])
      ])
    ]);
  }
  const PagesLoginCamouflageLoginCamouflageLogin = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$19], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/login/camouflageLogin/camouflageLogin.vue"]]);
  const ON_SHOW = "onShow";
  function requireNativePlugin(name) {
    return weex.requireModule(name);
  }
  function formatAppLog(type, filename, ...args) {
    if (uni.__log__) {
      uni.__log__(type, filename, ...args);
    } else {
      console[type].apply(console, [...args, filename]);
    }
  }
  function resolveEasycom(component, easycom) {
    return typeof component === "string" ? easycom : component;
  }
  const createHook = (lifecycle) => (hook, target = vue.getCurrentInstance()) => {
    !vue.isInSSRComponentSetup && vue.injectHook(lifecycle, hook, target);
  };
  const onShow = /* @__PURE__ */ createHook(ON_SHOW);
  const backendHost = "http://139.196.11.210:8500/communicate";
  const LIVEKITURL = "ws://192.168.37.163:7880";
  const BASE_URL = backendHost;
  const timeout = 5e3;
  const request = (params) => {
    let url = params.url;
    let method = params.method || "get";
    let data = params.data || {};
    let header = {
      "Content-Type": "application/json;charset=UTF-8",
      "Authorization": "Bearer " + uni.getStorageSync("token"),
      ...params.header
    };
    return new Promise((resolve, reject) => {
      uni.request({
        url: BASE_URL + url,
        method,
        header,
        data,
        timeout,
        success(response) {
          const res = response;
          if (res.statusCode == 200) {
            resolve(res.data);
          } else {
            switch (res.statusCode) {
              case 404:
                uni.showToast({
                  title: "è¯·æ±‚åœ°å€ä¸å­˜åœ¨...",
                  duration: 2e3
                });
                break;
              default:
                uni.showToast({
                  title: "è¯·é‡è¯•...",
                  duration: 2e3
                });
                break;
            }
          }
        },
        fail(err) {
          formatAppLog("log", "at utils/request.js:57", err);
          if (err.errMsg.indexOf("request:fail") !== -1) {
            uni.showToast({
              title: "ç½‘ç»œå¼‚å¸¸",
              icon: "error",
              duration: 2e3
            });
          } else {
            uni.showToast({
              title: "æœªçŸ¥å¼‚å¸¸",
              duration: 2e3
            });
          }
          reject(err);
        },
        complete() {
          uni.hideLoading();
          uni.hideToast();
        }
      });
    }).catch(() => {
    });
  };
  const login = (params) => {
    const data = {
      account: params.account,
      password: params.password
    };
    return request({
      // url: `/user/login?account=${params.account}&password=${params.password}`,
      url: `/user/login`,
      method: "post",
      header: {
        "Authorization": ""
      },
      data
    });
  };
  const register = (params) => {
    return request({
      url: "/user/register",
      method: "post",
      data: params
    });
  };
  const logout = (params) => {
    return request({
      url: "/user/logout",
      method: "post"
    });
  };
  var isVue2 = false;
  function set$1(target, key, val) {
    if (Array.isArray(target)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    target[key] = val;
    return val;
  }
  function del(target, key) {
    if (Array.isArray(target)) {
      target.splice(key, 1);
      return;
    }
    delete target[key];
  }
  function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  }
  const isProxyAvailable = typeof Proxy === "function";
  const HOOK_SETUP = "devtools-plugin:setup";
  const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
  let supported;
  let perf;
  function isPerformanceSupported() {
    var _a;
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
      supported = true;
      perf = global.perf_hooks.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
  }
  class ApiProxy {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = Object.assign({}, defaultSettings);
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e2) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e2) {
          }
          currentSettings = value;
        },
        now() {
          return now();
        }
      };
      if (hook) {
        hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
          if (pluginId === this.plugin.id) {
            this.fallbacks.setSettings(value);
          }
        });
      }
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  }
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = getTarget();
    const hook = getDevtoolsGlobalHook();
    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor: descriptor,
        setupFn,
        proxy
      });
      if (proxy)
        setupFn(proxy.proxiedTarget);
    }
  }
  /*!
   * pinia v2.1.7
   * (c) 2023 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia) => activePinia = pinia;
  const piniaSymbol = Symbol("pinia");
  function isPlainObject(o2) {
    return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  const IS_CLIENT = typeof window !== "undefined";
  const USE_DEVTOOLS = IS_CLIENT;
  const _global = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
  function bom(blob, { autoBom = false } = {}) {
    if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
      return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
    }
    return blob;
  }
  function download(url, name, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.onload = function() {
      saveAs(xhr.response, name, opts);
    };
    xhr.onerror = function() {
      console.error("could not download file");
    };
    xhr.send();
  }
  function corsEnabled(url) {
    const xhr = new XMLHttpRequest();
    xhr.open("HEAD", url, false);
    try {
      xhr.send();
    } catch (e2) {
    }
    return xhr.status >= 200 && xhr.status <= 299;
  }
  function click(node) {
    try {
      node.dispatchEvent(new MouseEvent("click"));
    } catch (e2) {
      const evt = document.createEvent("MouseEvents");
      evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      node.dispatchEvent(evt);
    }
  }
  const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
  const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
  const saveAs = !IS_CLIENT ? () => {
  } : (
    // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
    typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
      // Use msSaveOrOpenBlob as a second approach
      "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
        // Fallback to using FileReader and a popup
        fileSaverSaveAs
      )
    )
  );
  function downloadSaveAs(blob, name = "download", opts) {
    const a2 = document.createElement("a");
    a2.download = name;
    a2.rel = "noopener";
    if (typeof blob === "string") {
      a2.href = blob;
      if (a2.origin !== location.origin) {
        if (corsEnabled(a2.href)) {
          download(blob, name, opts);
        } else {
          a2.target = "_blank";
          click(a2);
        }
      } else {
        click(a2);
      }
    } else {
      a2.href = URL.createObjectURL(blob);
      setTimeout(function() {
        URL.revokeObjectURL(a2.href);
      }, 4e4);
      setTimeout(function() {
        click(a2);
      }, 0);
    }
  }
  function msSaveAs(blob, name = "download", opts) {
    if (typeof blob === "string") {
      if (corsEnabled(blob)) {
        download(blob, name, opts);
      } else {
        const a2 = document.createElement("a");
        a2.href = blob;
        a2.target = "_blank";
        setTimeout(function() {
          click(a2);
        });
      }
    } else {
      navigator.msSaveOrOpenBlob(bom(blob, opts), name);
    }
  }
  function fileSaverSaveAs(blob, name, opts, popup2) {
    popup2 = popup2 || open("", "_blank");
    if (popup2) {
      popup2.document.title = popup2.document.body.innerText = "downloading...";
    }
    if (typeof blob === "string")
      return download(blob, name, opts);
    const force = blob.type === "application/octet-stream";
    const isSafari2 = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || force && isSafari2 || isMacOSWebView) && typeof FileReader !== "undefined") {
      const reader = new FileReader();
      reader.onloadend = function() {
        let url = reader.result;
        if (typeof url !== "string") {
          popup2 = null;
          throw new Error("Wrong reader.result type");
        }
        url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
        if (popup2) {
          popup2.location.href = url;
        } else {
          location.assign(url);
        }
        popup2 = null;
      };
      reader.readAsDataURL(blob);
    } else {
      const url = URL.createObjectURL(blob);
      if (popup2)
        popup2.location.assign(url);
      else
        location.href = url;
      popup2 = null;
      setTimeout(function() {
        URL.revokeObjectURL(url);
      }, 4e4);
    }
  }
  function toastMessage(message, type) {
    const piniaMessage = "ðŸ " + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
      __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    } else if (type === "error") {
      console.error(piniaMessage);
    } else if (type === "warn") {
      console.warn(piniaMessage);
    } else {
      console.log(piniaMessage);
    }
  }
  function isPinia(o2) {
    return "_a" in o2 && "install" in o2;
  }
  function checkClipboardAccess() {
    if (!("clipboard" in navigator)) {
      toastMessage(`Your browser doesn't support the Clipboard API`, "error");
      return true;
    }
  }
  function checkNotFocusedError(error) {
    if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
      toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
      return true;
    }
    return false;
  }
  async function actionGlobalCopyState(pinia) {
    if (checkClipboardAccess())
      return;
    try {
      await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
      toastMessage("Global state copied to clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  async function actionGlobalPasteState(pinia) {
    if (checkClipboardAccess())
      return;
    try {
      loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));
      toastMessage("Global state pasted from clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  async function actionGlobalSaveState(pinia) {
    try {
      saveAs(new Blob([JSON.stringify(pinia.state.value)], {
        type: "text/plain;charset=utf-8"
      }), "pinia-state.json");
    } catch (error) {
      toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  let fileInput;
  function getFileOpener() {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".json";
    }
    function openFile() {
      return new Promise((resolve, reject) => {
        fileInput.onchange = async () => {
          const files = fileInput.files;
          if (!files)
            return resolve(null);
          const file = files.item(0);
          if (!file)
            return resolve(null);
          return resolve({ text: await file.text(), file });
        };
        fileInput.oncancel = () => resolve(null);
        fileInput.onerror = reject;
        fileInput.click();
      });
    }
    return openFile;
  }
  async function actionGlobalOpenStateFile(pinia) {
    try {
      const open2 = getFileOpener();
      const result = await open2();
      if (!result)
        return;
      const { text, file } = result;
      loadStoresState(pinia, JSON.parse(text));
      toastMessage(`Global state imported from "${file.name}".`);
    } catch (error) {
      toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  function loadStoresState(pinia, state) {
    for (const key in state) {
      const storeState = pinia.state.value[key];
      if (storeState) {
        Object.assign(storeState, state[key]);
      } else {
        pinia.state.value[key] = state[key];
      }
    }
  }
  function formatDisplay(display) {
    return {
      _custom: {
        display
      }
    };
  }
  const PINIA_ROOT_LABEL = "ðŸ Pinia (root)";
  const PINIA_ROOT_ID = "_root";
  function formatStoreForInspectorTree(store2) {
    return isPinia(store2) ? {
      id: PINIA_ROOT_ID,
      label: PINIA_ROOT_LABEL
    } : {
      id: store2.$id,
      label: store2.$id
    };
  }
  function formatStoreForInspectorState(store2) {
    if (isPinia(store2)) {
      const storeNames = Array.from(store2._s.keys());
      const storeMap = store2._s;
      const state2 = {
        state: storeNames.map((storeId) => ({
          editable: true,
          key: storeId,
          value: store2.state.value[storeId]
        })),
        getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
          const store22 = storeMap.get(id);
          return {
            editable: false,
            key: id,
            value: store22._getters.reduce((getters, key) => {
              getters[key] = store22[key];
              return getters;
            }, {})
          };
        })
      };
      return state2;
    }
    const state = {
      state: Object.keys(store2.$state).map((key) => ({
        editable: true,
        key,
        value: store2.$state[key]
      }))
    };
    if (store2._getters && store2._getters.length) {
      state.getters = store2._getters.map((getterName) => ({
        editable: false,
        key: getterName,
        value: store2[getterName]
      }));
    }
    if (store2._customProperties.size) {
      state.customProperties = Array.from(store2._customProperties).map((key) => ({
        editable: true,
        key,
        value: store2[key]
      }));
    }
    return state;
  }
  function formatEventData(events2) {
    if (!events2)
      return {};
    if (Array.isArray(events2)) {
      return events2.reduce((data, event) => {
        data.keys.push(event.key);
        data.operations.push(event.type);
        data.oldValue[event.key] = event.oldValue;
        data.newValue[event.key] = event.newValue;
        return data;
      }, {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
      });
    } else {
      return {
        operation: formatDisplay(events2.type),
        key: formatDisplay(events2.key),
        oldValue: events2.oldValue,
        newValue: events2.newValue
      };
    }
  }
  function formatMutationType(type) {
    switch (type) {
      case MutationType.direct:
        return "mutation";
      case MutationType.patchFunction:
        return "$patch";
      case MutationType.patchObject:
        return "$patch";
      default:
        return "unknown";
    }
  }
  let isTimelineActive = true;
  const componentStateTypes = [];
  const MUTATIONS_LAYER_ID = "pinia:mutations";
  const INSPECTOR_ID = "pinia";
  const { assign: assign$1 } = Object;
  const getStoreType = (id) => "ðŸ " + id;
  function registerPiniaDevtools(app, pinia) {
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia ðŸ",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app
    }, (api) => {
      if (typeof api.now !== "function") {
        toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
      }
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: `Pinia ðŸ`,
        color: 15064968
      });
      api.addInspector({
        id: INSPECTOR_ID,
        label: "Pinia ðŸ",
        icon: "storage",
        treeFilterPlaceholder: "Search stores",
        actions: [
          {
            icon: "content_copy",
            action: () => {
              actionGlobalCopyState(pinia);
            },
            tooltip: "Serialize and copy the state"
          },
          {
            icon: "content_paste",
            action: async () => {
              await actionGlobalPasteState(pinia);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Replace the state with the content of your clipboard"
          },
          {
            icon: "save",
            action: () => {
              actionGlobalSaveState(pinia);
            },
            tooltip: "Save the state as a JSON file"
          },
          {
            icon: "folder_open",
            action: async () => {
              await actionGlobalOpenStateFile(pinia);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Import the state from a JSON file"
          }
        ],
        nodeActions: [
          {
            icon: "restore",
            tooltip: 'Reset the state (with "$reset")',
            action: (nodeId) => {
              const store2 = pinia._s.get(nodeId);
              if (!store2) {
                toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
              } else if (typeof store2.$reset !== "function") {
                toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
              } else {
                store2.$reset();
                toastMessage(`Store "${nodeId}" reset.`);
              }
            }
          }
        ]
      });
      api.on.inspectComponent((payload, ctx) => {
        const proxy = payload.componentInstance && payload.componentInstance.proxy;
        if (proxy && proxy._pStores) {
          const piniaStores = payload.componentInstance.proxy._pStores;
          Object.values(piniaStores).forEach((store2) => {
            payload.instanceData.state.push({
              type: getStoreType(store2.$id),
              key: "state",
              editable: true,
              value: store2._isOptionsAPI ? {
                _custom: {
                  value: vue.toRaw(store2.$state),
                  actions: [
                    {
                      icon: "restore",
                      tooltip: "Reset the state of this store",
                      action: () => store2.$reset()
                    }
                  ]
                }
              } : (
                // NOTE: workaround to unwrap transferred refs
                Object.keys(store2.$state).reduce((state, key) => {
                  state[key] = store2.$state[key];
                  return state;
                }, {})
              )
            });
            if (store2._getters && store2._getters.length) {
              payload.instanceData.state.push({
                type: getStoreType(store2.$id),
                key: "getters",
                editable: false,
                value: store2._getters.reduce((getters, key) => {
                  try {
                    getters[key] = store2[key];
                  } catch (error) {
                    getters[key] = error;
                  }
                  return getters;
                }, {})
              });
            }
          });
        }
      });
      api.on.getInspectorTree((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          let stores = [pinia];
          stores = stores.concat(Array.from(pinia._s.values()));
          payload.rootNodes = (payload.filter ? stores.filter((store2) => "$id" in store2 ? store2.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
        }
      });
      api.on.getInspectorState((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
          if (!inspectedStore) {
            return;
          }
          if (inspectedStore) {
            payload.state = formatStoreForInspectorState(inspectedStore);
          }
        }
      });
      api.on.editInspectorState((payload, ctx) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
          if (!inspectedStore) {
            return toastMessage(`store "${payload.nodeId}" not found`, "error");
          }
          const { path } = payload;
          if (!isPinia(inspectedStore)) {
            if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
              path.unshift("$state");
            }
          } else {
            path.unshift("state");
          }
          isTimelineActive = false;
          payload.set(inspectedStore, path, payload.state.value);
          isTimelineActive = true;
        }
      });
      api.on.editComponentState((payload) => {
        if (payload.type.startsWith("ðŸ")) {
          const storeId = payload.type.replace(/^ðŸ\s*/, "");
          const store2 = pinia._s.get(storeId);
          if (!store2) {
            return toastMessage(`store "${storeId}" not found`, "error");
          }
          const { path } = payload;
          if (path[0] !== "state") {
            return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
          }
          path[0] = "$state";
          isTimelineActive = false;
          payload.set(store2, path, payload.state.value);
          isTimelineActive = true;
        }
      });
    });
  }
  function addStoreToDevtools(app, store2) {
    if (!componentStateTypes.includes(getStoreType(store2.$id))) {
      componentStateTypes.push(getStoreType(store2.$id));
    }
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia ðŸ",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app,
      settings: {
        logStoreChanges: {
          label: "Notify about new/deleted stores",
          type: "boolean",
          defaultValue: true
        }
        // useEmojis: {
        //   label: 'Use emojis in messages âš¡ï¸',
        //   type: 'boolean',
        //   defaultValue: true,
        // },
      }
    }, (api) => {
      const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
      store2.$onAction(({ after, onError, name, args }) => {
        const groupId = runningActionId++;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "ðŸ›« " + name,
            subtitle: "start",
            data: {
              store: formatDisplay(store2.$id),
              action: formatDisplay(name),
              args
            },
            groupId
          }
        });
        after((result) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "ðŸ›¬ " + name,
              subtitle: "end",
              data: {
                store: formatDisplay(store2.$id),
                action: formatDisplay(name),
                args,
                result
              },
              groupId
            }
          });
        });
        onError((error) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              logType: "error",
              title: "ðŸ’¥ " + name,
              subtitle: "end",
              data: {
                store: formatDisplay(store2.$id),
                action: formatDisplay(name),
                args,
                error
              },
              groupId
            }
          });
        });
      }, true);
      store2._customProperties.forEach((name) => {
        vue.watch(() => vue.unref(store2[name]), (newValue, oldValue) => {
          api.notifyComponentUpdate();
          api.sendInspectorState(INSPECTOR_ID);
          if (isTimelineActive) {
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: "Change",
                subtitle: name,
                data: {
                  newValue,
                  oldValue
                },
                groupId: activeAction
              }
            });
          }
        }, { deep: true });
      });
      store2.$subscribe(({ events: events2, type }, state) => {
        api.notifyComponentUpdate();
        api.sendInspectorState(INSPECTOR_ID);
        if (!isTimelineActive)
          return;
        const eventData = {
          time: now2(),
          title: formatMutationType(type),
          data: assign$1({ store: formatDisplay(store2.$id) }, formatEventData(events2)),
          groupId: activeAction
        };
        if (type === MutationType.patchFunction) {
          eventData.subtitle = "â¤µï¸";
        } else if (type === MutationType.patchObject) {
          eventData.subtitle = "ðŸ§©";
        } else if (events2 && !Array.isArray(events2)) {
          eventData.subtitle = events2.type;
        }
        if (events2) {
          eventData.data["rawEvent(s)"] = {
            _custom: {
              display: "DebuggerEvent",
              type: "object",
              tooltip: "raw DebuggerEvent[]",
              value: events2
            }
          };
        }
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: eventData
        });
      }, { detached: true, flush: "sync" });
      const hotUpdate = store2._hotUpdate;
      store2._hotUpdate = vue.markRaw((newStore) => {
        hotUpdate(newStore);
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "ðŸ”¥ " + store2.$id,
            subtitle: "HMR update",
            data: {
              store: formatDisplay(store2.$id),
              info: formatDisplay(`HMR update`)
            }
          }
        });
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
      });
      const { $dispose } = store2;
      store2.$dispose = () => {
        $dispose();
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges && toastMessage(`Disposed "${store2.$id}" store ðŸ—‘`);
      };
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.getSettings().logStoreChanges && toastMessage(`"${store2.$id}" store installed ðŸ†•`);
    });
  }
  let runningActionId = 0;
  let activeAction;
  function patchActionForGrouping(store2, actionNames, wrapWithProxy) {
    const actions = actionNames.reduce((storeActions, actionName) => {
      storeActions[actionName] = vue.toRaw(store2)[actionName];
      return storeActions;
    }, {});
    for (const actionName in actions) {
      store2[actionName] = function() {
        const _actionId = runningActionId;
        const trackedStore = wrapWithProxy ? new Proxy(store2, {
          get(...args) {
            activeAction = _actionId;
            return Reflect.get(...args);
          },
          set(...args) {
            activeAction = _actionId;
            return Reflect.set(...args);
          }
        }) : store2;
        activeAction = _actionId;
        const retValue = actions[actionName].apply(trackedStore, arguments);
        activeAction = void 0;
        return retValue;
      };
    }
  }
  function devtoolsPlugin({ app, store: store2, options }) {
    if (store2.$id.startsWith("__hot:")) {
      return;
    }
    store2._isOptionsAPI = !!options.state;
    patchActionForGrouping(store2, Object.keys(options.actions), store2._isOptionsAPI);
    const originalHotUpdate = store2._hotUpdate;
    vue.toRaw(store2)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store2, Object.keys(newStore._hmrPayload.actions), !!store2._isOptionsAPI);
    };
    addStoreToDevtools(
      app,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      store2
    );
  }
  function createPinia() {
    const scope = vue.effectScope(true);
    const state = scope.run(() => vue.ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = vue.markRaw({
      install(app) {
        setActivePinia(pinia);
        {
          pinia._a = app;
          app.provide(piniaSymbol, pinia);
          app.config.globalProperties.$pinia = pinia;
          if (USE_DEVTOOLS) {
            registerPiniaDevtools(app, pinia);
          }
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
      pinia.use(devtoolsPlugin);
    }
    return pinia;
  }
  function patchObject(newState, oldState) {
    for (const key in oldState) {
      const subPatch = oldState[key];
      if (!(key in newState)) {
        continue;
      }
      const targetValue = newState[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
        newState[key] = patchObject(targetValue, subPatch);
      } else {
        {
          newState[key] = subPatch;
        }
      }
    }
    return newState;
  }
  const noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && vue.getCurrentScope()) {
      vue.onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    }
    if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = Symbol("pinia:skipHydration");
  function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o2) {
    return !!(vue.isRef(o2) && o2.effect);
  }
  function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store2;
    function setup() {
      if (!initialState && !hot) {
        {
          pinia.state.value[id] = state ? state() : {};
        }
      }
      const localState = hot ? (
        // use ref() to unwrap refs inside state TODO: check if this is still necessary
        vue.toRefs(vue.ref(state ? state() : {}).value)
      ) : vue.toRefs(pinia.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        if (name in localState) {
          console.warn(`[ðŸ]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
        }
        computedGetters[name] = vue.markRaw(vue.computed(() => {
          setActivePinia(pinia);
          const store22 = pinia._s.get(id);
          return getters[name].call(store22, store22);
        }));
        return computedGetters;
      }, {}));
    }
    store2 = createSetupStore(id, setup, options, pinia, hot, true);
    return store2;
  }
  function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    if (!pinia._e.active) {
      throw new Error("Pinia destroyed");
    }
    const $subscribeOptions = {
      deep: true
      // flush: 'post',
    };
    {
      $subscribeOptions.onTrigger = (event) => {
        if (isListening) {
          debuggerEvents = event;
        } else if (isListening == false && !store2._hotUpdating) {
          if (Array.isArray(debuggerEvents)) {
            debuggerEvents.push(event);
          } else {
            console.error("ðŸ debuggerEvents should be an array. This is most likely an internal Pinia bug.");
          }
        }
      };
    }
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && !hot) {
      {
        pinia.state.value[$id] = {};
      }
    }
    const hotState = vue.ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      {
        debuggerEvents = [];
      }
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      vue.nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      () => {
        throw new Error(`ðŸ: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
      }
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia._s.delete($id);
    }
    function wrapAction(name, action) {
      return function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name,
          store: store2,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store2, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const _hmrPayload = /* @__PURE__ */ vue.markRaw({
      actions: {},
      getters: {},
      state: [],
      hotState
    });
    const partialStore = {
      _p: pinia,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => vue.watch(() => pinia.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store2 = vue.reactive(assign(
      {
        _hmrPayload,
        _customProperties: vue.markRaw(/* @__PURE__ */ new Set())
        // devtools custom properties
      },
      partialStore
      // must be added later
      // setupStore
    ));
    pinia._s.set($id, store2);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = vue.effectScope()).run(setup)));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (vue.isRef(prop) && !isComputed(prop) || vue.isReactive(prop)) {
        if (hot) {
          set$1(hotState.value, key, vue.toRef(setupStore, key));
        } else if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (vue.isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia.state.value[$id][key] = prop;
          }
        }
        {
          _hmrPayload.state.push(key);
        }
      } else if (typeof prop === "function") {
        const actionValue = hot ? prop : wrapAction(key, prop);
        {
          setupStore[key] = actionValue;
        }
        {
          _hmrPayload.actions[key] = prop;
        }
        optionsForPlugin.actions[key] = prop;
      } else {
        if (isComputed(prop)) {
          _hmrPayload.getters[key] = isOptionsStore ? (
            // @ts-expect-error
            options.getters[key]
          ) : prop;
          if (IS_CLIENT) {
            const getters = setupStore._getters || // @ts-expect-error: same
            (setupStore._getters = vue.markRaw([]));
            getters.push(key);
          }
        }
      }
    }
    {
      assign(store2, setupStore);
      assign(vue.toRaw(store2), setupStore);
    }
    Object.defineProperty(store2, "$state", {
      get: () => hot ? hotState.value : pinia.state.value[$id],
      set: (state) => {
        if (hot) {
          throw new Error("cannot set hotState");
        }
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    {
      store2._hotUpdate = vue.markRaw((newStore) => {
        store2._hotUpdating = true;
        newStore._hmrPayload.state.forEach((stateKey) => {
          if (stateKey in store2.$state) {
            const newStateTarget = newStore.$state[stateKey];
            const oldStateSource = store2.$state[stateKey];
            if (typeof newStateTarget === "object" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {
              patchObject(newStateTarget, oldStateSource);
            } else {
              newStore.$state[stateKey] = oldStateSource;
            }
          }
          set$1(store2, stateKey, vue.toRef(newStore.$state, stateKey));
        });
        Object.keys(store2.$state).forEach((stateKey) => {
          if (!(stateKey in newStore.$state)) {
            del(store2, stateKey);
          }
        });
        isListening = false;
        isSyncListening = false;
        pinia.state.value[$id] = vue.toRef(newStore._hmrPayload, "hotState");
        isSyncListening = true;
        vue.nextTick().then(() => {
          isListening = true;
        });
        for (const actionName in newStore._hmrPayload.actions) {
          const action = newStore[actionName];
          set$1(store2, actionName, wrapAction(actionName, action));
        }
        for (const getterName in newStore._hmrPayload.getters) {
          const getter = newStore._hmrPayload.getters[getterName];
          const getterValue = isOptionsStore ? (
            // special handling of options api
            vue.computed(() => {
              setActivePinia(pinia);
              return getter.call(store2, store2);
            })
          ) : getter;
          set$1(store2, getterName, getterValue);
        }
        Object.keys(store2._hmrPayload.getters).forEach((key) => {
          if (!(key in newStore._hmrPayload.getters)) {
            del(store2, key);
          }
        });
        Object.keys(store2._hmrPayload.actions).forEach((key) => {
          if (!(key in newStore._hmrPayload.actions)) {
            del(store2, key);
          }
        });
        store2._hmrPayload = newStore._hmrPayload;
        store2._getters = newStore._getters;
        store2._hotUpdating = false;
      });
    }
    if (USE_DEVTOOLS) {
      const nonEnumerable = {
        writable: true,
        configurable: true,
        // avoid warning on devtools trying to display this property
        enumerable: false
      };
      ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
        Object.defineProperty(store2, p2, assign({ value: store2[p2] }, nonEnumerable));
      });
    }
    pinia._p.forEach((extender) => {
      if (USE_DEVTOOLS) {
        const extensions = scope.run(() => extender({
          store: store2,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        }));
        Object.keys(extensions || {}).forEach((key) => store2._customProperties.add(key));
        assign(store2, extensions);
      } else {
        assign(store2, scope.run(() => extender({
          store: store2,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (store2.$state && typeof store2.$state === "object" && typeof store2.$state.constructor === "function" && !store2.$state.constructor.toString().includes("[native code]")) {
      console.warn(`[ðŸ]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store2.$id}".`);
    }
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store2.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store2;
  }
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
      if (typeof id !== "string") {
        throw new Error(`[ðŸ]: "defineStore()" must be passed a store id as its first argument.`);
      }
    }
    function useStore(pinia, hot) {
      const hasContext = vue.hasInjectionContext();
      pinia = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia || (hasContext ? vue.inject(piniaSymbol, null) : null);
      if (pinia)
        setActivePinia(pinia);
      if (!activePinia) {
        throw new Error(`[ðŸ]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
      }
      pinia = activePinia;
      if (!pinia._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia);
        } else {
          createOptionsStore(id, options, pinia);
        }
        {
          useStore._pinia = pinia;
        }
      }
      const store2 = pinia._s.get(id);
      if (hot) {
        const hotId = "__hot:" + id;
        const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);
        hot._hotUpdate(newStore);
        delete pinia.state.value[hotId];
        pinia._s.delete(hotId);
      }
      if (IS_CLIENT) {
        const currentInstance = vue.getCurrentInstance();
        if (currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement
        !hot) {
          const vm = currentInstance.proxy;
          const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
          cache[id] = store2;
        }
      }
      return store2;
    }
    useStore.$id = id;
    return useStore;
  }
  const useUserStore = defineStore("user", () => {
    const state = vue.reactive({
      id: "",
      account: "",
      name: "",
      department: "",
      role: "",
      phone: "",
      created: "",
      avatar: null,
      avatarUrl: "",
      token: "",
      status: "",
      missionId: ""
    });
    function setUserData(data) {
      formatAppLog("log", "at store/userStore.js:22", "è®¾ç½®ç”¨æˆ·æ•°æ®:", data);
      Object.keys(data).forEach((key) => {
        if (key in state) {
          state[key] = data[key];
        }
      });
      formatAppLog("log", "at store/userStore.js:28", "æ›´æ–°åŽçš„çŠ¶æ€:", state);
    }
    function clearUserData() {
      Object.keys(state).forEach((key) => {
        state[key] = state[key] instanceof Object ? null : "";
      });
    }
    function getUserData() {
      return { ...state };
    }
    return { state, setUserData, clearUserData, getUserData };
  });
  var lookup = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    62,
    0,
    62,
    0,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    0,
    0,
    0,
    0,
    63,
    0,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
  ];
  function base64Decode(source, target) {
    var sourceLength = source.length;
    var paddingLength = source[sourceLength - 2] === "=" ? 2 : source[sourceLength - 1] === "=" ? 1 : 0;
    var tmp;
    var byteIndex = 0;
    var baseLength = sourceLength - paddingLength & 4294967292;
    for (var i2 = 0; i2 < baseLength; i2 += 4) {
      tmp = lookup[source.charCodeAt(i2)] << 18 | lookup[source.charCodeAt(i2 + 1)] << 12 | lookup[source.charCodeAt(i2 + 2)] << 6 | lookup[source.charCodeAt(i2 + 3)];
      target[byteIndex++] = tmp >> 16 & 255;
      target[byteIndex++] = tmp >> 8 & 255;
      target[byteIndex++] = tmp & 255;
    }
    if (paddingLength === 1) {
      tmp = lookup[source.charCodeAt(i2)] << 10 | lookup[source.charCodeAt(i2 + 1)] << 4 | lookup[source.charCodeAt(i2 + 2)] >> 2;
      target[byteIndex++] = tmp >> 8 & 255;
      target[byteIndex++] = tmp & 255;
    }
    if (paddingLength === 2) {
      tmp = lookup[source.charCodeAt(i2)] << 2 | lookup[source.charCodeAt(i2 + 1)] >> 4;
      target[byteIndex++] = tmp & 255;
    }
  }
  const $inject_window_crypto = {
    getRandomValues(arr) {
      if (!(arr instanceof Int8Array || arr instanceof Uint8Array || arr instanceof Int16Array || arr instanceof Uint16Array || arr instanceof Int32Array || arr instanceof Uint32Array || arr instanceof Uint8ClampedArray)) {
        throw new Error("Expected an integer array");
      }
      if (arr.byteLength > 65536) {
        throw new Error("Can only request a maximum of 65536 bytes");
      }
      var crypto = requireNativePlugin("DCloud-Crypto");
      base64Decode(crypto.getRandomValues(arr.byteLength), new Uint8Array(
        arr.buffer,
        arr.byteOffset,
        arr.byteLength
      ));
      return arr;
    }
  };
  function getToken(roomName, userId) {
    return request({
      method: "post",
      url: "/livekit/token",
      data: { roomName, participantName: userId }
    });
  }
  var define_process_env_default = {};
  function _mergeNamespaces$1(n2, m2) {
    m2.forEach(function(e2) {
      e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k) {
        if (k !== "default" && !(k in n2)) {
          var d2 = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n2, k, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return e2[k];
            }
          });
        }
      });
    });
    return Object.freeze(n2);
  }
  var e$1 = Object.defineProperty;
  var h$1 = (i2, s2, t2) => s2 in i2 ? e$1(i2, s2, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: t2
  }) : i2[s2] = t2;
  var o$1 = (i2, s2, t2) => h$1(i2, typeof s2 != "symbol" ? s2 + "" : s2, t2);
  let _$1 = class _ {
    constructor() {
      o$1(this, "_locking");
      o$1(this, "_locks");
      this._locking = Promise.resolve(), this._locks = 0;
    }
    isLocked() {
      return this._locks > 0;
    }
    lock() {
      this._locks += 1;
      let s2;
      const t2 = new Promise((l2) => s2 = () => {
        this._locks -= 1, l2();
      }), c2 = this._locking.then(() => s2);
      return this._locking = this._locking.then(() => t2), c2;
    }
  };
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
  function getEnumType(enumObject) {
    const t2 = enumObject[enumTypeSymbol];
    assert(t2, "missing enum type on enum object");
    return t2;
  }
  function setEnumType(enumObject, typeName, values, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v2) => ({
      no: v2.no,
      name: v2.name,
      localName: enumObject[v2.no]
    })));
  }
  function makeEnumType(typeName, values, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values) {
      const n2 = normalizeEnumValue(value);
      normalValues.push(n2);
      names[value.name] = n2;
      numbers[value.no] = n2;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers[no];
      }
    };
  }
  function makeEnum(typeName, values, opt) {
    const enumObject = {};
    for (const value of values) {
      const n2 = normalizeEnumValue(value);
      enumObject[n2.localName] = n2.no;
      enumObject[n2.no] = n2.localName;
    }
    setEnumType(enumObject, typeName, values);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), {
      localName: value.name
    });
  }
  let Message$2 = class Message {
    /**
     * Compare with a message of the same type.
     * Note that this function disregards extensions and unknown fields.
     */
    equals(other) {
      return this.getType().runtime.util.equals(this.getType(), this, other);
    }
    /**
     * Create a deep copy.
     */
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes, options) {
      const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
      format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue, options) {
      const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
      format.readMessage(type, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString, options) {
      let json;
      try {
        json = JSON.parse(jsonString);
      } catch (e2) {
        throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(e2 instanceof Error ? e2.message : String(e2)));
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
    toBinary(options) {
      const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer2 = opt.writerFactory();
      bin.writeMessage(this, writer2, opt);
      return writer2.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options) {
      const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options) {
      var _a;
      const value = this.toJson(options);
      return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
    toJSON() {
      return this.toJson({
        emitDefaultValues: true
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  };
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a;
    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type = {
      [localName]: function(data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      }
    }[localName];
    Object.setPrototypeOf(type.prototype, new Message$2());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a2, b2) {
        return runtime.util.equals(type, a2, b2);
      }
    });
    return type;
  }
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b2 = this.buf[this.pos++];
      lowBits |= (b2 & 127) << shift;
      if ((b2 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b2 = this.buf[this.pos++];
      highBits |= (b2 & 127) << shift;
      if ((b2 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo, hi, bytes) {
    for (let i2 = 0; i2 < 28; i2 = i2 + 7) {
      const shift = lo >>> i2;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i2 = 3; i2 < 31; i2 = i2 + 7) {
      const shift = hi >>> i2;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  const TWO_PWR_32_DBL = 4294967296;
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
  }
  function uInt64ToString(lo, hi) {
    ({
      lo,
      hi
    } = toUnsigned(lo, hi));
    if (hi <= 2097151) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 16777215;
    const mid = (lo >>> 24 | hi << 8) & 16777215;
    const high = hi >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo, hi) {
    return {
      lo: lo >>> 0,
      hi: hi >>> 0
    };
  }
  function newBits(lo, hi) {
    return {
      lo: lo | 0,
      hi: hi | 0
    };
  }
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  const decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
  };
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i2 = 0; i2 < 9; i2++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b2 = this.buf[this.pos++];
    let result = b2 & 127;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 7;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 14;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 21;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 15) << 28;
    for (let readBytes = 5; (b2 & 128) !== 0 && readBytes < 10; readBytes++)
      b2 = this.buf[this.pos++];
    if ((b2 & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof define_process_env_default != "object" || define_process_env_default.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error("int64 invalid: ".concat(value));
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error("uint64 invalid: ".concat(value));
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), "int64 invalid: ".concat(value));
    const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), "uint64 invalid: ".concat(value));
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      }
    };
  }
  const protoInt64 = makeInt64Support();
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
  })(LongType || (LongType = {}));
  function scalarEquals(type, a2, b2) {
    if (a2 === b2) {
      return true;
    }
    if (type == ScalarType.BYTES) {
      if (!(a2 instanceof Uint8Array) || !(b2 instanceof Uint8Array)) {
        return false;
      }
      if (a2.length !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    }
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a2 == b2;
    }
    return false;
  }
  function scalarZeroValue(type, longType) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return longType == 0 ? protoInt64.zero : "0";
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function isScalarZeroValue(type, value) {
    switch (type) {
      case ScalarType.BOOL:
        return value === false;
      case ScalarType.STRING:
        return value === "";
      case ScalarType.BYTES:
        return value instanceof Uint8Array && !value.byteLength;
      default:
        return value == 0;
    }
  }
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));
  class BinaryWriter {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
      this.chunks = [];
      this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i2 = 0; i2 < this.chunks.length; i2++)
        len += this.chunks[i2].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i2 = 0; i2 < this.chunks.length; i2++) {
        bytes.set(this.chunks[i2], offset);
        offset += this.chunks[i2].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
      this.stack.push({
        chunks: this.chunks,
        buf: this.buf
      });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
      assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
      assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
      assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
      assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
      assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
      let tc = protoInt64.enc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
      let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
      varint64write(lo, hi, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
      let tc = protoInt64.uEnc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
  }
  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = varint64read;
      this.uint32 = varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
      let start = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        case WireType.Bit64:
          this.pos += 4;
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (; ; ) {
            const [fn, wt2] = this.tag();
            if (wt2 === WireType.EndGroup) {
              if (fieldNo !== void 0 && fn !== fieldNo) {
                throw new Error("invalid end group tag");
              }
              break;
            }
            this.skip(wt2, fn);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
      let [lo, hi] = this.varint64();
      let s2 = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s2;
      hi = hi >>> 1 ^ s2;
      return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
      let len = this.uint32(), start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  function makeExtension(runtime, typeName, extendee, field) {
    let fi;
    return {
      typeName,
      extendee,
      get field() {
        if (!fi) {
          const i2 = typeof field == "function" ? field() : field;
          i2.name = typeName.split(".").pop();
          i2.jsonName = "[".concat(typeName, "]");
          fi = runtime.util.newFieldList([i2]).list()[0];
        }
        return fi;
      },
      runtime
    };
  }
  function createExtensionContainer(extension) {
    const localName = extension.field.localName;
    const container = /* @__PURE__ */ Object.create(null);
    container[localName] = initExtensionField(extension);
    return [container, () => container[localName]];
  }
  function initExtensionField(ext) {
    const field = ext.field;
    if (field.repeated) {
      return [];
    }
    if (field.default !== void 0) {
      return field.default;
    }
    switch (field.kind) {
      case "enum":
        return field.T.values[0].no;
      case "scalar":
        return scalarZeroValue(field.T, field.L);
      case "message":
        const T2 = field.T, value = new T2();
        return T2.fieldWrapper ? T2.fieldWrapper.unwrapField(value) : value;
      case "map":
        throw "map fields are not allowed to be extensions";
    }
  }
  function filterUnknownFields(unknownFields, field) {
    if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
      for (let i2 = unknownFields.length - 1; i2 >= 0; --i2) {
        if (unknownFields[i2].no == field.no) {
          return [unknownFields[i2]];
        }
      }
      return [];
    }
    return unknownFields.filter((uf) => uf.no === field.no);
  }
  let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  let decTable = [];
  for (let i2 = 0; i2 < encTable.length; i2++)
    decTable[encTable[i2].charCodeAt(0)] = i2;
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  const protoBase64 = {
    /**
     * Decodes a base64 string to a byte array.
     *
     * - ignores white-space, including line breaks and tabs
     * - allows inner padding (can decode concatenated base64 strings)
     * - does not require padding
     * - understands base64url encoding:
     *   "-" instead of "+",
     *   "_" instead of "/",
     *   no padding
     */
    dec(base64Str) {
      let es2 = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es2 -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es2 -= 1;
      let bytes = new Uint8Array(es2), bytePos = 0, groupPos = 0, b2, p2 = 0;
      for (let i2 = 0; i2 < base64Str.length; i2++) {
        b2 = decTable[base64Str.charCodeAt(i2)];
        if (b2 === void 0) {
          switch (base64Str[i2]) {
            case "=":
              groupPos = 0;
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            default:
              throw Error("invalid base64 string.");
          }
        }
        switch (groupPos) {
          case 0:
            p2 = b2;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p2 << 2 | (b2 & 48) >> 4;
            p2 = b2;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p2 & 15) << 4 | (b2 & 60) >> 2;
            p2 = b2;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p2 & 3) << 6 | b2;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error("invalid base64 string.");
      return bytes.subarray(0, bytePos);
    },
    /**
     * Encode a byte array to a base64 string.
     */
    enc(bytes) {
      let base64 = "", groupPos = 0, b2, p2 = 0;
      for (let i2 = 0; i2 < bytes.length; i2++) {
        b2 = bytes[i2];
        switch (groupPos) {
          case 0:
            base64 += encTable[b2 >> 2];
            p2 = (b2 & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p2 | b2 >> 4];
            p2 = (b2 & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p2 | b2 >> 6];
            base64 += encTable[b2 & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += encTable[p2];
        base64 += "=";
        if (groupPos == 1)
          base64 += "=";
      }
      return base64;
    }
  };
  function getExtension(message, extension, options) {
    assertExtendee(extension, message);
    const opt = extension.runtime.bin.makeReadOptions(options);
    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
    const [container, get2] = createExtensionContainer(extension);
    for (const uf of ufs) {
      extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
    }
    return get2();
  }
  function setExtension(message, extension, value, options) {
    assertExtendee(extension, message);
    const readOpt = extension.runtime.bin.makeReadOptions(options);
    const writeOpt = extension.runtime.bin.makeWriteOptions(options);
    if (hasExtension(message, extension)) {
      const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
      message.getType().runtime.bin.discardUnknownFields(message);
      for (const uf of ufs) {
        message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
      }
    }
    const writer2 = writeOpt.writerFactory();
    let f2 = extension.field;
    if (!f2.opt && !f2.repeated && (f2.kind == "enum" || f2.kind == "scalar")) {
      f2 = Object.assign(Object.assign({}, extension.field), {
        opt: true
      });
    }
    extension.runtime.bin.writeField(f2, value, writer2, writeOpt);
    const reader = readOpt.readerFactory(writer2.finish());
    while (reader.pos < reader.len) {
      const [no, wireType] = reader.tag();
      const data = reader.skip(wireType, no);
      message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
    }
  }
  function hasExtension(message, extension) {
    const messageType = message.getType();
    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
  }
  function assertExtendee(extension, message) {
    assert(extension.extendee.typeName == message.getType().typeName, "extension ".concat(extension.typeName, " can only be applied to message ").concat(extension.extendee.typeName));
  }
  function isFieldSet(field, target) {
    const localName = field.localName;
    if (field.repeated) {
      return target[localName].length > 0;
    }
    if (field.oneof) {
      return target[field.oneof.localName].case === localName;
    }
    switch (field.kind) {
      case "enum":
      case "scalar":
        if (field.opt || field.req) {
          return target[localName] !== void 0;
        }
        if (field.kind == "enum") {
          return target[localName] !== field.T.values[0].no;
        }
        return !isScalarZeroValue(field.T, target[localName]);
      case "message":
        return target[localName] !== void 0;
      case "map":
        return Object.keys(target[localName]).length > 0;
    }
  }
  function clearField(field, target) {
    const localName = field.localName;
    const implicitPresence = !field.opt && !field.req;
    if (field.repeated) {
      target[localName] = [];
    } else if (field.oneof) {
      target[field.oneof.localName] = {
        case: void 0
      };
    } else {
      switch (field.kind) {
        case "map":
          target[localName] = {};
          break;
        case "enum":
          target[localName] = implicitPresence ? field.T.values[0].no : void 0;
          break;
        case "scalar":
          target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
          break;
        case "message":
          target[localName] = void 0;
          break;
      }
    }
  }
  function isMessage(arg, type) {
    if (arg === null || typeof arg != "object") {
      return false;
    }
    if (!Object.getOwnPropertyNames(Message$2.prototype).every((m2) => m2 in arg && typeof arg[m2] == "function")) {
      return false;
    }
    const actualType = arg.getType();
    if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
      return false;
    }
    return type === void 0 ? true : actualType.typeName == type.typeName;
  }
  function wrapField(type, value) {
    if (isMessage(value) || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  ({
    "google.protobuf.DoubleValue": ScalarType.DOUBLE,
    "google.protobuf.FloatValue": ScalarType.FLOAT,
    "google.protobuf.Int64Value": ScalarType.INT64,
    "google.protobuf.UInt64Value": ScalarType.UINT64,
    "google.protobuf.Int32Value": ScalarType.INT32,
    "google.protobuf.UInt32Value": ScalarType.UINT32,
    "google.protobuf.BoolValue": ScalarType.BOOL,
    "google.protobuf.StringValue": ScalarType.STRING,
    "google.protobuf.BytesValue": ScalarType.BYTES
  });
  const jsonReadDefaults = {
    ignoreUnknownFields: false
  };
  const jsonWriteDefaults = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  function makeReadOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  const tokenNull = Symbol();
  const tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions: makeReadOptions$1,
      makeWriteOptions: makeWriteOptions$1,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error("cannot decode message ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = /* @__PURE__ */ new Map();
        const registry = options.typeRegistry;
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (field) {
            if (field.oneof) {
              if (jsonValue === null && field.kind == "scalar") {
                continue;
              }
              const seen = oneofSeen.get(field.oneof);
              if (seen !== void 0) {
                throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: multiple keys for oneof "').concat(field.oneof.name, '" present: "').concat(seen, '", "').concat(jsonKey, '"'));
              }
              oneofSeen.set(field.oneof, jsonKey);
            }
            readField$1(message, jsonValue, field, options, type);
          } else {
            let found = false;
            if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
              const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
              if (ext && ext.extendee.typeName == type.typeName) {
                found = true;
                const [container, get2] = createExtensionContainer(ext);
                readField$1(container, jsonValue, ext.field, options, ext);
                setExtension(message, ext, get2(), options);
              }
            }
            if (!found && !options.ignoreUnknownFields) {
              throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: key "').concat(jsonKey, '" is unknown'));
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (field of type.fields.byNumber()) {
            if (!isFieldSet(field, message)) {
              if (field.req) {
                throw "required field not set";
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
            const jsonValue = writeField$1(field, value, options);
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
          const registry = options.typeRegistry;
          if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
            for (const uf of type.runtime.bin.listUnknownFields(message)) {
              const ext = registry.findExtensionFor(type.typeName, uf.no);
              if (ext && hasExtension(message, ext)) {
                const value = getExtension(message, ext, options);
                const jsonValue = writeField$1(ext.field, value, options);
                if (jsonValue !== void 0) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          }
        } catch (e2) {
          const m2 = field ? "cannot encode field ".concat(type.typeName, ".").concat(field.name, " to JSON") : "cannot encode message ".concat(type.typeName, " to JSON");
          const r2 = e2 instanceof Error ? e2.message : String(e2);
          throw new Error(m2 + (r2.length > 0 ? ": ".concat(r2) : ""));
        }
        return json;
      },
      readScalar(type, json, longType) {
        return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
      },
      writeScalar(type, value, emitDefaultValues) {
        if (value === void 0) {
          return void 0;
        }
        if (emitDefaultValues || isScalarZeroValue(type, value)) {
          return writeScalar$1(type, value);
        }
        return void 0;
      },
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : '"'.concat(json.split('"').join('\\"'), '"');
      default:
        return String(json);
    }
  }
  function readField$1(target, jsonValue, field, options, parentType) {
    let localName = field.localName;
    if (field.repeated) {
      assert(field.kind != "map");
      if (jsonValue === null) {
        return;
      }
      if (!Array.isArray(jsonValue)) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
      }
      const targetArray = target[localName];
      for (const jsonItem of jsonValue) {
        if (jsonItem === null) {
          throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem)));
        }
        switch (field.kind) {
          case "message":
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case "enum":
            const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case "scalar":
            try {
              targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));
            } catch (e2) {
              let m2 = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem));
              if (e2 instanceof Error && e2.message.length > 0) {
                m2 += ": ".concat(e2.message);
              }
              throw new Error(m2);
            }
            break;
        }
      }
    } else if (field.kind == "map") {
      if (jsonValue === null) {
        return;
      }
      if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
      }
      const targetMap = target[localName];
      for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
        if (jsonMapValue === null) {
          throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: map value null"));
        }
        let key;
        try {
          key = readMapKey(field.K, jsonMapKey);
        } catch (e2) {
          let m2 = "cannot decode map key for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
          if (e2 instanceof Error && e2.message.length > 0) {
            m2 += ": ".concat(e2.message);
          }
          throw new Error(m2);
        }
        switch (field.V.kind) {
          case "message":
            targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
            break;
          case "enum":
            const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetMap[key] = enumValue;
            }
            break;
          case "scalar":
            try {
              targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);
            } catch (e2) {
              let m2 = "cannot decode map value for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
              if (e2 instanceof Error && e2.message.length > 0) {
                m2 += ": ".concat(e2.message);
              }
              throw new Error(m2);
            }
            break;
        }
      }
    } else {
      if (field.oneof) {
        target = target[field.oneof.localName] = {
          case: localName
        };
        localName = "value";
      }
      switch (field.kind) {
        case "message":
          const messageType = field.T;
          if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
            return;
          }
          let currentValue = target[localName];
          if (isMessage(currentValue)) {
            currentValue.fromJson(jsonValue, options);
          } else {
            target[localName] = currentValue = messageType.fromJson(jsonValue, options);
            if (messageType.fieldWrapper && !field.oneof) {
              target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
            }
          }
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
          switch (enumValue) {
            case tokenNull:
              clearField(field, target);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              target[localName] = enumValue;
              break;
          }
          break;
        case "scalar":
          try {
            const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);
            switch (scalarValue) {
              case tokenNull:
                clearField(field, target);
                break;
              default:
                target[localName] = scalarValue;
                break;
            }
          } catch (e2) {
            let m2 = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
            if (e2 instanceof Error && e2.message.length > 0) {
              m2 += ": ".concat(e2.message);
            }
            throw new Error(m2);
          }
          break;
      }
    }
  }
  function readMapKey(type, json) {
    if (type === ScalarType.BOOL) {
      switch (json) {
        case "true":
          json = true;
          break;
        case "false":
          json = false;
          break;
      }
    }
    return readScalar$1(type, json, LongType.BIGINT, true).toString();
  }
  function readScalar$1(type, json, longType, nullAsZeroValue) {
    if (json === null) {
      if (nullAsZeroValue) {
        return scalarZeroValue(type, longType);
      }
      return tokenNull;
    }
    switch (type) {
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === "NaN")
          return Number.NaN;
        if (json === "Infinity")
          return Number.POSITIVE_INFINITY;
        if (json === "-Infinity")
          return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type == ScalarType.FLOAT)
          assertFloat32(float);
        return float;
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let int32;
        if (typeof json == "number")
          int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length)
            int32 = Number(json);
        }
        if (int32 === void 0)
          break;
        if (type == ScalarType.UINT32 || type == ScalarType.FIXED32)
          assertUInt32(int32);
        else
          assertInt32(int32);
        return int32;
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const long = protoInt64.parse(json);
        return longType ? long.toString() : long;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const uLong = protoInt64.uParse(json);
        return longType ? uLong.toString() : uLong;
      case ScalarType.BOOL:
        if (typeof json !== "boolean")
          break;
        return json;
      case ScalarType.STRING:
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e2) {
          throw new Error("invalid UTF8");
        }
        return json;
      case ScalarType.BYTES:
        if (json === "")
          return new Uint8Array(0);
        if (typeof json !== "string")
          break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
      if (type.typeName == "google.protobuf.NullValue") {
        return 0;
      }
      return nullAsZeroValue ? type.values[0].no : tokenNull;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type.findName(json);
        if (value !== void 0) {
          return value.no;
        }
        if (ignoreUnknownFields) {
          return tokenIgnoredUnknownEnum;
        }
        break;
    }
    throw new Error("cannot decode enum ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
  }
  function canEmitFieldDefaultValue(field) {
    if (field.repeated || field.kind == "map") {
      return true;
    }
    if (field.oneof) {
      return false;
    }
    if (field.kind == "message") {
      return false;
    }
    if (field.opt || field.req) {
      return false;
    }
    return true;
  }
  function writeField$1(field, value, options) {
    if (field.kind == "map") {
      assert(typeof value == "object" && value != null);
      const jsonObj = {};
      const entries = Object.entries(value);
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue);
          }
          break;
        case "message":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = entryValue.toJson(options);
          }
          break;
        case "enum":
          const enumType = field.V.T;
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
          }
          break;
      }
      return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
    }
    if (field.repeated) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(writeScalar$1(field.T, value[i2]));
          }
          break;
        case "enum":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(writeEnum(field.T, value[i2], options.enumAsInteger));
          }
          break;
        case "message":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(value[i2].toJson(options));
          }
          break;
      }
      return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
    }
    switch (field.kind) {
      case "scalar":
        return writeScalar$1(field.T, value);
      case "enum":
        return writeEnum(field.T, value, options.enumAsInteger);
      case "message":
        return wrapField(field.T, value).toJson(options);
    }
  }
  function writeEnum(type, value, enumAsInteger) {
    var _a;
    assert(typeof value == "number");
    if (type.typeName == "google.protobuf.NullValue") {
      return null;
    }
    if (enumAsInteger) {
      return value;
    }
    const val = type.findNumber(value);
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
  }
  function writeScalar$1(type, value) {
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert(typeof value == "number");
        return value;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      case ScalarType.STRING:
        assert(typeof value == "string");
        return value;
      case ScalarType.BOOL:
        assert(typeof value == "boolean");
        return value;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return value.toString();
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        return protoBase64.enc(value);
    }
  }
  const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
  const readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  const writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter()
  };
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(message) {
        var _a;
        return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer2) {
        const m2 = message;
        const c2 = m2[unknownFieldsSymbol];
        if (c2) {
          for (const f2 of c2) {
            writer2.tag(f2.no, f2.wireType).raw(f2.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data) {
        const m2 = message;
        if (!Array.isArray(m2[unknownFieldsSymbol])) {
          m2[unknownFieldsSymbol] = [];
        }
        m2[unknownFieldsSymbol].push({
          no,
          wireType,
          data
        });
      },
      readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
        const type = message.getType();
        const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
        let fieldNo, wireType;
        while (reader.pos < end) {
          [fieldNo, wireType] = reader.tag();
          if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
            break;
          }
          const field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType, fieldNo);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          readField(message, reader, field, wireType, options);
        }
        if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
        (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
          throw new Error("invalid end group tag");
        }
      },
      readField,
      writeMessage(message, writer2, options) {
        const type = message.getType();
        for (const field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error("cannot encode field ".concat(type.typeName, ".").concat(field.name, " to binary: required field not set"));
            }
            continue;
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          writeField(field, value, writer2, options);
        }
        if (options.writeUnknownFields) {
          this.writeUnknownFields(message, writer2);
        }
        return writer2;
      },
      writeField(field, value, writer2, options) {
        if (value === void 0) {
          return void 0;
        }
        writeField(field, value, writer2, options);
      }
    };
  }
  function readField(target, reader, field, wireType, options) {
    let {
      repeated,
      localName
    } = field;
    if (field.oneof) {
      target = target[field.oneof.localName];
      if (target.case != localName) {
        delete target.value;
      }
      target.case = localName;
      localName = "value";
    }
    switch (field.kind) {
      case "scalar":
      case "enum":
        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        let read = readScalar;
        if (field.kind == "scalar" && field.L > 0) {
          read = readScalarLTString;
        }
        if (repeated) {
          let arr = target[localName];
          const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
          if (isPacked) {
            let e2 = reader.uint32() + reader.pos;
            while (reader.pos < e2) {
              arr.push(read(reader, scalarType));
            }
          } else {
            arr.push(read(reader, scalarType));
          }
        } else {
          target[localName] = read(reader, scalarType);
        }
        break;
      case "message":
        const messageType = field.T;
        if (repeated) {
          target[localName].push(readMessageField(reader, new messageType(), options, field));
        } else {
          if (isMessage(target[localName])) {
            readMessageField(reader, target[localName], options, field);
          } else {
            target[localName] = readMessageField(reader, new messageType(), options, field);
            if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
              target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
            }
          }
        }
        break;
      case "map":
        let [mapKey, mapVal] = readMapEntry(field, reader, options);
        target[localName][mapKey] = mapVal;
        break;
    }
  }
  function readMessageField(reader, message, options, field) {
    const format = message.getType().runtime.bin;
    const delimited = field === null || field === void 0 ? void 0 : field.delimited;
    format.readMessage(
      message,
      reader,
      delimited ? field.no : reader.uint32(),
      // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      options,
      delimited
    );
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      const [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options, void 0);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      key = scalarZeroValue(field.K, LongType.BIGINT);
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarZeroValue(field.V.T, LongType.BIGINT);
          break;
        case "enum":
          val = field.V.T.values[0].no;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalarLTString(reader, type) {
    const v2 = readScalar(reader, type);
    return typeof v2 == "bigint" ? v2.toString() : v2;
  }
  function readScalar(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeField(field, value, writer2, options) {
    assert(value !== void 0);
    const repeated = field.repeated;
    switch (field.kind) {
      case "scalar":
      case "enum":
        let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (repeated) {
          assert(Array.isArray(value));
          if (field.packed) {
            writePacked(writer2, scalarType, field.no, value);
          } else {
            for (const item of value) {
              writeScalar(writer2, scalarType, field.no, item);
            }
          }
        } else {
          writeScalar(writer2, scalarType, field.no, value);
        }
        break;
      case "message":
        if (repeated) {
          assert(Array.isArray(value));
          for (const item of value) {
            writeMessageField(writer2, options, field, item);
          }
        } else {
          writeMessageField(writer2, options, field, value);
        }
        break;
      case "map":
        assert(typeof value == "object" && value != null);
        for (const [key, val] of Object.entries(value)) {
          writeMapEntry(writer2, options, field, key, val);
        }
        break;
    }
  }
  function writeMapEntry(writer2, options, field, key, value) {
    writer2.tag(field.no, WireType.LengthDelimited);
    writer2.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar(writer2, field.K, 1, keyValue);
    switch (field.V.kind) {
      case "scalar":
        writeScalar(writer2, field.V.T, 2, value);
        break;
      case "enum":
        writeScalar(writer2, ScalarType.INT32, 2, value);
        break;
      case "message":
        assert(value !== void 0);
        writer2.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
        break;
    }
    writer2.join();
  }
  function writeMessageField(writer2, options, field, value) {
    const message = wrapField(field.T, value);
    if (field.delimited)
      writer2.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
    else
      writer2.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
  }
  function writeScalar(writer2, type, fieldNo, value) {
    assert(value !== void 0);
    let [wireType, method] = scalarTypeInfo(type);
    writer2.tag(fieldNo, wireType)[method](value);
  }
  function writePacked(writer2, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer2.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i2 = 0; i2 < value.length; i2++) {
      writer2[method](value[i2]);
    }
    writer2.join();
  }
  function scalarTypeInfo(type) {
    let wireType = WireType.Varint;
    switch (type) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method];
  }
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === void 0) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName = member.localName, t2 = target, s2 = source;
          if (s2[localName] == null) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk = s2[localName].case;
              if (sk === void 0) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s2[localName].value;
              if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t2[localName] = {
                case: sk,
                value: val
              };
              break;
            case "scalar":
            case "enum":
              let copy = s2[localName];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t2[localName] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k, v2] of Object.entries(s2[localName])) {
                      t2[localName][k] = toU8Arr(v2);
                    }
                  } else {
                    Object.assign(t2[localName], s2[localName]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k of Object.keys(s2[localName])) {
                    let val2 = s2[localName][k];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t2[localName][k] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt2 = member.T;
              if (member.repeated) {
                t2[localName] = s2[localName].map((val2) => isMessage(val2, mt2) ? val2 : new mt2(val2));
              } else {
                const val2 = s2[localName];
                if (mt2.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt2.typeName === "google.protobuf.BytesValue"
                  ) {
                    t2[localName] = toU8Arr(val2);
                  } else {
                    t2[localName] = val2;
                  }
                } else {
                  t2[localName] = isMessage(val2, mt2) ? val2 : new mt2(val2);
                }
              }
              break;
          }
        }
      },
      // TODO use isFieldSet() here to support future field presence
      equals(type, a2, b2) {
        if (a2 === b2) {
          return true;
        }
        if (!a2 || !b2) {
          return false;
        }
        return type.fields.byMember().every((m2) => {
          const va = a2[m2.localName];
          const vb = b2[m2.localName];
          if (m2.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            switch (m2.kind) {
              case "message":
                return va.every((a22, i2) => m2.T.equals(a22, vb[i2]));
              case "scalar":
                return va.every((a22, i2) => scalarEquals(m2.T, a22, vb[i2]));
              case "enum":
                return va.every((a22, i2) => scalarEquals(ScalarType.INT32, a22, vb[i2]));
            }
            throw new Error("repeated cannot contain ".concat(m2.kind));
          }
          switch (m2.kind) {
            case "message":
              return m2.T.equals(va, vb);
            case "enum":
              return scalarEquals(ScalarType.INT32, va, vb);
            case "scalar":
              return scalarEquals(m2.T, va, vb);
            case "oneof":
              if (va.case !== vb.case) {
                return false;
              }
              const s2 = m2.findField(va.case);
              if (s2 === void 0) {
                return true;
              }
              switch (s2.kind) {
                case "message":
                  return s2.T.equals(va.value, vb.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case "scalar":
                  return scalarEquals(s2.T, va.value, vb.value);
              }
              throw new Error("oneof cannot contain ".concat(s2.kind));
            case "map":
              const keys = Object.keys(va).concat(Object.keys(vb));
              switch (m2.V.kind) {
                case "message":
                  const messageType = m2.V.T;
                  return keys.every((k) => messageType.equals(va[k], vb[k]));
                case "enum":
                  return keys.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
                case "scalar":
                  const scalarType = m2.V.T;
                  return keys.every((k) => scalarEquals(scalarType, va[k], vb[k]));
              }
              break;
          }
        });
      },
      // TODO use isFieldSet() here to support future field presence
      clone(message) {
        const type = message.getType(), target = new type(), any = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any[member.localName];
            for (const [key, v2] of Object.entries(source)) {
              copy[key] = cloneSingularField(v2);
            }
          } else if (member.kind == "oneof") {
            const f2 = member.findField(source.case);
            copy = f2 ? {
              case: source.case,
              value: cloneSingularField(source.value)
            } : {
              case: void 0
            };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
        for (const uf of type.runtime.bin.listUnknownFields(message)) {
          type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (isMessage(value)) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c2 = new Uint8Array(value.byteLength);
      c2.set(value);
      return c2;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }
  function makeProtoRuntime(syntax, newFieldList, initFields) {
    return {
      syntax,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList,
        initFields
      }),
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(typeName, extendee, field) {
        return makeExtension(this, typeName, extendee, field);
      }
    };
  }
  class InternalFieldList {
    constructor(fields, normalizer) {
      this._fields = fields;
      this._normalizer = normalizer;
    }
    findJsonName(jsonName) {
      if (!this.jsonNames) {
        const t2 = {};
        for (const f2 of this.list()) {
          t2[f2.jsonName] = t2[f2.name] = f2;
        }
        this.jsonNames = t2;
      }
      return this.jsonNames[jsonName];
    }
    find(fieldNo) {
      if (!this.numbers) {
        const t2 = {};
        for (const f2 of this.list()) {
          t2[f2.no] = f2;
        }
        this.numbers = t2;
      }
      return this.numbers[fieldNo];
    }
    list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
    byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list().concat().sort((a2, b2) => a2.no - b2.no);
      }
      return this.numbersAsc;
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const a2 = this.members;
        let o2;
        for (const f2 of this.list()) {
          if (f2.oneof) {
            if (f2.oneof !== o2) {
              o2 = f2.oneof;
              a2.push(o2);
            }
          } else {
            a2.push(f2);
          }
        }
      }
      return this.members;
    }
  }
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  const fieldJsonName = protoCamelCase;
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b2 = [];
    for (let i2 = 0; i2 < snakeCase.length; i2++) {
      let c2 = snakeCase.charAt(i2);
      switch (c2) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b2.push(c2);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c2 = c2.toUpperCase();
          }
          b2.push(c2);
          break;
      }
    }
    return b2.join("");
  }
  const reservedObjectProperties = /* @__PURE__ */ new Set([
    // names reserved by JavaScript
    "constructor",
    "toString",
    "toJSON",
    "valueOf"
  ]);
  const reservedMessageProperties = /* @__PURE__ */ new Set([
    // names reserved by the runtime
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    // names reserved by the runtime for the future
    "toObject"
  ]);
  const fallback = (name) => "".concat(name, "$");
  const safeMessageProperty = (name) => {
    if (reservedMessageProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  const safeObjectProperty = (name) => {
    if (reservedObjectProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  class InternalOneofInfo {
    constructor(name) {
      this.kind = "oneof";
      this.repeated = false;
      this.packed = false;
      this.opt = false;
      this.req = false;
      this.default = void 0;
      this.fields = [];
      this.name = name;
      this.localName = localOneofName(name);
    }
    addField(field) {
      assert(field.oneof === this, "field ".concat(field.name, " not one of ").concat(this.name));
      this.fields.push(field);
    }
    findField(localName) {
      if (!this._lookup) {
        this._lookup = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < this.fields.length; i2++) {
          this._lookup[this.fields[i2].localName] = this.fields[i2];
        }
      }
      return this._lookup[localName];
    }
  }
  function normalizeFieldInfos(fieldInfos, packedByDefault) {
    var _a, _b, _c, _d, _e2, _f;
    const r2 = [];
    let o2;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f2 = field;
      f2.localName = localFieldName(field.name, field.oneof !== void 0);
      f2.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f2.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      if (field.kind == "scalar") {
        f2.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
      }
      f2.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
      f2.req = (_e2 = field.req) !== null && _e2 !== void 0 ? _e2 : false;
      f2.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
      if (field.packed === void 0) {
        {
          f2.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
        }
      }
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o2 || o2.name != ooname) {
          o2 = new InternalOneofInfo(ooname);
        }
        f2.oneof = o2;
        o2.addField(f2);
      }
      r2.push(f2);
    }
    return r2;
  }
  const proto3 = makeProtoRuntime(
    "proto3",
    (fields) => {
      return new InternalFieldList(fields, (source) => normalizeFieldInfos(source));
    },
    // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        if (member.opt) {
          continue;
        }
        const name = member.localName, t2 = target;
        if (member.repeated) {
          t2[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t2[name] = {
              case: void 0
            };
            break;
          case "enum":
            t2[name] = 0;
            break;
          case "map":
            t2[name] = {};
            break;
          case "scalar":
            t2[name] = scalarZeroValue(member.T, member.L);
            break;
        }
      }
    }
  );
  class Timestamp extends Message$2 {
    constructor(data) {
      super();
      this.seconds = protoInt64.zero;
      this.nanos = 0;
      proto3.util.initPartial(data, this);
    }
    fromJson(json, options) {
      if (typeof json !== "string") {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(json)));
      }
      const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches) {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
      }
      const ms2 = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
      if (Number.isNaN(ms2)) {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
      }
      if (ms2 < Date.parse("0001-01-01T00:00:00Z") || ms2 > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
      }
      this.seconds = protoInt64.parse(ms2 / 1e3);
      this.nanos = 0;
      if (matches[7]) {
        this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
      }
      return this;
    }
    toJson(options) {
      const ms2 = Number(this.seconds) * 1e3;
      if (ms2 < Date.parse("0001-01-01T00:00:00Z") || ms2 > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
      }
      if (this.nanos < 0) {
        throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
      }
      let z2 = "Z";
      if (this.nanos > 0) {
        const nanosStr = (this.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000") {
          z2 = "." + nanosStr.substring(0, 3) + "Z";
        } else if (nanosStr.substring(6) === "000") {
          z2 = "." + nanosStr.substring(0, 6) + "Z";
        } else {
          z2 = "." + nanosStr + "Z";
        }
      }
      return new Date(ms2).toISOString().replace(".000Z", z2);
    }
    toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
    }
    static now() {
      return Timestamp.fromDate(/* @__PURE__ */ new Date());
    }
    static fromDate(date) {
      const ms2 = date.getTime();
      return new Timestamp({
        seconds: protoInt64.parse(Math.floor(ms2 / 1e3)),
        nanos: ms2 % 1e3 * 1e6
      });
    }
    static fromBinary(bytes, options) {
      return new Timestamp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Timestamp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Timestamp().fromJsonString(jsonString, options);
    }
    static equals(a2, b2) {
      return proto3.util.equals(Timestamp, a2, b2);
    }
  }
  Timestamp.runtime = proto3;
  Timestamp.typeName = "google.protobuf.Timestamp";
  Timestamp.fields = proto3.util.newFieldList(() => [{
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  const MetricsBatch = /* @__PURE__ */ proto3.makeMessageType("livekit.MetricsBatch", () => [{
    no: 1,
    name: "timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "normalized_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "str_data",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "time_series",
    kind: "message",
    T: TimeSeriesMetric,
    repeated: true
  }, {
    no: 5,
    name: "events",
    kind: "message",
    T: EventMetric,
    repeated: true
  }]);
  const TimeSeriesMetric = /* @__PURE__ */ proto3.makeMessageType("livekit.TimeSeriesMetric", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "participant_identity",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "track_sid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "samples",
    kind: "message",
    T: MetricSample,
    repeated: true
  }, {
    no: 5,
    name: "rid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const MetricSample = /* @__PURE__ */ proto3.makeMessageType("livekit.MetricSample", () => [{
    no: 1,
    name: "timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "normalized_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "value",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }]);
  const EventMetric = /* @__PURE__ */ proto3.makeMessageType("livekit.EventMetric", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "participant_identity",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "track_sid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "start_timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 5,
    name: "end_timestamp_ms",
    kind: "scalar",
    T: 3,
    opt: true
  }, {
    no: 6,
    name: "normalized_start_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 7,
    name: "normalized_end_timestamp",
    kind: "message",
    T: Timestamp,
    opt: true
  }, {
    no: 8,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "rid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const BackupCodecPolicy$1 = /* @__PURE__ */ proto3.makeEnum("livekit.BackupCodecPolicy", [{
    no: 0,
    name: "REGRESSION"
  }, {
    no: 1,
    name: "SIMULCAST"
  }]);
  const TrackType = /* @__PURE__ */ proto3.makeEnum("livekit.TrackType", [{
    no: 0,
    name: "AUDIO"
  }, {
    no: 1,
    name: "VIDEO"
  }, {
    no: 2,
    name: "DATA"
  }]);
  const TrackSource = /* @__PURE__ */ proto3.makeEnum("livekit.TrackSource", [{
    no: 0,
    name: "UNKNOWN"
  }, {
    no: 1,
    name: "CAMERA"
  }, {
    no: 2,
    name: "MICROPHONE"
  }, {
    no: 3,
    name: "SCREEN_SHARE"
  }, {
    no: 4,
    name: "SCREEN_SHARE_AUDIO"
  }]);
  const VideoQuality$1 = /* @__PURE__ */ proto3.makeEnum("livekit.VideoQuality", [{
    no: 0,
    name: "LOW"
  }, {
    no: 1,
    name: "MEDIUM"
  }, {
    no: 2,
    name: "HIGH"
  }, {
    no: 3,
    name: "OFF"
  }]);
  const ConnectionQuality$1 = /* @__PURE__ */ proto3.makeEnum("livekit.ConnectionQuality", [{
    no: 0,
    name: "POOR"
  }, {
    no: 1,
    name: "GOOD"
  }, {
    no: 2,
    name: "EXCELLENT"
  }, {
    no: 3,
    name: "LOST"
  }]);
  const ClientConfigSetting = /* @__PURE__ */ proto3.makeEnum("livekit.ClientConfigSetting", [{
    no: 0,
    name: "UNSET"
  }, {
    no: 1,
    name: "DISABLED"
  }, {
    no: 2,
    name: "ENABLED"
  }]);
  const DisconnectReason = /* @__PURE__ */ proto3.makeEnum("livekit.DisconnectReason", [{
    no: 0,
    name: "UNKNOWN_REASON"
  }, {
    no: 1,
    name: "CLIENT_INITIATED"
  }, {
    no: 2,
    name: "DUPLICATE_IDENTITY"
  }, {
    no: 3,
    name: "SERVER_SHUTDOWN"
  }, {
    no: 4,
    name: "PARTICIPANT_REMOVED"
  }, {
    no: 5,
    name: "ROOM_DELETED"
  }, {
    no: 6,
    name: "STATE_MISMATCH"
  }, {
    no: 7,
    name: "JOIN_FAILURE"
  }, {
    no: 8,
    name: "MIGRATION"
  }, {
    no: 9,
    name: "SIGNAL_CLOSE"
  }, {
    no: 10,
    name: "ROOM_CLOSED"
  }, {
    no: 11,
    name: "USER_UNAVAILABLE"
  }, {
    no: 12,
    name: "USER_REJECTED"
  }, {
    no: 13,
    name: "SIP_TRUNK_FAILURE"
  }]);
  const ReconnectReason = /* @__PURE__ */ proto3.makeEnum("livekit.ReconnectReason", [{
    no: 0,
    name: "RR_UNKNOWN"
  }, {
    no: 1,
    name: "RR_SIGNAL_DISCONNECTED"
  }, {
    no: 2,
    name: "RR_PUBLISHER_FAILED"
  }, {
    no: 3,
    name: "RR_SUBSCRIBER_FAILED"
  }, {
    no: 4,
    name: "RR_SWITCH_CANDIDATE"
  }]);
  const SubscriptionError = /* @__PURE__ */ proto3.makeEnum("livekit.SubscriptionError", [{
    no: 0,
    name: "SE_UNKNOWN"
  }, {
    no: 1,
    name: "SE_CODEC_UNSUPPORTED"
  }, {
    no: 2,
    name: "SE_TRACK_NOTFOUND"
  }]);
  const AudioTrackFeature = /* @__PURE__ */ proto3.makeEnum("livekit.AudioTrackFeature", [{
    no: 0,
    name: "TF_STEREO"
  }, {
    no: 1,
    name: "TF_NO_DTX"
  }, {
    no: 2,
    name: "TF_AUTO_GAIN_CONTROL"
  }, {
    no: 3,
    name: "TF_ECHO_CANCELLATION"
  }, {
    no: 4,
    name: "TF_NOISE_SUPPRESSION"
  }, {
    no: 5,
    name: "TF_ENHANCED_NOISE_CANCELLATION"
  }]);
  const Room$1 = /* @__PURE__ */ proto3.makeMessageType("livekit.Room", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "empty_timeout",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 14,
    name: "departure_timeout",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "max_participants",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "creation_time",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 15,
    name: "creation_time_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 6,
    name: "turn_password",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "enabled_codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 8,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "num_participants",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 11,
    name: "num_publishers",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 10,
    name: "active_recording",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 13,
    name: "version",
    kind: "message",
    T: TimedVersion
  }]);
  const Codec = /* @__PURE__ */ proto3.makeMessageType("livekit.Codec", () => [{
    no: 1,
    name: "mime",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "fmtp_line",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ParticipantPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantPermission", () => [{
    no: 1,
    name: "can_subscribe",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "can_publish",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "can_publish_data",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 9,
    name: "can_publish_sources",
    kind: "enum",
    T: proto3.getEnumType(TrackSource),
    repeated: true
  }, {
    no: 7,
    name: "hidden",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "recorder",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 10,
    name: "can_update_metadata",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 11,
    name: "agent",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 12,
    name: "can_subscribe_metrics",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const ParticipantInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "state",
    kind: "enum",
    T: proto3.getEnumType(ParticipantInfo_State)
  }, {
    no: 4,
    name: "tracks",
    kind: "message",
    T: TrackInfo,
    repeated: true
  }, {
    no: 5,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "joined_at",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 17,
    name: "joined_at_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 9,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "version",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 11,
    name: "permission",
    kind: "message",
    T: ParticipantPermission
  }, {
    no: 12,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 13,
    name: "is_publisher",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 14,
    name: "kind",
    kind: "enum",
    T: proto3.getEnumType(ParticipantInfo_Kind)
  }, {
    no: 15,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 16,
    name: "disconnect_reason",
    kind: "enum",
    T: proto3.getEnumType(DisconnectReason)
  }]);
  const ParticipantInfo_State = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.State", [{
    no: 0,
    name: "JOINING"
  }, {
    no: 1,
    name: "JOINED"
  }, {
    no: 2,
    name: "ACTIVE"
  }, {
    no: 3,
    name: "DISCONNECTED"
  }]);
  const ParticipantInfo_Kind = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.Kind", [{
    no: 0,
    name: "STANDARD"
  }, {
    no: 1,
    name: "INGRESS"
  }, {
    no: 2,
    name: "EGRESS"
  }, {
    no: 3,
    name: "SIP"
  }, {
    no: 4,
    name: "AGENT"
  }]);
  const Encryption_Type = /* @__PURE__ */ proto3.makeEnum("livekit.Encryption.Type", [{
    no: 0,
    name: "NONE"
  }, {
    no: 1,
    name: "GCM"
  }, {
    no: 2,
    name: "CUSTOM"
  }]);
  const SimulcastCodecInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulcastCodecInfo", () => [{
    no: 1,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "mid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }]);
  const TrackInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "type",
    kind: "enum",
    T: proto3.getEnumType(TrackType)
  }, {
    no: 3,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 5,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "simulcast",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "disable_dtx",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 9,
    name: "source",
    kind: "enum",
    T: proto3.getEnumType(TrackSource)
  }, {
    no: 10,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }, {
    no: 11,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 12,
    name: "mid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 13,
    name: "codecs",
    kind: "message",
    T: SimulcastCodecInfo,
    repeated: true
  }, {
    no: 14,
    name: "stereo",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 15,
    name: "disable_red",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 16,
    name: "encryption",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 17,
    name: "stream",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 18,
    name: "version",
    kind: "message",
    T: TimedVersion
  }, {
    no: 19,
    name: "audio_features",
    kind: "enum",
    T: proto3.getEnumType(AudioTrackFeature),
    repeated: true
  }, {
    no: 20,
    name: "backup_codec_policy",
    kind: "enum",
    T: proto3.getEnumType(BackupCodecPolicy$1)
  }]);
  const VideoLayer = /* @__PURE__ */ proto3.makeMessageType("livekit.VideoLayer", () => [{
    no: 1,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 2,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "bitrate",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "ssrc",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const DataPacket = /* @__PURE__ */ proto3.makeMessageType("livekit.DataPacket", () => [{
    no: 1,
    name: "kind",
    kind: "enum",
    T: proto3.getEnumType(DataPacket_Kind)
  }, {
    no: 4,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "destination_identities",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "user",
    kind: "message",
    T: UserPacket,
    oneof: "value"
  }, {
    no: 3,
    name: "speaker",
    kind: "message",
    T: ActiveSpeakerUpdate,
    oneof: "value"
  }, {
    no: 6,
    name: "sip_dtmf",
    kind: "message",
    T: SipDTMF,
    oneof: "value"
  }, {
    no: 7,
    name: "transcription",
    kind: "message",
    T: Transcription,
    oneof: "value"
  }, {
    no: 8,
    name: "metrics",
    kind: "message",
    T: MetricsBatch,
    oneof: "value"
  }, {
    no: 9,
    name: "chat_message",
    kind: "message",
    T: ChatMessage,
    oneof: "value"
  }, {
    no: 10,
    name: "rpc_request",
    kind: "message",
    T: RpcRequest,
    oneof: "value"
  }, {
    no: 11,
    name: "rpc_ack",
    kind: "message",
    T: RpcAck,
    oneof: "value"
  }, {
    no: 12,
    name: "rpc_response",
    kind: "message",
    T: RpcResponse,
    oneof: "value"
  }, {
    no: 13,
    name: "stream_header",
    kind: "message",
    T: DataStream_Header,
    oneof: "value"
  }, {
    no: 14,
    name: "stream_chunk",
    kind: "message",
    T: DataStream_Chunk,
    oneof: "value"
  }, {
    no: 15,
    name: "stream_trailer",
    kind: "message",
    T: DataStream_Trailer,
    oneof: "value"
  }]);
  const DataPacket_Kind = /* @__PURE__ */ proto3.makeEnum("livekit.DataPacket.Kind", [{
    no: 0,
    name: "RELIABLE"
  }, {
    no: 1,
    name: "LOSSY"
  }]);
  const ActiveSpeakerUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ActiveSpeakerUpdate", () => [{
    no: 1,
    name: "speakers",
    kind: "message",
    T: SpeakerInfo,
    repeated: true
  }]);
  const SpeakerInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.SpeakerInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "level",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }, {
    no: 3,
    name: "active",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const UserPacket = /* @__PURE__ */ proto3.makeMessageType("livekit.UserPacket", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "payload",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 3,
    name: "destination_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 6,
    name: "destination_identities",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "topic",
    kind: "scalar",
    T: 9,
    opt: true
  }, {
    no: 8,
    name: "id",
    kind: "scalar",
    T: 9,
    opt: true
  }, {
    no: 9,
    name: "start_time",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 10,
    name: "end_time",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 11,
    name: "nonce",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }]);
  const SipDTMF = /* @__PURE__ */ proto3.makeMessageType("livekit.SipDTMF", () => [{
    no: 3,
    name: "code",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "digit",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const Transcription = /* @__PURE__ */ proto3.makeMessageType("livekit.Transcription", () => [{
    no: 2,
    name: "transcribed_participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "track_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "segments",
    kind: "message",
    T: TranscriptionSegment,
    repeated: true
  }]);
  const TranscriptionSegment = /* @__PURE__ */ proto3.makeMessageType("livekit.TranscriptionSegment", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "text",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "start_time",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 4,
    name: "end_time",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 5,
    name: "final",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "language",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ChatMessage = /* @__PURE__ */ proto3.makeMessageType("livekit.ChatMessage", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 3,
    name: "edit_timestamp",
    kind: "scalar",
    T: 3,
    opt: true
  }, {
    no: 4,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "deleted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "generated",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const RpcRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcRequest", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "method",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "payload",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "response_timeout_ms",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "version",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const RpcAck = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcAck", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const RpcResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcResponse", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "payload",
    kind: "scalar",
    T: 9,
    oneof: "value"
  }, {
    no: 3,
    name: "error",
    kind: "message",
    T: RpcError$1,
    oneof: "value"
  }]);
  const RpcError$1 = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcError", () => [{
    no: 1,
    name: "code",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "data",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ParticipantTracks = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantTracks", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }]);
  const ServerInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ServerInfo", () => [{
    no: 1,
    name: "edition",
    kind: "enum",
    T: proto3.getEnumType(ServerInfo_Edition)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 4,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "node_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "debug_info",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "agent_protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  const ServerInfo_Edition = /* @__PURE__ */ proto3.makeEnum("livekit.ServerInfo.Edition", [{
    no: 0,
    name: "Standard"
  }, {
    no: 1,
    name: "Cloud"
  }]);
  const ClientInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ClientInfo", () => [{
    no: 1,
    name: "sdk",
    kind: "enum",
    T: proto3.getEnumType(ClientInfo_SDK)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 4,
    name: "os",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "os_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "device_model",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "browser",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "browser_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "address",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "network",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 11,
    name: "other_sdks",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ClientInfo_SDK = /* @__PURE__ */ proto3.makeEnum("livekit.ClientInfo.SDK", [{
    no: 0,
    name: "UNKNOWN"
  }, {
    no: 1,
    name: "JS"
  }, {
    no: 2,
    name: "SWIFT"
  }, {
    no: 3,
    name: "ANDROID"
  }, {
    no: 4,
    name: "FLUTTER"
  }, {
    no: 5,
    name: "GO"
  }, {
    no: 6,
    name: "UNITY"
  }, {
    no: 7,
    name: "REACT_NATIVE"
  }, {
    no: 8,
    name: "RUST"
  }, {
    no: 9,
    name: "PYTHON"
  }, {
    no: 10,
    name: "CPP"
  }, {
    no: 11,
    name: "UNITY_WEB"
  }, {
    no: 12,
    name: "NODE"
  }]);
  const ClientConfiguration = /* @__PURE__ */ proto3.makeMessageType("livekit.ClientConfiguration", () => [{
    no: 1,
    name: "video",
    kind: "message",
    T: VideoConfiguration
  }, {
    no: 2,
    name: "screen",
    kind: "message",
    T: VideoConfiguration
  }, {
    no: 3,
    name: "resume_connection",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }, {
    no: 4,
    name: "disabled_codecs",
    kind: "message",
    T: DisabledCodecs
  }, {
    no: 5,
    name: "force_relay",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }]);
  const VideoConfiguration = /* @__PURE__ */ proto3.makeMessageType("livekit.VideoConfiguration", () => [{
    no: 1,
    name: "hardware_encoder",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }]);
  const DisabledCodecs = /* @__PURE__ */ proto3.makeMessageType("livekit.DisabledCodecs", () => [{
    no: 1,
    name: "codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 2,
    name: "publish",
    kind: "message",
    T: Codec,
    repeated: true
  }]);
  const TimedVersion = /* @__PURE__ */ proto3.makeMessageType("livekit.TimedVersion", () => [{
    no: 1,
    name: "unix_micro",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "ticks",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  const DataStream_OperationType = /* @__PURE__ */ proto3.makeEnum("livekit.DataStream.OperationType", [{
    no: 0,
    name: "CREATE"
  }, {
    no: 1,
    name: "UPDATE"
  }, {
    no: 2,
    name: "DELETE"
  }, {
    no: 3,
    name: "REACTION"
  }]);
  const DataStream_TextHeader = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.TextHeader", () => [{
    no: 1,
    name: "operation_type",
    kind: "enum",
    T: proto3.getEnumType(DataStream_OperationType)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 3,
    name: "reply_to_stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "attached_stream_ids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 5,
    name: "generated",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }], {
    localName: "DataStream_TextHeader"
  });
  const DataStream_ByteHeader = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.ByteHeader", () => [{
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }], {
    localName: "DataStream_ByteHeader"
  });
  const DataStream_Header = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Header", () => [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 3,
    name: "topic",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "total_length",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 7,
    name: "encryption_type",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 8,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 9,
    name: "text_header",
    kind: "message",
    T: DataStream_TextHeader,
    oneof: "content_header"
  }, {
    no: 10,
    name: "byte_header",
    kind: "message",
    T: DataStream_ByteHeader,
    oneof: "content_header"
  }], {
    localName: "DataStream_Header"
  });
  const DataStream_Chunk = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Chunk", () => [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "chunk_index",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 3,
    name: "content",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 4,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 5,
    name: "iv",
    kind: "scalar",
    T: 12,
    opt: true
  }], {
    localName: "DataStream_Chunk"
  });
  const DataStream_Trailer = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Trailer", () => [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "reason",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }], {
    localName: "DataStream_Trailer"
  });
  const SignalTarget = /* @__PURE__ */ proto3.makeEnum("livekit.SignalTarget", [{
    no: 0,
    name: "PUBLISHER"
  }, {
    no: 1,
    name: "SUBSCRIBER"
  }]);
  const StreamState = /* @__PURE__ */ proto3.makeEnum("livekit.StreamState", [{
    no: 0,
    name: "ACTIVE"
  }, {
    no: 1,
    name: "PAUSED"
  }]);
  const CandidateProtocol = /* @__PURE__ */ proto3.makeEnum("livekit.CandidateProtocol", [{
    no: 0,
    name: "UDP"
  }, {
    no: 1,
    name: "TCP"
  }, {
    no: 2,
    name: "TLS"
  }]);
  const SignalRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.SignalRequest", () => [{
    no: 1,
    name: "offer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 2,
    name: "answer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 3,
    name: "trickle",
    kind: "message",
    T: TrickleRequest,
    oneof: "message"
  }, {
    no: 4,
    name: "add_track",
    kind: "message",
    T: AddTrackRequest,
    oneof: "message"
  }, {
    no: 5,
    name: "mute",
    kind: "message",
    T: MuteTrackRequest,
    oneof: "message"
  }, {
    no: 6,
    name: "subscription",
    kind: "message",
    T: UpdateSubscription,
    oneof: "message"
  }, {
    no: 7,
    name: "track_setting",
    kind: "message",
    T: UpdateTrackSettings,
    oneof: "message"
  }, {
    no: 8,
    name: "leave",
    kind: "message",
    T: LeaveRequest,
    oneof: "message"
  }, {
    no: 10,
    name: "update_layers",
    kind: "message",
    T: UpdateVideoLayers,
    oneof: "message"
  }, {
    no: 11,
    name: "subscription_permission",
    kind: "message",
    T: SubscriptionPermission,
    oneof: "message"
  }, {
    no: 12,
    name: "sync_state",
    kind: "message",
    T: SyncState,
    oneof: "message"
  }, {
    no: 13,
    name: "simulate",
    kind: "message",
    T: SimulateScenario,
    oneof: "message"
  }, {
    no: 14,
    name: "ping",
    kind: "scalar",
    T: 3,
    oneof: "message"
  }, {
    no: 15,
    name: "update_metadata",
    kind: "message",
    T: UpdateParticipantMetadata,
    oneof: "message"
  }, {
    no: 16,
    name: "ping_req",
    kind: "message",
    T: Ping,
    oneof: "message"
  }, {
    no: 17,
    name: "update_audio_track",
    kind: "message",
    T: UpdateLocalAudioTrack,
    oneof: "message"
  }, {
    no: 18,
    name: "update_video_track",
    kind: "message",
    T: UpdateLocalVideoTrack,
    oneof: "message"
  }]);
  const SignalResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.SignalResponse", () => [{
    no: 1,
    name: "join",
    kind: "message",
    T: JoinResponse,
    oneof: "message"
  }, {
    no: 2,
    name: "answer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 3,
    name: "offer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 4,
    name: "trickle",
    kind: "message",
    T: TrickleRequest,
    oneof: "message"
  }, {
    no: 5,
    name: "update",
    kind: "message",
    T: ParticipantUpdate,
    oneof: "message"
  }, {
    no: 6,
    name: "track_published",
    kind: "message",
    T: TrackPublishedResponse,
    oneof: "message"
  }, {
    no: 8,
    name: "leave",
    kind: "message",
    T: LeaveRequest,
    oneof: "message"
  }, {
    no: 9,
    name: "mute",
    kind: "message",
    T: MuteTrackRequest,
    oneof: "message"
  }, {
    no: 10,
    name: "speakers_changed",
    kind: "message",
    T: SpeakersChanged,
    oneof: "message"
  }, {
    no: 11,
    name: "room_update",
    kind: "message",
    T: RoomUpdate,
    oneof: "message"
  }, {
    no: 12,
    name: "connection_quality",
    kind: "message",
    T: ConnectionQualityUpdate,
    oneof: "message"
  }, {
    no: 13,
    name: "stream_state_update",
    kind: "message",
    T: StreamStateUpdate,
    oneof: "message"
  }, {
    no: 14,
    name: "subscribed_quality_update",
    kind: "message",
    T: SubscribedQualityUpdate,
    oneof: "message"
  }, {
    no: 15,
    name: "subscription_permission_update",
    kind: "message",
    T: SubscriptionPermissionUpdate,
    oneof: "message"
  }, {
    no: 16,
    name: "refresh_token",
    kind: "scalar",
    T: 9,
    oneof: "message"
  }, {
    no: 17,
    name: "track_unpublished",
    kind: "message",
    T: TrackUnpublishedResponse,
    oneof: "message"
  }, {
    no: 18,
    name: "pong",
    kind: "scalar",
    T: 3,
    oneof: "message"
  }, {
    no: 19,
    name: "reconnect",
    kind: "message",
    T: ReconnectResponse,
    oneof: "message"
  }, {
    no: 20,
    name: "pong_resp",
    kind: "message",
    T: Pong,
    oneof: "message"
  }, {
    no: 21,
    name: "subscription_response",
    kind: "message",
    T: SubscriptionResponse,
    oneof: "message"
  }, {
    no: 22,
    name: "request_response",
    kind: "message",
    T: RequestResponse,
    oneof: "message"
  }, {
    no: 23,
    name: "track_subscribed",
    kind: "message",
    T: TrackSubscribed,
    oneof: "message"
  }]);
  const SimulcastCodec = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulcastCodec", () => [{
    no: 1,
    name: "codec",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const AddTrackRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.AddTrackRequest", () => [{
    no: 1,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "type",
    kind: "enum",
    T: proto3.getEnumType(TrackType)
  }, {
    no: 4,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 7,
    name: "disable_dtx",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "source",
    kind: "enum",
    T: proto3.getEnumType(TrackSource)
  }, {
    no: 9,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }, {
    no: 10,
    name: "simulcast_codecs",
    kind: "message",
    T: SimulcastCodec,
    repeated: true
  }, {
    no: 11,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 12,
    name: "stereo",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 13,
    name: "disable_red",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 14,
    name: "encryption",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 15,
    name: "stream",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 16,
    name: "backup_codec_policy",
    kind: "enum",
    T: proto3.getEnumType(BackupCodecPolicy$1)
  }]);
  const TrickleRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.TrickleRequest", () => [{
    no: 1,
    name: "candidateInit",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "target",
    kind: "enum",
    T: proto3.getEnumType(SignalTarget)
  }, {
    no: 3,
    name: "final",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const MuteTrackRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.MuteTrackRequest", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const JoinResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.JoinResponse", () => [{
    no: 1,
    name: "room",
    kind: "message",
    T: Room$1
  }, {
    no: 2,
    name: "participant",
    kind: "message",
    T: ParticipantInfo
  }, {
    no: 3,
    name: "other_participants",
    kind: "message",
    T: ParticipantInfo,
    repeated: true
  }, {
    no: 4,
    name: "server_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "ice_servers",
    kind: "message",
    T: ICEServer,
    repeated: true
  }, {
    no: 6,
    name: "subscriber_primary",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 7,
    name: "alternative_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "client_configuration",
    kind: "message",
    T: ClientConfiguration
  }, {
    no: 9,
    name: "server_region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "ping_timeout",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 11,
    name: "ping_interval",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 12,
    name: "server_info",
    kind: "message",
    T: ServerInfo
  }, {
    no: 13,
    name: "sif_trailer",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 14,
    name: "enabled_publish_codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 15,
    name: "fast_publish",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const ReconnectResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.ReconnectResponse", () => [{
    no: 1,
    name: "ice_servers",
    kind: "message",
    T: ICEServer,
    repeated: true
  }, {
    no: 2,
    name: "client_configuration",
    kind: "message",
    T: ClientConfiguration
  }]);
  const TrackPublishedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackPublishedResponse", () => [{
    no: 1,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track",
    kind: "message",
    T: TrackInfo
  }]);
  const TrackUnpublishedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackUnpublishedResponse", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const SessionDescription = /* @__PURE__ */ proto3.makeMessageType("livekit.SessionDescription", () => [{
    no: 1,
    name: "type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "sdp",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const ParticipantUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantUpdate", () => [{
    no: 1,
    name: "participants",
    kind: "message",
    T: ParticipantInfo,
    repeated: true
  }]);
  const UpdateSubscription = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateSubscription", () => [{
    no: 1,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "subscribe",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "participant_tracks",
    kind: "message",
    T: ParticipantTracks,
    repeated: true
  }]);
  const UpdateTrackSettings = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateTrackSettings", () => [{
    no: 1,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 3,
    name: "disabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 4,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 5,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "fps",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 8,
    name: "priority",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const UpdateLocalAudioTrack = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateLocalAudioTrack", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "features",
    kind: "enum",
    T: proto3.getEnumType(AudioTrackFeature),
    repeated: true
  }]);
  const UpdateLocalVideoTrack = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateLocalVideoTrack", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const LeaveRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.LeaveRequest", () => [{
    no: 1,
    name: "can_reconnect",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "reason",
    kind: "enum",
    T: proto3.getEnumType(DisconnectReason)
  }, {
    no: 3,
    name: "action",
    kind: "enum",
    T: proto3.getEnumType(LeaveRequest_Action)
  }, {
    no: 4,
    name: "regions",
    kind: "message",
    T: RegionSettings
  }]);
  const LeaveRequest_Action = /* @__PURE__ */ proto3.makeEnum("livekit.LeaveRequest.Action", [{
    no: 0,
    name: "DISCONNECT"
  }, {
    no: 1,
    name: "RESUME"
  }, {
    no: 2,
    name: "RECONNECT"
  }]);
  const UpdateVideoLayers = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateVideoLayers", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }]);
  const UpdateParticipantMetadata = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateParticipantMetadata", () => [{
    no: 1,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 4,
    name: "request_id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  const ICEServer = /* @__PURE__ */ proto3.makeMessageType("livekit.ICEServer", () => [{
    no: 1,
    name: "urls",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "username",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "credential",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const SpeakersChanged = /* @__PURE__ */ proto3.makeMessageType("livekit.SpeakersChanged", () => [{
    no: 1,
    name: "speakers",
    kind: "message",
    T: SpeakerInfo,
    repeated: true
  }]);
  const RoomUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.RoomUpdate", () => [{
    no: 1,
    name: "room",
    kind: "message",
    T: Room$1
  }]);
  const ConnectionQualityInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ConnectionQualityInfo", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(ConnectionQuality$1)
  }, {
    no: 3,
    name: "score",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }]);
  const ConnectionQualityUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ConnectionQualityUpdate", () => [{
    no: 1,
    name: "updates",
    kind: "message",
    T: ConnectionQualityInfo,
    repeated: true
  }]);
  const StreamStateInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.StreamStateInfo", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "state",
    kind: "enum",
    T: proto3.getEnumType(StreamState)
  }]);
  const StreamStateUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.StreamStateUpdate", () => [{
    no: 1,
    name: "stream_states",
    kind: "message",
    T: StreamStateInfo,
    repeated: true
  }]);
  const SubscribedQuality = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedQuality", () => [{
    no: 1,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 2,
    name: "enabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const SubscribedCodec = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedCodec", () => [{
    no: 1,
    name: "codec",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "qualities",
    kind: "message",
    T: SubscribedQuality,
    repeated: true
  }]);
  const SubscribedQualityUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedQualityUpdate", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "subscribed_qualities",
    kind: "message",
    T: SubscribedQuality,
    repeated: true
  }, {
    no: 3,
    name: "subscribed_codecs",
    kind: "message",
    T: SubscribedCodec,
    repeated: true
  }]);
  const TrackPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackPermission", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "all_tracks",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const SubscriptionPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionPermission", () => [{
    no: 1,
    name: "all_participants",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "track_permissions",
    kind: "message",
    T: TrackPermission,
    repeated: true
  }]);
  const SubscriptionPermissionUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionPermissionUpdate", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "allowed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  const SyncState = /* @__PURE__ */ proto3.makeMessageType("livekit.SyncState", () => [{
    no: 1,
    name: "answer",
    kind: "message",
    T: SessionDescription
  }, {
    no: 2,
    name: "subscription",
    kind: "message",
    T: UpdateSubscription
  }, {
    no: 3,
    name: "publish_tracks",
    kind: "message",
    T: TrackPublishedResponse,
    repeated: true
  }, {
    no: 4,
    name: "data_channels",
    kind: "message",
    T: DataChannelInfo,
    repeated: true
  }, {
    no: 5,
    name: "offer",
    kind: "message",
    T: SessionDescription
  }, {
    no: 6,
    name: "track_sids_disabled",
    kind: "scalar",
    T: 9,
    repeated: true
  }]);
  const DataChannelInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.DataChannelInfo", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "target",
    kind: "enum",
    T: proto3.getEnumType(SignalTarget)
  }]);
  const SimulateScenario = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulateScenario", () => [{
    no: 1,
    name: "speaker_update",
    kind: "scalar",
    T: 5,
    oneof: "scenario"
  }, {
    no: 2,
    name: "node_failure",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 3,
    name: "migration",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 4,
    name: "server_leave",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 5,
    name: "switch_candidate_protocol",
    kind: "enum",
    T: proto3.getEnumType(CandidateProtocol),
    oneof: "scenario"
  }, {
    no: 6,
    name: "subscriber_bandwidth",
    kind: "scalar",
    T: 3,
    oneof: "scenario"
  }, {
    no: 7,
    name: "disconnect_signal_on_resume",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 8,
    name: "disconnect_signal_on_resume_no_messages",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 9,
    name: "leave_request_full_reconnect",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }]);
  const Ping = /* @__PURE__ */ proto3.makeMessageType("livekit.Ping", () => [{
    no: 1,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "rtt",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  const Pong = /* @__PURE__ */ proto3.makeMessageType("livekit.Pong", () => [{
    no: 1,
    name: "last_ping_timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  const RegionSettings = /* @__PURE__ */ proto3.makeMessageType("livekit.RegionSettings", () => [{
    no: 1,
    name: "regions",
    kind: "message",
    T: RegionInfo,
    repeated: true
  }]);
  const RegionInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.RegionInfo", () => [{
    no: 1,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "distance",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  const SubscriptionResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionResponse", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "err",
    kind: "enum",
    T: proto3.getEnumType(SubscriptionError)
  }]);
  const RequestResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RequestResponse", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "reason",
    kind: "enum",
    T: proto3.getEnumType(RequestResponse_Reason)
  }, {
    no: 3,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  const RequestResponse_Reason = /* @__PURE__ */ proto3.makeEnum("livekit.RequestResponse.Reason", [{
    no: 0,
    name: "OK"
  }, {
    no: 1,
    name: "NOT_FOUND"
  }, {
    no: 2,
    name: "NOT_ALLOWED"
  }, {
    no: 3,
    name: "LIMIT_EXCEEDED"
  }]);
  const TrackSubscribed = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackSubscribed", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  function getDefaultExportFromCjs$1(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var loglevel$1 = { exports: {} };
  var loglevel = loglevel$1.exports;
  var hasRequiredLoglevel;
  function requireLoglevel() {
    if (hasRequiredLoglevel)
      return loglevel$1.exports;
    hasRequiredLoglevel = 1;
    (function(module) {
      (function(root, definition) {
        if (module.exports) {
          module.exports = definition();
        } else {
          root.log = definition();
        }
      })(loglevel, function() {
        var noop2 = function() {
        };
        var undefinedType = "undefined";
        var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
        var logMethods = ["trace", "debug", "info", "warn", "error"];
        var _loggersByName = {};
        var defaultLogger = null;
        function bindMethod(obj, methodName) {
          var method = obj[methodName];
          if (typeof method.bind === "function") {
            return method.bind(obj);
          } else {
            try {
              return Function.prototype.bind.call(method, obj);
            } catch (e2) {
              return function() {
                return Function.prototype.apply.apply(method, [obj, arguments]);
              };
            }
          }
        }
        function traceForIE() {
          if (console.log) {
            if (console.log.apply) {
              console.log.apply(console, arguments);
            } else {
              Function.prototype.apply.apply(console.log, [console, arguments]);
            }
          }
          if (console.trace)
            console.trace();
        }
        function realMethod(methodName) {
          if (methodName === "debug") {
            methodName = "log";
          }
          if (typeof console === undefinedType) {
            return false;
          } else if (methodName === "trace" && isIE) {
            return traceForIE;
          } else if (console[methodName] !== void 0) {
            return bindMethod(console, methodName);
          } else if (console.log !== void 0) {
            return bindMethod(console, "log");
          } else {
            return noop2;
          }
        }
        function replaceLoggingMethods() {
          var level = this.getLevel();
          for (var i2 = 0; i2 < logMethods.length; i2++) {
            var methodName = logMethods[i2];
            this[methodName] = i2 < level ? noop2 : this.methodFactory(methodName, level, this.name);
          }
          this.log = this.debug;
          if (typeof console === undefinedType && level < this.levels.SILENT) {
            return "No console available for logging";
          }
        }
        function enableLoggingWhenConsoleArrives(methodName) {
          return function() {
            if (typeof console !== undefinedType) {
              replaceLoggingMethods.call(this);
              this[methodName].apply(this, arguments);
            }
          };
        }
        function defaultMethodFactory(methodName, _level, _loggerName) {
          return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
        }
        function Logger(name, factory) {
          var self2 = this;
          var inheritedLevel;
          var defaultLevel;
          var userLevel;
          var storageKey = "loglevel";
          if (typeof name === "string") {
            storageKey += ":" + name;
          } else if (typeof name === "symbol") {
            storageKey = void 0;
          }
          function persistLevelIfPossible(levelNum) {
            var levelName = (logMethods[levelNum] || "silent").toUpperCase();
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              window.localStorage[storageKey] = levelName;
              return;
            } catch (ignore) {
            }
            try {
              window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
            } catch (ignore) {
            }
          }
          function getPersistedLevel() {
            var storedLevel;
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              storedLevel = window.localStorage[storageKey];
            } catch (ignore) {
            }
            if (typeof storedLevel === undefinedType) {
              try {
                var cookie = window.document.cookie;
                var cookieName = encodeURIComponent(storageKey);
                var location2 = cookie.indexOf(cookieName + "=");
                if (location2 !== -1) {
                  storedLevel = /^([^;]+)/.exec(cookie.slice(location2 + cookieName.length + 1))[1];
                }
              } catch (ignore) {
              }
            }
            if (self2.levels[storedLevel] === void 0) {
              storedLevel = void 0;
            }
            return storedLevel;
          }
          function clearPersistedLevel() {
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              window.localStorage.removeItem(storageKey);
            } catch (ignore) {
            }
            try {
              window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch (ignore) {
            }
          }
          function normalizeLevel(input) {
            var level = input;
            if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
              level = self2.levels[level.toUpperCase()];
            }
            if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
              return level;
            } else {
              throw new TypeError("log.setLevel() called with invalid level: " + input);
            }
          }
          self2.name = name;
          self2.levels = {
            "TRACE": 0,
            "DEBUG": 1,
            "INFO": 2,
            "WARN": 3,
            "ERROR": 4,
            "SILENT": 5
          };
          self2.methodFactory = factory || defaultMethodFactory;
          self2.getLevel = function() {
            if (userLevel != null) {
              return userLevel;
            } else if (defaultLevel != null) {
              return defaultLevel;
            } else {
              return inheritedLevel;
            }
          };
          self2.setLevel = function(level, persist) {
            userLevel = normalizeLevel(level);
            if (persist !== false) {
              persistLevelIfPossible(userLevel);
            }
            return replaceLoggingMethods.call(self2);
          };
          self2.setDefaultLevel = function(level) {
            defaultLevel = normalizeLevel(level);
            if (!getPersistedLevel()) {
              self2.setLevel(level, false);
            }
          };
          self2.resetLevel = function() {
            userLevel = null;
            clearPersistedLevel();
            replaceLoggingMethods.call(self2);
          };
          self2.enableAll = function(persist) {
            self2.setLevel(self2.levels.TRACE, persist);
          };
          self2.disableAll = function(persist) {
            self2.setLevel(self2.levels.SILENT, persist);
          };
          self2.rebuild = function() {
            if (defaultLogger !== self2) {
              inheritedLevel = normalizeLevel(defaultLogger.getLevel());
            }
            replaceLoggingMethods.call(self2);
            if (defaultLogger === self2) {
              for (var childName in _loggersByName) {
                _loggersByName[childName].rebuild();
              }
            }
          };
          inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : "WARN");
          var initialLevel = getPersistedLevel();
          if (initialLevel != null) {
            userLevel = normalizeLevel(initialLevel);
          }
          replaceLoggingMethods.call(self2);
        }
        defaultLogger = new Logger();
        defaultLogger.getLogger = function getLogger2(name) {
          if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
            throw new TypeError("You must supply a name when creating a logger.");
          }
          var logger = _loggersByName[name];
          if (!logger) {
            logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);
          }
          return logger;
        };
        var _log = typeof window !== undefinedType ? window.log : void 0;
        defaultLogger.noConflict = function() {
          if (typeof window !== undefinedType && window.log === defaultLogger) {
            window.log = _log;
          }
          return defaultLogger;
        };
        defaultLogger.getLoggers = function getLoggers() {
          return _loggersByName;
        };
        defaultLogger["default"] = defaultLogger;
        return defaultLogger;
      });
    })(loglevel$1);
    return loglevel$1.exports;
  }
  var loglevelExports = requireLoglevel();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["trace"] = 0] = "trace";
    LogLevel2[LogLevel2["debug"] = 1] = "debug";
    LogLevel2[LogLevel2["info"] = 2] = "info";
    LogLevel2[LogLevel2["warn"] = 3] = "warn";
    LogLevel2[LogLevel2["error"] = 4] = "error";
    LogLevel2[LogLevel2["silent"] = 5] = "silent";
  })(LogLevel || (LogLevel = {}));
  var LoggerNames;
  (function(LoggerNames2) {
    LoggerNames2["Default"] = "livekit";
    LoggerNames2["Room"] = "livekit-room";
    LoggerNames2["Participant"] = "livekit-participant";
    LoggerNames2["Track"] = "livekit-track";
    LoggerNames2["Publication"] = "livekit-track-publication";
    LoggerNames2["Engine"] = "livekit-engine";
    LoggerNames2["Signal"] = "livekit-signal";
    LoggerNames2["PCManager"] = "livekit-pc-manager";
    LoggerNames2["PCTransport"] = "livekit-pc-transport";
    LoggerNames2["E2EE"] = "lk-e2ee";
  })(LoggerNames || (LoggerNames = {}));
  let livekitLogger = loglevelExports.getLogger("livekit");
  Object.values(LoggerNames).map((name) => loglevelExports.getLogger(name));
  livekitLogger.setDefaultLevel(LogLevel.info);
  function getLogger(name) {
    const logger = loglevelExports.getLogger(name);
    logger.setDefaultLevel(livekitLogger.getLevel());
    return logger;
  }
  const workerLogger = loglevelExports.getLogger("lk-e2ee");
  const maxRetryDelay = 7e3;
  const DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
  class DefaultReconnectPolicy {
    constructor(retryDelays) {
      this._retryDelays = retryDelays !== void 0 ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;
    }
    nextRetryDelayInMs(context) {
      if (context.retryCount >= this._retryDelays.length)
        return null;
      const retryDelay = this._retryDelays[context.retryCount];
      if (context.retryCount <= 1)
        return retryDelay;
      return retryDelay + Math.random() * 1e3;
    }
  }
  function __awaiter(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2)
      return m2.call(o2);
    if (o2 && typeof o2.length === "number")
      return {
        next: function() {
          if (o2 && i2 >= o2.length)
            o2 = void 0;
          return { value: o2 && o2[i2++], done: !o2 };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __asyncValues(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d2, v2) {
      Promise.resolve(v2).then(function(v22) {
        resolve({ value: v22, done: d2 });
      }, reject);
    }
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e2 = new Error(message);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  };
  var events = { exports: {} };
  var hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents)
      return events.exports;
    hasRequiredEvents = 1;
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:6727", warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    events.exports = EventEmitter;
    events.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++)
        args.push(arguments[i2]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit("newListener", type, listener.listener ? listener.listener : listener);
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = {
        fired: false,
        wrapFn: void 0,
        target,
        type,
        listener
      };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i2, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i2;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
          once: true
        });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
          });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    return events.exports;
  }
  var eventsExports = requireEvents();
  let logDisabled_ = true;
  let deprecationWarnings_ = true;
  function extractVersion(uastring, expr, pos) {
    const match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  }
  function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const proto = window2.RTCPeerConnection.prototype;
    const nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      const wrappedCallback = (e2) => {
        const modifiedEvent = wrapper(e2);
        if (modifiedEvent) {
          if (cb.handleEvent) {
            cb.handleEvent(modifiedEvent);
          } else {
            cb(modifiedEvent);
          }
        }
      };
      this._eventMap = this._eventMap || {};
      if (!this._eventMap[eventNameToWrap]) {
        this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
      }
      this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
      return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
    };
    const nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      if (!this._eventMap[eventNameToWrap].has(cb)) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
      this._eventMap[eventNameToWrap].delete(cb);
      if (this._eventMap[eventNameToWrap].size === 0) {
        delete this._eventMap[eventNameToWrap];
      }
      if (Object.keys(this._eventMap).length === 0) {
        delete this._eventMap;
      }
      return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
    };
    Object.defineProperty(proto, "on" + eventNameToWrap, {
      get() {
        return this["_on" + eventNameToWrap];
      },
      set(cb) {
        if (this["_on" + eventNameToWrap]) {
          this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
          delete this["_on" + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
  }
  function disableLog(bool) {
    if (typeof bool !== "boolean") {
      return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
    }
    logDisabled_ = bool;
    return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
  }
  function disableWarnings(bool) {
    if (typeof bool !== "boolean") {
      return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
    }
    deprecationWarnings_ = !bool;
    return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
  }
  function log() {
    if (typeof window === "object") {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== "undefined" && typeof console.log === "function") {
        console.log.apply(console, arguments);
      }
    }
  }
  function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:7218", oldMethod + " is deprecated, please use " + newMethod + " instead.");
  }
  function detectBrowser(window2) {
    const result = {
      browser: null,
      version: null
    };
    if (typeof window2 === "undefined" || !window2.navigator || !window2.navigator.userAgent) {
      result.browser = "Not a browser.";
      return result;
    }
    const {
      navigator: navigator2
    } = window2;
    if (navigator2.userAgentData && navigator2.userAgentData.brands) {
      const chromium = navigator2.userAgentData.brands.find((brand) => {
        return brand.brand === "Chromium";
      });
      if (chromium) {
        return {
          browser: "chrome",
          version: parseInt(chromium.version, 10)
        };
      }
    }
    if (navigator2.mozGetUserMedia) {
      result.browser = "firefox";
      result.version = extractVersion(navigator2.userAgent, /Firefox\/(\d+)\./, 1);
    } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {
      result.browser = "chrome";
      result.version = extractVersion(navigator2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
      result.browser = "safari";
      result.version = extractVersion(navigator2.userAgent, /AppleWebKit\/(\d+)\./, 1);
      result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
    } else {
      result.browser = "Not a supported browser.";
      return result;
    }
    return result;
  }
  function isObject$1(val) {
    return Object.prototype.toString.call(val) === "[object Object]";
  }
  function compactObject(data) {
    if (!isObject$1(data)) {
      return data;
    }
    return Object.keys(data).reduce(function(accumulator, key) {
      const isObj = isObject$1(data[key]);
      const value = isObj ? compactObject(data[key]) : data[key];
      const isEmptyObject = isObj && !Object.keys(value).length;
      if (value === void 0 || isEmptyObject) {
        return accumulator;
      }
      return Object.assign(accumulator, {
        [key]: value
      });
    }, {});
  }
  function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach((name) => {
      if (name.endsWith("Id")) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith("Ids")) {
        base[name].forEach((id) => {
          walkStats(stats, stats.get(id), resultSet);
        });
      }
    });
  }
  function filterStats(result, track, outbound) {
    const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
    const filteredResult = /* @__PURE__ */ new Map();
    if (track === null) {
      return filteredResult;
    }
    const trackStats = [];
    result.forEach((value) => {
      if (value.type === "track" && value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach((trackStat) => {
      result.forEach((stats) => {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }
  const logging = log;
  function shimGetUserMedia$2(window2, browserDetails2) {
    const navigator2 = window2 && window2.navigator;
    if (!navigator2.mediaDevices) {
      return;
    }
    const constraintsToChrome_ = function(c2) {
      if (typeof c2 !== "object" || c2.mandatory || c2.optional) {
        return c2;
      }
      const cc = {};
      Object.keys(c2).forEach((key) => {
        if (key === "require" || key === "advanced" || key === "mediaSource") {
          return;
        }
        const r2 = typeof c2[key] === "object" ? c2[key] : {
          ideal: c2[key]
        };
        if (r2.exact !== void 0 && typeof r2.exact === "number") {
          r2.min = r2.max = r2.exact;
        }
        const oldname_ = function(prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return name === "deviceId" ? "sourceId" : name;
        };
        if (r2.ideal !== void 0) {
          cc.optional = cc.optional || [];
          let oc = {};
          if (typeof r2.ideal === "number") {
            oc[oldname_("min", key)] = r2.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_("max", key)] = r2.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_("", key)] = r2.ideal;
            cc.optional.push(oc);
          }
        }
        if (r2.exact !== void 0 && typeof r2.exact !== "number") {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_("", key)] = r2.exact;
        } else {
          ["min", "max"].forEach((mix) => {
            if (r2[mix] !== void 0) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r2[mix];
            }
          });
        }
      });
      if (c2.advanced) {
        cc.optional = (cc.optional || []).concat(c2.advanced);
      }
      return cc;
    };
    const shimConstraints_ = function(constraints, func) {
      if (browserDetails2.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && typeof constraints.audio === "object") {
        const remap = function(obj, a2, b2) {
          if (a2 in obj && !(b2 in obj)) {
            obj[b2] = obj[a2];
            delete obj[a2];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, "autoGainControl", "googAutoGainControl");
        remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && typeof constraints.video === "object") {
        let face = constraints.video.facingMode;
        face = face && (typeof face === "object" ? face : {
          ideal: face
        });
        const getSupportedFacingModeLies = browserDetails2.version < 66;
        if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
          delete constraints.video.facingMode;
          let matches;
          if (face.exact === "environment" || face.ideal === "environment") {
            matches = ["back", "rear"];
          } else if (face.exact === "user" || face.ideal === "user") {
            matches = ["front"];
          }
          if (matches) {
            return navigator2.mediaDevices.enumerateDevices().then((devices) => {
              devices = devices.filter((d2) => d2.kind === "videoinput");
              let dev = devices.find((d2) => matches.some((match) => d2.label.toLowerCase().includes(match)));
              if (!dev && devices.length && matches.includes("back")) {
                dev = devices[devices.length - 1];
              }
              if (dev) {
                constraints.video.deviceId = face.exact ? {
                  exact: dev.deviceId
                } : {
                  ideal: dev.deviceId
                };
              }
              constraints.video = constraintsToChrome_(constraints.video);
              logging("chrome: " + JSON.stringify(constraints));
              return func(constraints);
            });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging("chrome: " + JSON.stringify(constraints));
      return func(constraints);
    };
    const shimError_ = function(e2) {
      if (browserDetails2.version >= 64) {
        return e2;
      }
      return {
        name: {
          PermissionDeniedError: "NotAllowedError",
          PermissionDismissedError: "NotAllowedError",
          InvalidStateError: "NotAllowedError",
          DevicesNotFoundError: "NotFoundError",
          ConstraintNotSatisfiedError: "OverconstrainedError",
          TrackStartError: "NotReadableError",
          MediaDeviceFailedDueToShutdown: "NotAllowedError",
          MediaDeviceKillSwitchOn: "NotAllowedError",
          TabCaptureError: "AbortError",
          ScreenCaptureError: "AbortError",
          DeviceCaptureError: "AbortError"
        }[e2.name] || e2.name,
        message: e2.message,
        constraint: e2.constraint || e2.constraintName,
        toString() {
          return this.name + (this.message && ": ") + this.message;
        }
      };
    };
    const getUserMedia_ = function(constraints, onSuccess, onError) {
      shimConstraints_(constraints, (c2) => {
        navigator2.webkitGetUserMedia(c2, onSuccess, (e2) => {
          if (onError) {
            onError(shimError_(e2));
          }
        });
      });
    };
    navigator2.getUserMedia = getUserMedia_.bind(navigator2);
    if (navigator2.mediaDevices.getUserMedia) {
      const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
      navigator2.mediaDevices.getUserMedia = function(cs2) {
        return shimConstraints_(cs2, (c2) => origGetUserMedia(c2).then((stream) => {
          if (c2.audio && !stream.getAudioTracks().length || c2.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach((track) => {
              track.stop();
            });
            throw new DOMException("", "NotFoundError");
          }
          return stream;
        }, (e2) => Promise.reject(shimError_(e2))));
      };
    }
  }
  function shimMediaStream(window2) {
    window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
  }
  function shimOnTrack$1(window2) {
    if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
        get() {
          return this._ontrack;
        },
        set(f2) {
          if (this._ontrack) {
            this.removeEventListener("track", this._ontrack);
          }
          this.addEventListener("track", this._ontrack = f2);
        },
        enumerable: true,
        configurable: true
      });
      const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
      window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        if (!this._ontrackpoly) {
          this._ontrackpoly = (e2) => {
            e2.stream.addEventListener("addtrack", (te2) => {
              let receiver;
              if (window2.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te2.track.id);
              } else {
                receiver = {
                  track: te2.track
                };
              }
              const event = new Event("track");
              event.track = te2.track;
              event.receiver = receiver;
              event.transceiver = {
                receiver
              };
              event.streams = [e2.stream];
              this.dispatchEvent(event);
            });
            e2.stream.getTracks().forEach((track) => {
              let receiver;
              if (window2.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);
              } else {
                receiver = {
                  track
                };
              }
              const event = new Event("track");
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {
                receiver
              };
              event.streams = [e2.stream];
              this.dispatchEvent(event);
            });
          };
          this.addEventListener("addstream", this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
    } else {
      wrapPeerConnectionEvent(window2, "track", (e2) => {
        if (!e2.transceiver) {
          Object.defineProperty(e2, "transceiver", {
            value: {
              receiver: e2.receiver
            }
          });
        }
        return e2;
      });
    }
  }
  function shimGetSendersWithDtmf(window2) {
    if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
      const shimSenderWithDtmf = function(pc, track) {
        return {
          track,
          get dtmf() {
            if (this._dtmf === void 0) {
              if (track.kind === "audio") {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };
      if (!window2.RTCPeerConnection.prototype.getSenders) {
        window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
          this._senders = this._senders || [];
          return this._senders.slice();
        };
        const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
        window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          let sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };
        const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
        window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          origRemoveTrack.apply(this, arguments);
          const idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
      }
      const origAddStream = window2.RTCPeerConnection.prototype.addStream;
      window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        this._senders = this._senders || [];
        origAddStream.apply(this, [stream]);
        stream.getTracks().forEach((track) => {
          this._senders.push(shimSenderWithDtmf(this, track));
        });
      };
      const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
      window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream]);
        stream.getTracks().forEach((track) => {
          const sender = this._senders.find((s2) => s2.track === track);
          if (sender) {
            this._senders.splice(this._senders.indexOf(sender), 1);
          }
        });
      };
    } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
      const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
      Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
        get() {
          if (this._dtmf === void 0) {
            if (this.track.kind === "audio") {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  }
  function shimSenderReceiverGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
      return;
    }
    if (!("getStats" in window2.RTCRtpSender.prototype)) {
      const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
          const senders = origGetSenders.apply(this, []);
          senders.forEach((sender) => sender._pc = this);
          return senders;
        };
      }
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
          const sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window2.RTCRtpSender.prototype.getStats = function getStats() {
        const sender = this;
        return this._pc.getStats().then((result) => (
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          filterStats(result, sender.track, true)
        ));
      };
    }
    if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
      const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
          const receivers = origGetReceivers.apply(this, []);
          receivers.forEach((receiver) => receiver._pc = this);
          return receivers;
        };
      }
      wrapPeerConnectionEvent(window2, "track", (e2) => {
        e2.receiver._pc = e2.srcElement;
        return e2;
      });
      window2.RTCRtpReceiver.prototype.getStats = function getStats() {
        const receiver = this;
        return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
      };
    }
    if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
      return;
    }
    const origGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
        const track = arguments[0];
        let sender;
        let receiver;
        let err;
        this.getSenders().forEach((s2) => {
          if (s2.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s2;
            }
          }
        });
        this.getReceivers().forEach((r2) => {
          if (r2.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r2;
            }
          }
          return r2.track === track;
        });
        if (err || sender && receiver) {
          return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
      }
      return origGetStats.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrackWithNative(window2) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
    };
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      const sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      stream.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s2) => s2.track === track);
        if (alreadyExists) {
          throw new DOMException("Track already exists.", "InvalidAccessError");
        }
      });
      const existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };
    const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
    window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            this._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (this._shimmedLocalStreams[streamId].length === 1) {
            delete this._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrack(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (window2.RTCPeerConnection.prototype.addTrack && browserDetails2.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window2);
    }
    const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      const nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
    };
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      stream.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s2) => s2.track === track);
        if (alreadyExists) {
          throw new DOMException("Track already exists.", "InvalidAccessError");
        }
      });
      if (!this._reverseStreams[stream.id]) {
        const newStream = new window2.MediaStream(stream.getTracks());
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(this, [stream]);
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
      delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
      delete this._streams[stream.id];
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
      if (this.signalingState === "closed") {
        throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
      }
      const streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 || !streams[0].getTracks().find((t2) => t2 === track)) {
        throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
      }
      const alreadyExists = this.getSenders().find((s2) => s2.track === track);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      const oldStream = this._streams[stream.id];
      if (oldStream) {
        oldStream.addTrack(track);
        Promise.resolve().then(() => {
          this.dispatchEvent(new Event("negotiationneeded"));
        });
      } else {
        const newStream = new window2.MediaStream([track]);
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        this.addStream(newStream);
      }
      return this.getSenders().find((s2) => s2.track === track);
    };
    function replaceInternalStreamId(pc, description) {
      let sdp2 = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp2 = sdp2.replace(new RegExp(internalStream.id, "g"), externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp2
      });
    }
    function replaceExternalStreamId(pc, description) {
      let sdp2 = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp2 = sdp2.replace(new RegExp(externalStream.id, "g"), internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp2
      });
    }
    ["createOffer", "createAnswer"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = {
        [method]() {
          const args = arguments;
          const isLegacyCall = arguments.length && typeof arguments[0] === "function";
          if (isLegacyCall) {
            return nativeMethod.apply(this, [(description) => {
              const desc = replaceInternalStreamId(this, description);
              args[0].apply(null, [desc]);
            }, (err) => {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]]);
          }
          return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
        }
      };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
    const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
    window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };
    const origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, "localDescription");
    Object.defineProperty(window2.RTCPeerConnection.prototype, "localDescription", {
      get() {
        const description = origLocalDescription.get.apply(this);
        if (description.type === "") {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    });
    window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      if (this.signalingState === "closed") {
        throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
      }
      if (!sender._pc) {
        throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
      }
      const isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
      }
      this._streams = this._streams || {};
      let stream;
      Object.keys(this._streams).forEach((streamid) => {
        const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
        if (hasTrack) {
          stream = this._streams[streamid];
        }
      });
      if (stream) {
        if (stream.getTracks().length === 1) {
          this.removeStream(this._reverseStreams[stream.id]);
        } else {
          stream.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event("negotiationneeded"));
      }
    };
  }
  function shimPeerConnection$1(window2, browserDetails2) {
    if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
      window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
    }
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (browserDetails2.version < 53) {
      ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
        const nativeMethod = window2.RTCPeerConnection.prototype[method];
        const methodObj = {
          [method]() {
            arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }
        };
        window2.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
  }
  function fixNegotiationNeeded(window2, browserDetails2) {
    wrapPeerConnectionEvent(window2, "negotiationneeded", (e2) => {
      const pc = e2.target;
      if (browserDetails2.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
        if (pc.signalingState !== "stable") {
          return;
        }
      }
      return e2;
    });
  }
  var chromeShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fixNegotiationNeeded,
    shimAddTrackRemoveTrack,
    shimAddTrackRemoveTrackWithNative,
    shimGetSendersWithDtmf,
    shimGetUserMedia: shimGetUserMedia$2,
    shimMediaStream,
    shimOnTrack: shimOnTrack$1,
    shimPeerConnection: shimPeerConnection$1,
    shimSenderReceiverGetStats
  });
  function shimGetUserMedia$1(window2, browserDetails2) {
    const navigator2 = window2 && window2.navigator;
    const MediaStreamTrack2 = window2 && window2.MediaStreamTrack;
    navigator2.getUserMedia = function(constraints, onSuccess, onError) {
      deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
      navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };
    if (!(browserDetails2.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
      const remap = function(obj, a2, b2) {
        if (a2 in obj && !(b2 in obj)) {
          obj[b2] = obj[a2];
          delete obj[a2];
        }
      };
      const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
      navigator2.mediaDevices.getUserMedia = function(c2) {
        if (typeof c2 === "object" && typeof c2.audio === "object") {
          c2 = JSON.parse(JSON.stringify(c2));
          remap(c2.audio, "autoGainControl", "mozAutoGainControl");
          remap(c2.audio, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeGetUserMedia(c2);
      };
      if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {
        const nativeGetSettings = MediaStreamTrack2.prototype.getSettings;
        MediaStreamTrack2.prototype.getSettings = function() {
          const obj = nativeGetSettings.apply(this, arguments);
          remap(obj, "mozAutoGainControl", "autoGainControl");
          remap(obj, "mozNoiseSuppression", "noiseSuppression");
          return obj;
        };
      }
      if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {
        const nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;
        MediaStreamTrack2.prototype.applyConstraints = function(c2) {
          if (this.kind === "audio" && typeof c2 === "object") {
            c2 = JSON.parse(JSON.stringify(c2));
            remap(c2, "autoGainControl", "mozAutoGainControl");
            remap(c2, "noiseSuppression", "mozNoiseSuppression");
          }
          return nativeApplyConstraints.apply(this, [c2]);
        };
      }
    }
  }
  function shimGetDisplayMedia(window2, preferredMediaSource) {
    if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
      return;
    }
    if (!window2.navigator.mediaDevices) {
      return;
    }
    window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
      if (!(constraints && constraints.video)) {
        const err = new DOMException("getDisplayMedia without video constraints is undefined");
        err.name = "NotFoundError";
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {
          mediaSource: preferredMediaSource
        };
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    };
  }
  function shimOnTrack(window2) {
    if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
      Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return {
            receiver: this.receiver
          };
        }
      });
    }
  }
  function shimPeerConnection(window2, browserDetails2) {
    if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
      return;
    }
    if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
      window2.RTCPeerConnection = window2.mozRTCPeerConnection;
    }
    if (browserDetails2.version < 53) {
      ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
        const nativeMethod = window2.RTCPeerConnection.prototype[method];
        const methodObj = {
          [method]() {
            arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }
        };
        window2.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
    const modernStatsTypes = {
      inboundrtp: "inbound-rtp",
      outboundrtp: "outbound-rtp",
      candidatepair: "candidate-pair",
      localcandidate: "local-candidate",
      remotecandidate: "remote-candidate"
    };
    const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
      return nativeGetStats.apply(this, [selector || null]).then((stats) => {
        if (browserDetails2.version < 53 && !onSucc) {
          try {
            stats.forEach((stat) => {
              stat.type = modernStatsTypes[stat.type] || stat.type;
            });
          } catch (e2) {
            if (e2.name !== "TypeError") {
              throw e2;
            }
            stats.forEach((stat, i2) => {
              stats.set(i2, Object.assign({}, stat, {
                type: modernStatsTypes[stat.type] || stat.type
              }));
            });
          }
        }
        return stats;
      }).then(onSucc, onErr);
    };
  }
  function shimSenderGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
      return;
    }
    if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
      return;
    }
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
    };
  }
  function shimReceiverGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
      return;
    }
    if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
      return;
    }
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", (e2) => {
      e2.receiver._pc = e2.srcElement;
      return e2;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      return this._pc.getStats(this.track);
    };
  }
  function shimRemoveStream(window2) {
    if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
      return;
    }
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      deprecated("removeStream", "removeTrack");
      this.getSenders().forEach((sender) => {
        if (sender.track && stream.getTracks().includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
  function shimRTCDataChannel(window2) {
    if (window2.DataChannel && !window2.RTCDataChannel) {
      window2.RTCDataChannel = window2.DataChannel;
    }
  }
  function shimAddTransceiver(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
    if (origAddTransceiver) {
      window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
        this.setParametersPromises = [];
        let sendEncodings = arguments[1] && arguments[1].sendEncodings;
        if (sendEncodings === void 0) {
          sendEncodings = [];
        }
        sendEncodings = [...sendEncodings];
        const shouldPerformCheck = sendEncodings.length > 0;
        if (shouldPerformCheck) {
          sendEncodings.forEach((encodingParam) => {
            if ("rid" in encodingParam) {
              const ridRegex = /^[a-z0-9]{0,16}$/i;
              if (!ridRegex.test(encodingParam.rid)) {
                throw new TypeError("Invalid RID value provided.");
              }
            }
            if ("scaleResolutionDownBy" in encodingParam) {
              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
                throw new RangeError("scale_resolution_down_by must be >= 1.0");
              }
            }
            if ("maxFramerate" in encodingParam) {
              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                throw new RangeError("max_framerate must be >= 0.0");
              }
            }
          });
        }
        const transceiver = origAddTransceiver.apply(this, arguments);
        if (shouldPerformCheck) {
          const {
            sender
          } = transceiver;
          const params = sender.getParameters();
          if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
          params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
            params.encodings = sendEncodings;
            sender.sendEncodings = sendEncodings;
            this.setParametersPromises.push(sender.setParameters(params).then(() => {
              delete sender.sendEncodings;
            }).catch(() => {
              delete sender.sendEncodings;
            }));
          }
        }
        return transceiver;
      };
    }
  }
  function shimGetParameters(window2) {
    if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
      return;
    }
    const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
    if (origGetParameters) {
      window2.RTCRtpSender.prototype.getParameters = function getParameters() {
        const params = origGetParameters.apply(this, arguments);
        if (!("encodings" in params)) {
          params.encodings = [].concat(this.sendEncodings || [{}]);
        }
        return params;
      };
    }
  }
  function shimCreateOffer(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
    window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises).then(() => {
          return origCreateOffer.apply(this, arguments);
        }).finally(() => {
          this.setParametersPromises = [];
        });
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimCreateAnswer(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
    window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises).then(() => {
          return origCreateAnswer.apply(this, arguments);
        }).finally(() => {
          this.setParametersPromises = [];
        });
      }
      return origCreateAnswer.apply(this, arguments);
    };
  }
  var firefoxShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    shimAddTransceiver,
    shimCreateAnswer,
    shimCreateOffer,
    shimGetDisplayMedia,
    shimGetParameters,
    shimGetUserMedia: shimGetUserMedia$1,
    shimOnTrack,
    shimPeerConnection,
    shimRTCDataChannel,
    shimReceiverGetStats,
    shimRemoveStream,
    shimSenderGetStats
  });
  function shimLocalStreamsAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!("addStream" in window2.RTCPeerConnection.prototype)) {
      const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
        stream.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream));
        stream.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream));
      };
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
        for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          streams[_key - 1] = arguments[_key];
        }
        if (streams) {
          streams.forEach((stream) => {
            if (!this._localStreams) {
              this._localStreams = [stream];
            } else if (!this._localStreams.includes(stream)) {
              this._localStreams.push(stream);
            }
          });
        }
        return _addTrack.apply(this, arguments);
      };
    }
    if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        const index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        const tracks = stream.getTracks();
        this.getSenders().forEach((sender) => {
          if (tracks.includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
    }
  }
  function shimRemoteStreamsAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
        get() {
          return this._onaddstream;
        },
        set(f2) {
          if (this._onaddstream) {
            this.removeEventListener("addstream", this._onaddstream);
            this.removeEventListener("track", this._onaddstreampoly);
          }
          this.addEventListener("addstream", this._onaddstream = f2);
          this.addEventListener("track", this._onaddstreampoly = (e2) => {
            e2.streams.forEach((stream) => {
              if (!this._remoteStreams) {
                this._remoteStreams = [];
              }
              if (this._remoteStreams.includes(stream)) {
                return;
              }
              this._remoteStreams.push(stream);
              const event = new Event("addstream");
              event.stream = stream;
              this.dispatchEvent(event);
            });
          });
        }
      });
      const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
      window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        const pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener("track", this._onaddstreampoly = function(e2) {
            e2.streams.forEach((stream) => {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              const event = new Event("addstream");
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  }
  function shimCallbacksAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    const prototype = window2.RTCPeerConnection.prototype;
    const origCreateOffer = prototype.createOffer;
    const origCreateAnswer = prototype.createAnswer;
    const setLocalDescription = prototype.setLocalDescription;
    const setRemoteDescription = prototype.setRemoteDescription;
    const addIceCandidate = prototype.addIceCandidate;
    prototype.createOffer = function createOffer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    let withCallback = function(description, successCallback, failureCallback) {
      const promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;
    withCallback = function(description, successCallback, failureCallback) {
      const promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;
    withCallback = function(candidate, successCallback, failureCallback) {
      const promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  }
  function shimGetUserMedia(window2) {
    const navigator2 = window2 && window2.navigator;
    if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
      const mediaDevices = navigator2.mediaDevices;
      const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator2.mediaDevices.getUserMedia = (constraints) => {
        return _getUserMedia(shimConstraints(constraints));
      };
    }
    if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
      navigator2.getUserMedia = (function getUserMedia(constraints, cb, errcb) {
        navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
      }).bind(navigator2);
    }
  }
  function shimConstraints(constraints) {
    if (constraints && constraints.video !== void 0) {
      return Object.assign({}, constraints, {
        video: compactObject(constraints.video)
      });
    }
    return constraints;
  }
  function shimRTCIceServerUrls(window2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const OrigPeerConnection = window2.RTCPeerConnection;
    window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        const newIceServers = [];
        for (let i2 = 0; i2 < pcConfig.iceServers.length; i2++) {
          let server = pcConfig.iceServers[i2];
          if (server.urls === void 0 && server.url) {
            deprecated("RTCIceServer.url", "RTCIceServer.urls");
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i2]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    if ("generateCertificate" in OrigPeerConnection) {
      Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
        get() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  }
  function shimTrackEventTransceiver(window2) {
    if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
      Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return {
            receiver: this.receiver
          };
        }
      });
    }
  }
  function shimCreateOfferLegacy(window2) {
    const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
    window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === "sendrecv") {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection("sendonly");
            } else {
              audioTransceiver.direction = "sendonly";
            }
          } else if (audioTransceiver.direction === "recvonly") {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection("inactive");
            } else {
              audioTransceiver.direction = "inactive";
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
          this.addTransceiver("audio", {
            direction: "recvonly"
          });
        }
        if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === "sendrecv") {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection("sendonly");
            } else {
              videoTransceiver.direction = "sendonly";
            }
          } else if (videoTransceiver.direction === "recvonly") {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection("inactive");
            } else {
              videoTransceiver.direction = "inactive";
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
          this.addTransceiver("video", {
            direction: "recvonly"
          });
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimAudioContext(window2) {
    if (typeof window2 !== "object" || window2.AudioContext) {
      return;
    }
    window2.AudioContext = window2.webkitAudioContext;
  }
  var safariShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    shimAudioContext,
    shimCallbacksAPI,
    shimConstraints,
    shimCreateOfferLegacy,
    shimGetUserMedia,
    shimLocalStreamsAPI,
    shimRTCIceServerUrls,
    shimRemoteStreamsAPI,
    shimTrackEventTransceiver
  });
  var sdp$1 = { exports: {} };
  var hasRequiredSdp;
  function requireSdp() {
    if (hasRequiredSdp)
      return sdp$1.exports;
    hasRequiredSdp = 1;
    (function(module) {
      const SDPUtils2 = {};
      SDPUtils2.generateIdentifier = function() {
        return Math.random().toString(36).substring(2, 12);
      };
      SDPUtils2.localCName = SDPUtils2.generateIdentifier();
      SDPUtils2.splitLines = function(blob) {
        return blob.trim().split("\n").map((line) => line.trim());
      };
      SDPUtils2.splitSections = function(blob) {
        const parts = blob.split("\nm=");
        return parts.map((part, index) => (index > 0 ? "m=" + part : part).trim() + "\r\n");
      };
      SDPUtils2.getDescription = function(blob) {
        const sections = SDPUtils2.splitSections(blob);
        return sections && sections[0];
      };
      SDPUtils2.getMediaSections = function(blob) {
        const sections = SDPUtils2.splitSections(blob);
        sections.shift();
        return sections;
      };
      SDPUtils2.matchPrefix = function(blob, prefix) {
        return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
      };
      SDPUtils2.parseCandidate = function(line) {
        let parts;
        if (line.indexOf("a=candidate:") === 0) {
          parts = line.substring(12).split(" ");
        } else {
          parts = line.substring(10).split(" ");
        }
        const candidate = {
          foundation: parts[0],
          component: {
            1: "rtp",
            2: "rtcp"
          }[parts[1]] || parts[1],
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          address: parts[4],
          // address is an alias for ip.
          port: parseInt(parts[5], 10),
          // skip parts[6] == 'typ'
          type: parts[7]
        };
        for (let i2 = 8; i2 < parts.length; i2 += 2) {
          switch (parts[i2]) {
            case "raddr":
              candidate.relatedAddress = parts[i2 + 1];
              break;
            case "rport":
              candidate.relatedPort = parseInt(parts[i2 + 1], 10);
              break;
            case "tcptype":
              candidate.tcpType = parts[i2 + 1];
              break;
            case "ufrag":
              candidate.ufrag = parts[i2 + 1];
              candidate.usernameFragment = parts[i2 + 1];
              break;
            default:
              if (candidate[parts[i2]] === void 0) {
                candidate[parts[i2]] = parts[i2 + 1];
              }
              break;
          }
        }
        return candidate;
      };
      SDPUtils2.writeCandidate = function(candidate) {
        const sdp2 = [];
        sdp2.push(candidate.foundation);
        const component = candidate.component;
        if (component === "rtp") {
          sdp2.push(1);
        } else if (component === "rtcp") {
          sdp2.push(2);
        } else {
          sdp2.push(component);
        }
        sdp2.push(candidate.protocol.toUpperCase());
        sdp2.push(candidate.priority);
        sdp2.push(candidate.address || candidate.ip);
        sdp2.push(candidate.port);
        const type = candidate.type;
        sdp2.push("typ");
        sdp2.push(type);
        if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
          sdp2.push("raddr");
          sdp2.push(candidate.relatedAddress);
          sdp2.push("rport");
          sdp2.push(candidate.relatedPort);
        }
        if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
          sdp2.push("tcptype");
          sdp2.push(candidate.tcpType);
        }
        if (candidate.usernameFragment || candidate.ufrag) {
          sdp2.push("ufrag");
          sdp2.push(candidate.usernameFragment || candidate.ufrag);
        }
        return "candidate:" + sdp2.join(" ");
      };
      SDPUtils2.parseIceOptions = function(line) {
        return line.substring(14).split(" ");
      };
      SDPUtils2.parseRtpMap = function(line) {
        let parts = line.substring(9).split(" ");
        const parsed = {
          payloadType: parseInt(parts.shift(), 10)
          // was: id
        };
        parts = parts[0].split("/");
        parsed.name = parts[0];
        parsed.clockRate = parseInt(parts[1], 10);
        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
        parsed.numChannels = parsed.channels;
        return parsed;
      };
      SDPUtils2.writeRtpMap = function(codec) {
        let pt2 = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt2 = codec.preferredPayloadType;
        }
        const channels = codec.channels || codec.numChannels || 1;
        return "a=rtpmap:" + pt2 + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
      };
      SDPUtils2.parseExtmap = function(line) {
        const parts = line.substring(9).split(" ");
        return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
          uri: parts[1],
          attributes: parts.slice(2).join(" ")
        };
      };
      SDPUtils2.writeExtmap = function(headerExtension) {
        return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
      };
      SDPUtils2.parseFmtp = function(line) {
        const parsed = {};
        let kv;
        const parts = line.substring(line.indexOf(" ") + 1).split(";");
        for (let j2 = 0; j2 < parts.length; j2++) {
          kv = parts[j2].trim().split("=");
          parsed[kv[0].trim()] = kv[1];
        }
        return parsed;
      };
      SDPUtils2.writeFmtp = function(codec) {
        let line = "";
        let pt2 = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt2 = codec.preferredPayloadType;
        }
        if (codec.parameters && Object.keys(codec.parameters).length) {
          const params = [];
          Object.keys(codec.parameters).forEach((param) => {
            if (codec.parameters[param] !== void 0) {
              params.push(param + "=" + codec.parameters[param]);
            } else {
              params.push(param);
            }
          });
          line += "a=fmtp:" + pt2 + " " + params.join(";") + "\r\n";
        }
        return line;
      };
      SDPUtils2.parseRtcpFb = function(line) {
        const parts = line.substring(line.indexOf(" ") + 1).split(" ");
        return {
          type: parts.shift(),
          parameter: parts.join(" ")
        };
      };
      SDPUtils2.writeRtcpFb = function(codec) {
        let lines = "";
        let pt2 = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt2 = codec.preferredPayloadType;
        }
        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
          codec.rtcpFeedback.forEach((fb) => {
            lines += "a=rtcp-fb:" + pt2 + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
          });
        }
        return lines;
      };
      SDPUtils2.parseSsrcMedia = function(line) {
        const sp = line.indexOf(" ");
        const parts = {
          ssrc: parseInt(line.substring(7, sp), 10)
        };
        const colon = line.indexOf(":", sp);
        if (colon > -1) {
          parts.attribute = line.substring(sp + 1, colon);
          parts.value = line.substring(colon + 1);
        } else {
          parts.attribute = line.substring(sp + 1);
        }
        return parts;
      };
      SDPUtils2.parseSsrcGroup = function(line) {
        const parts = line.substring(13).split(" ");
        return {
          semantics: parts.shift(),
          ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
        };
      };
      SDPUtils2.getMid = function(mediaSection) {
        const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
        if (mid) {
          return mid.substring(6);
        }
      };
      SDPUtils2.parseFingerprint = function(line) {
        const parts = line.substring(14).split(" ");
        return {
          algorithm: parts[0].toLowerCase(),
          // algorithm is case-sensitive in Edge.
          value: parts[1].toUpperCase()
          // the definition is upper-case in RFC 4572.
        };
      };
      SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
        return {
          role: "auto",
          fingerprints: lines.map(SDPUtils2.parseFingerprint)
        };
      };
      SDPUtils2.writeDtlsParameters = function(params, setupType) {
        let sdp2 = "a=setup:" + setupType + "\r\n";
        params.fingerprints.forEach((fp) => {
          sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
        });
        return sdp2;
      };
      SDPUtils2.parseCryptoLine = function(line) {
        const parts = line.substring(9).split(" ");
        return {
          tag: parseInt(parts[0], 10),
          cryptoSuite: parts[1],
          keyParams: parts[2],
          sessionParams: parts.slice(3)
        };
      };
      SDPUtils2.writeCryptoLine = function(parameters) {
        return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
      };
      SDPUtils2.parseCryptoKeyParams = function(keyParams) {
        if (keyParams.indexOf("inline:") !== 0) {
          return null;
        }
        const parts = keyParams.substring(7).split("|");
        return {
          keyMethod: "inline",
          keySalt: parts[0],
          lifeTime: parts[1],
          mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
          mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
        };
      };
      SDPUtils2.writeCryptoKeyParams = function(keyParams) {
        return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
      };
      SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=crypto:");
        return lines.map(SDPUtils2.parseCryptoLine);
      };
      SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
        const ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
        const pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
        if (!(ufrag && pwd)) {
          return null;
        }
        return {
          usernameFragment: ufrag.substring(12),
          password: pwd.substring(10)
        };
      };
      SDPUtils2.writeIceParameters = function(params) {
        let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
        if (params.iceLite) {
          sdp2 += "a=ice-lite\r\n";
        }
        return sdp2;
      };
      SDPUtils2.parseRtpParameters = function(mediaSection) {
        const description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: []
        };
        const lines = SDPUtils2.splitLines(mediaSection);
        const mline = lines[0].split(" ");
        description.profile = mline[2];
        for (let i2 = 3; i2 < mline.length; i2++) {
          const pt2 = mline[i2];
          const rtpmapline = SDPUtils2.matchPrefix(mediaSection, "a=rtpmap:" + pt2 + " ")[0];
          if (rtpmapline) {
            const codec = SDPUtils2.parseRtpMap(rtpmapline);
            const fmtps = SDPUtils2.matchPrefix(mediaSection, "a=fmtp:" + pt2 + " ");
            codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:" + pt2 + " ").map(SDPUtils2.parseRtcpFb);
            description.codecs.push(codec);
            switch (codec.name.toUpperCase()) {
              case "RED":
              case "ULPFEC":
                description.fecMechanisms.push(codec.name.toUpperCase());
                break;
            }
          }
        }
        SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
          description.headerExtensions.push(SDPUtils2.parseExtmap(line));
        });
        const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils2.parseRtcpFb);
        description.codecs.forEach((codec) => {
          wildcardRtcpFb.forEach((fb) => {
            const duplicate = codec.rtcpFeedback.find((existingFeedback) => {
              return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
            });
            if (!duplicate) {
              codec.rtcpFeedback.push(fb);
            }
          });
        });
        return description;
      };
      SDPUtils2.writeRtpDescription = function(kind, caps) {
        let sdp2 = "";
        sdp2 += "m=" + kind + " ";
        sdp2 += caps.codecs.length > 0 ? "9" : "0";
        sdp2 += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
        sdp2 += caps.codecs.map((codec) => {
          if (codec.preferredPayloadType !== void 0) {
            return codec.preferredPayloadType;
          }
          return codec.payloadType;
        }).join(" ") + "\r\n";
        sdp2 += "c=IN IP4 0.0.0.0\r\n";
        sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
        caps.codecs.forEach((codec) => {
          sdp2 += SDPUtils2.writeRtpMap(codec);
          sdp2 += SDPUtils2.writeFmtp(codec);
          sdp2 += SDPUtils2.writeRtcpFb(codec);
        });
        let maxptime = 0;
        caps.codecs.forEach((codec) => {
          if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
          }
        });
        if (maxptime > 0) {
          sdp2 += "a=maxptime:" + maxptime + "\r\n";
        }
        if (caps.headerExtensions) {
          caps.headerExtensions.forEach((extension) => {
            sdp2 += SDPUtils2.writeExtmap(extension);
          });
        }
        return sdp2;
      };
      SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
        const encodingParameters = [];
        const description = SDPUtils2.parseRtpParameters(mediaSection);
        const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
        const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
        const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
        let secondarySsrc;
        const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
          const parts = line.substring(17).split(" ");
          return parts.map((part) => parseInt(part, 10));
        });
        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
          secondarySsrc = flows[0][1];
        }
        description.codecs.forEach((codec) => {
          if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
            let encParam = {
              ssrc: primarySsrc,
              codecPayloadType: parseInt(codec.parameters.apt, 10)
            };
            if (primarySsrc && secondarySsrc) {
              encParam.rtx = {
                ssrc: secondarySsrc
              };
            }
            encodingParameters.push(encParam);
            if (hasRed) {
              encParam = JSON.parse(JSON.stringify(encParam));
              encParam.fec = {
                ssrc: primarySsrc,
                mechanism: hasUlpfec ? "red+ulpfec" : "red"
              };
              encodingParameters.push(encParam);
            }
          }
        });
        if (encodingParameters.length === 0 && primarySsrc) {
          encodingParameters.push({
            ssrc: primarySsrc
          });
        }
        let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
        if (bandwidth.length) {
          if (bandwidth[0].indexOf("b=TIAS:") === 0) {
            bandwidth = parseInt(bandwidth[0].substring(7), 10);
          } else if (bandwidth[0].indexOf("b=AS:") === 0) {
            bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
          } else {
            bandwidth = void 0;
          }
          encodingParameters.forEach((params) => {
            params.maxBitrate = bandwidth;
          });
        }
        return encodingParameters;
      };
      SDPUtils2.parseRtcpParameters = function(mediaSection) {
        const rtcpParameters = {};
        const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
        if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
        }
        const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
        rtcpParameters.reducedSize = rsize.length > 0;
        rtcpParameters.compound = rsize.length === 0;
        const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
        rtcpParameters.mux = mux.length > 0;
        return rtcpParameters;
      };
      SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
        let sdp2 = "";
        if (rtcpParameters.reducedSize) {
          sdp2 += "a=rtcp-rsize\r\n";
        }
        if (rtcpParameters.mux) {
          sdp2 += "a=rtcp-mux\r\n";
        }
        if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
          sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
        }
        return sdp2;
      };
      SDPUtils2.parseMsid = function(mediaSection) {
        let parts;
        const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
        if (spec.length === 1) {
          parts = spec[0].substring(7).split(" ");
          return {
            stream: parts[0],
            track: parts[1]
          };
        }
        const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
        if (planB.length > 0) {
          parts = planB[0].value.split(" ");
          return {
            stream: parts[0],
            track: parts[1]
          };
        }
      };
      SDPUtils2.parseSctpDescription = function(mediaSection) {
        const mline = SDPUtils2.parseMLine(mediaSection);
        const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
        let maxMessageSize;
        if (maxSizeLine.length > 0) {
          maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
        }
        if (isNaN(maxMessageSize)) {
          maxMessageSize = 65536;
        }
        const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
        if (sctpPort.length > 0) {
          return {
            port: parseInt(sctpPort[0].substring(12), 10),
            protocol: mline.fmt,
            maxMessageSize
          };
        }
        const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
        if (sctpMapLines.length > 0) {
          const parts = sctpMapLines[0].substring(10).split(" ");
          return {
            port: parseInt(parts[0], 10),
            protocol: parts[1],
            maxMessageSize
          };
        }
      };
      SDPUtils2.writeSctpDescription = function(media, sctp) {
        let output = [];
        if (media.protocol !== "DTLS/SCTP") {
          output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + sctp.port + "\r\n"];
        } else {
          output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"];
        }
        if (sctp.maxMessageSize !== void 0) {
          output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
        }
        return output.join("");
      };
      SDPUtils2.generateSessionId = function() {
        return Math.random().toString().substr(2, 22);
      };
      SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
        let sessionId;
        const version2 = sessVer !== void 0 ? sessVer : 2;
        if (sessId) {
          sessionId = sessId;
        } else {
          sessionId = SDPUtils2.generateSessionId();
        }
        const user = sessUser || "thisisadapterortc";
        return "v=0\r\no=" + user + " " + sessionId + " " + version2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
      };
      SDPUtils2.getDirection = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.splitLines(mediaSection);
        for (let i2 = 0; i2 < lines.length; i2++) {
          switch (lines[i2]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return lines[i2].substring(2);
          }
        }
        if (sessionpart) {
          return SDPUtils2.getDirection(sessionpart);
        }
        return "sendrecv";
      };
      SDPUtils2.getKind = function(mediaSection) {
        const lines = SDPUtils2.splitLines(mediaSection);
        const mline = lines[0].split(" ");
        return mline[0].substring(2);
      };
      SDPUtils2.isRejected = function(mediaSection) {
        return mediaSection.split(" ", 2)[1] === "0";
      };
      SDPUtils2.parseMLine = function(mediaSection) {
        const lines = SDPUtils2.splitLines(mediaSection);
        const parts = lines[0].substring(2).split(" ");
        return {
          kind: parts[0],
          port: parseInt(parts[1], 10),
          protocol: parts[2],
          fmt: parts.slice(3).join(" ")
        };
      };
      SDPUtils2.parseOLine = function(mediaSection) {
        const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
        const parts = line.substring(2).split(" ");
        return {
          username: parts[0],
          sessionId: parts[1],
          sessionVersion: parseInt(parts[2], 10),
          netType: parts[3],
          addressType: parts[4],
          address: parts[5]
        };
      };
      SDPUtils2.isValidSDP = function(blob) {
        if (typeof blob !== "string" || blob.length === 0) {
          return false;
        }
        const lines = SDPUtils2.splitLines(blob);
        for (let i2 = 0; i2 < lines.length; i2++) {
          if (lines[i2].length < 2 || lines[i2].charAt(1) !== "=") {
            return false;
          }
        }
        return true;
      };
      {
        module.exports = SDPUtils2;
      }
    })(sdp$1);
    return sdp$1.exports;
  }
  var sdpExports = requireSdp();
  var SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs$1(sdpExports);
  var sdp = /* @__PURE__ */ _mergeNamespaces$1({
    __proto__: null,
    default: SDPUtils
  }, [sdpExports]);
  function shimRTCIceCandidate(window2) {
    if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
      return;
    }
    const NativeRTCIceCandidate = window2.RTCIceCandidate;
    window2.RTCIceCandidate = function RTCIceCandidate2(args) {
      if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substring(2);
      }
      if (args.candidate && args.candidate.length) {
        const nativeCandidate = new NativeRTCIceCandidate(args);
        const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        for (const key in parsedCandidate) {
          if (!(key in nativeCandidate)) {
            Object.defineProperty(nativeCandidate, key, {
              value: parsedCandidate[key]
            });
          }
        }
        nativeCandidate.toJSON = function toJSON() {
          return {
            candidate: nativeCandidate.candidate,
            sdpMid: nativeCandidate.sdpMid,
            sdpMLineIndex: nativeCandidate.sdpMLineIndex,
            usernameFragment: nativeCandidate.usernameFragment
          };
        };
        return nativeCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
    wrapPeerConnectionEvent(window2, "icecandidate", (e2) => {
      if (e2.candidate) {
        Object.defineProperty(e2, "candidate", {
          value: new window2.RTCIceCandidate(e2.candidate),
          writable: "false"
        });
      }
      return e2;
    });
  }
  function shimRTCIceCandidateRelayProtocol(window2) {
    if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "relayProtocol" in window2.RTCIceCandidate.prototype) {
      return;
    }
    wrapPeerConnectionEvent(window2, "icecandidate", (e2) => {
      if (e2.candidate) {
        const parsedCandidate = SDPUtils.parseCandidate(e2.candidate.candidate);
        if (parsedCandidate.type === "relay") {
          e2.candidate.relayProtocol = {
            0: "tls",
            1: "tcp",
            2: "udp"
          }[parsedCandidate.priority >> 24];
        }
      }
      return e2;
    });
  }
  function shimMaxMessageSize(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (!("sctp" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
        get() {
          return typeof this._sctp === "undefined" ? null : this._sctp;
        }
      });
    }
    const sctpInDescription = function(description) {
      if (!description || !description.sdp) {
        return false;
      }
      const sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some((mediaSection) => {
        const mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
      });
    };
    const getRemoteFirefoxVersion = function(description) {
      const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      const version2 = parseInt(match[1], 10);
      return version2 !== version2 ? -1 : version2;
    };
    const getCanSendMaxMessageSize = function(remoteIsFirefox) {
      let canSendMaxMessageSize = 65536;
      if (browserDetails2.browser === "firefox") {
        if (browserDetails2.version < 57) {
          if (remoteIsFirefox === -1) {
            canSendMaxMessageSize = 16384;
          } else {
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails2.version < 60) {
          canSendMaxMessageSize = browserDetails2.version === 57 ? 65535 : 65536;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };
    const getMaxMessageSize = function(description, remoteIsFirefox) {
      let maxMessageSize = 65536;
      if (browserDetails2.browser === "firefox" && browserDetails2.version === 57) {
        maxMessageSize = 65535;
      }
      const match = SDPUtils.matchPrefix(description.sdp, "a=max-message-size:");
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substring(19), 10);
      } else if (browserDetails2.browser === "firefox" && remoteIsFirefox !== -1) {
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      this._sctp = null;
      if (browserDetails2.browser === "chrome" && browserDetails2.version >= 76) {
        const {
          sdpSemantics
        } = this.getConfiguration();
        if (sdpSemantics === "plan-b") {
          Object.defineProperty(this, "sctp", {
            get() {
              return typeof this._sctp === "undefined" ? null : this._sctp;
            },
            enumerable: true,
            configurable: true
          });
        }
      }
      if (sctpInDescription(arguments[0])) {
        const isFirefox = getRemoteFirefoxVersion(arguments[0]);
        const canSendMMS = getCanSendMaxMessageSize(isFirefox);
        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
        let maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }
        const sctp = {};
        Object.defineProperty(sctp, "maxMessageSize", {
          get() {
            return maxMessageSize;
          }
        });
        this._sctp = sctp;
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  }
  function shimSendThrowTypeError(window2) {
    if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
      return;
    }
    function wrapDcSend(dc, pc) {
      const origDataChannelSend = dc.send;
      dc.send = function send() {
        const data = arguments[0];
        const length = data.length || data.size || data.byteLength;
        if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
    window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
      const dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
    wrapPeerConnectionEvent(window2, "datachannel", (e2) => {
      wrapDcSend(e2.channel, e2.target);
      return e2;
    });
  }
  function shimConnectionState(window2) {
    if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
      return;
    }
    const proto = window2.RTCPeerConnection.prototype;
    Object.defineProperty(proto, "connectionState", {
      get() {
        return {
          completed: "connected",
          checking: "connecting"
        }[this.iceConnectionState] || this.iceConnectionState;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(proto, "onconnectionstatechange", {
      get() {
        return this._onconnectionstatechange || null;
      },
      set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
    ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
      const origMethod = proto[method];
      proto[method] = function() {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = (e2) => {
            const pc = e2.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              const newEvent = new Event("connectionstatechange", e2);
              pc.dispatchEvent(newEvent);
            }
            return e2;
          };
          this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
        }
        return origMethod.apply(this, arguments);
      };
    });
  }
  function removeExtmapAllowMixed(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (browserDetails2.browser === "chrome" && browserDetails2.version >= 71) {
      return;
    }
    if (browserDetails2.browser === "safari" && browserDetails2.version >= 605) {
      return;
    }
    const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
      if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
        const sdp2 = desc.sdp.split("\n").filter((line) => {
          return line.trim() !== "a=extmap-allow-mixed";
        }).join("\n");
        if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
          arguments[0] = new window2.RTCSessionDescription({
            type: desc.type,
            sdp: sdp2
          });
        } else {
          desc.sdp = sdp2;
        }
      }
      return nativeSRD.apply(this, arguments);
    };
  }
  function shimAddIceCandidateNullOrEmpty(window2, browserDetails2) {
    if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
      return;
    }
    window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      if ((browserDetails2.browser === "chrome" && browserDetails2.version < 78 || browserDetails2.browser === "firefox" && browserDetails2.version < 68 || browserDetails2.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
  function shimParameterlessSetLocalDescription(window2, browserDetails2) {
    if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
      return;
    }
    window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      let desc = arguments[0] || {};
      if (typeof desc !== "object" || desc.type && desc.sdp) {
        return nativeSetLocalDescription.apply(this, arguments);
      }
      desc = {
        type: desc.type,
        sdp: desc.sdp
      };
      if (!desc.type) {
        switch (this.signalingState) {
          case "stable":
          case "have-local-offer":
          case "have-remote-pranswer":
            desc.type = "offer";
            break;
          default:
            desc.type = "answer";
            break;
        }
      }
      if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
        return nativeSetLocalDescription.apply(this, [desc]);
      }
      const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
      return func.apply(this).then((d2) => nativeSetLocalDescription.apply(this, [d2]));
    };
  }
  var commonShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    removeExtmapAllowMixed,
    shimAddIceCandidateNullOrEmpty,
    shimConnectionState,
    shimMaxMessageSize,
    shimParameterlessSetLocalDescription,
    shimRTCIceCandidate,
    shimRTCIceCandidateRelayProtocol,
    shimSendThrowTypeError
  });
  function adapterFactory() {
    let {
      window: window2
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      shimChrome: true,
      shimFirefox: true,
      shimSafari: true
    };
    const logging2 = log;
    const browserDetails2 = detectBrowser(window2);
    const adapter = {
      browserDetails: browserDetails2,
      commonShim,
      extractVersion,
      disableLog,
      disableWarnings,
      // Expose sdp as a convenience. For production apps include directly.
      sdp
    };
    switch (browserDetails2.browser) {
      case "chrome":
        if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {
          logging2("Chrome shim is not included in this adapter release.");
          return adapter;
        }
        if (browserDetails2.version === null) {
          logging2("Chrome shim can not determine version, not shimming.");
          return adapter;
        }
        logging2("adapter.js shimming chrome.");
        adapter.browserShim = chromeShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimGetUserMedia$2(window2, browserDetails2);
        shimMediaStream(window2);
        shimPeerConnection$1(window2, browserDetails2);
        shimOnTrack$1(window2);
        shimAddTrackRemoveTrack(window2, browserDetails2);
        shimGetSendersWithDtmf(window2);
        shimSenderReceiverGetStats(window2);
        fixNegotiationNeeded(window2, browserDetails2);
        shimRTCIceCandidate(window2);
        shimRTCIceCandidateRelayProtocol(window2);
        shimConnectionState(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        removeExtmapAllowMixed(window2, browserDetails2);
        break;
      case "firefox":
        if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {
          logging2("Firefox shim is not included in this adapter release.");
          return adapter;
        }
        logging2("adapter.js shimming firefox.");
        adapter.browserShim = firefoxShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimGetUserMedia$1(window2, browserDetails2);
        shimPeerConnection(window2, browserDetails2);
        shimOnTrack(window2);
        shimRemoveStream(window2);
        shimSenderGetStats(window2);
        shimReceiverGetStats(window2);
        shimRTCDataChannel(window2);
        shimAddTransceiver(window2);
        shimGetParameters(window2);
        shimCreateOffer(window2);
        shimCreateAnswer(window2);
        shimRTCIceCandidate(window2);
        shimConnectionState(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        break;
      case "safari":
        if (!safariShim || !options.shimSafari) {
          logging2("Safari shim is not included in this adapter release.");
          return adapter;
        }
        logging2("adapter.js shimming safari.");
        adapter.browserShim = safariShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimRTCIceServerUrls(window2);
        shimCreateOfferLegacy(window2);
        shimCallbacksAPI(window2);
        shimLocalStreamsAPI(window2);
        shimRemoteStreamsAPI(window2);
        shimTrackEventTransceiver(window2);
        shimGetUserMedia(window2);
        shimAudioContext(window2);
        shimRTCIceCandidate(window2);
        shimRTCIceCandidateRelayProtocol(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        removeExtmapAllowMixed(window2, browserDetails2);
        break;
      default:
        logging2("Unsupported browser!");
        break;
    }
    return adapter;
  }
  adapterFactory({
    window: typeof window === "undefined" ? void 0 : window
  });
  const DECRYPTION_FAILURE_TOLERANCE = 10;
  const E2EE_FLAG = "lk_e2ee";
  const SALT = "LKFrameEncryptionKey";
  const KEY_PROVIDER_DEFAULTS = {
    sharedKey: false,
    ratchetSalt: SALT,
    ratchetWindowSize: 8,
    failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
    keyringSize: 16
  };
  var KeyProviderEvent;
  (function(KeyProviderEvent2) {
    KeyProviderEvent2["SetKey"] = "setKey";
    KeyProviderEvent2["RatchetRequest"] = "ratchetRequest";
    KeyProviderEvent2["KeyRatcheted"] = "keyRatcheted";
  })(KeyProviderEvent || (KeyProviderEvent = {}));
  var KeyHandlerEvent;
  (function(KeyHandlerEvent2) {
    KeyHandlerEvent2["KeyRatcheted"] = "keyRatcheted";
  })(KeyHandlerEvent || (KeyHandlerEvent = {}));
  var EncryptionEvent;
  (function(EncryptionEvent2) {
    EncryptionEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
    EncryptionEvent2["EncryptionError"] = "encryptionError";
  })(EncryptionEvent || (EncryptionEvent = {}));
  var CryptorEvent;
  (function(CryptorEvent2) {
    CryptorEvent2["Error"] = "cryptorError";
  })(CryptorEvent || (CryptorEvent = {}));
  function isE2EESupported() {
    return isInsertableStreamSupported() || isScriptTransformSupported();
  }
  function isScriptTransformSupported() {
    return typeof window.RTCRtpScriptTransform !== "undefined";
  }
  function isInsertableStreamSupported() {
    return typeof window.RTCRtpSender !== "undefined" && // @ts-ignore
    typeof window.RTCRtpSender.prototype.createEncodedStreams !== "undefined";
  }
  class BaseKeyProvider extends eventsExports.EventEmitter {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      super();
      this.onKeyRatcheted = (material, keyIndex) => {
        livekitLogger.debug("key ratcheted event received", {
          material,
          keyIndex
        });
      };
      this.keyInfoMap = /* @__PURE__ */ new Map();
      this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);
      this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
    }
    /**
     * callback to invoke once a key has been set for a participant
     * @param key
     * @param participantIdentity
     * @param keyIndex
     */
    onSetEncryptionKey(key, participantIdentity, keyIndex) {
      const keyInfo = {
        key,
        participantIdentity,
        keyIndex
      };
      if (!this.options.sharedKey && !participantIdentity) {
        throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
      }
      this.keyInfoMap.set("".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : "shared", "-").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);
      this.emit(KeyProviderEvent.SetKey, keyInfo);
    }
    getKeys() {
      return Array.from(this.keyInfoMap.values());
    }
    getOptions() {
      return this.options;
    }
    ratchetKey(participantIdentity, keyIndex) {
      this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);
    }
  }
  class LivekitError extends Error {
    constructor(code, message) {
      super(message || "an error has occured");
      this.name = "LiveKitError";
      this.code = code;
    }
  }
  var ConnectionErrorReason;
  (function(ConnectionErrorReason2) {
    ConnectionErrorReason2[ConnectionErrorReason2["NotAllowed"] = 0] = "NotAllowed";
    ConnectionErrorReason2[ConnectionErrorReason2["ServerUnreachable"] = 1] = "ServerUnreachable";
    ConnectionErrorReason2[ConnectionErrorReason2["InternalError"] = 2] = "InternalError";
    ConnectionErrorReason2[ConnectionErrorReason2["Cancelled"] = 3] = "Cancelled";
    ConnectionErrorReason2[ConnectionErrorReason2["LeaveRequest"] = 4] = "LeaveRequest";
  })(ConnectionErrorReason || (ConnectionErrorReason = {}));
  class ConnectionError extends LivekitError {
    constructor(message, reason, status, context) {
      super(1, message);
      this.name = "ConnectionError";
      this.status = status;
      this.reason = reason;
      this.context = context;
      this.reasonName = ConnectionErrorReason[reason];
    }
  }
  class DeviceUnsupportedError extends LivekitError {
    constructor(message) {
      super(21, message !== null && message !== void 0 ? message : "device is unsupported");
      this.name = "DeviceUnsupportedError";
    }
  }
  class TrackInvalidError extends LivekitError {
    constructor(message) {
      super(20, message !== null && message !== void 0 ? message : "track is invalid");
      this.name = "TrackInvalidError";
    }
  }
  class UnsupportedServer extends LivekitError {
    constructor(message) {
      super(10, message !== null && message !== void 0 ? message : "unsupported server");
      this.name = "UnsupportedServer";
    }
  }
  class UnexpectedConnectionState extends LivekitError {
    constructor(message) {
      super(12, message !== null && message !== void 0 ? message : "unexpected connection state");
      this.name = "UnexpectedConnectionState";
    }
  }
  class NegotiationError extends LivekitError {
    constructor(message) {
      super(13, message !== null && message !== void 0 ? message : "unable to negotiate");
      this.name = "NegotiationError";
    }
  }
  class SignalRequestError extends LivekitError {
    constructor(message, reason) {
      super(15, message);
      this.reason = reason;
      this.reasonName = typeof reason === "string" ? reason : RequestResponse_Reason[reason];
    }
  }
  var MediaDeviceFailure;
  (function(MediaDeviceFailure2) {
    MediaDeviceFailure2["PermissionDenied"] = "PermissionDenied";
    MediaDeviceFailure2["NotFound"] = "NotFound";
    MediaDeviceFailure2["DeviceInUse"] = "DeviceInUse";
    MediaDeviceFailure2["Other"] = "Other";
  })(MediaDeviceFailure || (MediaDeviceFailure = {}));
  (function(MediaDeviceFailure2) {
    function getFailure(error) {
      if (error && "name" in error) {
        if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          return MediaDeviceFailure2.NotFound;
        }
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
          return MediaDeviceFailure2.PermissionDenied;
        }
        if (error.name === "NotReadableError" || error.name === "TrackStartError") {
          return MediaDeviceFailure2.DeviceInUse;
        }
        return MediaDeviceFailure2.Other;
      }
    }
    MediaDeviceFailure2.getFailure = getFailure;
  })(MediaDeviceFailure || (MediaDeviceFailure = {}));
  var CryptorErrorReason;
  (function(CryptorErrorReason2) {
    CryptorErrorReason2[CryptorErrorReason2["InvalidKey"] = 0] = "InvalidKey";
    CryptorErrorReason2[CryptorErrorReason2["MissingKey"] = 1] = "MissingKey";
    CryptorErrorReason2[CryptorErrorReason2["InternalError"] = 2] = "InternalError";
  })(CryptorErrorReason || (CryptorErrorReason = {}));
  var RoomEvent;
  (function(RoomEvent2) {
    RoomEvent2["Connected"] = "connected";
    RoomEvent2["Reconnecting"] = "reconnecting";
    RoomEvent2["SignalReconnecting"] = "signalReconnecting";
    RoomEvent2["Reconnected"] = "reconnected";
    RoomEvent2["Disconnected"] = "disconnected";
    RoomEvent2["ConnectionStateChanged"] = "connectionStateChanged";
    RoomEvent2["MediaDevicesChanged"] = "mediaDevicesChanged";
    RoomEvent2["ParticipantConnected"] = "participantConnected";
    RoomEvent2["ParticipantDisconnected"] = "participantDisconnected";
    RoomEvent2["TrackPublished"] = "trackPublished";
    RoomEvent2["TrackSubscribed"] = "trackSubscribed";
    RoomEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    RoomEvent2["TrackUnpublished"] = "trackUnpublished";
    RoomEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
    RoomEvent2["TrackMuted"] = "trackMuted";
    RoomEvent2["TrackUnmuted"] = "trackUnmuted";
    RoomEvent2["LocalTrackPublished"] = "localTrackPublished";
    RoomEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    RoomEvent2["LocalAudioSilenceDetected"] = "localAudioSilenceDetected";
    RoomEvent2["ActiveSpeakersChanged"] = "activeSpeakersChanged";
    RoomEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
    RoomEvent2["ParticipantNameChanged"] = "participantNameChanged";
    RoomEvent2["ParticipantAttributesChanged"] = "participantAttributesChanged";
    RoomEvent2["RoomMetadataChanged"] = "roomMetadataChanged";
    RoomEvent2["DataReceived"] = "dataReceived";
    RoomEvent2["SipDTMFReceived"] = "sipDTMFReceived";
    RoomEvent2["TranscriptionReceived"] = "transcriptionReceived";
    RoomEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
    RoomEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
    RoomEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    RoomEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
    RoomEvent2["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";
    RoomEvent2["VideoPlaybackStatusChanged"] = "videoPlaybackChanged";
    RoomEvent2["MediaDevicesError"] = "mediaDevicesError";
    RoomEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
    RoomEvent2["SignalConnected"] = "signalConnected";
    RoomEvent2["RecordingStatusChanged"] = "recordingStatusChanged";
    RoomEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
    RoomEvent2["EncryptionError"] = "encryptionError";
    RoomEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
    RoomEvent2["ActiveDeviceChanged"] = "activeDeviceChanged";
    RoomEvent2["ChatMessage"] = "chatMessage";
    RoomEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    RoomEvent2["MetricsReceived"] = "metricsReceived";
  })(RoomEvent || (RoomEvent = {}));
  var ParticipantEvent;
  (function(ParticipantEvent2) {
    ParticipantEvent2["TrackPublished"] = "trackPublished";
    ParticipantEvent2["TrackSubscribed"] = "trackSubscribed";
    ParticipantEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    ParticipantEvent2["TrackUnpublished"] = "trackUnpublished";
    ParticipantEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
    ParticipantEvent2["TrackMuted"] = "trackMuted";
    ParticipantEvent2["TrackUnmuted"] = "trackUnmuted";
    ParticipantEvent2["LocalTrackPublished"] = "localTrackPublished";
    ParticipantEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    ParticipantEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
    ParticipantEvent2["ParticipantNameChanged"] = "participantNameChanged";
    ParticipantEvent2["DataReceived"] = "dataReceived";
    ParticipantEvent2["SipDTMFReceived"] = "sipDTMFReceived";
    ParticipantEvent2["TranscriptionReceived"] = "transcriptionReceived";
    ParticipantEvent2["IsSpeakingChanged"] = "isSpeakingChanged";
    ParticipantEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
    ParticipantEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
    ParticipantEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    ParticipantEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
    ParticipantEvent2["MediaDevicesError"] = "mediaDevicesError";
    ParticipantEvent2["AudioStreamAcquired"] = "audioStreamAcquired";
    ParticipantEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
    ParticipantEvent2["PCTrackAdded"] = "pcTrackAdded";
    ParticipantEvent2["AttributesChanged"] = "attributesChanged";
    ParticipantEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    ParticipantEvent2["ChatMessage"] = "chatMessage";
  })(ParticipantEvent || (ParticipantEvent = {}));
  var EngineEvent;
  (function(EngineEvent2) {
    EngineEvent2["TransportsCreated"] = "transportsCreated";
    EngineEvent2["Connected"] = "connected";
    EngineEvent2["Disconnected"] = "disconnected";
    EngineEvent2["Resuming"] = "resuming";
    EngineEvent2["Resumed"] = "resumed";
    EngineEvent2["Restarting"] = "restarting";
    EngineEvent2["Restarted"] = "restarted";
    EngineEvent2["SignalResumed"] = "signalResumed";
    EngineEvent2["SignalRestarted"] = "signalRestarted";
    EngineEvent2["Closing"] = "closing";
    EngineEvent2["MediaTrackAdded"] = "mediaTrackAdded";
    EngineEvent2["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";
    EngineEvent2["DataPacketReceived"] = "dataPacketReceived";
    EngineEvent2["RTPVideoMapUpdate"] = "rtpVideoMapUpdate";
    EngineEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
    EngineEvent2["ParticipantUpdate"] = "participantUpdate";
    EngineEvent2["RoomUpdate"] = "roomUpdate";
    EngineEvent2["SpeakersChanged"] = "speakersChanged";
    EngineEvent2["StreamStateChanged"] = "streamStateChanged";
    EngineEvent2["ConnectionQualityUpdate"] = "connectionQualityUpdate";
    EngineEvent2["SubscriptionError"] = "subscriptionError";
    EngineEvent2["SubscriptionPermissionUpdate"] = "subscriptionPermissionUpdate";
    EngineEvent2["RemoteMute"] = "remoteMute";
    EngineEvent2["SubscribedQualityUpdate"] = "subscribedQualityUpdate";
    EngineEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    EngineEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    EngineEvent2["Offline"] = "offline";
    EngineEvent2["SignalRequestResponse"] = "signalRequestResponse";
  })(EngineEvent || (EngineEvent = {}));
  var TrackEvent;
  (function(TrackEvent2) {
    TrackEvent2["Message"] = "message";
    TrackEvent2["Muted"] = "muted";
    TrackEvent2["Unmuted"] = "unmuted";
    TrackEvent2["Restarted"] = "restarted";
    TrackEvent2["Ended"] = "ended";
    TrackEvent2["Subscribed"] = "subscribed";
    TrackEvent2["Unsubscribed"] = "unsubscribed";
    TrackEvent2["UpdateSettings"] = "updateSettings";
    TrackEvent2["UpdateSubscription"] = "updateSubscription";
    TrackEvent2["AudioPlaybackStarted"] = "audioPlaybackStarted";
    TrackEvent2["AudioPlaybackFailed"] = "audioPlaybackFailed";
    TrackEvent2["AudioSilenceDetected"] = "audioSilenceDetected";
    TrackEvent2["VisibilityChanged"] = "visibilityChanged";
    TrackEvent2["VideoDimensionsChanged"] = "videoDimensionsChanged";
    TrackEvent2["VideoPlaybackStarted"] = "videoPlaybackStarted";
    TrackEvent2["VideoPlaybackFailed"] = "videoPlaybackFailed";
    TrackEvent2["ElementAttached"] = "elementAttached";
    TrackEvent2["ElementDetached"] = "elementDetached";
    TrackEvent2["UpstreamPaused"] = "upstreamPaused";
    TrackEvent2["UpstreamResumed"] = "upstreamResumed";
    TrackEvent2["SubscriptionPermissionChanged"] = "subscriptionPermissionChanged";
    TrackEvent2["SubscriptionStatusChanged"] = "subscriptionStatusChanged";
    TrackEvent2["SubscriptionFailed"] = "subscriptionFailed";
    TrackEvent2["TrackProcessorUpdate"] = "trackProcessorUpdate";
    TrackEvent2["AudioTrackFeatureUpdate"] = "audioTrackFeatureUpdate";
    TrackEvent2["TranscriptionReceived"] = "transcriptionReceived";
    TrackEvent2["TimeSyncUpdate"] = "timeSyncUpdate";
  })(TrackEvent || (TrackEvent = {}));
  function cloneDeep(value) {
    if (typeof value === "undefined") {
      return;
    }
    if (typeof structuredClone === "function") {
      return structuredClone(value);
    } else {
      return JSON.parse(JSON.stringify(value));
    }
  }
  const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
  let browserDetails;
  function getBrowser(userAgent) {
    let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (typeof userAgent === "undefined" && typeof navigator === "undefined") {
      return;
    }
    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();
    if (browserDetails === void 0 || force) {
      const browser = browsersList.find((_ref) => {
        let {
          test
        } = _ref;
        return test.test(ua);
      });
      browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);
    }
    return browserDetails;
  }
  const browsersList = [
    {
      test: /firefox|iceweasel|fxios/i,
      describe(ua) {
        const browser = {
          name: "Firefox",
          version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua),
          os: ua.toLowerCase().includes("fxios") ? "iOS" : void 0,
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    },
    {
      test: /chrom|crios|crmo/i,
      describe(ua) {
        const browser = {
          name: "Chrome",
          version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua),
          os: ua.toLowerCase().includes("crios") ? "iOS" : void 0,
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    },
    /* Safari */
    {
      test: /safari|applewebkit/i,
      describe(ua) {
        const browser = {
          name: "Safari",
          version: getMatch(commonVersionIdentifier, ua),
          os: ua.includes("mobile/") ? "iOS" : "macOS",
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    }
  ];
  function getMatch(exp, ua) {
    let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const match = ua.match(exp);
    return match && match.length >= id && match[id] || "";
  }
  function getOSVersion(ua) {
    return ua.includes("mac os") ? getMatch(/\(.+?(\d+_\d+(:?_\d+)?)/, ua, 1).replace(/_/g, ".") : void 0;
  }
  var version$1 = "2.9.1";
  const version = version$1;
  const protocolVersion = 15;
  class CriticalTimers {
  }
  CriticalTimers.setTimeout = function() {
    return setTimeout(...arguments);
  };
  CriticalTimers.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval
  function() {
    return setInterval(...arguments);
  };
  CriticalTimers.clearTimeout = function() {
    return clearTimeout(...arguments);
  };
  CriticalTimers.clearInterval = function() {
    return clearInterval(...arguments);
  };
  const BACKGROUND_REACTION_DELAY = 5e3;
  const recycledElements = [];
  var VideoQuality;
  (function(VideoQuality2) {
    VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
    VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
    VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
  })(VideoQuality || (VideoQuality = {}));
  class Track extends eventsExports.EventEmitter {
    constructor(mediaTrack, kind) {
      let loggerOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _a;
      super();
      this.attachedElements = [];
      this.isMuted = false;
      this.streamState = Track.StreamState.Active;
      this.isInBackground = false;
      this._currentBitrate = 0;
      this.log = livekitLogger;
      this.appVisibilityChangedListener = () => {
        if (this.backgroundTimeout) {
          clearTimeout(this.backgroundTimeout);
        }
        if (document.visibilityState === "hidden") {
          this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);
        } else {
          this.handleAppVisibilityChanged();
        }
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);
      this.loggerContextCb = loggerOptions.loggerContextCb;
      this.setMaxListeners(100);
      this.kind = kind;
      this._mediaStreamTrack = mediaTrack;
      this._mediaStreamID = mediaTrack.id;
      this.source = Track.Source.Unknown;
    }
    get logContext() {
      var _a;
      return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));
    }
    /** current receive bits per second */
    get currentBitrate() {
      return this._currentBitrate;
    }
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    /**
     * @internal
     * used for keep mediaStream's first id, since it's id might change
     * if we disable/enable a track
     */
    get mediaStreamID() {
      return this._mediaStreamID;
    }
    attach(element) {
      let elementType = "audio";
      if (this.kind === Track.Kind.Video) {
        elementType = "video";
      }
      if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {
        this.addAppVisibilityListener();
      }
      if (!element) {
        if (elementType === "audio") {
          recycledElements.forEach((e2) => {
            if (e2.parentElement === null && !element) {
              element = e2;
            }
          });
          if (element) {
            recycledElements.splice(recycledElements.indexOf(element), 1);
          }
        }
        if (!element) {
          element = document.createElement(elementType);
        }
      }
      if (!this.attachedElements.includes(element)) {
        this.attachedElements.push(element);
      }
      attachToElement(this.mediaStreamTrack, element);
      const allMediaStreamTracks = element.srcObject.getTracks();
      const hasAudio = allMediaStreamTracks.some((tr) => tr.kind === "audio");
      element.play().then(() => {
        this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
      }).catch((e2) => {
        if (e2.name === "NotAllowedError") {
          this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e2);
        } else if (e2.name === "AbortError") {
          livekitLogger.debug("".concat(hasAudio ? "audio" : "video", " playback aborted, likely due to new play request"));
        } else {
          livekitLogger.warn("could not playback ".concat(hasAudio ? "audio" : "video"), e2);
        }
        if (hasAudio && element && allMediaStreamTracks.some((tr) => tr.kind === "video") && e2.name === "NotAllowedError") {
          element.muted = true;
          element.play().catch(() => {
          });
        }
      });
      this.emit(TrackEvent.ElementAttached, element);
      return element;
    }
    detach(element) {
      try {
        if (element) {
          detachTrack(this.mediaStreamTrack, element);
          const idx = this.attachedElements.indexOf(element);
          if (idx >= 0) {
            this.attachedElements.splice(idx, 1);
            this.recycleElement(element);
            this.emit(TrackEvent.ElementDetached, element);
          }
          return element;
        }
        const detached = [];
        this.attachedElements.forEach((elm) => {
          detachTrack(this.mediaStreamTrack, elm);
          detached.push(elm);
          this.recycleElement(elm);
          this.emit(TrackEvent.ElementDetached, elm);
        });
        this.attachedElements = [];
        return detached;
      } finally {
        if (this.attachedElements.length === 0) {
          this.removeAppVisibilityListener();
        }
      }
    }
    stop() {
      this.stopMonitor();
      this._mediaStreamTrack.stop();
    }
    enable() {
      this._mediaStreamTrack.enabled = true;
    }
    disable() {
      this._mediaStreamTrack.enabled = false;
    }
    /* @internal */
    stopMonitor() {
      if (this.monitorInterval) {
        clearInterval(this.monitorInterval);
      }
      if (this.timeSyncHandle) {
        cancelAnimationFrame(this.timeSyncHandle);
      }
    }
    /** @internal */
    updateLoggerOptions(loggerOptions) {
      if (loggerOptions.loggerName) {
        this.log = getLogger(loggerOptions.loggerName);
      }
      if (loggerOptions.loggerContextCb) {
        this.loggerContextCb = loggerOptions.loggerContextCb;
      }
    }
    recycleElement(element) {
      if (element instanceof HTMLAudioElement) {
        let shouldCache = true;
        element.pause();
        recycledElements.forEach((e2) => {
          if (!e2.parentElement) {
            shouldCache = false;
          }
        });
        if (shouldCache) {
          recycledElements.push(element);
        }
      }
    }
    handleAppVisibilityChanged() {
      return __awaiter(this, void 0, void 0, function* () {
        this.isInBackground = document.visibilityState === "hidden";
        if (!this.isInBackground && this.kind === Track.Kind.Video) {
          setTimeout(() => this.attachedElements.forEach((el) => el.play().catch(() => {
          })), 0);
        }
      });
    }
    addAppVisibilityListener() {
      if (isWeb()) {
        this.isInBackground = document.visibilityState === "hidden";
        document.addEventListener("visibilitychange", this.appVisibilityChangedListener);
      } else {
        this.isInBackground = false;
      }
    }
    removeAppVisibilityListener() {
      if (isWeb()) {
        document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
      }
    }
  }
  function attachToElement(track, element) {
    let mediaStream;
    if (element.srcObject instanceof MediaStream) {
      mediaStream = element.srcObject;
    } else {
      mediaStream = new MediaStream();
    }
    let existingTracks;
    if (track.kind === "audio") {
      existingTracks = mediaStream.getAudioTracks();
    } else {
      existingTracks = mediaStream.getVideoTracks();
    }
    if (!existingTracks.includes(track)) {
      existingTracks.forEach((et2) => {
        mediaStream.removeTrack(et2);
      });
      mediaStream.addTrack(track);
    }
    if (!isSafari() || !(element instanceof HTMLVideoElement)) {
      element.autoplay = true;
    }
    element.muted = mediaStream.getAudioTracks().length === 0;
    if (element instanceof HTMLVideoElement) {
      element.playsInline = true;
    }
    if (element.srcObject !== mediaStream) {
      element.srcObject = mediaStream;
      if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {
        setTimeout(() => {
          element.srcObject = mediaStream;
          element.play().catch(() => {
          });
        }, 0);
      }
    }
  }
  function detachTrack(track, element) {
    if (element.srcObject instanceof MediaStream) {
      const mediaStream = element.srcObject;
      mediaStream.removeTrack(track);
      if (mediaStream.getTracks().length > 0) {
        element.srcObject = mediaStream;
      } else {
        element.srcObject = null;
      }
    }
  }
  (function(Track2) {
    let Kind;
    (function(Kind2) {
      Kind2["Audio"] = "audio";
      Kind2["Video"] = "video";
      Kind2["Unknown"] = "unknown";
    })(Kind = Track2.Kind || (Track2.Kind = {}));
    let Source;
    (function(Source2) {
      Source2["Camera"] = "camera";
      Source2["Microphone"] = "microphone";
      Source2["ScreenShare"] = "screen_share";
      Source2["ScreenShareAudio"] = "screen_share_audio";
      Source2["Unknown"] = "unknown";
    })(Source = Track2.Source || (Track2.Source = {}));
    let StreamState$1;
    (function(StreamState2) {
      StreamState2["Active"] = "active";
      StreamState2["Paused"] = "paused";
      StreamState2["Unknown"] = "unknown";
    })(StreamState$1 = Track2.StreamState || (Track2.StreamState = {}));
    function kindToProto(k) {
      switch (k) {
        case Kind.Audio:
          return TrackType.AUDIO;
        case Kind.Video:
          return TrackType.VIDEO;
        default:
          return TrackType.DATA;
      }
    }
    Track2.kindToProto = kindToProto;
    function kindFromProto(t2) {
      switch (t2) {
        case TrackType.AUDIO:
          return Kind.Audio;
        case TrackType.VIDEO:
          return Kind.Video;
        default:
          return Kind.Unknown;
      }
    }
    Track2.kindFromProto = kindFromProto;
    function sourceToProto(s2) {
      switch (s2) {
        case Source.Camera:
          return TrackSource.CAMERA;
        case Source.Microphone:
          return TrackSource.MICROPHONE;
        case Source.ScreenShare:
          return TrackSource.SCREEN_SHARE;
        case Source.ScreenShareAudio:
          return TrackSource.SCREEN_SHARE_AUDIO;
        default:
          return TrackSource.UNKNOWN;
      }
    }
    Track2.sourceToProto = sourceToProto;
    function sourceFromProto(s2) {
      switch (s2) {
        case TrackSource.CAMERA:
          return Source.Camera;
        case TrackSource.MICROPHONE:
          return Source.Microphone;
        case TrackSource.SCREEN_SHARE:
          return Source.ScreenShare;
        case TrackSource.SCREEN_SHARE_AUDIO:
          return Source.ScreenShareAudio;
        default:
          return Source.Unknown;
      }
    }
    Track2.sourceFromProto = sourceFromProto;
    function streamStateFromProto(s2) {
      switch (s2) {
        case StreamState.ACTIVE:
          return StreamState$1.Active;
        case StreamState.PAUSED:
          return StreamState$1.Paused;
        default:
          return StreamState$1.Unknown;
      }
    }
    Track2.streamStateFromProto = streamStateFromProto;
  })(Track);
  class VideoPreset {
    constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {
      if (typeof widthOrOptions === "object") {
        this.width = widthOrOptions.width;
        this.height = widthOrOptions.height;
        this.aspectRatio = widthOrOptions.aspectRatio;
        this.encoding = {
          maxBitrate: widthOrOptions.maxBitrate,
          maxFramerate: widthOrOptions.maxFramerate,
          priority: widthOrOptions.priority
        };
      } else if (height !== void 0 && maxBitrate !== void 0) {
        this.width = widthOrOptions;
        this.height = height;
        this.aspectRatio = widthOrOptions / height;
        this.encoding = {
          maxBitrate,
          maxFramerate,
          priority
        };
      } else {
        throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
      }
    }
    get resolution() {
      return {
        width: this.width,
        height: this.height,
        frameRate: this.encoding.maxFramerate,
        aspectRatio: this.aspectRatio
      };
    }
  }
  const backupCodecs = ["vp8", "h264"];
  const videoCodecs = ["vp8", "h264", "vp9", "av1"];
  function isBackupCodec(codec) {
    return !!backupCodecs.find((backup) => backup === codec);
  }
  var BackupCodecPolicy;
  (function(BackupCodecPolicy2) {
    BackupCodecPolicy2[BackupCodecPolicy2["REGRESSION"] = 0] = "REGRESSION";
    BackupCodecPolicy2[BackupCodecPolicy2["SIMULCAST"] = 1] = "SIMULCAST";
  })(BackupCodecPolicy || (BackupCodecPolicy = {}));
  var AudioPresets;
  (function(AudioPresets2) {
    AudioPresets2.telephone = {
      maxBitrate: 12e3
    };
    AudioPresets2.speech = {
      maxBitrate: 24e3
    };
    AudioPresets2.music = {
      maxBitrate: 48e3
    };
    AudioPresets2.musicStereo = {
      maxBitrate: 64e3
    };
    AudioPresets2.musicHighQuality = {
      maxBitrate: 96e3
    };
    AudioPresets2.musicHighQualityStereo = {
      maxBitrate: 128e3
    };
  })(AudioPresets || (AudioPresets = {}));
  const VideoPresets = {
    h90: new VideoPreset(160, 90, 9e4, 20),
    h180: new VideoPreset(320, 180, 16e4, 20),
    h216: new VideoPreset(384, 216, 18e4, 20),
    h360: new VideoPreset(640, 360, 45e4, 20),
    h540: new VideoPreset(960, 540, 8e5, 25),
    h720: new VideoPreset(1280, 720, 17e5, 30),
    h1080: new VideoPreset(1920, 1080, 3e6, 30),
    h1440: new VideoPreset(2560, 1440, 5e6, 30),
    h2160: new VideoPreset(3840, 2160, 8e6, 30)
  };
  const VideoPresets43 = {
    h120: new VideoPreset(160, 120, 7e4, 20),
    h180: new VideoPreset(240, 180, 125e3, 20),
    h240: new VideoPreset(320, 240, 14e4, 20),
    h360: new VideoPreset(480, 360, 33e4, 20),
    h480: new VideoPreset(640, 480, 5e5, 20),
    h540: new VideoPreset(720, 540, 6e5, 25),
    h720: new VideoPreset(960, 720, 13e5, 30),
    h1080: new VideoPreset(1440, 1080, 23e5, 30),
    h1440: new VideoPreset(1920, 1440, 38e5, 30)
  };
  const ScreenSharePresets = {
    h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
    h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
    h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
    h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
    h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
    h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
    h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
    // original resolution, without resizing
    original: new VideoPreset(0, 0, 7e6, 30, "medium")
  };
  const separator = "|";
  const ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
  function unpackStreamId(packed) {
    const parts = packed.split(separator);
    if (parts.length > 1) {
      return [parts[0], packed.substr(parts[0].length + 1)];
    }
    return [packed, ""];
  }
  function sleep(duration) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve) => CriticalTimers.setTimeout(resolve, duration));
    });
  }
  function supportsTransceiver() {
    return "addTransceiver" in RTCPeerConnection.prototype;
  }
  function supportsAddTrack() {
    return "addTrack" in RTCPeerConnection.prototype;
  }
  function supportsAV1() {
    if (!("getCapabilities" in RTCRtpSender)) {
      return false;
    }
    if (isSafari()) {
      return false;
    }
    const capabilities = RTCRtpSender.getCapabilities("video");
    let hasAV1 = false;
    if (capabilities) {
      for (const codec of capabilities.codecs) {
        if (codec.mimeType === "video/AV1") {
          hasAV1 = true;
          break;
        }
      }
    }
    return hasAV1;
  }
  function supportsVP9() {
    if (!("getCapabilities" in RTCRtpSender)) {
      return false;
    }
    if (isFireFox()) {
      return false;
    }
    if (isSafari()) {
      const browser = getBrowser();
      if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, "16") < 0) {
        return false;
      }
    }
    const capabilities = RTCRtpSender.getCapabilities("video");
    let hasVP9 = false;
    if (capabilities) {
      for (const codec of capabilities.codecs) {
        if (codec.mimeType === "video/VP9") {
          hasVP9 = true;
          break;
        }
      }
    }
    return hasVP9;
  }
  function isSVCCodec(codec) {
    return codec === "av1" || codec === "vp9";
  }
  function supportsSetSinkId(elm) {
    if (!document) {
      return false;
    }
    if (!elm) {
      elm = document.createElement("audio");
    }
    return "setSinkId" in elm;
  }
  function isBrowserSupported() {
    if (typeof RTCPeerConnection === "undefined") {
      return false;
    }
    return supportsTransceiver() || supportsAddTrack();
  }
  function isFireFox() {
    var _a;
    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Firefox";
  }
  function isSafari() {
    var _a;
    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Safari";
  }
  function isSafari17() {
    const b2 = getBrowser();
    return (b2 === null || b2 === void 0 ? void 0 : b2.name) === "Safari" && b2.version.startsWith("17.");
  }
  function isMobile() {
    var _a, _b;
    if (!isWeb())
      return false;
    return (
      // @ts-expect-error `userAgentData` is not yet part of typescript
      (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
    );
  }
  function isE2EESimulcastSupported() {
    const browser = getBrowser();
    const supportedSafariVersion = "17.2";
    if (browser) {
      if (browser.name !== "Safari" && browser.os !== "iOS") {
        return true;
      } else if (browser.os === "iOS" && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {
        return true;
      } else if (browser.name === "Safari" && compareVersions(supportedSafariVersion, browser.version) >= 0) {
        return true;
      } else {
        return false;
      }
    }
  }
  function isWeb() {
    return typeof document !== "undefined";
  }
  function isReactNative() {
    return navigator.product == "ReactNative";
  }
  function isCloud(serverUrl) {
    return serverUrl.hostname.endsWith(".livekit.cloud") || serverUrl.hostname.endsWith(".livekit.run");
  }
  function getLKReactNativeInfo() {
    if (global && global.LiveKitReactNativeGlobal) {
      return global.LiveKitReactNativeGlobal;
    }
    return void 0;
  }
  function getReactNativeOs() {
    if (!isReactNative()) {
      return void 0;
    }
    let info = getLKReactNativeInfo();
    if (info) {
      return info.platform;
    }
    return void 0;
  }
  function getDevicePixelRatio() {
    if (isWeb()) {
      return window.devicePixelRatio;
    }
    if (isReactNative()) {
      let info = getLKReactNativeInfo();
      if (info) {
        return info.devicePixelRatio;
      }
    }
    return 1;
  }
  function compareVersions(v1, v2) {
    const parts1 = v1.split(".");
    const parts2 = v2.split(".");
    const k = Math.min(parts1.length, parts2.length);
    for (let i2 = 0; i2 < k; ++i2) {
      const p1 = parseInt(parts1[i2], 10);
      const p2 = parseInt(parts2[i2], 10);
      if (p1 > p2)
        return 1;
      if (p1 < p2)
        return -1;
      if (i2 === k - 1 && p1 === p2)
        return 0;
    }
    if (v1 === "" && v2 !== "") {
      return -1;
    } else if (v2 === "") {
      return 1;
    }
    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;
  }
  function roDispatchCallback(entries) {
    for (const entry of entries) {
      entry.target.handleResize(entry);
    }
  }
  function ioDispatchCallback(entries) {
    for (const entry of entries) {
      entry.target.handleVisibilityChanged(entry);
    }
  }
  let resizeObserver = null;
  const getResizeObserver = () => {
    if (!resizeObserver)
      resizeObserver = new ResizeObserver(roDispatchCallback);
    return resizeObserver;
  };
  let intersectionObserver = null;
  const getIntersectionObserver = () => {
    if (!intersectionObserver) {
      intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
        root: null,
        rootMargin: "0px"
      });
    }
    return intersectionObserver;
  };
  function getClientInfo() {
    var _a;
    const info = new ClientInfo({
      sdk: ClientInfo_SDK.JS,
      protocol: protocolVersion,
      version
    });
    if (isReactNative()) {
      info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : "";
    }
    return info;
  }
  function createDummyVideoStreamTrack() {
    let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
    let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;
    let enabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let paintContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (paintContent && ctx) {
      ctx.beginPath();
      ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fillStyle = "grey";
      ctx.fill();
    }
    const dummyStream = canvas.captureStream();
    const [dummyTrack] = dummyStream.getTracks();
    if (!dummyTrack) {
      throw Error("Could not get empty media stream video track");
    }
    dummyTrack.enabled = enabled;
    return dummyTrack;
  }
  let emptyAudioStreamTrack;
  function getEmptyAudioStreamTrack() {
    if (!emptyAudioStreamTrack) {
      const ctx = new AudioContext();
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, 0);
      const dst = ctx.createMediaStreamDestination();
      oscillator.connect(gain);
      gain.connect(dst);
      oscillator.start();
      [emptyAudioStreamTrack] = dst.stream.getAudioTracks();
      if (!emptyAudioStreamTrack) {
        throw Error("Could not get empty media stream audio track");
      }
      emptyAudioStreamTrack.enabled = false;
    }
    return emptyAudioStreamTrack.clone();
  }
  class Future {
    constructor(futureBase, onFinally) {
      this.onFinally = onFinally;
      this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        this.resolve = resolve;
        this.reject = reject;
        if (futureBase) {
          yield futureBase(resolve, reject);
        }
      })).finally(() => {
        var _a;
        return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
  }
  function isVideoCodec(maybeCodec) {
    return videoCodecs.includes(maybeCodec);
  }
  function unwrapConstraint(constraint) {
    if (typeof constraint === "string" || typeof constraint === "number") {
      return constraint;
    }
    if (Array.isArray(constraint)) {
      return constraint[0];
    }
    if (constraint.exact) {
      if (Array.isArray(constraint.exact)) {
        return constraint.exact[0];
      }
      return constraint.exact;
    }
    if (constraint.ideal) {
      if (Array.isArray(constraint.ideal)) {
        return constraint.ideal[0];
      }
      return constraint.ideal;
    }
    throw Error("could not unwrap constraint");
  }
  function toWebsocketUrl(url) {
    if (url.startsWith("http")) {
      return url.replace(/^(http)/, "ws");
    }
    return url;
  }
  function toHttpUrl(url) {
    if (url.startsWith("ws")) {
      return url.replace(/^(ws)/, "http");
    }
    return url;
  }
  function extractTranscriptionSegments(transcription, firstReceivedTimesMap) {
    return transcription.segments.map((_ref) => {
      let {
        id,
        text,
        language,
        startTime,
        endTime,
        final
      } = _ref;
      var _a;
      const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();
      const lastReceivedTime = Date.now();
      if (final) {
        firstReceivedTimesMap.delete(id);
      } else {
        firstReceivedTimesMap.set(id, firstReceivedTime);
      }
      return {
        id,
        text,
        startTime: Number.parseInt(startTime.toString()),
        endTime: Number.parseInt(endTime.toString()),
        final,
        language,
        firstReceivedTime,
        lastReceivedTime
      };
    });
  }
  function extractChatMessage(msg) {
    const {
      id,
      timestamp,
      message,
      editTimestamp
    } = msg;
    return {
      id,
      timestamp: Number.parseInt(timestamp.toString()),
      editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : void 0,
      message
    };
  }
  function getDisconnectReasonFromConnectionError(e2) {
    switch (e2.reason) {
      case ConnectionErrorReason.LeaveRequest:
        return e2.context;
      case ConnectionErrorReason.Cancelled:
        return DisconnectReason.CLIENT_INITIATED;
      case ConnectionErrorReason.NotAllowed:
        return DisconnectReason.USER_REJECTED;
      case ConnectionErrorReason.ServerUnreachable:
        return DisconnectReason.JOIN_FAILURE;
      default:
        return DisconnectReason.UNKNOWN_REASON;
    }
  }
  function bigIntToNumber(value) {
    return value !== void 0 ? Number(value) : void 0;
  }
  function numberToBigInt(value) {
    return value !== void 0 ? BigInt(value) : void 0;
  }
  function isLocalTrack(track) {
    return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;
  }
  function isAudioTrack(track) {
    return !!track && track.kind == Track.Kind.Audio;
  }
  function isVideoTrack(track) {
    return !!track && track.kind == Track.Kind.Video;
  }
  function isLocalVideoTrack(track) {
    return isLocalTrack(track) && isVideoTrack(track);
  }
  function isLocalAudioTrack(track) {
    return isLocalTrack(track) && isAudioTrack(track);
  }
  function isRemoteTrack(track) {
    return !!track && !track.isLocal;
  }
  function isRemotePub(pub) {
    return !!pub && !pub.isLocal;
  }
  function isRemoteVideoTrack(track) {
    return isRemoteTrack(track) && isVideoTrack(track);
  }
  function isLocalParticipant(p2) {
    return p2.isLocal;
  }
  function mergeDefaultOptions(options, audioDefaults2, videoDefaults2) {
    var _a, _b, _c;
    var _d, _e2;
    const {
      optionsWithoutProcessor,
      audioProcessor,
      videoProcessor
    } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});
    const clonedOptions = (_a = cloneDeep(optionsWithoutProcessor)) !== null && _a !== void 0 ? _a : {};
    if (clonedOptions.audio === true)
      clonedOptions.audio = {};
    if (clonedOptions.video === true)
      clonedOptions.video = {};
    if (clonedOptions.audio) {
      mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults2);
      (_b = (_d = clonedOptions.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = "default";
      if (audioProcessor) {
        clonedOptions.audio.processor = audioProcessor;
      }
    }
    if (clonedOptions.video) {
      mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults2);
      (_c = (_e2 = clonedOptions.video).deviceId) !== null && _c !== void 0 ? _c : _e2.deviceId = "default";
      if (videoProcessor) {
        clonedOptions.video.processor = videoProcessor;
      }
    }
    return clonedOptions;
  }
  function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
    Object.keys(objectToMerge).forEach((key) => {
      if (mainObject[key] === void 0)
        mainObject[key] = objectToMerge[key];
    });
    return mainObject;
  }
  function constraintsForOptions(options) {
    var _a, _b;
    var _c, _d;
    const constraints = {};
    if (options.video) {
      if (typeof options.video === "object") {
        const videoOptions = {};
        const target = videoOptions;
        const source = options.video;
        Object.keys(source).forEach((key) => {
          switch (key) {
            case "resolution":
              mergeObjectWithoutOverwriting(target, source.resolution);
              break;
            default:
              target[key] = source[key];
          }
        });
        constraints.video = videoOptions;
        (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = "default";
      } else {
        constraints.video = options.video ? {
          deviceId: "default"
        } : false;
      }
    } else {
      constraints.video = false;
    }
    if (options.audio) {
      if (typeof options.audio === "object") {
        constraints.audio = options.audio;
        (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = "default";
      } else {
        constraints.audio = {
          deviceId: "default"
        };
      }
    } else {
      constraints.audio = false;
    }
    return constraints;
  }
  function detectSilence(track_1) {
    return __awaiter(this, arguments, void 0, function(track) {
      let timeOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
      return function* () {
        const ctx = getNewAudioContext();
        if (ctx) {
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 2048;
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));
          source.connect(analyser);
          yield sleep(timeOffset);
          analyser.getByteTimeDomainData(dataArray);
          const someNoise = dataArray.some((sample) => sample !== 128 && sample !== 0);
          ctx.close();
          return !someNoise;
        }
        return false;
      }();
    });
  }
  function getNewAudioContext() {
    const AudioContext2 = (
      // @ts-ignore
      typeof window !== "undefined" && (window.AudioContext || window.webkitAudioContext)
    );
    if (AudioContext2) {
      return new AudioContext2({
        latencyHint: "interactive"
      });
    }
  }
  function sourceToKind(source) {
    if (source === Track.Source.Microphone) {
      return "audioinput";
    } else if (source === Track.Source.Camera) {
      return "videoinput";
    } else {
      return void 0;
    }
  }
  function screenCaptureToDisplayMediaStreamOptions(options) {
    var _a, _b;
    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;
    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {
      videoConstraints = typeof videoConstraints === "boolean" ? {} : videoConstraints;
      if (isSafari()) {
        videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
          width: {
            max: options.resolution.width
          },
          height: {
            max: options.resolution.height
          },
          frameRate: options.resolution.frameRate
        });
      } else {
        videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
          width: {
            ideal: options.resolution.width
          },
          height: {
            ideal: options.resolution.height
          },
          frameRate: options.resolution.frameRate
        });
      }
    }
    return {
      audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,
      video: videoConstraints,
      // @ts-expect-error support for experimental display media features
      controller: options.controller,
      selfBrowserSurface: options.selfBrowserSurface,
      surfaceSwitching: options.surfaceSwitching,
      systemAudio: options.systemAudio,
      preferCurrentTab: options.preferCurrentTab
    };
  }
  function mimeTypeToVideoCodecString(mimeType) {
    return mimeType.split("/")[1].toLowerCase();
  }
  function getTrackPublicationInfo(tracks) {
    const infos = [];
    tracks.forEach((track) => {
      if (track.track !== void 0) {
        infos.push(new TrackPublishedResponse({
          cid: track.track.mediaStreamID,
          track: track.trackInfo
        }));
      }
    });
    return infos;
  }
  function getLogContextFromTrack(track) {
    if ("mediaStreamTrack" in track) {
      return {
        trackID: track.sid,
        source: track.source,
        muted: track.isMuted,
        enabled: track.mediaStreamTrack.enabled,
        kind: track.kind,
        streamID: track.mediaStreamID,
        streamTrackID: track.mediaStreamTrack.id
      };
    } else {
      return {
        trackID: track.trackSid,
        enabled: track.isEnabled,
        muted: track.isMuted,
        trackInfo: Object.assign({
          mimeType: track.mimeType,
          name: track.trackName,
          encrypted: track.isEncrypted,
          kind: track.kind,
          source: track.source
        }, track.track ? getLogContextFromTrack(track.track) : {})
      };
    }
  }
  function supportsSynchronizationSources() {
    return typeof RTCRtpReceiver !== "undefined" && "getSynchronizationSources" in RTCRtpReceiver;
  }
  function diffAttributes(oldValues, newValues) {
    var _a;
    if (oldValues === void 0) {
      oldValues = {};
    }
    if (newValues === void 0) {
      newValues = {};
    }
    const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];
    const diff = {};
    for (const key of allKeys) {
      if (oldValues[key] !== newValues[key]) {
        diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : "";
      }
    }
    return diff;
  }
  function extractProcessorsFromOptions(options) {
    const newOptions = Object.assign({}, options);
    let audioProcessor;
    let videoProcessor;
    if (typeof newOptions.audio === "object" && newOptions.audio.processor) {
      audioProcessor = newOptions.audio.processor;
      newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {
        processor: void 0
      });
    }
    if (typeof newOptions.video === "object" && newOptions.video.processor) {
      videoProcessor = newOptions.video.processor;
      newOptions.video = Object.assign(Object.assign({}, newOptions.video), {
        processor: void 0
      });
    }
    return {
      audioProcessor,
      videoProcessor,
      optionsWithoutProcessor: newOptions
    };
  }
  class E2EEManager extends eventsExports.EventEmitter {
    constructor(options) {
      super();
      this.onWorkerMessage = (ev) => {
        var _a, _b;
        const {
          kind,
          data
        } = ev.data;
        switch (kind) {
          case "error":
            livekitLogger.error(data.error.message);
            this.emit(EncryptionEvent.EncryptionError, data.error);
            break;
          case "initAck":
            if (data.enabled) {
              this.keyProvider.getKeys().forEach((keyInfo) => {
                this.postKey(keyInfo);
              });
            }
            break;
          case "enable":
            if (data.enabled) {
              this.keyProvider.getKeys().forEach((keyInfo) => {
                this.postKey(keyInfo);
              });
            }
            if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
              this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);
              this.encryptionEnabled = data.enabled;
            } else if (data.participantIdentity) {
              const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);
              if (!participant) {
                throw TypeError("couldn't set encryption status, participant not found".concat(data.participantIdentity));
              }
              this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);
            }
            break;
          case "ratchetKey":
            this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);
            break;
        }
      };
      this.onWorkerError = (ev) => {
        livekitLogger.error("e2ee worker encountered an error:", {
          error: ev.error
        });
        this.emit(EncryptionEvent.EncryptionError, ev.error);
      };
      this.keyProvider = options.keyProvider;
      this.worker = options.worker;
      this.encryptionEnabled = false;
    }
    /**
     * @internal
     */
    setup(room) {
      if (!isE2EESupported()) {
        throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
      }
      livekitLogger.info("setting up e2ee");
      if (room !== this.room) {
        this.room = room;
        this.setupEventListeners(room, this.keyProvider);
        const msg = {
          kind: "init",
          data: {
            keyProviderOptions: this.keyProvider.getOptions(),
            loglevel: workerLogger.getLevel()
          }
        };
        if (this.worker) {
          livekitLogger.info("initializing worker", {
            worker: this.worker
          });
          this.worker.onmessage = this.onWorkerMessage;
          this.worker.onerror = this.onWorkerError;
          this.worker.postMessage(msg);
        }
      }
    }
    /**
     * @internal
     */
    setParticipantCryptorEnabled(enabled, participantIdentity) {
      livekitLogger.debug("set e2ee to ".concat(enabled, " for participant ").concat(participantIdentity));
      this.postEnable(enabled, participantIdentity);
    }
    /**
     * @internal
     */
    setSifTrailer(trailer) {
      if (!trailer || trailer.length === 0) {
        livekitLogger.warn("ignoring server sent trailer as it's empty");
      } else {
        this.postSifTrailer(trailer);
      }
    }
    setupEngine(engine) {
      engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap) => {
        this.postRTPMap(rtpMap);
      });
    }
    setupEventListeners(room, keyProvider) {
      room.on(RoomEvent.TrackPublished, (pub, participant) => this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));
      room.on(RoomEvent.ConnectionStateChanged, (state) => {
        if (state === ConnectionState.Connected) {
          room.remoteParticipants.forEach((participant) => {
            participant.trackPublications.forEach((pub) => {
              this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);
            });
          });
        }
      }).on(RoomEvent.TrackUnsubscribed, (track, _2, participant) => {
        var _a;
        const msg = {
          kind: "removeTransform",
          data: {
            participantIdentity: participant.identity,
            trackId: track.mediaStreamID
          }
        };
        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);
      }).on(RoomEvent.TrackSubscribed, (track, pub, participant) => {
        this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);
      }).on(RoomEvent.SignalConnected, () => {
        if (!this.room) {
          throw new TypeError("expected room to be present on signal connect");
        }
        keyProvider.getKeys().forEach((keyInfo) => {
          this.postKey(keyInfo);
        });
        this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);
      });
      room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication) => __awaiter(this, void 0, void 0, function* () {
        this.setupE2EESender(publication.track, publication.track.sender);
      }));
      keyProvider.on(KeyProviderEvent.SetKey, (keyInfo) => this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) => this.postRatchetRequest(participantId, keyIndex));
    }
    postRatchetRequest(participantIdentity, keyIndex) {
      if (!this.worker) {
        throw Error("could not ratchet key, worker is missing");
      }
      const msg = {
        kind: "ratchetRequest",
        data: {
          participantIdentity,
          keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
    postKey(_ref) {
      let {
        key,
        participantIdentity,
        keyIndex
      } = _ref;
      var _a;
      if (!this.worker) {
        throw Error("could not set key, worker is missing");
      }
      const msg = {
        kind: "setKey",
        data: {
          participantIdentity,
          isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),
          key,
          keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
    postEnable(enabled, participantIdentity) {
      if (this.worker) {
        const enableMsg = {
          kind: "enable",
          data: {
            enabled,
            participantIdentity
          }
        };
        this.worker.postMessage(enableMsg);
      } else {
        throw new ReferenceError("failed to enable e2ee, worker is not ready");
      }
    }
    postRTPMap(map2) {
      var _a;
      if (!this.worker) {
        throw TypeError("could not post rtp map, worker is missing");
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
        throw TypeError("could not post rtp map, local participant identity is missing");
      }
      const msg = {
        kind: "setRTPMap",
        data: {
          map: map2,
          participantIdentity: this.room.localParticipant.identity
        }
      };
      this.worker.postMessage(msg);
    }
    postSifTrailer(trailer) {
      if (!this.worker) {
        throw Error("could not post SIF trailer, worker is missing");
      }
      const msg = {
        kind: "setSifTrailer",
        data: {
          trailer
        }
      };
      this.worker.postMessage(msg);
    }
    setupE2EEReceiver(track, remoteId, trackInfo) {
      if (!track.receiver) {
        return;
      }
      if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === "") {
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      }
      this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === "video" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : void 0);
    }
    setupE2EESender(track, sender) {
      if (!isLocalTrack(track) || !sender) {
        if (!sender)
          livekitLogger.warn("early return because sender is not ready");
        return;
      }
      this.handleSender(sender, track.mediaStreamID, void 0);
    }
    /**
     * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
     * a frame decoder.
     *
     */
    handleReceiver(receiver, trackId, participantIdentity, codec) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.worker) {
          return;
        }
        if (isScriptTransformSupported()) {
          const options = {
            kind: "decode",
            participantIdentity,
            trackId,
            codec
          };
          receiver.transform = new RTCRtpScriptTransform(this.worker, options);
        } else {
          if (E2EE_FLAG in receiver && codec) {
            const msg2 = {
              kind: "updateCodec",
              data: {
                trackId,
                codec,
                participantIdentity
              }
            };
            this.worker.postMessage(msg2);
            return;
          }
          let writable = receiver.writableStream;
          let readable = receiver.readableStream;
          if (!writable || !readable) {
            const receiverStreams = receiver.createEncodedStreams();
            receiver.writableStream = receiverStreams.writable;
            writable = receiverStreams.writable;
            receiver.readableStream = receiverStreams.readable;
            readable = receiverStreams.readable;
          }
          const msg = {
            kind: "decode",
            data: {
              readableStream: readable,
              writableStream: writable,
              trackId,
              codec,
              participantIdentity
            }
          };
          this.worker.postMessage(msg, [readable, writable]);
        }
        receiver[E2EE_FLAG] = true;
      });
    }
    /**
     * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
     * a frame encoder.
     *
     */
    handleSender(sender, trackId, codec) {
      var _a;
      if (E2EE_FLAG in sender || !this.worker) {
        return;
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === "") {
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      }
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const options = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId,
          codec
        };
        sender.transform = new RTCRtpScriptTransform(this.worker, options);
      } else {
        livekitLogger.info("initialize encoded streams");
        const senderStreams = sender.createEncodedStreams();
        const msg = {
          kind: "encode",
          data: {
            readableStream: senderStreams.readable,
            writableStream: senderStreams.writable,
            codec,
            trackId,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);
      }
      sender[E2EE_FLAG] = true;
    }
  }
  const defaultId = "default";
  class DeviceManager {
    constructor() {
      this._previousDevices = [];
    }
    static getInstance() {
      if (this.instance === void 0) {
        this.instance = new DeviceManager();
      }
      return this.instance;
    }
    get previousDevices() {
      return this._previousDevices;
    }
    getDevices(kind_1) {
      return __awaiter(this, arguments, void 0, function(kind) {
        var _this = this;
        let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a;
          if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {
            livekitLogger.debug("awaiting getUserMedia promise");
            try {
              if (kind) {
                yield DeviceManager.userMediaPromiseMap.get(kind);
              } else {
                yield Promise.all(DeviceManager.userMediaPromiseMap.values());
              }
            } catch (e2) {
              livekitLogger.warn("error waiting for media permissons");
            }
          }
          let devices = yield navigator.mediaDevices.enumerateDevices();
          if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
          !(isSafari() && _this.hasDeviceInUse(kind))) {
            const isDummyDeviceOrEmpty = devices.filter((d2) => d2.kind === kind).length === 0 || devices.some((device) => {
              const noLabel = device.label === "";
              const isRelevant = kind ? device.kind === kind : true;
              return noLabel && isRelevant;
            });
            if (isDummyDeviceOrEmpty) {
              const permissionsToAcquire = {
                video: kind !== "audioinput" && kind !== "audiooutput",
                audio: kind !== "videoinput" && {
                  deviceId: "default"
                }
              };
              const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);
              devices = yield navigator.mediaDevices.enumerateDevices();
              stream.getTracks().forEach((track) => {
                track.stop();
              });
            }
          }
          _this._previousDevices = devices;
          if (kind) {
            devices = devices.filter((device) => device.kind === kind);
          }
          return devices;
        }();
      });
    }
    normalizeDeviceId(kind, deviceId, groupId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (deviceId !== defaultId) {
          return deviceId;
        }
        const devices = yield this.getDevices(kind);
        const defaultDevice = devices.find((d2) => d2.deviceId === defaultId);
        if (!defaultDevice) {
          livekitLogger.warn("could not reliably determine default device");
          return void 0;
        }
        const device = devices.find((d2) => d2.deviceId !== defaultId && d2.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));
        if (!device) {
          livekitLogger.warn("could not reliably determine default device");
          return void 0;
        }
        return device === null || device === void 0 ? void 0 : device.deviceId;
      });
    }
    hasDeviceInUse(kind) {
      return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;
    }
  }
  DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
  DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
  var QueueTaskStatus;
  (function(QueueTaskStatus2) {
    QueueTaskStatus2[QueueTaskStatus2["WAITING"] = 0] = "WAITING";
    QueueTaskStatus2[QueueTaskStatus2["RUNNING"] = 1] = "RUNNING";
    QueueTaskStatus2[QueueTaskStatus2["COMPLETED"] = 2] = "COMPLETED";
  })(QueueTaskStatus || (QueueTaskStatus = {}));
  class AsyncQueue {
    constructor() {
      this.pendingTasks = /* @__PURE__ */ new Map();
      this.taskMutex = new _$1();
      this.nextTaskIndex = 0;
    }
    run(task) {
      return __awaiter(this, void 0, void 0, function* () {
        const taskInfo = {
          id: this.nextTaskIndex++,
          enqueuedAt: Date.now(),
          status: QueueTaskStatus.WAITING
        };
        this.pendingTasks.set(taskInfo.id, taskInfo);
        const unlock = yield this.taskMutex.lock();
        try {
          taskInfo.executedAt = Date.now();
          taskInfo.status = QueueTaskStatus.RUNNING;
          return yield task();
        } finally {
          taskInfo.status = QueueTaskStatus.COMPLETED;
          this.pendingTasks.delete(taskInfo.id);
          unlock();
        }
      });
    }
    flush() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.run(() => __awaiter(this, void 0, void 0, function* () {
        }));
      });
    }
    snapshot() {
      return Array.from(this.pendingTasks.values());
    }
  }
  const passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
  function canPassThroughQueue(req) {
    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;
    livekitLogger.trace("request allowed to bypass queue:", {
      canPass,
      req
    });
    return canPass;
  }
  var SignalConnectionState;
  (function(SignalConnectionState2) {
    SignalConnectionState2[SignalConnectionState2["CONNECTING"] = 0] = "CONNECTING";
    SignalConnectionState2[SignalConnectionState2["CONNECTED"] = 1] = "CONNECTED";
    SignalConnectionState2[SignalConnectionState2["RECONNECTING"] = 2] = "RECONNECTING";
    SignalConnectionState2[SignalConnectionState2["DISCONNECTING"] = 3] = "DISCONNECTING";
    SignalConnectionState2[SignalConnectionState2["DISCONNECTED"] = 4] = "DISCONNECTED";
  })(SignalConnectionState || (SignalConnectionState = {}));
  class SignalClient {
    get currentState() {
      return this.state;
    }
    get isDisconnected() {
      return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
    }
    get isEstablishingConnection() {
      return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
    }
    getNextRequestId() {
      this._requestId += 1;
      return this._requestId;
    }
    constructor() {
      let useJSON = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      let loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _a;
      this.rtt = 0;
      this.state = SignalConnectionState.DISCONNECTED;
      this.log = livekitLogger;
      this._requestId = 0;
      this.resetCallbacks = () => {
        this.onAnswer = void 0;
        this.onLeave = void 0;
        this.onLocalTrackPublished = void 0;
        this.onLocalTrackUnpublished = void 0;
        this.onNegotiateRequested = void 0;
        this.onOffer = void 0;
        this.onRemoteMuteChanged = void 0;
        this.onSubscribedQualityUpdate = void 0;
        this.onTokenRefresh = void 0;
        this.onTrickle = void 0;
        this.onClose = void 0;
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);
      this.loggerContextCb = loggerOptions.loggerContextCb;
      this.useJSON = useJSON;
      this.requestQueue = new AsyncQueue();
      this.queuedRequests = [];
      this.closingLock = new _$1();
      this.connectionLock = new _$1();
      this.state = SignalConnectionState.DISCONNECTED;
    }
    get logContext() {
      var _a, _b;
      return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};
    }
    join(url, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        this.state = SignalConnectionState.CONNECTING;
        this.options = opts;
        const res = yield this.connect(url, token, opts, abortSignal);
        return res;
      });
    }
    reconnect(url, token, sid, reason) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.options) {
          this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
          return;
        }
        this.state = SignalConnectionState.RECONNECTING;
        this.clearPingInterval();
        const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {
          reconnect: true,
          sid,
          reconnectReason: reason
        }));
        return res;
      });
    }
    connect(url, token, opts, abortSignal) {
      this.connectOptions = opts;
      url = toWebsocketUrl(url);
      url = url.replace(/\/$/, "");
      url += "/rtc";
      const clientInfo = getClientInfo();
      const params = createConnectionParams(token, clientInfo, opts);
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.connectionLock.lock();
        try {
          const abortHandler = () => __awaiter(this, void 0, void 0, function* () {
            this.close();
            clearTimeout(wsTimeout);
            reject(new ConnectionError("room connection has been cancelled (signal)", ConnectionErrorReason.Cancelled));
          });
          const wsTimeout = setTimeout(() => {
            this.close();
            reject(new ConnectionError("room connection has timed out (signal)", ConnectionErrorReason.ServerUnreachable));
          }, opts.websocketTimeout);
          if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
            abortHandler();
          }
          abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", abortHandler);
          this.log.debug("connecting to ".concat(url + params.replace(/access_token=([^&#$]*)/, "access_token=<redacted>")), this.logContext);
          if (this.ws) {
            yield this.close(false);
          }
          this.ws = new WebSocket(url + params);
          this.ws.binaryType = "arraybuffer";
          this.ws.onopen = () => {
            clearTimeout(wsTimeout);
          };
          this.ws.onerror = (ev) => __awaiter(this, void 0, void 0, function* () {
            if (this.state !== SignalConnectionState.CONNECTED) {
              this.state = SignalConnectionState.DISCONNECTED;
              clearTimeout(wsTimeout);
              try {
                const resp = yield fetch("http".concat(url.substring(2), "/validate").concat(params));
                if (resp.status.toFixed(0).startsWith("4")) {
                  const msg = yield resp.text();
                  reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));
                } else {
                  reject(new ConnectionError("Internal error", ConnectionErrorReason.InternalError, resp.status));
                }
              } catch (e2) {
                reject(new ConnectionError(e2 instanceof Error ? e2.message : "server was not reachable", ConnectionErrorReason.ServerUnreachable));
              }
              return;
            }
            this.handleWSError(ev);
          });
          this.ws.onmessage = (ev) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let resp;
            if (typeof ev.data === "string") {
              const json = JSON.parse(ev.data);
              resp = SignalResponse.fromJson(json, {
                ignoreUnknownFields: true
              });
            } else if (ev.data instanceof ArrayBuffer) {
              resp = SignalResponse.fromBinary(new Uint8Array(ev.data));
            } else {
              this.log.error("could not decode websocket message: ".concat(typeof ev.data), this.logContext);
              return;
            }
            if (this.state !== SignalConnectionState.CONNECTED) {
              let shouldProcessMessage = false;
              if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === "join") {
                this.state = SignalConnectionState.CONNECTED;
                abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
                this.pingTimeoutDuration = resp.message.value.pingTimeout;
                this.pingIntervalDuration = resp.message.value.pingInterval;
                if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {
                  this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
                    timeout: this.pingTimeoutDuration,
                    interval: this.pingIntervalDuration
                  }));
                  this.startPingInterval();
                }
                resolve(resp.message.value);
              } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== "leave") {
                this.state = SignalConnectionState.CONNECTED;
                abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
                this.startPingInterval();
                if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === "reconnect") {
                  resolve(resp.message.value);
                } else {
                  this.log.debug("declaring signal reconnected without reconnect response received", this.logContext);
                  resolve(void 0);
                  shouldProcessMessage = true;
                }
              } else if (this.isEstablishingConnection && resp.message.case === "leave") {
                reject(new ConnectionError("Received leave request while trying to (re)connect", ConnectionErrorReason.LeaveRequest, void 0, resp.message.value.reason));
              } else if (!opts.reconnect) {
                reject(new ConnectionError("did not receive join response, got ".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c.case, " instead"), ConnectionErrorReason.InternalError));
              }
              if (!shouldProcessMessage) {
                return;
              }
            }
            if (this.signalLatency) {
              yield sleep(this.signalLatency);
            }
            this.handleSignalResponse(resp);
          });
          this.ws.onclose = (ev) => {
            if (this.isEstablishingConnection) {
              reject(new ConnectionError("Websocket got closed during a (re)connection attempt", ConnectionErrorReason.InternalError));
            }
            this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
              reason: ev.reason,
              code: ev.code,
              wasClean: ev.wasClean,
              state: this.state
            }));
            this.handleOnClose(ev.reason);
          };
        } finally {
          unlock();
        }
      }));
    }
    close() {
      return __awaiter(this, arguments, void 0, function() {
        var _this = this;
        let updateState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          const unlock = yield _this.closingLock.lock();
          try {
            _this.clearPingInterval();
            if (updateState) {
              _this.state = SignalConnectionState.DISCONNECTING;
            }
            if (_this.ws) {
              _this.ws.onmessage = null;
              _this.ws.onopen = null;
              _this.ws.onclose = null;
              const closePromise = new Promise((resolve) => {
                if (_this.ws) {
                  _this.ws.onclose = () => {
                    resolve();
                  };
                } else {
                  resolve();
                }
              });
              if (_this.ws.readyState < _this.ws.CLOSING) {
                _this.ws.close();
                yield Promise.race([closePromise, sleep(250)]);
              }
              _this.ws = void 0;
            }
          } finally {
            if (updateState) {
              _this.state = SignalConnectionState.DISCONNECTED;
            }
            unlock();
          }
        }();
      });
    }
    // initial offer after joining
    sendOffer(offer) {
      this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
        offerSdp: offer.sdp
      }));
      this.sendRequest({
        case: "offer",
        value: toProtoSessionDescription(offer)
      });
    }
    // answer a server-initiated offer
    sendAnswer(answer) {
      this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
        answerSdp: answer.sdp
      }));
      return this.sendRequest({
        case: "answer",
        value: toProtoSessionDescription(answer)
      });
    }
    sendIceCandidate(candidate, target) {
      this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
        candidate
      }));
      return this.sendRequest({
        case: "trickle",
        value: new TrickleRequest({
          candidateInit: JSON.stringify(candidate),
          target
        })
      });
    }
    sendMuteTrack(trackSid, muted) {
      return this.sendRequest({
        case: "mute",
        value: new MuteTrackRequest({
          sid: trackSid,
          muted
        })
      });
    }
    sendAddTrack(req) {
      return this.sendRequest({
        case: "addTrack",
        value: req
      });
    }
    sendUpdateLocalMetadata(metadata_1, name_1) {
      return __awaiter(this, arguments, void 0, function(metadata, name) {
        var _this2 = this;
        let attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function* () {
          const requestId = _this2.getNextRequestId();
          yield _this2.sendRequest({
            case: "updateMetadata",
            value: new UpdateParticipantMetadata({
              requestId,
              metadata,
              name,
              attributes
            })
          });
          return requestId;
        }();
      });
    }
    sendUpdateTrackSettings(settings) {
      this.sendRequest({
        case: "trackSetting",
        value: settings
      });
    }
    sendUpdateSubscription(sub) {
      return this.sendRequest({
        case: "subscription",
        value: sub
      });
    }
    sendSyncState(sync) {
      return this.sendRequest({
        case: "syncState",
        value: sync
      });
    }
    sendUpdateVideoLayers(trackSid, layers) {
      return this.sendRequest({
        case: "updateLayers",
        value: new UpdateVideoLayers({
          trackSid,
          layers
        })
      });
    }
    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
      return this.sendRequest({
        case: "subscriptionPermission",
        value: new SubscriptionPermission({
          allParticipants,
          trackPermissions
        })
      });
    }
    sendSimulateScenario(scenario) {
      return this.sendRequest({
        case: "simulate",
        value: scenario
      });
    }
    sendPing() {
      return Promise.all([this.sendRequest({
        case: "ping",
        value: protoInt64.parse(Date.now())
      }), this.sendRequest({
        case: "pingReq",
        value: new Ping({
          timestamp: protoInt64.parse(Date.now()),
          rtt: protoInt64.parse(this.rtt)
        })
      })]);
    }
    sendUpdateLocalAudioTrack(trackSid, features) {
      return this.sendRequest({
        case: "updateAudioTrack",
        value: new UpdateLocalAudioTrack({
          trackSid,
          features
        })
      });
    }
    sendLeave() {
      return this.sendRequest({
        case: "leave",
        value: new LeaveRequest({
          reason: DisconnectReason.CLIENT_INITIATED,
          // server doesn't process this field, keeping it here to indicate the intent of a full disconnect
          action: LeaveRequest_Action.DISCONNECT
        })
      });
    }
    sendRequest(message_1) {
      return __awaiter(this, arguments, void 0, function(message) {
        var _this3 = this;
        let fromQueue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return function* () {
          const canQueue = !fromQueue && !canPassThroughQueue(message);
          if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {
            _this3.queuedRequests.push(() => __awaiter(_this3, void 0, void 0, function* () {
              yield this.sendRequest(message, true);
            }));
            return;
          }
          if (!fromQueue) {
            yield _this3.requestQueue.flush();
          }
          if (_this3.signalLatency) {
            yield sleep(_this3.signalLatency);
          }
          if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {
            _this3.log.error("cannot send signal request before connected, type: ".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);
            return;
          }
          const req = new SignalRequest({
            message
          });
          try {
            if (_this3.useJSON) {
              _this3.ws.send(req.toJsonString());
            } else {
              _this3.ws.send(req.toBinary());
            }
          } catch (e2) {
            _this3.log.error("error sending signal message", Object.assign(Object.assign({}, _this3.logContext), {
              error: e2
            }));
          }
        }();
      });
    }
    handleSignalResponse(res) {
      var _a, _b;
      const msg = res.message;
      if (msg == void 0) {
        this.log.debug("received unsupported message", this.logContext);
        return;
      }
      let pingHandled = false;
      if (msg.case === "answer") {
        const sd = fromProtoSessionDescription(msg.value);
        if (this.onAnswer) {
          this.onAnswer(sd);
        }
      } else if (msg.case === "offer") {
        const sd = fromProtoSessionDescription(msg.value);
        if (this.onOffer) {
          this.onOffer(sd);
        }
      } else if (msg.case === "trickle") {
        const candidate = JSON.parse(msg.value.candidateInit);
        if (this.onTrickle) {
          this.onTrickle(candidate, msg.value.target);
        }
      } else if (msg.case === "update") {
        if (this.onParticipantUpdate) {
          this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);
        }
      } else if (msg.case === "trackPublished") {
        if (this.onLocalTrackPublished) {
          this.onLocalTrackPublished(msg.value);
        }
      } else if (msg.case === "speakersChanged") {
        if (this.onSpeakersChanged) {
          this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);
        }
      } else if (msg.case === "leave") {
        if (this.onLeave) {
          this.onLeave(msg.value);
        }
      } else if (msg.case === "mute") {
        if (this.onRemoteMuteChanged) {
          this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);
        }
      } else if (msg.case === "roomUpdate") {
        if (this.onRoomUpdate && msg.value.room) {
          this.onRoomUpdate(msg.value.room);
        }
      } else if (msg.case === "connectionQuality") {
        if (this.onConnectionQuality) {
          this.onConnectionQuality(msg.value);
        }
      } else if (msg.case === "streamStateUpdate") {
        if (this.onStreamStateUpdate) {
          this.onStreamStateUpdate(msg.value);
        }
      } else if (msg.case === "subscribedQualityUpdate") {
        if (this.onSubscribedQualityUpdate) {
          this.onSubscribedQualityUpdate(msg.value);
        }
      } else if (msg.case === "subscriptionPermissionUpdate") {
        if (this.onSubscriptionPermissionUpdate) {
          this.onSubscriptionPermissionUpdate(msg.value);
        }
      } else if (msg.case === "refreshToken") {
        if (this.onTokenRefresh) {
          this.onTokenRefresh(msg.value);
        }
      } else if (msg.case === "trackUnpublished") {
        if (this.onLocalTrackUnpublished) {
          this.onLocalTrackUnpublished(msg.value);
        }
      } else if (msg.case === "subscriptionResponse") {
        if (this.onSubscriptionError) {
          this.onSubscriptionError(msg.value);
        }
      } else if (msg.case === "pong")
        ;
      else if (msg.case === "pongResp") {
        this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());
        this.resetPingTimeout();
        pingHandled = true;
      } else if (msg.case === "requestResponse") {
        if (this.onRequestResponse) {
          this.onRequestResponse(msg.value);
        }
      } else if (msg.case === "trackSubscribed") {
        if (this.onLocalTrackSubscribed) {
          this.onLocalTrackSubscribed(msg.value.trackSid);
        }
      } else {
        this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
          msgCase: msg.case
        }));
      }
      if (!pingHandled) {
        this.resetPingTimeout();
      }
    }
    setReconnected() {
      while (this.queuedRequests.length > 0) {
        const req = this.queuedRequests.shift();
        if (req) {
          this.requestQueue.run(req);
        }
      }
    }
    handleOnClose(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state === SignalConnectionState.DISCONNECTED)
          return;
        const onCloseCallback = this.onClose;
        yield this.close();
        this.log.debug("websocket connection closed: ".concat(reason), Object.assign(Object.assign({}, this.logContext), {
          reason
        }));
        if (onCloseCallback) {
          onCloseCallback(reason);
        }
      });
    }
    handleWSError(ev) {
      this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
        error: ev
      }));
    }
    /**
     * Resets the ping timeout and starts a new timeout.
     * Call this after receiving a pong message
     */
    resetPingTimeout() {
      this.clearPingTimeout();
      if (!this.pingTimeoutDuration) {
        this.log.warn("ping timeout duration not set", this.logContext);
        return;
      }
      this.pingTimeout = CriticalTimers.setTimeout(() => {
        this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext);
        this.handleOnClose("ping timeout");
      }, this.pingTimeoutDuration * 1e3);
    }
    /**
     * Clears ping timeout (does not start a new timeout)
     */
    clearPingTimeout() {
      if (this.pingTimeout) {
        CriticalTimers.clearTimeout(this.pingTimeout);
      }
    }
    startPingInterval() {
      this.clearPingInterval();
      this.resetPingTimeout();
      if (!this.pingIntervalDuration) {
        this.log.warn("ping interval duration not set", this.logContext);
        return;
      }
      this.log.debug("start ping interval", this.logContext);
      this.pingInterval = CriticalTimers.setInterval(() => {
        this.sendPing();
      }, this.pingIntervalDuration * 1e3);
    }
    clearPingInterval() {
      this.log.debug("clearing ping interval", this.logContext);
      this.clearPingTimeout();
      if (this.pingInterval) {
        CriticalTimers.clearInterval(this.pingInterval);
      }
    }
  }
  function fromProtoSessionDescription(sd) {
    const rsd = {
      type: "offer",
      sdp: sd.sdp
    };
    switch (sd.type) {
      case "answer":
      case "offer":
      case "pranswer":
      case "rollback":
        rsd.type = sd.type;
        break;
    }
    return rsd;
  }
  function toProtoSessionDescription(rsd) {
    const sd = new SessionDescription({
      sdp: rsd.sdp,
      type: rsd.type
    });
    return sd;
  }
  function createConnectionParams(token, info, opts) {
    var _a;
    const params = new URLSearchParams();
    params.set("access_token", token);
    if (opts.reconnect) {
      params.set("reconnect", "1");
      if (opts.sid) {
        params.set("sid", opts.sid);
      }
    }
    params.set("auto_subscribe", opts.autoSubscribe ? "1" : "0");
    params.set("sdk", isReactNative() ? "reactnative" : "js");
    params.set("version", info.version);
    params.set("protocol", info.protocol.toString());
    if (info.deviceModel) {
      params.set("device_model", info.deviceModel);
    }
    if (info.os) {
      params.set("os", info.os);
    }
    if (info.osVersion) {
      params.set("os_version", info.osVersion);
    }
    if (info.browser) {
      params.set("browser", info.browser);
    }
    if (info.browserVersion) {
      params.set("browser_version", info.browserVersion);
    }
    if (opts.adaptiveStream) {
      params.set("adaptive_stream", "1");
    }
    if (opts.reconnectReason) {
      params.set("reconnect_reason", opts.reconnectReason.toString());
    }
    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {
      params.set("network", navigator.connection.type);
    }
    return "?".concat(params.toString());
  }
  var lib = {};
  var parser = {};
  var grammar = { exports: {} };
  var hasRequiredGrammar;
  function requireGrammar() {
    if (hasRequiredGrammar)
      return grammar.exports;
    hasRequiredGrammar = 1;
    var grammar$1 = grammar.exports = {
      v: [{
        name: "version",
        reg: /^(\d*)$/
      }],
      o: [{
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
        format: "%s %s %d %s IP%d %s"
      }],
      // default parsing of these only (though some of these feel outdated)
      s: [{
        name: "name"
      }],
      i: [{
        name: "description"
      }],
      u: [{
        name: "uri"
      }],
      e: [{
        name: "email"
      }],
      p: [{
        name: "phone"
      }],
      z: [{
        name: "timezones"
      }],
      // TODO: this one can actually be parsed properly...
      r: [{
        name: "repeats"
      }],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [{
        // t=0 0
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d"
      }],
      c: [{
        // c=IN IP4 10.47.197.26
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s"
      }],
      b: [{
        // b=AS:4000
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s"
      }],
      m: [{
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s"
      }],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function(o2) {
            return o2.encoding ? "rtpmap:%d %s/%s/%s" : o2.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
          }
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s"
        },
        {
          // a=control:streamid=0
          name: "control",
          reg: /^control:(.*)/,
          format: "control:%s"
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function(o2) {
            return o2.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          }
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d"
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function(o2) {
            return o2.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          }
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function(o2) {
            return "extmap:%d" + (o2.direction ? "/%s" : "%v") + (o2["encrypt-uri"] ? " %s" : "%v") + " %s" + (o2.config ? " %s" : "");
          }
        },
        {
          // a=extmap-allow-mixed
          name: "extmapAllowMixed",
          reg: /^(extmap-allow-mixed)/
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function(o2) {
            return o2.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
          }
        },
        {
          // a=setup:actpass
          name: "setup",
          reg: /^setup:(\w*)/,
          format: "setup:%s"
        },
        {
          // a=connection:new
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s"
        },
        {
          // a=mid:1
          name: "mid",
          reg: /^mid:([^\s]*)/,
          format: "mid:%s"
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          name: "msid",
          reg: /^msid:(.*)/,
          format: "msid:%s"
        },
        {
          // a=ptime:20
          name: "ptime",
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: "ptime:%d"
        },
        {
          // a=maxptime:60
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d"
        },
        {
          // a=sendrecv
          name: "direction",
          reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
          // a=ice-lite
          name: "icelite",
          reg: /^(ice-lite)/
        },
        {
          // a=ice-ufrag:F7gI
          name: "iceUfrag",
          reg: /^ice-ufrag:(\S*)/,
          format: "ice-ufrag:%s"
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: "icePwd",
          reg: /^ice-pwd:(\S*)/,
          format: "ice-pwd:%s"
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s"
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
          format: function(o2) {
            var str = "candidate:%s %d %s %d %s %d typ %s";
            str += o2.raddr != null ? " raddr %s rport %d" : "%v%v";
            str += o2.tcptype != null ? " tcptype %s" : "%v";
            if (o2.generation != null) {
              str += " generation %d";
            }
            str += o2["network-id"] != null ? " network-id %d" : "%v";
            str += o2["network-cost"] != null ? " network-cost %d" : "%v";
            return str;
          }
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: "endOfCandidates",
          reg: /^(end-of-candidates)/
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s"
        },
        {
          // a=ice-options:google-ice
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s"
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function(o2) {
            var str = "ssrc:%d";
            if (o2.attribute != null) {
              str += " %s";
              if (o2.value != null) {
                str += ":%s";
              }
            }
            return str;
          }
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: "ssrcGroups",
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s"
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s"
          // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s"
        },
        {
          // a=rtcp-mux
          name: "rtcpMux",
          reg: /^(rtcp-mux)/
        },
        {
          // a=rtcp-rsize
          name: "rtcpRsize",
          reg: /^(rtcp-rsize)/
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function(o2) {
            return o2.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
          }
        },
        {
          // a=x-google-flag:conference
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s"
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function(o2) {
            return o2.params ? "rid:%s %s %s" : "rid:%s %s";
          }
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: "imageattrs",
          reg: new RegExp(
            // a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function(o2) {
            return "imageattr:%s %s %s" + (o2.dir2 ? " %s %s" : "");
          }
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: "simulcast",
          reg: new RegExp(
            // a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function(o2) {
            return "simulcast:%s %s" + (o2.dir2 ? " %s %s" : "");
          }
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s"
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s"
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
          format: "source-filter: %s %s %s %s %s"
        },
        {
          // a=bundle-only
          name: "bundleOnly",
          reg: /^(bundle-only)/
        },
        {
          // a=label:1
          name: "label",
          reg: /^label:(.+)/,
          format: "label:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: "sctpPort",
          reg: /^sctp-port:(\d+)$/,
          format: "sctp-port:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s"
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function(o2) {
            return "ts-refclk:%s" + (o2.clksrcExt != null ? "=%s" : "");
          }
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
          format: function(o2) {
            var str = "mediaclk:";
            str += o2.id != null ? "id=%s %s" : "%v%s";
            str += o2.mediaClockValue != null ? "=%s" : "";
            str += o2.rateNumerator != null ? " rate=%s" : "";
            str += o2.rateDenominator != null ? "/%s" : "";
            return str;
          }
        },
        {
          // a=keywds:keywords
          name: "keywords",
          reg: /^keywds:(.+)$/,
          format: "keywds:%s"
        },
        {
          // a=content:main
          name: "content",
          reg: /^content:(.+)/,
          format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s"
        },
        {
          // a=confid:1
          name: "bfcpConfId",
          reg: /^confid:(\d+)/,
          format: "confid:%s"
        },
        {
          // a=userid:1
          name: "bfcpUserId",
          reg: /^userid:(\d+)/,
          format: "userid:%s"
        },
        {
          // a=floorid:1
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s"
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: "invalid",
          names: ["value"]
        }
      ]
    };
    Object.keys(grammar$1).forEach(function(key) {
      var objs = grammar$1[key];
      objs.forEach(function(obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = "%s";
        }
      });
    });
    return grammar.exports;
  }
  var hasRequiredParser;
  function requireParser() {
    if (hasRequiredParser)
      return parser;
    hasRequiredParser = 1;
    (function(exports) {
      var toIntIfInt = function(v2) {
        return String(Number(v2)) === v2 ? Number(v2) : v2;
      };
      var attachProperties = function(match, location2, names, rawName) {
        if (rawName && !names) {
          location2[rawName] = toIntIfInt(match[1]);
        } else {
          for (var i2 = 0; i2 < names.length; i2 += 1) {
            if (match[i2 + 1] != null) {
              location2[names[i2]] = toIntIfInt(match[i2 + 1]);
            }
          }
        }
      };
      var parseReg = function(obj, location2, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location2[obj.push]) {
          location2[obj.push] = [];
        } else if (needsBlank && !location2[obj.name]) {
          location2[obj.name] = {};
        }
        var keyLocation = obj.push ? {} : (
          // blank object that will be pushed
          needsBlank ? location2[obj.name] : location2
        );
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        if (obj.push) {
          location2[obj.push].push(keyLocation);
        }
      };
      var grammar2 = requireGrammar();
      var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
      exports.parse = function(sdp2) {
        var session = {}, media = [], location2 = session;
        sdp2.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l2) {
          var type = l2[0];
          var content = l2.slice(2);
          if (type === "m") {
            media.push({
              rtp: [],
              fmtp: []
            });
            location2 = media[media.length - 1];
          }
          for (var j2 = 0; j2 < (grammar2[type] || []).length; j2 += 1) {
            var obj = grammar2[type][j2];
            if (obj.reg.test(content)) {
              return parseReg(obj, location2, content);
            }
          }
        });
        session.media = media;
        return session;
      };
      var paramReducer = function(acc, expr) {
        var s2 = expr.split(/=(.+)/, 2);
        if (s2.length === 2) {
          acc[s2[0]] = toIntIfInt(s2[1]);
        } else if (s2.length === 1 && expr.length > 1) {
          acc[s2[0]] = void 0;
        }
        return acc;
      };
      exports.parseParams = function(str) {
        return str.split(/;\s?/).reduce(paramReducer, {});
      };
      exports.parseFmtpConfig = exports.parseParams;
      exports.parsePayloads = function(str) {
        return str.toString().split(" ").map(Number);
      };
      exports.parseRemoteCandidates = function(str) {
        var candidates = [];
        var parts = str.split(" ").map(toIntIfInt);
        for (var i2 = 0; i2 < parts.length; i2 += 3) {
          candidates.push({
            component: parts[i2],
            ip: parts[i2 + 1],
            port: parts[i2 + 2]
          });
        }
        return candidates;
      };
      exports.parseImageAttributes = function(str) {
        return str.split(" ").map(function(item) {
          return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
        });
      };
      exports.parseSimulcastStreamList = function(str) {
        return str.split(";").map(function(stream) {
          return stream.split(",").map(function(format) {
            var scid, paused = false;
            if (format[0] !== "~") {
              scid = toIntIfInt(format);
            } else {
              scid = toIntIfInt(format.substring(1, format.length));
              paused = true;
            }
            return {
              scid,
              paused
            };
          });
        });
      };
    })(parser);
    return parser;
  }
  var writer;
  var hasRequiredWriter;
  function requireWriter() {
    if (hasRequiredWriter)
      return writer;
    hasRequiredWriter = 1;
    var grammar2 = requireGrammar();
    var formatRegExp = /%[sdv%]/g;
    var format = function(formatStr) {
      var i2 = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function(x) {
        if (i2 >= len) {
          return x;
        }
        var arg = args[i2];
        i2 += 1;
        switch (x) {
          case "%%":
            return "%";
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg);
          case "%v":
            return "";
        }
      });
    };
    var makeLine = function(type, obj, location2) {
      var str = obj.format instanceof Function ? obj.format(obj.push ? location2 : location2[obj.name]) : obj.format;
      var args = [type + "=" + str];
      if (obj.names) {
        for (var i2 = 0; i2 < obj.names.length; i2 += 1) {
          var n2 = obj.names[i2];
          if (obj.name) {
            args.push(location2[obj.name][n2]);
          } else {
            args.push(location2[obj.names[i2]]);
          }
        }
      } else {
        args.push(location2[obj.name]);
      }
      return format.apply(null, args);
    };
    var defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"];
    var defaultInnerOrder = ["i", "c", "b", "a"];
    writer = function(session, opts) {
      opts = opts || {};
      if (session.version == null) {
        session.version = 0;
      }
      if (session.name == null) {
        session.name = " ";
      }
      session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = "";
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp2 = [];
      outerOrder.forEach(function(type) {
        grammar2[type].forEach(function(obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp2.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function(el) {
              sdp2.push(makeLine(type, obj, el));
            });
          }
        });
      });
      session.media.forEach(function(mLine) {
        sdp2.push(makeLine("m", grammar2.m[0], mLine));
        innerOrder.forEach(function(type) {
          grammar2[type].forEach(function(obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp2.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function(el) {
                sdp2.push(makeLine(type, obj, el));
              });
            }
          });
        });
      });
      return sdp2.join("\r\n") + "\r\n";
    };
    return writer;
  }
  var hasRequiredLib;
  function requireLib() {
    if (hasRequiredLib)
      return lib;
    hasRequiredLib = 1;
    var parser2 = requireParser();
    var writer2 = requireWriter();
    var grammar2 = requireGrammar();
    lib.grammar = grammar2;
    lib.write = writer2;
    lib.parse = parser2.parse;
    lib.parseParams = parser2.parseParams;
    lib.parseFmtpConfig = parser2.parseFmtpConfig;
    lib.parsePayloads = parser2.parsePayloads;
    lib.parseRemoteCandidates = parser2.parseRemoteCandidates;
    lib.parseImageAttributes = parser2.parseImageAttributes;
    lib.parseSimulcastStreamList = parser2.parseSimulcastStreamList;
    return lib;
  }
  var libExports = requireLib();
  function r$1(r2, e2, n2) {
    var i2, t2, o2;
    void 0 === e2 && (e2 = 50), void 0 === n2 && (n2 = {});
    var a2 = null != (i2 = n2.isImmediate) && i2, u2 = null != (t2 = n2.callback) && t2, c2 = n2.maxWait, v2 = Date.now(), l2 = [];
    function f2() {
      if (void 0 !== c2) {
        var r3 = Date.now() - v2;
        if (r3 + e2 >= c2)
          return c2 - r3;
      }
      return e2;
    }
    var d2 = function() {
      var e3 = [].slice.call(arguments), n22 = this;
      return new Promise(function(i22, t22) {
        var c22 = a2 && void 0 === o2;
        if (void 0 !== o2 && clearTimeout(o2), o2 = setTimeout(function() {
          if (o2 = void 0, v2 = Date.now(), !a2) {
            var i3 = r2.apply(n22, e3);
            u2 && u2(i3), l2.forEach(function(r3) {
              return (0, r3.resolve)(i3);
            }), l2 = [];
          }
        }, f2()), c22) {
          var d22 = r2.apply(n22, e3);
          return u2 && u2(d22), i22(d22);
        }
        l2.push({
          resolve: i22,
          reject: t22
        });
      });
    };
    return d2.cancel = function(r3) {
      void 0 !== o2 && clearTimeout(o2), l2.forEach(function(e3) {
        return (0, e3.reject)(r3);
      }), l2 = [];
    }, d2;
  }
  const startBitrateForSVC = 0.7;
  const debounceInterval = 20;
  const PCEvents = {
    NegotiationStarted: "negotiationStarted",
    NegotiationComplete: "negotiationComplete",
    RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
  };
  class PCTransport extends eventsExports.EventEmitter {
    get pc() {
      if (!this._pc) {
        this._pc = this.createPC();
      }
      return this._pc;
    }
    constructor(config) {
      let loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _a;
      super();
      this.log = livekitLogger;
      this.ddExtID = 0;
      this.pendingCandidates = [];
      this.restartingIce = false;
      this.renegotiate = false;
      this.trackBitrates = [];
      this.remoteStereoMids = [];
      this.remoteNackMids = [];
      this.negotiate = r$1((onError) => __awaiter(this, void 0, void 0, function* () {
        this.emit(PCEvents.NegotiationStarted);
        try {
          yield this.createAndSendOffer();
        } catch (e2) {
          if (onError) {
            onError(e2);
          } else {
            throw e2;
          }
        }
      }), debounceInterval);
      this.close = () => {
        if (!this._pc) {
          return;
        }
        this._pc.close();
        this._pc.onconnectionstatechange = null;
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.ondatachannel = null;
        this._pc.onnegotiationneeded = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ondatachannel = null;
        this._pc.ontrack = null;
        this._pc.onconnectionstatechange = null;
        this._pc.oniceconnectionstatechange = null;
        this._pc = null;
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);
      this.loggerOptions = loggerOptions;
      this.config = config;
      this._pc = this.createPC();
    }
    createPC() {
      const pc = new RTCPeerConnection(this.config);
      pc.onicecandidate = (ev) => {
        var _a;
        if (!ev.candidate)
          return;
        (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);
      };
      pc.onicecandidateerror = (ev) => {
        var _a;
        (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      pc.oniceconnectionstatechange = () => {
        var _a;
        (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);
      };
      pc.onsignalingstatechange = () => {
        var _a;
        (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);
      };
      pc.onconnectionstatechange = () => {
        var _a;
        (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);
      };
      pc.ondatachannel = (ev) => {
        var _a;
        (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      pc.ontrack = (ev) => {
        var _a;
        (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      return pc;
    }
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    get isICEConnected() {
      return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
    }
    addIceCandidate(candidate) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.pc.remoteDescription && !this.restartingIce) {
          return this.pc.addIceCandidate(candidate);
        }
        this.pendingCandidates.push(candidate);
      });
    }
    setRemoteDescription(sd) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        let mungedSDP = void 0;
        if (sd.type === "offer") {
          let {
            stereoMids,
            nackMids
          } = extractStereoAndNackAudioFromOffer(sd);
          this.remoteStereoMids = stereoMids;
          this.remoteNackMids = nackMids;
        } else if (sd.type === "answer") {
          const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : "");
          sdpParsed.media.forEach((media) => {
            if (media.type === "audio") {
              this.trackBitrates.some((trackbr) => {
                if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {
                  return false;
                }
                let codecPayload = 0;
                media.rtp.some((rtp) => {
                  if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                    codecPayload = rtp.payload;
                    return true;
                  }
                  return false;
                });
                if (codecPayload === 0) {
                  return true;
                }
                let fmtpFound = false;
                for (const fmtp of media.fmtp) {
                  if (fmtp.payload === codecPayload) {
                    fmtp.config = fmtp.config.split(";").filter((attr) => !attr.includes("maxaveragebitrate")).join(";");
                    if (trackbr.maxbr > 0) {
                      fmtp.config += ";maxaveragebitrate=".concat(trackbr.maxbr * 1e3);
                    }
                    fmtpFound = true;
                    break;
                  }
                }
                if (!fmtpFound) {
                  if (trackbr.maxbr > 0) {
                    media.fmtp.push({
                      payload: codecPayload,
                      config: "maxaveragebitrate=".concat(trackbr.maxbr * 1e3)
                    });
                  }
                }
                return true;
              });
            }
          });
          mungedSDP = libExports.write(sdpParsed);
        }
        yield this.setMungedSDP(sd, mungedSDP, true);
        this.pendingCandidates.forEach((candidate) => {
          this.pc.addIceCandidate(candidate);
        });
        this.pendingCandidates = [];
        this.restartingIce = false;
        if (this.renegotiate) {
          this.renegotiate = false;
          yield this.createAndSendOffer();
        } else if (sd.type === "answer") {
          this.emit(PCEvents.NegotiationComplete);
          if (sd.sdp) {
            const sdpParsed = libExports.parse(sd.sdp);
            sdpParsed.media.forEach((media) => {
              if (media.type === "video") {
                this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);
              }
            });
          }
        }
      });
    }
    createAndSendOffer(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (this.onOffer === void 0) {
          return;
        }
        if (options === null || options === void 0 ? void 0 : options.iceRestart) {
          this.log.debug("restarting ICE", this.logContext);
          this.restartingIce = true;
        }
        if (this._pc && this._pc.signalingState === "have-local-offer") {
          const currentSD = this._pc.remoteDescription;
          if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {
            yield this._pc.setRemoteDescription(currentSD);
          } else {
            this.renegotiate = true;
            return;
          }
        } else if (!this._pc || this._pc.signalingState === "closed") {
          this.log.warn("could not createOffer with closed peer connection", this.logContext);
          return;
        }
        this.log.debug("starting to negotiate", this.logContext);
        const offer = yield this.pc.createOffer(options);
        this.log.debug("original offer", Object.assign({
          sdp: offer.sdp
        }, this.logContext));
        const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");
        sdpParsed.media.forEach((media) => {
          ensureIPAddrMatchVersion(media);
          if (media.type === "audio") {
            ensureAudioNackAndStereo(media, [], []);
          } else if (media.type === "video") {
            this.trackBitrates.some((trackbr) => {
              if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {
                return false;
              }
              let codecPayload = 0;
              media.rtp.some((rtp) => {
                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                  codecPayload = rtp.payload;
                  return true;
                }
                return false;
              });
              if (codecPayload === 0) {
                return true;
              }
              if (isSVCCodec(trackbr.codec)) {
                this.ensureVideoDDExtensionForSVC(media, sdpParsed);
              }
              if (trackbr.codec !== "av1") {
                return true;
              }
              const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);
              for (const fmtp of media.fmtp) {
                if (fmtp.payload === codecPayload) {
                  if (!fmtp.config.includes("x-google-start-bitrate")) {
                    fmtp.config += ";x-google-start-bitrate=".concat(startBitrate);
                  }
                  break;
                }
              }
              return true;
            });
          }
        });
        yield this.setMungedSDP(offer, libExports.write(sdpParsed));
        this.onOffer(offer);
      });
    }
    createAndSetAnswer() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const answer = yield this.pc.createAnswer();
        const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : "");
        sdpParsed.media.forEach((media) => {
          ensureIPAddrMatchVersion(media);
          if (media.type === "audio") {
            ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);
          }
        });
        yield this.setMungedSDP(answer, libExports.write(sdpParsed));
        return answer;
      });
    }
    createDataChannel(label, dataChannelDict) {
      return this.pc.createDataChannel(label, dataChannelDict);
    }
    addTransceiver(mediaStreamTrack, transceiverInit) {
      return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);
    }
    addTrack(track) {
      if (!this._pc) {
        throw new UnexpectedConnectionState("PC closed, cannot add track");
      }
      return this._pc.addTrack(track);
    }
    setTrackCodecBitrate(info) {
      this.trackBitrates.push(info);
    }
    setConfiguration(rtcConfig) {
      var _a;
      if (!this._pc) {
        throw new UnexpectedConnectionState("PC closed, cannot configure");
      }
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);
    }
    canRemoveTrack() {
      var _a;
      return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);
    }
    removeTrack(sender) {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);
    }
    getConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : "closed";
    }
    getICEConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : "closed";
    }
    getSignallingState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : "closed";
    }
    getTransceivers() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];
    }
    getSenders() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];
    }
    getLocalDescription() {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;
    }
    getRemoteDescription() {
      var _a;
      return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;
    }
    getStats() {
      return this.pc.getStats();
    }
    getConnectedAddress() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!this._pc) {
          return;
        }
        let selectedCandidatePairId = "";
        const candidatePairs = /* @__PURE__ */ new Map();
        const candidates = /* @__PURE__ */ new Map();
        const stats = yield this._pc.getStats();
        stats.forEach((v2) => {
          switch (v2.type) {
            case "transport":
              selectedCandidatePairId = v2.selectedCandidatePairId;
              break;
            case "candidate-pair":
              if (selectedCandidatePairId === "" && v2.selected) {
                selectedCandidatePairId = v2.id;
              }
              candidatePairs.set(v2.id, v2);
              break;
            case "remote-candidate":
              candidates.set(v2.id, "".concat(v2.address, ":").concat(v2.port));
              break;
          }
        });
        if (selectedCandidatePairId === "") {
          return void 0;
        }
        const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;
        if (selectedID === void 0) {
          return void 0;
        }
        return candidates.get(selectedID);
      });
    }
    setMungedSDP(sd, munged, remote) {
      return __awaiter(this, void 0, void 0, function* () {
        if (munged) {
          const originalSdp = sd.sdp;
          sd.sdp = munged;
          try {
            this.log.debug("setting munged ".concat(remote ? "remote" : "local", " description"), this.logContext);
            if (remote) {
              yield this.pc.setRemoteDescription(sd);
            } else {
              yield this.pc.setLocalDescription(sd);
            }
            return;
          } catch (e2) {
            this.log.warn("not able to set ".concat(sd.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
              error: e2,
              sdp: munged
            }));
            sd.sdp = originalSdp;
          }
        }
        try {
          if (remote) {
            yield this.pc.setRemoteDescription(sd);
          } else {
            yield this.pc.setLocalDescription(sd);
          }
        } catch (e2) {
          let msg = "unknown error";
          if (e2 instanceof Error) {
            msg = e2.message;
          } else if (typeof e2 === "string") {
            msg = e2;
          }
          const fields = {
            error: msg,
            sdp: sd.sdp
          };
          if (!remote && this.pc.remoteDescription) {
            fields.remoteSdp = this.pc.remoteDescription;
          }
          this.log.error("unable to set ".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {
            fields
          }));
          throw new NegotiationError(msg);
        }
      });
    }
    ensureVideoDDExtensionForSVC(media, sdp2) {
      var _a, _b;
      const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some((ext) => {
        if (ext.uri === ddExtensionURI) {
          return true;
        }
        return false;
      });
      if (!ddFound) {
        if (this.ddExtID === 0) {
          let maxID = 0;
          sdp2.media.forEach((m2) => {
            var _a2;
            if (m2.type !== "video") {
              return;
            }
            (_a2 = m2.ext) === null || _a2 === void 0 ? void 0 : _a2.forEach((ext) => {
              if (ext.value > maxID) {
                maxID = ext.value;
              }
            });
          });
          this.ddExtID = maxID + 1;
        }
        (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({
          value: this.ddExtID,
          uri: ddExtensionURI
        });
      }
    }
  }
  function ensureAudioNackAndStereo(media, stereoMids, nackMids) {
    let opusPayload = 0;
    media.rtp.some((rtp) => {
      if (rtp.codec === "opus") {
        opusPayload = rtp.payload;
        return true;
      }
      return false;
    });
    if (opusPayload > 0) {
      if (!media.rtcpFb) {
        media.rtcpFb = [];
      }
      if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
        media.rtcpFb.push({
          payload: opusPayload,
          type: "nack"
        });
      }
      if (stereoMids.includes(media.mid)) {
        media.fmtp.some((fmtp) => {
          if (fmtp.payload === opusPayload) {
            if (!fmtp.config.includes("stereo=1")) {
              fmtp.config += ";stereo=1";
            }
            return true;
          }
          return false;
        });
      }
    }
  }
  function extractStereoAndNackAudioFromOffer(offer) {
    var _a;
    const stereoMids = [];
    const nackMids = [];
    const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");
    let opusPayload = 0;
    sdpParsed.media.forEach((media) => {
      var _a2;
      if (media.type === "audio") {
        media.rtp.some((rtp) => {
          if (rtp.codec === "opus") {
            opusPayload = rtp.payload;
            return true;
          }
          return false;
        });
        if ((_a2 = media.rtcpFb) === null || _a2 === void 0 ? void 0 : _a2.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
          nackMids.push(media.mid);
        }
        media.fmtp.some((fmtp) => {
          if (fmtp.payload === opusPayload) {
            if (fmtp.config.includes("sprop-stereo=1")) {
              stereoMids.push(media.mid);
            }
            return true;
          }
          return false;
        });
      }
    });
    return {
      stereoMids,
      nackMids
    };
  }
  function ensureIPAddrMatchVersion(media) {
    if (media.connection) {
      const isV6 = media.connection.ip.indexOf(":") >= 0;
      if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {
        media.connection.ip = "0.0.0.0";
        media.connection.version = 4;
      }
    }
  }
  const defaultVideoCodec = "vp8";
  const publishDefaults = {
    audioPreset: AudioPresets.music,
    dtx: true,
    red: true,
    forceStereo: false,
    simulcast: true,
    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
    stopMicTrackOnMute: false,
    videoCodec: defaultVideoCodec,
    backupCodec: true
  };
  const audioDefaults = {
    deviceId: "default",
    autoGainControl: true,
    echoCancellation: true,
    noiseSuppression: true,
    voiceIsolation: true
  };
  const videoDefaults = {
    deviceId: "default",
    resolution: VideoPresets.h720.resolution
  };
  const roomOptionDefaults = {
    adaptiveStream: false,
    dynacast: false,
    stopLocalTrackOnUnpublish: true,
    reconnectPolicy: new DefaultReconnectPolicy(),
    disconnectOnPageLeave: true,
    webAudioMix: false
  };
  const roomConnectOptionDefaults = {
    autoSubscribe: true,
    maxRetries: 1,
    peerConnectionTimeout: 15e3,
    websocketTimeout: 15e3
  };
  var PCTransportState;
  (function(PCTransportState2) {
    PCTransportState2[PCTransportState2["NEW"] = 0] = "NEW";
    PCTransportState2[PCTransportState2["CONNECTING"] = 1] = "CONNECTING";
    PCTransportState2[PCTransportState2["CONNECTED"] = 2] = "CONNECTED";
    PCTransportState2[PCTransportState2["FAILED"] = 3] = "FAILED";
    PCTransportState2[PCTransportState2["CLOSING"] = 4] = "CLOSING";
    PCTransportState2[PCTransportState2["CLOSED"] = 5] = "CLOSED";
  })(PCTransportState || (PCTransportState = {}));
  class PCTransportManager {
    get needsPublisher() {
      return this.isPublisherConnectionRequired;
    }
    get needsSubscriber() {
      return this.isSubscriberConnectionRequired;
    }
    get currentState() {
      return this.state;
    }
    constructor(rtcConfig, subscriberPrimary, loggerOptions) {
      var _a;
      this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
      this.log = livekitLogger;
      this.updateState = () => {
        var _a2;
        const previousState = this.state;
        const connectionStates = this.requiredTransports.map((tr) => tr.getConnectionState());
        if (connectionStates.every((st2) => st2 === "connected")) {
          this.state = PCTransportState.CONNECTED;
        } else if (connectionStates.some((st2) => st2 === "failed")) {
          this.state = PCTransportState.FAILED;
        } else if (connectionStates.some((st2) => st2 === "connecting")) {
          this.state = PCTransportState.CONNECTING;
        } else if (connectionStates.every((st2) => st2 === "closed")) {
          this.state = PCTransportState.CLOSED;
        } else if (connectionStates.some((st2) => st2 === "closed")) {
          this.state = PCTransportState.CLOSING;
        } else if (connectionStates.every((st2) => st2 === "new")) {
          this.state = PCTransportState.NEW;
        }
        if (previousState !== this.state) {
          this.log.debug("pc state change: from ".concat(PCTransportState[previousState], " to ").concat(PCTransportState[this.state]), this.logContext);
          (_a2 = this.onStateChange) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());
        }
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);
      this.loggerOptions = loggerOptions;
      this.isPublisherConnectionRequired = !subscriberPrimary;
      this.isSubscriberConnectionRequired = subscriberPrimary;
      this.publisher = new PCTransport(rtcConfig, loggerOptions);
      this.subscriber = new PCTransport(rtcConfig, loggerOptions);
      this.publisher.onConnectionStateChange = this.updateState;
      this.subscriber.onConnectionStateChange = this.updateState;
      this.publisher.onIceConnectionStateChange = this.updateState;
      this.subscriber.onIceConnectionStateChange = this.updateState;
      this.publisher.onSignalingStatechange = this.updateState;
      this.subscriber.onSignalingStatechange = this.updateState;
      this.publisher.onIceCandidate = (candidate) => {
        var _a2;
        (_a2 = this.onIceCandidate) === null || _a2 === void 0 ? void 0 : _a2.call(this, candidate, SignalTarget.PUBLISHER);
      };
      this.subscriber.onIceCandidate = (candidate) => {
        var _a2;
        (_a2 = this.onIceCandidate) === null || _a2 === void 0 ? void 0 : _a2.call(this, candidate, SignalTarget.SUBSCRIBER);
      };
      this.subscriber.onDataChannel = (ev) => {
        var _a2;
        (_a2 = this.onDataChannel) === null || _a2 === void 0 ? void 0 : _a2.call(this, ev);
      };
      this.subscriber.onTrack = (ev) => {
        var _a2;
        (_a2 = this.onTrack) === null || _a2 === void 0 ? void 0 : _a2.call(this, ev);
      };
      this.publisher.onOffer = (offer) => {
        var _a2;
        (_a2 = this.onPublisherOffer) === null || _a2 === void 0 ? void 0 : _a2.call(this, offer);
      };
      this.state = PCTransportState.NEW;
      this.connectionLock = new _$1();
      this.remoteOfferLock = new _$1();
    }
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    requirePublisher() {
      let require = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.isPublisherConnectionRequired = require;
      this.updateState();
    }
    requireSubscriber() {
      let require = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.isSubscriberConnectionRequired = require;
      this.updateState();
    }
    createAndSendPublisherOffer(options) {
      return this.publisher.createAndSendOffer(options);
    }
    setPublisherAnswer(sd) {
      return this.publisher.setRemoteDescription(sd);
    }
    removeTrack(sender) {
      return this.publisher.removeTrack(sender);
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.publisher && this.publisher.getSignallingState() !== "closed") {
          const publisher = this.publisher;
          for (const sender of publisher.getSenders()) {
            try {
              if (publisher.canRemoveTrack()) {
                publisher.removeTrack(sender);
              }
            } catch (e2) {
              this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
                error: e2
              }));
            }
          }
        }
        yield Promise.all([this.publisher.close(), this.subscriber.close()]);
        this.updateState();
      });
    }
    triggerIceRestart() {
      return __awaiter(this, void 0, void 0, function* () {
        this.subscriber.restartingIce = true;
        if (this.needsPublisher) {
          yield this.createAndSendPublisherOffer({
            iceRestart: true
          });
        }
      });
    }
    addIceCandidate(candidate, target) {
      return __awaiter(this, void 0, void 0, function* () {
        if (target === SignalTarget.PUBLISHER) {
          yield this.publisher.addIceCandidate(candidate);
        } else {
          yield this.subscriber.addIceCandidate(candidate);
        }
      });
    }
    createSubscriberAnswerFromOffer(sd) {
      return __awaiter(this, void 0, void 0, function* () {
        this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
          RTCSdpType: sd.type,
          sdp: sd.sdp,
          signalingState: this.subscriber.getSignallingState().toString()
        }));
        const unlock = yield this.remoteOfferLock.lock();
        try {
          yield this.subscriber.setRemoteDescription(sd);
          const answer = yield this.subscriber.createAndSetAnswer();
          return answer;
        } finally {
          unlock();
        }
      });
    }
    updateConfiguration(config, iceRestart) {
      this.publisher.setConfiguration(config);
      this.subscriber.setConfiguration(config);
      if (iceRestart) {
        this.triggerIceRestart();
      }
    }
    ensurePCTransportConnection(abortController, timeout2) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.connectionLock.lock();
        try {
          if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting") {
            this.log.debug("negotiation required, start negotiating", this.logContext);
            this.publisher.negotiate();
          }
          yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport) => this.ensureTransportConnected(transport, abortController, timeout2)));
        } finally {
          unlock();
        }
      });
    }
    negotiate(abortController) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          const negotiationTimeout = setTimeout(() => {
            reject("negotiation timed out");
          }, this.peerConnectionTimeout);
          const abortHandler = () => {
            clearTimeout(negotiationTimeout);
            reject("negotiation aborted");
          };
          abortController.signal.addEventListener("abort", abortHandler);
          this.publisher.once(PCEvents.NegotiationStarted, () => {
            if (abortController.signal.aborted) {
              return;
            }
            this.publisher.once(PCEvents.NegotiationComplete, () => {
              clearTimeout(negotiationTimeout);
              resolve();
            });
          });
          yield this.publisher.negotiate((e2) => {
            clearTimeout(negotiationTimeout);
            reject(e2);
          });
        }));
      });
    }
    addPublisherTransceiver(track, transceiverInit) {
      return this.publisher.addTransceiver(track, transceiverInit);
    }
    addPublisherTrack(track) {
      return this.publisher.addTrack(track);
    }
    createPublisherDataChannel(label, dataChannelDict) {
      return this.publisher.createDataChannel(label, dataChannelDict);
    }
    /**
     * Returns the first required transport's address if no explicit target is specified
     */
    getConnectedAddress(target) {
      if (target === SignalTarget.PUBLISHER) {
        return this.publisher.getConnectedAddress();
      } else if (target === SignalTarget.SUBSCRIBER) {
        return this.publisher.getConnectedAddress();
      }
      return this.requiredTransports[0].getConnectedAddress();
    }
    get requiredTransports() {
      const transports = [];
      if (this.isPublisherConnectionRequired) {
        transports.push(this.publisher);
      }
      if (this.isSubscriberConnectionRequired) {
        transports.push(this.subscriber);
      }
      return transports;
    }
    ensureTransportConnected(pcTransport_1, abortController_1) {
      return __awaiter(this, arguments, void 0, function(pcTransport, abortController) {
        var _this = this;
        let timeout2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
        return function* () {
          const connectionState = pcTransport.getConnectionState();
          if (connectionState === "connected") {
            return;
          }
          return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {
            const abortHandler = () => {
              this.log.warn("abort transport connection", this.logContext);
              CriticalTimers.clearTimeout(connectTimeout);
              reject(new ConnectionError("room connection has been cancelled", ConnectionErrorReason.Cancelled));
            };
            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
              abortHandler();
            }
            abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener("abort", abortHandler);
            const connectTimeout = CriticalTimers.setTimeout(() => {
              abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
              reject(new ConnectionError("could not establish pc connection", ConnectionErrorReason.InternalError));
            }, timeout2);
            while (this.state !== PCTransportState.CONNECTED) {
              yield sleep(50);
              if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
                reject(new ConnectionError("room connection has been cancelled", ConnectionErrorReason.Cancelled));
                return;
              }
            }
            CriticalTimers.clearTimeout(connectTimeout);
            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
            resolve();
          }));
        }();
      });
    }
  }
  class RpcError extends Error {
    /**
     * Creates an error object with the given code and message, plus an optional data payload.
     *
     * If thrown in an RPC method handler, the error will be sent back to the caller.
     *
     * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).
     */
    constructor(code, message, data) {
      super(message);
      this.code = code;
      this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);
      this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : void 0;
    }
    /**
     * @internal
     */
    static fromProto(proto) {
      return new RpcError(proto.code, proto.message, proto.data);
    }
    /**
     * @internal
     */
    toProto() {
      return new RpcError$1({
        code: this.code,
        message: this.message,
        data: this.data
      });
    }
    /**
     * Creates an error object from the code, with an auto-populated message.
     *
     * @internal
     */
    static builtIn(key, data) {
      return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);
    }
  }
  RpcError.MAX_MESSAGE_BYTES = 256;
  RpcError.MAX_DATA_BYTES = 15360;
  RpcError.ErrorCode = {
    APPLICATION_ERROR: 1500,
    CONNECTION_TIMEOUT: 1501,
    RESPONSE_TIMEOUT: 1502,
    RECIPIENT_DISCONNECTED: 1503,
    RESPONSE_PAYLOAD_TOO_LARGE: 1504,
    SEND_FAILED: 1505,
    UNSUPPORTED_METHOD: 1400,
    RECIPIENT_NOT_FOUND: 1401,
    REQUEST_PAYLOAD_TOO_LARGE: 1402,
    UNSUPPORTED_SERVER: 1403,
    UNSUPPORTED_VERSION: 1404
  };
  RpcError.ErrorMessage = {
    APPLICATION_ERROR: "Application error in method handler",
    CONNECTION_TIMEOUT: "Connection timeout",
    RESPONSE_TIMEOUT: "Response timeout",
    RECIPIENT_DISCONNECTED: "Recipient disconnected",
    RESPONSE_PAYLOAD_TOO_LARGE: "Response payload too large",
    SEND_FAILED: "Failed to send",
    UNSUPPORTED_METHOD: "Method not supported at destination",
    RECIPIENT_NOT_FOUND: "Recipient not found",
    REQUEST_PAYLOAD_TOO_LARGE: "Request payload too large",
    UNSUPPORTED_SERVER: "RPC not supported by server",
    UNSUPPORTED_VERSION: "Unsupported RPC version"
  };
  const MAX_PAYLOAD_BYTES = 15360;
  function byteLength(str) {
    const encoder = new TextEncoder();
    return encoder.encode(str).length;
  }
  function truncateBytes(str, maxBytes) {
    if (byteLength(str) <= maxBytes) {
      return str;
    }
    let low = 0;
    let high = str.length;
    const encoder = new TextEncoder();
    while (low < high) {
      const mid = Math.floor((low + high + 1) / 2);
      if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {
        low = mid;
      } else {
        high = mid - 1;
      }
    }
    return str.slice(0, low);
  }
  const monitorFrequency = 2e3;
  function computeBitrate(currentStats, prevStats) {
    if (!prevStats) {
      return 0;
    }
    let bytesNow;
    let bytesPrev;
    if ("bytesReceived" in currentStats) {
      bytesNow = currentStats.bytesReceived;
      bytesPrev = prevStats.bytesReceived;
    } else if ("bytesSent" in currentStats) {
      bytesNow = currentStats.bytesSent;
      bytesPrev = prevStats.bytesSent;
    }
    if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {
      return 0;
    }
    return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);
  }
  const defaultDimensionsTimeout = 1e3;
  class LocalTrack extends Track {
    /** @internal */
    get sender() {
      return this._sender;
    }
    /** @internal */
    set sender(sender) {
      this._sender = sender;
    }
    get constraints() {
      return this._constraints;
    }
    /**
     *
     * @param mediaTrack
     * @param kind
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, kind, constraints) {
      let userProvidedTrack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      let loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
      super(mediaTrack, kind, loggerOptions);
      this.manuallyStopped = false;
      this._isUpstreamPaused = false;
      this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext));
      this.debouncedTrackMuteHandler = r$1(() => __awaiter(this, void 0, void 0, function* () {
        yield this.pauseUpstream();
      }), 5e3);
      this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {
        this.debouncedTrackMuteHandler.cancel("unmute");
        yield this.resumeUpstream();
      });
      this.handleEnded = () => {
        if (this.isInBackground) {
          this.reacquireTrack = true;
        }
        this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
        this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
        this.emit(TrackEvent.Ended, this);
      };
      this.reacquireTrack = false;
      this.providedByUser = userProvidedTrack;
      this.muteLock = new _$1();
      this.pauseUpstreamLock = new _$1();
      this.processorLock = new _$1();
      this.restartLock = new _$1();
      this.setMediaStreamTrack(mediaTrack, true);
      this._constraints = mediaTrack.getConstraints();
      if (constraints) {
        this._constraints = constraints;
      }
    }
    get id() {
      return this._mediaStreamTrack.id;
    }
    get dimensions() {
      if (this.kind !== Track.Kind.Video) {
        return void 0;
      }
      const {
        width,
        height
      } = this._mediaStreamTrack.getSettings();
      if (width && height) {
        return {
          width,
          height
        };
      }
      return void 0;
    }
    get isUpstreamPaused() {
      return this._isUpstreamPaused;
    }
    get isUserProvided() {
      return this.providedByUser;
    }
    get mediaStreamTrack() {
      var _a, _b;
      return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;
    }
    get isLocal() {
      return true;
    }
    /**
     * @internal
     * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors
     */
    getSourceTrackSettings() {
      return this._mediaStreamTrack.getSettings();
    }
    setMediaStreamTrack(newTrack, force) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (newTrack === this._mediaStreamTrack && !force) {
          return;
        }
        if (this._mediaStreamTrack) {
          this.attachedElements.forEach((el) => {
            detachTrack(this._mediaStreamTrack, el);
          });
          this.debouncedTrackMuteHandler.cancel("new-track");
          this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
          this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
          this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
        }
        this.mediaStream = new MediaStream([newTrack]);
        if (newTrack) {
          newTrack.addEventListener("ended", this.handleEnded);
          newTrack.addEventListener("mute", this.handleTrackMuteEvent);
          newTrack.addEventListener("unmute", this.handleTrackUnmuteEvent);
          this._constraints = newTrack.getConstraints();
        }
        let processedTrack;
        if (this.processor && newTrack) {
          const unlock = yield this.processorLock.lock();
          try {
            this.log.debug("restarting processor", this.logContext);
            if (this.kind === "unknown") {
              throw TypeError("cannot set processor on track of unknown kind");
            }
            if (this.processorElement) {
              attachToElement(newTrack, this.processorElement);
              this.processorElement.muted = true;
            }
            yield this.processor.restart({
              track: newTrack,
              kind: this.kind,
              element: this.processorElement
            });
            processedTrack = this.processor.processedTrack;
          } finally {
            unlock();
          }
        }
        if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== "closed") {
          yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);
        }
        if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {
          this._mediaStreamTrack.stop();
        }
        this._mediaStreamTrack = newTrack;
        if (newTrack) {
          this._mediaStreamTrack.enabled = !this.isMuted;
          yield this.resumeUpstream();
          this.attachedElements.forEach((el) => {
            attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);
          });
        }
      });
    }
    waitForDimensions() {
      return __awaiter(this, arguments, void 0, function() {
        var _this = this;
        let timeout2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
        return function* () {
          var _a;
          if (_this.kind === Track.Kind.Audio) {
            throw new Error("cannot get dimensions for audio tracks");
          }
          if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === "iOS") {
            yield sleep(10);
          }
          const started = Date.now();
          while (Date.now() - started < timeout2) {
            const dims = _this.dimensions;
            if (dims) {
              return dims;
            }
            yield sleep(50);
          }
          throw new TrackInvalidError("unable to get track dimensions after timeout");
        }();
      });
    }
    setDeviceId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {
          return true;
        }
        this._constraints.deviceId = deviceId;
        if (this.isMuted) {
          return true;
        }
        yield this.restartTrack();
        return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;
      });
    }
    /**
     * @returns DeviceID of the device that is currently being used for this track
     */
    getDeviceId() {
      return __awaiter(this, arguments, void 0, function() {
        var _this2 = this;
        let normalize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          if (_this2.source === Track.Source.ScreenShare) {
            return;
          }
          const {
            deviceId,
            groupId
          } = _this2._mediaStreamTrack.getSettings();
          const kind = _this2.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
          return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;
        }();
      });
    }
    mute() {
      return __awaiter(this, void 0, void 0, function* () {
        this.setTrackMuted(true);
        return this;
      });
    }
    unmute() {
      return __awaiter(this, void 0, void 0, function* () {
        this.setTrackMuted(false);
        return this;
      });
    }
    replaceTrack(track, userProvidedOrOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          throw new TrackInvalidError("unable to replace an unpublished track");
        }
        let userProvidedTrack;
        let stopProcessor;
        if (typeof userProvidedOrOptions === "boolean") {
          userProvidedTrack = userProvidedOrOptions;
        } else if (userProvidedOrOptions !== void 0) {
          userProvidedTrack = userProvidedOrOptions.userProvidedTrack;
          stopProcessor = userProvidedOrOptions.stopProcessor;
        }
        this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;
        this.log.debug("replace MediaStreamTrack", this.logContext);
        yield this.setMediaStreamTrack(track);
        if (stopProcessor && this.processor) {
          yield this.stopProcessor();
        }
        return this;
      });
    }
    restart(constraints) {
      return __awaiter(this, void 0, void 0, function* () {
        this.manuallyStopped = false;
        const unlock = yield this.restartLock.lock();
        try {
          if (!constraints) {
            constraints = this._constraints;
          }
          this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
            constraints
          }));
          const streamConstraints = {
            audio: false,
            video: false
          };
          if (this.kind === Track.Kind.Video) {
            streamConstraints.video = constraints;
          } else {
            streamConstraints.audio = constraints;
          }
          this.attachedElements.forEach((el) => {
            detachTrack(this.mediaStreamTrack, el);
          });
          this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
          this._mediaStreamTrack.stop();
          const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);
          const newTrack = mediaStream.getTracks()[0];
          newTrack.addEventListener("ended", this.handleEnded);
          this.log.debug("re-acquired MediaStreamTrack", this.logContext);
          yield this.setMediaStreamTrack(newTrack);
          this._constraints = constraints;
          this.emit(TrackEvent.Restarted, this);
          if (this.manuallyStopped) {
            this.log.warn("track was stopped during a restart, stopping restarted track", this.logContext);
            this.stop();
          }
          return this;
        } finally {
          unlock();
        }
      });
    }
    setTrackMuted(muted) {
      this.log.debug("setting ".concat(this.kind, " track ").concat(muted ? "muted" : "unmuted"), this.logContext);
      if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {
        return;
      }
      this.isMuted = muted;
      this._mediaStreamTrack.enabled = !muted;
      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
    }
    get needsReAcquisition() {
      return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!isMobile())
          return;
        this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext);
        if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {
          this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext);
          yield this.restart();
          this.reacquireTrack = false;
        }
      });
    }
    stop() {
      var _a;
      this.manuallyStopped = true;
      super.stop();
      this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
      this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
      this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
      (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();
      this.processor = void 0;
    }
    /**
     * pauses publishing to the server without disabling the local MediaStreamTrack
     * this is used to display a user's own video locally while pausing publishing to
     * the server.
     * this API is unsupported on Safari < 12 due to a bug
     **/
    pauseUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === true) {
            return;
          }
          if (!this.sender) {
            this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
            return;
          }
          this._isUpstreamPaused = true;
          this.emit(TrackEvent.UpstreamPaused, this);
          const browser = getBrowser();
          if ((browser === null || browser === void 0 ? void 0 : browser.name) === "Safari" && compareVersions(browser.version, "12.0") < 0) {
            throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
          }
          if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== "closed") {
            yield this.sender.replaceTrack(null);
          }
        } finally {
          unlock();
        }
      });
    }
    resumeUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === false) {
            return;
          }
          if (!this.sender) {
            this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
            return;
          }
          this._isUpstreamPaused = false;
          this.emit(TrackEvent.UpstreamResumed, this);
          if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== "closed") {
            yield this.sender.replaceTrack(this.mediaStreamTrack);
          }
        } finally {
          unlock();
        }
      });
    }
    /**
     * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
    getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return;
        }
        const statsReport = yield this.sender.getStats();
        return statsReport;
      });
    }
    /**
     * Sets a processor on this track.
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     *
     * @param processor
     * @param showProcessedStreamLocally
     * @returns
     */
    setProcessor(processor_1) {
      return __awaiter(this, arguments, void 0, function(processor) {
        var _this3 = this;
        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a;
          const unlock = yield _this3.processorLock.lock();
          try {
            _this3.log.debug("setting up processor", _this3.logContext);
            const processorElement = document.createElement(_this3.kind);
            const processorOptions = {
              kind: _this3.kind,
              track: _this3._mediaStreamTrack,
              element: processorElement,
              audioContext: _this3.audioContext
            };
            yield processor.init(processorOptions);
            _this3.log.debug("processor initialized", _this3.logContext);
            if (_this3.processor) {
              yield _this3.stopProcessor();
            }
            if (_this3.kind === "unknown") {
              throw TypeError("cannot set processor on track of unknown kind");
            }
            attachToElement(_this3._mediaStreamTrack, processorElement);
            processorElement.muted = true;
            processorElement.play().catch((error) => _this3.log.error("failed to play processor element", Object.assign(Object.assign({}, _this3.logContext), {
              error
            })));
            _this3.processor = processor;
            _this3.processorElement = processorElement;
            if (_this3.processor.processedTrack) {
              for (const el of _this3.attachedElements) {
                if (el !== _this3.processorElement && showProcessedStreamLocally) {
                  detachTrack(_this3._mediaStreamTrack, el);
                  attachToElement(_this3.processor.processedTrack, el);
                }
              }
              yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);
            }
            _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);
          } finally {
            unlock();
          }
        }();
      });
    }
    getProcessor() {
      return this.processor;
    }
    /**
     * Stops the track processor
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     * @returns
     */
    stopProcessor() {
      return __awaiter(this, arguments, void 0, function() {
        var _this4 = this;
        let keepElement = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          var _a, _b;
          if (!_this4.processor)
            return;
          _this4.log.debug("stopping processor", _this4.logContext);
          (_a = _this4.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();
          yield _this4.processor.destroy();
          _this4.processor = void 0;
          if (!keepElement) {
            (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();
            _this4.processorElement = void 0;
          }
          yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);
          yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);
          _this4.emit(TrackEvent.TrackProcessorUpdate);
        }();
      });
    }
  }
  class LocalAudioTrack extends LocalTrack {
    /**
     * boolean indicating whether enhanced noise cancellation is currently being used on this track
     */
    get enhancedNoiseCancellation() {
      return this.isKrispNoiseFilterEnabled;
    }
    /**
     *
     * @param mediaTrack
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, constraints) {
      let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      let audioContext = arguments.length > 3 ? arguments[3] : void 0;
      let loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
      super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);
      this.stopOnMute = false;
      this.isKrispNoiseFilterEnabled = false;
      this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          this._currentBitrate = 0;
          return;
        }
        let stats;
        try {
          stats = yield this.getSenderStats();
        } catch (e2) {
          this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
            error: e2
          }));
          return;
        }
        if (stats && this.prevStats) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.handleKrispNoiseFilterEnable = () => {
        this.isKrispNoiseFilterEnabled = true;
        this.log.debug("Krisp noise filter enabled", this.logContext);
        this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);
      };
      this.handleKrispNoiseFilterDisable = () => {
        this.isKrispNoiseFilterEnabled = false;
        this.log.debug("Krisp noise filter disabled", this.logContext);
        this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);
      };
      this.audioContext = audioContext;
      this.checkForSilence();
    }
    mute() {
      const _super = Object.create(null, {
        mute: {
          get: () => super.mute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (this.isMuted) {
            this.log.debug("Track already muted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {
            this.log.debug("stopping mic track", this.logContext);
            this._mediaStreamTrack.stop();
          }
          yield _super.mute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    unmute() {
      const _super = Object.create(null, {
        unmute: {
          get: () => super.unmute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (!this.isMuted) {
            this.log.debug("Track already unmuted", this.logContext);
            return this;
          }
          const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
          if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || deviceHasChanged) && !this.isUserProvided) {
            this.log.debug("reacquiring mic track", this.logContext);
            yield this.restartTrack();
          }
          yield _super.unmute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    restartTrack(options) {
      return __awaiter(this, void 0, void 0, function* () {
        let constraints;
        if (options) {
          const streamConstraints = constraintsForOptions({
            audio: options
          });
          if (typeof streamConstraints.audio !== "boolean") {
            constraints = streamConstraints.audio;
          }
        }
        yield this.restart(constraints);
      });
    }
    restart(constraints) {
      const _super = Object.create(null, {
        restart: {
          get: () => super.restart
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const track = yield _super.restart.call(this, constraints);
        this.checkForSilence();
        return track;
      });
    }
    /* @internal */
    startMonitor() {
      if (!isWeb()) {
        return;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(() => {
        this.monitorSender();
      }, monitorFrequency);
    }
    setProcessor(processor) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.processorLock.lock();
        try {
          if (!isReactNative() && !this.audioContext) {
            throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
          }
          if (this.processor) {
            yield this.stopProcessor();
          }
          const processorOptions = {
            kind: this.kind,
            track: this._mediaStreamTrack,
            // RN won't have or use AudioContext
            audioContext: this.audioContext
          };
          this.log.debug("setting up audio processor ".concat(processor.name), this.logContext);
          yield processor.init(processorOptions);
          this.processor = processor;
          if (this.processor.processedTrack) {
            yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);
            this.processor.processedTrack.addEventListener("enable-lk-krisp-noise-filter", this.handleKrispNoiseFilterEnable);
            this.processor.processedTrack.addEventListener("disable-lk-krisp-noise-filter", this.handleKrispNoiseFilterDisable);
          }
          this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
        } finally {
          unlock();
        }
      });
    }
    /**
     * @internal
     * @experimental
     */
    setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }
    getSenderStats() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return void 0;
        }
        const stats = yield this.sender.getStats();
        let audioStats;
        stats.forEach((v2) => {
          if (v2.type === "outbound-rtp") {
            audioStats = {
              type: "audio",
              streamId: v2.id,
              packetsSent: v2.packetsSent,
              packetsLost: v2.packetsLost,
              bytesSent: v2.bytesSent,
              timestamp: v2.timestamp,
              roundTripTime: v2.roundTripTime,
              jitter: v2.jitter
            };
          }
        });
        return audioStats;
      });
    }
    checkForSilence() {
      return __awaiter(this, void 0, void 0, function* () {
        const trackIsSilent = yield detectSilence(this);
        if (trackIsSilent) {
          if (!this.isMuted) {
            this.log.warn("silence detected on local audio track", this.logContext);
          }
          this.emit(TrackEvent.AudioSilenceDetected);
        }
        return trackIsSilent;
      });
    }
  }
  function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {
    switch (mediaStreamTrack.kind) {
      case "audio":
        return new LocalAudioTrack(mediaStreamTrack, constraints, false, void 0, loggerOptions);
      case "video":
        return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);
      default:
        throw new TrackInvalidError("unsupported track type: ".concat(mediaStreamTrack.kind));
    }
  }
  const presets169 = Object.values(VideoPresets);
  const presets43 = Object.values(VideoPresets43);
  const presetsScreenShare = Object.values(ScreenSharePresets);
  const defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];
  const defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];
  const computeDefaultScreenShareSimulcastPresets = (fromPreset) => {
    const layers = [{
      scaleResolutionDownBy: 2,
      fps: fromPreset.encoding.maxFramerate
    }];
    return layers.map((t2) => {
      var _a, _b;
      return new VideoPreset(Math.floor(fromPreset.width / t2.scaleResolutionDownBy), Math.floor(fromPreset.height / t2.scaleResolutionDownBy), Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t2.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t2.fps) !== null && _b !== void 0 ? _b : 30))))), t2.fps, fromPreset.encoding.priority);
    });
  };
  const videoRids = ["q", "h", "f"];
  function computeVideoEncodings(isScreenShare, width, height, options) {
    var _a, _b;
    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;
    if (isScreenShare) {
      videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;
    }
    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;
    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;
    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;
    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {
      return [{}];
    }
    if (!videoEncoding) {
      videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);
      livekitLogger.debug("using video encoding", videoEncoding);
    }
    const sourceFramerate = videoEncoding.maxFramerate;
    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);
    if (scalabilityMode && isSVCCodec(videoCodec)) {
      const sm = new ScalabilityMode(scalabilityMode);
      const encodings = [];
      if (sm.spatial > 3) {
        throw new Error("unsupported scalabilityMode: ".concat(scalabilityMode));
      }
      const browser = getBrowser();
      if (isSafari() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding
      // is provided. So we'll use the legacy SVC specification for now.
      // TODO: when we upstream libwebrtc, this will need additional verification
      isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, "113") < 0) {
        const bitratesRatio = sm.suffix == "h" ? 2 : 3;
        for (let i2 = 0; i2 < sm.spatial; i2 += 1) {
          encodings.push({
            rid: videoRids[2 - i2],
            maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i2),
            maxFramerate: original.encoding.maxFramerate
          });
        }
        encodings[0].scalabilityMode = scalabilityMode;
      } else {
        encodings.push({
          maxBitrate: videoEncoding.maxBitrate,
          maxFramerate: original.encoding.maxFramerate,
          /* @ts-ignore */
          scalabilityMode
        });
      }
      if (original.encoding.priority) {
        encodings[0].priority = original.encoding.priority;
        encodings[0].networkPriority = original.encoding.priority;
      }
      livekitLogger.debug("using svc encoding", {
        encodings
      });
      return encodings;
    }
    if (!useSimulcast) {
      return [videoEncoding];
    }
    let presets = [];
    if (isScreenShare) {
      presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);
    } else {
      presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);
    }
    let midPreset;
    if (presets.length > 0) {
      const lowPreset = presets[0];
      if (presets.length > 1) {
        [, midPreset] = presets;
      }
      const size = Math.max(width, height);
      if (size >= 960 && midPreset) {
        return encodingsFromPresets(width, height, [lowPreset, midPreset, original], sourceFramerate);
      }
      if (size >= 480) {
        return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);
      }
    }
    return encodingsFromPresets(width, height, [original]);
  }
  function computeTrackBackupEncodings(track, videoCodec, opts) {
    var _a, _b, _c, _d;
    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {
      return;
    }
    if (videoCodec !== opts.backupCodec.codec) {
      livekitLogger.warn("requested a different codec than specified as backup", {
        serverRequested: videoCodec,
        backup: opts.backupCodec.codec
      });
    }
    opts.videoCodec = videoCodec;
    opts.videoEncoding = opts.backupCodec.encoding;
    const settings = track.mediaStreamTrack.getSettings();
    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;
    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;
    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);
    return encodings;
  }
  function determineAppropriateEncoding(isScreenShare, width, height, codec) {
    const presets = presetsForResolution(isScreenShare, width, height);
    let {
      encoding
    } = presets[0];
    const size = Math.max(width, height);
    for (let i2 = 0; i2 < presets.length; i2 += 1) {
      const preset = presets[i2];
      encoding = preset.encoding;
      if (preset.width >= size) {
        break;
      }
    }
    if (codec) {
      switch (codec) {
        case "av1":
          encoding = Object.assign({}, encoding);
          encoding.maxBitrate = encoding.maxBitrate * 0.7;
          break;
        case "vp9":
          encoding = Object.assign({}, encoding);
          encoding.maxBitrate = encoding.maxBitrate * 0.85;
          break;
      }
    }
    return encoding;
  }
  function presetsForResolution(isScreenShare, width, height) {
    if (isScreenShare) {
      return presetsScreenShare;
    }
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
      return presets169;
    }
    return presets43;
  }
  function defaultSimulcastLayers(isScreenShare, original) {
    if (isScreenShare) {
      return computeDefaultScreenShareSimulcastPresets(original);
    }
    const {
      width,
      height
    } = original;
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
      return defaultSimulcastPresets169;
    }
    return defaultSimulcastPresets43;
  }
  function encodingsFromPresets(width, height, presets, sourceFramerate) {
    const encodings = [];
    presets.forEach((preset, idx) => {
      if (idx >= videoRids.length) {
        return;
      }
      const size = Math.min(width, height);
      const rid = videoRids[idx];
      const encoding = {
        rid,
        scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),
        maxBitrate: preset.encoding.maxBitrate
      };
      const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;
      if (maxFramerate) {
        encoding.maxFramerate = maxFramerate;
      }
      const canSetPriority = isFireFox() || idx === 0;
      if (preset.encoding.priority && canSetPriority) {
        encoding.priority = preset.encoding.priority;
        encoding.networkPriority = preset.encoding.priority;
      }
      encodings.push(encoding);
    });
    if (isReactNative() && getReactNativeOs() === "ios") {
      let topFramerate = void 0;
      encodings.forEach((encoding) => {
        if (!topFramerate) {
          topFramerate = encoding.maxFramerate;
        } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {
          topFramerate = encoding.maxFramerate;
        }
      });
      let notifyOnce = true;
      encodings.forEach((encoding) => {
        var _a;
        if (encoding.maxFramerate != topFramerate) {
          if (notifyOnce) {
            notifyOnce = false;
            livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.");
          }
          livekitLogger.info('Setting framerate of encoding "'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : "", '" to ').concat(topFramerate));
          encoding.maxFramerate = topFramerate;
        }
      });
    }
    return encodings;
  }
  function sortPresets(presets) {
    if (!presets)
      return;
    return presets.sort((a2, b2) => {
      const {
        encoding: aEnc
      } = a2;
      const {
        encoding: bEnc
      } = b2;
      if (aEnc.maxBitrate > bEnc.maxBitrate) {
        return 1;
      }
      if (aEnc.maxBitrate < bEnc.maxBitrate)
        return -1;
      if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
        return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
      }
      return 0;
    });
  }
  class ScalabilityMode {
    constructor(scalabilityMode) {
      const results = scalabilityMode.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
      if (!results) {
        throw new Error("invalid scalability mode");
      }
      this.spatial = parseInt(results[1]);
      this.temporal = parseInt(results[2]);
      if (results.length > 3) {
        switch (results[3]) {
          case "h":
          case "_KEY":
          case "_KEY_SHIFT":
            this.suffix = results[3];
        }
      }
    }
    toString() {
      var _a;
      return "L".concat(this.spatial, "T").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : "");
    }
  }
  function getDefaultDegradationPreference(track) {
    if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {
      return "maintain-resolution";
    } else {
      return "balanced";
    }
  }
  const refreshSubscribedCodecAfterNewCodec = 5e3;
  class LocalVideoTrack extends LocalTrack {
    get sender() {
      return this._sender;
    }
    set sender(sender) {
      this._sender = sender;
      if (this.degradationPreference) {
        this.setDegradationPreference(this.degradationPreference);
      }
    }
    /**
     *
     * @param mediaTrack
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, constraints) {
      let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      let loggerOptions = arguments.length > 3 ? arguments[3] : void 0;
      super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);
      this.simulcastCodecs = /* @__PURE__ */ new Map();
      this.degradationPreference = "balanced";
      this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          this._currentBitrate = 0;
          return;
        }
        let stats;
        try {
          stats = yield this.getSenderStats();
        } catch (e2) {
          this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
            error: e2
          }));
          return;
        }
        const statsMap = new Map(stats.map((s2) => [s2.rid, s2]));
        if (this.prevStats) {
          let totalBitrate = 0;
          statsMap.forEach((s2, key) => {
            var _a;
            const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);
            totalBitrate += computeBitrate(s2, prev);
          });
          this._currentBitrate = totalBitrate;
        }
        this.prevStats = statsMap;
      });
      this.senderLock = new _$1();
    }
    get isSimulcast() {
      if (this.sender && this.sender.getParameters().encodings.length > 1) {
        return true;
      }
      return false;
    }
    /* @internal */
    startMonitor(signalClient) {
      var _a;
      this.signalClient = signalClient;
      if (!isWeb()) {
        return;
      }
      const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();
      if (params) {
        this.encodings = params.encodings;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(() => {
        this.monitorSender();
      }, monitorFrequency);
    }
    stop() {
      this._mediaStreamTrack.getConstraints();
      this.simulcastCodecs.forEach((trackInfo) => {
        trackInfo.mediaStreamTrack.stop();
      });
      super.stop();
    }
    pauseUpstream() {
      const _super = Object.create(null, {
        pauseUpstream: {
          get: () => super.pauseUpstream
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        var _d;
        yield _super.pauseUpstream.call(this);
        try {
          for (var _e2 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e2 = true) {
            _c = _g.value;
            _e2 = false;
            const sc = _c;
            yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (!_e2 && !_a && (_b = _f.return))
              yield _b.call(_f);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    resumeUpstream() {
      const _super = Object.create(null, {
        resumeUpstream: {
          get: () => super.resumeUpstream
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_2, _b, _c;
        var _d;
        yield _super.resumeUpstream.call(this);
        try {
          for (var _e2 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e2 = true) {
            _c = _g.value;
            _e2 = false;
            const sc = _c;
            yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (!_e2 && !_a && (_b = _f.return))
              yield _b.call(_f);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    mute() {
      const _super = Object.create(null, {
        mute: {
          get: () => super.mute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (this.isMuted) {
            this.log.debug("Track already muted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Camera && !this.isUserProvided) {
            this.log.debug("stopping camera track", this.logContext);
            this._mediaStreamTrack.stop();
          }
          yield _super.mute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    unmute() {
      const _super = Object.create(null, {
        unmute: {
          get: () => super.unmute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (!this.isMuted) {
            this.log.debug("Track already unmuted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Camera && !this.isUserProvided) {
            this.log.debug("reacquiring camera track", this.logContext);
            yield this.restartTrack();
          }
          yield _super.unmute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    setTrackMuted(muted) {
      super.setTrackMuted(muted);
      for (const sc of this.simulcastCodecs.values()) {
        sc.mediaStreamTrack.enabled = !muted;
      }
    }
    getSenderStats() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return [];
        }
        const items = [];
        const stats = yield this.sender.getStats();
        stats.forEach((v2) => {
          var _a2;
          if (v2.type === "outbound-rtp") {
            const vs2 = {
              type: "video",
              streamId: v2.id,
              frameHeight: v2.frameHeight,
              frameWidth: v2.frameWidth,
              framesPerSecond: v2.framesPerSecond,
              framesSent: v2.framesSent,
              firCount: v2.firCount,
              pliCount: v2.pliCount,
              nackCount: v2.nackCount,
              packetsSent: v2.packetsSent,
              bytesSent: v2.bytesSent,
              qualityLimitationReason: v2.qualityLimitationReason,
              qualityLimitationDurations: v2.qualityLimitationDurations,
              qualityLimitationResolutionChanges: v2.qualityLimitationResolutionChanges,
              rid: (_a2 = v2.rid) !== null && _a2 !== void 0 ? _a2 : v2.id,
              retransmittedPacketsSent: v2.retransmittedPacketsSent,
              targetBitrate: v2.targetBitrate,
              timestamp: v2.timestamp
            };
            const r2 = stats.get(v2.remoteId);
            if (r2) {
              vs2.jitter = r2.jitter;
              vs2.packetsLost = r2.packetsLost;
              vs2.roundTripTime = r2.roundTripTime;
            }
            items.push(vs2);
          }
        });
        items.sort((a2, b2) => {
          var _a2, _b;
          return ((_a2 = b2.frameWidth) !== null && _a2 !== void 0 ? _a2 : 0) - ((_b = a2.frameWidth) !== null && _b !== void 0 ? _b : 0);
        });
        return items;
      });
    }
    setPublishingQuality(maxQuality) {
      const qualities = [];
      for (let q2 = VideoQuality.LOW; q2 <= VideoQuality.HIGH; q2 += 1) {
        qualities.push(new SubscribedQuality({
          quality: q2,
          enabled: q2 <= maxQuality
        }));
      }
      this.log.debug("setting publishing quality. max quality ".concat(maxQuality), this.logContext);
      this.setPublishingLayers(qualities);
    }
    restartTrack(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_3, _b, _c;
        var _d;
        let constraints;
        if (options) {
          const streamConstraints = constraintsForOptions({
            video: options
          });
          if (typeof streamConstraints.video !== "boolean") {
            constraints = streamConstraints.video;
          }
        }
        yield this.restart(constraints);
        try {
          for (var _e2 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e2 = true) {
            _c = _g.value;
            _e2 = false;
            const sc = _c;
            if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== "closed") {
              sc.mediaStreamTrack = this.mediaStreamTrack.clone();
              yield sc.sender.replaceTrack(sc.mediaStreamTrack);
            }
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (!_e2 && !_a && (_b = _f.return))
              yield _b.call(_f);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      });
    }
    setProcessor(processor_1) {
      const _super = Object.create(null, {
        setProcessor: {
          get: () => super.setProcessor
        }
      });
      return __awaiter(this, arguments, void 0, function(processor) {
        var _this = this;
        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a, e_4, _b, _c;
          var _d, _e2;
          yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);
          if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {
            try {
              for (var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true) {
                _c = _h.value;
                _f = false;
                const sc = _c;
                yield (_e2 = sc.sender) === null || _e2 === void 0 ? void 0 : _e2.replaceTrack(_this.processor.processedTrack);
              }
            } catch (e_4_1) {
              e_4 = {
                error: e_4_1
              };
            } finally {
              try {
                if (!_f && !_a && (_b = _g.return))
                  yield _b.call(_g);
              } finally {
                if (e_4)
                  throw e_4.error;
              }
            }
          }
        }();
      });
    }
    setDegradationPreference(preference) {
      return __awaiter(this, void 0, void 0, function* () {
        this.degradationPreference = preference;
        if (this.sender) {
          try {
            this.log.debug("setting degradationPreference to ".concat(preference), this.logContext);
            const params = this.sender.getParameters();
            params.degradationPreference = preference;
            this.sender.setParameters(params);
          } catch (e2) {
            this.log.warn("failed to set degradationPreference", Object.assign({
              error: e2
            }, this.logContext));
          }
        }
      });
    }
    addSimulcastTrack(codec, encodings) {
      if (this.simulcastCodecs.has(codec)) {
        this.log.error("".concat(codec, " already added, skipping adding simulcast codec"), this.logContext);
        return;
      }
      const simulcastCodecInfo = {
        codec,
        mediaStreamTrack: this.mediaStreamTrack.clone(),
        sender: void 0,
        encodings
      };
      this.simulcastCodecs.set(codec, simulcastCodecInfo);
      return simulcastCodecInfo;
    }
    setSimulcastTrackSender(codec, sender) {
      const simulcastCodecInfo = this.simulcastCodecs.get(codec);
      if (!simulcastCodecInfo) {
        return;
      }
      simulcastCodecInfo.sender = sender;
      setTimeout(() => {
        if (this.subscribedCodecs) {
          this.setPublishingCodecs(this.subscribedCodecs);
        }
      }, refreshSubscribedCodecAfterNewCodec);
    }
    /**
     * @internal
     * Sets codecs that should be publishing, returns new codecs that have not yet
     * been published
     */
    setPublishingCodecs(codecs) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, codecs_1, codecs_1_1;
        var _b, e_5, _c, _d;
        this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
          codecs,
          currentCodec: this.codec
        }));
        if (!this.codec && codecs.length > 0) {
          yield this.setPublishingLayers(codecs[0].qualities);
          return [];
        }
        this.subscribedCodecs = codecs;
        const newCodecs = [];
        try {
          for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true) {
            _d = codecs_1_1.value;
            _a = false;
            const codec = _d;
            if (!this.codec || this.codec === codec.codec) {
              yield this.setPublishingLayers(codec.qualities);
            } else {
              const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);
              this.log.debug("try setPublishingCodec for ".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {
                simulcastCodecInfo
              }));
              if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {
                for (const q2 of codec.qualities) {
                  if (q2.enabled) {
                    newCodecs.push(codec.codec);
                    break;
                  }
                }
              } else if (simulcastCodecInfo.encodings) {
                this.log.debug("try setPublishingLayersForSender ".concat(codec.codec), this.logContext);
                yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);
              }
            }
          }
        } catch (e_5_1) {
          e_5 = {
            error: e_5_1
          };
        } finally {
          try {
            if (!_a && !_b && (_c = codecs_1.return))
              yield _c.call(codecs_1);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
        return newCodecs;
      });
    }
    /**
     * @internal
     * Sets layers that should be publishing
     */
    setPublishingLayers(qualities) {
      return __awaiter(this, void 0, void 0, function* () {
        this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
          qualities
        }));
        if (!this.sender || !this.encodings) {
          return;
        }
        yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);
      });
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!isMobile())
          return;
        if (this.isInBackground && this.source === Track.Source.Camera) {
          this._mediaStreamTrack.enabled = false;
        }
      });
    }
  }
  function setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log2, logContext) {
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield senderLock.lock();
      log2.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, logContext), {
        sender,
        qualities,
        senderEncodings
      }));
      try {
        const params = sender.getParameters();
        const {
          encodings
        } = params;
        if (!encodings) {
          return;
        }
        if (encodings.length !== senderEncodings.length) {
          log2.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, logContext), {
            encodings,
            senderEncodings
          }));
          return;
        }
        let hasChanged = false;
        const closableSpatial = false;
        if (closableSpatial && encodings[0].scalabilityMode)
          ;
        else {
          encodings.forEach((encoding, idx) => {
            var _a;
            let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : "";
            if (rid === "") {
              rid = "q";
            }
            const quality = videoQualityForRid(rid);
            const subscribedQuality = qualities.find((q2) => q2.quality === quality);
            if (!subscribedQuality) {
              return;
            }
            if (encoding.active !== subscribedQuality.enabled) {
              hasChanged = true;
              encoding.active = subscribedQuality.enabled;
              log2.debug("setting layer ".concat(subscribedQuality.quality, " to ").concat(encoding.active ? "enabled" : "disabled"), logContext);
              if (isFireFox()) {
                if (subscribedQuality.enabled) {
                  encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;
                  encoding.maxBitrate = senderEncodings[idx].maxBitrate;
                  encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;
                } else {
                  encoding.scaleResolutionDownBy = 4;
                  encoding.maxBitrate = 10;
                  encoding.maxFrameRate = 2;
                }
              }
            }
          });
        }
        if (hasChanged) {
          params.encodings = encodings;
          log2.debug("setting encodings", Object.assign(Object.assign({}, logContext), {
            encodings: params.encodings
          }));
          yield sender.setParameters(params);
        }
      } finally {
        unlock();
      }
    });
  }
  function videoQualityForRid(rid) {
    switch (rid) {
      case "f":
        return VideoQuality.HIGH;
      case "h":
        return VideoQuality.MEDIUM;
      case "q":
        return VideoQuality.LOW;
      default:
        return VideoQuality.HIGH;
    }
  }
  function videoLayersFromEncodings(width, height, encodings, svc) {
    if (!encodings) {
      return [new VideoLayer({
        quality: VideoQuality.HIGH,
        width,
        height,
        bitrate: 0,
        ssrc: 0
      })];
    }
    if (svc) {
      const encodingSM = encodings[0].scalabilityMode;
      const sm = new ScalabilityMode(encodingSM);
      const layers = [];
      const resRatio = sm.suffix == "h" ? 1.5 : 2;
      const bitratesRatio = sm.suffix == "h" ? 2 : 3;
      for (let i2 = 0; i2 < sm.spatial; i2 += 1) {
        layers.push(new VideoLayer({
          quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i2,
          width: Math.ceil(width / Math.pow(resRatio, i2)),
          height: Math.ceil(height / Math.pow(resRatio, i2)),
          bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i2)) : 0,
          ssrc: 0
        }));
      }
      return layers;
    }
    return encodings.map((encoding) => {
      var _a, _b, _c;
      const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;
      let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : "");
      return new VideoLayer({
        quality,
        width: Math.ceil(width / scale),
        height: Math.ceil(height / scale),
        bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,
        ssrc: 0
      });
    });
  }
  const lossyDataChannel = "_lossy";
  const reliableDataChannel = "_reliable";
  const minReconnectWait = 2 * 1e3;
  const leaveReconnect = "leave-reconnect";
  var PCState;
  (function(PCState2) {
    PCState2[PCState2["New"] = 0] = "New";
    PCState2[PCState2["Connected"] = 1] = "Connected";
    PCState2[PCState2["Disconnected"] = 2] = "Disconnected";
    PCState2[PCState2["Reconnecting"] = 3] = "Reconnecting";
    PCState2[PCState2["Closed"] = 4] = "Closed";
  })(PCState || (PCState = {}));
  class RTCEngine extends eventsExports.EventEmitter {
    get isClosed() {
      return this._isClosed;
    }
    get pendingReconnect() {
      return !!this.reconnectTimeout;
    }
    constructor(options) {
      var _a;
      super();
      this.options = options;
      this.rtcConfig = {};
      this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
      this.fullReconnectOnNext = false;
      this.subscriberPrimary = false;
      this.pcState = PCState.New;
      this._isClosed = true;
      this.pendingTrackResolvers = {};
      this.reconnectAttempts = 0;
      this.reconnectStart = 0;
      this.attemptingReconnect = false;
      this.joinAttempts = 0;
      this.maxJoinAttempts = 1;
      this.shouldFailNext = false;
      this.log = livekitLogger;
      this.handleDataChannel = (_a2) => __awaiter(this, [_a2], void 0, function(_ref) {
        var _this = this;
        let {
          channel
        } = _ref;
        return function* () {
          if (!channel) {
            return;
          }
          if (channel.label === reliableDataChannel) {
            _this.reliableDCSub = channel;
          } else if (channel.label === lossyDataChannel) {
            _this.lossyDCSub = channel;
          } else {
            return;
          }
          _this.log.debug("on data channel ".concat(channel.id, ", ").concat(channel.label), _this.logContext);
          channel.onmessage = _this.handleDataMessage;
        }();
      });
      this.handleDataMessage = (message) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b;
        const unlock = yield this.dataProcessLock.lock();
        try {
          let buffer;
          if (message.data instanceof ArrayBuffer) {
            buffer = message.data;
          } else if (message.data instanceof Blob) {
            buffer = yield message.data.arrayBuffer();
          } else {
            this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
              data: message.data
            }));
            return;
          }
          const dp = DataPacket.fromBinary(new Uint8Array(buffer));
          if (((_a2 = dp.value) === null || _a2 === void 0 ? void 0 : _a2.case) === "speaker") {
            this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);
          } else {
            if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === "user") {
              applyUserDataCompat(dp, dp.value.value);
            }
            this.emit(EngineEvent.DataPacketReceived, dp);
          }
        } finally {
          unlock();
        }
      });
      this.handleDataError = (event) => {
        const channel = event.currentTarget;
        const channelKind = channel.maxRetransmits === 0 ? "lossy" : "reliable";
        if (event instanceof ErrorEvent && event.error) {
          const {
            error
          } = event.error;
          this.log.error("DataChannel error on ".concat(channelKind, ": ").concat(event.message), Object.assign(Object.assign({}, this.logContext), {
            error
          }));
        } else {
          this.log.error("Unknown DataChannel error on ".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {
            event
          }));
        }
      };
      this.handleBufferedAmountLow = (event) => {
        const channel = event.currentTarget;
        const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
        this.updateAndEmitDCBufferStatus(channelKind);
      };
      this.handleDisconnect = (connection, disconnectReason) => {
        if (this._isClosed) {
          return;
        }
        this.log.warn("".concat(connection, " disconnected"), this.logContext);
        if (this.reconnectAttempts === 0) {
          this.reconnectStart = Date.now();
        }
        const disconnect = (duration2) => {
          this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(duration2, "ms. giving up"), this.logContext);
          this.emit(EngineEvent.Disconnected);
          this.close();
        };
        const duration = Date.now() - this.reconnectStart;
        let delay = this.getNextRetryDelay({
          elapsedMs: duration,
          retryCount: this.reconnectAttempts
        });
        if (delay === null) {
          disconnect(duration);
          return;
        }
        if (connection === leaveReconnect) {
          delay = 0;
        }
        this.log.debug("reconnecting in ".concat(delay, "ms"), this.logContext);
        this.clearReconnectTimeout();
        if (this.token && this.regionUrlProvider) {
          this.regionUrlProvider.updateToken(this.token);
        }
        this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason).finally(() => this.reconnectTimeout = void 0), delay);
      };
      this.waitForRestarted = () => {
        return new Promise((resolve, reject) => {
          if (this.pcState === PCState.Connected) {
            resolve();
          }
          const onRestarted = () => {
            this.off(EngineEvent.Disconnected, onDisconnected);
            resolve();
          };
          const onDisconnected = () => {
            this.off(EngineEvent.Restarted, onRestarted);
            reject();
          };
          this.once(EngineEvent.Restarted, onRestarted);
          this.once(EngineEvent.Disconnected, onDisconnected);
        });
      };
      this.updateAndEmitDCBufferStatus = (kind) => {
        const status = this.isBufferStatusLow(kind);
        if (typeof status !== "undefined" && status !== this.dcBufferStatus.get(kind)) {
          this.dcBufferStatus.set(kind, status);
          this.emit(EngineEvent.DCBufferStatusChanged, status, kind);
        }
      };
      this.isBufferStatusLow = (kind) => {
        const dc = this.dataChannelForKind(kind);
        if (dc) {
          return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;
        }
      };
      this.handleBrowserOnLine = () => {
        if (this.client.currentState === SignalConnectionState.RECONNECTING) {
          this.clearReconnectTimeout();
          this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);
        }
      };
      this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);
      this.loggerOptions = {
        loggerName: options.loggerName,
        loggerContextCb: () => this.logContext
      };
      this.client = new SignalClient(void 0, this.loggerOptions);
      this.client.signalLatency = this.options.expSignalLatency;
      this.reconnectPolicy = this.options.reconnectPolicy;
      this.registerOnLineListener();
      this.closingLock = new _$1();
      this.dataProcessLock = new _$1();
      this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);
      this.client.onParticipantUpdate = (updates) => this.emit(EngineEvent.ParticipantUpdate, updates);
      this.client.onConnectionQuality = (update) => this.emit(EngineEvent.ConnectionQualityUpdate, update);
      this.client.onRoomUpdate = (update) => this.emit(EngineEvent.RoomUpdate, update);
      this.client.onSubscriptionError = (resp) => this.emit(EngineEvent.SubscriptionError, resp);
      this.client.onSubscriptionPermissionUpdate = (update) => this.emit(EngineEvent.SubscriptionPermissionUpdate, update);
      this.client.onSpeakersChanged = (update) => this.emit(EngineEvent.SpeakersChanged, update);
      this.client.onStreamStateUpdate = (update) => this.emit(EngineEvent.StreamStateChanged, update);
      this.client.onRequestResponse = (response) => this.emit(EngineEvent.SignalRequestResponse, response);
    }
    /** @internal */
    get logContext() {
      var _a, _b, _c, _d, _e2, _f, _g, _h;
      return {
        room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,
        roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,
        participant: (_f = (_e2 = this.latestJoinResponse) === null || _e2 === void 0 ? void 0 : _e2.participant) === null || _f === void 0 ? void 0 : _f.identity,
        pID: (_h = (_g = this.latestJoinResponse) === null || _g === void 0 ? void 0 : _g.participant) === null || _h === void 0 ? void 0 : _h.sid
      };
    }
    join(url, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        this.url = url;
        this.token = token;
        this.signalOpts = opts;
        this.maxJoinAttempts = opts.maxRetries;
        try {
          this.joinAttempts += 1;
          this.setupSignalClientCallbacks();
          const joinResponse = yield this.client.join(url, token, opts, abortSignal);
          this._isClosed = false;
          this.latestJoinResponse = joinResponse;
          this.subscriberPrimary = joinResponse.subscriberPrimary;
          if (!this.pcManager) {
            yield this.configure(joinResponse);
          }
          if (!this.subscriberPrimary || joinResponse.fastPublish) {
            this.negotiate();
          }
          this.clientConfiguration = joinResponse.clientConfiguration;
          return joinResponse;
        } catch (e2) {
          if (e2 instanceof ConnectionError) {
            if (e2.reason === ConnectionErrorReason.ServerUnreachable) {
              this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext);
              if (this.joinAttempts < this.maxJoinAttempts) {
                return this.join(url, token, opts, abortSignal);
              }
            }
          }
          throw e2;
        }
      });
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.closingLock.lock();
        if (this.isClosed) {
          unlock();
          return;
        }
        try {
          this._isClosed = true;
          this.joinAttempts = 0;
          this.emit(EngineEvent.Closing);
          this.removeAllListeners();
          this.deregisterOnLineListener();
          this.clearPendingReconnect();
          yield this.cleanupPeerConnections();
          yield this.cleanupClient();
        } finally {
          unlock();
        }
      });
    }
    cleanupPeerConnections() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();
        this.pcManager = void 0;
        const dcCleanup = (dc) => {
          if (!dc)
            return;
          dc.close();
          dc.onbufferedamountlow = null;
          dc.onclose = null;
          dc.onclosing = null;
          dc.onerror = null;
          dc.onmessage = null;
          dc.onopen = null;
        };
        dcCleanup(this.lossyDC);
        dcCleanup(this.lossyDCSub);
        dcCleanup(this.reliableDC);
        dcCleanup(this.reliableDCSub);
        this.lossyDC = void 0;
        this.lossyDCSub = void 0;
        this.reliableDC = void 0;
        this.reliableDCSub = void 0;
      });
    }
    cleanupClient() {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.client.close();
        this.client.resetCallbacks();
      });
    }
    addTrack(req) {
      if (this.pendingTrackResolvers[req.cid]) {
        throw new TrackInvalidError("a track with the same ID has already been published");
      }
      return new Promise((resolve, reject) => {
        const publicationTimeout = setTimeout(() => {
          delete this.pendingTrackResolvers[req.cid];
          reject(new ConnectionError("publication of local track timed out, no response from server", ConnectionErrorReason.InternalError));
        }, 1e4);
        this.pendingTrackResolvers[req.cid] = {
          resolve: (info) => {
            clearTimeout(publicationTimeout);
            resolve(info);
          },
          reject: () => {
            clearTimeout(publicationTimeout);
            reject(new Error("Cancelled publication by calling unpublish"));
          }
        };
        this.client.sendAddTrack(req);
      });
    }
    /**
     * Removes sender from PeerConnection, returning true if it was removed successfully
     * and a negotiation is necessary
     * @param sender
     * @returns
     */
    removeTrack(sender) {
      if (sender.track && this.pendingTrackResolvers[sender.track.id]) {
        const {
          reject
        } = this.pendingTrackResolvers[sender.track.id];
        if (reject) {
          reject();
        }
        delete this.pendingTrackResolvers[sender.track.id];
      }
      try {
        this.pcManager.removeTrack(sender);
        return true;
      } catch (e2) {
        this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
          error: e2
        }));
      }
      return false;
    }
    updateMuteStatus(trackSid, muted) {
      this.client.sendMuteTrack(trackSid, muted);
    }
    get dataSubscriberReadyState() {
      var _a;
      return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;
    }
    getConnectedServerAddress() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();
      });
    }
    /* @internal */
    setRegionUrlProvider(provider) {
      this.regionUrlProvider = provider;
    }
    configure(joinResponse) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {
          return;
        }
        this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;
        const rtcConfig = this.makeRTCConfiguration(joinResponse);
        this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);
        this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);
        this.pcManager.onIceCandidate = (candidate, target) => {
          this.client.sendIceCandidate(candidate, target);
        };
        this.pcManager.onPublisherOffer = (offer) => {
          this.client.sendOffer(offer);
        };
        this.pcManager.onDataChannel = this.handleDataChannel;
        this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) => __awaiter(this, void 0, void 0, function* () {
          this.log.debug("primary PC state changed ".concat(connectionState), this.logContext);
          if (["closed", "disconnected", "failed"].includes(publisherState)) {
            this.publisherConnectionPromise = void 0;
          }
          if (connectionState === PCTransportState.CONNECTED) {
            const shouldEmit = this.pcState === PCState.New;
            this.pcState = PCState.Connected;
            if (shouldEmit) {
              this.emit(EngineEvent.Connected, joinResponse);
            }
          } else if (connectionState === PCTransportState.FAILED) {
            if (this.pcState === PCState.Connected) {
              this.pcState = PCState.Disconnected;
              this.handleDisconnect("peerconnection failed", subscriberState === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);
            }
          }
          const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;
          const isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);
          if (isSignalSevered && isPCSevered && !this._isClosed) {
            this.emit(EngineEvent.Offline);
          }
        });
        this.pcManager.onTrack = (ev) => {
          this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
        };
        if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {
          this.createDataChannels();
        }
      });
    }
    setupSignalClientCallbacks() {
      this.client.onAnswer = (sd) => __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          return;
        }
        this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
          RTCSdpType: sd.type
        }));
        yield this.pcManager.setPublisherAnswer(sd);
      });
      this.client.onTrickle = (candidate, target) => {
        if (!this.pcManager) {
          return;
        }
        this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
          candidate,
          target
        }));
        this.pcManager.addIceCandidate(candidate, target);
      };
      this.client.onOffer = (sd) => __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          return;
        }
        const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);
        this.client.sendAnswer(answer);
      });
      this.client.onLocalTrackPublished = (res) => {
        var _a;
        this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
          cid: res.cid,
          track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid
        }));
        if (!this.pendingTrackResolvers[res.cid]) {
          this.log.error("missing track resolver for ".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {
            cid: res.cid
          }));
          return;
        }
        const {
          resolve
        } = this.pendingTrackResolvers[res.cid];
        delete this.pendingTrackResolvers[res.cid];
        resolve(res.track);
      };
      this.client.onLocalTrackUnpublished = (response) => {
        this.emit(EngineEvent.LocalTrackUnpublished, response);
      };
      this.client.onLocalTrackSubscribed = (trackSid) => {
        this.emit(EngineEvent.LocalTrackSubscribed, trackSid);
      };
      this.client.onTokenRefresh = (token) => {
        this.token = token;
      };
      this.client.onRemoteMuteChanged = (trackSid, muted) => {
        this.emit(EngineEvent.RemoteMute, trackSid, muted);
      };
      this.client.onSubscribedQualityUpdate = (update) => {
        this.emit(EngineEvent.SubscribedQualityUpdate, update);
      };
      this.client.onClose = () => {
        this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
      };
      this.client.onLeave = (leave) => {
        this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
          reason: leave === null || leave === void 0 ? void 0 : leave.reason
        }));
        if (leave.regions && this.regionUrlProvider) {
          this.log.debug("updating regions", this.logContext);
          this.regionUrlProvider.setServerReportedRegions(leave.regions);
        }
        switch (leave.action) {
          case LeaveRequest_Action.DISCONNECT:
            this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);
            this.close();
            break;
          case LeaveRequest_Action.RECONNECT:
            this.fullReconnectOnNext = true;
            this.handleDisconnect(leaveReconnect);
            break;
          case LeaveRequest_Action.RESUME:
            this.handleDisconnect(leaveReconnect);
        }
      };
    }
    makeRTCConfiguration(serverResponse) {
      var _a;
      const rtcConfig = Object.assign({}, this.rtcConfig);
      if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {
        this.log.debug("E2EE - setting up transports with insertable streams", this.logContext);
        rtcConfig.encodedInsertableStreams = true;
      }
      if (serverResponse.iceServers && !rtcConfig.iceServers) {
        const rtcIceServers = [];
        serverResponse.iceServers.forEach((iceServer) => {
          const rtcIceServer = {
            urls: iceServer.urls
          };
          if (iceServer.username)
            rtcIceServer.username = iceServer.username;
          if (iceServer.credential) {
            rtcIceServer.credential = iceServer.credential;
          }
          rtcIceServers.push(rtcIceServer);
        });
        rtcConfig.iceServers = rtcIceServers;
      }
      if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {
        rtcConfig.iceTransportPolicy = "relay";
      }
      rtcConfig.sdpSemantics = "unified-plan";
      rtcConfig.continualGatheringPolicy = "gather_continually";
      return rtcConfig;
    }
    createDataChannels() {
      if (!this.pcManager) {
        return;
      }
      if (this.lossyDC) {
        this.lossyDC.onmessage = null;
        this.lossyDC.onerror = null;
      }
      if (this.reliableDC) {
        this.reliableDC.onmessage = null;
        this.reliableDC.onerror = null;
      }
      this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
        // will drop older packets that arrive
        ordered: true,
        maxRetransmits: 0
      });
      this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
        ordered: true
      });
      this.lossyDC.onmessage = this.handleDataMessage;
      this.reliableDC.onmessage = this.handleDataMessage;
      this.lossyDC.onerror = this.handleDataError;
      this.reliableDC.onerror = this.handleDataError;
      this.lossyDC.bufferedAmountLowThreshold = 65535;
      this.reliableDC.bufferedAmountLowThreshold = 65535;
      this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;
      this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;
    }
    createSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (supportsTransceiver()) {
          const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);
          return sender;
        }
        if (supportsAddTrack()) {
          this.log.warn("using add-track fallback", this.logContext);
          const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);
          return sender;
        }
        throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
      });
    }
    createSimulcastSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (supportsTransceiver()) {
          return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);
        }
        if (supportsAddTrack()) {
          this.log.debug("using add-track fallback", this.logContext);
          return this.createRTCRtpSender(track.mediaStreamTrack);
        }
        throw new UnexpectedConnectionState("Cannot stream on this device");
      });
    }
    createTransceiverRTCRtpSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        const streams = [];
        if (track.mediaStream) {
          streams.push(track.mediaStream);
        }
        if (isVideoTrack(track)) {
          track.codec = opts.videoCodec;
        }
        const transceiverInit = {
          direction: "sendonly",
          streams
        };
        if (encodings) {
          transceiverInit.sendEncodings = encodings;
        }
        const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);
        return transceiver.sender;
      });
    }
    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        const transceiverInit = {
          direction: "sendonly"
        };
        if (encodings) {
          transceiverInit.sendEncodings = encodings;
        }
        const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);
        if (!opts.videoCodec) {
          return;
        }
        track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);
        return transceiver.sender;
      });
    }
    createRTCRtpSender(track) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        return this.pcManager.addPublisherTrack(track);
      });
    }
    attemptReconnect(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (this._isClosed) {
          return;
        }
        if (this.attemptingReconnect) {
          livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {
          this.fullReconnectOnNext = true;
        }
        try {
          this.attemptingReconnect = true;
          if (this.fullReconnectOnNext) {
            yield this.restartConnection();
          } else {
            yield this.resumeConnection(reason);
          }
          this.clearPendingReconnect();
          this.fullReconnectOnNext = false;
        } catch (e2) {
          this.reconnectAttempts += 1;
          let recoverable = true;
          if (e2 instanceof UnexpectedConnectionState) {
            this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
              error: e2
            }));
            recoverable = false;
          } else if (!(e2 instanceof SignalReconnectError)) {
            this.fullReconnectOnNext = true;
          }
          if (recoverable) {
            this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN);
          } else {
            this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext);
            this.emit(EngineEvent.Disconnected);
            yield this.close();
          }
        } finally {
          this.attemptingReconnect = false;
        }
      });
    }
    getNextRetryDelay(context) {
      try {
        return this.reconnectPolicy.nextRetryDelayInMs(context);
      } catch (e2) {
        this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
          error: e2
        }));
      }
      return null;
    }
    restartConnection(regionUrl) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        try {
          if (!this.url || !this.token) {
            throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
          }
          this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext);
          this.emit(EngineEvent.Restarting);
          if (!this.client.isDisconnected) {
            yield this.client.sendLeave();
          }
          yield this.cleanupPeerConnections();
          yield this.cleanupClient();
          let joinResponse;
          try {
            if (!this.signalOpts) {
              this.log.warn("attempted connection restart, without signal options present", this.logContext);
              throw new SignalReconnectError();
            }
            joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);
          } catch (e2) {
            if (e2 instanceof ConnectionError && e2.reason === ConnectionErrorReason.NotAllowed) {
              throw new UnexpectedConnectionState("could not reconnect, token might be expired");
            }
            throw new SignalReconnectError();
          }
          if (this.shouldFailNext) {
            this.shouldFailNext = false;
            throw new Error("simulated failure");
          }
          this.client.setReconnected();
          this.emit(EngineEvent.SignalRestarted, joinResponse);
          yield this.waitForPCReconnected();
          if (this.client.currentState !== SignalConnectionState.CONNECTED) {
            throw new SignalReconnectError("Signal connection got severed during reconnect");
          }
          (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();
          this.emit(EngineEvent.Restarted);
        } catch (error) {
          const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();
          if (nextRegionUrl) {
            yield this.restartConnection(nextRegionUrl);
            return;
          } else {
            (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();
            throw error;
          }
        }
      });
    }
    resumeConnection(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!this.url || !this.token) {
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        }
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher and subscriber connections unset");
        }
        this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext);
        this.emit(EngineEvent.Resuming);
        let res;
        try {
          this.setupSignalClientCallbacks();
          res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);
        } catch (error) {
          let message = "";
          if (error instanceof Error) {
            message = error.message;
            this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {
              error
            }));
          }
          if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {
            throw new UnexpectedConnectionState("could not reconnect, token might be expired");
          }
          if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {
            throw error;
          }
          throw new SignalReconnectError(message);
        }
        this.emit(EngineEvent.SignalResumed);
        if (res) {
          const rtcConfig = this.makeRTCConfiguration(res);
          this.pcManager.updateConfiguration(rtcConfig);
        } else {
          this.log.warn("Did not receive reconnect response", this.logContext);
        }
        if (this.shouldFailNext) {
          this.shouldFailNext = false;
          throw new Error("simulated failure");
        }
        yield this.pcManager.triggerIceRestart();
        yield this.waitForPCReconnected();
        if (this.client.currentState !== SignalConnectionState.CONNECTED) {
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        }
        this.client.setReconnected();
        if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === "open" && this.reliableDC.id === null) {
          this.createDataChannels();
        }
        this.emit(EngineEvent.Resumed);
      });
    }
    waitForPCInitialConnection(timeout2, abortController) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("PC manager is closed");
        }
        yield this.pcManager.ensurePCTransportConnection(abortController, timeout2);
      });
    }
    waitForPCReconnected() {
      return __awaiter(this, void 0, void 0, function* () {
        this.pcState = PCState.Reconnecting;
        this.log.debug("waiting for peer connection to reconnect", this.logContext);
        try {
          yield sleep(minReconnectWait);
          if (!this.pcManager) {
            throw new UnexpectedConnectionState("PC manager is closed");
          }
          yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout);
          this.pcState = PCState.Connected;
        } catch (e2) {
          this.pcState = PCState.Disconnected;
          throw new ConnectionError("could not establish PC connection, ".concat(e2.message), ConnectionErrorReason.InternalError);
        }
      });
    }
    /** @internal */
    publishRpcResponse(destinationIdentity, requestId, payload, error) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcResponse",
            value: new RpcResponse({
              requestId,
              value: error ? {
                case: "error",
                value: error.toProto()
              } : {
                case: "payload",
                value: payload !== null && payload !== void 0 ? payload : ""
              }
            })
          }
        });
        yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    publishRpcAck(destinationIdentity, requestId) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcAck",
            value: new RpcAck({
              requestId
            })
          }
        });
        yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /* @internal */
    sendDataPacket(packet, kind) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = packet.toBinary();
        yield this.ensurePublisherConnected(kind);
        const dc = this.dataChannelForKind(kind);
        if (dc) {
          dc.send(msg);
        }
        this.updateAndEmitDCBufferStatus(kind);
      });
    }
    waitForBufferStatusLow(kind) {
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        if (this.isBufferStatusLow(kind)) {
          resolve();
        } else {
          const onClosing = () => reject("Engine closed");
          this.once(EngineEvent.Closing, onClosing);
          while (!this.dcBufferStatus.get(kind)) {
            yield sleep(10);
          }
          this.off(EngineEvent.Closing, onClosing);
          resolve();
        }
      }));
    }
    /**
     * @internal
     */
    ensureDataTransportConnected(kind_1) {
      return __awaiter(this, arguments, void 0, function(kind) {
        var _this2 = this;
        let subscriber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
        return function* () {
          var _a;
          if (!_this2.pcManager) {
            throw new UnexpectedConnectionState("PC manager is closed");
          }
          const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;
          const transportName = subscriber ? "Subscriber" : "Publisher";
          if (!transport) {
            throw new ConnectionError("".concat(transportName, " connection not set"), ConnectionErrorReason.InternalError);
          }
          let needNegotiation = false;
          if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {
            _this2.createDataChannels();
            needNegotiation = true;
          }
          if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== "checking") {
            needNegotiation = true;
          }
          if (needNegotiation) {
            _this2.negotiate();
          }
          const targetChannel = _this2.dataChannelForKind(kind, subscriber);
          if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === "open") {
            return;
          }
          const endTime = (/* @__PURE__ */ new Date()).getTime() + _this2.peerConnectionTimeout;
          while ((/* @__PURE__ */ new Date()).getTime() < endTime) {
            if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === "open") {
              return;
            }
            yield sleep(50);
          }
          throw new ConnectionError("could not establish ".concat(transportName, " connection, state: ").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);
        }();
      });
    }
    ensurePublisherConnected(kind) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.publisherConnectionPromise) {
          this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);
        }
        yield this.publisherConnectionPromise;
      });
    }
    /* @internal */
    verifyTransport() {
      if (!this.pcManager) {
        return false;
      }
      if (this.pcManager.currentState !== PCTransportState.CONNECTED) {
        return false;
      }
      if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {
        return false;
      }
      return true;
    }
    /** @internal */
    negotiate() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          if (!this.pcManager) {
            reject(new NegotiationError("PC manager is closed"));
            return;
          }
          this.pcManager.requirePublisher();
          if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {
            this.createDataChannels();
          }
          const abortController = new AbortController();
          const handleClosed = () => {
            abortController.abort();
            this.log.debug("engine disconnected while negotiation was ongoing", this.logContext);
            resolve();
            return;
          };
          if (this.isClosed) {
            reject("cannot negotiate on closed engine");
          }
          this.on(EngineEvent.Closing, handleClosed);
          this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes) => {
            const rtpMap = /* @__PURE__ */ new Map();
            rtpTypes.forEach((rtp) => {
              const codec = rtp.codec.toLowerCase();
              if (isVideoCodec(codec)) {
                rtpMap.set(rtp.payload, codec);
              }
            });
            this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);
          });
          try {
            yield this.pcManager.negotiate(abortController);
            resolve();
          } catch (e2) {
            if (e2 instanceof NegotiationError) {
              this.fullReconnectOnNext = true;
            }
            this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN);
            reject(e2);
          } finally {
            this.off(EngineEvent.Closing, handleClosed);
          }
        }));
      });
    }
    dataChannelForKind(kind, sub) {
      if (!sub) {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDC;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDC;
        }
      } else {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDCSub;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDCSub;
        }
      }
    }
    /** @internal */
    sendSyncState(remoteTracks, localTracks) {
      var _a, _b;
      if (!this.pcManager) {
        this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
        return;
      }
      const previousAnswer = this.pcManager.subscriber.getLocalDescription();
      const previousOffer = this.pcManager.subscriber.getRemoteDescription();
      const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;
      const trackSids = new Array();
      const trackSidsDisabled = new Array();
      remoteTracks.forEach((track) => {
        if (track.isDesired !== autoSubscribe) {
          trackSids.push(track.trackSid);
        }
        if (!track.isEnabled) {
          trackSidsDisabled.push(track.trackSid);
        }
      });
      this.client.sendSyncState(new SyncState({
        answer: previousAnswer ? toProtoSessionDescription({
          sdp: previousAnswer.sdp,
          type: previousAnswer.type
        }) : void 0,
        offer: previousOffer ? toProtoSessionDescription({
          sdp: previousOffer.sdp,
          type: previousOffer.type
        }) : void 0,
        subscription: new UpdateSubscription({
          trackSids,
          subscribe: !autoSubscribe,
          participantTracks: []
        }),
        publishTracks: getTrackPublicationInfo(localTracks),
        dataChannels: this.dataChannelsInfo(),
        trackSidsDisabled
      }));
    }
    /* @internal */
    failNext() {
      this.shouldFailNext = true;
    }
    dataChannelsInfo() {
      const infos = [];
      const getInfo = (dc, target) => {
        if ((dc === null || dc === void 0 ? void 0 : dc.id) !== void 0 && dc.id !== null) {
          infos.push(new DataChannelInfo({
            label: dc.label,
            id: dc.id,
            target
          }));
        }
      };
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);
      return infos;
    }
    clearReconnectTimeout() {
      if (this.reconnectTimeout) {
        CriticalTimers.clearTimeout(this.reconnectTimeout);
      }
    }
    clearPendingReconnect() {
      this.clearReconnectTimeout();
      this.reconnectAttempts = 0;
    }
    registerOnLineListener() {
      if (isWeb()) {
        window.addEventListener("online", this.handleBrowserOnLine);
      }
    }
    deregisterOnLineListener() {
      if (isWeb()) {
        window.removeEventListener("online", this.handleBrowserOnLine);
      }
    }
  }
  class SignalReconnectError extends Error {
  }
  function supportOptionalDatachannel(protocol) {
    return protocol !== void 0 && protocol > 13;
  }
  function applyUserDataCompat(newObj, oldObj) {
    const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;
    newObj.participantIdentity = participantIdentity;
    oldObj.participantIdentity = participantIdentity;
    const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;
    newObj.destinationIdentities = destinationIdentities;
    oldObj.destinationIdentities = destinationIdentities;
  }
  class RegionUrlProvider {
    constructor(url, token) {
      this.lastUpdateAt = 0;
      this.settingsCacheTime = 3e3;
      this.attemptedRegions = [];
      this.serverUrl = new URL(url);
      this.token = token;
    }
    updateToken(token) {
      this.token = token;
    }
    isCloud() {
      return isCloud(this.serverUrl);
    }
    getServerUrl() {
      return this.serverUrl;
    }
    getNextBestRegionUrl(abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.isCloud()) {
          throw Error("region availability is only supported for LiveKit Cloud domains");
        }
        if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {
          this.regionSettings = yield this.fetchRegionSettings(abortSignal);
        }
        const regionsLeft = this.regionSettings.regions.filter((region) => !this.attemptedRegions.find((attempted) => attempted.url === region.url));
        if (regionsLeft.length > 0) {
          const nextRegion = regionsLeft[0];
          this.attemptedRegions.push(nextRegion);
          livekitLogger.debug("next region: ".concat(nextRegion.region));
          return nextRegion.url;
        } else {
          return null;
        }
      });
    }
    resetAttempts() {
      this.attemptedRegions = [];
    }
    /* @internal */
    fetchRegionSettings(signal) {
      return __awaiter(this, void 0, void 0, function* () {
        const regionSettingsResponse = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
          headers: {
            authorization: "Bearer ".concat(this.token)
          },
          signal
        });
        if (regionSettingsResponse.ok) {
          const regionSettings = yield regionSettingsResponse.json();
          this.lastUpdateAt = Date.now();
          return regionSettings;
        } else {
          throw new ConnectionError("Could not fetch region settings: ".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);
        }
      });
    }
    setServerReportedRegions(regions) {
      this.regionSettings = regions;
      this.lastUpdateAt = Date.now();
    }
  }
  function getCloudConfigUrl(serverUrl) {
    return "".concat(serverUrl.protocol.replace("ws", "http"), "//").concat(serverUrl.host, "/settings");
  }
  class BaseStreamReader {
    get info() {
      return this._info;
    }
    constructor(info, stream, totalByteSize) {
      this.reader = stream;
      this.totalByteSize = totalByteSize;
      this._info = info;
      this.bytesReceived = 0;
    }
  }
  class ByteStreamReader extends BaseStreamReader {
    handleChunkReceived(chunk) {
      var _a;
      this.bytesReceived += chunk.content.byteLength;
      const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : void 0;
      (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);
    }
    [Symbol.asyncIterator]() {
      const reader = this.reader.getReader();
      return {
        next: () => __awaiter(this, void 0, void 0, function* () {
          try {
            const {
              done,
              value
            } = yield reader.read();
            if (done) {
              return {
                done: true,
                value: void 0
              };
            } else {
              this.handleChunkReceived(value);
              return {
                done: false,
                value: value.content
              };
            }
          } catch (error) {
            return {
              done: true,
              value: void 0
            };
          }
        }),
        return() {
          return __awaiter(this, void 0, void 0, function* () {
            reader.releaseLock();
            return {
              done: true,
              value: void 0
            };
          });
        }
      };
    }
    readAll() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        let chunks = /* @__PURE__ */ new Set();
        try {
          for (var _d = true, _e2 = __asyncValues(this), _f; _f = yield _e2.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const chunk = _c;
            chunks.add(chunk);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (!_d && !_a && (_b = _e2.return))
              yield _b.call(_e2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return Array.from(chunks);
      });
    }
  }
  class TextStreamReader extends BaseStreamReader {
    /**
     * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string
     * that has been received up to the current point in time.
     */
    constructor(info, stream, totalChunkCount) {
      super(info, stream, totalChunkCount);
      this.receivedChunks = /* @__PURE__ */ new Map();
    }
    handleChunkReceived(chunk) {
      var _a;
      const index = bigIntToNumber(chunk.chunkIndex);
      const previousChunkAtIndex = this.receivedChunks.get(index);
      if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {
        return;
      }
      this.receivedChunks.set(index, chunk);
      this.bytesReceived += chunk.content.byteLength;
      const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : void 0;
      (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);
    }
    /**
     * Async iterator implementation to allow usage of `for await...of` syntax.
     * Yields structured chunks from the stream.
     *
     */
    [Symbol.asyncIterator]() {
      const reader = this.reader.getReader();
      const decoder = new TextDecoder();
      return {
        next: () => __awaiter(this, void 0, void 0, function* () {
          try {
            const {
              done,
              value
            } = yield reader.read();
            if (done) {
              return {
                done: true,
                value: void 0
              };
            } else {
              this.handleChunkReceived(value);
              return {
                done: false,
                value: {
                  index: bigIntToNumber(value.chunkIndex),
                  current: decoder.decode(value.content),
                  collected: Array.from(this.receivedChunks.values()).sort((a2, b2) => bigIntToNumber(a2.chunkIndex) - bigIntToNumber(b2.chunkIndex)).map((chunk) => decoder.decode(chunk.content)).join("")
                }
              };
            }
          } catch (error) {
            return {
              done: true,
              value: void 0
            };
          }
        }),
        return() {
          return __awaiter(this, void 0, void 0, function* () {
            reader.releaseLock();
            return {
              done: true,
              value: void 0
            };
          });
        }
      };
    }
    readAll() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_2, _b, _c;
        let latestString = "";
        try {
          for (var _d = true, _e2 = __asyncValues(this), _f; _f = yield _e2.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const {
              collected
            } = _c;
            latestString = collected;
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (!_d && !_a && (_b = _e2.return))
              yield _b.call(_e2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        return latestString;
      });
    }
  }
  class BaseStreamWriter {
    constructor(writableStream, info, onClose) {
      this.writableStream = writableStream;
      this.defaultWriter = writableStream.getWriter();
      this.onClose = onClose;
      this.info = info;
    }
    write(chunk) {
      return this.defaultWriter.write([chunk]);
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield this.defaultWriter.close();
        this.defaultWriter.releaseLock();
        (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
  }
  class TextStreamWriter extends BaseStreamWriter {
  }
  class RemoteTrack extends Track {
    constructor(mediaTrack, sid, kind, receiver, loggerOptions) {
      super(mediaTrack, kind, loggerOptions);
      this.sid = sid;
      this.receiver = receiver;
    }
    get isLocal() {
      return false;
    }
    /** @internal */
    setMuted(muted) {
      if (this.isMuted !== muted) {
        this.isMuted = muted;
        this._mediaStreamTrack.enabled = !muted;
        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
      }
    }
    /** @internal */
    setMediaStream(stream) {
      this.mediaStream = stream;
      const onRemoveTrack = (event) => {
        if (event.track === this._mediaStreamTrack) {
          stream.removeEventListener("removetrack", onRemoveTrack);
          if (this.receiver && "playoutDelayHint" in this.receiver) {
            this.receiver.playoutDelayHint = void 0;
          }
          this.receiver = void 0;
          this._currentBitrate = 0;
          this.emit(TrackEvent.Ended, this);
        }
      };
      stream.addEventListener("removetrack", onRemoveTrack);
    }
    start() {
      this.startMonitor();
      super.enable();
    }
    stop() {
      this.stopMonitor();
      super.disable();
    }
    /**
     * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
    getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return;
        }
        const statsReport = yield this.receiver.getStats();
        return statsReport;
      });
    }
    /**
     * Allows to set a playout delay (in seconds) for this track.
     * A higher value allows for more buffering of the track in the browser
     * and will result in a delay of media being played back of `delayInSeconds`
     */
    setPlayoutDelay(delayInSeconds) {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver) {
          this.receiver.playoutDelayHint = delayInSeconds;
        } else {
          this.log.warn("Playout delay not supported in this browser");
        }
      } else {
        this.log.warn("Cannot set playout delay, track already ended");
      }
    }
    /**
     * Returns the current playout delay (in seconds) of this track.
     */
    getPlayoutDelay() {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver) {
          return this.receiver.playoutDelayHint;
        } else {
          this.log.warn("Playout delay not supported in this browser");
        }
      } else {
        this.log.warn("Cannot get playout delay, track already ended");
      }
      return 0;
    }
    /* @internal */
    startMonitor() {
      if (!this.monitorInterval) {
        this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);
      }
      if (supportsSynchronizationSources()) {
        this.registerTimeSyncUpdate();
      }
    }
    registerTimeSyncUpdate() {
      const loop = () => {
        var _a;
        this.timeSyncHandle = requestAnimationFrame(() => loop());
        const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];
        if (sources) {
          const {
            timestamp,
            rtpTimestamp
          } = sources;
          if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {
            this.emit(TrackEvent.TimeSyncUpdate, {
              timestamp,
              rtpTimestamp
            });
            this.rtpTimestamp = rtpTimestamp;
          }
        }
      };
      loop();
    }
  }
  class RemoteAudioTrack extends RemoteTrack {
    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {
      super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);
      this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver) {
          this._currentBitrate = 0;
          return;
        }
        const stats = yield this.getReceiverStats();
        if (stats && this.prevStats && this.receiver) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.audioContext = audioContext;
      this.webAudioPluginNodes = [];
      if (audioOutput) {
        this.sinkId = audioOutput.deviceId;
      }
    }
    /**
     * sets the volume for all attached audio elements
     */
    setVolume(volume) {
      var _a;
      for (const el of this.attachedElements) {
        if (this.audioContext) {
          (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);
        } else {
          el.volume = volume;
        }
      }
      if (isReactNative()) {
        this._mediaStreamTrack._setVolume(volume);
      }
      this.elementVolume = volume;
    }
    /**
     * gets the volume of attached audio elements (loudest)
     */
    getVolume() {
      if (this.elementVolume) {
        return this.elementVolume;
      }
      if (isReactNative()) {
        return 1;
      }
      let highestVolume = 0;
      this.attachedElements.forEach((element) => {
        if (element.volume > highestVolume) {
          highestVolume = element.volume;
        }
      });
      return highestVolume;
    }
    /**
     * calls setSinkId on all attached elements, if supported
     * @param deviceId audio output device
     */
    setSinkId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        this.sinkId = deviceId;
        yield Promise.all(this.attachedElements.map((elm) => {
          if (!supportsSetSinkId(elm)) {
            return;
          }
          return elm.setSinkId(deviceId);
        }));
      });
    }
    attach(element) {
      const needsNewWebAudioConnection = this.attachedElements.length === 0;
      if (!element) {
        element = super.attach();
      } else {
        super.attach(element);
      }
      if (this.sinkId && supportsSetSinkId(element)) {
        element.setSinkId(this.sinkId);
      }
      if (this.audioContext && needsNewWebAudioConnection) {
        this.log.debug("using audio context mapping", this.logContext);
        this.connectWebAudio(this.audioContext, element);
        element.volume = 0;
        element.muted = true;
      }
      if (this.elementVolume) {
        this.setVolume(this.elementVolume);
      }
      return element;
    }
    detach(element) {
      let detached;
      if (!element) {
        detached = super.detach();
        this.disconnectWebAudio();
      } else {
        detached = super.detach(element);
        if (this.audioContext) {
          if (this.attachedElements.length > 0) {
            this.connectWebAudio(this.audioContext, this.attachedElements[0]);
          } else {
            this.disconnectWebAudio();
          }
        }
      }
      return detached;
    }
    /**
     * @internal
     * @experimental
     */
    setAudioContext(audioContext) {
      this.audioContext = audioContext;
      if (audioContext && this.attachedElements.length > 0) {
        this.connectWebAudio(audioContext, this.attachedElements[0]);
      } else if (!audioContext) {
        this.disconnectWebAudio();
      }
    }
    /**
     * @internal
     * @experimental
     * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
     */
    setWebAudioPlugins(nodes) {
      this.webAudioPluginNodes = nodes;
      if (this.attachedElements.length > 0 && this.audioContext) {
        this.connectWebAudio(this.audioContext, this.attachedElements[0]);
      }
    }
    connectWebAudio(context, element) {
      this.disconnectWebAudio();
      this.sourceNode = context.createMediaStreamSource(element.srcObject);
      let lastNode = this.sourceNode;
      this.webAudioPluginNodes.forEach((node) => {
        lastNode.connect(node);
        lastNode = node;
      });
      this.gainNode = context.createGain();
      lastNode.connect(this.gainNode);
      this.gainNode.connect(context.destination);
      if (this.elementVolume) {
        this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);
      }
      if (context.state !== "running") {
        context.resume().then(() => {
          if (context.state !== "running") {
            this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
          }
        }).catch((e2) => {
          this.emit(TrackEvent.AudioPlaybackFailed, e2);
        });
      }
    }
    disconnectWebAudio() {
      var _a, _b;
      (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();
      (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();
      this.gainNode = void 0;
      this.sourceNode = void 0;
    }
    getReceiverStats() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) {
          return;
        }
        const stats = yield this.receiver.getStats();
        let receiverStats;
        stats.forEach((v2) => {
          if (v2.type === "inbound-rtp") {
            receiverStats = {
              type: "audio",
              streamId: v2.id,
              timestamp: v2.timestamp,
              jitter: v2.jitter,
              bytesReceived: v2.bytesReceived,
              concealedSamples: v2.concealedSamples,
              concealmentEvents: v2.concealmentEvents,
              silentConcealedSamples: v2.silentConcealedSamples,
              silentConcealmentEvents: v2.silentConcealmentEvents,
              totalAudioEnergy: v2.totalAudioEnergy,
              totalSamplesDuration: v2.totalSamplesDuration
            };
          }
        });
        return receiverStats;
      });
    }
  }
  const REACTION_DELAY = 100;
  class RemoteVideoTrack extends RemoteTrack {
    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {
      super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);
      this.elementInfos = [];
      this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver) {
          this._currentBitrate = 0;
          return;
        }
        const stats = yield this.getReceiverStats();
        if (stats && this.prevStats && this.receiver) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.debouncedHandleResize = r$1(() => {
        this.updateDimensions();
      }, REACTION_DELAY);
      this.adaptiveStreamSettings = adaptiveStreamSettings;
    }
    get isAdaptiveStream() {
      return this.adaptiveStreamSettings !== void 0;
    }
    /**
     * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
     */
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    /** @internal */
    setMuted(muted) {
      super.setMuted(muted);
      this.attachedElements.forEach((element) => {
        if (muted) {
          detachTrack(this._mediaStreamTrack, element);
        } else {
          attachToElement(this._mediaStreamTrack, element);
        }
      });
    }
    attach(element) {
      if (!element) {
        element = super.attach();
      } else {
        super.attach(element);
      }
      if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info.element === element) === void 0) {
        const elementInfo = new HTMLElementInfo(element);
        this.observeElementInfo(elementInfo);
      }
      return element;
    }
    /**
     * Observe an ElementInfo for changes when adaptive streaming.
     * @param elementInfo
     * @internal
     */
    observeElementInfo(elementInfo) {
      if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info === elementInfo) === void 0) {
        elementInfo.handleResize = () => {
          this.debouncedHandleResize();
        };
        elementInfo.handleVisibilityChanged = () => {
          this.updateVisibility();
        };
        this.elementInfos.push(elementInfo);
        elementInfo.observe();
        this.debouncedHandleResize();
        this.updateVisibility();
      } else {
        this.log.warn("visibility resize observer not triggered", this.logContext);
      }
    }
    /**
     * Stop observing an ElementInfo for changes.
     * @param elementInfo
     * @internal
     */
    stopObservingElementInfo(elementInfo) {
      if (!this.isAdaptiveStream) {
        this.log.warn("stopObservingElementInfo ignored", this.logContext);
        return;
      }
      const stopElementInfos = this.elementInfos.filter((info) => info === elementInfo);
      for (const info of stopElementInfos) {
        info.stopObserving();
      }
      this.elementInfos = this.elementInfos.filter((info) => info !== elementInfo);
      this.updateVisibility();
      this.debouncedHandleResize();
    }
    detach(element) {
      let detachedElements = [];
      if (element) {
        this.stopObservingElement(element);
        return super.detach(element);
      }
      detachedElements = super.detach();
      for (const e2 of detachedElements) {
        this.stopObservingElement(e2);
      }
      return detachedElements;
    }
    /** @internal */
    getDecoderImplementation() {
      var _a;
      return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;
    }
    getReceiverStats() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) {
          return;
        }
        const stats = yield this.receiver.getStats();
        let receiverStats;
        let codecID = "";
        let codecs = /* @__PURE__ */ new Map();
        stats.forEach((v2) => {
          if (v2.type === "inbound-rtp") {
            codecID = v2.codecId;
            receiverStats = {
              type: "video",
              streamId: v2.id,
              framesDecoded: v2.framesDecoded,
              framesDropped: v2.framesDropped,
              framesReceived: v2.framesReceived,
              packetsReceived: v2.packetsReceived,
              packetsLost: v2.packetsLost,
              frameWidth: v2.frameWidth,
              frameHeight: v2.frameHeight,
              pliCount: v2.pliCount,
              firCount: v2.firCount,
              nackCount: v2.nackCount,
              jitter: v2.jitter,
              timestamp: v2.timestamp,
              bytesReceived: v2.bytesReceived,
              decoderImplementation: v2.decoderImplementation
            };
          } else if (v2.type === "codec") {
            codecs.set(v2.id, v2);
          }
        });
        if (receiverStats && codecID !== "" && codecs.get(codecID)) {
          receiverStats.mimeType = codecs.get(codecID).mimeType;
        }
        return receiverStats;
      });
    }
    stopObservingElement(element) {
      const stopElementInfos = this.elementInfos.filter((info) => info.element === element);
      for (const info of stopElementInfos) {
        this.stopObservingElementInfo(info);
      }
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!this.isAdaptiveStream)
          return;
        this.updateVisibility();
      });
    }
    updateVisibility() {
      var _a, _b;
      const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);
      const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true) ? this.isInBackground : false;
      const isPiPMode = this.elementInfos.some((info) => info.pictureInPicture);
      const isVisible = this.elementInfos.some((info) => info.visible) && !backgroundPause || isPiPMode;
      if (this.lastVisible === isVisible) {
        return;
      }
      if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = isVisible;
      this.emit(TrackEvent.VisibilityChanged, isVisible, this);
    }
    updateDimensions() {
      var _a, _b;
      let maxWidth = 0;
      let maxHeight = 0;
      const pixelDensity = this.getPixelDensity();
      for (const info of this.elementInfos) {
        const currentElementWidth = info.width() * pixelDensity;
        const currentElementHeight = info.height() * pixelDensity;
        if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {
          maxWidth = currentElementWidth;
          maxHeight = currentElementHeight;
        }
      }
      if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {
        return;
      }
      this.lastDimensions = {
        width: maxWidth,
        height: maxHeight
      };
      this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
    }
    getPixelDensity() {
      var _a;
      const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;
      if (pixelDensity === "screen") {
        return getDevicePixelRatio();
      } else if (!pixelDensity) {
        const devicePixelRatio = getDevicePixelRatio();
        if (devicePixelRatio > 2) {
          return 2;
        } else {
          return 1;
        }
      }
      return pixelDensity;
    }
  }
  class HTMLElementInfo {
    get visible() {
      return this.isPiP || this.isIntersecting;
    }
    get pictureInPicture() {
      return this.isPiP;
    }
    constructor(element, visible) {
      this.onVisibilityChanged = (entry) => {
        var _a;
        const {
          target,
          isIntersecting
        } = entry;
        if (target === this.element) {
          this.isIntersecting = isIntersecting;
          this.isPiP = isElementInPiP(this.element);
          this.visibilityChangedAt = Date.now();
          (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);
        }
      };
      this.onEnterPiP = () => {
        var _a, _b, _c;
        (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener("pagehide", this.onLeavePiP);
        this.isPiP = isElementInPiP(this.element);
        (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);
      };
      this.onLeavePiP = () => {
        var _a;
        this.isPiP = isElementInPiP(this.element);
        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);
      };
      this.element = element;
      this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);
      this.isPiP = isWeb() && isElementInPiP(element);
      this.visibilityChangedAt = 0;
    }
    width() {
      return this.element.clientWidth;
    }
    height() {
      return this.element.clientHeight;
    }
    observe() {
      var _a, _b, _c;
      this.isIntersecting = isElementInViewport(this.element);
      this.isPiP = isElementInPiP(this.element);
      this.element.handleResize = () => {
        var _a2;
        (_a2 = this.handleResize) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      };
      this.element.handleVisibilityChanged = this.onVisibilityChanged;
      getIntersectionObserver().observe(this.element);
      getResizeObserver().observe(this.element);
      this.element.addEventListener("enterpictureinpicture", this.onEnterPiP);
      this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
      (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener("enter", this.onEnterPiP);
      (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener("pagehide", this.onLeavePiP);
    }
    stopObserving() {
      var _a, _b, _c, _d, _e2;
      (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);
      (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);
      this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP);
      this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
      (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener("enter", this.onEnterPiP);
      (_e2 = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e2 === void 0 ? void 0 : _e2.removeEventListener("pagehide", this.onLeavePiP);
    }
  }
  function isElementInPiP(el) {
    var _a, _b;
    if (document.pictureInPictureElement === el)
      return true;
    if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window)
      return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);
    return false;
  }
  function isElementInViewport(el, win) {
    const viewportWindow = win || window;
    let top = el.offsetTop;
    let left = el.offsetLeft;
    const width = el.offsetWidth;
    const height = el.offsetHeight;
    const {
      hidden
    } = el;
    const {
      display
    } = getComputedStyle(el);
    while (el.offsetParent) {
      el = el.offsetParent;
      top += el.offsetTop;
      left += el.offsetLeft;
    }
    return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== "none";
  }
  class TrackPublication extends eventsExports.EventEmitter {
    constructor(kind, id, name, loggerOptions) {
      var _a;
      super();
      this.metadataMuted = false;
      this.encryption = Encryption_Type.NONE;
      this.log = livekitLogger;
      this.handleMuted = () => {
        this.emit(TrackEvent.Muted);
      };
      this.handleUnmuted = () => {
        this.emit(TrackEvent.Unmuted);
      };
      this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);
      this.loggerContextCb = this.loggerContextCb;
      this.setMaxListeners(100);
      this.kind = kind;
      this.trackSid = id;
      this.trackName = name;
      this.source = Track.Source.Unknown;
    }
    /** @internal */
    setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Muted, this.handleMuted);
        this.track.off(TrackEvent.Unmuted, this.handleUnmuted);
      }
      this.track = track;
      if (track) {
        track.on(TrackEvent.Muted, this.handleMuted);
        track.on(TrackEvent.Unmuted, this.handleUnmuted);
      }
    }
    get logContext() {
      var _a;
      return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));
    }
    get isMuted() {
      return this.metadataMuted;
    }
    get isEnabled() {
      return true;
    }
    get isSubscribed() {
      return this.track !== void 0;
    }
    get isEncrypted() {
      return this.encryption !== Encryption_Type.NONE;
    }
    /**
     * an [AudioTrack] if this publication holds an audio track
     */
    get audioTrack() {
      if (isAudioTrack(this.track)) {
        return this.track;
      }
    }
    /**
     * an [VideoTrack] if this publication holds a video track
     */
    get videoTrack() {
      if (isVideoTrack(this.track)) {
        return this.track;
      }
    }
    /** @internal */
    updateInfo(info) {
      this.trackSid = info.sid;
      this.trackName = info.name;
      this.source = Track.sourceFromProto(info.source);
      this.mimeType = info.mimeType;
      if (this.kind === Track.Kind.Video && info.width > 0) {
        this.dimensions = {
          width: info.width,
          height: info.height
        };
        this.simulcasted = info.simulcast;
      }
      this.encryption = info.encryption;
      this.trackInfo = info;
      this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
        info
      }));
    }
  }
  (function(TrackPublication2) {
    (function(SubscriptionStatus) {
      SubscriptionStatus["Desired"] = "desired";
      SubscriptionStatus["Subscribed"] = "subscribed";
      SubscriptionStatus["Unsubscribed"] = "unsubscribed";
    })(TrackPublication2.SubscriptionStatus || (TrackPublication2.SubscriptionStatus = {}));
    (function(PermissionStatus) {
      PermissionStatus["Allowed"] = "allowed";
      PermissionStatus["NotAllowed"] = "not_allowed";
    })(TrackPublication2.PermissionStatus || (TrackPublication2.PermissionStatus = {}));
  })(TrackPublication);
  class LocalTrackPublication extends TrackPublication {
    get isUpstreamPaused() {
      var _a;
      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;
    }
    constructor(kind, ti, track, loggerOptions) {
      super(kind, ti.sid, ti.name, loggerOptions);
      this.track = void 0;
      this.handleTrackEnded = () => {
        this.emit(TrackEvent.Ended);
      };
      this.updateInfo(ti);
      this.setTrack(track);
    }
    setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Ended, this.handleTrackEnded);
      }
      super.setTrack(track);
      if (track) {
        track.on(TrackEvent.Ended, this.handleTrackEnded);
      }
    }
    get isMuted() {
      if (this.track) {
        return this.track.isMuted;
      }
      return super.isMuted;
    }
    get audioTrack() {
      return super.audioTrack;
    }
    get videoTrack() {
      return super.videoTrack;
    }
    get isLocal() {
      return true;
    }
    /**
     * Mute the track associated with this publication
     */
    mute() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();
      });
    }
    /**
     * Unmute track associated with this publication
     */
    unmute() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();
      });
    }
    /**
     * Pauses the media stream track associated with this publication from being sent to the server
     * and signals "muted" event to other participants
     * Useful if you want to pause the stream without pausing the local media stream track
     */
    pauseUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();
      });
    }
    /**
     * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
     * and signals "unmuted" event to other participants (unless the track is explicitly muted)
     */
    resumeUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();
      });
    }
    getTrackFeatures() {
      var _a;
      if (isAudioTrack(this.track)) {
        const settings = this.track.getSourceTrackSettings();
        const features = /* @__PURE__ */ new Set();
        if (settings.autoGainControl) {
          features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);
        }
        if (settings.echoCancellation) {
          features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);
        }
        if (settings.noiseSuppression) {
          features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);
        }
        if (settings.channelCount && settings.channelCount > 1) {
          features.add(AudioTrackFeature.TF_STEREO);
        }
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {
          features.add(AudioTrackFeature.TF_NO_DTX);
        }
        if (this.track.enhancedNoiseCancellation) {
          features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);
        }
        return Array.from(features.values());
      } else
        return [];
    }
  }
  var ConnectionQuality;
  (function(ConnectionQuality2) {
    ConnectionQuality2["Excellent"] = "excellent";
    ConnectionQuality2["Good"] = "good";
    ConnectionQuality2["Poor"] = "poor";
    ConnectionQuality2["Lost"] = "lost";
    ConnectionQuality2["Unknown"] = "unknown";
  })(ConnectionQuality || (ConnectionQuality = {}));
  function qualityFromProto(q2) {
    switch (q2) {
      case ConnectionQuality$1.EXCELLENT:
        return ConnectionQuality.Excellent;
      case ConnectionQuality$1.GOOD:
        return ConnectionQuality.Good;
      case ConnectionQuality$1.POOR:
        return ConnectionQuality.Poor;
      case ConnectionQuality$1.LOST:
        return ConnectionQuality.Lost;
      default:
        return ConnectionQuality.Unknown;
    }
  }
  class Participant extends eventsExports.EventEmitter {
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    get isEncrypted() {
      return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((tr) => tr.isEncrypted);
    }
    get isAgent() {
      var _a;
      return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;
    }
    get kind() {
      return this._kind;
    }
    /** participant attributes, similar to metadata, but as a key/value map */
    get attributes() {
      return Object.freeze(Object.assign({}, this._attributes));
    }
    /** @internal */
    constructor(sid, identity, name, metadata, attributes, loggerOptions) {
      let kind = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : ParticipantInfo_Kind.STANDARD;
      var _a;
      super();
      this.audioLevel = 0;
      this.isSpeaking = false;
      this._connectionQuality = ConnectionQuality.Unknown;
      this.log = livekitLogger;
      this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);
      this.loggerOptions = loggerOptions;
      this.setMaxListeners(100);
      this.sid = sid;
      this.identity = identity;
      this.name = name;
      this.metadata = metadata;
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.trackPublications = /* @__PURE__ */ new Map();
      this._kind = kind;
      this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};
    }
    getTrackPublications() {
      return Array.from(this.trackPublications.values());
    }
    /**
     * Finds the first track that matches the source filter, for example, getting
     * the user's camera track with getTrackBySource(Track.Source.Camera).
     */
    getTrackPublication(source) {
      for (const [, pub] of this.trackPublications) {
        if (pub.source === source) {
          return pub;
        }
      }
    }
    /**
     * Finds the first track that matches the track's name.
     */
    getTrackPublicationByName(name) {
      for (const [, pub] of this.trackPublications) {
        if (pub.trackName === name) {
          return pub;
        }
      }
    }
    get connectionQuality() {
      return this._connectionQuality;
    }
    get isCameraEnabled() {
      var _a;
      const track = this.getTrackPublication(Track.Source.Camera);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
    get isMicrophoneEnabled() {
      var _a;
      const track = this.getTrackPublication(Track.Source.Microphone);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
    get isScreenShareEnabled() {
      const track = this.getTrackPublication(Track.Source.ScreenShare);
      return !!track;
    }
    get isLocal() {
      return false;
    }
    /** when participant joined the room */
    get joinedAt() {
      if (this.participantInfo) {
        return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3);
      }
      return /* @__PURE__ */ new Date();
    }
    /** @internal */
    updateInfo(info) {
      if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {
        return false;
      }
      this.identity = info.identity;
      this.sid = info.sid;
      this._setName(info.name);
      this._setMetadata(info.metadata);
      this._setAttributes(info.attributes);
      if (info.permission) {
        this.setPermissions(info.permission);
      }
      this.participantInfo = info;
      this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
        info
      }));
      return true;
    }
    /**
     * Updates metadata from server
     **/
    _setMetadata(md) {
      const changed = this.metadata !== md;
      const prevMetadata = this.metadata;
      this.metadata = md;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);
      }
    }
    _setName(name) {
      const changed = this.name !== name;
      this.name = name;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantNameChanged, name);
      }
    }
    /**
     * Updates metadata from server
     **/
    _setAttributes(attributes) {
      const diff = diffAttributes(this.attributes, attributes);
      this._attributes = attributes;
      if (Object.keys(diff).length > 0) {
        this.emit(ParticipantEvent.AttributesChanged, diff);
      }
    }
    /** @internal */
    setPermissions(permissions) {
      var _a, _b, _c, _d, _e2, _f;
      const prevPermissions = this.permissions;
      const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e2 = this.permissions) === null || _e2 === void 0 ? void 0 : _e2.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {
        var _a2;
        return value !== ((_a2 = this.permissions) === null || _a2 === void 0 ? void 0 : _a2.canPublishSources[index]);
      }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);
      this.permissions = permissions;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
      }
      return changed;
    }
    /** @internal */
    setIsSpeaking(speaking) {
      if (speaking === this.isSpeaking) {
        return;
      }
      this.isSpeaking = speaking;
      if (speaking) {
        this.lastSpokeAt = /* @__PURE__ */ new Date();
      }
      this.emit(ParticipantEvent.IsSpeakingChanged, speaking);
    }
    /** @internal */
    setConnectionQuality(q2) {
      const prevQuality = this._connectionQuality;
      this._connectionQuality = qualityFromProto(q2);
      if (prevQuality !== this._connectionQuality) {
        this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
      }
    }
    /**
     * @internal
     */
    setAudioContext(ctx) {
      this.audioContext = ctx;
      this.audioTrackPublications.forEach((track) => isAudioTrack(track.track) && track.track.setAudioContext(ctx));
    }
    addTrackPublication(publication) {
      publication.on(TrackEvent.Muted, () => {
        this.emit(ParticipantEvent.TrackMuted, publication);
      });
      publication.on(TrackEvent.Unmuted, () => {
        this.emit(ParticipantEvent.TrackUnmuted, publication);
      });
      const pub = publication;
      if (pub.track) {
        pub.track.sid = publication.trackSid;
      }
      this.trackPublications.set(publication.trackSid, publication);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.set(publication.trackSid, publication);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.set(publication.trackSid, publication);
          break;
      }
    }
  }
  function trackPermissionToProto(perms) {
    var _a, _b, _c;
    if (!perms.participantSid && !perms.participantIdentity) {
      throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
    }
    return new TrackPermission({
      participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : "",
      participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : "",
      allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,
      trackSids: perms.allowedTrackSids || []
    });
  }
  const STREAM_CHUNK_SIZE = 15e3;
  class LocalParticipant extends Participant {
    /** @internal */
    constructor(sid, identity, engine, options, roomRpcHandlers) {
      super(sid, identity, void 0, void 0, void 0, {
        loggerName: options.loggerName,
        loggerContextCb: () => this.engine.logContext
      });
      this.pendingPublishing = /* @__PURE__ */ new Set();
      this.pendingPublishPromises = /* @__PURE__ */ new Map();
      this.participantTrackPermissions = [];
      this.allParticipantsAllowedToSubscribe = true;
      this.encryptionType = Encryption_Type.NONE;
      this.enabledPublishVideoCodecs = [];
      this.pendingAcks = /* @__PURE__ */ new Map();
      this.pendingResponses = /* @__PURE__ */ new Map();
      this.handleReconnecting = () => {
        if (!this.reconnectFuture) {
          this.reconnectFuture = new Future();
        }
      };
      this.handleReconnected = () => {
        var _a, _b;
        (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.reconnectFuture = void 0;
        this.updateTrackSubscriptionPermissions();
      };
      this.handleDisconnected = () => {
        var _a, _b;
        if (this.reconnectFuture) {
          this.reconnectFuture.promise.catch((e2) => this.log.warn(e2.message, this.logContext));
          (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, "Got disconnected during reconnection attempt");
          this.reconnectFuture = void 0;
        }
      };
      this.handleSignalRequestResponse = (response) => {
        const {
          requestId,
          reason,
          message
        } = response;
        const targetRequest = this.pendingSignalRequests.get(requestId);
        if (targetRequest) {
          if (reason !== RequestResponse_Reason.OK) {
            targetRequest.reject(new SignalRequestError(message, reason));
          }
          this.pendingSignalRequests.delete(requestId);
        }
      };
      this.handleDataPacket = (packet) => {
        switch (packet.value.case) {
          case "rpcResponse":
            let rpcResponse = packet.value.value;
            let payload = null;
            let error = null;
            if (rpcResponse.value.case === "payload") {
              payload = rpcResponse.value.value;
            } else if (rpcResponse.value.case === "error") {
              error = RpcError.fromProto(rpcResponse.value.value);
            }
            this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);
            break;
          case "rpcAck":
            let rpcAck = packet.value.value;
            this.handleIncomingRpcAck(rpcAck.requestId);
            break;
        }
      };
      this.updateTrackSubscriptionPermissions = () => {
        this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
          allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
          participantTrackPermissions: this.participantTrackPermissions
        }));
        this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p2) => trackPermissionToProto(p2)));
      };
      this.onTrackUnmuted = (track) => {
        this.onTrackMuted(track, track.isUpstreamPaused);
      };
      this.onTrackMuted = (track, muted) => {
        if (muted === void 0) {
          muted = true;
        }
        if (!track.sid) {
          this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          return;
        }
        this.engine.updateMuteStatus(track.sid, muted);
      };
      this.onTrackUpstreamPaused = (track) => {
        this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        this.onTrackMuted(track, true);
      };
      this.onTrackUpstreamResumed = (track) => {
        this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        this.onTrackMuted(track, track.isMuted);
      };
      this.onTrackFeatureUpdate = (track) => {
        const pub = this.audioTrackPublications.get(track.sid);
        if (!pub) {
          this.log.warn("Could not update local audio track settings, missing publication for track ".concat(track.sid), this.logContext);
          return;
        }
        this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());
      };
      this.handleSubscribedQualityUpdate = (update) => __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        var _d, _e2;
        if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {
          return;
        }
        const pub = this.videoTrackPublications.get(update.trackSid);
        if (!pub) {
          this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: update.trackSid
          }));
          return;
        }
        if (update.subscribedCodecs.length > 0) {
          if (!pub.videoTrack) {
            return;
          }
          const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);
          try {
            for (var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true) {
              _c = newCodecs_1_1.value;
              _f = false;
              const codec = _c;
              if (isBackupCodec(codec)) {
                this.log.debug("publish ".concat(codec, " for ").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));
                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);
              }
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (!_f && !_a && (_b = newCodecs_1.return))
                yield _b.call(newCodecs_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else if (update.subscribedQualities.length > 0) {
          yield (_e2 = pub.videoTrack) === null || _e2 === void 0 ? void 0 : _e2.setPublishingLayers(update.subscribedQualities);
        }
      });
      this.handleLocalTrackUnpublished = (unpublished) => {
        const track = this.trackPublications.get(unpublished.trackSid);
        if (!track) {
          this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: unpublished.trackSid
          }));
          return;
        }
        this.unpublishTrack(track.track);
      };
      this.handleTrackEnded = (track) => __awaiter(this, void 0, void 0, function* () {
        if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {
          this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          this.unpublishTrack(track);
        } else if (track.isUserProvided) {
          yield track.mute();
        } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {
          try {
            if (isWeb()) {
              try {
                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({
                  // the permission query for camera and microphone currently not supported in Safari and Firefox
                  // @ts-ignore
                  name: track.source === Track.Source.Camera ? "camera" : "microphone"
                });
                if (currentPermissions && currentPermissions.state === "denied") {
                  this.log.warn("user has revoked access to ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
                  currentPermissions.onchange = () => {
                    if (currentPermissions.state !== "denied") {
                      if (!track.isMuted) {
                        track.restartTrack();
                      }
                      currentPermissions.onchange = null;
                    }
                  };
                  throw new Error("GetUserMedia Permission denied");
                }
              } catch (e2) {
              }
            }
            if (!track.isMuted) {
              this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              if (isLocalAudioTrack(track)) {
                yield track.restartTrack({
                  deviceId: "default"
                });
              } else {
                yield track.restartTrack();
              }
            }
          } catch (e2) {
            this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
            yield track.mute();
          }
        }
      });
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.trackPublications = /* @__PURE__ */ new Map();
      this.engine = engine;
      this.roomOptions = options;
      this.setupEngine(engine);
      this.activeDeviceMap = /* @__PURE__ */ new Map([["audioinput", "default"], ["videoinput", "default"], ["audiooutput", "default"]]);
      this.pendingSignalRequests = /* @__PURE__ */ new Map();
      this.rpcHandlers = roomRpcHandlers;
    }
    get lastCameraError() {
      return this.cameraError;
    }
    get lastMicrophoneError() {
      return this.microphoneError;
    }
    get isE2EEEnabled() {
      return this.encryptionType !== Encryption_Type.NONE;
    }
    getTrackPublication(source) {
      const track = super.getTrackPublication(source);
      if (track) {
        return track;
      }
    }
    getTrackPublicationByName(name) {
      const track = super.getTrackPublicationByName(name);
      if (track) {
        return track;
      }
    }
    /**
     * @internal
     */
    setupEngine(engine) {
      this.engine = engine;
      this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {
        const pub = this.trackPublications.get(trackSid);
        if (!pub || !pub.track) {
          return;
        }
        if (muted) {
          pub.mute();
        } else {
          pub.unmute();
        }
      });
      this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);
    }
    /**
     * Sets and updates the metadata of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
    setMetadata(metadata) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          metadata
        });
      });
    }
    /**
     * Sets and updates the name of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
    setName(name) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          name
        });
      });
    }
    /**
     * Set or update participant attributes. It will make updates only to keys that
     * are present in `attributes`, and will not override others.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * @param attributes attributes to update
     */
    setAttributes(attributes) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          attributes
        });
      });
    }
    requestMetadataUpdate(_a) {
      return __awaiter(this, arguments, void 0, function(_ref) {
        var _this = this;
        let {
          metadata,
          name,
          attributes
        } = _ref;
        return function* () {
          return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {
            var _a2, _b;
            try {
              let isRejected = false;
              const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a2 = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a2 !== void 0 ? _a2 : "", (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : "", attributes);
              const startTime = performance.now();
              this.pendingSignalRequests.set(requestId, {
                resolve,
                reject: (error) => {
                  reject(error);
                  isRejected = true;
                },
                values: {
                  name,
                  metadata,
                  attributes
                }
              });
              while (performance.now() - startTime < 5e3 && !isRejected) {
                if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every((_ref2) => {
                  let [key, value] = _ref2;
                  return this.attributes[key] === value || value === "" && !this.attributes[key];
                }))) {
                  this.pendingSignalRequests.delete(requestId);
                  resolve();
                  return;
                }
                yield sleep(50);
              }
              reject(new SignalRequestError("Request to update local metadata timed out", "TimeoutError"));
            } catch (e2) {
              if (e2 instanceof Error)
                reject(e2);
            }
          }));
        }();
      });
    }
    /**
     * Enable or disable a participant's camera track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setCameraEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);
    }
    /**
     * Enable or disable a participant's microphone track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setMicrophoneEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);
    }
    /**
     * Start or stop sharing a participant's screen
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setScreenShareEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);
    }
    /** @internal */
    setPermissions(permissions) {
      const prevPermissions = this.permissions;
      const changed = super.setPermissions(permissions);
      if (changed && prevPermissions) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
      }
      return changed;
    }
    /** @internal */
    setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, function* () {
        this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;
        yield this.republishAllTracks(void 0, false);
      });
    }
    setTrackEnabled(source, enabled, options, publishOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
          source,
          enabled
        }));
        if (this.republishPromise) {
          yield this.republishPromise;
        }
        let track = this.getTrackPublication(source);
        if (enabled) {
          if (track) {
            yield track.unmute();
          } else {
            let localTracks;
            if (this.pendingPublishing.has(source)) {
              const pendingTrack = yield this.waitForPendingPublicationOfSource(source);
              if (!pendingTrack) {
                this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                  source
                }));
              }
              yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();
              return pendingTrack;
            }
            this.pendingPublishing.add(source);
            try {
              switch (source) {
                case Track.Source.Camera:
                  localTracks = yield this.createTracks({
                    video: (_a = options) !== null && _a !== void 0 ? _a : true
                  });
                  break;
                case Track.Source.Microphone:
                  localTracks = yield this.createTracks({
                    audio: (_b = options) !== null && _b !== void 0 ? _b : true
                  });
                  break;
                case Track.Source.ScreenShare:
                  localTracks = yield this.createScreenTracks(Object.assign({}, options));
                  break;
                default:
                  throw new TrackInvalidError(source);
              }
            } catch (e2) {
              localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr) => {
                tr.stop();
              });
              if (e2 instanceof Error) {
                this.emit(ParticipantEvent.MediaDevicesError, e2);
              }
              this.pendingPublishing.delete(source);
              throw e2;
            }
            try {
              const publishPromises = [];
              for (const localTrack of localTracks) {
                this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));
                publishPromises.push(this.publishTrack(localTrack, publishOptions));
              }
              const publishedTracks = yield Promise.all(publishPromises);
              [track] = publishedTracks;
            } catch (e2) {
              localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr) => {
                tr.stop();
              });
              throw e2;
            } finally {
              this.pendingPublishing.delete(source);
            }
          }
        } else {
          if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {
            track = yield this.waitForPendingPublicationOfSource(source);
            if (!track) {
              this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                source
              }));
            }
          }
          if (track && track.track) {
            if (source === Track.Source.ScreenShare) {
              track = yield this.unpublishTrack(track.track);
              const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);
              if (screenAudioTrack && screenAudioTrack.track) {
                this.unpublishTrack(screenAudioTrack.track);
              }
            } else {
              yield track.mute();
            }
          }
        }
        return track;
      });
    }
    /**
     * Publish both camera and microphone at the same time. This is useful for
     * displaying a single Permission Dialog box to the end user.
     */
    enableCameraAndMicrophone() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {
          return;
        }
        this.pendingPublishing.add(Track.Source.Camera);
        this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const tracks = yield this.createTracks({
            audio: true,
            video: true
          });
          yield Promise.all(tracks.map((track) => this.publishTrack(track)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera);
          this.pendingPublishing.delete(Track.Source.Microphone);
        }
      });
    }
    /**
     * Create local camera and/or microphone tracks
     * @param options
     * @returns
     */
    createTracks(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        options !== null && options !== void 0 ? options : options = {};
        const {
          audioProcessor,
          videoProcessor,
          optionsWithoutProcessor
        } = extractProcessorsFromOptions(options);
        const mergedOptions = mergeDefaultOptions(optionsWithoutProcessor, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);
        const constraints = constraintsForOptions(mergedOptions);
        let stream;
        try {
          stream = yield navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          if (err instanceof Error) {
            if (constraints.audio) {
              this.microphoneError = err;
            }
            if (constraints.video) {
              this.cameraError = err;
            }
          }
          throw err;
        }
        if (constraints.audio) {
          this.microphoneError = void 0;
          this.emit(ParticipantEvent.AudioStreamAcquired);
        }
        if (constraints.video) {
          this.cameraError = void 0;
        }
        return Promise.all(stream.getTracks().map((mediaStreamTrack) => __awaiter(this, void 0, void 0, function* () {
          const isAudio = mediaStreamTrack.kind === "audio";
          isAudio ? mergedOptions.audio : mergedOptions.video;
          let trackConstraints;
          const conOrBool = isAudio ? constraints.audio : constraints.video;
          if (typeof conOrBool !== "boolean") {
            trackConstraints = conOrBool;
          }
          const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext
          });
          if (track.kind === Track.Kind.Video) {
            track.source = Track.Source.Camera;
          } else if (track.kind === Track.Kind.Audio) {
            track.source = Track.Source.Microphone;
            track.setAudioContext(this.audioContext);
          }
          track.mediaStream = stream;
          if (isAudioTrack(track) && audioProcessor) {
            yield track.setProcessor(audioProcessor);
          } else if (isVideoTrack(track) && videoProcessor) {
            yield track.setProcessor(videoProcessor);
          }
          return track;
        })));
      });
    }
    /**
     * Creates a screen capture tracks with getDisplayMedia().
     * A LocalVideoTrack is always created and returned.
     * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
     */
    createScreenTracks(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (options === void 0) {
          options = {};
        }
        if (navigator.mediaDevices.getDisplayMedia === void 0) {
          throw new DeviceUnsupportedError("getDisplayMedia not supported");
        }
        if (options.resolution === void 0 && !isSafari17()) {
          options.resolution = ScreenSharePresets.h1080fps30.resolution;
        }
        const constraints = screenCaptureToDisplayMediaStreamOptions(options);
        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);
        const tracks = stream.getVideoTracks();
        if (tracks.length === 0) {
          throw new TrackInvalidError("no video track found");
        }
        const screenVideo = new LocalVideoTrack(tracks[0], void 0, false, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        screenVideo.source = Track.Source.ScreenShare;
        if (options.contentHint) {
          screenVideo.mediaStreamTrack.contentHint = options.contentHint;
        }
        const localTracks = [screenVideo];
        if (stream.getAudioTracks().length > 0) {
          this.emit(ParticipantEvent.AudioStreamAcquired);
          const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false, this.audioContext, {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext
          });
          screenAudio.source = Track.Source.ScreenShareAudio;
          localTracks.push(screenAudio);
        }
        return localTracks;
      });
    }
    /**
     * Publish a new track to the room
     * @param track
     * @param options
     */
    publishTrack(track, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.publishOrRepublishTrack(track, options);
      });
    }
    publishOrRepublishTrack(track_1, options_1) {
      return __awaiter(this, arguments, void 0, function(track, options) {
        var _this2 = this;
        let isRepublish = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return function* () {
          var _a, _b, _c, _d;
          if (isLocalAudioTrack(track)) {
            track.setAudioContext(_this2.audioContext);
          }
          yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;
          if (_this2.republishPromise && !isRepublish) {
            yield _this2.republishPromise;
          }
          if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {
            yield _this2.pendingPublishPromises.get(track);
          }
          let defaultConstraints;
          if (track instanceof MediaStreamTrack) {
            defaultConstraints = track.getConstraints();
          } else {
            defaultConstraints = track.constraints;
            let deviceKind = void 0;
            switch (track.source) {
              case Track.Source.Microphone:
                deviceKind = "audioinput";
                break;
              case Track.Source.Camera:
                deviceKind = "videoinput";
            }
            if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {
              defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {
                deviceId: _this2.activeDeviceMap.get(deviceKind)
              });
            }
          }
          if (track instanceof MediaStreamTrack) {
            switch (track.kind) {
              case "audio":
                track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {
                  loggerName: _this2.roomOptions.loggerName,
                  loggerContextCb: () => _this2.logContext
                });
                break;
              case "video":
                track = new LocalVideoTrack(track, defaultConstraints, true, {
                  loggerName: _this2.roomOptions.loggerName,
                  loggerContextCb: () => _this2.logContext
                });
                break;
              default:
                throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(track.kind));
            }
          } else {
            track.updateLoggerOptions({
              loggerName: _this2.roomOptions.loggerName,
              loggerContextCb: () => _this2.logContext
            });
          }
          let existingPublication;
          _this2.trackPublications.forEach((publication) => {
            if (!publication.track) {
              return;
            }
            if (publication.track === track) {
              existingPublication = publication;
            }
          });
          if (existingPublication) {
            _this2.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));
            return existingPublication;
          }
          const isStereoInput = "channelCount" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
          track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;
          const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;
          if (isStereo) {
            if (!options) {
              options = {};
            }
            if (options.dtx === void 0) {
              _this2.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));
            }
            if (options.red === void 0) {
              _this2.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.");
            }
            (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;
            (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;
          }
          const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);
          if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {
            _this2.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2", Object.assign({}, _this2.logContext));
            opts.simulcast = false;
          }
          if (opts.source) {
            track.source = opts.source;
          }
          const publishPromise = _this2.publish(track, opts, isStereo);
          _this2.pendingPublishPromises.set(track, publishPromise);
          try {
            const publication = yield publishPromise;
            return publication;
          } catch (e2) {
            throw e2;
          } finally {
            _this2.pendingPublishPromises.delete(track);
          }
        }();
      });
    }
    publish(track, opts, isStereo) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k;
        const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack) => isLocalTrack(track) && publishedTrack.source === track.source);
        if (existingTrackOfSource && track.source !== Track.Source.Unknown) {
          this.log.info("publishing a second track with the same source: ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        }
        if (opts.stopMicTrackOnMute && isAudioTrack(track)) {
          track.stopOnMute = true;
        }
        if (track.source === Track.Source.ScreenShare && isFireFox()) {
          opts.simulcast = false;
        }
        if (opts.videoCodec === "av1" && !supportsAV1()) {
          opts.videoCodec = void 0;
        }
        if (opts.videoCodec === "vp9" && !supportsVP9()) {
          opts.videoCodec = void 0;
        }
        if (opts.videoCodec === void 0) {
          opts.videoCodec = defaultVideoCodec;
        }
        if (this.enabledPublishVideoCodecs.length > 0) {
          if (!this.enabledPublishVideoCodecs.some((c2) => opts.videoCodec === mimeTypeToVideoCodecString(c2.mime))) {
            opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);
          }
        }
        const videoCodec = opts.videoCodec;
        track.on(TrackEvent.Muted, this.onTrackMuted);
        track.on(TrackEvent.Unmuted, this.onTrackUnmuted);
        track.on(TrackEvent.Ended, this.handleTrackEnded);
        track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
        track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
        track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        const req = new AddTrackRequest({
          // get local track id for use during publishing
          cid: track.mediaStreamTrack.id,
          name: opts.name,
          type: Track.kindToProto(track.kind),
          muted: track.isMuted,
          source: Track.sourceToProto(track.source),
          disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),
          encryption: this.encryptionType,
          stereo: isStereo,
          disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),
          stream: opts === null || opts === void 0 ? void 0 : opts.stream,
          backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy
        });
        let encodings;
        if (track.kind === Track.Kind.Video) {
          let dims = {
            width: 0,
            height: 0
          };
          try {
            dims = yield track.waitForDimensions();
          } catch (e2) {
            const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;
            dims = {
              width: defaultRes.width,
              height: defaultRes.height
            };
            this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {
              dims
            }));
          }
          req.width = dims.width;
          req.height = dims.height;
          if (isLocalVideoTrack(track)) {
            if (isSVCCodec(videoCodec)) {
              if (track.source === Track.Source.ScreenShare) {
                opts.scalabilityMode = "L1T3";
                if ("contentHint" in track.mediaStreamTrack) {
                  track.mediaStreamTrack.contentHint = "motion";
                  this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
                }
              }
              opts.scalabilityMode = (_e2 = opts.scalabilityMode) !== null && _e2 !== void 0 ? _e2 : "L3T3_KEY";
            }
            req.simulcastCodecs = [new SimulcastCodec({
              codec: videoCodec,
              cid: track.mediaStreamTrack.id
            })];
            if (opts.backupCodec === true) {
              opts.backupCodec = {
                codec: defaultVideoCodec
              };
            }
            if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
            req.encryption === Encryption_Type.NONE) {
              if (!this.roomOptions.dynacast) {
                this.roomOptions.dynacast = true;
              }
              req.simulcastCodecs.push(new SimulcastCodec({
                codec: opts.backupCodec.codec,
                cid: ""
              }));
            }
          }
          encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);
          req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));
        } else if (track.kind === Track.Kind.Audio) {
          encodings = [{
            maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,
            priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : "high",
            networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : "high"
          }];
        }
        if (!this.engine || this.engine.isClosed) {
          throw new UnexpectedConnectionState("cannot publish track when not connected");
        }
        const negotiate = () => __awaiter(this, void 0, void 0, function* () {
          var _a2, _b2, _c2;
          if (!this.engine.pcManager) {
            throw new UnexpectedConnectionState("pcManager is not ready");
          }
          track.sender = yield this.engine.createSender(track, opts, encodings);
          if (isLocalVideoTrack(track)) {
            (_a2 = opts.degradationPreference) !== null && _a2 !== void 0 ? _a2 : opts.degradationPreference = getDefaultDegradationPreference(track);
            track.setDegradationPreference(opts.degradationPreference);
          }
          if (encodings) {
            if (isFireFox() && track.kind === Track.Kind.Audio) {
              let trackTransceiver = void 0;
              for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
                if (transceiver.sender === track.sender) {
                  trackTransceiver = transceiver;
                  break;
                }
              }
              if (trackTransceiver) {
                this.engine.pcManager.publisher.setTrackCodecBitrate({
                  transceiver: trackTransceiver,
                  codec: "opus",
                  maxbr: ((_b2 = encodings[0]) === null || _b2 === void 0 ? void 0 : _b2.maxBitrate) ? encodings[0].maxBitrate / 1e3 : 0
                });
              }
            } else if (track.codec && isSVCCodec(track.codec) && ((_c2 = encodings[0]) === null || _c2 === void 0 ? void 0 : _c2.maxBitrate)) {
              this.engine.pcManager.publisher.setTrackCodecBitrate({
                cid: req.cid,
                codec: track.codec,
                maxbr: encodings[0].maxBitrate / 1e3
              });
            }
          }
          yield this.engine.negotiate();
        });
        let ti;
        if (this.enabledPublishVideoCodecs.length > 0) {
          const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);
          ti = rets[0];
        } else {
          ti = yield this.engine.addTrack(req);
          let primaryCodecMime;
          ti.codecs.forEach((codec) => {
            if (primaryCodecMime === void 0) {
              primaryCodecMime = codec.mimeType;
            }
          });
          if (primaryCodecMime && track.kind === Track.Kind.Video) {
            const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);
            if (updatedCodec !== videoCodec) {
              this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {
                codec: updatedCodec
              }));
              opts.videoCodec = updatedCodec;
              encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);
            }
          }
          yield negotiate();
        }
        const publication = new LocalTrackPublication(track.kind, ti, track, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        publication.options = opts;
        track.sid = ti.sid;
        this.log.debug("publishing ".concat(track.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
          encodings,
          trackInfo: ti
        }));
        if (isLocalVideoTrack(track)) {
          track.startMonitor(this.engine.client);
        } else if (isLocalAudioTrack(track)) {
          track.startMonitor();
        }
        this.addTrackPublication(publication);
        this.emit(ParticipantEvent.LocalTrackPublished, publication);
        return publication;
      });
    }
    get isLocal() {
      return true;
    }
    /** @internal
     * publish additional codec to existing track
     */
    publishAdditionalCodecForTrack(track, videoCodec, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (this.encryptionType !== Encryption_Type.NONE) {
          return;
        }
        let existingPublication;
        this.trackPublications.forEach((publication) => {
          if (!publication.track) {
            return;
          }
          if (publication.track === track) {
            existingPublication = publication;
          }
        });
        if (!existingPublication) {
          throw new TrackInvalidError("track is not published");
        }
        if (!isLocalVideoTrack(track)) {
          throw new TrackInvalidError("track is not a video track");
        }
        const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);
        const encodings = computeTrackBackupEncodings(track, videoCodec, opts);
        if (!encodings) {
          this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          return;
        }
        const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);
        if (!simulcastTrack) {
          return;
        }
        const req = new AddTrackRequest({
          cid: simulcastTrack.mediaStreamTrack.id,
          type: Track.kindToProto(track.kind),
          muted: track.isMuted,
          source: Track.sourceToProto(track.source),
          sid: track.sid,
          simulcastCodecs: [{
            codec: opts.videoCodec,
            cid: simulcastTrack.mediaStreamTrack.id
          }]
        });
        req.layers = videoLayersFromEncodings(req.width, req.height, encodings);
        if (!this.engine || this.engine.isClosed) {
          throw new UnexpectedConnectionState("cannot publish track when not connected");
        }
        const negotiate = () => __awaiter(this, void 0, void 0, function* () {
          yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);
          yield this.engine.negotiate();
        });
        const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);
        const ti = rets[0];
        this.log.debug("published ".concat(videoCodec, " for track ").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {
          encodings,
          trackInfo: ti
        }));
      });
    }
    unpublishTrack(track, stopOnUnpublish) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (isLocalTrack(track)) {
          const publishPromise = this.pendingPublishPromises.get(track);
          if (publishPromise) {
            this.log.info("awaiting publish promise before attempting to unpublish", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
            yield publishPromise;
          }
        }
        const publication = this.getPublicationForTrack(track);
        const pubLogContext = publication ? getLogContextFromTrack(publication) : void 0;
        this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), pubLogContext));
        if (!publication || !publication.track) {
          this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), pubLogContext));
          return void 0;
        }
        track = publication.track;
        track.off(TrackEvent.Muted, this.onTrackMuted);
        track.off(TrackEvent.Unmuted, this.onTrackUnmuted);
        track.off(TrackEvent.Ended, this.handleTrackEnded);
        track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
        track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
        track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        if (stopOnUnpublish === void 0) {
          stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;
        }
        if (stopOnUnpublish) {
          track.stop();
        } else {
          track.stopMonitor();
        }
        let negotiationNeeded = false;
        const trackSender = track.sender;
        track.sender = void 0;
        if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {
          try {
            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
              if (transceiver.sender === trackSender) {
                transceiver.direction = "inactive";
                negotiationNeeded = true;
              }
            }
            if (this.engine.removeTrack(trackSender)) {
              negotiationNeeded = true;
            }
            if (isLocalVideoTrack(track)) {
              for (const [, trackInfo] of track.simulcastCodecs) {
                if (trackInfo.sender) {
                  if (this.engine.removeTrack(trackInfo.sender)) {
                    negotiationNeeded = true;
                  }
                  trackInfo.sender = void 0;
                }
              }
              track.simulcastCodecs.clear();
            }
          } catch (e2) {
            this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {
              error: e2
            }));
          }
        }
        this.trackPublications.delete(publication.trackSid);
        switch (publication.kind) {
          case Track.Kind.Audio:
            this.audioTrackPublications.delete(publication.trackSid);
            break;
          case Track.Kind.Video:
            this.videoTrackPublications.delete(publication.trackSid);
            break;
        }
        this.emit(ParticipantEvent.LocalTrackUnpublished, publication);
        publication.setTrack(void 0);
        if (negotiationNeeded) {
          yield this.engine.negotiate();
        }
        return publication;
      });
    }
    unpublishTracks(tracks) {
      return __awaiter(this, void 0, void 0, function* () {
        const results = yield Promise.all(tracks.map((track) => this.unpublishTrack(track)));
        return results.filter((track) => !!track);
      });
    }
    republishAllTracks(options_1) {
      return __awaiter(this, arguments, void 0, function(options) {
        var _this3 = this;
        let restartTracks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          if (_this3.republishPromise) {
            yield _this3.republishPromise;
          }
          _this3.republishPromise = new Promise((resolve, reject) => __awaiter(_this3, void 0, void 0, function* () {
            try {
              const localPubs = [];
              this.trackPublications.forEach((pub) => {
                if (pub.track) {
                  if (options) {
                    pub.options = Object.assign(Object.assign({}, pub.options), options);
                  }
                  localPubs.push(pub);
                }
              });
              yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {
                const track = pub.track;
                yield this.unpublishTrack(track, false);
                if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {
                  this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
                    track: pub.trackSid
                  }));
                  yield track.restartTrack();
                }
                yield this.publishOrRepublishTrack(track, pub.options, true);
              })));
              resolve();
            } catch (error) {
              reject(error);
            } finally {
              this.republishPromise = void 0;
            }
          }));
          yield _this3.republishPromise;
        }();
      });
    }
    /**
     * Publish a new data payload to the room. Data will be forwarded to each
     * participant in the room if the destination field in publishOptions is empty
     *
     * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
     * @param options optionally specify a `reliable`, `topic` and `destination`
     */
    publishData(data_1) {
      return __awaiter(this, arguments, void 0, function(data) {
        var _this4 = this;
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function* () {
          const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;
          const destinationIdentities = options.destinationIdentities;
          const topic = options.topic;
          const packet = new DataPacket({
            kind,
            value: {
              case: "user",
              value: new UserPacket({
                participantIdentity: _this4.identity,
                payload: data,
                destinationIdentities,
                topic
              })
            }
          });
          yield _this4.engine.sendDataPacket(packet, kind);
        }();
      });
    }
    /**
     * Publish SIP DTMF message to the room.
     *
     * @param code DTMF code
     * @param digit DTMF digit
     */
    publishDtmf(code, digit) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "sipDtmf",
            value: new SipDTMF({
              code,
              digit
            })
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    sendChatMessage(text, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = {
          id: $inject_window_crypto.randomUUID(),
          message: text,
          timestamp: Date.now(),
          attachedFiles: options === null || options === void 0 ? void 0 : options.attachments
        };
        const packet = new DataPacket({
          value: {
            case: "chatMessage",
            value: new ChatMessage(Object.assign(Object.assign({}, msg), {
              timestamp: protoInt64.parse(msg.timestamp)
            }))
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        this.emit(ParticipantEvent.ChatMessage, msg);
        return msg;
      });
    }
    editChatMessage(editText, originalMessage) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = Object.assign(Object.assign({}, originalMessage), {
          message: editText,
          editTimestamp: Date.now()
        });
        const packet = new DataPacket({
          value: {
            case: "chatMessage",
            value: new ChatMessage(Object.assign(Object.assign({}, msg), {
              timestamp: protoInt64.parse(msg.timestamp),
              editTimestamp: protoInt64.parse(msg.editTimestamp)
            }))
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        this.emit(ParticipantEvent.ChatMessage, msg);
        return msg;
      });
    }
    sendText(text, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const streamId = $inject_window_crypto.randomUUID();
        const textInBytes = new TextEncoder().encode(text);
        const totalTextLength = textInBytes.byteLength;
        const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(() => $inject_window_crypto.randomUUID());
        const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);
        const handleProgress = (progress, idx) => {
          var _a2;
          progresses[idx] = progress;
          const totalProgress = progresses.reduce((acc, val) => acc + val, 0);
          (_a2 = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a2 === void 0 ? void 0 : _a2.call(options, totalProgress);
        };
        const writer2 = yield this.streamText({
          streamId,
          totalSize: totalTextLength,
          destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,
          topic: options === null || options === void 0 ? void 0 : options.topic,
          attachedStreamIds: fileIds
        });
        const textChunkSize = Math.floor(STREAM_CHUNK_SIZE / 4);
        const totalTextChunks = Math.ceil(totalTextLength / textChunkSize);
        for (let i2 = 0; i2 < totalTextChunks; i2++) {
          const chunkData = text.slice(i2 * textChunkSize, Math.min((i2 + 1) * textChunkSize, totalTextLength));
          yield this.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
          yield writer2.write(chunkData);
          handleProgress(Math.ceil((i2 + 1) / totalTextChunks), 0);
        }
        yield writer2.close();
        if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {
          yield Promise.all(options.attachments.map((file, idx) => __awaiter(this, void 0, void 0, function* () {
            return this._sendFile(fileIds[idx], file, {
              topic: options.topic,
              mimeType: file.type,
              onProgress: (progress) => {
                handleProgress(progress, idx + 1);
              }
            });
          })));
        }
        return writer2.info;
      });
    }
    /**
     * @internal
     * @experimental CAUTION, might get removed in a minor release
     */
    streamText(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : $inject_window_crypto.randomUUID();
        const info = {
          id: streamId,
          mimeType: "text/plain",
          timestamp: Date.now(),
          topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : "",
          size: options === null || options === void 0 ? void 0 : options.totalSize
        };
        const header = new DataStream_Header({
          streamId,
          mimeType: info.mimeType,
          topic: info.topic,
          timestamp: numberToBigInt(info.timestamp),
          totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),
          contentHeader: {
            case: "textHeader",
            value: new DataStream_TextHeader({
              version: options === null || options === void 0 ? void 0 : options.version,
              attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,
              replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,
              operationType: (options === null || options === void 0 ? void 0 : options.type) === "update" ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE
            })
          }
        });
        const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;
        const packet = new DataPacket({
          destinationIdentities,
          value: {
            case: "streamHeader",
            value: header
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        let chunkId = 0;
        const localP = this;
        const writableStream = new WritableStream({
          // Implement the sink
          write(_ref3) {
            let [textChunk] = _ref3;
            var _a2;
            const textInBytes = new TextEncoder().encode(textChunk);
            if (textInBytes.byteLength > STREAM_CHUNK_SIZE) {
              (_a2 = this.abort) === null || _a2 === void 0 ? void 0 : _a2.call(this);
              throw new Error("chunk size too large");
            }
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
              yield localP.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
              const chunk = new DataStream_Chunk({
                content: textInBytes,
                streamId,
                chunkIndex: numberToBigInt(chunkId)
              });
              const chunkPacket = new DataPacket({
                destinationIdentities,
                value: {
                  case: "streamChunk",
                  value: chunk
                }
              });
              yield localP.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);
              chunkId += 1;
              resolve();
            }));
          },
          close() {
            return __awaiter(this, void 0, void 0, function* () {
              const trailer = new DataStream_Trailer({
                streamId
              });
              const trailerPacket = new DataPacket({
                destinationIdentities,
                value: {
                  case: "streamTrailer",
                  value: trailer
                }
              });
              yield localP.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);
            });
          },
          abort(err) {
            formatAppLog("log", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:20907", "Sink error:", err);
          }
        });
        let onEngineClose = () => __awaiter(this, void 0, void 0, function* () {
          yield writer2.close();
        });
        localP.engine.once(EngineEvent.Closing, onEngineClose);
        const writer2 = new TextStreamWriter(writableStream, info, () => this.engine.off(EngineEvent.Closing, onEngineClose));
        return writer2;
      });
    }
    sendFile(file, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const streamId = $inject_window_crypto.randomUUID();
        yield this._sendFile(streamId, file, options);
        return {
          id: streamId
        };
      });
    }
    _sendFile(streamId, file, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const totalLength = file.size;
        const header = new DataStream_Header({
          totalLength: numberToBigInt(totalLength),
          mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,
          streamId,
          topic: options === null || options === void 0 ? void 0 : options.topic,
          encryptionType: options === null || options === void 0 ? void 0 : options.encryptionType,
          timestamp: numberToBigInt(Date.now()),
          contentHeader: {
            case: "byteHeader",
            value: new DataStream_ByteHeader({
              name: file.name
            })
          }
        });
        const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;
        const packet = new DataPacket({
          destinationIdentities,
          value: {
            case: "streamHeader",
            value: header
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        function read(b2) {
          return new Promise((resolve) => {
            const fr = new FileReader();
            fr.onload = () => {
              resolve(new Uint8Array(fr.result));
            };
            fr.readAsArrayBuffer(b2);
          });
        }
        const totalChunks = Math.ceil(totalLength / STREAM_CHUNK_SIZE);
        for (let i2 = 0; i2 < totalChunks; i2++) {
          const chunkData = yield read(file.slice(i2 * STREAM_CHUNK_SIZE, Math.min((i2 + 1) * STREAM_CHUNK_SIZE, totalLength)));
          yield this.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
          const chunk = new DataStream_Chunk({
            content: chunkData,
            streamId,
            chunkIndex: numberToBigInt(i2)
          });
          const chunkPacket = new DataPacket({
            destinationIdentities,
            value: {
              case: "streamChunk",
              value: chunk
            }
          });
          yield this.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);
          (_b = options === null || options === void 0 ? void 0 : options.onProgress) === null || _b === void 0 ? void 0 : _b.call(options, (i2 + 1) / totalChunks);
        }
        const trailer = new DataStream_Trailer({
          streamId
        });
        const trailerPacket = new DataPacket({
          destinationIdentities,
          value: {
            case: "streamTrailer",
            value: trailer
          }
        });
        yield this.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);
      });
    }
    /**
     * Initiate an RPC call to a remote participant
     * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
     * @returns A promise that resolves with the response payload or rejects with an error.
     * @throws Error on failure. Details in `message`.
     */
    performRpc(_a) {
      return __awaiter(this, arguments, void 0, function(_ref4) {
        var _this5 = this;
        let {
          destinationIdentity,
          method,
          payload,
          responseTimeout = 1e4
        } = _ref4;
        return function* () {
          const maxRoundTripLatency = 2e3;
          return new Promise((resolve, reject) => __awaiter(_this5, void 0, void 0, function* () {
            var _a2, _b, _c, _d;
            if (byteLength(payload) > MAX_PAYLOAD_BYTES) {
              reject(RpcError.builtIn("REQUEST_PAYLOAD_TOO_LARGE"));
              return;
            }
            if (((_b = (_a2 = this.engine.latestJoinResponse) === null || _a2 === void 0 ? void 0 : _a2.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, "1.8.0") < 0) {
              reject(RpcError.builtIn("UNSUPPORTED_SERVER"));
              return;
            }
            const id = $inject_window_crypto.randomUUID();
            yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);
            const ackTimeoutId = setTimeout(() => {
              this.pendingAcks.delete(id);
              reject(RpcError.builtIn("CONNECTION_TIMEOUT"));
              this.pendingResponses.delete(id);
              clearTimeout(responseTimeoutId);
            }, maxRoundTripLatency);
            this.pendingAcks.set(id, {
              resolve: () => {
                clearTimeout(ackTimeoutId);
              },
              participantIdentity: destinationIdentity
            });
            const responseTimeoutId = setTimeout(() => {
              this.pendingResponses.delete(id);
              reject(RpcError.builtIn("RESPONSE_TIMEOUT"));
            }, responseTimeout);
            this.pendingResponses.set(id, {
              resolve: (responsePayload, responseError) => {
                clearTimeout(responseTimeoutId);
                if (this.pendingAcks.has(id)) {
                  formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:21045", "RPC response received before ack", id);
                  this.pendingAcks.delete(id);
                  clearTimeout(ackTimeoutId);
                }
                if (responseError) {
                  reject(responseError);
                } else {
                  resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : "");
                }
              },
              participantIdentity: destinationIdentity
            });
          }));
        }();
      });
    }
    /**
     * @deprecated use `room.registerRpcMethod` instead
     */
    registerRpcMethod(method, handler) {
      if (this.rpcHandlers.has(method)) {
        this.log.warn("you're overriding the RPC handler for method ".concat(method, ", in the future this will throw an error"));
      }
      this.rpcHandlers.set(method, handler);
    }
    /**
     * @deprecated use `room.unregisterRpcMethod` instead
     */
    unregisterRpcMethod(method) {
      this.rpcHandlers.delete(method);
    }
    /**
     * Control who can subscribe to LocalParticipant's published tracks.
     *
     * By default, all participants can subscribe. This allows fine-grained control over
     * who is able to subscribe at a participant and track level.
     *
     * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
     * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
     * will not grant permissions to any participants and will require a subsequent
     * permissions update to allow subscription.
     *
     * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
     *  Takes precedence over [[participantTrackPermissions]] if set to true.
     *  By default this is set to true.
     * @param participantTrackPermissions Full list of individual permissions per
     *  participant/track. Any omitted participants will not receive any permissions.
     */
    setTrackSubscriptionPermissions(allParticipantsAllowed) {
      let participantTrackPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      this.participantTrackPermissions = participantTrackPermissions;
      this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;
      if (!this.engine.client.isDisconnected) {
        this.updateTrackSubscriptionPermissions();
      }
    }
    handleIncomingRpcAck(requestId) {
      const handler = this.pendingAcks.get(requestId);
      if (handler) {
        handler.resolve();
        this.pendingAcks.delete(requestId);
      } else {
        formatAppLog("error", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:21107", "Ack received for unexpected RPC request", requestId);
      }
    }
    handleIncomingRpcResponse(requestId, payload, error) {
      const handler = this.pendingResponses.get(requestId);
      if (handler) {
        handler.resolve(payload, error);
        this.pendingResponses.delete(requestId);
      } else {
        formatAppLog("error", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:21116", "Response received for unexpected RPC request", requestId);
      }
    }
    /** @internal */
    publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcRequest",
            value: new RpcRequest({
              id: requestId,
              method,
              payload,
              responseTimeoutMs: responseTimeout,
              version: 1
            })
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    handleParticipantDisconnected(participantIdentity) {
      for (const [id, {
        participantIdentity: pendingIdentity
      }] of this.pendingAcks) {
        if (pendingIdentity === participantIdentity) {
          this.pendingAcks.delete(id);
        }
      }
      for (const [id, {
        participantIdentity: pendingIdentity,
        resolve
      }] of this.pendingResponses) {
        if (pendingIdentity === participantIdentity) {
          resolve(null, RpcError.builtIn("RECIPIENT_DISCONNECTED"));
          this.pendingResponses.delete(id);
        }
      }
    }
    /** @internal */
    setEnabledPublishCodecs(codecs) {
      this.enabledPublishVideoCodecs = codecs.filter((c2) => c2.mime.split("/")[0].toLowerCase() === "video");
    }
    /** @internal */
    updateInfo(info) {
      if (info.sid !== this.sid) {
        return false;
      }
      if (!super.updateInfo(info)) {
        return false;
      }
      info.tracks.forEach((ti) => {
        var _a, _b;
        const pub = this.trackPublications.get(ti.sid);
        if (pub) {
          const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);
          if (mutedOnServer !== ti.muted) {
            this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {
              mutedOnServer
            }));
            this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);
          }
        }
      });
      return true;
    }
    getPublicationForTrack(track) {
      let publication;
      this.trackPublications.forEach((pub) => {
        const localTrack = pub.track;
        if (!localTrack) {
          return;
        }
        if (track instanceof MediaStreamTrack) {
          if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {
            if (localTrack.mediaStreamTrack === track) {
              publication = pub;
            }
          }
        } else if (track === localTrack) {
          publication = pub;
        }
      });
      return publication;
    }
    waitForPendingPublicationOfSource(source) {
      return __awaiter(this, void 0, void 0, function* () {
        const waitForPendingTimeout = 1e4;
        const startTime = Date.now();
        while (Date.now() < startTime + waitForPendingTimeout) {
          const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find((_ref5) => {
            let [pendingTrack] = _ref5;
            return pendingTrack.source === source;
          });
          if (publishPromiseEntry) {
            return publishPromiseEntry[1];
          }
          yield sleep(20);
        }
      });
    }
  }
  class RemoteTrackPublication extends TrackPublication {
    constructor(kind, ti, autoSubscribe, loggerOptions) {
      super(kind, ti.sid, ti.name, loggerOptions);
      this.track = void 0;
      this.allowed = true;
      this.disabled = false;
      this.currentVideoQuality = VideoQuality.HIGH;
      this.handleEnded = (track) => {
        this.setTrack(void 0);
        this.emit(TrackEvent.Ended, track);
      };
      this.handleVisibilityChange = (visible) => {
        this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(visible), this.logContext);
        this.disabled = !visible;
        this.emitTrackUpdate();
      };
      this.handleVideoDimensionsChange = (dimensions) => {
        this.log.debug("adaptivestream video dimensions ".concat(dimensions.width, "x").concat(dimensions.height), this.logContext);
        this.videoDimensions = dimensions;
        this.emitTrackUpdate();
      };
      this.subscribed = autoSubscribe;
      this.updateInfo(ti);
    }
    /**
     * Subscribe or unsubscribe to this remote track
     * @param subscribed true to subscribe to a track, false to unsubscribe
     */
    setSubscribed(subscribed) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      this.subscribed = subscribed;
      if (subscribed) {
        this.allowed = true;
      }
      const sub = new UpdateSubscription({
        trackSids: [this.trackSid],
        subscribe: this.subscribed,
        participantTracks: [new ParticipantTracks({
          // sending an empty participant id since TrackPublication doesn't keep it
          // this is filled in by the participant that receives this message
          participantSid: "",
          trackSids: [this.trackSid]
        })]
      });
      this.emit(TrackEvent.UpdateSubscription, sub);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
      this.emitPermissionUpdateIfChanged(prevPermission);
    }
    get subscriptionStatus() {
      if (this.subscribed === false) {
        return TrackPublication.SubscriptionStatus.Unsubscribed;
      }
      if (!super.isSubscribed) {
        return TrackPublication.SubscriptionStatus.Desired;
      }
      return TrackPublication.SubscriptionStatus.Subscribed;
    }
    get permissionStatus() {
      return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
    }
    /**
     * Returns true if track is subscribed, and ready for playback
     */
    get isSubscribed() {
      if (this.subscribed === false) {
        return false;
      }
      return super.isSubscribed;
    }
    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
    get isDesired() {
      return this.subscribed !== false;
    }
    get isEnabled() {
      return !this.disabled;
    }
    get isLocal() {
      return false;
    }
    /**
     * disable server from sending down data for this track. this is useful when
     * the participant is off screen, you may disable streaming down their video
     * to reduce bandwidth requirements
     * @param enabled
     */
    setEnabled(enabled) {
      if (!this.isManualOperationAllowed() || this.disabled === !enabled) {
        return;
      }
      this.disabled = !enabled;
      this.emitTrackUpdate();
    }
    /**
     * for tracks that support simulcasting, adjust subscribed quality
     *
     * This indicates the highest quality the client can accept. if network
     * bandwidth does not allow, server will automatically reduce quality to
     * optimize for uninterrupted video
     */
    setVideoQuality(quality) {
      if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {
        return;
      }
      this.currentVideoQuality = quality;
      this.videoDimensions = void 0;
      this.emitTrackUpdate();
    }
    setVideoDimensions(dimensions) {
      var _a, _b;
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
        return;
      }
      if (isRemoteVideoTrack(this.track)) {
        this.videoDimensions = dimensions;
      }
      this.currentVideoQuality = void 0;
      this.emitTrackUpdate();
    }
    setVideoFPS(fps) {
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (!isRemoteVideoTrack(this.track)) {
        return;
      }
      if (this.fps === fps) {
        return;
      }
      this.fps = fps;
      this.emitTrackUpdate();
    }
    get videoQuality() {
      return this.currentVideoQuality;
    }
    /** @internal */
    setTrack(track) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      const prevTrack = this.track;
      if (prevTrack === track) {
        return;
      }
      if (prevTrack) {
        prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        prevTrack.off(TrackEvent.Ended, this.handleEnded);
        prevTrack.detach();
        prevTrack.stopMonitor();
        this.emit(TrackEvent.Unsubscribed, prevTrack);
      }
      super.setTrack(track);
      if (track) {
        track.sid = this.trackSid;
        track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        track.on(TrackEvent.Ended, this.handleEnded);
        this.emit(TrackEvent.Subscribed, track);
      }
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
    setAllowed(allowed) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      this.allowed = allowed;
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
    setSubscriptionError(error) {
      this.emit(TrackEvent.SubscriptionFailed, error);
    }
    /** @internal */
    updateInfo(info) {
      super.updateInfo(info);
      const prevMetadataMuted = this.metadataMuted;
      this.metadataMuted = info.muted;
      if (this.track) {
        this.track.setMuted(info.muted);
      } else if (prevMetadataMuted !== info.muted) {
        this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
      }
    }
    emitSubscriptionUpdateIfChanged(previousStatus) {
      const currentStatus = this.subscriptionStatus;
      if (previousStatus === currentStatus) {
        return;
      }
      this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);
    }
    emitPermissionUpdateIfChanged(previousPermissionStatus) {
      const currentPermissionStatus = this.permissionStatus;
      if (currentPermissionStatus !== previousPermissionStatus) {
        this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);
      }
    }
    isManualOperationAllowed() {
      if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {
        this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext);
        return false;
      }
      if (!this.isDesired) {
        this.log.warn("cannot update track settings when not subscribed", this.logContext);
        return false;
      }
      return true;
    }
    get isAdaptiveStream() {
      return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;
    }
    /* @internal */
    emitTrackUpdate() {
      const settings = new UpdateTrackSettings({
        trackSids: [this.trackSid],
        disabled: this.disabled,
        fps: this.fps
      });
      if (this.videoDimensions) {
        settings.width = Math.ceil(this.videoDimensions.width);
        settings.height = Math.ceil(this.videoDimensions.height);
      } else if (this.currentVideoQuality !== void 0) {
        settings.quality = this.currentVideoQuality;
      } else {
        settings.quality = VideoQuality.HIGH;
      }
      this.emit(TrackEvent.UpdateSettings, settings);
    }
  }
  class RemoteParticipant extends Participant {
    /** @internal */
    static fromParticipantInfo(signalClient, pi, loggerOptions) {
      return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);
    }
    get logContext() {
      return Object.assign(Object.assign({}, super.logContext), {
        rpID: this.sid,
        remoteParticipant: this.identity
      });
    }
    /** @internal */
    constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {
      let kind = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : ParticipantInfo_Kind.STANDARD;
      super(sid, identity || "", name, metadata, attributes, loggerOptions, kind);
      this.signalClient = signalClient;
      this.trackPublications = /* @__PURE__ */ new Map();
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.volumeMap = /* @__PURE__ */ new Map();
    }
    addTrackPublication(publication) {
      super.addTrackPublication(publication);
      publication.on(TrackEvent.UpdateSettings, (settings) => {
        this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
        this.signalClient.sendUpdateTrackSettings(settings);
      });
      publication.on(TrackEvent.UpdateSubscription, (sub) => {
        sub.participantTracks.forEach((pt2) => {
          pt2.participantSid = this.sid;
        });
        this.signalClient.sendUpdateSubscription(sub);
      });
      publication.on(TrackEvent.SubscriptionPermissionChanged, (status) => {
        this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);
      });
      publication.on(TrackEvent.SubscriptionStatusChanged, (status) => {
        this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);
      });
      publication.on(TrackEvent.Subscribed, (track) => {
        this.emit(ParticipantEvent.TrackSubscribed, track, publication);
      });
      publication.on(TrackEvent.Unsubscribed, (previousTrack) => {
        this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);
      });
      publication.on(TrackEvent.SubscriptionFailed, (error) => {
        this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);
      });
    }
    getTrackPublication(source) {
      const track = super.getTrackPublication(source);
      if (track) {
        return track;
      }
    }
    getTrackPublicationByName(name) {
      const track = super.getTrackPublicationByName(name);
      if (track) {
        return track;
      }
    }
    /**
     * sets the volume on the participant's audio track
     * by default, this affects the microphone publication
     * a different source can be passed in as a second argument
     * if no track exists the volume will be applied when the microphone track is added
     */
    setVolume(volume) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
      this.volumeMap.set(source, volume);
      const audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        audioPublication.track.setVolume(volume);
      }
    }
    /**
     * gets the volume on the participant's microphone track
     */
    getVolume() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
      const audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        return audioPublication.track.getVolume();
      }
      return this.volumeMap.get(source);
    }
    /** @internal */
    addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {
      let publication = this.getTrackPublicationBySid(sid);
      if (!publication) {
        if (!sid.startsWith("TR")) {
          this.trackPublications.forEach((p2) => {
            if (!publication && mediaTrack.kind === p2.kind.toString()) {
              publication = p2;
            }
          });
        }
      }
      if (!publication) {
        if (triesLeft === 0) {
          this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: sid
          }));
          this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
          return;
        }
        if (triesLeft === void 0)
          triesLeft = 20;
        setTimeout(() => {
          this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);
        }, 150);
        return;
      }
      if (mediaTrack.readyState === "ended") {
        this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
        return;
      }
      const isVideo = mediaTrack.kind === "video";
      let track;
      if (isVideo) {
        track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);
      } else {
        track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);
      }
      track.source = publication.source;
      track.isMuted = publication.isMuted;
      track.setMediaStream(mediaStream);
      track.start();
      publication.setTrack(track);
      if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {
        track.setVolume(this.volumeMap.get(publication.source));
      }
      return publication;
    }
    /** @internal */
    get hasMetadata() {
      return !!this.participantInfo;
    }
    /**
     * @internal
     */
    getTrackPublicationBySid(sid) {
      return this.trackPublications.get(sid);
    }
    /** @internal */
    updateInfo(info) {
      if (!super.updateInfo(info)) {
        return false;
      }
      const validTracks = /* @__PURE__ */ new Map();
      const newTracks = /* @__PURE__ */ new Map();
      info.tracks.forEach((ti) => {
        var _a, _b;
        let publication = this.getTrackPublicationBySid(ti.sid);
        if (!publication) {
          const kind = Track.kindFromProto(ti.type);
          if (!kind) {
            return;
          }
          publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {
            loggerContextCb: () => this.logContext,
            loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName
          });
          publication.updateInfo(ti);
          newTracks.set(ti.sid, publication);
          const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack) => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));
          if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {
            this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {
              oldTrack: getLogContextFromTrack(existingTrackOfSource),
              newTrack: getLogContextFromTrack(publication)
            }));
          }
          this.addTrackPublication(publication);
        } else {
          publication.updateInfo(ti);
        }
        validTracks.set(ti.sid, publication);
      });
      this.trackPublications.forEach((publication) => {
        if (!validTracks.has(publication.trackSid)) {
          this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
          this.unpublishTrack(publication.trackSid, true);
        }
      });
      newTracks.forEach((publication) => {
        this.emit(ParticipantEvent.TrackPublished, publication);
      });
      return true;
    }
    /** @internal */
    unpublishTrack(sid, sendUnpublish) {
      const publication = this.trackPublications.get(sid);
      if (!publication) {
        return;
      }
      const {
        track
      } = publication;
      if (track) {
        track.stop();
        publication.setTrack(void 0);
      }
      this.trackPublications.delete(sid);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(sid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(sid);
          break;
      }
      if (sendUnpublish) {
        this.emit(ParticipantEvent.TrackUnpublished, publication);
      }
    }
    /**
     * @internal
     */
    setAudioOutput(output) {
      return __awaiter(this, void 0, void 0, function* () {
        this.audioOutput = output;
        const promises = [];
        this.audioTrackPublications.forEach((pub) => {
          var _a;
          if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {
            promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : "default"));
          }
        });
        yield Promise.all(promises);
      });
    }
    /** @internal */
    emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
        event,
        args
      }));
      return super.emit(event, ...args);
    }
  }
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2["Disconnected"] = "disconnected";
    ConnectionState2["Connecting"] = "connecting";
    ConnectionState2["Connected"] = "connected";
    ConnectionState2["Reconnecting"] = "reconnecting";
    ConnectionState2["SignalReconnecting"] = "signalReconnecting";
  })(ConnectionState || (ConnectionState = {}));
  const connectionReconcileFrequency = 4 * 1e3;
  class Room extends eventsExports.EventEmitter {
    /**
     * Creates a new Room, the primary construct for a LiveKit session.
     * @param options
     */
    constructor(options) {
      var _this;
      var _a, _b, _c;
      super();
      _this = this;
      this.state = ConnectionState.Disconnected;
      this.activeSpeakers = [];
      this.isE2EEEnabled = false;
      this.audioEnabled = true;
      this.isVideoPlaybackBlocked = false;
      this.log = livekitLogger;
      this.bufferedEvents = [];
      this.isResuming = false;
      this.byteStreamControllers = /* @__PURE__ */ new Map();
      this.textStreamControllers = /* @__PURE__ */ new Map();
      this.byteStreamHandlers = /* @__PURE__ */ new Map();
      this.textStreamHandlers = /* @__PURE__ */ new Map();
      this.rpcHandlers = /* @__PURE__ */ new Map();
      this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {
        var _a2;
        if (!isBrowserSupported()) {
          if (isReactNative()) {
            throw Error("WebRTC isn't detected, have you called registerGlobals?");
          } else {
            throw Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
          }
        }
        const unlockDisconnect = yield this.disconnectLock.lock();
        if (this.state === ConnectionState.Connected) {
          this.log.info("already connected to room ".concat(this.name), this.logContext);
          unlockDisconnect();
          return Promise.resolve();
        }
        if (this.connectFuture) {
          unlockDisconnect();
          return this.connectFuture.promise;
        }
        this.setAndEmitConnectionState(ConnectionState.Connecting);
        if (((_a2 = this.regionUrlProvider) === null || _a2 === void 0 ? void 0 : _a2.getServerUrl().toString()) !== url) {
          this.regionUrl = void 0;
          this.regionUrlProvider = void 0;
        }
        if (isCloud(new URL(url))) {
          if (this.regionUrlProvider === void 0) {
            this.regionUrlProvider = new RegionUrlProvider(url, token);
          } else {
            this.regionUrlProvider.updateToken(token);
          }
          this.regionUrlProvider.fetchRegionSettings().then((settings) => {
            var _a3;
            (_a3 = this.regionUrlProvider) === null || _a3 === void 0 ? void 0 : _a3.setServerReportedRegions(settings);
          }).catch((e2) => {
            this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
              error: e2
            }));
          });
        }
        const connectFn = (resolve, reject, regionUrl2) => __awaiter(this, void 0, void 0, function* () {
          var _a3, _b2;
          if (this.abortController) {
            this.abortController.abort();
          }
          const abortController = new AbortController();
          this.abortController = abortController;
          unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();
          try {
            yield this.attemptConnection(regionUrl2 !== null && regionUrl2 !== void 0 ? regionUrl2 : url, token, opts, abortController);
            this.abortController = void 0;
            resolve();
          } catch (e2) {
            if (this.regionUrlProvider && e2 instanceof ConnectionError && e2.reason !== ConnectionErrorReason.Cancelled && e2.reason !== ConnectionErrorReason.NotAllowed) {
              let nextUrl = null;
              try {
                nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a3 = this.abortController) === null || _a3 === void 0 ? void 0 : _a3.signal);
              } catch (error) {
                if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {
                  this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
                  reject(error);
                  return;
                }
              }
              if (nextUrl && !((_b2 = this.abortController) === null || _b2 === void 0 ? void 0 : _b2.signal.aborted)) {
                this.log.info("Initial connection failed with ConnectionError: ".concat(e2.message, ". Retrying with another region: ").concat(nextUrl), this.logContext);
                this.recreateEngine();
                yield connectFn(resolve, reject, nextUrl);
              } else {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e2));
                reject(e2);
              }
            } else {
              let disconnectReason = DisconnectReason.UNKNOWN_REASON;
              if (e2 instanceof ConnectionError) {
                disconnectReason = getDisconnectReasonFromConnectionError(e2);
              }
              this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);
              reject(e2);
            }
          }
        });
        const regionUrl = this.regionUrl;
        this.regionUrl = void 0;
        this.connectFuture = new Future((resolve, reject) => {
          connectFn(resolve, reject, regionUrl);
        }, () => {
          this.clearConnectionFutures();
        });
        return this.connectFuture.promise;
      });
      this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2, _c2;
        const joinResponse = yield engine.join(url, token, {
          autoSubscribe: connectOptions.autoSubscribe,
          adaptiveStream: typeof roomOptions.adaptiveStream === "object" ? true : roomOptions.adaptiveStream,
          maxRetries: connectOptions.maxRetries,
          e2eeEnabled: !!this.e2eeManager,
          websocketTimeout: connectOptions.websocketTimeout
        }, abortController.signal);
        let serverInfo = joinResponse.serverInfo;
        if (!serverInfo) {
          serverInfo = {
            version: joinResponse.serverVersion,
            region: joinResponse.serverRegion
          };
        }
        this.serverInfo = serverInfo;
        this.log.debug("connected to Livekit Server ".concat(Object.entries(serverInfo).map((_ref) => {
          let [key, value] = _ref;
          return "".concat(key, ": ").concat(value);
        }).join(", ")), {
          room: (_a2 = joinResponse.room) === null || _a2 === void 0 ? void 0 : _a2.name,
          roomSid: (_b2 = joinResponse.room) === null || _b2 === void 0 ? void 0 : _b2.sid,
          identity: (_c2 = joinResponse.participant) === null || _c2 === void 0 ? void 0 : _c2.identity
        });
        if (!serverInfo.version) {
          throw new UnsupportedServer("unknown server version");
        }
        if (serverInfo.version === "0.15.1" && this.options.dynacast) {
          this.log.debug("disabling dynacast due to server version", this.logContext);
          roomOptions.dynacast = false;
        }
        return joinResponse;
      });
      this.applyJoinResponse = (joinResponse) => {
        const pi = joinResponse.participant;
        this.localParticipant.sid = pi.sid;
        this.localParticipant.identity = pi.identity;
        this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);
        if (this.options.e2ee && this.e2eeManager) {
          try {
            this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);
          } catch (e2) {
            this.log.error(e2 instanceof Error ? e2.message : "Could not set SifTrailer", Object.assign(Object.assign({}, this.logContext), {
              error: e2
            }));
          }
        }
        this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);
        if (joinResponse.room) {
          this.handleRoomUpdate(joinResponse.room);
        }
      };
      this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2;
        if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.pendingReconnect)) {
          this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext);
          this.recreateEngine();
        } else {
          this.maybeCreateEngine();
        }
        if ((_b2 = this.regionUrlProvider) === null || _b2 === void 0 ? void 0 : _b2.isCloud()) {
          this.engine.setRegionUrlProvider(this.regionUrlProvider);
        }
        this.acquireAudioContext();
        this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);
        if (this.connOptions.rtcConfig) {
          this.engine.rtcConfig = this.connOptions.rtcConfig;
        }
        if (this.connOptions.peerConnectionTimeout) {
          this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;
        }
        try {
          const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);
          this.applyJoinResponse(joinResponse);
          this.setupLocalParticipantEvents();
          this.emit(RoomEvent.SignalConnected);
        } catch (err) {
          yield this.engine.close();
          this.recreateEngine();
          const resultingError = new ConnectionError("could not establish signal connection", ConnectionErrorReason.ServerUnreachable);
          if (err instanceof Error) {
            resultingError.message = "".concat(resultingError.message, ": ").concat(err.message);
          }
          if (err instanceof ConnectionError) {
            resultingError.reason = err.reason;
            resultingError.status = err.status;
          }
          this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
            error: err
          }));
          throw resultingError;
        }
        if (abortController.signal.aborted) {
          yield this.engine.close();
          this.recreateEngine();
          throw new ConnectionError("Connection attempt aborted", ConnectionErrorReason.Cancelled);
        }
        try {
          yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);
        } catch (e2) {
          yield this.engine.close();
          this.recreateEngine();
          throw e2;
        }
        if (isWeb() && this.options.disconnectOnPageLeave) {
          window.addEventListener("pagehide", this.onPageLeave);
          window.addEventListener("beforeunload", this.onPageLeave);
        }
        if (isWeb()) {
          document.addEventListener("freeze", this.onPageLeave);
        }
        this.setAndEmitConnectionState(ConnectionState.Connected);
        this.emit(RoomEvent.Connected);
        this.registerConnectionReconcile();
      });
      this.disconnect = function() {
        for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {
          args_1[_key] = arguments[_key];
        }
        return __awaiter(_this, [...args_1], void 0, function() {
          var _this2 = this;
          let stopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          return function* () {
            var _a2, _b2, _c2, _d;
            const unlock = yield _this2.disconnectLock.lock();
            try {
              if (_this2.state === ConnectionState.Disconnected) {
                _this2.log.debug("already disconnected", _this2.logContext);
                return;
              }
              _this2.log.info("disconnect from room", Object.assign({}, _this2.logContext));
              if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {
                _this2.log.warn("abort connection attempt", _this2.logContext);
                (_a2 = _this2.abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
                (_c2 = (_b2 = _this2.connectFuture) === null || _b2 === void 0 ? void 0 : _b2.reject) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, new ConnectionError("Client initiated disconnect", ConnectionErrorReason.Cancelled));
                _this2.connectFuture = void 0;
              }
              if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {
                yield _this2.engine.client.sendLeave();
              }
              if (_this2.engine) {
                yield _this2.engine.close();
              }
              _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);
              _this2.engine = void 0;
            } finally {
              unlock();
            }
          }();
        });
      };
      this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {
        this.log.info("Page leave detected, disconnecting", this.logContext);
        yield this.disconnect();
      });
      this.startAudio = () => __awaiter(this, void 0, void 0, function* () {
        const elements = [];
        const browser = getBrowser();
        if (browser && browser.os === "iOS") {
          const audioId = "livekit-dummy-audio-el";
          let dummyAudioEl = document.getElementById(audioId);
          if (!dummyAudioEl) {
            dummyAudioEl = document.createElement("audio");
            dummyAudioEl.id = audioId;
            dummyAudioEl.autoplay = true;
            dummyAudioEl.hidden = true;
            const track = getEmptyAudioStreamTrack();
            track.enabled = true;
            const stream = new MediaStream([track]);
            dummyAudioEl.srcObject = stream;
            document.addEventListener("visibilitychange", () => {
              if (!dummyAudioEl) {
                return;
              }
              dummyAudioEl.srcObject = document.hidden ? null : stream;
              if (!document.hidden) {
                this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext);
                this.startAudio();
              }
            });
            document.body.append(dummyAudioEl);
            this.once(RoomEvent.Disconnected, () => {
              dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();
              dummyAudioEl = null;
            });
          }
          elements.push(dummyAudioEl);
        }
        this.remoteParticipants.forEach((p2) => {
          p2.audioTrackPublications.forEach((t2) => {
            if (t2.track) {
              t2.track.attachedElements.forEach((e2) => {
                elements.push(e2);
              });
            }
          });
        });
        try {
          yield Promise.all([this.acquireAudioContext(), ...elements.map((e2) => {
            e2.muted = false;
            return e2.play();
          })]);
          this.handleAudioPlaybackStarted();
        } catch (err) {
          this.handleAudioPlaybackFailed(err);
          throw err;
        }
      });
      this.startVideo = () => __awaiter(this, void 0, void 0, function* () {
        const elements = [];
        for (const p2 of this.remoteParticipants.values()) {
          p2.videoTrackPublications.forEach((tr) => {
            var _a2;
            (_a2 = tr.track) === null || _a2 === void 0 ? void 0 : _a2.attachedElements.forEach((el) => {
              if (!elements.includes(el)) {
                elements.push(el);
              }
            });
          });
        }
        yield Promise.all(elements.map((el) => el.play())).then(() => {
          this.handleVideoPlaybackStarted();
        }).catch((e2) => {
          if (e2.name === "NotAllowedError") {
            this.handleVideoPlaybackFailed();
          } else {
            this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
          }
        });
      });
      this.handleRestarting = () => {
        this.clearConnectionReconcile();
        this.isResuming = false;
        for (const p2 of this.remoteParticipants.values()) {
          this.handleParticipantDisconnected(p2.identity, p2);
        }
        if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
          this.emit(RoomEvent.Reconnecting);
        }
      };
      this.handleSignalRestarted = (joinResponse) => __awaiter(this, void 0, void 0, function* () {
        this.log.debug("signal reconnected to server, region ".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {
          region: joinResponse.serverRegion
        }));
        this.bufferedEvents = [];
        this.applyJoinResponse(joinResponse);
        try {
          yield this.localParticipant.republishAllTracks(void 0, true);
        } catch (error) {
          this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
            error
          }));
        }
        try {
          yield this.engine.waitForRestarted();
          this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
            region: joinResponse.serverRegion
          }));
        } catch (_a2) {
          return;
        }
        this.setAndEmitConnectionState(ConnectionState.Connected);
        this.emit(RoomEvent.Reconnected);
        this.registerConnectionReconcile();
        this.emitBufferedEvents();
      });
      this.handleParticipantUpdates = (participantInfos) => {
        participantInfos.forEach((info) => {
          var _a2;
          if (info.identity === this.localParticipant.identity) {
            this.localParticipant.updateInfo(info);
            return;
          }
          if (info.identity === "") {
            info.identity = (_a2 = this.sidToIdentity.get(info.sid)) !== null && _a2 !== void 0 ? _a2 : "";
          }
          let remoteParticipant = this.remoteParticipants.get(info.identity);
          if (info.state === ParticipantInfo_State.DISCONNECTED) {
            this.handleParticipantDisconnected(info.identity, remoteParticipant);
          } else {
            remoteParticipant = this.getOrCreateParticipant(info.identity, info);
          }
        });
      };
      this.handleActiveSpeakersUpdate = (speakers) => {
        const activeSpeakers = [];
        const seenSids = {};
        speakers.forEach((speaker) => {
          seenSids[speaker.sid] = true;
          if (speaker.sid === this.localParticipant.sid) {
            this.localParticipant.audioLevel = speaker.level;
            this.localParticipant.setIsSpeaking(true);
            activeSpeakers.push(this.localParticipant);
          } else {
            const p2 = this.getRemoteParticipantBySid(speaker.sid);
            if (p2) {
              p2.audioLevel = speaker.level;
              p2.setIsSpeaking(true);
              activeSpeakers.push(p2);
            }
          }
        });
        if (!seenSids[this.localParticipant.sid]) {
          this.localParticipant.audioLevel = 0;
          this.localParticipant.setIsSpeaking(false);
        }
        this.remoteParticipants.forEach((p2) => {
          if (!seenSids[p2.sid]) {
            p2.audioLevel = 0;
            p2.setIsSpeaking(false);
          }
        });
        this.activeSpeakers = activeSpeakers;
        this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleSpeakersChanged = (speakerUpdates) => {
        const lastSpeakers = /* @__PURE__ */ new Map();
        this.activeSpeakers.forEach((p2) => {
          const remoteParticipant = this.remoteParticipants.get(p2.identity);
          if (remoteParticipant && remoteParticipant.sid !== p2.sid) {
            return;
          }
          lastSpeakers.set(p2.sid, p2);
        });
        speakerUpdates.forEach((speaker) => {
          let p2 = this.getRemoteParticipantBySid(speaker.sid);
          if (speaker.sid === this.localParticipant.sid) {
            p2 = this.localParticipant;
          }
          if (!p2) {
            return;
          }
          p2.audioLevel = speaker.level;
          p2.setIsSpeaking(speaker.active);
          if (speaker.active) {
            lastSpeakers.set(speaker.sid, p2);
          } else {
            lastSpeakers.delete(speaker.sid);
          }
        });
        const activeSpeakers = Array.from(lastSpeakers.values());
        activeSpeakers.sort((a2, b2) => b2.audioLevel - a2.audioLevel);
        this.activeSpeakers = activeSpeakers;
        this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleStreamStateUpdate = (streamStateUpdate) => {
        streamStateUpdate.streamStates.forEach((streamState) => {
          const participant = this.getRemoteParticipantBySid(streamState.participantSid);
          if (!participant) {
            return;
          }
          const pub = participant.getTrackPublicationBySid(streamState.trackSid);
          if (!pub || !pub.track) {
            return;
          }
          const newStreamState = Track.streamStateFromProto(streamState.state);
          if (newStreamState !== pub.track.streamState) {
            pub.track.streamState = newStreamState;
            participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
            this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
          }
        });
      };
      this.handleSubscriptionPermissionUpdate = (update) => {
        const participant = this.getRemoteParticipantBySid(update.participantSid);
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(update.trackSid);
        if (!pub) {
          return;
        }
        pub.setAllowed(update.allowed);
      };
      this.handleSubscriptionError = (update) => {
        const participant = Array.from(this.remoteParticipants.values()).find((p2) => p2.trackPublications.has(update.trackSid));
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(update.trackSid);
        if (!pub) {
          return;
        }
        pub.setSubscriptionError(update.err);
      };
      this.handleDataPacket = (packet) => {
        const participant = this.remoteParticipants.get(packet.participantIdentity);
        if (packet.value.case === "user") {
          this.handleUserPacket(participant, packet.value.value, packet.kind);
        } else if (packet.value.case === "transcription") {
          this.handleTranscription(participant, packet.value.value);
        } else if (packet.value.case === "sipDtmf") {
          this.handleSipDtmf(participant, packet.value.value);
        } else if (packet.value.case === "chatMessage") {
          this.handleChatMessage(participant, packet.value.value);
        } else if (packet.value.case === "metrics") {
          this.handleMetrics(packet.value.value, participant);
        } else if (packet.value.case === "streamHeader") {
          this.handleStreamHeader(packet.value.value, packet.participantIdentity);
        } else if (packet.value.case === "streamChunk") {
          this.handleStreamChunk(packet.value.value);
        } else if (packet.value.case === "streamTrailer") {
          this.handleStreamTrailer(packet.value.value);
        } else if (packet.value.case === "rpcRequest") {
          const rpc = packet.value.value;
          this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);
        }
      };
      this.handleUserPacket = (participant, userPacket, kind) => {
        this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);
      };
      this.handleSipDtmf = (participant, dtmf) => {
        this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);
      };
      this.bufferedSegments = /* @__PURE__ */ new Map();
      this.handleTranscription = (_remoteParticipant, transcription) => {
        const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);
        const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);
        const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);
        publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);
        this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);
      };
      this.handleChatMessage = (participant, chatMessage) => {
        const msg = extractChatMessage(chatMessage);
        this.emit(RoomEvent.ChatMessage, msg, participant);
      };
      this.handleMetrics = (metrics, participant) => {
        this.emit(RoomEvent.MetricsReceived, metrics, participant);
      };
      this.handleAudioPlaybackStarted = () => {
        if (this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = true;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, true);
      };
      this.handleAudioPlaybackFailed = (e2) => {
        this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
          error: e2
        }));
        if (!this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = false;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, false);
      };
      this.handleVideoPlaybackStarted = () => {
        if (this.isVideoPlaybackBlocked) {
          this.isVideoPlaybackBlocked = false;
          this.emit(RoomEvent.VideoPlaybackStatusChanged, true);
        }
      };
      this.handleVideoPlaybackFailed = () => {
        if (!this.isVideoPlaybackBlocked) {
          this.isVideoPlaybackBlocked = true;
          this.emit(RoomEvent.VideoPlaybackStatusChanged, false);
        }
      };
      this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2;
        const previousDevices = DeviceManager.getInstance().previousDevices;
        const availableDevices = yield DeviceManager.getInstance().getDevices(void 0, false);
        const browser = getBrowser();
        if ((browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && browser.os !== "iOS") {
          for (let availableDevice of availableDevices) {
            const previousDevice = previousDevices.find((info) => info.deviceId === availableDevice.deviceId);
            if (previousDevice && previousDevice.label !== "" && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {
              if (this.getActiveDevice(availableDevice.kind) === "default") {
                this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);
              }
            }
          }
        }
        const kinds = ["audiooutput", "audioinput", "videoinput"];
        for (let kind of kinds) {
          const devicesOfKind = availableDevices.filter((d2) => d2.kind === kind);
          const activeDevice = this.getActiveDevice(kind);
          if (activeDevice === ((_a2 = previousDevices.filter((info) => info.kind === kind)[0]) === null || _a2 === void 0 ? void 0 : _a2.deviceId)) {
            if (devicesOfKind.length > 0 && ((_b2 = devicesOfKind[0]) === null || _b2 === void 0 ? void 0 : _b2.deviceId) !== activeDevice) {
              yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
              continue;
            }
          }
          if (kind === "audioinput" && !isSafari() || kind === "videoinput") {
            continue;
          }
          if (devicesOfKind.length > 0 && !devicesOfKind.find((deviceInfo) => deviceInfo.deviceId === this.getActiveDevice(kind))) {
            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
          }
        }
        this.emit(RoomEvent.MediaDevicesChanged);
      });
      this.handleRoomUpdate = (room) => {
        const oldRoom = this.roomInfo;
        this.roomInfo = room;
        if (oldRoom && oldRoom.metadata !== room.metadata) {
          this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);
        }
        if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {
          this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);
        }
      };
      this.handleConnectionQualityUpdate = (update) => {
        update.updates.forEach((info) => {
          if (info.participantSid === this.localParticipant.sid) {
            this.localParticipant.setConnectionQuality(info.quality);
            return;
          }
          const participant = this.getRemoteParticipantBySid(info.participantSid);
          if (participant) {
            participant.setConnectionQuality(info.quality);
          }
        });
      };
      this.onLocalParticipantMetadataChanged = (metadata) => {
        this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
      };
      this.onLocalParticipantNameChanged = (name) => {
        this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);
      };
      this.onLocalAttributesChanged = (changedAttributes) => {
        this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);
      };
      this.onLocalTrackMuted = (pub) => {
        this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);
      };
      this.onLocalTrackUnmuted = (pub) => {
        this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);
      };
      this.onTrackProcessorUpdate = (processor) => {
        var _a2;
        (_a2 = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a2 === void 0 ? void 0 : _a2.call(processor, this);
      };
      this.onLocalTrackPublished = (pub) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2, _c2, _d, _e2, _f;
        (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
        (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.on(TrackEvent.Restarted, this.onLocalTrackRestarted);
        (_e2 = (_d = (_c2 = pub.track) === null || _c2 === void 0 ? void 0 : _c2.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e2 === void 0 ? void 0 : _e2.call(_d, this);
        this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);
        if (isLocalAudioTrack(pub.track)) {
          const trackIsSilent = yield pub.track.checkForSilence();
          if (trackIsSilent) {
            this.emit(RoomEvent.LocalAudioSilenceDetected, pub);
          }
        }
        const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);
        const deviceKind = sourceToKind(pub.source);
        if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
          this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
          this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
        }
      });
      this.onLocalTrackUnpublished = (pub) => {
        var _a2, _b2;
        (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
        (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.off(TrackEvent.Restarted, this.onLocalTrackRestarted);
        this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
      };
      this.onLocalTrackRestarted = (track) => __awaiter(this, void 0, void 0, function* () {
        const deviceId = yield track.getDeviceId(false);
        const deviceKind = sourceToKind(track.source);
        if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
          this.log.debug("local track restarted, setting ".concat(deviceKind, " ").concat(deviceId, " active"), this.logContext);
          this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
          this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
        }
      });
      this.onLocalConnectionQualityChanged = (quality) => {
        this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
      };
      this.onMediaDevicesError = (e2) => {
        this.emit(RoomEvent.MediaDevicesError, e2);
      };
      this.onLocalParticipantPermissionsChanged = (prevPermissions) => {
        this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);
      };
      this.onLocalChatMessageSent = (msg) => {
        this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);
      };
      this.setMaxListeners(100);
      this.remoteParticipants = /* @__PURE__ */ new Map();
      this.sidToIdentity = /* @__PURE__ */ new Map();
      this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);
      this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);
      this.transcriptionReceivedTimes = /* @__PURE__ */ new Map();
      this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);
      this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);
      this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);
      this.maybeCreateEngine();
      this.disconnectLock = new _$1();
      this.localParticipant = new LocalParticipant("", "", this.engine, this.options, this.rpcHandlers);
      if (this.options.videoCaptureDefaults.deviceId) {
        this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));
      }
      if (this.options.audioCaptureDefaults.deviceId) {
        this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));
      }
      if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {
        this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e2) => this.log.warn("Could not set audio output: ".concat(e2.message), this.logContext));
      }
      if (this.options.e2ee) {
        this.setupE2EE();
      }
      if (isWeb()) {
        const abortController = new AbortController();
        (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener("devicechange", this.handleDeviceChange, {
          signal: abortController.signal
        });
        if (Room.cleanupRegistry) {
          Room.cleanupRegistry.register(this, () => {
            abortController.abort();
          });
        }
      }
    }
    registerTextStreamHandler(topic, callback) {
      if (this.textStreamHandlers.has(topic)) {
        throw new TypeError('A text stream handler for topic "'.concat(topic, '" has already been set.'));
      }
      this.textStreamHandlers.set(topic, callback);
    }
    unregisterTextStreamHandler(topic) {
      this.textStreamHandlers.delete(topic);
    }
    registerByteStreamHandler(topic, callback) {
      if (this.byteStreamHandlers.has(topic)) {
        throw new TypeError('A byte stream handler for topic "'.concat(topic, '" has already been set.'));
      }
      this.byteStreamHandlers.set(topic, callback);
    }
    unregisterByteStreamHandler(topic) {
      this.byteStreamHandlers.delete(topic);
    }
    /**
     * Establishes the participant as a receiver for calls of the specified RPC method.
     * Will overwrite any existing callback for the same method.
     *
     * @param method - The name of the indicated RPC method
     * @param handler - Will be invoked when an RPC request for this method is received
     * @returns A promise that resolves when the method is successfully registered
     * @throws {Error} if the handler for a specific method has already been registered already
     *
     * @example
     * ```typescript
     * room.localParticipant?.registerRpcMethod(
     *   'greet',
     *   async (data: RpcInvocationData) => {
     *     __f__('log','at node_modules/livekit-client/dist/livekit-client.esm.mjs:22580',`Received greeting from ${data.callerIdentity}: ${data.payload}`);
     *     return `Hello, ${data.callerIdentity}!`;
     *   }
     * );
     * ```
     *
     * The handler should return a Promise that resolves to a string.
     * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
     *
     * You may throw errors of type `RpcError` with a string `message` in the handler,
     * and they will be received on the caller's side with the message intact.
     * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
     */
    registerRpcMethod(method, handler) {
      if (this.rpcHandlers.has(method)) {
        throw Error("RPC handler already registered for method ".concat(method, ", unregisterRpcMethod before trying to register again"));
      }
      this.rpcHandlers.set(method, handler);
    }
    /**
     * Unregisters a previously registered RPC method.
     *
     * @param method - The name of the RPC method to unregister
     */
    unregisterRpcMethod(method) {
      this.rpcHandlers.delete(method);
    }
    handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version2) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.engine.publishRpcAck(callerIdentity, requestId);
        if (version2 !== 1) {
          yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_VERSION"));
          return;
        }
        const handler = this.rpcHandlers.get(method);
        if (!handler) {
          yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_METHOD"));
          return;
        }
        let responseError = null;
        let responsePayload = null;
        try {
          const response = yield handler({
            requestId,
            callerIdentity,
            payload,
            responseTimeout
          });
          if (byteLength(response) > MAX_PAYLOAD_BYTES) {
            responseError = RpcError.builtIn("RESPONSE_PAYLOAD_TOO_LARGE");
            formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:22630", "RPC Response payload too large for ".concat(method));
          } else {
            responsePayload = response;
          }
        } catch (error) {
          if (error instanceof RpcError) {
            responseError = error;
          } else {
            formatAppLog("warn", "at node_modules/livekit-client/dist/livekit-client.esm.mjs:22638", "Uncaught error returned by RPC handler for ".concat(method, ". Returning APPLICATION_ERROR instead."), error);
            responseError = RpcError.builtIn("APPLICATION_ERROR");
          }
        }
        yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);
      });
    }
    /**
     * @experimental
     */
    setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.e2eeManager) {
          yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);
          if (this.localParticipant.identity !== "") {
            this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);
          }
        } else {
          throw Error("e2ee not configured, please set e2ee settings within the room options");
        }
      });
    }
    setupE2EE() {
      var _a;
      if (this.options.e2ee) {
        if ("e2eeManager" in this.options.e2ee) {
          this.e2eeManager = this.options.e2ee.e2eeManager;
        } else {
          this.e2eeManager = new E2EEManager(this.options.e2ee);
        }
        this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant) => {
          if (isLocalParticipant(participant)) {
            this.isE2EEEnabled = enabled;
          }
          this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);
        });
        this.e2eeManager.on(EncryptionEvent.EncryptionError, (error) => this.emit(RoomEvent.EncryptionError, error));
        (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);
      }
    }
    get logContext() {
      var _a;
      return {
        room: this.name,
        roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,
        participant: this.localParticipant.identity,
        pID: this.localParticipant.sid
      };
    }
    /**
     * if the current room has a participant with `recorder: true` in its JWT grant
     **/
    get isRecording() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * server assigned unique room id.
     * returns once a sid has been issued by the server.
     */
    getSid() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state === ConnectionState.Disconnected) {
          return "";
        }
        if (this.roomInfo && this.roomInfo.sid !== "") {
          return this.roomInfo.sid;
        }
        return new Promise((resolve, reject) => {
          const handleRoomUpdate = (roomInfo) => {
            if (roomInfo.sid !== "") {
              this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
              resolve(roomInfo.sid);
            }
          };
          this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);
          this.once(RoomEvent.Disconnected, () => {
            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
            reject("Room disconnected before room server id was available");
          });
        });
      });
    }
    /** user assigned name, derived from JWT token */
    get name() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "";
    }
    /** room metadata */
    get metadata() {
      var _a;
      return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;
    }
    get numParticipants() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;
    }
    get numPublishers() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;
    }
    maybeCreateEngine() {
      if (this.engine && !this.engine.isClosed) {
        return;
      }
      this.engine = new RTCEngine(this.options);
      this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {
        this.onTrackAdded(mediaTrack, stream, receiver);
      }).on(EngineEvent.Disconnected, (reason) => {
        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);
      }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
        this.clearConnectionReconcile();
        this.isResuming = true;
        this.log.info("Resuming signal connection", this.logContext);
        if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {
          this.emit(RoomEvent.SignalReconnecting);
        }
      }).on(EngineEvent.Resumed, () => {
        this.registerConnectionReconcile();
        this.isResuming = false;
        this.log.info("Resumed signal connection", this.logContext);
        this.updateSubscriptions();
        this.emitBufferedEvents();
        if (this.setAndEmitConnectionState(ConnectionState.Connected)) {
          this.emit(RoomEvent.Reconnected);
        }
      }).on(EngineEvent.SignalResumed, () => {
        this.bufferedEvents = [];
        if (this.state === ConnectionState.Reconnecting || this.isResuming) {
          this.sendSyncState();
        }
      }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {
        if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
          this.emit(RoomEvent.Reconnecting);
        }
      }).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {
        this.emit(RoomEvent.DCBufferStatusChanged, status, kind);
      }).on(EngineEvent.LocalTrackSubscribed, (subscribedSid) => {
        const trackPublication = this.localParticipant.getTrackPublications().find((_ref2) => {
          let {
            trackSid
          } = _ref2;
          return trackSid === subscribedSid;
        });
        if (!trackPublication) {
          this.log.warn("could not find local track subscription for subscribed event", this.logContext);
          return;
        }
        this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);
        this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);
      });
      if (this.localParticipant) {
        this.localParticipant.setupEngine(this.engine);
      }
      if (this.e2eeManager) {
        this.e2eeManager.setupEngine(this.engine);
      }
    }
    /**
     * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
     * In particular, it requests device permissions by default if needed
     * and makes sure the returned device does not consist of dummy devices
     * @param kind
     * @returns a list of available local devices
     */
    static getLocalDevices(kind) {
      let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return DeviceManager.getInstance().getDevices(kind, requestPermissions);
    }
    /**
     * prepareConnection should be called as soon as the page is loaded, in order
     * to speed up the connection attempt. This function will
     * - perform DNS resolution and pre-warm the DNS cache
     * - establish TLS connection and cache TLS keys
     *
     * With LiveKit Cloud, it will also determine the best edge data center for
     * the current client to connect to if a token is provided.
     */
    prepareConnection(url, token) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state !== ConnectionState.Disconnected) {
          return;
        }
        this.log.debug("prepareConnection to ".concat(url), this.logContext);
        try {
          if (isCloud(new URL(url)) && token) {
            this.regionUrlProvider = new RegionUrlProvider(url, token);
            const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();
            if (regionUrl && this.state === ConnectionState.Disconnected) {
              this.regionUrl = regionUrl;
              yield fetch(toHttpUrl(regionUrl), {
                method: "HEAD"
              });
              this.log.debug("prepared connection to ".concat(regionUrl), this.logContext);
            }
          } else {
            yield fetch(toHttpUrl(url), {
              method: "HEAD"
            });
          }
        } catch (e2) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: e2
          }));
        }
      });
    }
    /**
     * retrieves a participant by identity
     * @param identity
     * @returns
     */
    getParticipantByIdentity(identity) {
      if (this.localParticipant.identity === identity) {
        return this.localParticipant;
      }
      return this.remoteParticipants.get(identity);
    }
    clearConnectionFutures() {
      this.connectFuture = void 0;
    }
    /**
     * @internal for testing
     */
    simulateScenario(scenario, arg) {
      return __awaiter(this, void 0, void 0, function* () {
        let postAction = () => {
        };
        let req;
        switch (scenario) {
          case "signal-reconnect":
            yield this.engine.client.handleOnClose("simulate disconnect");
            break;
          case "speaker":
            req = new SimulateScenario({
              scenario: {
                case: "speakerUpdate",
                value: 3
              }
            });
            break;
          case "node-failure":
            req = new SimulateScenario({
              scenario: {
                case: "nodeFailure",
                value: true
              }
            });
            break;
          case "server-leave":
            req = new SimulateScenario({
              scenario: {
                case: "serverLeave",
                value: true
              }
            });
            break;
          case "migration":
            req = new SimulateScenario({
              scenario: {
                case: "migration",
                value: true
              }
            });
            break;
          case "resume-reconnect":
            this.engine.failNext();
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
            break;
          case "disconnect-signal-on-resume":
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              yield this.engine.client.handleOnClose("simulate resume-disconnect");
            });
            req = new SimulateScenario({
              scenario: {
                case: "disconnectSignalOnResume",
                value: true
              }
            });
            break;
          case "disconnect-signal-on-resume-no-messages":
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              yield this.engine.client.handleOnClose("simulate resume-disconnect");
            });
            req = new SimulateScenario({
              scenario: {
                case: "disconnectSignalOnResumeNoMessages",
                value: true
              }
            });
            break;
          case "full-reconnect":
            this.engine.fullReconnectOnNext = true;
            yield this.engine.client.handleOnClose("simulate full-reconnect");
            break;
          case "force-tcp":
          case "force-tls":
            req = new SimulateScenario({
              scenario: {
                case: "switchCandidateProtocol",
                value: scenario === "force-tls" ? 2 : 1
              }
            });
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              const onLeave = this.engine.client.onLeave;
              if (onLeave) {
                onLeave(new LeaveRequest({
                  reason: DisconnectReason.CLIENT_INITIATED,
                  action: LeaveRequest_Action.RECONNECT
                }));
              }
            });
            break;
          case "subscriber-bandwidth":
            if (arg === void 0 || typeof arg !== "number") {
              throw new Error("subscriber-bandwidth requires a number as argument");
            }
            req = new SimulateScenario({
              scenario: {
                case: "subscriberBandwidth",
                value: numberToBigInt(arg)
              }
            });
            break;
          case "leave-full-reconnect":
            req = new SimulateScenario({
              scenario: {
                case: "leaveRequestFullReconnect",
                value: true
              }
            });
        }
        if (req) {
          yield this.engine.client.sendSimulateScenario(req);
          yield postAction();
        }
      });
    }
    /**
     * Returns true if audio playback is enabled
     */
    get canPlaybackAudio() {
      return this.audioEnabled;
    }
    /**
     * Returns true if video playback is enabled
     */
    get canPlaybackVideo() {
      return !this.isVideoPlaybackBlocked;
    }
    getActiveDevice(kind) {
      return this.localParticipant.activeDeviceMap.get(kind);
    }
    /**
     * Switches all active devices used in this room to the given device.
     *
     * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
     *
     * @param kind use `videoinput` for camera track,
     *  `audioinput` for microphone track,
     *  `audiooutput` to set speaker for all incoming audio tracks
     * @param deviceId
     */
    switchActiveDevice(kind_1, deviceId_1) {
      return __awaiter(this, arguments, void 0, function(kind, deviceId) {
        var _this3 = this;
        let exact = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return function* () {
          var _a, _b, _c, _d, _e2, _f, _g;
          var _h;
          let success = true;
          let needsUpdateWithoutTracks = false;
          const deviceConstraint = exact ? {
            exact: deviceId
          } : deviceId;
          if (kind === "audioinput") {
            needsUpdateWithoutTracks = _this3.localParticipant.audioTrackPublications.size === 0;
            const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;
            _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;
            const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter((track) => track.source === Track.Source.Microphone);
            try {
              success = (yield Promise.all(tracks.map((t2) => {
                var _a2;
                return (_a2 = t2.audioTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);
              }))).every((val) => val === true);
            } catch (e2) {
              _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;
              throw e2;
            }
          } else if (kind === "videoinput") {
            needsUpdateWithoutTracks = _this3.localParticipant.videoTrackPublications.size === 0;
            const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;
            _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;
            const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter((track) => track.source === Track.Source.Camera);
            try {
              success = (yield Promise.all(tracks.map((t2) => {
                var _a2;
                return (_a2 = t2.videoTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);
              }))).every((val) => val === true);
            } catch (e2) {
              _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;
              throw e2;
            }
          } else if (kind === "audiooutput") {
            if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !("setSinkId" in _this3.audioContext)) {
              throw new Error("cannot switch audio output, setSinkId not supported");
            }
            if (_this3.options.webAudioMix) {
              deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId("audiooutput", deviceId)) !== null && _c !== void 0 ? _c : "";
            }
            (_d = (_h = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _h.audioOutput = {};
            const prevDeviceId = (_e2 = _this3.getActiveDevice(kind)) !== null && _e2 !== void 0 ? _e2 : _this3.options.audioOutput.deviceId;
            _this3.options.audioOutput.deviceId = deviceId;
            try {
              if (_this3.options.webAudioMix) {
                (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);
              }
              yield Promise.all(Array.from(_this3.remoteParticipants.values()).map((p2) => p2.setAudioOutput({
                deviceId
              })));
            } catch (e2) {
              _this3.options.audioOutput.deviceId = prevDeviceId;
              throw e2;
            }
          }
          if (needsUpdateWithoutTracks || kind === "audiooutput") {
            _this3.localParticipant.activeDeviceMap.set(kind, kind === "audiooutput" && ((_g = _this3.options.audioOutput) === null || _g === void 0 ? void 0 : _g.deviceId) || deviceId);
            _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);
          }
          return success;
        }();
      });
    }
    setupLocalParticipantEvents() {
      this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
    }
    recreateEngine() {
      var _a;
      (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
      this.engine = void 0;
      this.isResuming = false;
      this.remoteParticipants.clear();
      this.sidToIdentity.clear();
      this.bufferedEvents = [];
      this.maybeCreateEngine();
    }
    onTrackAdded(mediaTrack, stream, receiver) {
      if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
        const reconnectedHandler = () => {
          this.onTrackAdded(mediaTrack, stream, receiver);
          cleanup();
        };
        const cleanup = () => {
          this.off(RoomEvent.Reconnected, reconnectedHandler);
          this.off(RoomEvent.Connected, reconnectedHandler);
          this.off(RoomEvent.Disconnected, cleanup);
        };
        this.once(RoomEvent.Reconnected, reconnectedHandler);
        this.once(RoomEvent.Connected, reconnectedHandler);
        this.once(RoomEvent.Disconnected, cleanup);
        return;
      }
      if (this.state === ConnectionState.Disconnected) {
        this.log.warn("skipping incoming track after Room disconnected", this.logContext);
        return;
      }
      const parts = unpackStreamId(stream.id);
      const participantSid = parts[0];
      let streamId = parts[1];
      let trackId = mediaTrack.id;
      if (streamId && streamId.startsWith("TR"))
        trackId = streamId;
      if (participantSid === this.localParticipant.sid) {
        this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
        return;
      }
      const participant = Array.from(this.remoteParticipants.values()).find((p2) => p2.sid === participantSid);
      if (!participant) {
        this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(participantSid), this.logContext);
        return;
      }
      let adaptiveStreamSettings;
      if (this.options.adaptiveStream) {
        if (typeof this.options.adaptiveStream === "object") {
          adaptiveStreamSettings = this.options.adaptiveStream;
        } else {
          adaptiveStreamSettings = {};
        }
      }
      participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);
    }
    handleDisconnect() {
      let shouldStopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      let reason = arguments.length > 1 ? arguments[1] : void 0;
      var _a;
      this.clearConnectionReconcile();
      this.isResuming = false;
      this.bufferedEvents = [];
      this.transcriptionReceivedTimes.clear();
      if (this.state === ConnectionState.Disconnected) {
        return;
      }
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((p2) => {
          p2.trackPublications.forEach((pub) => {
            p2.unpublishTrack(pub.trackSid);
          });
        });
        this.localParticipant.trackPublications.forEach((pub) => {
          var _a2, _b, _c;
          if (pub.track) {
            this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);
          }
          if (shouldStopTracks) {
            (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.detach();
            (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
          } else {
            (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();
          }
        });
        this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
        this.localParticipant.trackPublications.clear();
        this.localParticipant.videoTrackPublications.clear();
        this.localParticipant.audioTrackPublications.clear();
        this.remoteParticipants.clear();
        this.sidToIdentity.clear();
        this.activeSpeakers = [];
        if (this.audioContext && typeof this.options.webAudioMix === "boolean") {
          this.audioContext.close();
          this.audioContext = void 0;
        }
        if (isWeb()) {
          window.removeEventListener("beforeunload", this.onPageLeave);
          window.removeEventListener("pagehide", this.onPageLeave);
          window.removeEventListener("freeze", this.onPageLeave);
          (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener("devicechange", this.handleDeviceChange);
        }
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected);
        this.emit(RoomEvent.Disconnected, reason);
      }
    }
    handleParticipantDisconnected(identity, participant) {
      var _a;
      this.remoteParticipants.delete(identity);
      if (!participant) {
        return;
      }
      participant.trackPublications.forEach((publication) => {
        participant.unpublishTrack(publication.trackSid, true);
      });
      this.emit(RoomEvent.ParticipantDisconnected, participant);
      (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);
    }
    handleStreamHeader(streamHeader, participantIdentity) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (streamHeader.contentHeader.case === "byteHeader") {
          const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);
          if (!streamHandlerCallback) {
            this.log.debug("ignoring incoming byte stream due to no handler for topic", streamHeader.topic);
            return;
          }
          let streamController;
          const info = {
            id: streamHeader.streamId,
            name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : "unknown",
            mimeType: streamHeader.mimeType,
            size: streamHeader.totalLength ? Number(streamHeader.totalLength) : void 0,
            topic: streamHeader.topic,
            timestamp: bigIntToNumber(streamHeader.timestamp),
            attributes: streamHeader.attributes
          };
          const stream = new ReadableStream({
            start: (controller) => {
              streamController = controller;
              this.byteStreamControllers.set(streamHeader.streamId, {
                info,
                controller: streamController,
                startTime: Date.now()
              });
            }
          });
          streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {
            identity: participantIdentity
          });
        } else if (streamHeader.contentHeader.case === "textHeader") {
          const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);
          if (!streamHandlerCallback) {
            this.log.debug("ignoring incoming text stream due to no handler for topic", streamHeader.topic);
            return;
          }
          let streamController;
          const info = {
            id: streamHeader.streamId,
            mimeType: streamHeader.mimeType,
            size: streamHeader.totalLength ? Number(streamHeader.totalLength) : void 0,
            topic: streamHeader.topic,
            timestamp: Number(streamHeader.timestamp),
            attributes: streamHeader.attributes
          };
          const stream = new ReadableStream({
            start: (controller) => {
              streamController = controller;
              this.textStreamControllers.set(streamHeader.streamId, {
                info,
                controller: streamController,
                startTime: Date.now()
              });
            }
          });
          streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {
            identity: participantIdentity
          });
        }
      });
    }
    handleStreamChunk(chunk) {
      const fileBuffer = this.byteStreamControllers.get(chunk.streamId);
      if (fileBuffer) {
        if (chunk.content.length > 0) {
          fileBuffer.controller.enqueue(chunk);
        }
      }
      const textBuffer = this.textStreamControllers.get(chunk.streamId);
      if (textBuffer) {
        if (chunk.content.length > 0) {
          textBuffer.controller.enqueue(chunk);
        }
      }
    }
    handleStreamTrailer(trailer) {
      const textBuffer = this.textStreamControllers.get(trailer.streamId);
      if (textBuffer) {
        textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);
        textBuffer.controller.close();
        this.byteStreamControllers.delete(trailer.streamId);
      }
      const fileBuffer = this.byteStreamControllers.get(trailer.streamId);
      if (fileBuffer) {
        {
          fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);
          fileBuffer.controller.close();
          this.byteStreamControllers.delete(trailer.streamId);
        }
      }
    }
    acquireAudioContext() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (typeof this.options.webAudioMix !== "boolean" && this.options.webAudioMix.audioContext) {
          this.audioContext = this.options.webAudioMix.audioContext;
        } else if (!this.audioContext || this.audioContext.state === "closed") {
          this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : void 0;
        }
        if (this.options.webAudioMix) {
          this.remoteParticipants.forEach((participant) => participant.setAudioContext(this.audioContext));
        }
        this.localParticipant.setAudioContext(this.audioContext);
        if (this.audioContext && this.audioContext.state === "suspended") {
          try {
            yield Promise.race([this.audioContext.resume(), sleep(200)]);
          } catch (e2) {
            this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
              error: e2
            }));
          }
        }
        const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === "running";
        if (newContextIsRunning !== this.canPlaybackAudio) {
          this.audioEnabled = newContextIsRunning;
          this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);
        }
      });
    }
    createParticipant(identity, info) {
      var _a;
      let participant;
      if (info) {
        participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {
          loggerContextCb: () => this.logContext,
          loggerName: this.options.loggerName
        });
      } else {
        participant = new RemoteParticipant(this.engine.client, "", identity, void 0, void 0, void 0, {
          loggerContextCb: () => this.logContext,
          loggerName: this.options.loggerName
        });
      }
      if (this.options.webAudioMix) {
        participant.setAudioContext(this.audioContext);
      }
      if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {
        participant.setAudioOutput(this.options.audioOutput).catch((e2) => this.log.warn("Could not set audio output: ".concat(e2.message), this.logContext));
      }
      return participant;
    }
    getOrCreateParticipant(identity, info) {
      if (this.remoteParticipants.has(identity)) {
        const existingParticipant = this.remoteParticipants.get(identity);
        if (info) {
          const wasUpdated = existingParticipant.updateInfo(info);
          if (wasUpdated) {
            this.sidToIdentity.set(info.sid, info.identity);
          }
        }
        return existingParticipant;
      }
      const participant = this.createParticipant(identity, info);
      this.remoteParticipants.set(identity, participant);
      this.sidToIdentity.set(info.sid, info.identity);
      this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);
      participant.on(ParticipantEvent.TrackPublished, (trackPublication) => {
        this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);
      }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {
        if (track.kind === Track.Kind.Audio) {
          track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
          track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
        } else if (track.kind === Track.Kind.Video) {
          track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);
          track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);
        }
        this.emit(RoomEvent.TrackSubscribed, track, publication, participant);
      }).on(ParticipantEvent.TrackUnpublished, (publication) => {
        this.emit(RoomEvent.TrackUnpublished, publication, participant);
      }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {
        this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);
      }).on(ParticipantEvent.TrackMuted, (pub) => {
        this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);
      }).on(ParticipantEvent.TrackUnmuted, (pub) => {
        this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);
      }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
        this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);
      }).on(ParticipantEvent.ParticipantNameChanged, (name) => {
        this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);
      }).on(ParticipantEvent.AttributesChanged, (changedAttributes) => {
        this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);
      }).on(ParticipantEvent.ConnectionQualityChanged, (quality) => {
        this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);
      }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {
        this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);
      }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {
        this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);
      }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {
        this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);
      }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {
        this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);
      });
      if (info) {
        participant.updateInfo(info);
      }
      return participant;
    }
    sendSyncState() {
      const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant) => {
        acc.push(...participant.getTrackPublications());
        return acc;
      }, []);
      const localTracks = this.localParticipant.getTrackPublications();
      this.engine.sendSyncState(remoteTracks, localTracks);
    }
    /**
     * After resuming, we'll need to notify the server of the current
     * subscription settings.
     */
    updateSubscriptions() {
      for (const p2 of this.remoteParticipants.values()) {
        for (const pub of p2.videoTrackPublications.values()) {
          if (pub.isSubscribed && isRemotePub(pub)) {
            pub.emitTrackUpdate();
          }
        }
      }
    }
    getRemoteParticipantBySid(sid) {
      const identity = this.sidToIdentity.get(sid);
      if (identity) {
        return this.remoteParticipants.get(identity);
      }
    }
    registerConnectionReconcile() {
      this.clearConnectionReconcile();
      let consecutiveFailures = 0;
      this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
        if (
          // ensure we didn't tear it down
          !this.engine || // engine detected close, but Room missed it
          this.engine.isClosed || // transports failed without notifying engine
          !this.engine.verifyTransport()
        ) {
          consecutiveFailures++;
          this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
            numFailures: consecutiveFailures,
            engine: this.engine ? {
              closed: this.engine.isClosed,
              transportsConnected: this.engine.verifyTransport()
            } : void 0
          }));
          if (consecutiveFailures >= 3) {
            this.recreateEngine();
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);
          }
        } else {
          consecutiveFailures = 0;
        }
      }, connectionReconcileFrequency);
    }
    clearConnectionReconcile() {
      if (this.connectionReconcileInterval) {
        CriticalTimers.clearInterval(this.connectionReconcileInterval);
      }
    }
    setAndEmitConnectionState(state) {
      if (state === this.state) {
        return false;
      }
      this.state = state;
      this.emit(RoomEvent.ConnectionStateChanged, this.state);
      return true;
    }
    emitBufferedEvents() {
      this.bufferedEvents.forEach((_ref3) => {
        let [ev, args] = _ref3;
        this.emit(ev, ...args);
      });
      this.bufferedEvents = [];
    }
    emitWhenConnected(event) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {
        this.bufferedEvents.push([event, args]);
      } else if (this.state === ConnectionState.Connected) {
        return this.emit(event, ...args);
      }
      return false;
    }
    /**
     * Allows to populate a room with simulated participants.
     * No actual connection to a server will be established, all state is
     * @experimental
     */
    simulateParticipants(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const publishOptions = Object.assign({
          audio: true,
          video: true,
          useRealTracks: false
        }, options.publish);
        const participantOptions = Object.assign({
          count: 9,
          audio: false,
          video: true,
          aspectRatios: [1.66, 1.7, 1.3]
        }, options.participants);
        this.handleDisconnect();
        this.roomInfo = new Room$1({
          sid: "RM_SIMULATED",
          name: "simulated-room",
          emptyTimeout: 0,
          maxParticipants: 0,
          creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
          metadata: "",
          numParticipants: 1,
          numPublishers: 1,
          turnPassword: "",
          enabledCodecs: [],
          activeRecording: false
        });
        this.localParticipant.updateInfo(new ParticipantInfo({
          identity: "simulated-local",
          name: "local-name"
        }));
        this.setupLocalParticipantEvents();
        this.emit(RoomEvent.SignalConnected);
        this.emit(RoomEvent.Connected);
        this.setAndEmitConnectionState(ConnectionState.Connected);
        if (publishOptions.video) {
          const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO,
            name: "video-dummy"
          }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
            video: true
          })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), void 0, false, {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          }), {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          });
          this.localParticipant.addTrackPublication(camPub);
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);
        }
        if (publishOptions.audio) {
          const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
            audio: true
          })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, false, this.audioContext, {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          }), {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          });
          this.localParticipant.addTrackPublication(audioPub);
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);
        }
        for (let i2 = 0; i2 < participantOptions.count - 1; i2 += 1) {
          let info = new ParticipantInfo({
            sid: Math.floor(Math.random() * 1e4).toString(),
            identity: "simulated-".concat(i2),
            state: ParticipantInfo_State.ACTIVE,
            tracks: [],
            joinedAt: protoInt64.parse(Date.now())
          });
          const p2 = this.getOrCreateParticipant(info.identity, info);
          if (participantOptions.video) {
            const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i2 % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);
            const videoTrack = new TrackInfo({
              source: TrackSource.CAMERA,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO
            });
            p2.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());
            info.tracks = [...info.tracks, videoTrack];
          }
          if (participantOptions.audio) {
            const dummyTrack = getEmptyAudioStreamTrack();
            const audioTrack = new TrackInfo({
              source: TrackSource.MICROPHONE,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO
            });
            p2.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());
            info.tracks = [...info.tracks, audioTrack];
          }
          p2.updateInfo(info);
        }
      });
    }
    // /** @internal */
    emit(event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      if (event !== RoomEvent.ActiveSpeakersChanged) {
        const minimizedArgs = mapArgs(args).filter((arg) => arg !== void 0);
        this.log.debug("room event ".concat(event), Object.assign(Object.assign({}, this.logContext), {
          event,
          args: minimizedArgs
        }));
      }
      return super.emit(event, ...args);
    }
  }
  Room.cleanupRegistry = typeof FinalizationRegistry !== "undefined" && new FinalizationRegistry((cleanup) => {
    cleanup();
  });
  function mapArgs(args) {
    return args.map((arg) => {
      if (!arg) {
        return;
      }
      if (Array.isArray(arg)) {
        return mapArgs(arg);
      }
      if (typeof arg === "object") {
        return "logContext" in arg ? arg.logContext : void 0;
      }
      return arg;
    });
  }
  var CheckStatus;
  (function(CheckStatus2) {
    CheckStatus2[CheckStatus2["IDLE"] = 0] = "IDLE";
    CheckStatus2[CheckStatus2["RUNNING"] = 1] = "RUNNING";
    CheckStatus2[CheckStatus2["SKIPPED"] = 2] = "SKIPPED";
    CheckStatus2[CheckStatus2["SUCCESS"] = 3] = "SUCCESS";
    CheckStatus2[CheckStatus2["FAILED"] = 4] = "FAILED";
  })(CheckStatus || (CheckStatus = {}));
  class Checker extends eventsExports.EventEmitter {
    constructor(url, token) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super();
      this.status = CheckStatus.IDLE;
      this.logs = [];
      this.errorsAsWarnings = false;
      this.url = url;
      this.token = token;
      this.name = this.constructor.name;
      this.room = new Room(options.roomOptions);
      this.connectOptions = options.connectOptions;
      if (options.errorsAsWarnings) {
        this.errorsAsWarnings = options.errorsAsWarnings;
      }
    }
    run(onComplete) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.status !== CheckStatus.IDLE) {
          throw Error("check is running already");
        }
        this.setStatus(CheckStatus.RUNNING);
        try {
          yield this.perform();
        } catch (err) {
          if (err instanceof Error) {
            if (this.errorsAsWarnings) {
              this.appendWarning(err.message);
            } else {
              this.appendError(err.message);
            }
          }
        }
        yield this.disconnect();
        yield new Promise((resolve) => setTimeout(resolve, 500));
        if (this.status !== CheckStatus.SKIPPED) {
          this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);
        }
        if (onComplete) {
          onComplete();
        }
        return this.getInfo();
      });
    }
    isSuccess() {
      return !this.logs.some((l2) => l2.level === "error");
    }
    connect() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.room.state === ConnectionState.Connected) {
          return this.room;
        }
        yield this.room.connect(this.url, this.token, this.connectOptions);
        return this.room;
      });
    }
    disconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.room && this.room.state !== ConnectionState.Disconnected) {
          yield this.room.disconnect();
          yield new Promise((resolve) => setTimeout(resolve, 500));
        }
      });
    }
    skip() {
      this.setStatus(CheckStatus.SKIPPED);
    }
    appendMessage(message) {
      this.logs.push({
        level: "info",
        message
      });
      this.emit("update", this.getInfo());
    }
    appendWarning(message) {
      this.logs.push({
        level: "warning",
        message
      });
      this.emit("update", this.getInfo());
    }
    appendError(message) {
      this.logs.push({
        level: "error",
        message
      });
      this.emit("update", this.getInfo());
    }
    setStatus(status) {
      this.status = status;
      this.emit("update", this.getInfo());
    }
    get engine() {
      var _a;
      return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;
    }
    getInfo() {
      return {
        logs: this.logs,
        name: this.name,
        status: this.status,
        description: this.description
      };
    }
  }
  function createLocalTracks(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      options !== null && options !== void 0 ? options : options = {};
      (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = {
        deviceId: "default"
      };
      (_b = options.video) !== null && _b !== void 0 ? _b : options.video = {
        deviceId: "default"
      };
      const {
        audioProcessor,
        videoProcessor
      } = extractProcessorsFromOptions(options);
      const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);
      const constraints = constraintsForOptions(opts);
      const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);
      if (options.audio) {
        DeviceManager.userMediaPromiseMap.set("audioinput", mediaPromise);
        mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"));
      }
      if (options.video) {
        DeviceManager.userMediaPromiseMap.set("videoinput", mediaPromise);
        mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput"));
      }
      const stream = yield mediaPromise;
      return Promise.all(stream.getTracks().map((mediaStreamTrack) => __awaiter(this, void 0, void 0, function* () {
        const isAudio = mediaStreamTrack.kind === "audio";
        isAudio ? opts.audio : opts.video;
        let trackConstraints;
        const conOrBool = isAudio ? constraints.audio : constraints.video;
        if (typeof conOrBool !== "boolean") {
          trackConstraints = conOrBool;
        }
        if (trackConstraints) {
          trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;
        } else {
          trackConstraints = {
            deviceId: mediaStreamTrack.getSettings().deviceId
          };
        }
        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
        if (track.kind === Track.Kind.Video) {
          track.source = Track.Source.Camera;
        } else if (track.kind === Track.Kind.Audio) {
          track.source = Track.Source.Microphone;
        }
        track.mediaStream = stream;
        if (isAudioTrack(track) && audioProcessor) {
          yield track.setProcessor(audioProcessor);
        } else if (isVideoTrack(track) && videoProcessor) {
          yield track.setProcessor(videoProcessor);
        }
        return track;
      })));
    });
  }
  function createLocalVideoTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const tracks = yield createLocalTracks({
        audio: false,
        video: options
      });
      return tracks[0];
    });
  }
  function createLocalAudioTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const tracks = yield createLocalTracks({
        audio: options,
        video: false
      });
      return tracks[0];
    });
  }
  class PublishAudioCheck extends Checker {
    get description() {
      return "Can publish audio";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        const track = yield createLocalAudioTrack();
        room.localParticipant.publishTrack(track);
        yield new Promise((resolve) => setTimeout(resolve, 3e3));
        const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
        if (!stats) {
          throw new Error("Could not get RTCStats");
        }
        let numPackets = 0;
        stats.forEach((stat) => {
          if (stat.type === "outbound-rtp" && (stat.kind === "audio" || !stat.kind && stat.mediaType === "audio")) {
            numPackets = stat.packetsSent;
          }
        });
        if (numPackets === 0) {
          throw new Error("Could not determine packets are sent");
        }
        this.appendMessage("published ".concat(numPackets, " audio packets"));
      });
    }
  }
  class PublishVideoCheck extends Checker {
    get description() {
      return "Can publish video";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        const track = yield createLocalVideoTrack();
        room.localParticipant.publishTrack(track);
        yield new Promise((resolve) => setTimeout(resolve, 5e3));
        const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
        if (!stats) {
          throw new Error("Could not get RTCStats");
        }
        let numPackets = 0;
        stats.forEach((stat) => {
          if (stat.type === "outbound-rtp" && (stat.kind === "video" || !stat.kind && stat.mediaType === "video")) {
            numPackets += stat.packetsSent;
          }
        });
        if (numPackets === 0) {
          throw new Error("Could not determine packets are sent");
        }
        this.appendMessage("published ".concat(numPackets, " video packets"));
      });
    }
  }
  class ReconnectCheck extends Checker {
    get description() {
      return "Resuming connection after interruption";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        let reconnectingTriggered = false;
        let reconnected = false;
        let reconnectResolver;
        const reconnectTimeout = new Promise((resolve) => {
          setTimeout(resolve, 5e3);
          reconnectResolver = resolve;
        });
        const handleReconnecting = () => {
          reconnectingTriggered = true;
        };
        room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, () => {
          reconnected = true;
          reconnectResolver(true);
        });
        (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();
        const onClose = room.engine.client.onClose;
        if (onClose) {
          onClose("");
        }
        yield reconnectTimeout;
        if (!reconnectingTriggered) {
          throw new Error("Did not attempt to reconnect");
        } else if (!reconnected || room.state !== ConnectionState.Connected) {
          this.appendWarning("reconnection is only possible in Redis-based configurations");
          throw new Error("Not able to reconnect");
        }
      });
    }
  }
  class TURNCheck extends Checker {
    get description() {
      return "Can connect via TURN";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const signalClient = new SignalClient();
        const joinRes = yield signalClient.join(this.url, this.token, {
          autoSubscribe: true,
          maxRetries: 0,
          e2eeEnabled: false,
          websocketTimeout: 15e3
        });
        let hasTLS = false;
        let hasTURN = false;
        let hasSTUN = false;
        for (let iceServer of joinRes.iceServers) {
          for (let url of iceServer.urls) {
            if (url.startsWith("turn:")) {
              hasTURN = true;
              hasSTUN = true;
            } else if (url.startsWith("turns:")) {
              hasTURN = true;
              hasSTUN = true;
              hasTLS = true;
            }
            if (url.startsWith("stun:")) {
              hasSTUN = true;
            }
          }
        }
        if (!hasSTUN) {
          this.appendWarning("No STUN servers configured on server side.");
        } else if (hasTURN && !hasTLS) {
          this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.");
        }
        yield signalClient.close();
        if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {
          yield this.room.connect(this.url, this.token, {
            rtcConfig: {
              iceTransportPolicy: "relay"
            }
          });
        } else {
          this.appendWarning("No TURN servers configured.");
          this.skip();
          yield new Promise((resolve) => setTimeout(resolve, 0));
        }
      });
    }
  }
  class WebRTCCheck extends Checker {
    get description() {
      return "Establishing WebRTC connection";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        let hasTcp = false;
        let hasIpv4Udp = false;
        this.room.on(RoomEvent.SignalConnected, () => {
          const prevTrickle = this.room.engine.client.onTrickle;
          this.room.engine.client.onTrickle = (sd, target) => {
            if (sd.candidate) {
              const candidate = new RTCIceCandidate(sd);
              let str = "".concat(candidate.protocol, " ").concat(candidate.address, ":").concat(candidate.port, " ").concat(candidate.type);
              if (candidate.address) {
                if (isIPPrivate(candidate.address)) {
                  str += " (private)";
                } else {
                  if (candidate.protocol === "tcp" && candidate.tcpType === "passive") {
                    hasTcp = true;
                    str += " (passive)";
                  } else if (candidate.protocol === "udp") {
                    hasIpv4Udp = true;
                  }
                }
              }
              this.appendMessage(str);
            }
            if (prevTrickle) {
              prevTrickle(sd, target);
            }
          };
          if (this.room.engine.pcManager) {
            this.room.engine.pcManager.subscriber.onIceCandidateError = (ev) => {
              if (ev instanceof RTCPeerConnectionIceErrorEvent) {
                this.appendWarning("error with ICE candidate: ".concat(ev.errorCode, " ").concat(ev.errorText, " ").concat(ev.url));
              }
            };
          }
        });
        try {
          yield this.connect();
          livekitLogger.info("now the room is connected");
        } catch (err) {
          this.appendWarning("ports need to be open on firewall in order to connect.");
          throw err;
        }
        if (!hasTcp) {
          this.appendWarning("Server is not configured for ICE/TCP");
        }
        if (!hasIpv4Udp) {
          this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
        }
      });
    }
  }
  function isIPPrivate(address) {
    const parts = address.split(".");
    if (parts.length === 4) {
      if (parts[0] === "10") {
        return true;
      } else if (parts[0] === "192" && parts[1] === "168") {
        return true;
      } else if (parts[0] === "172") {
        const second = parseInt(parts[1], 10);
        if (second >= 16 && second <= 31) {
          return true;
        }
      }
    }
    return false;
  }
  class WebSocketCheck extends Checker {
    get description() {
      return "Connecting to signal connection via WebSocket";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (this.url.startsWith("ws:") || this.url.startsWith("http:")) {
          this.appendWarning("Server is insecure, clients may block connections to it");
        }
        let signalClient = new SignalClient();
        const joinRes = yield signalClient.join(this.url, this.token, {
          autoSubscribe: true,
          maxRetries: 0,
          e2eeEnabled: false,
          websocketTimeout: 15e3
        });
        this.appendMessage("Connected to server, version ".concat(joinRes.serverVersion, "."));
        if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {
          this.appendMessage("LiveKit Cloud: ".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));
        }
        yield signalClient.close();
      });
    }
  }
  class ConnectionCheck extends eventsExports.EventEmitter {
    constructor(url, token) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super();
      this.options = {};
      this.checkResults = /* @__PURE__ */ new Map();
      this.url = url;
      this.token = token;
      this.options = options;
    }
    getNextCheckId() {
      const nextId = this.checkResults.size;
      this.checkResults.set(nextId, {
        logs: [],
        status: CheckStatus.IDLE,
        name: "",
        description: ""
      });
      return nextId;
    }
    updateCheck(checkId, info) {
      this.checkResults.set(checkId, info);
      this.emit("checkUpdate", checkId, info);
    }
    isSuccess() {
      return Array.from(this.checkResults.values()).every((r2) => r2.status !== CheckStatus.FAILED);
    }
    getResults() {
      return Array.from(this.checkResults.values());
    }
    createAndRunCheck(check) {
      return __awaiter(this, void 0, void 0, function* () {
        const checkId = this.getNextCheckId();
        const test = new check(this.url, this.token, this.options);
        const handleUpdate = (info) => {
          this.updateCheck(checkId, info);
        };
        test.on("update", handleUpdate);
        const result = yield test.run();
        test.off("update", handleUpdate);
        return result;
      });
    }
    checkWebsocket() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebSocketCheck);
      });
    }
    checkWebRTC() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebRTCCheck);
      });
    }
    checkTURN() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(TURNCheck);
      });
    }
    checkReconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(ReconnectCheck);
      });
    }
    checkPublishAudio() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishAudioCheck);
      });
    }
    checkPublishVideo() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishVideoCheck);
      });
    }
  }
  const useMeetingStore = defineStore("meeting", () => {
    const showMeetingDialog = vue.ref(false);
    const userStore = useUserStore();
    const webSocket = useWebSocket();
    const currentVideoRef = vue.ref();
    const remoteVideoRef = vue.ref();
    const currentAudioRef = vue.ref();
    const remoteAudioRef = vue.ref();
    let room = vue.ref(null);
    let token = "";
    let isCaller = vue.ref(true);
    let callerId = vue.ref("");
    let callerName = vue.ref("");
    let isAnswered = vue.ref(false);
    let isGroup = vue.ref(false);
    let isVideoCall = vue.ref(false);
    async function createRoom(status) {
      const { roomType } = status;
      isVideoCall.value = roomType === "video";
      room.value = new Room({
        // automatically manage subscribed video quality
        adaptiveStream: true,
        // optimize publishing bandwidth and CPU for published tracks
        dynacast: true,
        // default capture settings
        videoCaptureDefaults: {
          resolution: VideoPresets.h720.resolution
        }
      });
      const roomName = $inject_window_crypto.randomUUID();
      const res = await getToken(roomName, userStore.userInfo.id);
      token = res.token;
      room.value.prepareConnection(LIVEKITURL, token);
      room.value.on(RoomEvent.TrackSubscribed, handleTrackSubscribed).on(RoomEvent.TrackUnsubscribed, handleTrackUnsubscribed).on(RoomEvent.ActiveSpeakersChanged, handleActiveSpeakerChange).on(RoomEvent.Disconnected, handleDisconnect).on(RoomEvent.LocalTrackUnpublished, handleLocalTrackUnpublished);
      await room.value.connect(LIVEKITURL, token);
      await room.value.localParticipant.setMicrophoneEnabled(true);
      await room.value.localParticipant.setCameraEnabled(isVideoCall.value);
    }
    function informParticipant(participant) {
      if (participant !== userStore.userInfo.id) {
        const message = JSON.stringify({
          type: "room-created",
          sender: userStore.userInfo.id,
          receiver: participant,
          roomId: room.value.name,
          roomType: isVideoCall.value ? "video" : "audio"
        });
        webSocket.sendMessage(message);
      }
    }
    async function joinRoom(status) {
      const { roomName, roomType } = status;
      isVideoCall.value = roomType === "video";
      formatAppLog("log", "at store/meeting.js:91", "join room", status);
      room.value = new Room({
        // è‡ªåŠ¨è°ƒæ•´è®¢é˜…çš„è§†é¢‘è´¨é‡
        adaptiveStream: true,
        // ä¼˜åŒ–å‘å¸ƒçš„éŸ³è§†é¢‘æµçš„å¸¦å®½å’ŒCPU
        dynacast: true,
        // é»˜è®¤çš„éŸ³è§†é¢‘æµè®¾ç½®
        videoCaptureDefaults: {
          resolution: VideoPresets.h720.resolution
        }
      });
      const res = await getToken(roomName, userStore.userInfo.id);
      token = res.token;
      room.value.prepareConnection(LIVEKITURL, token);
      room.value.on(RoomEvent.TrackSubscribed, handleTrackSubscribed).on(RoomEvent.TrackUnsubscribed, handleTrackUnsubscribed).on(RoomEvent.ActiveSpeakersChanged, handleActiveSpeakerChange).on(RoomEvent.Disconnected, handleDisconnect).on(RoomEvent.LocalTrackUnpublished, handleLocalTrackUnpublished);
      await room.value.connect(LIVEKITURL, token);
      await room.value.localParticipant.setMicrophoneEnabled(true);
      await room.value.localParticipant.setCameraEnabled(isVideoCall.value);
    }
    function handleTrackSubscribed(track, publication, participant) {
      var _a;
      const cameraPub = participant.getTrackPublication(Track.Source.Camera);
      participant.getTrackPublication(Track.Source.Microphone);
      (_a = cameraPub == null ? void 0 : cameraPub.videoTrack) == null ? void 0 : _a.attach(remoteVideoRef.value);
    }
    function handleTrackUnsubscribed(track, publication, participant) {
      track.detach();
    }
    function handleLocalTrackUnpublished(publication, participant) {
      publication.track.detach();
    }
    function handleActiveSpeakerChange(speakers) {
    }
    function handleDisconnect() {
      formatAppLog("log", "at store/meeting.js:168", "disconnected from room");
    }
    async function callRemote(target) {
      formatAppLog("log", "at store/meeting.js:172", "call remote", target);
      if (target.isGroup) {
        isGroup.value = true;
        for (let member of target.members) {
          if (member.id === userStore.userInfo.id) {
            continue;
          }
          const message = JSON.stringify({
            type: "call-remote",
            sender: userStore.userInfo.id,
            receiver: member.id,
            isGroup: true,
            roomType: isVideoCall.value ? "video" : "audio"
          });
          webSocket.sendMessage(message);
        }
      } else {
        isGroup.value = false;
        const message = JSON.stringify({
          type: "call-remote",
          sender: userStore.userInfo.id,
          receiver: target.id,
          isGroup: false,
          roomType: isVideoCall.value ? "video" : "audio"
        });
        webSocket.sendMessage(message);
      }
    }
    function acceptVideoCall() {
      const message = JSON.stringify({
        type: "answer-call",
        sender: userStore.state.id,
        receiver: callerId.value,
        reply: "accept"
      });
      webSocket.sendMessage(message);
      isAnswered.value = true;
    }
    function rejectVideoCall() {
      if (isCaller.value)
        ;
      else {
        isAnswered.value = false;
        const message = JSON.stringify({
          type: "answer-call",
          sender: userStore.userInfo.id,
          receiver: callerId.value,
          reply: "reject"
        });
        webSocket.sendMessage(message);
      }
      showMeetingDialog.value = false;
    }
    function leaveRoom() {
      if (room.value) {
        room.value.disconnect();
      }
      formatAppLog("log", "at store/meeting.js:239", "leave room", room.value.name);
      const message = JSON.stringify({
        type: "leave-room",
        sender: userStore.userInfo.id,
        roomId: room.value.name
      });
      webSocket.sendMessage(message);
    }
    return {
      showMeetingDialog,
      currentVideoRef,
      remoteVideoRef,
      currentAudioRef,
      remoteAudioRef,
      room,
      isCaller,
      isAnswered,
      callerId,
      callerName,
      isGroup,
      isVideoCall,
      createRoom,
      informParticipant,
      joinRoom,
      callRemote,
      acceptVideoCall,
      rejectVideoCall,
      leaveRoom
    };
  });
  const isCurrentPageMain = () => {
    const pages2 = getCurrentPages();
    if (pages2 && pages2.length > 0) {
      const currentPage = pages2[pages2.length - 1];
      formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:14", currentPage, currentPage.route);
      return currentPage && currentPage.route === "pages/tabBar/tabBar";
    }
    return false;
  };
  const useWebSocket = () => {
    const isConnected = vue.ref(false);
    const reconnectAttempts = vue.ref(0);
    const maxReconnectAttempts = 5;
    let socket = null;
    useMeetingStore();
    const connect = (userId, token) => {
      formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:31", token, "tokentokentokentoken");
      if (!userId || !token) {
        formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:33", "WebSocket è¿žæŽ¥å¤±è´¥: userId æˆ– token æœªæä¾›", { userId, token });
        return;
      }
      if (isConnected.value) {
        formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:38", "WebSocket å·²ç»è¿žæŽ¥");
        return;
      }
      const wsProtocol = backendHost.startsWith("https") ? "wss" : "ws";
      const wsUrl = `${wsProtocol}://${backendHost.split("://")[1]}/chat/${userId}`;
      formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:45", "å°è¯•è¿žæŽ¥ WebSocket:", wsUrl);
      socket = uni.connectSocket({
        url: wsUrl,
        header: {
          "content-type": "application/json"
        },
        protocols: [token],
        success: () => {
          formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:54", "WebSocket è¿žæŽ¥æˆåŠŸ");
        },
        fail: (error) => {
          formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:57", "WebSocket è¿žæŽ¥å¤±è´¥:", error);
        }
      });
      socket.onOpen(() => {
        formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:62", "WebSocket å·²è¿žæŽ¥");
        isConnected.value = true;
        reconnectAttempts.value = 0;
        startPingInterval();
      });
      socket.onMessage((res) => {
        formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:69", "æ”¶åˆ°æ¶ˆæ¯:", res.data);
        try {
          const message = JSON.parse(res.data);
          handleMessage(message);
        } catch (error) {
          formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:74", "è§£æžæ¶ˆæ¯å¤±è´¥:", error);
        }
      });
      socket.onError((res) => {
        formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:79", "WebSocket é”™è¯¯:", res);
      });
      socket.onClose((res) => {
        formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:83", "WebSocket å·²æ–­å¼€", res);
        isConnected.value = false;
        stopPingInterval();
        if (reconnectAttempts.value < maxReconnectAttempts) {
          const delay = Math.min(1e3 * Math.pow(2, reconnectAttempts.value), 3e4);
          formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:89", `å°†åœ¨ ${delay}ms åŽå°è¯•é‡æ–°è¿žæŽ¥...`);
          setTimeout(() => {
            formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:91", `å°è¯•é‡æ–°è¿žæŽ¥... (${reconnectAttempts.value + 1}/${maxReconnectAttempts})`);
            reconnectAttempts.value++;
            connect(userId, token);
          }, delay);
        } else {
          formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:96", "WebSocket é‡è¿žå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿žæŽ¥æˆ–è”ç³»ç®¡ç†å‘˜");
        }
      });
    };
    const disconnect = () => {
      if (isConnected.value && socket) {
        socket.close({
          success: () => {
            formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:105", "WebSocket å·²å…³é—­");
            isConnected.value = false;
            reconnectAttempts.value = 0;
            stopPingInterval();
          }
        });
      }
    };
    const sendMessage = (message) => {
      if (isConnected.value && socket) {
        socket.send({
          data: JSON.stringify(message),
          success: () => {
            formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:119", "æ¶ˆæ¯å‘é€æˆåŠŸ");
          },
          fail: (error) => {
            formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:122", "æ¶ˆæ¯å‘é€å¤±è´¥:", error);
          }
        });
      } else {
        formatAppLog("error", "at pages/WebSocket/WebSocketService.vue:126", "WebSocket æœªè¿žæŽ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯");
      }
    };
    const handleMessage = (message) => {
      formatAppLog("log", "at pages/WebSocket/WebSocketService.vue:131", "æ¶ˆæ¯", message);
      uni.$emit("newChatMessage", message);
      if (isCurrentPageMain()) {
        uni.$emit("refreshMainPage");
      }
    };
    const ping = () => {
      sendMessage({ type: "ping" });
    };
    let pingInterval;
    const startPingInterval = () => {
      pingInterval = setInterval(() => {
        ping();
      }, 3e4);
    };
    const stopPingInterval = () => {
      if (pingInterval) {
        clearInterval(pingInterval);
      }
    };
    vue.onUnmounted(() => {
      disconnect();
    });
    return {
      isConnected,
      connect,
      disconnect,
      sendMessage
    };
  };
  const _imports_0$d = "/static/icon/login.png";
  const _sfc_main$19 = {
    __name: "login",
    setup(__props, { expose: __expose }) {
      __expose();
      const { connect } = useWebSocket();
      const userStore = useUserStore();
      const autoLogin = vue.ref(false);
      const username = vue.ref("test-app");
      const password = vue.ref("Test123456");
      const goToRegister = () => {
        uni.navigateTo({
          url: "/pages/register/register"
        });
      };
      const goToForgetPassword = () => {
        uni.navigateTo({
          url: "/pages/forgetPassword/forgetPassword"
        });
      };
      const goToFingerLogin = () => {
        uni.navigateTo({
          url: "/pages/fingerLogin/fingerLogin"
        });
      };
      const goToTask = () => {
        uni.redirectTo({
          url: "/pages/tabBar/tabBar"
        });
      };
      const toggleAutoLogin = (e2) => {
        autoLogin.value = e2.detail.value.length > 0;
        if (autoLogin.value) {
          uni.navigateTo({
            url: "/pages/register/register"
          });
        }
      };
      const checkLogin = () => {
        uni.showLoading({
          title: "æ­£åœ¨ç™»å½•",
          mask: true
        });
        login({
          account: username.value,
          password: password.value
        }).then((res) => {
          if (res.code === 200) {
            uni.setStorageSync("username", username.value);
            uni.setStorageSync("password", password.value);
            uni.setStorageSync("token", res.data.token);
            const userData = {
              id: res.data.id,
              account: res.data.account,
              name: res.data.name,
              department: res.data.department,
              role: res.data.role,
              phone: res.data.phone,
              created: res.data.created,
              avatar: res.data.avatar,
              avatarUrl: res.data.avatarUrl,
              token: res.data.token,
              status: res.data.status
            };
            userStore.setUserData(userData);
            connect(res.data.id, res.data.token);
            uni.setStorageSync("userInfo", userData);
            formatAppLog("log", "at pages/login/login.vue:117", "ç™»å½•æˆåŠŸã€‚ç”¨æˆ·æ•°æ®:", userData);
            uni.hideLoading();
            uni.showToast({
              title: "ç™»å½•æˆåŠŸ",
              duration: 2e3
            }).then(() => {
              goToTask();
            });
          } else {
            throw new Error(res.message || "ç™»å½•å¤±è´¥");
          }
        }).catch((error) => {
          formatAppLog("error", "at pages/login/login.vue:130", "ç™»å½•å¤±è´¥:", error);
          uni.hideLoading();
          uni.showToast({
            title: error.message || "ç™»å½•å¤±è´¥",
            icon: "none",
            duration: 2e3
          });
        });
      };
      const __returned__ = { connect, userStore, autoLogin, username, password, goToRegister, goToForgetPassword, goToFingerLogin, goToTask, toggleAutoLogin, checkLogin, ref: vue.ref, get login() {
        return login;
      }, get useUserStore() {
        return useUserStore;
      }, useWebSocket };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "layout" }, [
      vue.createElementVNode("view", { class: "iconView" }, [
        vue.createElementVNode("image", {
          src: _imports_0$d,
          class: "icon"
        })
      ]),
      vue.createElementVNode("view", { class: "text" }, [
        vue.createElementVNode("text", null, "æ¬¢è¿Žç™»å½•ï¼")
      ]),
      vue.createElementVNode("view", {
        class: "account",
        style: { "margin-top": "25px" }
      }, [
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin-bottom": "7px" }
        }, "ç”¨æˆ·å"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            focus: "",
            placeholder: "è¯·è¾“å…¥ç”¨æˆ·å",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.username = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $setup.username]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "å¯†ç "),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            password: "",
            type: "text",
            placeholder: "è¯·è¾“å…¥å¯†ç ",
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.password = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $setup.password]
        ]),
        vue.createElementVNode("button", {
          onClick: $setup.checkLogin,
          type: "primary",
          style: { "margin-top": "15px" }
        }, "ç™»å½•")
      ]),
      vue.createElementVNode("view", { class: "container" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("label", { class: "checkbox" }, [
            vue.createElementVNode("checkbox", {
              value: $setup.autoLogin,
              onChange: $setup.toggleAutoLogin
            }, "è‡ªåŠ¨ç™»å½•", 40, ["value"])
          ])
        ]),
        vue.createElementVNode("view", { class: "right" }, [
          vue.createElementVNode("text", {
            onClick: $setup.goToRegister,
            class: "clicked_text"
          }, "æ³¨å†Œ "),
          vue.createElementVNode("text", {
            onClick: $setup.goToForgetPassword,
            class: "clicked_text"
          }, " å¿˜è®°å¯†ç "),
          vue.createElementVNode("text", null, " | "),
          vue.createElementVNode("text", {
            onClick: $setup.goToFingerLogin,
            class: "clicked_text"
          }, "æŒ‡çº¹ç™»å½•")
        ])
      ])
    ]);
  }
  const PagesLoginLogin = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$18], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/login/login.vue"]]);
  const isObject = (val) => val !== null && typeof val === "object";
  const defaultDelimiters = ["{", "}"];
  class BaseFormatter {
    constructor() {
      this._caches = /* @__PURE__ */ Object.create(null);
    }
    interpolate(message, values, delimiters = defaultDelimiters) {
      if (!values) {
        return [message];
      }
      let tokens = this._caches[message];
      if (!tokens) {
        tokens = parse(message, delimiters);
        this._caches[message] = tokens;
      }
      return compile(tokens, values);
    }
  }
  const RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
  const RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;
  function parse(format, [startDelimiter, endDelimiter]) {
    const tokens = [];
    let position = 0;
    let text = "";
    while (position < format.length) {
      let char = format[position++];
      if (char === startDelimiter) {
        if (text) {
          tokens.push({ type: "text", value: text });
        }
        text = "";
        let sub = "";
        char = format[position++];
        while (char !== void 0 && char !== endDelimiter) {
          sub += char;
          char = format[position++];
        }
        const isClosed = char === endDelimiter;
        const type = RE_TOKEN_LIST_VALUE.test(sub) ? "list" : isClosed && RE_TOKEN_NAMED_VALUE.test(sub) ? "named" : "unknown";
        tokens.push({ value: sub, type });
      } else {
        text += char;
      }
    }
    text && tokens.push({ type: "text", value: text });
    return tokens;
  }
  function compile(tokens, values) {
    const compiled = [];
    let index = 0;
    const mode = Array.isArray(values) ? "list" : isObject(values) ? "named" : "unknown";
    if (mode === "unknown") {
      return compiled;
    }
    while (index < tokens.length) {
      const token = tokens[index];
      switch (token.type) {
        case "text":
          compiled.push(token.value);
          break;
        case "list":
          compiled.push(values[parseInt(token.value, 10)]);
          break;
        case "named":
          if (mode === "named") {
            compiled.push(values[token.value]);
          } else {
            {
              console.warn(`Type of token '${token.type}' and format of value '${mode}' don't match!`);
            }
          }
          break;
        case "unknown":
          {
            console.warn(`Detect 'unknown' type of token!`);
          }
          break;
      }
      index++;
    }
    return compiled;
  }
  const LOCALE_ZH_HANS = "zh-Hans";
  const LOCALE_ZH_HANT = "zh-Hant";
  const LOCALE_EN = "en";
  const LOCALE_FR = "fr";
  const LOCALE_ES = "es";
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty.call(val, key);
  const defaultFormatter = new BaseFormatter();
  function include(str, parts) {
    return !!parts.find((part) => str.indexOf(part) !== -1);
  }
  function startsWith(str, parts) {
    return parts.find((part) => str.indexOf(part) === 0);
  }
  function normalizeLocale(locale, messages2) {
    if (!locale) {
      return;
    }
    locale = locale.trim().replace(/_/g, "-");
    if (messages2 && messages2[locale]) {
      return locale;
    }
    locale = locale.toLowerCase();
    if (locale === "chinese") {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf("zh") === 0) {
      if (locale.indexOf("-hans") > -1) {
        return LOCALE_ZH_HANS;
      }
      if (locale.indexOf("-hant") > -1) {
        return LOCALE_ZH_HANT;
      }
      if (include(locale, ["-tw", "-hk", "-mo", "-cht"])) {
        return LOCALE_ZH_HANT;
      }
      return LOCALE_ZH_HANS;
    }
    let locales = [LOCALE_EN, LOCALE_FR, LOCALE_ES];
    if (messages2 && Object.keys(messages2).length > 0) {
      locales = Object.keys(messages2);
    }
    const lang = startsWith(locale, locales);
    if (lang) {
      return lang;
    }
  }
  class I18n {
    constructor({ locale, fallbackLocale, messages: messages2, watcher, formater: formater2 }) {
      this.locale = LOCALE_EN;
      this.fallbackLocale = LOCALE_EN;
      this.message = {};
      this.messages = {};
      this.watchers = [];
      if (fallbackLocale) {
        this.fallbackLocale = fallbackLocale;
      }
      this.formater = formater2 || defaultFormatter;
      this.messages = messages2 || {};
      this.setLocale(locale || LOCALE_EN);
      if (watcher) {
        this.watchLocale(watcher);
      }
    }
    setLocale(locale) {
      const oldLocale = this.locale;
      this.locale = normalizeLocale(locale, this.messages) || this.fallbackLocale;
      if (!this.messages[this.locale]) {
        this.messages[this.locale] = {};
      }
      this.message = this.messages[this.locale];
      if (oldLocale !== this.locale) {
        this.watchers.forEach((watcher) => {
          watcher(this.locale, oldLocale);
        });
      }
    }
    getLocale() {
      return this.locale;
    }
    watchLocale(fn) {
      const index = this.watchers.push(fn) - 1;
      return () => {
        this.watchers.splice(index, 1);
      };
    }
    add(locale, message, override = true) {
      const curMessages = this.messages[locale];
      if (curMessages) {
        if (override) {
          Object.assign(curMessages, message);
        } else {
          Object.keys(message).forEach((key) => {
            if (!hasOwn(curMessages, key)) {
              curMessages[key] = message[key];
            }
          });
        }
      } else {
        this.messages[locale] = message;
      }
    }
    f(message, values, delimiters) {
      return this.formater.interpolate(message, values, delimiters).join("");
    }
    t(key, locale, values) {
      let message = this.message;
      if (typeof locale === "string") {
        locale = normalizeLocale(locale, this.messages);
        locale && (message = this.messages[locale]);
      } else {
        values = locale;
      }
      if (!hasOwn(message, key)) {
        console.warn(`Cannot translate the value of keypath ${key}. Use the value of keypath as default.`);
        return key;
      }
      return this.formater.interpolate(message[key], values).join("");
    }
  }
  function watchAppLocale(appVm, i18n) {
    if (appVm.$watchLocale) {
      appVm.$watchLocale((newLocale) => {
        i18n.setLocale(newLocale);
      });
    } else {
      appVm.$watch(() => appVm.$locale, (newLocale) => {
        i18n.setLocale(newLocale);
      });
    }
  }
  function getDefaultLocale() {
    if (typeof uni !== "undefined" && uni.getLocale) {
      return uni.getLocale();
    }
    if (typeof global !== "undefined" && global.getLocale) {
      return global.getLocale();
    }
    return LOCALE_EN;
  }
  function initVueI18n(locale, messages2 = {}, fallbackLocale, watcher) {
    if (typeof locale !== "string") {
      const options = [
        messages2,
        locale
      ];
      locale = options[0];
      messages2 = options[1];
    }
    if (typeof locale !== "string") {
      locale = getDefaultLocale();
    }
    if (typeof fallbackLocale !== "string") {
      fallbackLocale = typeof __uniConfig !== "undefined" && __uniConfig.fallbackLocale || LOCALE_EN;
    }
    const i18n = new I18n({
      locale,
      fallbackLocale,
      messages: messages2,
      watcher
    });
    let t2 = (key, values) => {
      if (typeof getApp !== "function") {
        t2 = function(key2, values2) {
          return i18n.t(key2, values2);
        };
      } else {
        let isWatchedAppLocale = false;
        t2 = function(key2, values2) {
          const appVm = getApp().$vm;
          if (appVm) {
            appVm.$locale;
            if (!isWatchedAppLocale) {
              isWatchedAppLocale = true;
              watchAppLocale(appVm, i18n);
            }
          }
          return i18n.t(key2, values2);
        };
      }
      return t2(key, values);
    };
    return {
      i18n,
      f(message, values, delimiters) {
        return i18n.f(message, values, delimiters);
      },
      t(key, values) {
        return t2(key, values);
      },
      add(locale2, message, override = true) {
        return i18n.add(locale2, message, override);
      },
      watch(fn) {
        return i18n.watchLocale(fn);
      },
      getLocale() {
        return i18n.getLocale();
      },
      setLocale(newLocale) {
        return i18n.setLocale(newLocale);
      }
    };
  }
  const en$1 = {
    "uni-load-more.contentdown": "Pull up to show more",
    "uni-load-more.contentrefresh": "loading...",
    "uni-load-more.contentnomore": "No more data"
  };
  const zhHans$1 = {
    "uni-load-more.contentdown": "ä¸Šæ‹‰æ˜¾ç¤ºæ›´å¤š",
    "uni-load-more.contentrefresh": "æ­£åœ¨åŠ è½½...",
    "uni-load-more.contentnomore": "æ²¡æœ‰æ›´å¤šæ•°æ®äº†"
  };
  const zhHant$1 = {
    "uni-load-more.contentdown": "ä¸Šæ‹‰é¡¯ç¤ºæ›´å¤š",
    "uni-load-more.contentrefresh": "æ­£åœ¨åŠ è¼‰...",
    "uni-load-more.contentnomore": "æ²’æœ‰æ›´å¤šæ•¸æ“šäº†"
  };
  const messages$1 = {
    en: en$1,
    "zh-Hans": zhHans$1,
    "zh-Hant": zhHant$1
  };
  let platform$1;
  setTimeout(() => {
    platform$1 = uni.getSystemInfoSync().platform;
  }, 16);
  const {
    t: t$2
  } = initVueI18n(messages$1);
  const _sfc_main$18 = {
    name: "UniLoadMore",
    emits: ["clickLoadMore"],
    props: {
      status: {
        // ä¸Šæ‹‰çš„çŠ¶æ€ï¼šmore-loadingå‰ï¼›loading-loadingä¸­ï¼›noMore-æ²¡æœ‰æ›´å¤šäº†
        type: String,
        default: "more"
      },
      showIcon: {
        type: Boolean,
        default: true
      },
      iconType: {
        type: String,
        default: "auto"
      },
      iconSize: {
        type: Number,
        default: 24
      },
      color: {
        type: String,
        default: "#777777"
      },
      contentText: {
        type: Object,
        default() {
          return {
            contentdown: "",
            contentrefresh: "",
            contentnomore: ""
          };
        }
      },
      showText: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        webviewHide: false,
        platform: platform$1,
        imgBase64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzlBMzU3OTlEOUM0MTFFOUI0NTZDNERBQURBQzI4RkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzlBMzU3OUFEOUM0MTFFOUI0NTZDNERBQURBQzI4RkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDOUEzNTc5N0Q5QzQxMUU5QjQ1NkM0REFBREFDMjhGRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDOUEzNTc5OEQ5QzQxMUU5QjQ1NkM0REFBREFDMjhGRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pt+ALSwAAA6CSURBVHja1FsLkFZVHb98LM+F5bHL8khA1iSeiyQBCRM+YGqKUnnJTDLGI0BGZlKDIU2MMglUiDApEZvSsZnQtBRJtKwQNKQMFYeRDR10WOLd8ljYXdh+v8v5fR3Od+797t1dnOnO/Ofce77z+J//+b/P+ZqtXbs2sJ9MJhNUV1cHJ06cCJo3bx7EPc2aNcvpy7pWrVoF+/fvDyoqKoI2bdoE9fX1F7TjN8a+EXBn/fkfvw942Tf+wYMHg9mzZwfjxo0LDhw4EPa1x2MbFw/fOGfPng1qa2tzcCkILsLDydq2bRsunpOTMM7TD/W/tZDZhPdeKD+yGxHhdu3aBV27dg3OnDlzMVANMheLAO3btw8KCwuDmpoaX5OxbgUIMEq7K8IcPnw4KCsrC/r37x8cP378/4cAXAB3vqSkJMuiDhTkw+XcuXNhOWbMmKBly5YhUT8xArhyFvP0BfwRsAuwxJZJsm/nzp2DTp06he/OU+cZ64K6o0ePBkOHDg2GDx8e6gEbJ5Q/NHNuAJQ1hgBeHUDlR7nVTkY8rQAvAi4z34vR/mPs1FoRsaCgIJThI0eOBC1atEiFGGV+5MiRoS45efJkqFjJFXV1dQuA012m2WcwTw98fy6CqBdsaiIO4CScrGPHjvk4odhavPquRtFWXEC25VgkREKOCh/qDSq+vn37htzD/mZTOmOc5U7zKzBPEedygWshcDyWvs30igAbU+6oyMgJBCFhwQE0fccxN60Ay9iebbjoDh06hMowjQxT4fXq1SskArmHZpkArvixp/kWzHdMeArExSJEaiXIjjRjRJ4DaAGWpibLzXN3Fm1vA5teBgh3j1Rv3bp1YgKwPdmf2p9zcyNYYgPKMfY0T5f5nNYdw158nJ8QawW4CLKwiOBSEgO/hok2eBydR+3dYH+PLxA5J8Vv0KBBwenTp0P2JWAx6+yFEBfs8lMY+y0SWMBNI9E4ThKi58VKTg3FQZS1RQF1cz27eC0QHMu+3E0SkUowjhVt5VdaWhp07949ZHv2Qd1EjDXM2cla1M0nl3GxAs3J9yREzyTdFVKVFOaE9qRA8GM0WebRuo9JGZKA7Mv2SeS/Z8+eoQ9BArMfFrLGo6jvxbhHbJZnKX2Rzz1O7QhJJ9Cs2ZMaWIyq/zhdeqPNfIoHd58clIQD+JSXl4dKlyIAuBdVXZwFVWKspSSoxE++h8x4k3uCnEhE4I5KwRiFWGOU0QWKiCYLbdoRMRKAu2kQ9vkfLU6dOhX06NEjlH+yMRZSinnuyWnYosVcji8CEA/6Cg2JF+IIUBqnGKUTCNwtwBN4f89RiK1R96DEgO2o0NDmtEdvVFdVVYV+P3UAPUEs6GFwV3PHmXkD4vh74iDFJysVI/MlaQhwKeBNTLYX5VuA8T4/gZxA4MRGFxDB6R7OmYPfyykGRJbyie+XnGYnQIC/coH9+vULiYrxrkL9ZA9+0ykaHIfEpM7ge8TiJ2CsHYwyMfafAF1yCGBHYIbCVDjDjKt7BeB51D+LgQa6OkG7IDYEEtvQ7lnXLKLtLdLuJBpE4gPUXcW2+PkZwOex+4cGDhwYDBkyRL7/HFcEwUGPo/8uWRUpYnfxGHco8HkewLHLyYmAawAPuIFZxhOpDfJQ8gbUv41yORAptMWBNr6oqMhWird5+u+iHmBb2nhjDV7HWBNQTgK8y11l5NetWzc5ULscAtSj7nbNI0skhWeUZCc0W4nyH/jO4Vz0u1IeYhbk4AiwM6tjxIWByHsoZ9qcIBPJd/y+DwPfBESOmCa/QF3WiZHucLlEDpNxcNhmheEOPgdQNx6/VZFQzFZ5TN08AHXQt2Ii3EdyFuUsPtTcGPhW5iMiCNELvz+Gdn9huG4HUJaW/w3g0wxV0XaG7arG2WeKiUWYM4Y7GO5ezshTARbbWGw/DvXkpp/ivVvE0JVoMxN4rpGzJMhE5Pl+xlATsDIqikP9F9D2z3h9nOksEUFhK+qO4rcPkoalMQ/HqJLIyb3F3JdjrCcw1yZ8joyJLR5gCo54etlag7qIoeNh1N1BRYj3DTFJ0elotxPlVzkGuYAmL0VSJVGAJA41c4Z6A3BzTLfn0HYwYKEI6CUAMzZEWvLsIcQOo1AmmyyM72nHJCfYsogflGV6jEk9vyQZXSuq6w4c16NsGcGZbwOPr+H1RkOk2LEzjNepxQkihHSCQ4ynAYNRx2zMKV92CQMWqj8J0BRE8EShxRFN6YrfCRhC0x3r/Zm4IbQCcmJoV0kMamllccR6FjHqUC5F2R/wS2dcymOlfAKOS4KmzQb5cpNC2MC7JhVn5wjXoJ44rYhLh8n0eXOCorJxa7POjbSlCGVczr34/RsAmrcvo9s+wGp3tzVhntxiXiJ4nvEYb4FJkf0O8HocAePmLvCxnL0AORraVekJk6TYjDabRVXfRE2lCN1h6ZQRN1+InUbsCpKwoBZHh0dODN9JBCUffItXxEavTQkUtnfTVAplCWL3JISz29h4NjotnuSsQKJCk8dF+kJR6RARjrqFVmfPnj3ZbK8cIJ0msd6jgHPGtfVTQ8VLmlvh4mct9sobRmPic0DyDQQnx/NlfYUgyz59+oScsH379pAwXABD32nTpoUHIToESeI5mnbE/UqDdyLcafEBf2MCqgC7NwxIbMREJQ0g4D4sfJwnD+AmRrII05cfMWJE+L1169bQr+fip06dGp4oJ83lmYd5wj/EmMa4TaHivo4EeCguYZBnkB5g2aWA69OIEnUHOaGysjIYMGBAMGnSpODYsWPZwCpFmm4lNq+4gSLQA7jcX8DwtjEyRC8wjabnXEx9kfWnTJkSJkAo90xpJVV+FmcVNeYAF5zWngS4C4O91MBxmAv8blLEpbjI5sz9MTdAhcgkCT1RO8mZkAjfiYpTEvStAS53Uw1vAiUGgZ3GpuQEYvoiBqlIan7kSDHnTwJQFNiPu0+5VxCVYhcZIjNrdXUDdp+Eq5AZ3Gkg8QAyVZRZIk4Tl4QAbF9cXJxNYZMAtAokgs4BrNxEpCtteXg7DDTMDKYNSuQdKsnJBek7HxewvxaosWxLYXtw+cJp18217wql4aKCfBNoEu0O5VU+PhctJ0YeXD4C6JQpyrlpSLTojpGGGN5YwNziChdIZLk4lvLcFJ9jMX3QdiImY9bmGQU+TRUL5CHITTRlgF8D9ouD1MfmLoEPl5xokIumZ2cfgMpHt47IW9N64Hsh7wQYYjyIugWuF5fCqYncXRd5vPMWyizzvhi/32+nvG0dZc9vR6fZOu0md5e+uC408FvKSIOZwXlGvxPv95izA2Vtvg1xKFWARI+vMX66HUhpQQb643uW1bSjuTWyw2SBvDrBvjFic1eGGlz5esq3ko9uSIlBRqPuFcCv8F4WIcN12nVaBd0SaYwI6PDDImR11JkqgHcPmQssjxIn6bUshygDFJUTxPMpHk+jfjPgupgdnYV2R/g7xSjtpah8RJBewhwf0gGK6XI92u4wXFEU40afJ4DN4h5LcAd+40HI3JgJecuT0c062W0i2hQJUTcxan3/CMW1PF2K6bbA+Daz4xRs1D3Br1Cm0OihKCqizW78/nXAF/G5TXrEcVzaNMH6CyMswqsAHqDyDLEyou8lwOXnKF8DjI6KjV3KzMBiXkDH8ij/H214J5A596ekrZ3F0zXlWeL7+P5eUrNo3/QwC15uxthuzidy7DzKRwEDaAViiDgKbTbz7CJnzo0bN7pIfIiid8SuPwn25o3QCmpnyjlZkyxPP8EomCJzrGb7GJMx7tNsq4MT2xMUYaiErZOluTzKsnz3gwCeCZyVRZJfYplNEokEjwrPtxlxjeYAk+F1F74VAzPxQRNYYdtpOUvWs8J1sGhBJMNsb7igN8plJs1eSmLIhLKE4rvaCX27gOhLpLOsIzJ7qn/i+wZzcvSOZ23/du8TZjwV8zHIXoP4R3ifBxiFz1dcVpa3aPntPE+c6TmIWE9EtcMmAcPdWAhYhAXxcLOQi9L1WhD1Sc8p1d2oL7XGiRKp8F4A2i8K/nfI+y/gsTDJ/YC/8+AD5Uh04KHiGl+cIFPnBDDrPMjwRGkLXyxO4VGbfQWnDH2v0bVWE3C9QOXlepbgjEfIJQI6XDG3z5ahD9cw2pS78ipB85wyScNTvsVzlzzhL8/jRrnmVjfFJK/m3m4nj9vbgQTguT8XZTjsm672R5uJKEaQmBI/c58gyus8ZDagLpEVSJBIyHp4jn++xqPV71OgQgJYEWOtZ/haxRtKmWOBu8xdBLftWltsY84zE6WIEy/eIOWL+BaayMx+KHtL7EAkqdNDLiEXmEMUHniedtJqg9HmZtfvt26vNi0BdG3Ft3g8ZOf7PAu59TxtzivLNIekyi+wD1i8CuUiD9FXAa8C+/xS3JPmZnomyc7H+fb4/Se0bk41Fel621r4cgVxbq91V4jVqwB7HTe2M7jgB+QWHavZkDRPmZcASoZEmBx6i75bGjPcMdL4/VKGFAGWZkGzPG0XAbdL9A81G5LOmUnC9hHKJeO7dcUMjblSl12867ElFTtaGl20xvvLGPdVz/8TVuU7y0x1PG7vtNg24oz9Uo/Z412++VFWI7Fcog9tu9Lm6gvRmIPv9x1xmQAu6RDkXtbOtlGEmpgD5Nvnyc0dcv0EE6cfdi1HmhMf9wDF3k3gtRvEedhxjpgfqPb9PU9iEJHnyOUA7bQUXh6kq/D7l2iTjWv7XOD530BDr8jIrus+srXjt4MzumJMHuTsBa63YKE1+RR5lBjEikCCnWKWiHdzOgKO+nRIBAF88za/IFmJ3eMZov4CYxGBabcpGL8EYx+SeMXJeRwHNsV/h+vdxeuhEpN3ZyNY78Gm2fknJxVGhyjixPiQvVkNzT1elD9Py/aTAL64Hb9vcYmC9zfdXdT/C1LeGbg4rnBaAihDFJH12W5ulfNCNe/xTsP3bp8ikzJs5BF+5PNfAQYAPaseTdsEcaYAAAAASUVORK5CYII="
      };
    },
    computed: {
      iconSnowWidth() {
        return (Math.floor(this.iconSize / 24) || 1) * 2;
      },
      contentdownText() {
        return this.contentText.contentdown || t$2("uni-load-more.contentdown");
      },
      contentrefreshText() {
        return this.contentText.contentrefresh || t$2("uni-load-more.contentrefresh");
      },
      contentnomoreText() {
        return this.contentText.contentnomore || t$2("uni-load-more.contentnomore");
      }
    },
    mounted() {
      var pages2 = getCurrentPages();
      var page = pages2[pages2.length - 1];
      var currentWebview = page.$getAppWebview();
      currentWebview.addEventListener("hide", () => {
        this.webviewHide = true;
      });
      currentWebview.addEventListener("show", () => {
        this.webviewHide = false;
      });
    },
    methods: {
      onClick() {
        this.$emit("clickLoadMore", {
          detail: {
            status: this.status
          }
        });
      }
    }
  };
  function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "uni-load-more",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
    }, [
      !$data.webviewHide && ($props.iconType === "circle" || $props.iconType === "auto" && $data.platform === "android") && $props.status === "loading" && $props.showIcon ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 0,
          style: vue.normalizeStyle({ width: $props.iconSize + "px", height: $props.iconSize + "px" }),
          class: "uni-load-more__img uni-load-more__img--android-MP"
        },
        [
          vue.createElementVNode(
            "view",
            {
              class: "uni-load-more__img-icon",
              style: vue.normalizeStyle({ borderTopColor: $props.color, borderTopWidth: $props.iconSize / 12 })
            },
            null,
            4
            /* STYLE */
          ),
          vue.createElementVNode(
            "view",
            {
              class: "uni-load-more__img-icon",
              style: vue.normalizeStyle({ borderTopColor: $props.color, borderTopWidth: $props.iconSize / 12 })
            },
            null,
            4
            /* STYLE */
          ),
          vue.createElementVNode(
            "view",
            {
              class: "uni-load-more__img-icon",
              style: vue.normalizeStyle({ borderTopColor: $props.color, borderTopWidth: $props.iconSize / 12 })
            },
            null,
            4
            /* STYLE */
          )
        ],
        4
        /* STYLE */
      )) : !$data.webviewHide && $props.status === "loading" && $props.showIcon ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 1,
          style: vue.normalizeStyle({ width: $props.iconSize + "px", height: $props.iconSize + "px" }),
          class: "uni-load-more__img uni-load-more__img--ios-H5"
        },
        [
          vue.createElementVNode("image", {
            src: $data.imgBase64,
            mode: "widthFix"
          }, null, 8, ["src"])
        ],
        4
        /* STYLE */
      )) : vue.createCommentVNode("v-if", true),
      $props.showText ? (vue.openBlock(), vue.createElementBlock(
        "text",
        {
          key: 2,
          class: "uni-load-more__text",
          style: vue.normalizeStyle({ color: $props.color })
        },
        vue.toDisplayString($props.status === "more" ? $options.contentdownText : $props.status === "loading" ? $options.contentrefreshText : $options.contentnomoreText),
        5
        /* TEXT, STYLE */
      )) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const __easycom_0$6 = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$17], ["__scopeId", "data-v-9245e42c"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-load-more/components/uni-load-more/uni-load-more.vue"]]);
  const fontData = [
    {
      "font_class": "arrow-down",
      "unicode": "îš¾"
    },
    {
      "font_class": "arrow-left",
      "unicode": "îš¼"
    },
    {
      "font_class": "arrow-right",
      "unicode": "îš»"
    },
    {
      "font_class": "arrow-up",
      "unicode": "îš½"
    },
    {
      "font_class": "auth",
      "unicode": "îš«"
    },
    {
      "font_class": "auth-filled",
      "unicode": "î›Œ"
    },
    {
      "font_class": "back",
      "unicode": "îš¹"
    },
    {
      "font_class": "bars",
      "unicode": "î˜§"
    },
    {
      "font_class": "calendar",
      "unicode": "îš "
    },
    {
      "font_class": "calendar-filled",
      "unicode": "î›€"
    },
    {
      "font_class": "camera",
      "unicode": "î™š"
    },
    {
      "font_class": "camera-filled",
      "unicode": "î™˜"
    },
    {
      "font_class": "cart",
      "unicode": "î˜±"
    },
    {
      "font_class": "cart-filled",
      "unicode": "î›"
    },
    {
      "font_class": "chat",
      "unicode": "î™"
    },
    {
      "font_class": "chat-filled",
      "unicode": "î™™"
    },
    {
      "font_class": "chatboxes",
      "unicode": "îš–"
    },
    {
      "font_class": "chatboxes-filled",
      "unicode": "îš’"
    },
    {
      "font_class": "chatbubble",
      "unicode": "îš—"
    },
    {
      "font_class": "chatbubble-filled",
      "unicode": "îš”"
    },
    {
      "font_class": "checkbox",
      "unicode": "î˜«"
    },
    {
      "font_class": "checkbox-filled",
      "unicode": "î˜¬"
    },
    {
      "font_class": "checkmarkempty",
      "unicode": "î™œ"
    },
    {
      "font_class": "circle",
      "unicode": "î™›"
    },
    {
      "font_class": "circle-filled",
      "unicode": "î™ž"
    },
    {
      "font_class": "clear",
      "unicode": "î™­"
    },
    {
      "font_class": "close",
      "unicode": "î™³"
    },
    {
      "font_class": "closeempty",
      "unicode": "î™¬"
    },
    {
      "font_class": "cloud-download",
      "unicode": "î™‡"
    },
    {
      "font_class": "cloud-download-filled",
      "unicode": "î™†"
    },
    {
      "font_class": "cloud-upload",
      "unicode": "î™…"
    },
    {
      "font_class": "cloud-upload-filled",
      "unicode": "î™ˆ"
    },
    {
      "font_class": "color",
      "unicode": "î›"
    },
    {
      "font_class": "color-filled",
      "unicode": "î›‰"
    },
    {
      "font_class": "compose",
      "unicode": "î™¿"
    },
    {
      "font_class": "contact",
      "unicode": "îš“"
    },
    {
      "font_class": "contact-filled",
      "unicode": "îš•"
    },
    {
      "font_class": "down",
      "unicode": "îš¸"
    },
    {
      "font_class": "bottom",
      "unicode": "îš¸"
    },
    {
      "font_class": "download",
      "unicode": "îš"
    },
    {
      "font_class": "download-filled",
      "unicode": "îš"
    },
    {
      "font_class": "email",
      "unicode": "îšž"
    },
    {
      "font_class": "email-filled",
      "unicode": "îšš"
    },
    {
      "font_class": "eye",
      "unicode": "î™‘"
    },
    {
      "font_class": "eye-filled",
      "unicode": "î™ª"
    },
    {
      "font_class": "eye-slash",
      "unicode": "îš³"
    },
    {
      "font_class": "eye-slash-filled",
      "unicode": "îš´"
    },
    {
      "font_class": "fire",
      "unicode": "îš¡"
    },
    {
      "font_class": "fire-filled",
      "unicode": "î›…"
    },
    {
      "font_class": "flag",
      "unicode": "î™Ÿ"
    },
    {
      "font_class": "flag-filled",
      "unicode": "î™ "
    },
    {
      "font_class": "folder-add",
      "unicode": "îš©"
    },
    {
      "font_class": "folder-add-filled",
      "unicode": "î›ˆ"
    },
    {
      "font_class": "font",
      "unicode": "îš£"
    },
    {
      "font_class": "forward",
      "unicode": "îšº"
    },
    {
      "font_class": "gear",
      "unicode": "î™¤"
    },
    {
      "font_class": "gear-filled",
      "unicode": "î™¡"
    },
    {
      "font_class": "gift",
      "unicode": "îš¤"
    },
    {
      "font_class": "gift-filled",
      "unicode": "î›„"
    },
    {
      "font_class": "hand-down",
      "unicode": "î˜½"
    },
    {
      "font_class": "hand-down-filled",
      "unicode": "î˜¼"
    },
    {
      "font_class": "hand-up",
      "unicode": "î˜¿"
    },
    {
      "font_class": "hand-up-filled",
      "unicode": "î˜¾"
    },
    {
      "font_class": "headphones",
      "unicode": "î˜°"
    },
    {
      "font_class": "heart",
      "unicode": "î˜¹"
    },
    {
      "font_class": "heart-filled",
      "unicode": "î™"
    },
    {
      "font_class": "help",
      "unicode": "î™¹"
    },
    {
      "font_class": "help-filled",
      "unicode": "î™´"
    },
    {
      "font_class": "home",
      "unicode": "î™¢"
    },
    {
      "font_class": "home-filled",
      "unicode": "î™£"
    },
    {
      "font_class": "image",
      "unicode": "î™°"
    },
    {
      "font_class": "image-filled",
      "unicode": "î™¸"
    },
    {
      "font_class": "images",
      "unicode": "î™"
    },
    {
      "font_class": "images-filled",
      "unicode": "î™‹"
    },
    {
      "font_class": "info",
      "unicode": "î™©"
    },
    {
      "font_class": "info-filled",
      "unicode": "î™‰"
    },
    {
      "font_class": "left",
      "unicode": "îš·"
    },
    {
      "font_class": "link",
      "unicode": "îš¥"
    },
    {
      "font_class": "list",
      "unicode": "î™„"
    },
    {
      "font_class": "location",
      "unicode": "îš®"
    },
    {
      "font_class": "location-filled",
      "unicode": "îš¯"
    },
    {
      "font_class": "locked",
      "unicode": "î™«"
    },
    {
      "font_class": "locked-filled",
      "unicode": "î™¨"
    },
    {
      "font_class": "loop",
      "unicode": "î˜³"
    },
    {
      "font_class": "mail-open",
      "unicode": "î™ƒ"
    },
    {
      "font_class": "mail-open-filled",
      "unicode": "î˜º"
    },
    {
      "font_class": "map",
      "unicode": "î™§"
    },
    {
      "font_class": "map-filled",
      "unicode": "î™¦"
    },
    {
      "font_class": "map-pin",
      "unicode": "îš­"
    },
    {
      "font_class": "map-pin-ellipse",
      "unicode": "îš¬"
    },
    {
      "font_class": "medal",
      "unicode": "îš¢"
    },
    {
      "font_class": "medal-filled",
      "unicode": "î›ƒ"
    },
    {
      "font_class": "mic",
      "unicode": "î™±"
    },
    {
      "font_class": "mic-filled",
      "unicode": "î™·"
    },
    {
      "font_class": "micoff",
      "unicode": "î™¾"
    },
    {
      "font_class": "micoff-filled",
      "unicode": "îš°"
    },
    {
      "font_class": "minus",
      "unicode": "î™¯"
    },
    {
      "font_class": "minus-filled",
      "unicode": "î™½"
    },
    {
      "font_class": "more",
      "unicode": "î™"
    },
    {
      "font_class": "more-filled",
      "unicode": "î™Ž"
    },
    {
      "font_class": "navigate",
      "unicode": "î™®"
    },
    {
      "font_class": "navigate-filled",
      "unicode": "î™º"
    },
    {
      "font_class": "notification",
      "unicode": "îš¦"
    },
    {
      "font_class": "notification-filled",
      "unicode": "î›"
    },
    {
      "font_class": "paperclip",
      "unicode": "î™’"
    },
    {
      "font_class": "paperplane",
      "unicode": "î™²"
    },
    {
      "font_class": "paperplane-filled",
      "unicode": "î™µ"
    },
    {
      "font_class": "person",
      "unicode": "îš™"
    },
    {
      "font_class": "person-filled",
      "unicode": "îš"
    },
    {
      "font_class": "personadd",
      "unicode": "îšŸ"
    },
    {
      "font_class": "personadd-filled",
      "unicode": "îš˜"
    },
    {
      "font_class": "personadd-filled-copy",
      "unicode": "î›‘"
    },
    {
      "font_class": "phone",
      "unicode": "îšœ"
    },
    {
      "font_class": "phone-filled",
      "unicode": "îš›"
    },
    {
      "font_class": "plus",
      "unicode": "î™¶"
    },
    {
      "font_class": "plus-filled",
      "unicode": "î›‡"
    },
    {
      "font_class": "plusempty",
      "unicode": "î™»"
    },
    {
      "font_class": "pulldown",
      "unicode": "î˜²"
    },
    {
      "font_class": "pyq",
      "unicode": "îš‚"
    },
    {
      "font_class": "qq",
      "unicode": "îš€"
    },
    {
      "font_class": "redo",
      "unicode": "î™Š"
    },
    {
      "font_class": "redo-filled",
      "unicode": "î™•"
    },
    {
      "font_class": "refresh",
      "unicode": "î™—"
    },
    {
      "font_class": "refresh-filled",
      "unicode": "î™–"
    },
    {
      "font_class": "refreshempty",
      "unicode": "îš¿"
    },
    {
      "font_class": "reload",
      "unicode": "îš²"
    },
    {
      "font_class": "right",
      "unicode": "îšµ"
    },
    {
      "font_class": "scan",
      "unicode": "î˜ª"
    },
    {
      "font_class": "search",
      "unicode": "î™”"
    },
    {
      "font_class": "settings",
      "unicode": "î™“"
    },
    {
      "font_class": "settings-filled",
      "unicode": "î›Ž"
    },
    {
      "font_class": "shop",
      "unicode": "î˜¯"
    },
    {
      "font_class": "shop-filled",
      "unicode": "î›"
    },
    {
      "font_class": "smallcircle",
      "unicode": "î™¼"
    },
    {
      "font_class": "smallcircle-filled",
      "unicode": "î™¥"
    },
    {
      "font_class": "sound",
      "unicode": "îš„"
    },
    {
      "font_class": "sound-filled",
      "unicode": "îš†"
    },
    {
      "font_class": "spinner-cycle",
      "unicode": "îšŠ"
    },
    {
      "font_class": "staff",
      "unicode": "îš§"
    },
    {
      "font_class": "staff-filled",
      "unicode": "î›‹"
    },
    {
      "font_class": "star",
      "unicode": "îšˆ"
    },
    {
      "font_class": "star-filled",
      "unicode": "îš"
    },
    {
      "font_class": "starhalf",
      "unicode": "îšƒ"
    },
    {
      "font_class": "trash",
      "unicode": "îš‡"
    },
    {
      "font_class": "trash-filled",
      "unicode": "îš…"
    },
    {
      "font_class": "tune",
      "unicode": "îšª"
    },
    {
      "font_class": "tune-filled",
      "unicode": "î›Š"
    },
    {
      "font_class": "undo",
      "unicode": "î™"
    },
    {
      "font_class": "undo-filled",
      "unicode": "î™Œ"
    },
    {
      "font_class": "up",
      "unicode": "îš¶"
    },
    {
      "font_class": "top",
      "unicode": "îš¶"
    },
    {
      "font_class": "upload",
      "unicode": "îš"
    },
    {
      "font_class": "upload-filled",
      "unicode": "îšŽ"
    },
    {
      "font_class": "videocam",
      "unicode": "îšŒ"
    },
    {
      "font_class": "videocam-filled",
      "unicode": "îš‰"
    },
    {
      "font_class": "vip",
      "unicode": "îš¨"
    },
    {
      "font_class": "vip-filled",
      "unicode": "î›†"
    },
    {
      "font_class": "wallet",
      "unicode": "îš±"
    },
    {
      "font_class": "wallet-filled",
      "unicode": "î›‚"
    },
    {
      "font_class": "weibo",
      "unicode": "îš‹"
    },
    {
      "font_class": "weixin",
      "unicode": "îš‘"
    }
  ];
  const getVal$1 = (val) => {
    const reg = /^[0-9]*$/g;
    return typeof val === "number" || reg.test(val) ? val + "px" : val;
  };
  const _sfc_main$17 = {
    name: "UniIcons",
    emits: ["click"],
    props: {
      type: {
        type: String,
        default: ""
      },
      color: {
        type: String,
        default: "#333333"
      },
      size: {
        type: [Number, String],
        default: 16
      },
      customPrefix: {
        type: String,
        default: ""
      },
      fontFamily: {
        type: String,
        default: ""
      }
    },
    data() {
      return {
        icons: fontData
      };
    },
    computed: {
      unicode() {
        let code = this.icons.find((v2) => v2.font_class === this.type);
        if (code) {
          return code.unicode;
        }
        return "";
      },
      iconSize() {
        return getVal$1(this.size);
      },
      styleObj() {
        if (this.fontFamily !== "") {
          return `color: ${this.color}; font-size: ${this.iconSize}; font-family: ${this.fontFamily};`;
        }
        return `color: ${this.color}; font-size: ${this.iconSize};`;
      }
    },
    methods: {
      _onClick() {
        this.$emit("click");
      }
    }
  };
  function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "text",
      {
        style: vue.normalizeStyle($options.styleObj),
        class: vue.normalizeClass(["uni-icons", ["uniui-" + $props.type, $props.customPrefix, $props.customPrefix ? $props.type : ""]]),
        onClick: _cache[0] || (_cache[0] = (...args) => $options._onClick && $options._onClick(...args))
      },
      [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const __easycom_0$5 = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$16], ["__scopeId", "data-v-d31e1c47"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-icons/components/uni-icons/uni-icons.vue"]]);
  const pages = [
    {
      path: "pages/login/camouflageLogin/camouflageLogin",
      style: {
        navigationBarTitleText: "",
        navigationStyle: "custom",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/login/login",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/register/register",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/forgetPassword/forgetPassword",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/fingerLogin/fingerLogin",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/task/task",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/task/task_detail/task_detail",
      style: {
        navigationBarTitleText: "ä»»åŠ¡åˆ—è¡¨",
        "app-plus": {
          scrollIndicator: "none",
          titleNView: {
            buttons: [
              {
                type: "menu"
              }
            ]
          }
        }
      }
    },
    {
      path: "pages/task/task_detail/document/document",
      style: {
        navigationBarTitleText: "æ–‡ä»¶",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/task/task_detail/baidu_map/baidu_map",
      style: {
        navigationBarTitleText: "ç™¾åº¦åœ°å›¾æµ‹è¯•"
      }
    },
    {
      path: "pages/profile/profile",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/message/main",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/message/chat",
      style: {
        navigationBarTitleText: "",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/tabBar/tabBar",
      style: {
        navigationBarTitleText: "é¦–é¡µ",
        navigationStyle: "custom",
        titleNView: {
          autoBackButton: false
        },
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    },
    {
      path: "pages/message/video-call",
      style: {
        navigationBarTitleText: "è§†é¢‘é€šè¯"
      }
    },
    {
      path: "pages/message/ChatComponent/CallReminder",
      style: {
        navigationBarTitleText: ""
      }
    },
    {
      path: "pages/message/video-answer",
      style: {
        navigationBarTitleText: ""
      }
    },
    {
      path: "pages/login/camouflageLogin/inputAccount/inputAccount",
      style: {
        navigationBarTitleText: "",
        navigationStyle: "custom"
      }
    },
    {
      path: "pages/contacts/pages/contacts",
      style: {
        navigationBarTitleText: "é€šè®¯å½•"
      }
    },
    {
      path: "pages/contacts/pages/contacts/create-group-chat/index",
      style: {
        navigationBarTitleText: "å‘èµ·ç¾¤èŠ",
        navigationStyle: "custom"
      }
    },
    {
      path: "pages/contacts/components/ContactDetail/ContactDetailView",
      style: {
        navigationBarTitleText: "è”ç³»äººè¯¦æƒ…"
      }
    },
    {
      path: "pages/message/ChatComponent/MessageReadStatus",
      style: {
        navigationBarTitleText: "æ¶ˆæ¯è¯¦æƒ…",
        "app-plus": {
          scrollIndicator: "none"
        }
      }
    }
  ];
  const globalStyle = {
    navigationBarTextStyle: "black",
    navigationBarTitleText: "uni-app",
    navigationBarBackgroundColor: "#F8F8F8",
    backgroundColor: "#F8F8F8",
    "app-plus": {
      background: "#efeff4",
      bounce: "none"
    }
  };
  const e = {
    pages,
    globalStyle
  };
  var define_process_env_UNI_SECURE_NETWORK_CONFIG_default = [];
  function t$1(e2) {
    return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  function n(e2, t2, n2) {
    return e2(n2 = { path: t2, exports: {}, require: function(e3, t3) {
      return function() {
        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
      }(null == t3 && n2.path);
    } }, n2.exports), n2.exports;
  }
  var s = n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = n2 || function(e3, t3) {
      var n3 = Object.create || /* @__PURE__ */ function() {
        function e4() {
        }
        return function(t4) {
          var n4;
          return e4.prototype = t4, n4 = new e4(), e4.prototype = null, n4;
        };
      }(), s2 = {}, r2 = s2.lib = {}, i2 = r2.Base = { extend: function(e4) {
        var t4 = n3(this);
        return e4 && t4.mixIn(e4), t4.hasOwnProperty("init") && this.init !== t4.init || (t4.init = function() {
          t4.$super.init.apply(this, arguments);
        }), t4.init.prototype = t4, t4.$super = this, t4;
      }, create: function() {
        var e4 = this.extend();
        return e4.init.apply(e4, arguments), e4;
      }, init: function() {
      }, mixIn: function(e4) {
        for (var t4 in e4)
          e4.hasOwnProperty(t4) && (this[t4] = e4[t4]);
        e4.hasOwnProperty("toString") && (this.toString = e4.toString);
      }, clone: function() {
        return this.init.prototype.extend(this);
      } }, o2 = r2.WordArray = i2.extend({ init: function(e4, n4) {
        e4 = this.words = e4 || [], this.sigBytes = n4 != t3 ? n4 : 4 * e4.length;
      }, toString: function(e4) {
        return (e4 || c2).stringify(this);
      }, concat: function(e4) {
        var t4 = this.words, n4 = e4.words, s3 = this.sigBytes, r3 = e4.sigBytes;
        if (this.clamp(), s3 % 4)
          for (var i3 = 0; i3 < r3; i3++) {
            var o3 = n4[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
            t4[s3 + i3 >>> 2] |= o3 << 24 - (s3 + i3) % 4 * 8;
          }
        else
          for (i3 = 0; i3 < r3; i3 += 4)
            t4[s3 + i3 >>> 2] = n4[i3 >>> 2];
        return this.sigBytes += r3, this;
      }, clamp: function() {
        var t4 = this.words, n4 = this.sigBytes;
        t4[n4 >>> 2] &= 4294967295 << 32 - n4 % 4 * 8, t4.length = e3.ceil(n4 / 4);
      }, clone: function() {
        var e4 = i2.clone.call(this);
        return e4.words = this.words.slice(0), e4;
      }, random: function(t4) {
        for (var n4, s3 = [], r3 = function(t5) {
          t5 = t5;
          var n5 = 987654321, s4 = 4294967295;
          return function() {
            var r4 = ((n5 = 36969 * (65535 & n5) + (n5 >> 16) & s4) << 16) + (t5 = 18e3 * (65535 & t5) + (t5 >> 16) & s4) & s4;
            return r4 /= 4294967296, (r4 += 0.5) * (e3.random() > 0.5 ? 1 : -1);
          };
        }, i3 = 0; i3 < t4; i3 += 4) {
          var a3 = r3(4294967296 * (n4 || e3.random()));
          n4 = 987654071 * a3(), s3.push(4294967296 * a3() | 0);
        }
        return new o2.init(s3, t4);
      } }), a2 = s2.enc = {}, c2 = a2.Hex = { stringify: function(e4) {
        for (var t4 = e4.words, n4 = e4.sigBytes, s3 = [], r3 = 0; r3 < n4; r3++) {
          var i3 = t4[r3 >>> 2] >>> 24 - r3 % 4 * 8 & 255;
          s3.push((i3 >>> 4).toString(16)), s3.push((15 & i3).toString(16));
        }
        return s3.join("");
      }, parse: function(e4) {
        for (var t4 = e4.length, n4 = [], s3 = 0; s3 < t4; s3 += 2)
          n4[s3 >>> 3] |= parseInt(e4.substr(s3, 2), 16) << 24 - s3 % 8 * 4;
        return new o2.init(n4, t4 / 2);
      } }, u2 = a2.Latin1 = { stringify: function(e4) {
        for (var t4 = e4.words, n4 = e4.sigBytes, s3 = [], r3 = 0; r3 < n4; r3++) {
          var i3 = t4[r3 >>> 2] >>> 24 - r3 % 4 * 8 & 255;
          s3.push(String.fromCharCode(i3));
        }
        return s3.join("");
      }, parse: function(e4) {
        for (var t4 = e4.length, n4 = [], s3 = 0; s3 < t4; s3++)
          n4[s3 >>> 2] |= (255 & e4.charCodeAt(s3)) << 24 - s3 % 4 * 8;
        return new o2.init(n4, t4);
      } }, l2 = a2.Utf8 = { stringify: function(e4) {
        try {
          return decodeURIComponent(escape(u2.stringify(e4)));
        } catch (e5) {
          throw new Error("Malformed UTF-8 data");
        }
      }, parse: function(e4) {
        return u2.parse(unescape(encodeURIComponent(e4)));
      } }, h2 = r2.BufferedBlockAlgorithm = i2.extend({ reset: function() {
        this._data = new o2.init(), this._nDataBytes = 0;
      }, _append: function(e4) {
        "string" == typeof e4 && (e4 = l2.parse(e4)), this._data.concat(e4), this._nDataBytes += e4.sigBytes;
      }, _process: function(t4) {
        var n4 = this._data, s3 = n4.words, r3 = n4.sigBytes, i3 = this.blockSize, a3 = r3 / (4 * i3), c3 = (a3 = t4 ? e3.ceil(a3) : e3.max((0 | a3) - this._minBufferSize, 0)) * i3, u3 = e3.min(4 * c3, r3);
        if (c3) {
          for (var l3 = 0; l3 < c3; l3 += i3)
            this._doProcessBlock(s3, l3);
          var h3 = s3.splice(0, c3);
          n4.sigBytes -= u3;
        }
        return new o2.init(h3, u3);
      }, clone: function() {
        var e4 = i2.clone.call(this);
        return e4._data = this._data.clone(), e4;
      }, _minBufferSize: 0 });
      r2.Hasher = h2.extend({ cfg: i2.extend(), init: function(e4) {
        this.cfg = this.cfg.extend(e4), this.reset();
      }, reset: function() {
        h2.reset.call(this), this._doReset();
      }, update: function(e4) {
        return this._append(e4), this._process(), this;
      }, finalize: function(e4) {
        return e4 && this._append(e4), this._doFinalize();
      }, blockSize: 16, _createHelper: function(e4) {
        return function(t4, n4) {
          return new e4.init(n4).finalize(t4);
        };
      }, _createHmacHelper: function(e4) {
        return function(t4, n4) {
          return new d2.HMAC.init(e4, n4).finalize(t4);
        };
      } });
      var d2 = s2.algo = {};
      return s2;
    }(Math), n2);
  }), r = s, i = (n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = r, function(e3) {
      var t3 = n2, s2 = t3.lib, r2 = s2.WordArray, i2 = s2.Hasher, o2 = t3.algo, a2 = [];
      !function() {
        for (var t4 = 0; t4 < 64; t4++)
          a2[t4] = 4294967296 * e3.abs(e3.sin(t4 + 1)) | 0;
      }();
      var c2 = o2.MD5 = i2.extend({ _doReset: function() {
        this._hash = new r2.init([1732584193, 4023233417, 2562383102, 271733878]);
      }, _doProcessBlock: function(e4, t4) {
        for (var n3 = 0; n3 < 16; n3++) {
          var s3 = t4 + n3, r3 = e4[s3];
          e4[s3] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8);
        }
        var i3 = this._hash.words, o3 = e4[t4 + 0], c3 = e4[t4 + 1], p2 = e4[t4 + 2], f2 = e4[t4 + 3], g2 = e4[t4 + 4], m2 = e4[t4 + 5], y2 = e4[t4 + 6], _2 = e4[t4 + 7], w2 = e4[t4 + 8], v2 = e4[t4 + 9], I2 = e4[t4 + 10], S2 = e4[t4 + 11], b2 = e4[t4 + 12], k2 = e4[t4 + 13], A2 = e4[t4 + 14], C2 = e4[t4 + 15], P2 = i3[0], T2 = i3[1], x2 = i3[2], O2 = i3[3];
        P2 = u2(P2, T2, x2, O2, o3, 7, a2[0]), O2 = u2(O2, P2, T2, x2, c3, 12, a2[1]), x2 = u2(x2, O2, P2, T2, p2, 17, a2[2]), T2 = u2(T2, x2, O2, P2, f2, 22, a2[3]), P2 = u2(P2, T2, x2, O2, g2, 7, a2[4]), O2 = u2(O2, P2, T2, x2, m2, 12, a2[5]), x2 = u2(x2, O2, P2, T2, y2, 17, a2[6]), T2 = u2(T2, x2, O2, P2, _2, 22, a2[7]), P2 = u2(P2, T2, x2, O2, w2, 7, a2[8]), O2 = u2(O2, P2, T2, x2, v2, 12, a2[9]), x2 = u2(x2, O2, P2, T2, I2, 17, a2[10]), T2 = u2(T2, x2, O2, P2, S2, 22, a2[11]), P2 = u2(P2, T2, x2, O2, b2, 7, a2[12]), O2 = u2(O2, P2, T2, x2, k2, 12, a2[13]), x2 = u2(x2, O2, P2, T2, A2, 17, a2[14]), P2 = l2(P2, T2 = u2(T2, x2, O2, P2, C2, 22, a2[15]), x2, O2, c3, 5, a2[16]), O2 = l2(O2, P2, T2, x2, y2, 9, a2[17]), x2 = l2(x2, O2, P2, T2, S2, 14, a2[18]), T2 = l2(T2, x2, O2, P2, o3, 20, a2[19]), P2 = l2(P2, T2, x2, O2, m2, 5, a2[20]), O2 = l2(O2, P2, T2, x2, I2, 9, a2[21]), x2 = l2(x2, O2, P2, T2, C2, 14, a2[22]), T2 = l2(T2, x2, O2, P2, g2, 20, a2[23]), P2 = l2(P2, T2, x2, O2, v2, 5, a2[24]), O2 = l2(O2, P2, T2, x2, A2, 9, a2[25]), x2 = l2(x2, O2, P2, T2, f2, 14, a2[26]), T2 = l2(T2, x2, O2, P2, w2, 20, a2[27]), P2 = l2(P2, T2, x2, O2, k2, 5, a2[28]), O2 = l2(O2, P2, T2, x2, p2, 9, a2[29]), x2 = l2(x2, O2, P2, T2, _2, 14, a2[30]), P2 = h2(P2, T2 = l2(T2, x2, O2, P2, b2, 20, a2[31]), x2, O2, m2, 4, a2[32]), O2 = h2(O2, P2, T2, x2, w2, 11, a2[33]), x2 = h2(x2, O2, P2, T2, S2, 16, a2[34]), T2 = h2(T2, x2, O2, P2, A2, 23, a2[35]), P2 = h2(P2, T2, x2, O2, c3, 4, a2[36]), O2 = h2(O2, P2, T2, x2, g2, 11, a2[37]), x2 = h2(x2, O2, P2, T2, _2, 16, a2[38]), T2 = h2(T2, x2, O2, P2, I2, 23, a2[39]), P2 = h2(P2, T2, x2, O2, k2, 4, a2[40]), O2 = h2(O2, P2, T2, x2, o3, 11, a2[41]), x2 = h2(x2, O2, P2, T2, f2, 16, a2[42]), T2 = h2(T2, x2, O2, P2, y2, 23, a2[43]), P2 = h2(P2, T2, x2, O2, v2, 4, a2[44]), O2 = h2(O2, P2, T2, x2, b2, 11, a2[45]), x2 = h2(x2, O2, P2, T2, C2, 16, a2[46]), P2 = d2(P2, T2 = h2(T2, x2, O2, P2, p2, 23, a2[47]), x2, O2, o3, 6, a2[48]), O2 = d2(O2, P2, T2, x2, _2, 10, a2[49]), x2 = d2(x2, O2, P2, T2, A2, 15, a2[50]), T2 = d2(T2, x2, O2, P2, m2, 21, a2[51]), P2 = d2(P2, T2, x2, O2, b2, 6, a2[52]), O2 = d2(O2, P2, T2, x2, f2, 10, a2[53]), x2 = d2(x2, O2, P2, T2, I2, 15, a2[54]), T2 = d2(T2, x2, O2, P2, c3, 21, a2[55]), P2 = d2(P2, T2, x2, O2, w2, 6, a2[56]), O2 = d2(O2, P2, T2, x2, C2, 10, a2[57]), x2 = d2(x2, O2, P2, T2, y2, 15, a2[58]), T2 = d2(T2, x2, O2, P2, k2, 21, a2[59]), P2 = d2(P2, T2, x2, O2, g2, 6, a2[60]), O2 = d2(O2, P2, T2, x2, S2, 10, a2[61]), x2 = d2(x2, O2, P2, T2, p2, 15, a2[62]), T2 = d2(T2, x2, O2, P2, v2, 21, a2[63]), i3[0] = i3[0] + P2 | 0, i3[1] = i3[1] + T2 | 0, i3[2] = i3[2] + x2 | 0, i3[3] = i3[3] + O2 | 0;
      }, _doFinalize: function() {
        var t4 = this._data, n3 = t4.words, s3 = 8 * this._nDataBytes, r3 = 8 * t4.sigBytes;
        n3[r3 >>> 5] |= 128 << 24 - r3 % 32;
        var i3 = e3.floor(s3 / 4294967296), o3 = s3;
        n3[15 + (r3 + 64 >>> 9 << 4)] = 16711935 & (i3 << 8 | i3 >>> 24) | 4278255360 & (i3 << 24 | i3 >>> 8), n3[14 + (r3 + 64 >>> 9 << 4)] = 16711935 & (o3 << 8 | o3 >>> 24) | 4278255360 & (o3 << 24 | o3 >>> 8), t4.sigBytes = 4 * (n3.length + 1), this._process();
        for (var a3 = this._hash, c3 = a3.words, u3 = 0; u3 < 4; u3++) {
          var l3 = c3[u3];
          c3[u3] = 16711935 & (l3 << 8 | l3 >>> 24) | 4278255360 & (l3 << 24 | l3 >>> 8);
        }
        return a3;
      }, clone: function() {
        var e4 = i2.clone.call(this);
        return e4._hash = this._hash.clone(), e4;
      } });
      function u2(e4, t4, n3, s3, r3, i3, o3) {
        var a3 = e4 + (t4 & n3 | ~t4 & s3) + r3 + o3;
        return (a3 << i3 | a3 >>> 32 - i3) + t4;
      }
      function l2(e4, t4, n3, s3, r3, i3, o3) {
        var a3 = e4 + (t4 & s3 | n3 & ~s3) + r3 + o3;
        return (a3 << i3 | a3 >>> 32 - i3) + t4;
      }
      function h2(e4, t4, n3, s3, r3, i3, o3) {
        var a3 = e4 + (t4 ^ n3 ^ s3) + r3 + o3;
        return (a3 << i3 | a3 >>> 32 - i3) + t4;
      }
      function d2(e4, t4, n3, s3, r3, i3, o3) {
        var a3 = e4 + (n3 ^ (t4 | ~s3)) + r3 + o3;
        return (a3 << i3 | a3 >>> 32 - i3) + t4;
      }
      t3.MD5 = i2._createHelper(c2), t3.HmacMD5 = i2._createHmacHelper(c2);
    }(Math), n2.MD5);
  }), n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = r, void function() {
      var e3 = n2, t3 = e3.lib.Base, s2 = e3.enc.Utf8;
      e3.algo.HMAC = t3.extend({ init: function(e4, t4) {
        e4 = this._hasher = new e4.init(), "string" == typeof t4 && (t4 = s2.parse(t4));
        var n3 = e4.blockSize, r2 = 4 * n3;
        t4.sigBytes > r2 && (t4 = e4.finalize(t4)), t4.clamp();
        for (var i2 = this._oKey = t4.clone(), o2 = this._iKey = t4.clone(), a2 = i2.words, c2 = o2.words, u2 = 0; u2 < n3; u2++)
          a2[u2] ^= 1549556828, c2[u2] ^= 909522486;
        i2.sigBytes = o2.sigBytes = r2, this.reset();
      }, reset: function() {
        var e4 = this._hasher;
        e4.reset(), e4.update(this._iKey);
      }, update: function(e4) {
        return this._hasher.update(e4), this;
      }, finalize: function(e4) {
        var t4 = this._hasher, n3 = t4.finalize(e4);
        return t4.reset(), t4.finalize(this._oKey.clone().concat(n3));
      } });
    }());
  }), n(function(e2, t2) {
    e2.exports = r.HmacMD5;
  })), o = n(function(e2, t2) {
    e2.exports = r.enc.Utf8;
  }), a = n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = r, function() {
      var e3 = n2, t3 = e3.lib.WordArray;
      function s2(e4, n3, s3) {
        for (var r2 = [], i2 = 0, o2 = 0; o2 < n3; o2++)
          if (o2 % 4) {
            var a2 = s3[e4.charCodeAt(o2 - 1)] << o2 % 4 * 2, c2 = s3[e4.charCodeAt(o2)] >>> 6 - o2 % 4 * 2;
            r2[i2 >>> 2] |= (a2 | c2) << 24 - i2 % 4 * 8, i2++;
          }
        return t3.create(r2, i2);
      }
      e3.enc.Base64 = { stringify: function(e4) {
        var t4 = e4.words, n3 = e4.sigBytes, s3 = this._map;
        e4.clamp();
        for (var r2 = [], i2 = 0; i2 < n3; i2 += 3)
          for (var o2 = (t4[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) << 16 | (t4[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255) << 8 | t4[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255, a2 = 0; a2 < 4 && i2 + 0.75 * a2 < n3; a2++)
            r2.push(s3.charAt(o2 >>> 6 * (3 - a2) & 63));
        var c2 = s3.charAt(64);
        if (c2)
          for (; r2.length % 4; )
            r2.push(c2);
        return r2.join("");
      }, parse: function(e4) {
        var t4 = e4.length, n3 = this._map, r2 = this._reverseMap;
        if (!r2) {
          r2 = this._reverseMap = [];
          for (var i2 = 0; i2 < n3.length; i2++)
            r2[n3.charCodeAt(i2)] = i2;
        }
        var o2 = n3.charAt(64);
        if (o2) {
          var a2 = e4.indexOf(o2);
          -1 !== a2 && (t4 = a2);
        }
        return s2(e4, t4, r2);
      }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
    }(), n2.enc.Base64);
  });
  const c = "FUNCTION", u = "OBJECT", l = "CLIENT_DB", h = "pending", d = "fulfilled", p = "rejected";
  function f(e2) {
    return Object.prototype.toString.call(e2).slice(8, -1).toLowerCase();
  }
  function g(e2) {
    return "object" === f(e2);
  }
  function m(e2) {
    return "function" == typeof e2;
  }
  function y(e2) {
    return function() {
      try {
        return e2.apply(e2, arguments);
      } catch (e3) {
        console.error(e3);
      }
    };
  }
  const _ = "REJECTED", w = "NOT_PENDING";
  class v {
    constructor({ createPromise: e2, retryRule: t2 = _ } = {}) {
      this.createPromise = e2, this.status = null, this.promise = null, this.retryRule = t2;
    }
    get needRetry() {
      if (!this.status)
        return true;
      switch (this.retryRule) {
        case _:
          return this.status === p;
        case w:
          return this.status !== h;
      }
    }
    exec() {
      return this.needRetry ? (this.status = h, this.promise = this.createPromise().then((e2) => (this.status = d, Promise.resolve(e2)), (e2) => (this.status = p, Promise.reject(e2))), this.promise) : this.promise;
    }
  }
  function I(e2) {
    return e2 && "string" == typeof e2 ? JSON.parse(e2) : e2;
  }
  const S = true, b = "app", A = I(define_process_env_UNI_SECURE_NETWORK_CONFIG_default), C = b, P = I(""), T = I("[]") || [];
  let O = "";
  try {
    O = "__UNI__2368BC0";
  } catch (e2) {
  }
  let E = {};
  function L(e2, t2 = {}) {
    var n2, s2;
    return n2 = E, s2 = e2, Object.prototype.hasOwnProperty.call(n2, s2) || (E[e2] = t2), E[e2];
  }
  E = uni._globalUniCloudObj ? uni._globalUniCloudObj : uni._globalUniCloudObj = {};
  const R = ["invoke", "success", "fail", "complete"], U = L("_globalUniCloudInterceptor");
  function N(e2, t2) {
    U[e2] || (U[e2] = {}), g(t2) && Object.keys(t2).forEach((n2) => {
      R.indexOf(n2) > -1 && function(e3, t3, n3) {
        let s2 = U[e3][t3];
        s2 || (s2 = U[e3][t3] = []), -1 === s2.indexOf(n3) && m(n3) && s2.push(n3);
      }(e2, n2, t2[n2]);
    });
  }
  function D(e2, t2) {
    U[e2] || (U[e2] = {}), g(t2) ? Object.keys(t2).forEach((n2) => {
      R.indexOf(n2) > -1 && function(e3, t3, n3) {
        const s2 = U[e3][t3];
        if (!s2)
          return;
        const r2 = s2.indexOf(n3);
        r2 > -1 && s2.splice(r2, 1);
      }(e2, n2, t2[n2]);
    }) : delete U[e2];
  }
  function M(e2, t2) {
    return e2 && 0 !== e2.length ? e2.reduce((e3, n2) => e3.then(() => n2(t2)), Promise.resolve()) : Promise.resolve();
  }
  function q(e2, t2) {
    return U[e2] && U[e2][t2] || [];
  }
  function F(e2) {
    N("callObject", e2);
  }
  const K = L("_globalUniCloudListener"), j = "response", $ = "needLogin", B = "refreshToken", W = "clientdb", H = "cloudfunction", J = "cloudobject";
  function z(e2) {
    return K[e2] || (K[e2] = []), K[e2];
  }
  function V(e2, t2) {
    const n2 = z(e2);
    n2.includes(t2) || n2.push(t2);
  }
  function G(e2, t2) {
    const n2 = z(e2), s2 = n2.indexOf(t2);
    -1 !== s2 && n2.splice(s2, 1);
  }
  function Y(e2, t2) {
    const n2 = z(e2);
    for (let e3 = 0; e3 < n2.length; e3++) {
      (0, n2[e3])(t2);
    }
  }
  let Q, X = false;
  function Z() {
    return Q || (Q = new Promise((e2) => {
      X && e2(), function t2() {
        if ("function" == typeof getCurrentPages) {
          const t3 = getCurrentPages();
          t3 && t3[0] && (X = true, e2());
        }
        X || setTimeout(() => {
          t2();
        }, 30);
      }();
    }), Q);
  }
  function ee(e2) {
    const t2 = {};
    for (const n2 in e2) {
      const s2 = e2[n2];
      m(s2) && (t2[n2] = y(s2));
    }
    return t2;
  }
  class te extends Error {
    constructor(e2) {
      super(e2.message), this.errMsg = e2.message || e2.errMsg || "unknown system error", this.code = this.errCode = e2.code || e2.errCode || "SYSTEM_ERROR", this.errSubject = this.subject = e2.subject || e2.errSubject, this.cause = e2.cause, this.requestId = e2.requestId;
    }
    toJson(e2 = 0) {
      if (!(e2 >= 10))
        return e2++, { errCode: this.errCode, errMsg: this.errMsg, errSubject: this.errSubject, cause: this.cause && this.cause.toJson ? this.cause.toJson(e2) : this.cause };
    }
  }
  var ne = { request: (e2) => uni.request(e2), uploadFile: (e2) => uni.uploadFile(e2), setStorageSync: (e2, t2) => uni.setStorageSync(e2, t2), getStorageSync: (e2) => uni.getStorageSync(e2), removeStorageSync: (e2) => uni.removeStorageSync(e2), clearStorageSync: () => uni.clearStorageSync(), connectSocket: (e2) => uni.connectSocket(e2) };
  function se(e2) {
    return e2 && se(e2.__v_raw) || e2;
  }
  function re() {
    return { token: ne.getStorageSync("uni_id_token") || ne.getStorageSync("uniIdToken"), tokenExpired: ne.getStorageSync("uni_id_token_expired") };
  }
  function ie({ token: e2, tokenExpired: t2 } = {}) {
    e2 && ne.setStorageSync("uni_id_token", e2), t2 && ne.setStorageSync("uni_id_token_expired", t2);
  }
  let oe, ae;
  function ce() {
    return oe || (oe = uni.getSystemInfoSync()), oe;
  }
  function ue() {
    let e2, t2;
    try {
      if (uni.getLaunchOptionsSync) {
        if (uni.getLaunchOptionsSync.toString().indexOf("not yet implemented") > -1)
          return;
        const { scene: n2, channel: s2 } = uni.getLaunchOptionsSync();
        e2 = s2, t2 = n2;
      }
    } catch (e3) {
    }
    return { channel: e2, scene: t2 };
  }
  let le = {};
  function he() {
    const e2 = uni.getLocale && uni.getLocale() || "en";
    if (ae)
      return { ...le, ...ae, locale: e2, LOCALE: e2 };
    const t2 = ce(), { deviceId: n2, osName: s2, uniPlatform: r2, appId: i2 } = t2, o2 = ["appId", "appLanguage", "appName", "appVersion", "appVersionCode", "appWgtVersion", "browserName", "browserVersion", "deviceBrand", "deviceId", "deviceModel", "deviceType", "osName", "osVersion", "romName", "romVersion", "ua", "hostName", "hostVersion", "uniPlatform", "uniRuntimeVersion", "uniRuntimeVersionCode", "uniCompilerVersion", "uniCompilerVersionCode"];
    for (const e3 in t2)
      Object.hasOwnProperty.call(t2, e3) && -1 === o2.indexOf(e3) && delete t2[e3];
    return ae = { PLATFORM: r2, OS: s2, APPID: i2, DEVICEID: n2, ...ue(), ...t2 }, { ...le, ...ae, locale: e2, LOCALE: e2 };
  }
  var de = { sign: function(e2, t2) {
    let n2 = "";
    return Object.keys(e2).sort().forEach(function(t3) {
      e2[t3] && (n2 = n2 + "&" + t3 + "=" + e2[t3]);
    }), n2 = n2.slice(1), i(n2, t2).toString();
  }, wrappedRequest: function(e2, t2) {
    return new Promise((n2, s2) => {
      t2(Object.assign(e2, { complete(e3) {
        e3 || (e3 = {});
        const t3 = e3.data && e3.data.header && e3.data.header["x-serverless-request-id"] || e3.header && e3.header["request-id"];
        if (!e3.statusCode || e3.statusCode >= 400) {
          const n3 = e3.data && e3.data.error && e3.data.error.code || "SYS_ERR", r3 = e3.data && e3.data.error && e3.data.error.message || e3.errMsg || "request:fail";
          return s2(new te({ code: n3, message: r3, requestId: t3 }));
        }
        const r2 = e3.data;
        if (r2.error)
          return s2(new te({ code: r2.error.code, message: r2.error.message, requestId: t3 }));
        r2.result = r2.data, r2.requestId = t3, delete r2.data, n2(r2);
      } }));
    });
  }, toBase64: function(e2) {
    return a.stringify(o.parse(e2));
  } };
  var pe = class {
    constructor(e2) {
      ["spaceId", "clientSecret"].forEach((t2) => {
        if (!Object.prototype.hasOwnProperty.call(e2, t2))
          throw new Error(`${t2} required`);
      }), this.config = Object.assign({}, { endpoint: 0 === e2.spaceId.indexOf("mp-") ? "https://api.next.bspapp.com" : "https://api.bspapp.com" }, e2), this.config.provider = "aliyun", this.config.requestUrl = this.config.endpoint + "/client", this.config.envType = this.config.envType || "public", this.config.accessTokenKey = "access_token_" + this.config.spaceId, this.adapter = ne, this._getAccessTokenPromiseHub = new v({ createPromise: () => this.requestAuth(this.setupRequest({ method: "serverless.auth.user.anonymousAuthorize", params: "{}" }, "auth")).then((e3) => {
        if (!e3.result || !e3.result.accessToken)
          throw new te({ code: "AUTH_FAILED", message: "èŽ·å–accessTokenå¤±è´¥" });
        this.setAccessToken(e3.result.accessToken);
      }), retryRule: w });
    }
    get hasAccessToken() {
      return !!this.accessToken;
    }
    setAccessToken(e2) {
      this.accessToken = e2;
    }
    requestWrapped(e2) {
      return de.wrappedRequest(e2, this.adapter.request);
    }
    requestAuth(e2) {
      return this.requestWrapped(e2);
    }
    request(e2, t2) {
      return Promise.resolve().then(() => this.hasAccessToken ? t2 ? this.requestWrapped(e2) : this.requestWrapped(e2).catch((t3) => new Promise((e3, n2) => {
        !t3 || "GATEWAY_INVALID_TOKEN" !== t3.code && "InvalidParameter.InvalidToken" !== t3.code ? n2(t3) : e3();
      }).then(() => this.getAccessToken()).then(() => {
        const t4 = this.rebuildRequest(e2);
        return this.request(t4, true);
      })) : this.getAccessToken().then(() => {
        const t3 = this.rebuildRequest(e2);
        return this.request(t3, true);
      }));
    }
    rebuildRequest(e2) {
      const t2 = Object.assign({}, e2);
      return t2.data.token = this.accessToken, t2.header["x-basement-token"] = this.accessToken, t2.header["x-serverless-sign"] = de.sign(t2.data, this.config.clientSecret), t2;
    }
    setupRequest(e2, t2) {
      const n2 = Object.assign({}, e2, { spaceId: this.config.spaceId, timestamp: Date.now() }), s2 = { "Content-Type": "application/json" };
      return "auth" !== t2 && (n2.token = this.accessToken, s2["x-basement-token"] = this.accessToken), s2["x-serverless-sign"] = de.sign(n2, this.config.clientSecret), { url: this.config.requestUrl, method: "POST", data: n2, dataType: "json", header: s2 };
    }
    getAccessToken() {
      return this._getAccessTokenPromiseHub.exec();
    }
    async authorize() {
      await this.getAccessToken();
    }
    callFunction(e2) {
      const t2 = { method: "serverless.function.runtime.invoke", params: JSON.stringify({ functionTarget: e2.name, functionArgs: e2.data || {} }) };
      return this.request({ ...this.setupRequest(t2), timeout: e2.timeout });
    }
    getOSSUploadOptionsFromPath(e2) {
      const t2 = { method: "serverless.file.resource.generateProximalSign", params: JSON.stringify(e2) };
      return this.request(this.setupRequest(t2));
    }
    uploadFileToOSS({ url: e2, formData: t2, name: n2, filePath: s2, fileType: r2, onUploadProgress: i2 }) {
      return new Promise((o2, a2) => {
        const c2 = this.adapter.uploadFile({ url: e2, formData: t2, name: n2, filePath: s2, fileType: r2, header: { "X-OSS-server-side-encrpytion": "AES256" }, success(e3) {
          e3 && e3.statusCode < 400 ? o2(e3) : a2(new te({ code: "UPLOAD_FAILED", message: "æ–‡ä»¶ä¸Šä¼ å¤±è´¥" }));
        }, fail(e3) {
          a2(new te({ code: e3.code || "UPLOAD_FAILED", message: e3.message || e3.errMsg || "æ–‡ä»¶ä¸Šä¼ å¤±è´¥" }));
        } });
        "function" == typeof i2 && c2 && "function" == typeof c2.onProgressUpdate && c2.onProgressUpdate((e3) => {
          i2({ loaded: e3.totalBytesSent, total: e3.totalBytesExpectedToSend });
        });
      });
    }
    reportOSSUpload(e2) {
      const t2 = { method: "serverless.file.resource.report", params: JSON.stringify(e2) };
      return this.request(this.setupRequest(t2));
    }
    async uploadFile({ filePath: e2, cloudPath: t2, fileType: n2 = "image", cloudPathAsRealPath: s2 = false, onUploadProgress: r2, config: i2 }) {
      if ("string" !== f(t2))
        throw new te({ code: "INVALID_PARAM", message: "cloudPathå¿…é¡»ä¸ºå­—ç¬¦ä¸²ç±»åž‹" });
      if (!(t2 = t2.trim()))
        throw new te({ code: "INVALID_PARAM", message: "cloudPathä¸å¯ä¸ºç©º" });
      if (/:\/\//.test(t2))
        throw new te({ code: "INVALID_PARAM", message: "cloudPathä¸åˆæ³•" });
      const o2 = i2 && i2.envType || this.config.envType;
      if (s2 && ("/" !== t2[0] && (t2 = "/" + t2), t2.indexOf("\\") > -1))
        throw new te({ code: "INVALID_PARAM", message: "ä½¿ç”¨cloudPathä½œä¸ºè·¯å¾„æ—¶ï¼ŒcloudPathä¸å¯åŒ…å«â€œ\\â€" });
      const a2 = (await this.getOSSUploadOptionsFromPath({ env: o2, filename: s2 ? t2.split("/").pop() : t2, fileId: s2 ? t2 : void 0 })).result, c2 = "https://" + a2.cdnDomain + "/" + a2.ossPath, { securityToken: u2, accessKeyId: l2, signature: h2, host: d2, ossPath: p2, id: g2, policy: m2, ossCallbackUrl: y2 } = a2, _2 = { "Cache-Control": "max-age=2592000", "Content-Disposition": "attachment", OSSAccessKeyId: l2, Signature: h2, host: d2, id: g2, key: p2, policy: m2, success_action_status: 200 };
      if (u2 && (_2["x-oss-security-token"] = u2), y2) {
        const e3 = JSON.stringify({ callbackUrl: y2, callbackBody: JSON.stringify({ fileId: g2, spaceId: this.config.spaceId }), callbackBodyType: "application/json" });
        _2.callback = de.toBase64(e3);
      }
      const w2 = { url: "https://" + a2.host, formData: _2, fileName: "file", name: "file", filePath: e2, fileType: n2 };
      if (await this.uploadFileToOSS(Object.assign({}, w2, { onUploadProgress: r2 })), y2)
        return { success: true, filePath: e2, fileID: c2 };
      if ((await this.reportOSSUpload({ id: g2 })).success)
        return { success: true, filePath: e2, fileID: c2 };
      throw new te({ code: "UPLOAD_FAILED", message: "æ–‡ä»¶ä¸Šä¼ å¤±è´¥" });
    }
    getTempFileURL({ fileList: e2 } = {}) {
      return new Promise((t2, n2) => {
        Array.isArray(e2) && 0 !== e2.length || n2(new te({ code: "INVALID_PARAM", message: "fileListçš„å…ƒç´ å¿…é¡»æ˜¯éžç©ºçš„å­—ç¬¦ä¸²" })), t2({ fileList: e2.map((e3) => ({ fileID: e3, tempFileURL: e3 })) });
      });
    }
    async getFileInfo({ fileList: e2 } = {}) {
      if (!Array.isArray(e2) || 0 === e2.length)
        throw new te({ code: "INVALID_PARAM", message: "fileListçš„å…ƒç´ å¿…é¡»æ˜¯éžç©ºçš„å­—ç¬¦ä¸²" });
      const t2 = { method: "serverless.file.resource.info", params: JSON.stringify({ id: e2.map((e3) => e3.split("?")[0]).join(",") }) };
      return { fileList: (await this.request(this.setupRequest(t2))).result };
    }
  };
  var fe = { init(e2) {
    const t2 = new pe(e2), n2 = { signInAnonymously: function() {
      return t2.authorize();
    }, getLoginState: function() {
      return Promise.resolve(false);
    } };
    return t2.auth = function() {
      return n2;
    }, t2.customAuth = t2.auth, t2;
  } };
  const ge = "undefined" != typeof location && "http:" === location.protocol ? "http:" : "https:";
  var me;
  !function(e2) {
    e2.local = "local", e2.none = "none", e2.session = "session";
  }(me || (me = {}));
  var ye = function() {
  }, _e = n(function(e2, t2) {
    var n2;
    e2.exports = (n2 = r, function(e3) {
      var t3 = n2, s2 = t3.lib, r2 = s2.WordArray, i2 = s2.Hasher, o2 = t3.algo, a2 = [], c2 = [];
      !function() {
        function t4(t5) {
          for (var n4 = e3.sqrt(t5), s4 = 2; s4 <= n4; s4++)
            if (!(t5 % s4))
              return false;
          return true;
        }
        function n3(e4) {
          return 4294967296 * (e4 - (0 | e4)) | 0;
        }
        for (var s3 = 2, r3 = 0; r3 < 64; )
          t4(s3) && (r3 < 8 && (a2[r3] = n3(e3.pow(s3, 0.5))), c2[r3] = n3(e3.pow(s3, 1 / 3)), r3++), s3++;
      }();
      var u2 = [], l2 = o2.SHA256 = i2.extend({ _doReset: function() {
        this._hash = new r2.init(a2.slice(0));
      }, _doProcessBlock: function(e4, t4) {
        for (var n3 = this._hash.words, s3 = n3[0], r3 = n3[1], i3 = n3[2], o3 = n3[3], a3 = n3[4], l3 = n3[5], h2 = n3[6], d2 = n3[7], p2 = 0; p2 < 64; p2++) {
          if (p2 < 16)
            u2[p2] = 0 | e4[t4 + p2];
          else {
            var f2 = u2[p2 - 15], g2 = (f2 << 25 | f2 >>> 7) ^ (f2 << 14 | f2 >>> 18) ^ f2 >>> 3, m2 = u2[p2 - 2], y2 = (m2 << 15 | m2 >>> 17) ^ (m2 << 13 | m2 >>> 19) ^ m2 >>> 10;
            u2[p2] = g2 + u2[p2 - 7] + y2 + u2[p2 - 16];
          }
          var _2 = s3 & r3 ^ s3 & i3 ^ r3 & i3, w2 = (s3 << 30 | s3 >>> 2) ^ (s3 << 19 | s3 >>> 13) ^ (s3 << 10 | s3 >>> 22), v2 = d2 + ((a3 << 26 | a3 >>> 6) ^ (a3 << 21 | a3 >>> 11) ^ (a3 << 7 | a3 >>> 25)) + (a3 & l3 ^ ~a3 & h2) + c2[p2] + u2[p2];
          d2 = h2, h2 = l3, l3 = a3, a3 = o3 + v2 | 0, o3 = i3, i3 = r3, r3 = s3, s3 = v2 + (w2 + _2) | 0;
        }
        n3[0] = n3[0] + s3 | 0, n3[1] = n3[1] + r3 | 0, n3[2] = n3[2] + i3 | 0, n3[3] = n3[3] + o3 | 0, n3[4] = n3[4] + a3 | 0, n3[5] = n3[5] + l3 | 0, n3[6] = n3[6] + h2 | 0, n3[7] = n3[7] + d2 | 0;
      }, _doFinalize: function() {
        var t4 = this._data, n3 = t4.words, s3 = 8 * this._nDataBytes, r3 = 8 * t4.sigBytes;
        return n3[r3 >>> 5] |= 128 << 24 - r3 % 32, n3[14 + (r3 + 64 >>> 9 << 4)] = e3.floor(s3 / 4294967296), n3[15 + (r3 + 64 >>> 9 << 4)] = s3, t4.sigBytes = 4 * n3.length, this._process(), this._hash;
      }, clone: function() {
        var e4 = i2.clone.call(this);
        return e4._hash = this._hash.clone(), e4;
      } });
      t3.SHA256 = i2._createHelper(l2), t3.HmacSHA256 = i2._createHmacHelper(l2);
    }(Math), n2.SHA256);
  }), we = _e, ve = n(function(e2, t2) {
    e2.exports = r.HmacSHA256;
  });
  const Ie = () => {
    let e2;
    if (!Promise) {
      e2 = () => {
      }, e2.promise = {};
      const t3 = () => {
        throw new te({ message: 'Your Node runtime does support ES6 Promises. Set "global.Promise" to your preferred implementation of promises.' });
      };
      return Object.defineProperty(e2.promise, "then", { get: t3 }), Object.defineProperty(e2.promise, "catch", { get: t3 }), e2;
    }
    const t2 = new Promise((t3, n2) => {
      e2 = (e3, s2) => e3 ? n2(e3) : t3(s2);
    });
    return e2.promise = t2, e2;
  };
  function Se(e2) {
    return void 0 === e2;
  }
  function be(e2) {
    return "[object Null]" === Object.prototype.toString.call(e2);
  }
  var ke;
  function Ae(e2) {
    const t2 = (n2 = e2, "[object Array]" === Object.prototype.toString.call(n2) ? e2 : [e2]);
    var n2;
    for (const e3 of t2) {
      const { isMatch: t3, genAdapter: n3, runtime: s2 } = e3;
      if (t3())
        return { adapter: n3(), runtime: s2 };
    }
  }
  !function(e2) {
    e2.WEB = "web", e2.WX_MP = "wx_mp";
  }(ke || (ke = {}));
  const Ce = { adapter: null, runtime: void 0 }, Pe = ["anonymousUuidKey"];
  class Te extends ye {
    constructor() {
      super(), Ce.adapter.root.tcbObject || (Ce.adapter.root.tcbObject = {});
    }
    setItem(e2, t2) {
      Ce.adapter.root.tcbObject[e2] = t2;
    }
    getItem(e2) {
      return Ce.adapter.root.tcbObject[e2];
    }
    removeItem(e2) {
      delete Ce.adapter.root.tcbObject[e2];
    }
    clear() {
      delete Ce.adapter.root.tcbObject;
    }
  }
  function xe(e2, t2) {
    switch (e2) {
      case "local":
        return t2.localStorage || new Te();
      case "none":
        return new Te();
      default:
        return t2.sessionStorage || new Te();
    }
  }
  class Oe {
    constructor(e2) {
      if (!this._storage) {
        this._persistence = Ce.adapter.primaryStorage || e2.persistence, this._storage = xe(this._persistence, Ce.adapter);
        const t2 = `access_token_${e2.env}`, n2 = `access_token_expire_${e2.env}`, s2 = `refresh_token_${e2.env}`, r2 = `anonymous_uuid_${e2.env}`, i2 = `login_type_${e2.env}`, o2 = `user_info_${e2.env}`;
        this.keys = { accessTokenKey: t2, accessTokenExpireKey: n2, refreshTokenKey: s2, anonymousUuidKey: r2, loginTypeKey: i2, userInfoKey: o2 };
      }
    }
    updatePersistence(e2) {
      if (e2 === this._persistence)
        return;
      const t2 = "local" === this._persistence;
      this._persistence = e2;
      const n2 = xe(e2, Ce.adapter);
      for (const e3 in this.keys) {
        const s2 = this.keys[e3];
        if (t2 && Pe.includes(e3))
          continue;
        const r2 = this._storage.getItem(s2);
        Se(r2) || be(r2) || (n2.setItem(s2, r2), this._storage.removeItem(s2));
      }
      this._storage = n2;
    }
    setStore(e2, t2, n2) {
      if (!this._storage)
        return;
      const s2 = { version: n2 || "localCachev1", content: t2 }, r2 = JSON.stringify(s2);
      try {
        this._storage.setItem(e2, r2);
      } catch (e3) {
        throw e3;
      }
    }
    getStore(e2, t2) {
      try {
        if (!this._storage)
          return;
      } catch (e3) {
        return "";
      }
      t2 = t2 || "localCachev1";
      const n2 = this._storage.getItem(e2);
      if (!n2)
        return "";
      if (n2.indexOf(t2) >= 0) {
        return JSON.parse(n2).content;
      }
      return "";
    }
    removeStore(e2) {
      this._storage.removeItem(e2);
    }
  }
  const Ee = {}, Le = {};
  function Re(e2) {
    return Ee[e2];
  }
  class Ue {
    constructor(e2, t2) {
      this.data = t2 || null, this.name = e2;
    }
  }
  class Ne extends Ue {
    constructor(e2, t2) {
      super("error", { error: e2, data: t2 }), this.error = e2;
    }
  }
  const De = new class {
    constructor() {
      this._listeners = {};
    }
    on(e2, t2) {
      return function(e3, t3, n2) {
        n2[e3] = n2[e3] || [], n2[e3].push(t3);
      }(e2, t2, this._listeners), this;
    }
    off(e2, t2) {
      return function(e3, t3, n2) {
        if (n2 && n2[e3]) {
          const s2 = n2[e3].indexOf(t3);
          -1 !== s2 && n2[e3].splice(s2, 1);
        }
      }(e2, t2, this._listeners), this;
    }
    fire(e2, t2) {
      if (e2 instanceof Ne)
        return console.error(e2.error), this;
      const n2 = "string" == typeof e2 ? new Ue(e2, t2 || {}) : e2;
      const s2 = n2.name;
      if (this._listens(s2)) {
        n2.target = this;
        const e3 = this._listeners[s2] ? [...this._listeners[s2]] : [];
        for (const t3 of e3)
          t3.call(this, n2);
      }
      return this;
    }
    _listens(e2) {
      return this._listeners[e2] && this._listeners[e2].length > 0;
    }
  }();
  function Me(e2, t2) {
    De.on(e2, t2);
  }
  function qe(e2, t2 = {}) {
    De.fire(e2, t2);
  }
  function Fe(e2, t2) {
    De.off(e2, t2);
  }
  const Ke = "loginStateChanged", je = "loginStateExpire", $e = "loginTypeChanged", Be = "anonymousConverted", We = "refreshAccessToken";
  var He;
  !function(e2) {
    e2.ANONYMOUS = "ANONYMOUS", e2.WECHAT = "WECHAT", e2.WECHAT_PUBLIC = "WECHAT-PUBLIC", e2.WECHAT_OPEN = "WECHAT-OPEN", e2.CUSTOM = "CUSTOM", e2.EMAIL = "EMAIL", e2.USERNAME = "USERNAME", e2.NULL = "NULL";
  }(He || (He = {}));
  const Je = ["auth.getJwt", "auth.logout", "auth.signInWithTicket", "auth.signInAnonymously", "auth.signIn", "auth.fetchAccessTokenWithRefreshToken", "auth.signUpWithEmailAndPassword", "auth.activateEndUserMail", "auth.sendPasswordResetEmail", "auth.resetPasswordWithToken", "auth.isUsernameRegistered"], ze = { "X-SDK-Version": "1.3.5" };
  function Ve(e2, t2, n2) {
    const s2 = e2[t2];
    e2[t2] = function(t3) {
      const r2 = {}, i2 = {};
      n2.forEach((n3) => {
        const { data: s3, headers: o3 } = n3.call(e2, t3);
        Object.assign(r2, s3), Object.assign(i2, o3);
      });
      const o2 = t3.data;
      return o2 && (() => {
        var e3;
        if (e3 = o2, "[object FormData]" !== Object.prototype.toString.call(e3))
          t3.data = { ...o2, ...r2 };
        else
          for (const e4 in r2)
            o2.append(e4, r2[e4]);
      })(), t3.headers = { ...t3.headers || {}, ...i2 }, s2.call(e2, t3);
    };
  }
  function Ge() {
    const e2 = Math.random().toString(16).slice(2);
    return { data: { seqId: e2 }, headers: { ...ze, "x-seqid": e2 } };
  }
  class Ye {
    constructor(e2 = {}) {
      var t2;
      this.config = e2, this._reqClass = new Ce.adapter.reqClass({ timeout: this.config.timeout, timeoutMsg: `è¯·æ±‚åœ¨${this.config.timeout / 1e3}så†…æœªå®Œæˆï¼Œå·²ä¸­æ–­`, restrictedMethods: ["post"] }), this._cache = Re(this.config.env), this._localCache = (t2 = this.config.env, Le[t2]), Ve(this._reqClass, "post", [Ge]), Ve(this._reqClass, "upload", [Ge]), Ve(this._reqClass, "download", [Ge]);
    }
    async post(e2) {
      return await this._reqClass.post(e2);
    }
    async upload(e2) {
      return await this._reqClass.upload(e2);
    }
    async download(e2) {
      return await this._reqClass.download(e2);
    }
    async refreshAccessToken() {
      let e2, t2;
      this._refreshAccessTokenPromise || (this._refreshAccessTokenPromise = this._refreshAccessToken());
      try {
        e2 = await this._refreshAccessTokenPromise;
      } catch (e3) {
        t2 = e3;
      }
      if (this._refreshAccessTokenPromise = null, this._shouldRefreshAccessTokenHook = null, t2)
        throw t2;
      return e2;
    }
    async _refreshAccessToken() {
      const { accessTokenKey: e2, accessTokenExpireKey: t2, refreshTokenKey: n2, loginTypeKey: s2, anonymousUuidKey: r2 } = this._cache.keys;
      this._cache.removeStore(e2), this._cache.removeStore(t2);
      let i2 = this._cache.getStore(n2);
      if (!i2)
        throw new te({ message: "æœªç™»å½•CloudBase" });
      const o2 = { refresh_token: i2 }, a2 = await this.request("auth.fetchAccessTokenWithRefreshToken", o2);
      if (a2.data.code) {
        const { code: e3 } = a2.data;
        if ("SIGN_PARAM_INVALID" === e3 || "REFRESH_TOKEN_EXPIRED" === e3 || "INVALID_REFRESH_TOKEN" === e3) {
          if (this._cache.getStore(s2) === He.ANONYMOUS && "INVALID_REFRESH_TOKEN" === e3) {
            const e4 = this._cache.getStore(r2), t3 = this._cache.getStore(n2), s3 = await this.send("auth.signInAnonymously", { anonymous_uuid: e4, refresh_token: t3 });
            return this.setRefreshToken(s3.refresh_token), this._refreshAccessToken();
          }
          qe(je), this._cache.removeStore(n2);
        }
        throw new te({ code: a2.data.code, message: `åˆ·æ–°access tokenå¤±è´¥ï¼š${a2.data.code}` });
      }
      if (a2.data.access_token)
        return qe(We), this._cache.setStore(e2, a2.data.access_token), this._cache.setStore(t2, a2.data.access_token_expire + Date.now()), { accessToken: a2.data.access_token, accessTokenExpire: a2.data.access_token_expire };
      a2.data.refresh_token && (this._cache.removeStore(n2), this._cache.setStore(n2, a2.data.refresh_token), this._refreshAccessToken());
    }
    async getAccessToken() {
      const { accessTokenKey: e2, accessTokenExpireKey: t2, refreshTokenKey: n2 } = this._cache.keys;
      if (!this._cache.getStore(n2))
        throw new te({ message: "refresh tokenä¸å­˜åœ¨ï¼Œç™»å½•çŠ¶æ€å¼‚å¸¸" });
      let s2 = this._cache.getStore(e2), r2 = this._cache.getStore(t2), i2 = true;
      return this._shouldRefreshAccessTokenHook && !await this._shouldRefreshAccessTokenHook(s2, r2) && (i2 = false), (!s2 || !r2 || r2 < Date.now()) && i2 ? this.refreshAccessToken() : { accessToken: s2, accessTokenExpire: r2 };
    }
    async request(e2, t2, n2) {
      const s2 = `x-tcb-trace_${this.config.env}`;
      let r2 = "application/x-www-form-urlencoded";
      const i2 = { action: e2, env: this.config.env, dataVersion: "2019-08-16", ...t2 };
      if (-1 === Je.indexOf(e2)) {
        const { refreshTokenKey: e3 } = this._cache.keys;
        this._cache.getStore(e3) && (i2.access_token = (await this.getAccessToken()).accessToken);
      }
      let o2;
      if ("storage.uploadFile" === e2) {
        o2 = new FormData();
        for (let e3 in o2)
          o2.hasOwnProperty(e3) && void 0 !== o2[e3] && o2.append(e3, i2[e3]);
        r2 = "multipart/form-data";
      } else {
        r2 = "application/json", o2 = {};
        for (let e3 in i2)
          void 0 !== i2[e3] && (o2[e3] = i2[e3]);
      }
      let a2 = { headers: { "content-type": r2 } };
      n2 && n2.timeout && (a2.timeout = n2.timeout), n2 && n2.onUploadProgress && (a2.onUploadProgress = n2.onUploadProgress);
      const c2 = this._localCache.getStore(s2);
      c2 && (a2.headers["X-TCB-Trace"] = c2);
      const { parse: u2, inQuery: l2, search: h2 } = t2;
      let d2 = { env: this.config.env };
      u2 && (d2.parse = true), l2 && (d2 = { ...l2, ...d2 });
      let p2 = function(e3, t3, n3 = {}) {
        const s3 = /\?/.test(t3);
        let r3 = "";
        for (let e4 in n3)
          "" === r3 ? !s3 && (t3 += "?") : r3 += "&", r3 += `${e4}=${encodeURIComponent(n3[e4])}`;
        return /^http(s)?\:\/\//.test(t3 += r3) ? t3 : `${e3}${t3}`;
      }(ge, "//tcb-api.tencentcloudapi.com/web", d2);
      h2 && (p2 += h2);
      const f2 = await this.post({ url: p2, data: o2, ...a2 }), g2 = f2.header && f2.header["x-tcb-trace"];
      if (g2 && this._localCache.setStore(s2, g2), 200 !== Number(f2.status) && 200 !== Number(f2.statusCode) || !f2.data)
        throw new te({ code: "NETWORK_ERROR", message: "network request error" });
      return f2;
    }
    async send(e2, t2 = {}, n2 = {}) {
      const s2 = await this.request(e2, t2, { ...n2, onUploadProgress: t2.onUploadProgress });
      if ("ACCESS_TOKEN_EXPIRED" === s2.data.code && -1 === Je.indexOf(e2)) {
        await this.refreshAccessToken();
        const s3 = await this.request(e2, t2, { ...n2, onUploadProgress: t2.onUploadProgress });
        if (s3.data.code)
          throw new te({ code: s3.data.code, message: s3.data.message });
        return s3.data;
      }
      if (s2.data.code)
        throw new te({ code: s2.data.code, message: s2.data.message });
      return s2.data;
    }
    setRefreshToken(e2) {
      const { accessTokenKey: t2, accessTokenExpireKey: n2, refreshTokenKey: s2 } = this._cache.keys;
      this._cache.removeStore(t2), this._cache.removeStore(n2), this._cache.setStore(s2, e2);
    }
  }
  const Qe = {};
  function Xe(e2) {
    return Qe[e2];
  }
  class Ze {
    constructor(e2) {
      this.config = e2, this._cache = Re(e2.env), this._request = Xe(e2.env);
    }
    setRefreshToken(e2) {
      const { accessTokenKey: t2, accessTokenExpireKey: n2, refreshTokenKey: s2 } = this._cache.keys;
      this._cache.removeStore(t2), this._cache.removeStore(n2), this._cache.setStore(s2, e2);
    }
    setAccessToken(e2, t2) {
      const { accessTokenKey: n2, accessTokenExpireKey: s2 } = this._cache.keys;
      this._cache.setStore(n2, e2), this._cache.setStore(s2, t2);
    }
    async refreshUserInfo() {
      const { data: e2 } = await this._request.send("auth.getUserInfo", {});
      return this.setLocalUserInfo(e2), e2;
    }
    setLocalUserInfo(e2) {
      const { userInfoKey: t2 } = this._cache.keys;
      this._cache.setStore(t2, e2);
    }
  }
  class et {
    constructor(e2) {
      if (!e2)
        throw new te({ code: "PARAM_ERROR", message: "envId is not defined" });
      this._envId = e2, this._cache = Re(this._envId), this._request = Xe(this._envId), this.setUserInfo();
    }
    linkWithTicket(e2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "ticket must be string" });
      return this._request.send("auth.linkWithTicket", { ticket: e2 });
    }
    linkWithRedirect(e2) {
      e2.signInWithRedirect();
    }
    updatePassword(e2, t2) {
      return this._request.send("auth.updatePassword", { oldPassword: t2, newPassword: e2 });
    }
    updateEmail(e2) {
      return this._request.send("auth.updateEmail", { newEmail: e2 });
    }
    updateUsername(e2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "username must be a string" });
      return this._request.send("auth.updateUsername", { username: e2 });
    }
    async getLinkedUidList() {
      const { data: e2 } = await this._request.send("auth.getLinkedUidList", {});
      let t2 = false;
      const { users: n2 } = e2;
      return n2.forEach((e3) => {
        e3.wxOpenId && e3.wxPublicId && (t2 = true);
      }), { users: n2, hasPrimaryUid: t2 };
    }
    setPrimaryUid(e2) {
      return this._request.send("auth.setPrimaryUid", { uid: e2 });
    }
    unlink(e2) {
      return this._request.send("auth.unlink", { platform: e2 });
    }
    async update(e2) {
      const { nickName: t2, gender: n2, avatarUrl: s2, province: r2, country: i2, city: o2 } = e2, { data: a2 } = await this._request.send("auth.updateUserInfo", { nickName: t2, gender: n2, avatarUrl: s2, province: r2, country: i2, city: o2 });
      this.setLocalUserInfo(a2);
    }
    async refresh() {
      const { data: e2 } = await this._request.send("auth.getUserInfo", {});
      return this.setLocalUserInfo(e2), e2;
    }
    setUserInfo() {
      const { userInfoKey: e2 } = this._cache.keys, t2 = this._cache.getStore(e2);
      ["uid", "loginType", "openid", "wxOpenId", "wxPublicId", "unionId", "qqMiniOpenId", "email", "hasPassword", "customUserId", "nickName", "gender", "avatarUrl"].forEach((e3) => {
        this[e3] = t2[e3];
      }), this.location = { country: t2.country, province: t2.province, city: t2.city };
    }
    setLocalUserInfo(e2) {
      const { userInfoKey: t2 } = this._cache.keys;
      this._cache.setStore(t2, e2), this.setUserInfo();
    }
  }
  class tt {
    constructor(e2) {
      if (!e2)
        throw new te({ code: "PARAM_ERROR", message: "envId is not defined" });
      this._cache = Re(e2);
      const { refreshTokenKey: t2, accessTokenKey: n2, accessTokenExpireKey: s2 } = this._cache.keys, r2 = this._cache.getStore(t2), i2 = this._cache.getStore(n2), o2 = this._cache.getStore(s2);
      this.credential = { refreshToken: r2, accessToken: i2, accessTokenExpire: o2 }, this.user = new et(e2);
    }
    get isAnonymousAuth() {
      return this.loginType === He.ANONYMOUS;
    }
    get isCustomAuth() {
      return this.loginType === He.CUSTOM;
    }
    get isWeixinAuth() {
      return this.loginType === He.WECHAT || this.loginType === He.WECHAT_OPEN || this.loginType === He.WECHAT_PUBLIC;
    }
    get loginType() {
      return this._cache.getStore(this._cache.keys.loginTypeKey);
    }
  }
  class nt extends Ze {
    async signIn() {
      this._cache.updatePersistence("local");
      const { anonymousUuidKey: e2, refreshTokenKey: t2 } = this._cache.keys, n2 = this._cache.getStore(e2) || void 0, s2 = this._cache.getStore(t2) || void 0, r2 = await this._request.send("auth.signInAnonymously", { anonymous_uuid: n2, refresh_token: s2 });
      if (r2.uuid && r2.refresh_token) {
        this._setAnonymousUUID(r2.uuid), this.setRefreshToken(r2.refresh_token), await this._request.refreshAccessToken(), qe(Ke), qe($e, { env: this.config.env, loginType: He.ANONYMOUS, persistence: "local" });
        const e3 = new tt(this.config.env);
        return await e3.user.refresh(), e3;
      }
      throw new te({ message: "åŒ¿åç™»å½•å¤±è´¥" });
    }
    async linkAndRetrieveDataWithTicket(e2) {
      const { anonymousUuidKey: t2, refreshTokenKey: n2 } = this._cache.keys, s2 = this._cache.getStore(t2), r2 = this._cache.getStore(n2), i2 = await this._request.send("auth.linkAndRetrieveDataWithTicket", { anonymous_uuid: s2, refresh_token: r2, ticket: e2 });
      if (i2.refresh_token)
        return this._clearAnonymousUUID(), this.setRefreshToken(i2.refresh_token), await this._request.refreshAccessToken(), qe(Be, { env: this.config.env }), qe($e, { loginType: He.CUSTOM, persistence: "local" }), { credential: { refreshToken: i2.refresh_token } };
      throw new te({ message: "åŒ¿åè½¬åŒ–å¤±è´¥" });
    }
    _setAnonymousUUID(e2) {
      const { anonymousUuidKey: t2, loginTypeKey: n2 } = this._cache.keys;
      this._cache.removeStore(t2), this._cache.setStore(t2, e2), this._cache.setStore(n2, He.ANONYMOUS);
    }
    _clearAnonymousUUID() {
      this._cache.removeStore(this._cache.keys.anonymousUuidKey);
    }
  }
  class st extends Ze {
    async signIn(e2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "ticket must be a string" });
      const { refreshTokenKey: t2 } = this._cache.keys, n2 = await this._request.send("auth.signInWithTicket", { ticket: e2, refresh_token: this._cache.getStore(t2) || "" });
      if (n2.refresh_token)
        return this.setRefreshToken(n2.refresh_token), await this._request.refreshAccessToken(), qe(Ke), qe($e, { env: this.config.env, loginType: He.CUSTOM, persistence: this.config.persistence }), await this.refreshUserInfo(), new tt(this.config.env);
      throw new te({ message: "è‡ªå®šä¹‰ç™»å½•å¤±è´¥" });
    }
  }
  class rt extends Ze {
    async signIn(e2, t2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "email must be a string" });
      const { refreshTokenKey: n2 } = this._cache.keys, s2 = await this._request.send("auth.signIn", { loginType: "EMAIL", email: e2, password: t2, refresh_token: this._cache.getStore(n2) || "" }), { refresh_token: r2, access_token: i2, access_token_expire: o2 } = s2;
      if (r2)
        return this.setRefreshToken(r2), i2 && o2 ? this.setAccessToken(i2, o2) : await this._request.refreshAccessToken(), await this.refreshUserInfo(), qe(Ke), qe($e, { env: this.config.env, loginType: He.EMAIL, persistence: this.config.persistence }), new tt(this.config.env);
      throw s2.code ? new te({ code: s2.code, message: `é‚®ç®±ç™»å½•å¤±è´¥: ${s2.message}` }) : new te({ message: "é‚®ç®±ç™»å½•å¤±è´¥" });
    }
    async activate(e2) {
      return this._request.send("auth.activateEndUserMail", { token: e2 });
    }
    async resetPasswordWithToken(e2, t2) {
      return this._request.send("auth.resetPasswordWithToken", { token: e2, newPassword: t2 });
    }
  }
  class it extends Ze {
    async signIn(e2, t2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "username must be a string" });
      "string" != typeof t2 && (t2 = "", console.warn("password is empty"));
      const { refreshTokenKey: n2 } = this._cache.keys, s2 = await this._request.send("auth.signIn", { loginType: He.USERNAME, username: e2, password: t2, refresh_token: this._cache.getStore(n2) || "" }), { refresh_token: r2, access_token_expire: i2, access_token: o2 } = s2;
      if (r2)
        return this.setRefreshToken(r2), o2 && i2 ? this.setAccessToken(o2, i2) : await this._request.refreshAccessToken(), await this.refreshUserInfo(), qe(Ke), qe($e, { env: this.config.env, loginType: He.USERNAME, persistence: this.config.persistence }), new tt(this.config.env);
      throw s2.code ? new te({ code: s2.code, message: `ç”¨æˆ·åå¯†ç ç™»å½•å¤±è´¥: ${s2.message}` }) : new te({ message: "ç”¨æˆ·åå¯†ç ç™»å½•å¤±è´¥" });
    }
  }
  class ot {
    constructor(e2) {
      this.config = e2, this._cache = Re(e2.env), this._request = Xe(e2.env), this._onAnonymousConverted = this._onAnonymousConverted.bind(this), this._onLoginTypeChanged = this._onLoginTypeChanged.bind(this), Me($e, this._onLoginTypeChanged);
    }
    get currentUser() {
      const e2 = this.hasLoginState();
      return e2 && e2.user || null;
    }
    get loginType() {
      return this._cache.getStore(this._cache.keys.loginTypeKey);
    }
    anonymousAuthProvider() {
      return new nt(this.config);
    }
    customAuthProvider() {
      return new st(this.config);
    }
    emailAuthProvider() {
      return new rt(this.config);
    }
    usernameAuthProvider() {
      return new it(this.config);
    }
    async signInAnonymously() {
      return new nt(this.config).signIn();
    }
    async signInWithEmailAndPassword(e2, t2) {
      return new rt(this.config).signIn(e2, t2);
    }
    signInWithUsernameAndPassword(e2, t2) {
      return new it(this.config).signIn(e2, t2);
    }
    async linkAndRetrieveDataWithTicket(e2) {
      this._anonymousAuthProvider || (this._anonymousAuthProvider = new nt(this.config)), Me(Be, this._onAnonymousConverted);
      return await this._anonymousAuthProvider.linkAndRetrieveDataWithTicket(e2);
    }
    async signOut() {
      if (this.loginType === He.ANONYMOUS)
        throw new te({ message: "åŒ¿åç”¨æˆ·ä¸æ”¯æŒç™»å‡ºæ“ä½œ" });
      const { refreshTokenKey: e2, accessTokenKey: t2, accessTokenExpireKey: n2 } = this._cache.keys, s2 = this._cache.getStore(e2);
      if (!s2)
        return;
      const r2 = await this._request.send("auth.logout", { refresh_token: s2 });
      return this._cache.removeStore(e2), this._cache.removeStore(t2), this._cache.removeStore(n2), qe(Ke), qe($e, { env: this.config.env, loginType: He.NULL, persistence: this.config.persistence }), r2;
    }
    async signUpWithEmailAndPassword(e2, t2) {
      return this._request.send("auth.signUpWithEmailAndPassword", { email: e2, password: t2 });
    }
    async sendPasswordResetEmail(e2) {
      return this._request.send("auth.sendPasswordResetEmail", { email: e2 });
    }
    onLoginStateChanged(e2) {
      Me(Ke, () => {
        const t3 = this.hasLoginState();
        e2.call(this, t3);
      });
      const t2 = this.hasLoginState();
      e2.call(this, t2);
    }
    onLoginStateExpired(e2) {
      Me(je, e2.bind(this));
    }
    onAccessTokenRefreshed(e2) {
      Me(We, e2.bind(this));
    }
    onAnonymousConverted(e2) {
      Me(Be, e2.bind(this));
    }
    onLoginTypeChanged(e2) {
      Me($e, () => {
        const t2 = this.hasLoginState();
        e2.call(this, t2);
      });
    }
    async getAccessToken() {
      return { accessToken: (await this._request.getAccessToken()).accessToken, env: this.config.env };
    }
    hasLoginState() {
      const { refreshTokenKey: e2 } = this._cache.keys;
      return this._cache.getStore(e2) ? new tt(this.config.env) : null;
    }
    async isUsernameRegistered(e2) {
      if ("string" != typeof e2)
        throw new te({ code: "PARAM_ERROR", message: "username must be a string" });
      const { data: t2 } = await this._request.send("auth.isUsernameRegistered", { username: e2 });
      return t2 && t2.isRegistered;
    }
    getLoginState() {
      return Promise.resolve(this.hasLoginState());
    }
    async signInWithTicket(e2) {
      return new st(this.config).signIn(e2);
    }
    shouldRefreshAccessToken(e2) {
      this._request._shouldRefreshAccessTokenHook = e2.bind(this);
    }
    getUserInfo() {
      return this._request.send("auth.getUserInfo", {}).then((e2) => e2.code ? e2 : { ...e2.data, requestId: e2.seqId });
    }
    getAuthHeader() {
      const { refreshTokenKey: e2, accessTokenKey: t2 } = this._cache.keys, n2 = this._cache.getStore(e2);
      return { "x-cloudbase-credentials": this._cache.getStore(t2) + "/@@/" + n2 };
    }
    _onAnonymousConverted(e2) {
      const { env: t2 } = e2.data;
      t2 === this.config.env && this._cache.updatePersistence(this.config.persistence);
    }
    _onLoginTypeChanged(e2) {
      const { loginType: t2, persistence: n2, env: s2 } = e2.data;
      s2 === this.config.env && (this._cache.updatePersistence(n2), this._cache.setStore(this._cache.keys.loginTypeKey, t2));
    }
  }
  const at = function(e2, t2) {
    t2 = t2 || Ie();
    const n2 = Xe(this.config.env), { cloudPath: s2, filePath: r2, onUploadProgress: i2, fileType: o2 = "image" } = e2;
    return n2.send("storage.getUploadMetadata", { path: s2 }).then((e3) => {
      const { data: { url: a2, authorization: c2, token: u2, fileId: l2, cosFileId: h2 }, requestId: d2 } = e3, p2 = { key: s2, signature: c2, "x-cos-meta-fileid": h2, success_action_status: "201", "x-cos-security-token": u2 };
      n2.upload({ url: a2, data: p2, file: r2, name: s2, fileType: o2, onUploadProgress: i2 }).then((e4) => {
        201 === e4.statusCode ? t2(null, { fileID: l2, requestId: d2 }) : t2(new te({ code: "STORAGE_REQUEST_FAIL", message: `STORAGE_REQUEST_FAIL: ${e4.data}` }));
      }).catch((e4) => {
        t2(e4);
      });
    }).catch((e3) => {
      t2(e3);
    }), t2.promise;
  }, ct = function(e2, t2) {
    t2 = t2 || Ie();
    const n2 = Xe(this.config.env), { cloudPath: s2 } = e2;
    return n2.send("storage.getUploadMetadata", { path: s2 }).then((e3) => {
      t2(null, e3);
    }).catch((e3) => {
      t2(e3);
    }), t2.promise;
  }, ut = function({ fileList: e2 }, t2) {
    if (t2 = t2 || Ie(), !e2 || !Array.isArray(e2))
      return { code: "INVALID_PARAM", message: "fileListå¿…é¡»æ˜¯éžç©ºçš„æ•°ç»„" };
    for (let t3 of e2)
      if (!t3 || "string" != typeof t3)
        return { code: "INVALID_PARAM", message: "fileListçš„å…ƒç´ å¿…é¡»æ˜¯éžç©ºçš„å­—ç¬¦ä¸²" };
    const n2 = { fileid_list: e2 };
    return Xe(this.config.env).send("storage.batchDeleteFile", n2).then((e3) => {
      e3.code ? t2(null, e3) : t2(null, { fileList: e3.data.delete_list, requestId: e3.requestId });
    }).catch((e3) => {
      t2(e3);
    }), t2.promise;
  }, lt = function({ fileList: e2 }, t2) {
    t2 = t2 || Ie(), e2 && Array.isArray(e2) || t2(null, { code: "INVALID_PARAM", message: "fileListå¿…é¡»æ˜¯éžç©ºçš„æ•°ç»„" });
    let n2 = [];
    for (let s3 of e2)
      "object" == typeof s3 ? (s3.hasOwnProperty("fileID") && s3.hasOwnProperty("maxAge") || t2(null, { code: "INVALID_PARAM", message: "fileListçš„å…ƒç´ å¿…é¡»æ˜¯åŒ…å«fileIDå’ŒmaxAgeçš„å¯¹è±¡" }), n2.push({ fileid: s3.fileID, max_age: s3.maxAge })) : "string" == typeof s3 ? n2.push({ fileid: s3 }) : t2(null, { code: "INVALID_PARAM", message: "fileListçš„å…ƒç´ å¿…é¡»æ˜¯å­—ç¬¦ä¸²" });
    const s2 = { file_list: n2 };
    return Xe(this.config.env).send("storage.batchGetDownloadUrl", s2).then((e3) => {
      e3.code ? t2(null, e3) : t2(null, { fileList: e3.data.download_list, requestId: e3.requestId });
    }).catch((e3) => {
      t2(e3);
    }), t2.promise;
  }, ht = async function({ fileID: e2 }, t2) {
    const n2 = (await lt.call(this, { fileList: [{ fileID: e2, maxAge: 600 }] })).fileList[0];
    if ("SUCCESS" !== n2.code)
      return t2 ? t2(n2) : new Promise((e3) => {
        e3(n2);
      });
    const s2 = Xe(this.config.env);
    let r2 = n2.download_url;
    if (r2 = encodeURI(r2), !t2)
      return s2.download({ url: r2 });
    t2(await s2.download({ url: r2 }));
  }, dt = function({ name: e2, data: t2, query: n2, parse: s2, search: r2, timeout: i2 }, o2) {
    const a2 = o2 || Ie();
    let c2;
    try {
      c2 = t2 ? JSON.stringify(t2) : "";
    } catch (e3) {
      return Promise.reject(e3);
    }
    if (!e2)
      return Promise.reject(new te({ code: "PARAM_ERROR", message: "å‡½æ•°åä¸èƒ½ä¸ºç©º" }));
    const u2 = { inQuery: n2, parse: s2, search: r2, function_name: e2, request_data: c2 };
    return Xe(this.config.env).send("functions.invokeFunction", u2, { timeout: i2 }).then((e3) => {
      if (e3.code)
        a2(null, e3);
      else {
        let t3 = e3.data.response_data;
        if (s2)
          a2(null, { result: t3, requestId: e3.requestId });
        else
          try {
            t3 = JSON.parse(e3.data.response_data), a2(null, { result: t3, requestId: e3.requestId });
          } catch (e4) {
            a2(new te({ message: "response data must be json" }));
          }
      }
      return a2.promise;
    }).catch((e3) => {
      a2(e3);
    }), a2.promise;
  }, pt = { timeout: 15e3, persistence: "session" }, ft = {};
  class gt {
    constructor(e2) {
      this.config = e2 || this.config, this.authObj = void 0;
    }
    init(e2) {
      switch (Ce.adapter || (this.requestClient = new Ce.adapter.reqClass({ timeout: e2.timeout || 5e3, timeoutMsg: `è¯·æ±‚åœ¨${(e2.timeout || 5e3) / 1e3}så†…æœªå®Œæˆï¼Œå·²ä¸­æ–­` })), this.config = { ...pt, ...e2 }, true) {
        case this.config.timeout > 6e5:
          console.warn("timeoutå¤§äºŽå¯é…ç½®ä¸Šé™[10åˆ†é’Ÿ]ï¼Œå·²é‡ç½®ä¸ºä¸Šé™æ•°å€¼"), this.config.timeout = 6e5;
          break;
        case this.config.timeout < 100:
          console.warn("timeoutå°äºŽå¯é…ç½®ä¸‹é™[100ms]ï¼Œå·²é‡ç½®ä¸ºä¸‹é™æ•°å€¼"), this.config.timeout = 100;
      }
      return new gt(this.config);
    }
    auth({ persistence: e2 } = {}) {
      if (this.authObj)
        return this.authObj;
      const t2 = e2 || Ce.adapter.primaryStorage || pt.persistence;
      var n2;
      return t2 !== this.config.persistence && (this.config.persistence = t2), function(e3) {
        const { env: t3 } = e3;
        Ee[t3] = new Oe(e3), Le[t3] = new Oe({ ...e3, persistence: "local" });
      }(this.config), n2 = this.config, Qe[n2.env] = new Ye(n2), this.authObj = new ot(this.config), this.authObj;
    }
    on(e2, t2) {
      return Me.apply(this, [e2, t2]);
    }
    off(e2, t2) {
      return Fe.apply(this, [e2, t2]);
    }
    callFunction(e2, t2) {
      return dt.apply(this, [e2, t2]);
    }
    deleteFile(e2, t2) {
      return ut.apply(this, [e2, t2]);
    }
    getTempFileURL(e2, t2) {
      return lt.apply(this, [e2, t2]);
    }
    downloadFile(e2, t2) {
      return ht.apply(this, [e2, t2]);
    }
    uploadFile(e2, t2) {
      return at.apply(this, [e2, t2]);
    }
    getUploadMetadata(e2, t2) {
      return ct.apply(this, [e2, t2]);
    }
    registerExtension(e2) {
      ft[e2.name] = e2;
    }
    async invokeExtension(e2, t2) {
      const n2 = ft[e2];
      if (!n2)
        throw new te({ message: `æ‰©å±•${e2} å¿…é¡»å…ˆæ³¨å†Œ` });
      return await n2.invoke(t2, this);
    }
    useAdapters(e2) {
      const { adapter: t2, runtime: n2 } = Ae(e2) || {};
      t2 && (Ce.adapter = t2), n2 && (Ce.runtime = n2);
    }
  }
  var mt = new gt();
  function yt(e2, t2, n2) {
    void 0 === n2 && (n2 = {});
    var s2 = /\?/.test(t2), r2 = "";
    for (var i2 in n2)
      "" === r2 ? !s2 && (t2 += "?") : r2 += "&", r2 += i2 + "=" + encodeURIComponent(n2[i2]);
    return /^http(s)?:\/\//.test(t2 += r2) ? t2 : "" + e2 + t2;
  }
  class _t {
    post(e2) {
      const { url: t2, data: n2, headers: s2, timeout: r2 } = e2;
      return new Promise((e3, i2) => {
        ne.request({ url: yt("https:", t2), data: n2, method: "POST", header: s2, timeout: r2, success(t3) {
          e3(t3);
        }, fail(e4) {
          i2(e4);
        } });
      });
    }
    upload(e2) {
      return new Promise((t2, n2) => {
        const { url: s2, file: r2, data: i2, headers: o2, fileType: a2 } = e2, c2 = ne.uploadFile({ url: yt("https:", s2), name: "file", formData: Object.assign({}, i2), filePath: r2, fileType: a2, header: o2, success(e3) {
          const n3 = { statusCode: e3.statusCode, data: e3.data || {} };
          200 === e3.statusCode && i2.success_action_status && (n3.statusCode = parseInt(i2.success_action_status, 10)), t2(n3);
        }, fail(e3) {
          n2(new Error(e3.errMsg || "uploadFile:fail"));
        } });
        "function" == typeof e2.onUploadProgress && c2 && "function" == typeof c2.onProgressUpdate && c2.onProgressUpdate((t3) => {
          e2.onUploadProgress({ loaded: t3.totalBytesSent, total: t3.totalBytesExpectedToSend });
        });
      });
    }
  }
  const wt = { setItem(e2, t2) {
    ne.setStorageSync(e2, t2);
  }, getItem: (e2) => ne.getStorageSync(e2), removeItem(e2) {
    ne.removeStorageSync(e2);
  }, clear() {
    ne.clearStorageSync();
  } };
  var vt = { genAdapter: function() {
    return { root: {}, reqClass: _t, localStorage: wt, primaryStorage: "local" };
  }, isMatch: function() {
    return true;
  }, runtime: "uni_app" };
  mt.useAdapters(vt);
  const It = mt, St = It.init;
  It.init = function(e2) {
    e2.env = e2.spaceId;
    const t2 = St.call(this, e2);
    t2.config.provider = "tencent", t2.config.spaceId = e2.spaceId;
    const n2 = t2.auth;
    return t2.auth = function(e3) {
      const t3 = n2.call(this, e3);
      return ["linkAndRetrieveDataWithTicket", "signInAnonymously", "signOut", "getAccessToken", "getLoginState", "signInWithTicket", "getUserInfo"].forEach((e4) => {
        var n3;
        t3[e4] = (n3 = t3[e4], function(e5) {
          e5 = e5 || {};
          const { success: t4, fail: s2, complete: r2 } = ee(e5);
          if (!(t4 || s2 || r2))
            return n3.call(this, e5);
          n3.call(this, e5).then((e6) => {
            t4 && t4(e6), r2 && r2(e6);
          }, (e6) => {
            s2 && s2(e6), r2 && r2(e6);
          });
        }).bind(t3);
      }), t3;
    }, t2.customAuth = t2.auth, t2;
  };
  var bt = It;
  async function kt(e2, t2) {
    const n2 = `http://${e2}:${t2}/system/ping`;
    try {
      const e3 = await (s2 = { url: n2, timeout: 500 }, new Promise((e4, t3) => {
        ne.request({ ...s2, success(t4) {
          e4(t4);
        }, fail(e5) {
          t3(e5);
        } });
      }));
      return !(!e3.data || 0 !== e3.data.code);
    } catch (e3) {
      return false;
    }
    var s2;
  }
  async function At(e2, t2) {
    let n2;
    for (let s2 = 0; s2 < e2.length; s2++) {
      const r2 = e2[s2];
      if (await kt(r2, t2)) {
        n2 = r2;
        break;
      }
    }
    return { address: n2, port: t2 };
  }
  const Ct = { "serverless.file.resource.generateProximalSign": "storage/generate-proximal-sign", "serverless.file.resource.report": "storage/report", "serverless.file.resource.delete": "storage/delete", "serverless.file.resource.getTempFileURL": "storage/get-temp-file-url" };
  var Pt = class {
    constructor(e2) {
      if (["spaceId", "clientSecret"].forEach((t2) => {
        if (!Object.prototype.hasOwnProperty.call(e2, t2))
          throw new Error(`${t2} required`);
      }), !e2.endpoint)
        throw new Error("é›†ç¾¤ç©ºé—´æœªé…ç½®ApiEndpointï¼Œé…ç½®åŽéœ€è¦é‡æ–°å…³è”æœåŠ¡ç©ºé—´åŽç”Ÿæ•ˆ");
      this.config = Object.assign({}, e2), this.config.provider = "dcloud", this.config.requestUrl = this.config.endpoint + "/client", this.config.envType = this.config.envType || "public", this.adapter = ne;
    }
    async request(e2, t2 = true) {
      const n2 = t2;
      return e2 = n2 ? await this.setupLocalRequest(e2) : this.setupRequest(e2), Promise.resolve().then(() => n2 ? this.requestLocal(e2) : de.wrappedRequest(e2, this.adapter.request));
    }
    requestLocal(e2) {
      return new Promise((t2, n2) => {
        this.adapter.request(Object.assign(e2, { complete(e3) {
          if (e3 || (e3 = {}), !e3.statusCode || e3.statusCode >= 400) {
            const t3 = e3.data && e3.data.code || "SYS_ERR", s2 = e3.data && e3.data.message || "request:fail";
            return n2(new te({ code: t3, message: s2 }));
          }
          t2({ success: true, result: e3.data });
        } }));
      });
    }
    setupRequest(e2) {
      const t2 = Object.assign({}, e2, { spaceId: this.config.spaceId, timestamp: Date.now() }), n2 = { "Content-Type": "application/json" };
      n2["x-serverless-sign"] = de.sign(t2, this.config.clientSecret);
      const s2 = he();
      n2["x-client-info"] = encodeURIComponent(JSON.stringify(s2));
      const { token: r2 } = re();
      return n2["x-client-token"] = r2, { url: this.config.requestUrl, method: "POST", data: t2, dataType: "json", header: JSON.parse(JSON.stringify(n2)) };
    }
    async setupLocalRequest(e2) {
      const t2 = he(), { token: n2 } = re(), s2 = Object.assign({}, e2, { spaceId: this.config.spaceId, timestamp: Date.now(), clientInfo: t2, token: n2 }), { address: r2, servePort: i2 } = this.__dev__ && this.__dev__.debugInfo || {}, { address: o2 } = await At(r2, i2);
      return { url: `http://${o2}:${i2}/${Ct[e2.method]}`, method: "POST", data: s2, dataType: "json", header: JSON.parse(JSON.stringify({ "Content-Type": "application/json" })) };
    }
    callFunction(e2) {
      const t2 = { method: "serverless.function.runtime.invoke", params: JSON.stringify({ functionTarget: e2.name, functionArgs: e2.data || {} }) };
      return this.request(t2, false);
    }
    getUploadFileOptions(e2) {
      const t2 = { method: "serverless.file.resource.generateProximalSign", params: JSON.stringify(e2) };
      return this.request(t2);
    }
    reportUploadFile(e2) {
      const t2 = { method: "serverless.file.resource.report", params: JSON.stringify(e2) };
      return this.request(t2);
    }
    uploadFile({ filePath: e2, cloudPath: t2, fileType: n2 = "image", onUploadProgress: s2 }) {
      if (!t2)
        throw new te({ code: "CLOUDPATH_REQUIRED", message: "cloudPathä¸å¯ä¸ºç©º" });
      let r2;
      return this.getUploadFileOptions({ cloudPath: t2 }).then((t3) => {
        const { url: i2, formData: o2, name: a2 } = t3.result;
        return r2 = t3.result.fileUrl, new Promise((t4, r3) => {
          const c2 = this.adapter.uploadFile({ url: i2, formData: o2, name: a2, filePath: e2, fileType: n2, success(e3) {
            e3 && e3.statusCode < 400 ? t4(e3) : r3(new te({ code: "UPLOAD_FAILED", message: "æ–‡ä»¶ä¸Šä¼ å¤±è´¥" }));
          }, fail(e3) {
            r3(new te({ code: e3.code || "UPLOAD_FAILED", message: e3.message || e3.errMsg || "æ–‡ä»¶ä¸Šä¼ å¤±è´¥" }));
          } });
          "function" == typeof s2 && c2 && "function" == typeof c2.onProgressUpdate && c2.onProgressUpdate((e3) => {
            s2({ loaded: e3.totalBytesSent, total: e3.totalBytesExpectedToSend });
          });
        });
      }).then(() => this.reportUploadFile({ cloudPath: t2 })).then((t3) => new Promise((n3, s3) => {
        t3.success ? n3({ success: true, filePath: e2, fileID: r2 }) : s3(new te({ code: "UPLOAD_FAILED", message: "æ–‡ä»¶ä¸Šä¼ å¤±è´¥" }));
      }));
    }
    deleteFile({ fileList: e2 }) {
      const t2 = { method: "serverless.file.resource.delete", params: JSON.stringify({ fileList: e2 }) };
      return this.request(t2).then((e3) => {
        if (e3.success)
          return e3.result;
        throw new te({ code: "DELETE_FILE_FAILED", message: "åˆ é™¤æ–‡ä»¶å¤±è´¥" });
      });
    }
    getTempFileURL({ fileList: e2, maxAge: t2 } = {}) {
      if (!Array.isArray(e2) || 0 === e2.length)
        throw new te({ code: "INVALID_PARAM", message: "fileListçš„å…ƒç´ å¿…é¡»æ˜¯éžç©ºçš„å­—ç¬¦ä¸²" });
      const n2 = { method: "serverless.file.resource.getTempFileURL", params: JSON.stringify({ fileList: e2, maxAge: t2 }) };
      return this.request(n2).then((e3) => {
        if (e3.success)
          return { fileList: e3.result.fileList.map((e4) => ({ fileID: e4.fileID, tempFileURL: e4.tempFileURL })) };
        throw new te({ code: "GET_TEMP_FILE_URL_FAILED", message: "èŽ·å–ä¸´æ—¶æ–‡ä»¶é“¾æŽ¥å¤±è´¥" });
      });
    }
  };
  var Tt = { init(e2) {
    const t2 = new Pt(e2), n2 = { signInAnonymously: function() {
      return Promise.resolve();
    }, getLoginState: function() {
      return Promise.resolve(false);
    } };
    return t2.auth = function() {
      return n2;
    }, t2.customAuth = t2.auth, t2;
  } }, xt = n(function(e2, t2) {
    e2.exports = r.enc.Hex;
  });
  function Ot() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e2) {
      var t2 = 16 * Math.random() | 0;
      return ("x" === e2 ? t2 : 3 & t2 | 8).toString(16);
    });
  }
  function Et(e2 = "", t2 = {}) {
    const { data: n2, functionName: s2, method: r2, headers: i2, signHeaderKeys: o2 = [], config: a2 } = t2, c2 = Date.now(), u2 = Ot(), l2 = Object.assign({}, i2, { "x-from-app-id": a2.spaceAppId, "x-from-env-id": a2.spaceId, "x-to-env-id": a2.spaceId, "x-from-instance-id": c2, "x-from-function-name": s2, "x-client-timestamp": c2, "x-alipay-source": "client", "x-request-id": u2, "x-alipay-callid": u2, "x-trace-id": u2 }), h2 = ["x-from-app-id", "x-from-env-id", "x-to-env-id", "x-from-instance-id", "x-from-function-name", "x-client-timestamp"].concat(o2), [d2 = "", p2 = ""] = e2.split("?") || [], f2 = function(e3) {
      const t3 = e3.signedHeaders.join(";"), n3 = e3.signedHeaders.map((t4) => `${t4.toLowerCase()}:${e3.headers[t4]}
`).join(""), s3 = we(e3.body).toString(xt), r3 = `${e3.method.toUpperCase()}
${e3.path}
${e3.query}
${n3}
${t3}
${s3}
`, i3 = we(r3).toString(xt), o3 = `HMAC-SHA256
${e3.timestamp}
${i3}
`, a3 = ve(o3, e3.secretKey).toString(xt);
      return `HMAC-SHA256 Credential=${e3.secretId}, SignedHeaders=${t3}, Signature=${a3}`;
    }({ path: d2, query: p2, method: r2, headers: l2, timestamp: c2, body: JSON.stringify(n2), secretId: a2.accessKey, secretKey: a2.secretKey, signedHeaders: h2.sort() });
    return { url: `${a2.endpoint}${e2}`, headers: Object.assign({}, l2, { Authorization: f2 }) };
  }
  function Lt({ url: e2, data: t2, method: n2 = "POST", headers: s2 = {}, timeout: r2 }) {
    return new Promise((i2, o2) => {
      ne.request({ url: e2, method: n2, data: "object" == typeof t2 ? JSON.stringify(t2) : t2, header: s2, dataType: "json", timeout: r2, complete: (e3 = {}) => {
        const t3 = s2["x-trace-id"] || "";
        if (!e3.statusCode || e3.statusCode >= 400) {
          const { message: n3, errMsg: s3, trace_id: r3 } = e3.data || {};
          return o2(new te({ code: "SYS_ERR", message: n3 || s3 || "request:fail", requestId: r3 || t3 }));
        }
        i2({ status: e3.statusCode, data: e3.data, headers: e3.header, requestId: t3 });
      } });
    });
  }
  function Rt(e2, t2) {
    const { path: n2, data: s2, method: r2 = "GET" } = e2, { url: i2, headers: o2 } = Et(n2, { functionName: "", data: s2, method: r2, headers: { "x-alipay-cloud-mode": "oss", "x-data-api-type": "oss", "x-expire-timestamp": Date.now() + 6e4 }, signHeaderKeys: ["x-data-api-type", "x-expire-timestamp"], config: t2 });
    return Lt({ url: i2, data: s2, method: r2, headers: o2 }).then((e3) => {
      const t3 = e3.data || {};
      if (!t3.success)
        throw new te({ code: e3.errCode, message: e3.errMsg, requestId: e3.requestId });
      return t3.data || {};
    }).catch((e3) => {
      throw new te({ code: e3.errCode, message: e3.errMsg, requestId: e3.requestId });
    });
  }
  function Ut(e2 = "") {
    const t2 = e2.trim().replace(/^cloud:\/\//, ""), n2 = t2.indexOf("/");
    if (n2 <= 0)
      throw new te({ code: "INVALID_PARAM", message: "fileIDä¸åˆæ³•" });
    const s2 = t2.substring(0, n2), r2 = t2.substring(n2 + 1);
    return s2 !== this.config.spaceId && console.warn("file ".concat(e2, " does not belong to env ").concat(this.config.spaceId)), r2;
  }
  function Nt(e2 = "") {
    return "cloud://".concat(this.config.spaceId, "/").concat(e2.replace(/^\/+/, ""));
  }
  class Dt {
    constructor(e2) {
      this.config = e2;
    }
    signedURL(e2, t2 = {}) {
      const n2 = `/ws/function/${e2}`, s2 = this.config.wsEndpoint.replace(/^ws(s)?:\/\//, ""), r2 = Object.assign({}, t2, { accessKeyId: this.config.accessKey, signatureNonce: Ot(), timestamp: "" + Date.now() }), i2 = [n2, ["accessKeyId", "authorization", "signatureNonce", "timestamp"].sort().map(function(e3) {
        return r2[e3] ? "".concat(e3, "=").concat(r2[e3]) : null;
      }).filter(Boolean).join("&"), `host:${s2}`].join("\n"), o2 = ["HMAC-SHA256", we(i2).toString(xt)].join("\n"), a2 = ve(o2, this.config.secretKey).toString(xt), c2 = Object.keys(r2).map((e3) => `${e3}=${encodeURIComponent(r2[e3])}`).join("&");
      return `${this.config.wsEndpoint}${n2}?${c2}&signature=${a2}`;
    }
  }
  var Mt = class {
    constructor(e2) {
      if (["spaceId", "spaceAppId", "accessKey", "secretKey"].forEach((t2) => {
        if (!Object.prototype.hasOwnProperty.call(e2, t2))
          throw new Error(`${t2} required`);
      }), e2.endpoint) {
        if ("string" != typeof e2.endpoint)
          throw new Error("endpoint must be string");
        if (!/^https:\/\//.test(e2.endpoint))
          throw new Error("endpoint must start with https://");
        e2.endpoint = e2.endpoint.replace(/\/$/, "");
      }
      this.config = Object.assign({}, e2, { endpoint: e2.endpoint || `https://${e2.spaceId}.api-hz.cloudbasefunction.cn`, wsEndpoint: e2.wsEndpoint || `wss://${e2.spaceId}.api-hz.cloudbasefunction.cn` }), this._websocket = new Dt(this.config);
    }
    callFunction(e2) {
      return function(e3, t2) {
        const { name: n2, data: s2, async: r2 = false, timeout: i2 } = e3, o2 = "POST", a2 = { "x-to-function-name": n2 };
        r2 && (a2["x-function-invoke-type"] = "async");
        const { url: c2, headers: u2 } = Et("/functions/invokeFunction", { functionName: n2, data: s2, method: o2, headers: a2, signHeaderKeys: ["x-to-function-name"], config: t2 });
        return Lt({ url: c2, data: s2, method: o2, headers: u2, timeout: i2 }).then((e4) => {
          let t3 = 0;
          if (r2) {
            const n3 = e4.data || {};
            t3 = "200" === n3.errCode ? 0 : n3.errCode, e4.data = n3.data || {}, e4.errMsg = n3.errMsg;
          }
          if (0 !== t3)
            throw new te({ code: t3, message: e4.errMsg, requestId: e4.requestId });
          return { errCode: t3, success: 0 === t3, requestId: e4.requestId, result: e4.data };
        }).catch((e4) => {
          throw new te({ code: e4.errCode, message: e4.errMsg, requestId: e4.requestId });
        });
      }(e2, this.config);
    }
    uploadFileToOSS({ url: e2, filePath: t2, fileType: n2, formData: s2, onUploadProgress: r2 }) {
      return new Promise((i2, o2) => {
        const a2 = ne.uploadFile({ url: e2, filePath: t2, fileType: n2, formData: s2, name: "file", success(e3) {
          e3 && e3.statusCode < 400 ? i2(e3) : o2(new te({ code: "UPLOAD_FAILED", message: "æ–‡ä»¶ä¸Šä¼ å¤±è´¥" }));
        }, fail(e3) {
          o2(new te({ code: e3.code || "UPLOAD_FAILED", message: e3.message || e3.errMsg || "æ–‡ä»¶ä¸Šä¼ å¤±è´¥" }));
        } });
        "function" == typeof r2 && a2 && "function" == typeof a2.onProgressUpdate && a2.onProgressUpdate((e3) => {
          r2({ loaded: e3.totalBytesSent, total: e3.totalBytesExpectedToSend });
        });
      });
    }
    async uploadFile({ filePath: e2, cloudPath: t2 = "", fileType: n2 = "image", onUploadProgress: s2 }) {
      if ("string" !== f(t2))
        throw new te({ code: "INVALID_PARAM", message: "cloudPathå¿…é¡»ä¸ºå­—ç¬¦ä¸²ç±»åž‹" });
      if (!(t2 = t2.trim()))
        throw new te({ code: "INVALID_PARAM", message: "cloudPathä¸å¯ä¸ºç©º" });
      if (/:\/\//.test(t2))
        throw new te({ code: "INVALID_PARAM", message: "cloudPathä¸åˆæ³•" });
      const r2 = await Rt({ path: "/".concat(t2.replace(/^\//, ""), "?post_url") }, this.config), { file_id: i2, upload_url: o2, form_data: a2 } = r2, c2 = a2 && a2.reduce((e3, t3) => (e3[t3.key] = t3.value, e3), {});
      return this.uploadFileToOSS({ url: o2, filePath: e2, fileType: n2, formData: c2, onUploadProgress: s2 }).then(() => ({ fileID: i2 }));
    }
    async getTempFileURL({ fileList: e2 }) {
      return new Promise((t2, n2) => {
        (!e2 || e2.length < 0) && n2(new te({ errCode: "INVALID_PARAM", errMsg: "fileListä¸èƒ½ä¸ºç©ºæ•°ç»„" })), e2.length > 50 && n2(new te({ errCode: "INVALID_PARAM", errMsg: "fileListæ•°ç»„é•¿åº¦ä¸èƒ½è¶…è¿‡50" }));
        const s2 = [];
        for (const t3 of e2) {
          "string" !== f(t3) && n2(new te({ errCode: "INVALID_PARAM", errMsg: "fileListçš„å…ƒç´ å¿…é¡»æ˜¯éžç©ºçš„å­—ç¬¦ä¸²" }));
          const e3 = Ut.call(this, t3);
          s2.push({ file_id: e3, expire: 600 });
        }
        Rt({ path: "/?download_url", data: { file_list: s2 }, method: "POST" }, this.config).then((e3) => {
          const { file_list: n3 = [] } = e3;
          t2({ fileList: n3.map((e4) => ({ fileID: Nt.call(this, e4.file_id), tempFileURL: e4.download_url })) });
        }).catch((e3) => n2(e3));
      });
    }
    async connectWebSocket(e2) {
      const { name: t2, query: n2 } = e2;
      return ne.connectSocket({ url: this._websocket.signedURL(t2, n2), complete: () => {
      } });
    }
  };
  var qt = { init: (e2) => {
    e2.provider = "alipay";
    const t2 = new Mt(e2);
    return t2.auth = function() {
      return { signInAnonymously: function() {
        return Promise.resolve();
      }, getLoginState: function() {
        return Promise.resolve(true);
      } };
    }, t2;
  } };
  function Ft({ data: e2 }) {
    let t2;
    t2 = he();
    const n2 = JSON.parse(JSON.stringify(e2 || {}));
    if (Object.assign(n2, { clientInfo: t2 }), !n2.uniIdToken) {
      const { token: e3 } = re();
      e3 && (n2.uniIdToken = e3);
    }
    return n2;
  }
  async function Kt(e2 = {}) {
    await this.__dev__.initLocalNetwork();
    const { localAddress: t2, localPort: n2 } = this.__dev__, s2 = { aliyun: "aliyun", tencent: "tcb", alipay: "alipay", dcloud: "dcloud" }[this.config.provider], r2 = this.config.spaceId, i2 = `http://${t2}:${n2}/system/check-function`, o2 = `http://${t2}:${n2}/cloudfunctions/${e2.name}`;
    return new Promise((t3, n3) => {
      ne.request({ method: "POST", url: i2, data: { name: e2.name, platform: C, provider: s2, spaceId: r2 }, timeout: 3e3, success(e3) {
        t3(e3);
      }, fail() {
        t3({ data: { code: "NETWORK_ERROR", message: "è¿žæŽ¥æœ¬åœ°è°ƒè¯•æœåŠ¡å¤±è´¥ï¼Œè¯·æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦å’Œä¸»æœºåœ¨åŒä¸€å±€åŸŸç½‘ä¸‹ï¼Œè‡ªåŠ¨åˆ‡æ¢ä¸ºå·²éƒ¨ç½²çš„äº‘å‡½æ•°ã€‚" } });
      } });
    }).then(({ data: e3 } = {}) => {
      const { code: t3, message: n3 } = e3 || {};
      return { code: 0 === t3 ? 0 : t3 || "SYS_ERR", message: n3 || "SYS_ERR" };
    }).then(({ code: t3, message: n3 }) => {
      if (0 !== t3) {
        switch (t3) {
          case "MODULE_ENCRYPTED":
            console.error(`æ­¤äº‘å‡½æ•°ï¼ˆ${e2.name}ï¼‰ä¾èµ–åŠ å¯†å…¬å…±æ¨¡å—ä¸å¯æœ¬åœ°è°ƒè¯•ï¼Œè‡ªåŠ¨åˆ‡æ¢ä¸ºäº‘ç«¯å·²éƒ¨ç½²çš„äº‘å‡½æ•°`);
            break;
          case "FUNCTION_ENCRYPTED":
            console.error(`æ­¤äº‘å‡½æ•°ï¼ˆ${e2.name}ï¼‰å·²åŠ å¯†ä¸å¯æœ¬åœ°è°ƒè¯•ï¼Œè‡ªåŠ¨åˆ‡æ¢ä¸ºäº‘ç«¯å·²éƒ¨ç½²çš„äº‘å‡½æ•°`);
            break;
          case "ACTION_ENCRYPTED":
            console.error(n3 || "éœ€è¦è®¿é—®åŠ å¯†çš„uni-clientDB-actionï¼Œè‡ªåŠ¨åˆ‡æ¢ä¸ºäº‘ç«¯çŽ¯å¢ƒ");
            break;
          case "NETWORK_ERROR":
            console.error(n3 || "è¿žæŽ¥æœ¬åœ°è°ƒè¯•æœåŠ¡å¤±è´¥ï¼Œè¯·æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦å’Œä¸»æœºåœ¨åŒä¸€å±€åŸŸç½‘ä¸‹");
            break;
          case "SWITCH_TO_CLOUD":
            break;
          default: {
            const e3 = `æ£€æµ‹æœ¬åœ°è°ƒè¯•æœåŠ¡å‡ºçŽ°é”™è¯¯ï¼š${n3}ï¼Œè¯·æ£€æŸ¥ç½‘ç»œçŽ¯å¢ƒæˆ–é‡å¯å®¢æˆ·ç«¯å†è¯•`;
            throw console.error(e3), new Error(e3);
          }
        }
        return this._callCloudFunction(e2);
      }
      return new Promise((t4, n4) => {
        const r3 = Ft.call(this, { data: e2.data });
        ne.request({ method: "POST", url: o2, data: { provider: s2, platform: C, param: r3 }, timeout: e2.timeout, success: ({ statusCode: e3, data: s3 } = {}) => !e3 || e3 >= 400 ? n4(new te({ code: s3.code || "SYS_ERR", message: s3.message || "request:fail" })) : t4({ result: s3 }), fail(e3) {
          n4(new te({ code: e3.code || e3.errCode || "SYS_ERR", message: e3.message || e3.errMsg || "request:fail" }));
        } });
      });
    });
  }
  const jt = [{ rule: /fc_function_not_found|FUNCTION_NOT_FOUND/, content: "ï¼Œäº‘å‡½æ•°[{functionName}]åœ¨äº‘ç«¯ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥æ­¤äº‘å‡½æ•°åç§°æ˜¯å¦æ­£ç¡®ä»¥åŠè¯¥äº‘å‡½æ•°æ˜¯å¦å·²ä¸Šä¼ åˆ°æœåŠ¡ç©ºé—´", mode: "append" }];
  var $t = /[\\^$.*+?()[\]{}|]/g, Bt = RegExp($t.source);
  function Wt(e2, t2, n2) {
    return e2.replace(new RegExp((s2 = t2) && Bt.test(s2) ? s2.replace($t, "\\$&") : s2, "g"), n2);
    var s2;
  }
  const Jt = "request", zt = "response", Vt = "both";
  const En = { code: 2e4, message: "System error" }, Ln = { code: 20101, message: "Invalid client" };
  function Nn(e2) {
    const { errSubject: t2, subject: n2, errCode: s2, errMsg: r2, code: i2, message: o2, cause: a2 } = e2 || {};
    return new te({ subject: t2 || n2 || "uni-secure-network", code: s2 || i2 || En.code, message: r2 || o2, cause: a2 });
  }
  let Mn;
  function $n({ secretType: e2 } = {}) {
    return e2 === Jt || e2 === zt || e2 === Vt;
  }
  function Bn({ name: e2, data: t2 = {} } = {}) {
    return "DCloud-clientDB" === e2 && "encryption" === t2.redirectTo && "getAppClientKey" === t2.action;
  }
  function Wn({ provider: e2, spaceId: t2, functionName: n2 } = {}) {
    const { appId: s2, uniPlatform: r2, osName: i2 } = ce();
    let o2 = r2;
    "app" === r2 && (o2 = i2);
    const a2 = function({ provider: e3, spaceId: t3 } = {}) {
      const n3 = A;
      if (!n3)
        return {};
      e3 = /* @__PURE__ */ function(e4) {
        return "tencent" === e4 ? "tcb" : e4;
      }(e3);
      const s3 = n3.find((n4) => n4.provider === e3 && n4.spaceId === t3);
      return s3 && s3.config;
    }({ provider: e2, spaceId: t2 });
    if (!a2 || !a2.accessControl || !a2.accessControl.enable)
      return false;
    const c2 = a2.accessControl.function || {}, u2 = Object.keys(c2);
    if (0 === u2.length)
      return true;
    const l2 = function(e3, t3) {
      let n3, s3, r3;
      for (let i3 = 0; i3 < e3.length; i3++) {
        const o3 = e3[i3];
        o3 !== t3 ? "*" !== o3 ? o3.split(",").map((e4) => e4.trim()).indexOf(t3) > -1 && (s3 = o3) : r3 = o3 : n3 = o3;
      }
      return n3 || s3 || r3;
    }(u2, n2);
    if (!l2)
      return false;
    if ((c2[l2] || []).find((e3 = {}) => e3.appId === s2 && (e3.platform || "").toLowerCase() === o2.toLowerCase()))
      return true;
    throw console.error(`æ­¤åº”ç”¨[appId: ${s2}, platform: ${o2}]ä¸åœ¨äº‘ç«¯é…ç½®çš„å…è®¸è®¿é—®çš„åº”ç”¨åˆ—è¡¨å†…ï¼Œå‚è€ƒï¼šhttps://uniapp.dcloud.net.cn/uniCloud/secure-network.html#verify-client`), Nn(Ln);
  }
  function Hn({ functionName: e2, result: t2, logPvd: n2 }) {
    if (this.__dev__.debugLog && t2 && t2.requestId) {
      const s2 = JSON.stringify({ spaceId: this.config.spaceId, functionName: e2, requestId: t2.requestId });
      console.log(`[${n2}-request]${s2}[/${n2}-request]`);
    }
  }
  function Jn(e2) {
    const t2 = e2.callFunction, n2 = function(n3) {
      const s2 = n3.name;
      n3.data = Ft.call(e2, { data: n3.data });
      const r2 = { aliyun: "aliyun", tencent: "tcb", tcb: "tcb", alipay: "alipay", dcloud: "dcloud" }[this.config.provider], i2 = $n(n3), o2 = Bn(n3), a2 = i2 || o2;
      return t2.call(this, n3).then((e3) => (e3.errCode = 0, !a2 && Hn.call(this, { functionName: s2, result: e3, logPvd: r2 }), Promise.resolve(e3)), (e3) => (!a2 && Hn.call(this, { functionName: s2, result: e3, logPvd: r2 }), e3 && e3.message && (e3.message = function({ message: e4 = "", extraInfo: t3 = {}, formatter: n4 = [] } = {}) {
        for (let s3 = 0; s3 < n4.length; s3++) {
          const { rule: r3, content: i3, mode: o3 } = n4[s3], a3 = e4.match(r3);
          if (!a3)
            continue;
          let c2 = i3;
          for (let e5 = 1; e5 < a3.length; e5++)
            c2 = Wt(c2, `{$${e5}}`, a3[e5]);
          for (const e5 in t3)
            c2 = Wt(c2, `{${e5}}`, t3[e5]);
          return "replace" === o3 ? c2 : e4 + c2;
        }
        return e4;
      }({ message: `[${n3.name}]: ${e3.message}`, formatter: jt, extraInfo: { functionName: s2 } })), Promise.reject(e3)));
    };
    e2.callFunction = function(t3) {
      const { provider: s2, spaceId: r2 } = e2.config, i2 = t3.name;
      let o2, a2;
      if (t3.data = t3.data || {}, e2.__dev__.debugInfo && !e2.__dev__.debugInfo.forceRemote && T ? (e2._callCloudFunction || (e2._callCloudFunction = n2, e2._callLocalFunction = Kt), o2 = Kt) : o2 = n2, o2 = o2.bind(e2), Bn(t3))
        a2 = n2.call(e2, t3);
      else if ($n(t3)) {
        a2 = new Mn({ secretType: t3.secretType, uniCloudIns: e2 }).wrapEncryptDataCallFunction(n2.bind(e2))(t3);
      } else if (Wn({ provider: s2, spaceId: r2, functionName: i2 })) {
        a2 = new Mn({ secretType: t3.secretType, uniCloudIns: e2 }).wrapVerifyClientCallFunction(n2.bind(e2))(t3);
      } else
        a2 = o2(t3);
      return Object.defineProperty(a2, "result", { get: () => (console.warn("å½“å‰è¿”å›žç»“æžœä¸ºPromiseç±»åž‹ï¼Œä¸å¯ç›´æŽ¥è®¿é—®å…¶resultå±žæ€§ï¼Œè¯¦æƒ…è¯·å‚è€ƒï¼šhttps://uniapp.dcloud.net.cn/uniCloud/faq?id=promise"), {}) }), a2.then((e3) => ("undefined" != typeof UTSJSONObject && (e3.result = new UTSJSONObject(e3.result)), e3));
    };
  }
  Mn = class {
    constructor() {
      throw Nn({ message: `Platform ${C} is not enabled, please check whether secure network module is enabled in your manifest.json` });
    }
  };
  const zn = Symbol("CLIENT_DB_INTERNAL");
  function Vn(e2, t2) {
    return e2.then = "DoNotReturnProxyWithAFunctionNamedThen", e2._internalType = zn, e2.inspect = null, e2.__v_raw = void 0, new Proxy(e2, { get(e3, n2, s2) {
      if ("_uniClient" === n2)
        return null;
      if ("symbol" == typeof n2)
        return e3[n2];
      if (n2 in e3 || "string" != typeof n2) {
        const t3 = e3[n2];
        return "function" == typeof t3 ? t3.bind(e3) : t3;
      }
      return t2.get(e3, n2, s2);
    } });
  }
  function Gn(e2) {
    return { on: (t2, n2) => {
      e2[t2] = e2[t2] || [], e2[t2].indexOf(n2) > -1 || e2[t2].push(n2);
    }, off: (t2, n2) => {
      e2[t2] = e2[t2] || [];
      const s2 = e2[t2].indexOf(n2);
      -1 !== s2 && e2[t2].splice(s2, 1);
    } };
  }
  const Yn = ["db.Geo", "db.command", "command.aggregate"];
  function Qn(e2, t2) {
    return Yn.indexOf(`${e2}.${t2}`) > -1;
  }
  function Xn(e2) {
    switch (f(e2 = se(e2))) {
      case "array":
        return e2.map((e3) => Xn(e3));
      case "object":
        return e2._internalType === zn || Object.keys(e2).forEach((t2) => {
          e2[t2] = Xn(e2[t2]);
        }), e2;
      case "regexp":
        return { $regexp: { source: e2.source, flags: e2.flags } };
      case "date":
        return { $date: e2.toISOString() };
      default:
        return e2;
    }
  }
  function Zn(e2) {
    return e2 && e2.content && e2.content.$method;
  }
  class es {
    constructor(e2, t2, n2) {
      this.content = e2, this.prevStage = t2 || null, this.udb = null, this._database = n2;
    }
    toJSON() {
      let e2 = this;
      const t2 = [e2.content];
      for (; e2.prevStage; )
        e2 = e2.prevStage, t2.push(e2.content);
      return { $db: t2.reverse().map((e3) => ({ $method: e3.$method, $param: Xn(e3.$param) })) };
    }
    toString() {
      return JSON.stringify(this.toJSON());
    }
    getAction() {
      const e2 = this.toJSON().$db.find((e3) => "action" === e3.$method);
      return e2 && e2.$param && e2.$param[0];
    }
    getCommand() {
      return { $db: this.toJSON().$db.filter((e2) => "action" !== e2.$method) };
    }
    get isAggregate() {
      let e2 = this;
      for (; e2; ) {
        const t2 = Zn(e2), n2 = Zn(e2.prevStage);
        if ("aggregate" === t2 && "collection" === n2 || "pipeline" === t2)
          return true;
        e2 = e2.prevStage;
      }
      return false;
    }
    get isCommand() {
      let e2 = this;
      for (; e2; ) {
        if ("command" === Zn(e2))
          return true;
        e2 = e2.prevStage;
      }
      return false;
    }
    get isAggregateCommand() {
      let e2 = this;
      for (; e2; ) {
        const t2 = Zn(e2), n2 = Zn(e2.prevStage);
        if ("aggregate" === t2 && "command" === n2)
          return true;
        e2 = e2.prevStage;
      }
      return false;
    }
    getNextStageFn(e2) {
      const t2 = this;
      return function() {
        return ts({ $method: e2, $param: Xn(Array.from(arguments)) }, t2, t2._database);
      };
    }
    get count() {
      return this.isAggregate ? this.getNextStageFn("count") : function() {
        return this._send("count", Array.from(arguments));
      };
    }
    get remove() {
      return this.isCommand ? this.getNextStageFn("remove") : function() {
        return this._send("remove", Array.from(arguments));
      };
    }
    get() {
      return this._send("get", Array.from(arguments));
    }
    get add() {
      return this.isCommand ? this.getNextStageFn("add") : function() {
        return this._send("add", Array.from(arguments));
      };
    }
    update() {
      return this._send("update", Array.from(arguments));
    }
    end() {
      return this._send("end", Array.from(arguments));
    }
    get set() {
      return this.isCommand ? this.getNextStageFn("set") : function() {
        throw new Error("JQLç¦æ­¢ä½¿ç”¨setæ–¹æ³•");
      };
    }
    _send(e2, t2) {
      const n2 = this.getAction(), s2 = this.getCommand();
      if (s2.$db.push({ $method: e2, $param: Xn(t2) }), S) {
        const e3 = s2.$db.find((e4) => "collection" === e4.$method), t3 = e3 && e3.$param;
        t3 && 1 === t3.length && "string" == typeof e3.$param[0] && e3.$param[0].indexOf(",") > -1 && console.warn("æ£€æµ‹åˆ°ä½¿ç”¨JQLè¯­æ³•è”è¡¨æŸ¥è¯¢æ—¶ï¼Œæœªä½¿ç”¨getTempå…ˆè¿‡æ»¤ä¸»è¡¨æ•°æ®ï¼Œåœ¨ä¸»è¡¨æ•°æ®é‡å¤§çš„æƒ…å†µä¸‹å¯èƒ½ä¼šæŸ¥è¯¢ç¼“æ…¢ã€‚\n- å¦‚ä½•ä¼˜åŒ–è¯·å‚è€ƒæ­¤æ–‡æ¡£ï¼šhttps://uniapp.dcloud.net.cn/uniCloud/jql?id=lookup-with-temp \n- å¦‚æžœä¸»è¡¨æ•°æ®é‡å¾ˆå°è¯·å¿½ç•¥æ­¤ä¿¡æ¯ï¼Œé¡¹ç›®å‘è¡Œæ—¶ä¸ä¼šå‡ºçŽ°æ­¤æç¤ºã€‚");
      }
      return this._database._callCloudFunction({ action: n2, command: s2 });
    }
  }
  function ts(e2, t2, n2) {
    return Vn(new es(e2, t2, n2), { get(e3, t3) {
      let s2 = "db";
      return e3 && e3.content && (s2 = e3.content.$method), Qn(s2, t3) ? ts({ $method: t3 }, e3, n2) : function() {
        return ts({ $method: t3, $param: Xn(Array.from(arguments)) }, e3, n2);
      };
    } });
  }
  function ns({ path: e2, method: t2 }) {
    return class {
      constructor() {
        this.param = Array.from(arguments);
      }
      toJSON() {
        return { $newDb: [...e2.map((e3) => ({ $method: e3 })), { $method: t2, $param: this.param }] };
      }
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
  }
  function ss(e2, t2 = {}) {
    return Vn(new e2(t2), { get: (e3, t3) => Qn("db", t3) ? ts({ $method: t3 }, null, e3) : function() {
      return ts({ $method: t3, $param: Xn(Array.from(arguments)) }, null, e3);
    } });
  }
  class rs extends class {
    constructor({ uniClient: e2 = {}, isJQL: t2 = false } = {}) {
      this._uniClient = e2, this._authCallBacks = {}, this._dbCallBacks = {}, e2._isDefault && (this._dbCallBacks = L("_globalUniCloudDatabaseCallback")), t2 || (this.auth = Gn(this._authCallBacks)), this._isJQL = t2, Object.assign(this, Gn(this._dbCallBacks)), this.env = Vn({}, { get: (e3, t3) => ({ $env: t3 }) }), this.Geo = Vn({}, { get: (e3, t3) => ns({ path: ["Geo"], method: t3 }) }), this.serverDate = ns({ path: [], method: "serverDate" }), this.RegExp = ns({ path: [], method: "RegExp" });
    }
    getCloudEnv(e2) {
      if ("string" != typeof e2 || !e2.trim())
        throw new Error("getCloudEnvå‚æ•°é”™è¯¯");
      return { $env: e2.replace("$cloudEnv_", "") };
    }
    _callback(e2, t2) {
      const n2 = this._dbCallBacks;
      n2[e2] && n2[e2].forEach((e3) => {
        e3(...t2);
      });
    }
    _callbackAuth(e2, t2) {
      const n2 = this._authCallBacks;
      n2[e2] && n2[e2].forEach((e3) => {
        e3(...t2);
      });
    }
    multiSend() {
      const e2 = Array.from(arguments), t2 = e2.map((e3) => {
        const t3 = e3.getAction(), n2 = e3.getCommand();
        if ("getTemp" !== n2.$db[n2.$db.length - 1].$method)
          throw new Error("multiSendåªæ”¯æŒå­å‘½ä»¤å†…ä½¿ç”¨getTemp");
        return { action: t3, command: n2 };
      });
      return this._callCloudFunction({ multiCommand: t2, queryList: e2 });
    }
  } {
    _parseResult(e2) {
      return this._isJQL ? e2.result : e2;
    }
    _callCloudFunction({ action: e2, command: t2, multiCommand: n2, queryList: s2 }) {
      function r2(e3, t3) {
        if (n2 && s2)
          for (let n3 = 0; n3 < s2.length; n3++) {
            const r3 = s2[n3];
            r3.udb && "function" == typeof r3.udb.setResult && (t3 ? r3.udb.setResult(t3) : r3.udb.setResult(e3.result.dataList[n3]));
          }
      }
      const i2 = this, o2 = this._isJQL ? "databaseForJQL" : "database";
      function a2(e3) {
        return i2._callback("error", [e3]), M(q(o2, "fail"), e3).then(() => M(q(o2, "complete"), e3)).then(() => (r2(null, e3), Y(j, { type: W, content: e3 }), Promise.reject(e3)));
      }
      const c2 = M(q(o2, "invoke")), u2 = this._uniClient;
      return c2.then(() => u2.callFunction({ name: "DCloud-clientDB", type: l, data: { action: e2, command: t2, multiCommand: n2 } })).then((e3) => {
        const { code: t3, message: n3, token: s3, tokenExpired: c3, systemInfo: u3 = [] } = e3.result;
        if (u3)
          for (let e4 = 0; e4 < u3.length; e4++) {
            const { level: t4, message: n4, detail: s4 } = u3[e4], r3 = console["warn" === t4 ? "error" : t4] || console.log;
            let i3 = "[System Info]" + n4;
            s4 && (i3 = `${i3}
è¯¦ç»†ä¿¡æ¯ï¼š${s4}`), r3(i3);
          }
        if (t3) {
          return a2(new te({ code: t3, message: n3, requestId: e3.requestId }));
        }
        e3.result.errCode = e3.result.errCode || e3.result.code, e3.result.errMsg = e3.result.errMsg || e3.result.message, s3 && c3 && (ie({ token: s3, tokenExpired: c3 }), this._callbackAuth("refreshToken", [{ token: s3, tokenExpired: c3 }]), this._callback("refreshToken", [{ token: s3, tokenExpired: c3 }]), Y(B, { token: s3, tokenExpired: c3 }));
        const l2 = [{ prop: "affectedDocs", tips: "affectedDocsä¸å†æŽ¨èä½¿ç”¨ï¼Œè¯·ä½¿ç”¨inserted/deleted/updated/data.lengthæ›¿ä»£" }, { prop: "code", tips: "codeä¸å†æŽ¨èä½¿ç”¨ï¼Œè¯·ä½¿ç”¨errCodeæ›¿ä»£" }, { prop: "message", tips: "messageä¸å†æŽ¨èä½¿ç”¨ï¼Œè¯·ä½¿ç”¨errMsgæ›¿ä»£" }];
        for (let t4 = 0; t4 < l2.length; t4++) {
          const { prop: n4, tips: s4 } = l2[t4];
          if (n4 in e3.result) {
            const t5 = e3.result[n4];
            Object.defineProperty(e3.result, n4, { get: () => (console.warn(s4), t5) });
          }
        }
        return function(e4) {
          return M(q(o2, "success"), e4).then(() => M(q(o2, "complete"), e4)).then(() => {
            r2(e4, null);
            const t4 = i2._parseResult(e4);
            return Y(j, { type: W, content: t4 }), Promise.resolve(t4);
          });
        }(e3);
      }, (e3) => {
        /fc_function_not_found|FUNCTION_NOT_FOUND/g.test(e3.message) && console.warn("clientDBæœªåˆå§‹åŒ–ï¼Œè¯·åœ¨webæŽ§åˆ¶å°ä¿å­˜ä¸€æ¬¡schemaä»¥å¼€å¯clientDB");
        return a2(new te({ code: e3.code || "SYSTEM_ERROR", message: e3.message, requestId: e3.requestId }));
      });
    }
  }
  const is = "tokenæ— æ•ˆï¼Œè·³è½¬ç™»å½•é¡µé¢", os = "tokenè¿‡æœŸï¼Œè·³è½¬ç™»å½•é¡µé¢", as = { TOKEN_INVALID_TOKEN_EXPIRED: os, TOKEN_INVALID_INVALID_CLIENTID: is, TOKEN_INVALID: is, TOKEN_INVALID_WRONG_TOKEN: is, TOKEN_INVALID_ANONYMOUS_USER: is }, cs = { "uni-id-token-expired": os, "uni-id-check-token-failed": is, "uni-id-token-not-exist": is, "uni-id-check-device-feature-failed": is };
  function us(e2, t2) {
    let n2 = "";
    return n2 = e2 ? `${e2}/${t2}` : t2, n2.replace(/^\//, "");
  }
  function ls(e2 = [], t2 = "") {
    const n2 = [], s2 = [];
    return e2.forEach((e3) => {
      true === e3.needLogin ? n2.push(us(t2, e3.path)) : false === e3.needLogin && s2.push(us(t2, e3.path));
    }), { needLoginPage: n2, notNeedLoginPage: s2 };
  }
  function hs(e2) {
    return e2.split("?")[0].replace(/^\//, "");
  }
  function ds() {
    return function(e2) {
      let t2 = e2 && e2.$page && e2.$page.fullPath || "";
      return t2 ? ("/" !== t2.charAt(0) && (t2 = "/" + t2), t2) : t2;
    }(function() {
      const e2 = getCurrentPages();
      return e2[e2.length - 1];
    }());
  }
  function ps() {
    return hs(ds());
  }
  function fs(e2 = "", t2 = {}) {
    if (!e2)
      return false;
    if (!(t2 && t2.list && t2.list.length))
      return false;
    const n2 = t2.list, s2 = hs(e2);
    return n2.some((e3) => e3.pagePath === s2);
  }
  const gs = !!e.uniIdRouter;
  const { loginPage: ms, routerNeedLogin: ys, resToLogin: _s, needLoginPage: ws, notNeedLoginPage: vs, loginPageInTabBar: Is } = function({ pages: t2 = [], subPackages: n2 = [], uniIdRouter: s2 = {}, tabBar: r2 = {} } = e) {
    const { loginPage: i2, needLogin: o2 = [], resToLogin: a2 = true } = s2, { needLoginPage: c2, notNeedLoginPage: u2 } = ls(t2), { needLoginPage: l2, notNeedLoginPage: h2 } = function(e2 = []) {
      const t3 = [], n3 = [];
      return e2.forEach((e3) => {
        const { root: s3, pages: r3 = [] } = e3, { needLoginPage: i3, notNeedLoginPage: o3 } = ls(r3, s3);
        t3.push(...i3), n3.push(...o3);
      }), { needLoginPage: t3, notNeedLoginPage: n3 };
    }(n2);
    return { loginPage: i2, routerNeedLogin: o2, resToLogin: a2, needLoginPage: [...c2, ...l2], notNeedLoginPage: [...u2, ...h2], loginPageInTabBar: fs(i2, r2) };
  }();
  if (ws.indexOf(ms) > -1)
    throw new Error(`Login page [${ms}] should not be "needLogin", please check your pages.json`);
  function Ss(e2) {
    const t2 = ps();
    if ("/" === e2.charAt(0))
      return e2;
    const [n2, s2] = e2.split("?"), r2 = n2.replace(/^\//, "").split("/"), i2 = t2.split("/");
    i2.pop();
    for (let e3 = 0; e3 < r2.length; e3++) {
      const t3 = r2[e3];
      ".." === t3 ? i2.pop() : "." !== t3 && i2.push(t3);
    }
    return "" === i2[0] && i2.shift(), "/" + i2.join("/") + (s2 ? "?" + s2 : "");
  }
  function bs(e2) {
    const t2 = hs(Ss(e2));
    return !(vs.indexOf(t2) > -1) && (ws.indexOf(t2) > -1 || ys.some((t3) => function(e3, t4) {
      return new RegExp(t4).test(e3);
    }(e2, t3)));
  }
  function ks({ redirect: e2 }) {
    const t2 = hs(e2), n2 = hs(ms);
    return ps() !== n2 && t2 !== n2;
  }
  function As({ api: e2, redirect: t2 } = {}) {
    if (!t2 || !ks({ redirect: t2 }))
      return;
    const n2 = function(e3, t3) {
      return "/" !== e3.charAt(0) && (e3 = "/" + e3), t3 ? e3.indexOf("?") > -1 ? e3 + `&uniIdRedirectUrl=${encodeURIComponent(t3)}` : e3 + `?uniIdRedirectUrl=${encodeURIComponent(t3)}` : e3;
    }(ms, t2);
    Is ? "navigateTo" !== e2 && "redirectTo" !== e2 || (e2 = "switchTab") : "switchTab" === e2 && (e2 = "navigateTo");
    const s2 = { navigateTo: uni.navigateTo, redirectTo: uni.redirectTo, switchTab: uni.switchTab, reLaunch: uni.reLaunch };
    setTimeout(() => {
      s2[e2]({ url: n2 });
    }, 0);
  }
  function Cs({ url: e2 } = {}) {
    const t2 = { abortLoginPageJump: false, autoToLoginPage: false }, n2 = function() {
      const { token: e3, tokenExpired: t3 } = re();
      let n3;
      if (e3) {
        if (t3 < Date.now()) {
          const e4 = "uni-id-token-expired";
          n3 = { errCode: e4, errMsg: cs[e4] };
        }
      } else {
        const e4 = "uni-id-check-token-failed";
        n3 = { errCode: e4, errMsg: cs[e4] };
      }
      return n3;
    }();
    if (bs(e2) && n2) {
      n2.uniIdRedirectUrl = e2;
      if (z($).length > 0)
        return setTimeout(() => {
          Y($, n2);
        }, 0), t2.abortLoginPageJump = true, t2;
      t2.autoToLoginPage = true;
    }
    return t2;
  }
  function Ps() {
    !function() {
      const e3 = ds(), { abortLoginPageJump: t2, autoToLoginPage: n2 } = Cs({ url: e3 });
      t2 || n2 && As({ api: "redirectTo", redirect: e3 });
    }();
    const e2 = ["navigateTo", "redirectTo", "reLaunch", "switchTab"];
    for (let t2 = 0; t2 < e2.length; t2++) {
      const n2 = e2[t2];
      uni.addInterceptor(n2, { invoke(e3) {
        const { abortLoginPageJump: t3, autoToLoginPage: s2 } = Cs({ url: e3.url });
        return t3 ? e3 : s2 ? (As({ api: n2, redirect: Ss(e3.url) }), false) : e3;
      } });
    }
  }
  function Ts() {
    this.onResponse((e2) => {
      const { type: t2, content: n2 } = e2;
      let s2 = false;
      switch (t2) {
        case "cloudobject":
          s2 = function(e3) {
            if ("object" != typeof e3)
              return false;
            const { errCode: t3 } = e3 || {};
            return t3 in cs;
          }(n2);
          break;
        case "clientdb":
          s2 = function(e3) {
            if ("object" != typeof e3)
              return false;
            const { errCode: t3 } = e3 || {};
            return t3 in as;
          }(n2);
      }
      s2 && function(e3 = {}) {
        const t3 = z($);
        Z().then(() => {
          const n3 = ds();
          if (n3 && ks({ redirect: n3 }))
            return t3.length > 0 ? Y($, Object.assign({ uniIdRedirectUrl: n3 }, e3)) : void (ms && As({ api: "navigateTo", redirect: n3 }));
        });
      }(n2);
    });
  }
  function xs(e2) {
    !function(e3) {
      e3.onResponse = function(e4) {
        V(j, e4);
      }, e3.offResponse = function(e4) {
        G(j, e4);
      };
    }(e2), function(e3) {
      e3.onNeedLogin = function(e4) {
        V($, e4);
      }, e3.offNeedLogin = function(e4) {
        G($, e4);
      }, gs && (L("_globalUniCloudStatus").needLoginInit || (L("_globalUniCloudStatus").needLoginInit = true, Z().then(() => {
        Ps.call(e3);
      }), _s && Ts.call(e3)));
    }(e2), function(e3) {
      e3.onRefreshToken = function(e4) {
        V(B, e4);
      }, e3.offRefreshToken = function(e4) {
        G(B, e4);
      };
    }(e2);
  }
  let Os;
  const Es = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Ls = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;
  function Rs() {
    const e2 = re().token || "", t2 = e2.split(".");
    if (!e2 || 3 !== t2.length)
      return { uid: null, role: [], permission: [], tokenExpired: 0 };
    let n2;
    try {
      n2 = JSON.parse((s2 = t2[1], decodeURIComponent(Os(s2).split("").map(function(e3) {
        return "%" + ("00" + e3.charCodeAt(0).toString(16)).slice(-2);
      }).join(""))));
    } catch (e3) {
      throw new Error("èŽ·å–å½“å‰ç”¨æˆ·ä¿¡æ¯å‡ºé”™ï¼Œè¯¦ç»†é”™è¯¯ä¿¡æ¯ä¸ºï¼š" + e3.message);
    }
    var s2;
    return n2.tokenExpired = 1e3 * n2.exp, delete n2.exp, delete n2.iat, n2;
  }
  Os = "function" != typeof atob ? function(e2) {
    if (e2 = String(e2).replace(/[\t\n\f\r ]+/g, ""), !Ls.test(e2))
      throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
    var t2;
    e2 += "==".slice(2 - (3 & e2.length));
    for (var n2, s2, r2 = "", i2 = 0; i2 < e2.length; )
      t2 = Es.indexOf(e2.charAt(i2++)) << 18 | Es.indexOf(e2.charAt(i2++)) << 12 | (n2 = Es.indexOf(e2.charAt(i2++))) << 6 | (s2 = Es.indexOf(e2.charAt(i2++))), r2 += 64 === n2 ? String.fromCharCode(t2 >> 16 & 255) : 64 === s2 ? String.fromCharCode(t2 >> 16 & 255, t2 >> 8 & 255) : String.fromCharCode(t2 >> 16 & 255, t2 >> 8 & 255, 255 & t2);
    return r2;
  } : atob;
  var Us = n(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", { value: true });
    const n2 = "chooseAndUploadFile:ok", s2 = "chooseAndUploadFile:fail";
    function r2(e3, t3) {
      return e3.tempFiles.forEach((e4, n3) => {
        e4.name || (e4.name = e4.path.substring(e4.path.lastIndexOf("/") + 1)), t3 && (e4.fileType = t3), e4.cloudPath = Date.now() + "_" + n3 + e4.name.substring(e4.name.lastIndexOf("."));
      }), e3.tempFilePaths || (e3.tempFilePaths = e3.tempFiles.map((e4) => e4.path)), e3;
    }
    function i2(e3, t3, { onChooseFile: s3, onUploadProgress: r3 }) {
      return t3.then((e4) => {
        if (s3) {
          const t4 = s3(e4);
          if (void 0 !== t4)
            return Promise.resolve(t4).then((t5) => void 0 === t5 ? e4 : t5);
        }
        return e4;
      }).then((t4) => false === t4 ? { errMsg: n2, tempFilePaths: [], tempFiles: [] } : function(e4, t5, s4 = 5, r4) {
        (t5 = Object.assign({}, t5)).errMsg = n2;
        const i3 = t5.tempFiles, o2 = i3.length;
        let a2 = 0;
        return new Promise((n3) => {
          for (; a2 < s4; )
            c2();
          function c2() {
            const s5 = a2++;
            if (s5 >= o2)
              return void (!i3.find((e5) => !e5.url && !e5.errMsg) && n3(t5));
            const u2 = i3[s5];
            e4.uploadFile({ provider: u2.provider, filePath: u2.path, cloudPath: u2.cloudPath, fileType: u2.fileType, cloudPathAsRealPath: u2.cloudPathAsRealPath, onUploadProgress(e5) {
              e5.index = s5, e5.tempFile = u2, e5.tempFilePath = u2.path, r4 && r4(e5);
            } }).then((e5) => {
              u2.url = e5.fileID, s5 < o2 && c2();
            }).catch((e5) => {
              u2.errMsg = e5.errMsg || e5.message, s5 < o2 && c2();
            });
          }
        });
      }(e3, t4, 5, r3));
    }
    t2.initChooseAndUploadFile = function(e3) {
      return function(t3 = { type: "all" }) {
        return "image" === t3.type ? i2(e3, function(e4) {
          const { count: t4, sizeType: n3, sourceType: i3 = ["album", "camera"], extension: o2 } = e4;
          return new Promise((e5, a2) => {
            uni.chooseImage({ count: t4, sizeType: n3, sourceType: i3, extension: o2, success(t5) {
              e5(r2(t5, "image"));
            }, fail(e6) {
              a2({ errMsg: e6.errMsg.replace("chooseImage:fail", s2) });
            } });
          });
        }(t3), t3) : "video" === t3.type ? i2(e3, function(e4) {
          const { camera: t4, compressed: n3, maxDuration: i3, sourceType: o2 = ["album", "camera"], extension: a2 } = e4;
          return new Promise((e5, c2) => {
            uni.chooseVideo({ camera: t4, compressed: n3, maxDuration: i3, sourceType: o2, extension: a2, success(t5) {
              const { tempFilePath: n4, duration: s3, size: i4, height: o3, width: a3 } = t5;
              e5(r2({ errMsg: "chooseVideo:ok", tempFilePaths: [n4], tempFiles: [{ name: t5.tempFile && t5.tempFile.name || "", path: n4, size: i4, type: t5.tempFile && t5.tempFile.type || "", width: a3, height: o3, duration: s3, fileType: "video", cloudPath: "" }] }, "video"));
            }, fail(e6) {
              c2({ errMsg: e6.errMsg.replace("chooseVideo:fail", s2) });
            } });
          });
        }(t3), t3) : i2(e3, function(e4) {
          const { count: t4, extension: n3 } = e4;
          return new Promise((e5, i3) => {
            let o2 = uni.chooseFile;
            if ("undefined" != typeof wx && "function" == typeof wx.chooseMessageFile && (o2 = wx.chooseMessageFile), "function" != typeof o2)
              return i3({ errMsg: s2 + " è¯·æŒ‡å®š type ç±»åž‹ï¼Œè¯¥å¹³å°ä»…æ”¯æŒé€‰æ‹© image æˆ– videoã€‚" });
            o2({ type: "all", count: t4, extension: n3, success(t5) {
              e5(r2(t5));
            }, fail(e6) {
              i3({ errMsg: e6.errMsg.replace("chooseFile:fail", s2) });
            } });
          });
        }(t3), t3);
      };
    };
  }), Ns = t$1(Us);
  const Ds = "manual";
  function Ms(e2) {
    return { props: { localdata: { type: Array, default: () => [] }, options: { type: [Object, Array], default: () => ({}) }, spaceInfo: { type: Object, default: () => ({}) }, collection: { type: [String, Array], default: "" }, action: { type: String, default: "" }, field: { type: String, default: "" }, orderby: { type: String, default: "" }, where: { type: [String, Object], default: "" }, pageData: { type: String, default: "add" }, pageCurrent: { type: Number, default: 1 }, pageSize: { type: Number, default: 20 }, getcount: { type: [Boolean, String], default: false }, gettree: { type: [Boolean, String], default: false }, gettreepath: { type: [Boolean, String], default: false }, startwith: { type: String, default: "" }, limitlevel: { type: Number, default: 10 }, groupby: { type: String, default: "" }, groupField: { type: String, default: "" }, distinct: { type: [Boolean, String], default: false }, foreignKey: { type: String, default: "" }, loadtime: { type: String, default: "auto" }, manual: { type: Boolean, default: false } }, data: () => ({ mixinDatacomLoading: false, mixinDatacomHasMore: false, mixinDatacomResData: [], mixinDatacomErrorMessage: "", mixinDatacomPage: {}, mixinDatacomError: null }), created() {
      this.mixinDatacomPage = { current: this.pageCurrent, size: this.pageSize, count: 0 }, this.$watch(() => {
        var e3 = [];
        return ["pageCurrent", "pageSize", "localdata", "collection", "action", "field", "orderby", "where", "getont", "getcount", "gettree", "groupby", "groupField", "distinct"].forEach((t2) => {
          e3.push(this[t2]);
        }), e3;
      }, (e3, t2) => {
        if (this.loadtime === Ds)
          return;
        let n2 = false;
        const s2 = [];
        for (let r2 = 2; r2 < e3.length; r2++)
          e3[r2] !== t2[r2] && (s2.push(e3[r2]), n2 = true);
        e3[0] !== t2[0] && (this.mixinDatacomPage.current = this.pageCurrent), this.mixinDatacomPage.size = this.pageSize, this.onMixinDatacomPropsChange(n2, s2);
      });
    }, methods: { onMixinDatacomPropsChange(e3, t2) {
    }, mixinDatacomEasyGet({ getone: e3 = false, success: t2, fail: n2 } = {}) {
      this.mixinDatacomLoading || (this.mixinDatacomLoading = true, this.mixinDatacomErrorMessage = "", this.mixinDatacomError = null, this.mixinDatacomGet().then((n3) => {
        this.mixinDatacomLoading = false;
        const { data: s2, count: r2 } = n3.result;
        this.getcount && (this.mixinDatacomPage.count = r2), this.mixinDatacomHasMore = s2.length < this.pageSize;
        const i2 = e3 ? s2.length ? s2[0] : void 0 : s2;
        this.mixinDatacomResData = i2, t2 && t2(i2);
      }).catch((e4) => {
        this.mixinDatacomLoading = false, this.mixinDatacomErrorMessage = e4, this.mixinDatacomError = e4, n2 && n2(e4);
      }));
    }, mixinDatacomGet(t2 = {}) {
      let n2;
      t2 = t2 || {}, n2 = "undefined" != typeof __uniX && __uniX ? e2.databaseForJQL(this.spaceInfo) : e2.database(this.spaceInfo);
      const s2 = t2.action || this.action;
      s2 && (n2 = n2.action(s2));
      const r2 = t2.collection || this.collection;
      n2 = Array.isArray(r2) ? n2.collection(...r2) : n2.collection(r2);
      const i2 = t2.where || this.where;
      i2 && Object.keys(i2).length && (n2 = n2.where(i2));
      const o2 = t2.field || this.field;
      o2 && (n2 = n2.field(o2));
      const a2 = t2.foreignKey || this.foreignKey;
      a2 && (n2 = n2.foreignKey(a2));
      const c2 = t2.groupby || this.groupby;
      c2 && (n2 = n2.groupBy(c2));
      const u2 = t2.groupField || this.groupField;
      u2 && (n2 = n2.groupField(u2));
      true === (void 0 !== t2.distinct ? t2.distinct : this.distinct) && (n2 = n2.distinct());
      const l2 = t2.orderby || this.orderby;
      l2 && (n2 = n2.orderBy(l2));
      const h2 = void 0 !== t2.pageCurrent ? t2.pageCurrent : this.mixinDatacomPage.current, d2 = void 0 !== t2.pageSize ? t2.pageSize : this.mixinDatacomPage.size, p2 = void 0 !== t2.getcount ? t2.getcount : this.getcount, f2 = void 0 !== t2.gettree ? t2.gettree : this.gettree, g2 = void 0 !== t2.gettreepath ? t2.gettreepath : this.gettreepath, m2 = { getCount: p2 }, y2 = { limitLevel: void 0 !== t2.limitlevel ? t2.limitlevel : this.limitlevel, startWith: void 0 !== t2.startwith ? t2.startwith : this.startwith };
      return f2 && (m2.getTree = y2), g2 && (m2.getTreePath = y2), n2 = n2.skip(d2 * (h2 - 1)).limit(d2).get(m2), n2;
    } } };
  }
  function qs(e2) {
    return function(t2, n2 = {}) {
      n2 = function(e3, t3 = {}) {
        return e3.customUI = t3.customUI || e3.customUI, e3.parseSystemError = t3.parseSystemError || e3.parseSystemError, Object.assign(e3.loadingOptions, t3.loadingOptions), Object.assign(e3.errorOptions, t3.errorOptions), "object" == typeof t3.secretMethods && (e3.secretMethods = t3.secretMethods), e3;
      }({ customUI: false, loadingOptions: { title: "åŠ è½½ä¸­...", mask: true }, errorOptions: { type: "modal", retry: false } }, n2);
      const { customUI: s2, loadingOptions: r2, errorOptions: i2, parseSystemError: o2 } = n2, a2 = !s2;
      return new Proxy({}, { get(s3, c2) {
        switch (c2) {
          case "toString":
            return "[object UniCloudObject]";
          case "toJSON":
            return {};
        }
        return function({ fn: e3, interceptorName: t3, getCallbackArgs: n3 } = {}) {
          return async function(...s4) {
            const r3 = n3 ? n3({ params: s4 }) : {};
            let i3, o3;
            try {
              return await M(q(t3, "invoke"), { ...r3 }), i3 = await e3(...s4), await M(q(t3, "success"), { ...r3, result: i3 }), i3;
            } catch (e4) {
              throw o3 = e4, await M(q(t3, "fail"), { ...r3, error: o3 }), o3;
            } finally {
              await M(q(t3, "complete"), o3 ? { ...r3, error: o3 } : { ...r3, result: i3 });
            }
          };
        }({ fn: async function s4(...l2) {
          let h2;
          a2 && uni.showLoading({ title: r2.title, mask: r2.mask });
          const d2 = { name: t2, type: u, data: { method: c2, params: l2 } };
          "object" == typeof n2.secretMethods && function(e3, t3) {
            const n3 = t3.data.method, s5 = e3.secretMethods || {}, r3 = s5[n3] || s5["*"];
            r3 && (t3.secretType = r3);
          }(n2, d2);
          let p2 = false;
          try {
            h2 = await e2.callFunction(d2);
          } catch (e3) {
            p2 = true, h2 = { result: new te(e3) };
          }
          const { errSubject: f2, errCode: g2, errMsg: m2, newToken: y2 } = h2.result || {};
          if (a2 && uni.hideLoading(), y2 && y2.token && y2.tokenExpired && (ie(y2), Y(B, { ...y2 })), g2) {
            let e3 = m2;
            if (p2 && o2) {
              e3 = (await o2({ objectName: t2, methodName: c2, params: l2, errSubject: f2, errCode: g2, errMsg: m2 })).errMsg || m2;
            }
            if (a2)
              if ("toast" === i2.type)
                uni.showToast({ title: e3, icon: "none" });
              else {
                if ("modal" !== i2.type)
                  throw new Error(`Invalid errorOptions.type: ${i2.type}`);
                {
                  const { confirm: t3 } = await async function({ title: e4, content: t4, showCancel: n4, cancelText: s5, confirmText: r3 } = {}) {
                    return new Promise((i3, o3) => {
                      uni.showModal({ title: e4, content: t4, showCancel: n4, cancelText: s5, confirmText: r3, success(e5) {
                        i3(e5);
                      }, fail() {
                        i3({ confirm: false, cancel: true });
                      } });
                    });
                  }({ title: "æç¤º", content: e3, showCancel: i2.retry, cancelText: "å–æ¶ˆ", confirmText: i2.retry ? "é‡è¯•" : "ç¡®å®š" });
                  if (i2.retry && t3)
                    return s4(...l2);
                }
              }
            const n3 = new te({ subject: f2, code: g2, message: m2, requestId: h2.requestId });
            throw n3.detail = h2.result, Y(j, { type: J, content: n3 }), n3;
          }
          return Y(j, { type: J, content: h2.result }), h2.result;
        }, interceptorName: "callObject", getCallbackArgs: function({ params: e3 } = {}) {
          return { objectName: t2, methodName: c2, params: e3 };
        } });
      } });
    };
  }
  function Fs(e2) {
    return L("_globalUniCloudSecureNetworkCache__{spaceId}".replace("{spaceId}", e2.config.spaceId));
  }
  async function Ks({ openid: e2, callLoginByWeixin: t2 = false } = {}) {
    Fs(this);
    throw new Error(`[SecureNetwork] API \`initSecureNetworkByWeixin\` is not supported on platform \`${C}\``);
  }
  async function js(e2) {
    const t2 = Fs(this);
    return t2.initPromise || (t2.initPromise = Ks.call(this, e2).then((e3) => e3).catch((e3) => {
      throw delete t2.initPromise, e3;
    })), t2.initPromise;
  }
  function $s(e2) {
    return function({ openid: t2, callLoginByWeixin: n2 = false } = {}) {
      return js.call(e2, { openid: t2, callLoginByWeixin: n2 });
    };
  }
  function Bs(e2) {
    !function(e3) {
      le = e3;
    }(e2);
  }
  function Ws(e2) {
    const t2 = { getSystemInfo: uni.getSystemInfo, getPushClientId: uni.getPushClientId };
    return function(n2) {
      return new Promise((s2, r2) => {
        t2[e2]({ ...n2, success(e3) {
          s2(e3);
        }, fail(e3) {
          r2(e3);
        } });
      });
    };
  }
  class Hs extends class {
    constructor() {
      this._callback = {};
    }
    addListener(e2, t2) {
      this._callback[e2] || (this._callback[e2] = []), this._callback[e2].push(t2);
    }
    on(e2, t2) {
      return this.addListener(e2, t2);
    }
    removeListener(e2, t2) {
      if (!t2)
        throw new Error('The "listener" argument must be of type function. Received undefined');
      const n2 = this._callback[e2];
      if (!n2)
        return;
      const s2 = function(e3, t3) {
        for (let n3 = e3.length - 1; n3 >= 0; n3--)
          if (e3[n3] === t3)
            return n3;
        return -1;
      }(n2, t2);
      n2.splice(s2, 1);
    }
    off(e2, t2) {
      return this.removeListener(e2, t2);
    }
    removeAllListener(e2) {
      delete this._callback[e2];
    }
    emit(e2, ...t2) {
      const n2 = this._callback[e2];
      if (n2)
        for (let e3 = 0; e3 < n2.length; e3++)
          n2[e3](...t2);
    }
  } {
    constructor() {
      super(), this._uniPushMessageCallback = this._receivePushMessage.bind(this), this._currentMessageId = -1, this._payloadQueue = [];
    }
    init() {
      return Promise.all([Ws("getSystemInfo")(), Ws("getPushClientId")()]).then(([{ appId: e2 } = {}, { cid: t2 } = {}] = []) => {
        if (!e2)
          throw new Error("Invalid appId, please check the manifest.json file");
        if (!t2)
          throw new Error("Invalid push client id");
        this._appId = e2, this._pushClientId = t2, this._seqId = Date.now() + "-" + Math.floor(9e5 * Math.random() + 1e5), this.emit("open"), this._initMessageListener();
      }, (e2) => {
        throw this.emit("error", e2), this.close(), e2;
      });
    }
    async open() {
      return this.init();
    }
    _isUniCloudSSE(e2) {
      if ("receive" !== e2.type)
        return false;
      const t2 = e2 && e2.data && e2.data.payload;
      return !(!t2 || "UNI_CLOUD_SSE" !== t2.channel || t2.seqId !== this._seqId);
    }
    _receivePushMessage(e2) {
      if (!this._isUniCloudSSE(e2))
        return;
      const t2 = e2 && e2.data && e2.data.payload, { action: n2, messageId: s2, message: r2 } = t2;
      this._payloadQueue.push({ action: n2, messageId: s2, message: r2 }), this._consumMessage();
    }
    _consumMessage() {
      for (; ; ) {
        const e2 = this._payloadQueue.find((e3) => e3.messageId === this._currentMessageId + 1);
        if (!e2)
          break;
        this._currentMessageId++, this._parseMessagePayload(e2);
      }
    }
    _parseMessagePayload(e2) {
      const { action: t2, messageId: n2, message: s2 } = e2;
      "end" === t2 ? this._end({ messageId: n2, message: s2 }) : "message" === t2 && this._appendMessage({ messageId: n2, message: s2 });
    }
    _appendMessage({ messageId: e2, message: t2 } = {}) {
      this.emit("message", t2);
    }
    _end({ messageId: e2, message: t2 } = {}) {
      this.emit("end", t2), this.close();
    }
    _initMessageListener() {
      uni.onPushMessage(this._uniPushMessageCallback);
    }
    _destroy() {
      uni.offPushMessage(this._uniPushMessageCallback);
    }
    toJSON() {
      return { appId: this._appId, pushClientId: this._pushClientId, seqId: this._seqId };
    }
    close() {
      this._destroy(), this.emit("close");
    }
  }
  async function Js(e2) {
    {
      const { osName: e3, osVersion: t3 } = ce();
      "ios" === e3 && function(e4) {
        if (!e4 || "string" != typeof e4)
          return 0;
        const t4 = e4.match(/^(\d+)./);
        return t4 && t4[1] ? parseInt(t4[1]) : 0;
      }(t3) >= 14 && console.warn("iOS 14åŠä»¥ä¸Šç‰ˆæœ¬è¿žæŽ¥uniCloudæœ¬åœ°è°ƒè¯•æœåŠ¡éœ€è¦å…è®¸å®¢æˆ·ç«¯æŸ¥æ‰¾å¹¶è¿žæŽ¥åˆ°æœ¬åœ°ç½‘ç»œä¸Šçš„è®¾å¤‡ï¼ˆä»…å¼€å‘æœŸé—´éœ€è¦ï¼Œå‘è¡ŒåŽä¸éœ€è¦ï¼‰");
    }
    const t2 = e2.__dev__;
    if (!t2.debugInfo)
      return;
    const { address: n2, servePort: s2 } = t2.debugInfo, { address: r2 } = await At(n2, s2);
    if (r2)
      return t2.localAddress = r2, void (t2.localPort = s2);
    const i2 = console["error"];
    let o2 = "";
    if ("remote" === t2.debugInfo.initialLaunchType ? (t2.debugInfo.forceRemote = true, o2 = "å½“å‰å®¢æˆ·ç«¯å’ŒHBuilderXä¸åœ¨åŒä¸€å±€åŸŸç½‘ä¸‹ï¼ˆæˆ–å…¶ä»–ç½‘ç»œåŽŸå› æ— æ³•è¿žæŽ¥HBuilderXï¼‰ï¼ŒuniCloudæœ¬åœ°è°ƒè¯•æœåŠ¡ä¸å¯¹å½“å‰å®¢æˆ·ç«¯ç”Ÿæ•ˆã€‚\n- å¦‚æžœä¸ä½¿ç”¨uniCloudæœ¬åœ°è°ƒè¯•æœåŠ¡ï¼Œè¯·ç›´æŽ¥å¿½ç•¥æ­¤ä¿¡æ¯ã€‚\n- å¦‚éœ€ä½¿ç”¨uniCloudæœ¬åœ°è°ƒè¯•æœåŠ¡ï¼Œè¯·å°†å®¢æˆ·ç«¯ä¸Žä¸»æœºè¿žæŽ¥åˆ°åŒä¸€å±€åŸŸç½‘ä¸‹å¹¶é‡æ–°è¿è¡Œåˆ°å®¢æˆ·ç«¯ã€‚") : o2 = "æ— æ³•è¿žæŽ¥uniCloudæœ¬åœ°è°ƒè¯•æœåŠ¡ï¼Œè¯·æ£€æŸ¥å½“å‰å®¢æˆ·ç«¯æ˜¯å¦ä¸Žä¸»æœºåœ¨åŒä¸€å±€åŸŸç½‘ä¸‹ã€‚\n- å¦‚éœ€ä½¿ç”¨uniCloudæœ¬åœ°è°ƒè¯•æœåŠ¡ï¼Œè¯·å°†å®¢æˆ·ç«¯ä¸Žä¸»æœºè¿žæŽ¥åˆ°åŒä¸€å±€åŸŸç½‘ä¸‹å¹¶é‡æ–°è¿è¡Œåˆ°å®¢æˆ·ç«¯ã€‚", o2 += "\n- å¦‚æžœåœ¨HBuilderXå¼€å¯çš„çŠ¶æ€ä¸‹åˆ‡æ¢è¿‡ç½‘ç»œçŽ¯å¢ƒï¼Œè¯·é‡å¯HBuilderXåŽå†è¯•\n- æ£€æŸ¥ç³»ç»Ÿé˜²ç«å¢™æ˜¯å¦æ‹¦æˆªäº†HBuilderXè‡ªå¸¦çš„nodejs\n- æ£€æŸ¥æ˜¯å¦é”™è¯¯çš„ä½¿ç”¨æ‹¦æˆªå™¨ä¿®æ”¹uni.requestæ–¹æ³•çš„å‚æ•°", 0 === C.indexOf("mp-") && (o2 += "\n- å°ç¨‹åºä¸­å¦‚ä½•ä½¿ç”¨uniCloudï¼Œè¯·å‚è€ƒï¼šhttps://uniapp.dcloud.net.cn/uniCloud/publish.html#useinmp"), !t2.debugInfo.forceRemote)
      throw new Error(o2);
    i2(o2);
  }
  function zs(e2) {
    e2._initPromiseHub || (e2._initPromiseHub = new v({ createPromise: function() {
      let t2 = Promise.resolve();
      var n2;
      n2 = 1, t2 = new Promise((e3) => {
        setTimeout(() => {
          e3();
        }, n2);
      });
      const s2 = e2.auth();
      return t2.then(() => s2.getLoginState()).then((e3) => e3 ? Promise.resolve() : s2.signInAnonymously());
    } }));
  }
  const Vs = { tcb: bt, tencent: bt, aliyun: fe, private: Tt, dcloud: Tt, alipay: qt };
  let Gs = new class {
    init(e2) {
      let t2 = {};
      const n2 = Vs[e2.provider];
      if (!n2)
        throw new Error("æœªæä¾›æ­£ç¡®çš„providerå‚æ•°");
      t2 = n2.init(e2), function(e3) {
        const t3 = {};
        e3.__dev__ = t3, t3.debugLog = "app" === C;
        const n3 = P;
        n3 && !n3.code && (t3.debugInfo = n3);
        const s2 = new v({ createPromise: function() {
          return Js(e3);
        } });
        t3.initLocalNetwork = function() {
          return s2.exec();
        };
      }(t2), zs(t2), Jn(t2), function(e3) {
        const t3 = e3.uploadFile;
        e3.uploadFile = function(e4) {
          return t3.call(this, e4);
        };
      }(t2), function(e3) {
        e3.database = function(t3) {
          if (t3 && Object.keys(t3).length > 0)
            return e3.init(t3).database();
          if (this._database)
            return this._database;
          const n3 = ss(rs, { uniClient: e3 });
          return this._database = n3, n3;
        }, e3.databaseForJQL = function(t3) {
          if (t3 && Object.keys(t3).length > 0)
            return e3.init(t3).databaseForJQL();
          if (this._databaseForJQL)
            return this._databaseForJQL;
          const n3 = ss(rs, { uniClient: e3, isJQL: true });
          return this._databaseForJQL = n3, n3;
        };
      }(t2), function(e3) {
        e3.getCurrentUserInfo = Rs, e3.chooseAndUploadFile = Ns.initChooseAndUploadFile(e3), Object.assign(e3, { get mixinDatacom() {
          return Ms(e3);
        } }), e3.SSEChannel = Hs, e3.initSecureNetworkByWeixin = $s(e3), e3.setCustomClientInfo = Bs, e3.importObject = qs(e3);
      }(t2);
      return ["callFunction", "uploadFile", "deleteFile", "getTempFileURL", "downloadFile", "chooseAndUploadFile"].forEach((e3) => {
        if (!t2[e3])
          return;
        const n3 = t2[e3];
        t2[e3] = function() {
          return n3.apply(t2, Array.from(arguments));
        }, t2[e3] = (/* @__PURE__ */ function(e4, t3) {
          return function(n4) {
            let s2 = false;
            if ("callFunction" === t3) {
              const e5 = n4 && n4.type || c;
              s2 = e5 !== c;
            }
            const r2 = "callFunction" === t3 && !s2, i2 = this._initPromiseHub.exec();
            n4 = n4 || {};
            const { success: o2, fail: a2, complete: u2 } = ee(n4), l2 = i2.then(() => s2 ? Promise.resolve() : M(q(t3, "invoke"), n4)).then(() => e4.call(this, n4)).then((e5) => s2 ? Promise.resolve(e5) : M(q(t3, "success"), e5).then(() => M(q(t3, "complete"), e5)).then(() => (r2 && Y(j, { type: H, content: e5 }), Promise.resolve(e5))), (e5) => s2 ? Promise.reject(e5) : M(q(t3, "fail"), e5).then(() => M(q(t3, "complete"), e5)).then(() => (Y(j, { type: H, content: e5 }), Promise.reject(e5))));
            if (!(o2 || a2 || u2))
              return l2;
            l2.then((e5) => {
              o2 && o2(e5), u2 && u2(e5), r2 && Y(j, { type: H, content: e5 });
            }, (e5) => {
              a2 && a2(e5), u2 && u2(e5), r2 && Y(j, { type: H, content: e5 });
            });
          };
        }(t2[e3], e3)).bind(t2);
      }), t2.init = this.init, t2;
    }
  }();
  (() => {
    const e2 = T;
    let t2 = {};
    if (e2 && 1 === e2.length)
      t2 = e2[0], Gs = Gs.init(t2), Gs._isDefault = true;
    else {
      const t3 = ["auth", "callFunction", "uploadFile", "deleteFile", "getTempFileURL", "downloadFile", "database", "getCurrentUSerInfo", "importObject"];
      let n2;
      n2 = e2 && e2.length > 0 ? "åº”ç”¨æœ‰å¤šä¸ªæœåŠ¡ç©ºé—´ï¼Œè¯·é€šè¿‡uniCloud.initæ–¹æ³•æŒ‡å®šè¦ä½¿ç”¨çš„æœåŠ¡ç©ºé—´" : "åº”ç”¨æœªå…³è”æœåŠ¡ç©ºé—´ï¼Œè¯·åœ¨uniCloudç›®å½•å³é”®å…³è”æœåŠ¡ç©ºé—´", t3.forEach((e3) => {
        Gs[e3] = function() {
          return console.error(n2), Promise.reject(new te({ code: "SYS_ERR", message: n2 }));
        };
      });
    }
    Object.assign(Gs, { get mixinDatacom() {
      return Ms(Gs);
    } }), xs(Gs), Gs.addInterceptor = N, Gs.removeInterceptor = D, Gs.interceptObject = F;
  })();
  var Ys = Gs;
  const dataPicker = {
    props: {
      localdata: {
        type: [Array, Object],
        default() {
          return [];
        }
      },
      spaceInfo: {
        type: Object,
        default() {
          return {};
        }
      },
      collection: {
        type: String,
        default: ""
      },
      action: {
        type: String,
        default: ""
      },
      field: {
        type: String,
        default: ""
      },
      orderby: {
        type: String,
        default: ""
      },
      where: {
        type: [String, Object],
        default: ""
      },
      pageData: {
        type: String,
        default: "add"
      },
      pageCurrent: {
        type: Number,
        default: 1
      },
      pageSize: {
        type: Number,
        default: 500
      },
      getcount: {
        type: [Boolean, String],
        default: false
      },
      getone: {
        type: [Boolean, String],
        default: false
      },
      gettree: {
        type: [Boolean, String],
        default: false
      },
      manual: {
        type: Boolean,
        default: false
      },
      value: {
        type: [Array, String, Number],
        default() {
          return [];
        }
      },
      modelValue: {
        type: [Array, String, Number],
        default() {
          return [];
        }
      },
      preload: {
        type: Boolean,
        default: false
      },
      stepSearh: {
        type: Boolean,
        default: true
      },
      selfField: {
        type: String,
        default: ""
      },
      parentField: {
        type: String,
        default: ""
      },
      multiple: {
        type: Boolean,
        default: false
      },
      map: {
        type: Object,
        default() {
          return {
            text: "text",
            value: "value"
          };
        }
      }
    },
    data() {
      return {
        loading: false,
        errorMessage: "",
        loadMore: {
          contentdown: "",
          contentrefresh: "",
          contentnomore: ""
        },
        dataList: [],
        selected: [],
        selectedIndex: 0,
        page: {
          current: this.pageCurrent,
          size: this.pageSize,
          count: 0
        }
      };
    },
    computed: {
      isLocalData() {
        return !this.collection.length;
      },
      isCloudData() {
        return this.collection.length > 0;
      },
      isCloudDataList() {
        return this.isCloudData && (!this.parentField && !this.selfField);
      },
      isCloudDataTree() {
        return this.isCloudData && this.parentField && this.selfField;
      },
      dataValue() {
        let isModelValue = Array.isArray(this.modelValue) ? this.modelValue.length > 0 : this.modelValue !== null || this.modelValue !== void 0;
        return isModelValue ? this.modelValue : this.value;
      },
      hasValue() {
        if (typeof this.dataValue === "number") {
          return true;
        }
        return this.dataValue != null && this.dataValue.length > 0;
      }
    },
    created() {
      this.$watch(() => {
        var al = [];
        [
          "pageCurrent",
          "pageSize",
          "spaceInfo",
          "value",
          "modelValue",
          "localdata",
          "collection",
          "action",
          "field",
          "orderby",
          "where",
          "getont",
          "getcount",
          "gettree"
        ].forEach((key) => {
          al.push(this[key]);
        });
        return al;
      }, (newValue, oldValue) => {
        for (let i2 = 2; i2 < newValue.length; i2++) {
          if (newValue[i2] != oldValue[i2]) {
            break;
          }
        }
        if (newValue[0] != oldValue[0]) {
          this.page.current = this.pageCurrent;
        }
        this.page.size = this.pageSize;
        this.onPropsChange();
      });
      this._treeData = [];
    },
    methods: {
      onPropsChange() {
        this._treeData = [];
      },
      // å¡«å…… pickview æ•°æ®
      async loadData() {
        if (this.isLocalData) {
          this.loadLocalData();
        } else if (this.isCloudDataList) {
          this.loadCloudDataList();
        } else if (this.isCloudDataTree) {
          this.loadCloudDataTree();
        }
      },
      // åŠ è½½æœ¬åœ°æ•°æ®
      async loadLocalData() {
        this._treeData = [];
        this._extractTree(this.localdata, this._treeData);
        let inputValue = this.dataValue;
        if (inputValue === void 0) {
          return;
        }
        if (Array.isArray(inputValue)) {
          inputValue = inputValue[inputValue.length - 1];
          if (typeof inputValue === "object" && inputValue[this.map.value]) {
            inputValue = inputValue[this.map.value];
          }
        }
        this.selected = this._findNodePath(inputValue, this.localdata);
      },
      // åŠ è½½ Cloud æ•°æ® (å•åˆ—)
      async loadCloudDataList() {
        if (this.loading) {
          return;
        }
        this.loading = true;
        try {
          let response = await this.getCommand();
          let responseData = response.result.data;
          this._treeData = responseData;
          this._updateBindData();
          this._updateSelected();
          this.onDataChange();
        } catch (e2) {
          this.errorMessage = e2;
        } finally {
          this.loading = false;
        }
      },
      // åŠ è½½ Cloud æ•°æ® (æ ‘å½¢)
      async loadCloudDataTree() {
        if (this.loading) {
          return;
        }
        this.loading = true;
        try {
          let commandOptions = {
            field: this._cloudDataPostField(),
            where: this._cloudDataTreeWhere()
          };
          if (this.gettree) {
            commandOptions.startwith = `${this.selfField}=='${this.dataValue}'`;
          }
          let response = await this.getCommand(commandOptions);
          let responseData = response.result.data;
          this._treeData = responseData;
          this._updateBindData();
          this._updateSelected();
          this.onDataChange();
        } catch (e2) {
          this.errorMessage = e2;
        } finally {
          this.loading = false;
        }
      },
      // åŠ è½½ Cloud æ•°æ® (èŠ‚ç‚¹)
      async loadCloudDataNode(callback) {
        if (this.loading) {
          return;
        }
        this.loading = true;
        try {
          let commandOptions = {
            field: this._cloudDataPostField(),
            where: this._cloudDataNodeWhere()
          };
          let response = await this.getCommand(commandOptions);
          let responseData = response.result.data;
          callback(responseData);
        } catch (e2) {
          this.errorMessage = e2;
        } finally {
          this.loading = false;
        }
      },
      // å›žæ˜¾ Cloud æ•°æ®
      getCloudDataValue() {
        if (this.isCloudDataList) {
          return this.getCloudDataListValue();
        }
        if (this.isCloudDataTree) {
          return this.getCloudDataTreeValue();
        }
      },
      // å›žæ˜¾ Cloud æ•°æ® (å•åˆ—)
      getCloudDataListValue() {
        let where = [];
        let whereField = this._getForeignKeyByField();
        if (whereField) {
          where.push(`${whereField} == '${this.dataValue}'`);
        }
        where = where.join(" || ");
        if (this.where) {
          where = `(${this.where}) && (${where})`;
        }
        return this.getCommand({
          field: this._cloudDataPostField(),
          where
        }).then((res) => {
          this.selected = res.result.data;
          return res.result.data;
        });
      },
      // å›žæ˜¾ Cloud æ•°æ® (æ ‘å½¢)
      getCloudDataTreeValue() {
        return this.getCommand({
          field: this._cloudDataPostField(),
          getTreePath: {
            startWith: `${this.selfField}=='${this.dataValue}'`
          }
        }).then((res) => {
          let treePath = [];
          this._extractTreePath(res.result.data, treePath);
          this.selected = treePath;
          return treePath;
        });
      },
      getCommand(options = {}) {
        let db = Ys.database(this.spaceInfo);
        const action = options.action || this.action;
        if (action) {
          db = db.action(action);
        }
        const collection = options.collection || this.collection;
        db = db.collection(collection);
        const where = options.where || this.where;
        if (!(!where || !Object.keys(where).length)) {
          db = db.where(where);
        }
        const field = options.field || this.field;
        if (field) {
          db = db.field(field);
        }
        const orderby = options.orderby || this.orderby;
        if (orderby) {
          db = db.orderBy(orderby);
        }
        const current = options.pageCurrent !== void 0 ? options.pageCurrent : this.page.current;
        const size = options.pageSize !== void 0 ? options.pageSize : this.page.size;
        const getCount = options.getcount !== void 0 ? options.getcount : this.getcount;
        const getTree = options.gettree !== void 0 ? options.gettree : this.gettree;
        const getOptions = {
          getCount,
          getTree
        };
        if (options.getTreePath) {
          getOptions.getTreePath = options.getTreePath;
        }
        db = db.skip(size * (current - 1)).limit(size).get(getOptions);
        return db;
      },
      _cloudDataPostField() {
        let fields = [this.field];
        if (this.parentField) {
          fields.push(`${this.parentField} as parent_value`);
        }
        return fields.join(",");
      },
      _cloudDataTreeWhere() {
        let result = [];
        let selected = this.selected;
        let parentField = this.parentField;
        if (parentField) {
          result.push(`${parentField} == null || ${parentField} == ""`);
        }
        if (selected.length) {
          for (var i2 = 0; i2 < selected.length - 1; i2++) {
            result.push(`${parentField} == '${selected[i2].value}'`);
          }
        }
        let where = [];
        if (this.where) {
          where.push(`(${this.where})`);
        }
        if (result.length) {
          where.push(`(${result.join(" || ")})`);
        }
        return where.join(" && ");
      },
      _cloudDataNodeWhere() {
        let where = [];
        let selected = this.selected;
        if (selected.length) {
          where.push(`${this.parentField} == '${selected[selected.length - 1].value}'`);
        }
        where = where.join(" || ");
        if (this.where) {
          return `(${this.where}) && (${where})`;
        }
        return where;
      },
      _getWhereByForeignKey() {
        let result = [];
        let whereField = this._getForeignKeyByField();
        if (whereField) {
          result.push(`${whereField} == '${this.dataValue}'`);
        }
        if (this.where) {
          return `(${this.where}) && (${result.join(" || ")})`;
        }
        return result.join(" || ");
      },
      _getForeignKeyByField() {
        let fields = this.field.split(",");
        let whereField = null;
        for (let i2 = 0; i2 < fields.length; i2++) {
          const items = fields[i2].split("as");
          if (items.length < 2) {
            continue;
          }
          if (items[1].trim() === "value") {
            whereField = items[0].trim();
            break;
          }
        }
        return whereField;
      },
      _updateBindData(node) {
        const {
          dataList,
          hasNodes
        } = this._filterData(this._treeData, this.selected);
        let isleaf = this._stepSearh === false && !hasNodes;
        if (node) {
          node.isleaf = isleaf;
        }
        this.dataList = dataList;
        this.selectedIndex = dataList.length - 1;
        if (!isleaf && this.selected.length < dataList.length) {
          this.selected.push({
            value: null,
            text: "è¯·é€‰æ‹©"
          });
        }
        return {
          isleaf,
          hasNodes
        };
      },
      _updateSelected() {
        let dl = this.dataList;
        let sl = this.selected;
        let textField = this.map.text;
        let valueField = this.map.value;
        for (let i2 = 0; i2 < sl.length; i2++) {
          let value = sl[i2].value;
          let dl2 = dl[i2];
          for (let j2 = 0; j2 < dl2.length; j2++) {
            let item2 = dl2[j2];
            if (item2[valueField] === value) {
              sl[i2].text = item2[textField];
              break;
            }
          }
        }
      },
      _filterData(data, paths) {
        let dataList = [];
        let hasNodes = true;
        dataList.push(data.filter((item) => {
          return item.parent_value === null || item.parent_value === void 0 || item.parent_value === "";
        }));
        for (let i2 = 0; i2 < paths.length; i2++) {
          let value = paths[i2].value;
          let nodes = data.filter((item) => {
            return item.parent_value === value;
          });
          if (nodes.length) {
            dataList.push(nodes);
          } else {
            hasNodes = false;
          }
        }
        return {
          dataList,
          hasNodes
        };
      },
      _extractTree(nodes, result, parent_value) {
        let valueField = this.map.value;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          let node = nodes[i2];
          let child = {};
          for (let key in node) {
            if (key !== "children") {
              child[key] = node[key];
            }
          }
          if (parent_value !== null && parent_value !== void 0 && parent_value !== "") {
            child.parent_value = parent_value;
          }
          result.push(child);
          let children = node.children;
          if (children) {
            this._extractTree(children, result, node[valueField]);
          }
        }
      },
      _extractTreePath(nodes, result) {
        for (let i2 = 0; i2 < nodes.length; i2++) {
          let node = nodes[i2];
          let child = {};
          for (let key in node) {
            if (key !== "children") {
              child[key] = node[key];
            }
          }
          result.push(child);
          let children = node.children;
          if (children) {
            this._extractTreePath(children, result);
          }
        }
      },
      _findNodePath(key, nodes, path = []) {
        let textField = this.map.text;
        let valueField = this.map.value;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          let node = nodes[i2];
          let children = node.children;
          let text = node[textField];
          let value = node[valueField];
          path.push({
            value,
            text
          });
          if (value === key) {
            return path;
          }
          if (children) {
            const p2 = this._findNodePath(key, children, path);
            if (p2.length) {
              return p2;
            }
          }
          path.pop();
        }
        return [];
      }
    }
  };
  const _sfc_main$16 = {
    name: "UniDataPickerView",
    emits: ["nodeclick", "change", "datachange", "update:modelValue"],
    mixins: [dataPicker],
    props: {
      managedMode: {
        type: Boolean,
        default: false
      },
      ellipsis: {
        type: Boolean,
        default: true
      }
    },
    created() {
      if (!this.managedMode) {
        this.$nextTick(() => {
          this.loadData();
        });
      }
    },
    methods: {
      onPropsChange() {
        this._treeData = [];
        this.selectedIndex = 0;
        this.$nextTick(() => {
          this.loadData();
        });
      },
      handleSelect(index) {
        this.selectedIndex = index;
      },
      handleNodeClick(item, i2, j2) {
        if (item.disable) {
          return;
        }
        const node = this.dataList[i2][j2];
        const text = node[this.map.text];
        const value = node[this.map.value];
        if (i2 < this.selected.length - 1) {
          this.selected.splice(i2, this.selected.length - i2);
          this.selected.push({
            text,
            value
          });
        } else if (i2 === this.selected.length - 1) {
          this.selected.splice(i2, 1, {
            text,
            value
          });
        }
        if (node.isleaf) {
          this.onSelectedChange(node, node.isleaf);
          return;
        }
        const {
          isleaf,
          hasNodes
        } = this._updateBindData();
        if (this.isLocalData) {
          this.onSelectedChange(node, !hasNodes || isleaf);
        } else if (this.isCloudDataList) {
          this.onSelectedChange(node, true);
        } else if (this.isCloudDataTree) {
          if (isleaf) {
            this.onSelectedChange(node, node.isleaf);
          } else if (!hasNodes) {
            this.loadCloudDataNode((data) => {
              if (!data.length) {
                node.isleaf = true;
              } else {
                this._treeData.push(...data);
                this._updateBindData(node);
              }
              this.onSelectedChange(node, node.isleaf);
            });
          }
        }
      },
      updateData(data) {
        this._treeData = data.treeData;
        this.selected = data.selected;
        if (!this._treeData.length) {
          this.loadData();
        } else {
          this._updateBindData();
        }
      },
      onDataChange() {
        this.$emit("datachange");
      },
      onSelectedChange(node, isleaf) {
        if (isleaf) {
          this._dispatchEvent();
        }
        if (node) {
          this.$emit("nodeclick", node);
        }
      },
      _dispatchEvent() {
        this.$emit("change", this.selected.slice(0));
      }
    }
  };
  function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_load_more = resolveEasycom(vue.resolveDynamicComponent("uni-load-more"), __easycom_0$6);
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-data-pickerview" }, [
      !_ctx.isCloudDataList ? (vue.openBlock(), vue.createElementBlock("scroll-view", {
        key: 0,
        class: "selected-area",
        "scroll-x": "true"
      }, [
        vue.createElementVNode("view", { class: "selected-list" }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.selected, (item, index) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: vue.normalizeClass(["selected-item", {
                  "selected-item-active": index == _ctx.selectedIndex
                }]),
                key: index,
                onClick: ($event) => $options.handleSelect(index)
              }, [
                vue.createElementVNode(
                  "text",
                  null,
                  vue.toDisplayString(item.text || ""),
                  1
                  /* TEXT */
                )
              ], 10, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("view", { class: "tab-c" }, [
        vue.createElementVNode("scroll-view", {
          class: "list",
          "scroll-y": true
        }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.dataList[_ctx.selectedIndex], (item, j2) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: vue.normalizeClass(["item", { "is-disabled": !!item.disable }]),
                key: j2,
                onClick: ($event) => $options.handleNodeClick(item, _ctx.selectedIndex, j2)
              }, [
                vue.createElementVNode(
                  "text",
                  { class: "item-text" },
                  vue.toDisplayString(item[_ctx.map.text]),
                  1
                  /* TEXT */
                ),
                _ctx.selected.length > _ctx.selectedIndex && item[_ctx.map.value] == _ctx.selected[_ctx.selectedIndex].value ? (vue.openBlock(), vue.createElementBlock("view", {
                  key: 0,
                  class: "check"
                })) : vue.createCommentVNode("v-if", true)
              ], 10, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        _ctx.loading ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "loading-cover"
        }, [
          vue.createVNode(_component_uni_load_more, {
            class: "load-more",
            contentText: _ctx.loadMore,
            status: "loading"
          }, null, 8, ["contentText"])
        ])) : vue.createCommentVNode("v-if", true),
        _ctx.errorMessage ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 1,
          class: "error-message"
        }, [
          vue.createElementVNode(
            "text",
            { class: "error-text" },
            vue.toDisplayString(_ctx.errorMessage),
            1
            /* TEXT */
          )
        ])) : vue.createCommentVNode("v-if", true)
      ])
    ]);
  }
  const DataPickerView = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$15], ["__scopeId", "data-v-91ec6a82"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-data-picker/components/uni-data-pickerview/uni-data-pickerview.vue"]]);
  const _sfc_main$15 = {
    name: "UniDataPicker",
    emits: ["popupopened", "popupclosed", "nodeclick", "input", "change", "update:modelValue", "inputclick"],
    mixins: [dataPicker],
    components: {
      DataPickerView
    },
    props: {
      options: {
        type: [Object, Array],
        default() {
          return {};
        }
      },
      popupTitle: {
        type: String,
        default: "è¯·é€‰æ‹©"
      },
      placeholder: {
        type: String,
        default: "è¯·é€‰æ‹©"
      },
      heightMobile: {
        type: String,
        default: ""
      },
      readonly: {
        type: Boolean,
        default: false
      },
      clearIcon: {
        type: Boolean,
        default: true
      },
      border: {
        type: Boolean,
        default: true
      },
      split: {
        type: String,
        default: "/"
      },
      ellipsis: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        isOpened: false,
        inputSelected: []
      };
    },
    created() {
      this.$nextTick(() => {
        this.load();
      });
    },
    watch: {
      localdata: {
        handler() {
          this.load();
        },
        deep: true
      }
    },
    methods: {
      clear() {
        this._dispatchEvent([]);
      },
      onPropsChange() {
        this._treeData = [];
        this.selectedIndex = 0;
        this.load();
      },
      load() {
        if (this.readonly) {
          this._processReadonly(this.localdata, this.dataValue);
          return;
        }
        if (this.isLocalData) {
          this.loadData();
          this.inputSelected = this.selected.slice(0);
        } else if (this.isCloudDataList || this.isCloudDataTree) {
          this.loading = true;
          this.getCloudDataValue().then((res) => {
            this.loading = false;
            this.inputSelected = res;
          }).catch((err) => {
            this.loading = false;
            this.errorMessage = err;
          });
        }
      },
      show() {
        this.isOpened = true;
        setTimeout(() => {
          this.$refs.pickerView.updateData({
            treeData: this._treeData,
            selected: this.selected,
            selectedIndex: this.selectedIndex
          });
        }, 200);
        this.$emit("popupopened");
      },
      hide() {
        this.isOpened = false;
        this.$emit("popupclosed");
      },
      handleInput() {
        if (this.readonly) {
          this.$emit("inputclick");
          return;
        }
        this.show();
      },
      handleClose(e2) {
        this.hide();
      },
      onnodeclick(e2) {
        this.$emit("nodeclick", e2);
      },
      ondatachange(e2) {
        this._treeData = this.$refs.pickerView._treeData;
      },
      onchange(e2) {
        this.hide();
        this.$nextTick(() => {
          this.inputSelected = e2;
        });
        this._dispatchEvent(e2);
      },
      _processReadonly(dataList, value) {
        var isTree = dataList.findIndex((item2) => {
          return item2.children;
        });
        if (isTree > -1) {
          let inputValue;
          if (Array.isArray(value)) {
            inputValue = value[value.length - 1];
            if (typeof inputValue === "object" && inputValue.value) {
              inputValue = inputValue.value;
            }
          } else {
            inputValue = value;
          }
          this.inputSelected = this._findNodePath(inputValue, this.localdata);
          return;
        }
        if (!this.hasValue) {
          this.inputSelected = [];
          return;
        }
        let result = [];
        for (let i2 = 0; i2 < value.length; i2++) {
          var val = value[i2];
          var item = dataList.find((v2) => {
            return v2.value == val;
          });
          if (item) {
            result.push(item);
          }
        }
        if (result.length) {
          this.inputSelected = result;
        }
      },
      _filterForArray(data, valueArray) {
        var result = [];
        for (let i2 = 0; i2 < valueArray.length; i2++) {
          var value = valueArray[i2];
          var found = data.find((item) => {
            return item.value == value;
          });
          if (found) {
            result.push(found);
          }
        }
        return result;
      },
      _dispatchEvent(selected) {
        let item = {};
        if (selected.length) {
          var value = new Array(selected.length);
          for (var i2 = 0; i2 < selected.length; i2++) {
            value[i2] = selected[i2].value;
          }
          item = selected[selected.length - 1];
        } else {
          item.value = "";
        }
        if (this.formItem) {
          this.formItem.setValue(item.value);
        }
        this.$emit("input", item.value);
        this.$emit("update:modelValue", item.value);
        this.$emit("change", {
          detail: {
            value: selected
          }
        });
      }
    }
  };
  function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_load_more = resolveEasycom(vue.resolveDynamicComponent("uni-load-more"), __easycom_0$6);
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    const _component_data_picker_view = vue.resolveComponent("data-picker-view");
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-data-tree" }, [
      vue.createElementVNode("view", {
        class: "uni-data-tree-input",
        onClick: _cache[1] || (_cache[1] = (...args) => $options.handleInput && $options.handleInput(...args))
      }, [
        vue.renderSlot(_ctx.$slots, "default", {
          options: $props.options,
          data: $data.inputSelected,
          error: _ctx.errorMessage
        }, () => [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["input-value", { "input-value-border": $props.border }])
            },
            [
              _ctx.errorMessage ? (vue.openBlock(), vue.createElementBlock(
                "text",
                {
                  key: 0,
                  class: "selected-area error-text"
                },
                vue.toDisplayString(_ctx.errorMessage),
                1
                /* TEXT */
              )) : _ctx.loading && !$data.isOpened ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 1,
                class: "selected-area"
              }, [
                vue.createVNode(_component_uni_load_more, {
                  class: "load-more",
                  contentText: _ctx.loadMore,
                  status: "loading"
                }, null, 8, ["contentText"])
              ])) : $data.inputSelected.length ? (vue.openBlock(), vue.createElementBlock("scroll-view", {
                key: 2,
                class: "selected-area",
                "scroll-x": "true"
              }, [
                vue.createElementVNode("view", { class: "selected-list" }, [
                  (vue.openBlock(true), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList($data.inputSelected, (item, index) => {
                      return vue.openBlock(), vue.createElementBlock("view", {
                        class: "selected-item",
                        key: index
                      }, [
                        vue.createElementVNode(
                          "text",
                          { class: "text-color" },
                          vue.toDisplayString(item.text),
                          1
                          /* TEXT */
                        ),
                        index < $data.inputSelected.length - 1 ? (vue.openBlock(), vue.createElementBlock(
                          "text",
                          {
                            key: 0,
                            class: "input-split-line"
                          },
                          vue.toDisplayString($props.split),
                          1
                          /* TEXT */
                        )) : vue.createCommentVNode("v-if", true)
                      ]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ])
              ])) : (vue.openBlock(), vue.createElementBlock(
                "text",
                {
                  key: 3,
                  class: "selected-area placeholder"
                },
                vue.toDisplayString($props.placeholder),
                1
                /* TEXT */
              )),
              $props.clearIcon && !$props.readonly && $data.inputSelected.length ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 4,
                class: "icon-clear",
                onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $options.clear && $options.clear(...args), ["stop"]))
              }, [
                vue.createVNode(_component_uni_icons, {
                  type: "clear",
                  color: "#c0c4cc",
                  size: "24"
                })
              ])) : vue.createCommentVNode("v-if", true),
              (!$props.clearIcon || !$data.inputSelected.length) && !$props.readonly ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 5,
                class: "arrow-area"
              }, [
                vue.createElementVNode("view", { class: "input-arrow" })
              ])) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )
        ], true)
      ]),
      $data.isOpened ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "uni-data-tree-cover",
        onClick: _cache[2] || (_cache[2] = (...args) => $options.handleClose && $options.handleClose(...args))
      })) : vue.createCommentVNode("v-if", true),
      $data.isOpened ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 1,
        class: "uni-data-tree-dialog"
      }, [
        vue.createElementVNode("view", { class: "uni-popper__arrow" }),
        vue.createElementVNode("view", { class: "dialog-caption" }, [
          vue.createElementVNode("view", { class: "title-area" }, [
            vue.createElementVNode(
              "text",
              { class: "dialog-title" },
              vue.toDisplayString($props.popupTitle),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", {
            class: "dialog-close",
            onClick: _cache[3] || (_cache[3] = (...args) => $options.handleClose && $options.handleClose(...args))
          }, [
            vue.createElementVNode("view", {
              class: "dialog-close-plus",
              "data-id": "close"
            }),
            vue.createElementVNode("view", {
              class: "dialog-close-plus dialog-close-rotate",
              "data-id": "close"
            })
          ])
        ]),
        vue.createVNode(_component_data_picker_view, {
          class: "picker-view",
          ref: "pickerView",
          modelValue: _ctx.dataValue,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.dataValue = $event),
          localdata: _ctx.localdata,
          preload: _ctx.preload,
          collection: _ctx.collection,
          field: _ctx.field,
          orderby: _ctx.orderby,
          where: _ctx.where,
          "step-searh": _ctx.stepSearh,
          "self-field": _ctx.selfField,
          "parent-field": _ctx.parentField,
          "managed-mode": true,
          map: _ctx.map,
          ellipsis: $props.ellipsis,
          onChange: $options.onchange,
          onDatachange: $options.ondatachange,
          onNodeclick: $options.onnodeclick
        }, null, 8, ["modelValue", "localdata", "preload", "collection", "field", "orderby", "where", "step-searh", "self-field", "parent-field", "map", "ellipsis", "onChange", "onDatachange", "onNodeclick"])
      ])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const __easycom_0$4 = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$14], ["__scopeId", "data-v-2653531e"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-data-picker/components/uni-data-picker/uni-data-picker.vue"]]);
  const _sfc_main$14 = {
    data() {
      return {
        account: "test-app",
        username: "test-app",
        password: "Test123456",
        confirmPassword: "Test123456",
        phone: "13888888888",
        department: "äºŒåä¸€å®¤",
        departments: []
      };
    },
    mounted() {
      this.getDepartments();
    },
    methods: {
      validatePasswordComplexity(password) {
        const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z\d]{8,}$/;
        return regex.test(password);
      },
      submitRegister() {
        const data = {
          "account": this.account,
          "department": this.department,
          "name": this.username,
          "password": this.password,
          "phone": this.phone,
          "role": "ACTOR",
          "status": "USING"
        };
        if (this.password !== this.confirmPassword) {
          uni.showToast({
            title: "ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´",
            icon: "none"
          });
          return;
        }
        if (!this.validatePasswordComplexity(this.password)) {
          uni.showToast({
            title: "å¯†ç å¿…é¡»åŒ…å«è‡³å°‘8ä¸ªå­—ç¬¦ï¼Œä¸”åŒ…å«å¤§å°å†™å­—æ¯å’Œæ•°å­—",
            icon: "none"
          });
          return;
        }
        register(data).then((res) => {
          formatAppLog("log", "at pages/register/register.vue:75", res);
          if (res.code == 200) {
            uni.showToast({
              title: "æ³¨å†ŒæˆåŠŸ",
              duration: 2e3
            }).then((res2) => {
              uni.navigateTo({
                url: "/pages/login/login"
                // æ›¿æ¢ä¸ºç›®æ ‡é¡µé¢çš„è·¯å¾„
              });
            });
          }
        });
      },
      // èŽ·å–éƒ¨é—¨åˆ—è¡¨
      getDepartments() {
        this.departments = [
          {
            text: "äºŒåä¸€å®¤",
            value: "äºŒåä¸€å®¤"
          },
          {
            text: "äºŒåäºŒå®¤",
            value: "äºŒåäºŒå®¤"
          },
          {
            text: "äºŒåä¸‰å®¤",
            value: "äºŒåä¸‰å®¤"
          }
        ];
      },
      dataPickerChange(item) {
        this.department = item.detail.value[0].text;
        formatAppLog("log", "at pages/register/register.vue:107", this.department);
      }
    }
  };
  function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_data_picker = resolveEasycom(vue.resolveDynamicComponent("uni-data-picker"), __easycom_0$4);
    return vue.openBlock(), vue.createElementBlock("view", { class: "layout" }, [
      vue.createElementVNode("view", { class: "text" }, [
        vue.createElementVNode("text", null, "æ¬¢è¿Žæ³¨å†Œï¼")
      ]),
      vue.createElementVNode("view", {
        class: "account",
        style: { "margin-top": "25px" }
      }, [
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin-bottom": "7px" }
        }, "è´¦æˆ·å"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            focus: "",
            placeholder: "è¯·è¾“å…¥è´¦æˆ·å",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.account = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.account]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin-bottom": "7px" }
        }, "å§“å"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            focus: "",
            placeholder: "è¯·è¾“å…¥å§“å",
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.username = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.username]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "å¯†ç "),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            password: "",
            type: "text",
            placeholder: "è¯·è¾“å…¥å¯†ç ",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.password = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.password]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "å†æ¬¡è¾“å…¥å¯†ç "),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            password: "",
            type: "text",
            placeholder: "è¯·å†æ¬¡è¾“å…¥å¯†ç ",
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.confirmPassword = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.confirmPassword]
        ]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "éƒ¨é—¨"),
        vue.createVNode(_component_uni_data_picker, {
          localdata: $data.departments,
          "popup-title": "è¯·é€‰æ‹©éƒ¨é—¨",
          onChange: $options.dataPickerChange
        }, null, 8, ["localdata", "onChange"]),
        vue.createElementVNode("view", {
          class: "title",
          style: { "margin": "15px 0px 7px 0px" }
        }, "æ‰‹æœºå·"),
        vue.withDirectives(vue.createElementVNode(
          "input",
          {
            class: "uni-input",
            type: "text",
            placeholder: "è¯·è¾“å…¥æ‰‹æœºå·",
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.phone = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vue.vModelText, $data.phone]
        ]),
        vue.createElementVNode("button", {
          type: "primary",
          style: { "margin-top": "30px" },
          onClick: _cache[5] || (_cache[5] = (...args) => $options.submitRegister && $options.submitRegister(...args))
        }, "æ³¨å†Œ")
      ])
    ]);
  }
  const PagesRegisterRegister = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$13], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/register/register.vue"]]);
  const _sfc_main$13 = {
    data() {
      return {};
    },
    methods: {}
  };
  function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view");
  }
  const PagesForgetPasswordForgetPassword = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$12], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/forgetPassword/forgetPassword.vue"]]);
  const _imports_0$c = "/static/icon/finger.png";
  const _sfc_main$12 = {
    data() {
      return {
        result: "",
        disabled: true,
        show: false
      };
    },
    onLoad() {
      if (!plus.fingerprint.isSupport()) {
        this.result = "æ­¤è®¾å¤‡ä¸æ”¯æŒæŒ‡çº¹è¯†åˆ«";
        this.disabled = true;
      } else if (!plus.fingerprint.isKeyguardSecure()) {
        this.result = "æ­¤è®¾å¤‡æœªè®¾ç½®å¯†ç é”å±ï¼Œæ— æ³•ä½¿ç”¨æŒ‡çº¹è¯†åˆ«";
        this.disabled = true;
      } else if (!plus.fingerprint.isEnrolledFingerprints()) {
        this.result = "æ­¤è®¾å¤‡æœªå½•å…¥æŒ‡çº¹ï¼Œè¯·åˆ°è®¾ç½®ä¸­å¼€å¯";
        this.disabled = true;
      } else {
        this.result = "æ­¤è®¾å¤‡æ”¯æŒæŒ‡çº¹è¯†åˆ«";
        this.disabled = false;
      }
    },
    methods: {
      printCancel: function() {
        plus.fingerprint.cancel();
        this.result = "åœæ­¢æŒ‡çº¹è¯†åˆ«";
      },
      fingerprint: function() {
        let that = this;
        plus.fingerprint.authenticate(function() {
          plus.nativeUI.closeWaiting();
          that.show = false;
          that.result = "æŒ‡çº¹è¯†åˆ«æˆåŠŸ";
          const username = uni.getStorageSync("username");
          const password = uni.getStorageSync("password");
          login({
            account: username,
            password
          }).then((res) => {
            formatAppLog("log", "at pages/fingerLogin/fingerLogin.vue:68", res);
            if (res.code == 200) {
              uni.setStorageSync("token", res.data.token);
              uni.setStorageSync("userInfo", res.data.account);
              formatAppLog("log", "at pages/fingerLogin/fingerLogin.vue:72", uni.getStorageSync("token"));
              uni.showToast({
                title: "ç™»å½•æˆåŠŸ",
                duration: 2e3
              }).then(
                that.goToTask()
              );
            }
          });
        }, function(e2) {
          switch (e2.code) {
            case e2.AUTHENTICATE_MISMATCH:
              plus.nativeUI.toast("æŒ‡çº¹åŒ¹é…å¤±è´¥ï¼Œè¯·é‡æ–°è¾“å…¥");
              break;
            case e2.AUTHENTICATE_OVERLIMIT:
              plus.nativeUI.closeWaiting();
              plus.nativeUI.alert("æŒ‡çº¹è¯†åˆ«å¤±è´¥æ¬¡æ•°è¶…å‡ºé™åˆ¶ï¼Œè¯·ä½¿ç”¨å…¶å®ƒæ–¹å¼è¿›è¡Œè®¤è¯");
              break;
            case e2.CANCEL:
              plus.nativeUI.toast("å·²å–æ¶ˆè¯†åˆ«");
              break;
            default:
              plus.nativeUI.closeWaiting();
              plus.nativeUI.alert("æŒ‡çº¹è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•");
              break;
          }
        });
        if ("Android" == plus.os.name) {
          this.show = true;
        }
      },
      goToTask() {
        uni.redirectTo({
          url: "/pages/tabBar/tabBar"
        });
      }
    }
  };
  function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "layout" }, [
      vue.createElementVNode("view", {
        class: "fingerView",
        onClick: _cache[0] || (_cache[0] = ($event) => $options.fingerprint()),
        disabled: $data.disabled
      }, [
        vue.createElementVNode("image", {
          src: _imports_0$c,
          class: "fingerIcon"
        })
      ], 8, ["disabled"]),
      vue.createElementVNode("view", {
        onClick: _cache[1] || (_cache[1] = ($event) => $options.fingerprint()),
        disabled: $data.disabled
      }, [
        vue.createElementVNode("text", { style: { "color": "rgb(45, 130, 254)" } }, "ç‚¹å‡»è¿›è¡ŒæŒ‡çº¹è®¤è¯")
      ], 8, ["disabled"]),
      vue.createElementVNode("view", { style: { "margin-top": "70px" } }, [
        vue.createElementVNode("text", null, [
          vue.createElementVNode("navigator", {
            url: "/pages/login/login",
            "open-type": "navigateBack",
            "hover-class": "null"
          }, "è´¦å·å¯†ç ç™»å½•")
        ])
      ]),
      vue.createElementVNode(
        "view",
        { style: { "color": "red" } },
        vue.toDisplayString($data.result),
        1
        /* TEXT */
      )
    ]);
  }
  const PagesFingerLoginFingerLogin = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$11], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/fingerLogin/fingerLogin.vue"]]);
  const searchMission = (query) => {
    return request({
      url: `/mission/search`,
      method: "post",
      data: query
    });
  };
  const deleteMission = (missionId) => {
    return request({
      url: `/mission/delete/${missionId}`,
      method: "delete"
    });
  };
  const getMissionFileById = (missionId, curPage, pageSize) => {
    return request({
      url: "/missionFile/get/files",
      method: "get",
      data: {
        missionId,
        curPage,
        pageSize
      }
    });
  };
  const getMissionDetails = (params) => {
    return request({
      url: `/mission/details`,
      method: "post",
      data: params
    });
  };
  const getFileUrl = (id) => {
    return request({
      url: "/missionFile/get/file/mission",
      method: "get",
      data: {
        missionFileId: id
      }
    });
  };
  const _imports_0$b = "/static/icon/location_grey.png";
  const _imports_1$5 = "/static/icon/time_grey.png";
  const _sfc_main$11 = {
    name: "TaskPage",
    data() {
      return {
        currentTime: /* @__PURE__ */ new Date(),
        taskItem: [],
        tabbarIndex: 0,
        handlingType: [
          {
            value: "å…¨éƒ¨"
          },
          {
            value: "æœªå¼€å§‹"
          },
          {
            value: "è¿›è¡Œä¸­"
          },
          {
            value: "å·²å®Œæˆ"
          }
        ],
        query: {
          "param": {
            "curPage": 1,
            "pageSize": 10
          },
          "statuses": [
            "USING",
            "UNUSED",
            "COMING"
          ]
        }
      };
    },
    mounted() {
      this.initializeTasks();
    },
    computed: {},
    methods: {
      initializeTasks() {
        uni.showLoading({
          title: "æ­£åœ¨åŠ è½½ä»»åŠ¡",
          mask: true
        });
        searchMission(this.query).then((res) => {
          this.taskItem = res.data.records.map((e2) => ({
            id: e2.id,
            task_name: e2.missionName,
            country: e2.missionCountry,
            position: e2.missionCity,
            start_time: e2.missionStartTime,
            end_time: e2.missionEndTime,
            type: this.getTaskType(e2.missionStartTime, e2.missionEndTime),
            description: e2.missionDescription,
            key: e2.missionPassword,
            latitude: e2.latitude,
            longitude: e2.longitude,
            geoJson: e2.geoJson
          }));
          uni.hideLoading();
        });
      },
      getItems(index) {
        switch (index) {
          case 0:
            return this.taskItem;
          case 1:
            return this.filterUpcomingTasks();
          case 2:
            return this.filterComingTasks();
          case 3:
            return this.filterEndedTasks();
        }
      },
      getTaskType(startTime, endTime) {
        const start = new Date(startTime);
        const end = new Date(endTime);
        if (this.currentTime < start) {
          return "1";
        } else if (this.currentTime >= start && this.currentTime <= end) {
          return "2";
        } else {
          return "3";
        }
      },
      getTypeString(type) {
        switch (type) {
          case "1":
            return "æœªå¼€å§‹";
          case "2":
            return "è¿›è¡Œä¸­";
          case "3":
            return "å·²å®Œæˆ";
        }
      },
      getColor(type) {
        switch (type) {
          case "1":
            return "#ffcccc";
          case "2":
            return "#ccffcc";
          case "3":
            return "#dadada";
          default:
            return "#ffffff";
        }
      },
      showType(tbIndex) {
        this.tabbarIndex = tbIndex;
        formatAppLog("info", "at pages/task/task.vue:179", this.tabbarIndex);
      },
      filterUpcomingTasks() {
        return this.taskItem.filter((item) => item.type === "1");
      },
      filterComingTasks() {
        return this.taskItem.filter((item) => item.type === "2");
      },
      filterEndedTasks() {
        return this.taskItem.filter((item) => item.type === "3");
      },
      goToDetail(index, tabbarIndex) {
        var jsonData = this.getItems(tabbarIndex)[index];
        var strData = JSON.stringify(jsonData);
        uni.navigateTo({
          url: `/pages/task/task_detail/task_detail?taskItem=${strData}`
        });
      }
    }
  };
  function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createCommentVNode(" é¡¶éƒ¨Tabèœå• "),
      vue.createElementVNode("view", { class: "topTabBar" }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($data.handlingType, (item, tbIndex) => {
            return vue.openBlock(), vue.createElementBlock("view", {
              class: "grid",
              key: tbIndex,
              onClick: ($event) => $options.showType(tbIndex)
            }, [
              vue.createElementVNode(
                "view",
                {
                  class: vue.normalizeClass(["text", [tbIndex === $data.tabbarIndex ? "active" : ""]])
                },
                vue.toDisplayString(item.value),
                3
                /* TEXT, CLASS */
              )
            ], 8, ["onClick"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]),
      vue.createCommentVNode(" ä»»åŠ¡åˆ—è¡¨å±•ç¤ºåŒºåŸŸ "),
      vue.createElementVNode("view", { style: { "margin-top": "100upx", "padding": "0 20upx 50px 20upx" } }, [
        vue.createCommentVNode(" å¾ªçŽ¯è®¾ç½®å››ä¸ªèœå•é¡¹ "),
        (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList(4, (top_item, top_index) => {
            return vue.createElementVNode("view", { key: top_index }, [
              vue.createCommentVNode(" æ ¹æ®top_indexå†³å®šæ‰€å±žèœå•é¡¹ "),
              $data.tabbarIndex === top_index ? (vue.openBlock(), vue.createElementBlock(
                vue.Fragment,
                { key: 0 },
                [
                  vue.createCommentVNode(" ä»»åŠ¡åˆ—è¡¨ "),
                  (vue.openBlock(true), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList($options.getItems($data.tabbarIndex), (item, index) => {
                      return vue.openBlock(), vue.createElementBlock("view", { key: index }, [
                        vue.createCommentVNode(" åˆ—è¡¨é¡¹ "),
                        vue.createElementVNode("view", {
                          onClick: ($event) => $options.goToDetail(index, $data.tabbarIndex),
                          class: "task_item"
                        }, [
                          vue.createCommentVNode(" ä»»åŠ¡åç§°ã€ä»»åŠ¡çŠ¶æ€ "),
                          vue.createElementVNode("view", { class: "item_top" }, [
                            vue.createElementVNode("view", null, [
                              vue.createElementVNode(
                                "text",
                                null,
                                vue.toDisplayString(item.task_name),
                                1
                                /* TEXT */
                              )
                            ]),
                            vue.createElementVNode("view", null, [
                              vue.createElementVNode(
                                "text",
                                {
                                  style: vue.normalizeStyle({ background: $options.getColor(item.type) })
                                },
                                vue.toDisplayString($options.getTypeString(item.type)),
                                5
                                /* TEXT, STYLE */
                              )
                            ])
                          ]),
                          vue.createCommentVNode(" ä»»åŠ¡åœ°ç‚¹ "),
                          vue.createElementVNode("view", { class: "item_bottom" }, [
                            vue.createElementVNode("view", null, [
                              vue.createElementVNode("image", {
                                src: _imports_0$b,
                                style: { "width": "15px", "height": "15px" }
                              })
                            ]),
                            vue.createElementVNode("view", { style: { "margin-left": "7px" } }, [
                              vue.createElementVNode(
                                "text",
                                { style: { "line-height": "20px", "text-align": "center" } },
                                vue.toDisplayString(item.position),
                                1
                                /* TEXT */
                              )
                            ])
                          ]),
                          vue.createCommentVNode(" ä»»åŠ¡æ—¶é—´ "),
                          vue.createElementVNode("view", { class: "item_bottom" }, [
                            vue.createElementVNode("view", null, [
                              vue.createElementVNode("image", {
                                src: _imports_1$5,
                                style: { "width": "16px", "height": "16px" }
                              })
                            ]),
                            vue.createElementVNode("view", { style: { "margin-left": "7px" } }, [
                              vue.createElementVNode(
                                "text",
                                null,
                                vue.toDisplayString(item.start_time) + " - " + vue.toDisplayString(item.end_time),
                                1
                                /* TEXT */
                              )
                            ])
                          ])
                        ], 8, ["onClick"])
                      ]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ],
                64
                /* STABLE_FRAGMENT */
              )) : vue.createCommentVNode("v-if", true)
            ]);
          }),
          64
          /* STABLE_FRAGMENT */
        ))
      ])
    ]);
  }
  const PagesTaskTask = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$10], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/task/task.vue"]]);
  const _sfc_main$10 = {
    name: "UniStatusBar",
    data() {
      return {
        statusBarHeight: uni.getSystemInfoSync().statusBarHeight + "px"
      };
    }
  };
  function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        style: vue.normalizeStyle({ height: $data.statusBarHeight }),
        class: "uni-status-bar"
      },
      [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ],
      4
      /* STYLE */
    );
  }
  const statusBar = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$$], ["__scopeId", "data-v-7920e3e0"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-nav-bar/components/uni-nav-bar/uni-status-bar.vue"]]);
  const getVal = (val) => typeof val === "number" ? val + "px" : val;
  const _sfc_main$$ = {
    name: "UniNavBar",
    components: {
      statusBar
    },
    emits: ["clickLeft", "clickRight", "clickTitle"],
    props: {
      dark: {
        type: Boolean,
        default: false
      },
      title: {
        type: String,
        default: ""
      },
      leftText: {
        type: String,
        default: ""
      },
      rightText: {
        type: String,
        default: ""
      },
      leftIcon: {
        type: String,
        default: ""
      },
      rightIcon: {
        type: String,
        default: ""
      },
      fixed: {
        type: [Boolean, String],
        default: false
      },
      color: {
        type: String,
        default: ""
      },
      backgroundColor: {
        type: String,
        default: ""
      },
      statusBar: {
        type: [Boolean, String],
        default: false
      },
      shadow: {
        type: [Boolean, String],
        default: false
      },
      border: {
        type: [Boolean, String],
        default: true
      },
      height: {
        type: [Number, String],
        default: 44
      },
      leftWidth: {
        type: [Number, String],
        default: 60
      },
      rightWidth: {
        type: [Number, String],
        default: 60
      },
      stat: {
        type: [Boolean, String],
        default: ""
      }
    },
    computed: {
      themeBgColor() {
        if (this.dark) {
          if (this.backgroundColor) {
            return this.backgroundColor;
          } else {
            return this.dark ? "#333" : "#FFF";
          }
        }
        return this.backgroundColor || "#FFF";
      },
      themeColor() {
        if (this.dark) {
          if (this.color) {
            return this.color;
          } else {
            return this.dark ? "#fff" : "#333";
          }
        }
        return this.color || "#333";
      },
      navbarHeight() {
        return getVal(this.height);
      },
      leftIconWidth() {
        return getVal(this.leftWidth);
      },
      rightIconWidth() {
        return getVal(this.rightWidth);
      }
    },
    mounted() {
      if (uni.report && this.stat && this.title !== "") {
        uni.report("title", this.title);
      }
    },
    methods: {
      onClickLeft() {
        this.$emit("clickLeft");
      },
      onClickRight() {
        this.$emit("clickRight");
      },
      onClickTitle() {
        this.$emit("clickTitle");
      }
    }
  };
  function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_status_bar = vue.resolveComponent("status-bar");
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["uni-navbar", { "uni-dark": $props.dark, "uni-nvue-fixed": $props.fixed }])
      },
      [
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["uni-navbar__content", { "uni-navbar--fixed": $props.fixed, "uni-navbar--shadow": $props.shadow, "uni-navbar--border": $props.border }]),
            style: vue.normalizeStyle({ "background-color": $options.themeBgColor, "border-bottom-color": $options.themeColor })
          },
          [
            $props.statusBar ? (vue.openBlock(), vue.createBlock(_component_status_bar, { key: 0 })) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "view",
              {
                style: vue.normalizeStyle({ color: $options.themeColor, backgroundColor: $options.themeBgColor, height: $options.navbarHeight }),
                class: "uni-navbar__header"
              },
              [
                vue.createElementVNode(
                  "view",
                  {
                    onClick: _cache[0] || (_cache[0] = (...args) => $options.onClickLeft && $options.onClickLeft(...args)),
                    class: "uni-navbar__header-btns uni-navbar__header-btns-left",
                    style: vue.normalizeStyle({ width: $options.leftIconWidth })
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "left", {}, () => [
                      $props.leftIcon.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", {
                        key: 0,
                        class: "uni-navbar__content_view"
                      }, [
                        vue.createVNode(_component_uni_icons, {
                          color: $options.themeColor,
                          type: $props.leftIcon,
                          size: "20"
                        }, null, 8, ["color", "type"])
                      ])) : vue.createCommentVNode("v-if", true),
                      $props.leftText.length ? (vue.openBlock(), vue.createElementBlock(
                        "view",
                        {
                          key: 1,
                          class: vue.normalizeClass([{ "uni-navbar-btn-icon-left": !$props.leftIcon.length > 0 }, "uni-navbar-btn-text"])
                        },
                        [
                          vue.createElementVNode(
                            "text",
                            {
                              style: vue.normalizeStyle({ color: $options.themeColor, fontSize: "12px" })
                            },
                            vue.toDisplayString($props.leftText),
                            5
                            /* TEXT, STYLE */
                          )
                        ],
                        2
                        /* CLASS */
                      )) : vue.createCommentVNode("v-if", true)
                    ], true)
                  ],
                  4
                  /* STYLE */
                ),
                vue.createElementVNode("view", {
                  class: "uni-navbar__header-container",
                  onClick: _cache[1] || (_cache[1] = (...args) => $options.onClickTitle && $options.onClickTitle(...args))
                }, [
                  vue.renderSlot(_ctx.$slots, "default", {}, () => [
                    $props.title.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", {
                      key: 0,
                      class: "uni-navbar__header-container-inner"
                    }, [
                      vue.createElementVNode(
                        "text",
                        {
                          class: "uni-nav-bar-text uni-ellipsis-1",
                          style: vue.normalizeStyle({ color: $options.themeColor })
                        },
                        vue.toDisplayString($props.title),
                        5
                        /* TEXT, STYLE */
                      )
                    ])) : vue.createCommentVNode("v-if", true)
                  ], true)
                ]),
                vue.createElementVNode(
                  "view",
                  {
                    onClick: _cache[2] || (_cache[2] = (...args) => $options.onClickRight && $options.onClickRight(...args)),
                    class: "uni-navbar__header-btns uni-navbar__header-btns-right",
                    style: vue.normalizeStyle({ width: $options.rightIconWidth })
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "right", {}, () => [
                      $props.rightIcon.length ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, [
                        vue.createVNode(_component_uni_icons, {
                          color: $options.themeColor,
                          type: $props.rightIcon,
                          size: "22"
                        }, null, 8, ["color", "type"])
                      ])) : vue.createCommentVNode("v-if", true),
                      $props.rightText.length && !$props.rightIcon.length ? (vue.openBlock(), vue.createElementBlock("view", {
                        key: 1,
                        class: "uni-navbar-btn-text"
                      }, [
                        vue.createElementVNode(
                          "text",
                          {
                            class: "uni-nav-bar-right-text",
                            style: vue.normalizeStyle({ color: $options.themeColor })
                          },
                          vue.toDisplayString($props.rightText),
                          5
                          /* TEXT, STYLE */
                        )
                      ])) : vue.createCommentVNode("v-if", true)
                    ], true)
                  ],
                  4
                  /* STYLE */
                )
              ],
              4
              /* STYLE */
            )
          ],
          6
          /* CLASS, STYLE */
        ),
        $props.fixed ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "uni-navbar__placeholder"
        }, [
          $props.statusBar ? (vue.openBlock(), vue.createBlock(_component_status_bar, { key: 0 })) : vue.createCommentVNode("v-if", true),
          vue.createElementVNode(
            "view",
            {
              class: "uni-navbar__placeholder-view",
              style: vue.normalizeStyle({ height: $options.navbarHeight })
            },
            null,
            4
            /* STYLE */
          )
        ])) : vue.createCommentVNode("v-if", true)
      ],
      2
      /* CLASS */
    );
  }
  const __easycom_0$3 = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$_], ["__scopeId", "data-v-26544265"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-nav-bar/components/uni-nav-bar/uni-nav-bar.vue"]]);
  const _sfc_main$_ = {
    name: "uni-data-select",
    mixins: [Ys.mixinDatacom || {}],
    props: {
      localdata: {
        type: Array,
        default() {
          return [];
        }
      },
      value: {
        type: [String, Number],
        default: ""
      },
      modelValue: {
        type: [String, Number],
        default: ""
      },
      label: {
        type: String,
        default: ""
      },
      placeholder: {
        type: String,
        default: "è¯·é€‰æ‹©"
      },
      emptyTips: {
        type: String,
        default: "æ— é€‰é¡¹"
      },
      clear: {
        type: Boolean,
        default: true
      },
      defItem: {
        type: Number,
        default: 0
      },
      disabled: {
        type: Boolean,
        default: false
      },
      // æ ¼å¼åŒ–è¾“å‡º ç”¨æ³• field="_id as value, version as text, uni_platform as label" format="{label} - {text}"
      format: {
        type: String,
        default: ""
      },
      placement: {
        type: String,
        default: "bottom"
      }
    },
    data() {
      return {
        showSelector: false,
        current: "",
        mixinDatacomResData: [],
        apps: [],
        channels: [],
        cacheKey: "uni-data-select-lastSelectedValue"
      };
    },
    created() {
      this.debounceGet = this.debounce(() => {
        this.query();
      }, 300);
      if (this.collection && !this.localdata.length) {
        this.debounceGet();
      }
    },
    computed: {
      typePlaceholder() {
        const text = {
          "opendb-stat-app-versions": "ç‰ˆæœ¬",
          "opendb-app-channels": "æ¸ é“",
          "opendb-app-list": "åº”ç”¨"
        };
        const common = this.placeholder;
        const placeholder = text[this.collection];
        return placeholder ? common + placeholder : common;
      },
      valueCom() {
        return this.modelValue;
      },
      textShow() {
        let text = this.current;
        if (text.length > 10) {
          return text.slice(0, 25) + "...";
        }
        return text;
      },
      getOffsetByPlacement() {
        switch (this.placement) {
          case "top":
            return "bottom:calc(100% + 12px);";
          case "bottom":
            return "top:calc(100% + 12px);";
        }
      }
    },
    watch: {
      localdata: {
        immediate: true,
        handler(val, old) {
          if (Array.isArray(val) && old !== val) {
            this.mixinDatacomResData = val;
          }
        }
      },
      valueCom(val, old) {
        this.initDefVal();
      },
      mixinDatacomResData: {
        immediate: true,
        handler(val) {
          if (val.length) {
            this.initDefVal();
          }
        }
      }
    },
    methods: {
      debounce(fn, time = 100) {
        let timer = null;
        return function(...args) {
          if (timer)
            clearTimeout(timer);
          timer = setTimeout(() => {
            fn.apply(this, args);
          }, time);
        };
      },
      // æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢
      query() {
        this.mixinDatacomEasyGet();
      },
      // ç›‘å¬æŸ¥è¯¢æ¡ä»¶å˜æ›´äº‹ä»¶
      onMixinDatacomPropsChange() {
        if (this.collection) {
          this.debounceGet();
        }
      },
      initDefVal() {
        let defValue = "";
        if ((this.valueCom || this.valueCom === 0) && !this.isDisabled(this.valueCom)) {
          defValue = this.valueCom;
        } else {
          let strogeValue;
          if (this.collection) {
            strogeValue = this.getCache();
          }
          if (strogeValue || strogeValue === 0) {
            defValue = strogeValue;
          } else {
            let defItem = "";
            if (this.defItem > 0 && this.defItem <= this.mixinDatacomResData.length) {
              defItem = this.mixinDatacomResData[this.defItem - 1].value;
            }
            defValue = defItem;
          }
          if (defValue || defValue === 0) {
            this.emit(defValue);
          }
        }
        const def = this.mixinDatacomResData.find((item) => item.value === defValue);
        this.current = def ? this.formatItemName(def) : "";
      },
      /**
       * @param {[String, Number]} value
       * åˆ¤æ–­ç”¨æˆ·ç»™çš„ value æ˜¯å¦åŒæ—¶ä¸ºç¦ç”¨çŠ¶æ€
       */
      isDisabled(value) {
        let isDisabled = false;
        this.mixinDatacomResData.forEach((item) => {
          if (item.value === value) {
            isDisabled = item.disable;
          }
        });
        return isDisabled;
      },
      clearVal() {
        this.emit("");
        if (this.collection) {
          this.removeCache();
        }
      },
      change(item) {
        if (!item.disable) {
          this.showSelector = false;
          this.current = this.formatItemName(item);
          this.emit(item.value);
        }
      },
      emit(val) {
        this.$emit("input", val);
        this.$emit("update:modelValue", val);
        this.$emit("change", val);
        if (this.collection) {
          this.setCache(val);
        }
      },
      toggleSelector() {
        if (this.disabled) {
          return;
        }
        this.showSelector = !this.showSelector;
      },
      formatItemName(item) {
        let {
          text,
          value,
          channel_code
        } = item;
        channel_code = channel_code ? `(${channel_code})` : "";
        if (this.format) {
          let str = "";
          str = this.format;
          for (let key in item) {
            str = str.replace(new RegExp(`{${key}}`, "g"), item[key]);
          }
          return str;
        } else {
          return this.collection.indexOf("app-list") > 0 ? `${text}(${value})` : text ? text : `æœªå‘½å${channel_code}`;
        }
      },
      // èŽ·å–å½“å‰åŠ è½½çš„æ•°æ®
      getLoadData() {
        return this.mixinDatacomResData;
      },
      // èŽ·å–å½“å‰ç¼“å­˜key
      getCurrentCacheKey() {
        return this.collection;
      },
      // èŽ·å–ç¼“å­˜
      getCache(name = this.getCurrentCacheKey()) {
        let cacheData = uni.getStorageSync(this.cacheKey) || {};
        return cacheData[name];
      },
      // è®¾ç½®ç¼“å­˜
      setCache(value, name = this.getCurrentCacheKey()) {
        let cacheData = uni.getStorageSync(this.cacheKey) || {};
        cacheData[name] = value;
        uni.setStorageSync(this.cacheKey, cacheData);
      },
      // åˆ é™¤ç¼“å­˜
      removeCache(name = this.getCurrentCacheKey()) {
        let cacheData = uni.getStorageSync(this.cacheKey) || {};
        delete cacheData[name];
        uni.setStorageSync(this.cacheKey, cacheData);
      }
    }
  };
  function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-stat__select" }, [
      $props.label ? (vue.openBlock(), vue.createElementBlock(
        "span",
        {
          key: 0,
          class: "uni-label-text hide-on-phone"
        },
        vue.toDisplayString($props.label + "ï¼š"),
        1
        /* TEXT */
      )) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode(
        "view",
        {
          class: vue.normalizeClass(["uni-stat-box", { "uni-stat__actived": $data.current }])
        },
        [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["uni-select", { "uni-select--disabled": $props.disabled }])
            },
            [
              vue.createElementVNode("view", {
                class: "uni-select__input-box",
                onClick: _cache[1] || (_cache[1] = (...args) => $options.toggleSelector && $options.toggleSelector(...args))
              }, [
                $data.current ? (vue.openBlock(), vue.createElementBlock(
                  "view",
                  {
                    key: 0,
                    class: "uni-select__input-text"
                  },
                  vue.toDisplayString($options.textShow),
                  1
                  /* TEXT */
                )) : (vue.openBlock(), vue.createElementBlock(
                  "view",
                  {
                    key: 1,
                    class: "uni-select__input-text uni-select__input-placeholder"
                  },
                  vue.toDisplayString($options.typePlaceholder),
                  1
                  /* TEXT */
                )),
                $data.current && $props.clear && !$props.disabled ? (vue.openBlock(), vue.createElementBlock("view", {
                  key: 2,
                  onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $options.clearVal && $options.clearVal(...args), ["stop"]))
                }, [
                  vue.createVNode(_component_uni_icons, {
                    type: "clear",
                    color: "#c0c4cc",
                    size: "24"
                  })
                ])) : (vue.openBlock(), vue.createElementBlock("view", { key: 3 }, [
                  vue.createVNode(_component_uni_icons, {
                    type: $data.showSelector ? "top" : "bottom",
                    size: "14",
                    color: "#999"
                  }, null, 8, ["type"])
                ]))
              ]),
              $data.showSelector ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 0,
                class: "uni-select--mask",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.toggleSelector && $options.toggleSelector(...args))
              })) : vue.createCommentVNode("v-if", true),
              $data.showSelector ? (vue.openBlock(), vue.createElementBlock(
                "view",
                {
                  key: 1,
                  class: "uni-select__selector",
                  style: vue.normalizeStyle($options.getOffsetByPlacement)
                },
                [
                  vue.createElementVNode(
                    "view",
                    {
                      class: vue.normalizeClass($props.placement == "bottom" ? "uni-popper__arrow_bottom" : "uni-popper__arrow_top")
                    },
                    null,
                    2
                    /* CLASS */
                  ),
                  vue.createElementVNode("scroll-view", {
                    "scroll-y": "true",
                    class: "uni-select__selector-scroll"
                  }, [
                    $data.mixinDatacomResData.length === 0 ? (vue.openBlock(), vue.createElementBlock("view", {
                      key: 0,
                      class: "uni-select__selector-empty"
                    }, [
                      vue.createElementVNode(
                        "text",
                        null,
                        vue.toDisplayString($props.emptyTips),
                        1
                        /* TEXT */
                      )
                    ])) : (vue.openBlock(true), vue.createElementBlock(
                      vue.Fragment,
                      { key: 1 },
                      vue.renderList($data.mixinDatacomResData, (item, index) => {
                        return vue.openBlock(), vue.createElementBlock("view", {
                          class: "uni-select__selector-item",
                          key: index,
                          onClick: ($event) => $options.change(item)
                        }, [
                          vue.createElementVNode(
                            "text",
                            {
                              class: vue.normalizeClass({ "uni-select__selector__disabled": item.disable })
                            },
                            vue.toDisplayString($options.formatItemName(item)),
                            3
                            /* TEXT, CLASS */
                          )
                        ], 8, ["onClick"]);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ])
                ],
                4
                /* STYLE */
              )) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      )
    ]);
  }
  const __easycom_1$2 = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$Z], ["__scopeId", "data-v-ddf9e0a2"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-data-select/components/uni-data-select/uni-data-select.vue"]]);
  class MPAnimation {
    constructor(options, _this) {
      this.options = options;
      this.animation = uni.createAnimation({
        ...options
      });
      this.currentStepAnimates = {};
      this.next = 0;
      this.$ = _this;
    }
    _nvuePushAnimates(type, args) {
      let aniObj = this.currentStepAnimates[this.next];
      let styles = {};
      if (!aniObj) {
        styles = {
          styles: {},
          config: {}
        };
      } else {
        styles = aniObj;
      }
      if (animateTypes1.includes(type)) {
        if (!styles.styles.transform) {
          styles.styles.transform = "";
        }
        let unit = "";
        if (type === "rotate") {
          unit = "deg";
        }
        styles.styles.transform += `${type}(${args + unit}) `;
      } else {
        styles.styles[type] = `${args}`;
      }
      this.currentStepAnimates[this.next] = styles;
    }
    _animateRun(styles = {}, config = {}) {
      let ref = this.$.$refs["ani"].ref;
      if (!ref)
        return;
      return new Promise((resolve, reject) => {
        nvueAnimation.transition(ref, {
          styles,
          ...config
        }, (res) => {
          resolve();
        });
      });
    }
    _nvueNextAnimate(animates, step = 0, fn) {
      let obj = animates[step];
      if (obj) {
        let {
          styles,
          config
        } = obj;
        this._animateRun(styles, config).then(() => {
          step += 1;
          this._nvueNextAnimate(animates, step, fn);
        });
      } else {
        this.currentStepAnimates = {};
        typeof fn === "function" && fn();
        this.isEnd = true;
      }
    }
    step(config = {}) {
      this.animation.step(config);
      return this;
    }
    run(fn) {
      this.$.animationData = this.animation.export();
      this.$.timer = setTimeout(() => {
        typeof fn === "function" && fn();
      }, this.$.durationTime);
    }
  }
  const animateTypes1 = [
    "matrix",
    "matrix3d",
    "rotate",
    "rotate3d",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scale3d",
    "scaleX",
    "scaleY",
    "scaleZ",
    "skew",
    "skewX",
    "skewY",
    "translate",
    "translate3d",
    "translateX",
    "translateY",
    "translateZ"
  ];
  const animateTypes2 = ["opacity", "backgroundColor"];
  const animateTypes3 = ["width", "height", "left", "right", "top", "bottom"];
  animateTypes1.concat(animateTypes2, animateTypes3).forEach((type) => {
    MPAnimation.prototype[type] = function(...args) {
      this.animation[type](...args);
      return this;
    };
  });
  function createAnimation(option, _this) {
    if (!_this)
      return;
    clearTimeout(_this.timer);
    return new MPAnimation(option, _this);
  }
  const _sfc_main$Z = {
    name: "uniTransition",
    emits: ["click", "change"],
    props: {
      show: {
        type: Boolean,
        default: false
      },
      modeClass: {
        type: [Array, String],
        default() {
          return "fade";
        }
      },
      duration: {
        type: Number,
        default: 300
      },
      styles: {
        type: Object,
        default() {
          return {};
        }
      },
      customClass: {
        type: String,
        default: ""
      },
      onceRender: {
        type: Boolean,
        default: false
      }
    },
    data() {
      return {
        isShow: false,
        transform: "",
        opacity: 1,
        animationData: {},
        durationTime: 300,
        config: {}
      };
    },
    watch: {
      show: {
        handler(newVal) {
          if (newVal) {
            this.open();
          } else {
            if (this.isShow) {
              this.close();
            }
          }
        },
        immediate: true
      }
    },
    computed: {
      // ç”Ÿæˆæ ·å¼æ•°æ®
      stylesObject() {
        let styles = {
          ...this.styles,
          "transition-duration": this.duration / 1e3 + "s"
        };
        let transform = "";
        for (let i2 in styles) {
          let line = this.toLine(i2);
          transform += line + ":" + styles[i2] + ";";
        }
        return transform;
      },
      // åˆå§‹åŒ–åŠ¨ç”»æ¡ä»¶
      transformStyles() {
        return "transform:" + this.transform + ";opacity:" + this.opacity + ";" + this.stylesObject;
      }
    },
    created() {
      this.config = {
        duration: this.duration,
        timingFunction: "ease",
        transformOrigin: "50% 50%",
        delay: 0
      };
      this.durationTime = this.duration;
    },
    methods: {
      /**
       *  ref è§¦å‘ åˆå§‹åŒ–åŠ¨ç”»
       */
      init(obj = {}) {
        if (obj.duration) {
          this.durationTime = obj.duration;
        }
        this.animation = createAnimation(Object.assign(this.config, obj), this);
      },
      /**
       * ç‚¹å‡»ç»„ä»¶è§¦å‘å›žè°ƒ
       */
      onClick() {
        this.$emit("click", {
          detail: this.isShow
        });
      },
      /**
       * ref è§¦å‘ åŠ¨ç”»åˆ†ç»„
       * @param {Object} obj
       */
      step(obj, config = {}) {
        if (!this.animation)
          return;
        for (let i2 in obj) {
          try {
            if (typeof obj[i2] === "object") {
              this.animation[i2](...obj[i2]);
            } else {
              this.animation[i2](obj[i2]);
            }
          } catch (e2) {
            formatAppLog("error", "at uni_modules/uni-transition/components/uni-transition/uni-transition.vue:148", `æ–¹æ³• ${i2} ä¸å­˜åœ¨`);
          }
        }
        this.animation.step(config);
        return this;
      },
      /**
       *  ref è§¦å‘ æ‰§è¡ŒåŠ¨ç”»
       */
      run(fn) {
        if (!this.animation)
          return;
        this.animation.run(fn);
      },
      // å¼€å§‹è¿‡åº¦åŠ¨ç”»
      open() {
        clearTimeout(this.timer);
        this.transform = "";
        this.isShow = true;
        let { opacity, transform } = this.styleInit(false);
        if (typeof opacity !== "undefined") {
          this.opacity = opacity;
        }
        this.transform = transform;
        this.$nextTick(() => {
          this.timer = setTimeout(() => {
            this.animation = createAnimation(this.config, this);
            this.tranfromInit(false).step();
            this.animation.run();
            this.$emit("change", {
              detail: this.isShow
            });
          }, 20);
        });
      },
      // å…³é—­è¿‡åº¦åŠ¨ç”»
      close(type) {
        if (!this.animation)
          return;
        this.tranfromInit(true).step().run(() => {
          this.isShow = false;
          this.animationData = null;
          this.animation = null;
          let { opacity, transform } = this.styleInit(false);
          this.opacity = opacity || 1;
          this.transform = transform;
          this.$emit("change", {
            detail: this.isShow
          });
        });
      },
      // å¤„ç†åŠ¨ç”»å¼€å§‹å‰çš„é»˜è®¤æ ·å¼
      styleInit(type) {
        let styles = {
          transform: ""
        };
        let buildStyle = (type2, mode) => {
          if (mode === "fade") {
            styles.opacity = this.animationType(type2)[mode];
          } else {
            styles.transform += this.animationType(type2)[mode] + " ";
          }
        };
        if (typeof this.modeClass === "string") {
          buildStyle(type, this.modeClass);
        } else {
          this.modeClass.forEach((mode) => {
            buildStyle(type, mode);
          });
        }
        return styles;
      },
      // å¤„ç†å†…ç½®ç»„åˆåŠ¨ç”»
      tranfromInit(type) {
        let buildTranfrom = (type2, mode) => {
          let aniNum = null;
          if (mode === "fade") {
            aniNum = type2 ? 0 : 1;
          } else {
            aniNum = type2 ? "-100%" : "0";
            if (mode === "zoom-in") {
              aniNum = type2 ? 0.8 : 1;
            }
            if (mode === "zoom-out") {
              aniNum = type2 ? 1.2 : 1;
            }
            if (mode === "slide-right") {
              aniNum = type2 ? "100%" : "0";
            }
            if (mode === "slide-bottom") {
              aniNum = type2 ? "100%" : "0";
            }
          }
          this.animation[this.animationMode()[mode]](aniNum);
        };
        if (typeof this.modeClass === "string") {
          buildTranfrom(type, this.modeClass);
        } else {
          this.modeClass.forEach((mode) => {
            buildTranfrom(type, mode);
          });
        }
        return this.animation;
      },
      animationType(type) {
        return {
          fade: type ? 0 : 1,
          "slide-top": `translateY(${type ? "0" : "-100%"})`,
          "slide-right": `translateX(${type ? "0" : "100%"})`,
          "slide-bottom": `translateY(${type ? "0" : "100%"})`,
          "slide-left": `translateX(${type ? "0" : "-100%"})`,
          "zoom-in": `scaleX(${type ? 1 : 0.8}) scaleY(${type ? 1 : 0.8})`,
          "zoom-out": `scaleX(${type ? 1 : 1.2}) scaleY(${type ? 1 : 1.2})`
        };
      },
      // å†…ç½®åŠ¨ç”»ç±»åž‹ä¸Žå®žé™…åŠ¨ç”»å¯¹åº”å­—å…¸
      animationMode() {
        return {
          fade: "opacity",
          "slide-top": "translateY",
          "slide-right": "translateX",
          "slide-bottom": "translateY",
          "slide-left": "translateX",
          "zoom-in": "scale",
          "zoom-out": "scale"
        };
      },
      // é©¼å³°è½¬ä¸­æ¨ªçº¿
      toLine(name) {
        return name.replace(/([A-Z])/g, "-$1").toLowerCase();
      }
    }
  };
  function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.withDirectives((vue.openBlock(), vue.createElementBlock("view", {
      ref: "ani",
      animation: $data.animationData,
      class: vue.normalizeClass($props.customClass),
      style: vue.normalizeStyle($options.transformStyles),
      onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 14, ["animation"])), [
      [vue.vShow, $data.isShow]
    ]);
  }
  const __easycom_0$2 = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Y], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-transition/components/uni-transition/uni-transition.vue"]]);
  const _sfc_main$Y = {
    name: "uniPopup",
    components: {},
    emits: ["change", "maskClick"],
    props: {
      // å¼€å¯åŠ¨ç”»
      animation: {
        type: Boolean,
        default: true
      },
      // å¼¹å‡ºå±‚ç±»åž‹ï¼Œå¯é€‰å€¼ï¼Œtop: é¡¶éƒ¨å¼¹å‡ºå±‚ï¼›bottomï¼šåº•éƒ¨å¼¹å‡ºå±‚ï¼›centerï¼šå…¨å±å¼¹å‡ºå±‚
      // message: æ¶ˆæ¯æç¤º ; dialog : å¯¹è¯æ¡†
      type: {
        type: String,
        default: "center"
      },
      // maskClick
      isMaskClick: {
        type: Boolean,
        default: null
      },
      // TODO 2 ä¸ªç‰ˆæœ¬åŽåºŸå¼ƒå±žæ€§ ï¼Œä½¿ç”¨ isMaskClick
      maskClick: {
        type: Boolean,
        default: null
      },
      backgroundColor: {
        type: String,
        default: "none"
      },
      safeArea: {
        type: Boolean,
        default: true
      },
      maskBackgroundColor: {
        type: String,
        default: "rgba(0, 0, 0, 0.4)"
      },
      borderRadius: {
        type: String
      }
    },
    watch: {
      /**
       * ç›‘å¬typeç±»åž‹
       */
      type: {
        handler: function(type) {
          if (!this.config[type])
            return;
          this[this.config[type]](true);
        },
        immediate: true
      },
      isDesktop: {
        handler: function(newVal) {
          if (!this.config[newVal])
            return;
          this[this.config[this.type]](true);
        },
        immediate: true
      },
      /**
       * ç›‘å¬é®ç½©æ˜¯å¦å¯ç‚¹å‡»
       * @param {Object} val
       */
      maskClick: {
        handler: function(val) {
          this.mkclick = val;
        },
        immediate: true
      },
      isMaskClick: {
        handler: function(val) {
          this.mkclick = val;
        },
        immediate: true
      },
      // H5 ä¸‹ç¦æ­¢åº•éƒ¨æ»šåŠ¨
      showPopup(show) {
      }
    },
    data() {
      return {
        duration: 300,
        ani: [],
        showPopup: false,
        showTrans: false,
        popupWidth: 0,
        popupHeight: 0,
        config: {
          top: "top",
          bottom: "bottom",
          center: "center",
          left: "left",
          right: "right",
          message: "top",
          dialog: "center",
          share: "bottom"
        },
        maskClass: {
          position: "fixed",
          bottom: 0,
          top: 0,
          left: 0,
          right: 0,
          backgroundColor: "rgba(0, 0, 0, 0.4)"
        },
        transClass: {
          backgroundColor: "transparent",
          borderRadius: this.borderRadius || "0",
          position: "fixed",
          left: 0,
          right: 0
        },
        maskShow: true,
        mkclick: true,
        popupstyle: "top"
      };
    },
    computed: {
      getStyles() {
        let res = { backgroundColor: this.bg };
        if (this.borderRadius || "0") {
          res = Object.assign(res, { borderRadius: this.borderRadius });
        }
        return res;
      },
      isDesktop() {
        return this.popupWidth >= 500 && this.popupHeight >= 500;
      },
      bg() {
        if (this.backgroundColor === "" || this.backgroundColor === "none") {
          return "transparent";
        }
        return this.backgroundColor;
      }
    },
    mounted() {
      const fixSize = () => {
        const {
          windowWidth,
          windowHeight,
          windowTop,
          safeArea,
          screenHeight,
          safeAreaInsets
        } = uni.getSystemInfoSync();
        this.popupWidth = windowWidth;
        this.popupHeight = windowHeight + (windowTop || 0);
        if (safeArea && this.safeArea) {
          this.safeAreaInsets = safeAreaInsets.bottom;
        } else {
          this.safeAreaInsets = 0;
        }
      };
      fixSize();
    },
    // TODO vue3
    unmounted() {
      this.setH5Visible();
    },
    activated() {
      this.setH5Visible(!this.showPopup);
    },
    deactivated() {
      this.setH5Visible(true);
    },
    created() {
      if (this.isMaskClick === null && this.maskClick === null) {
        this.mkclick = true;
      } else {
        this.mkclick = this.isMaskClick !== null ? this.isMaskClick : this.maskClick;
      }
      if (this.animation) {
        this.duration = 300;
      } else {
        this.duration = 0;
      }
      this.messageChild = null;
      this.clearPropagation = false;
      this.maskClass.backgroundColor = this.maskBackgroundColor;
    },
    methods: {
      setH5Visible(visible = true) {
      },
      /**
       * å…¬ç”¨æ–¹æ³•ï¼Œä¸æ˜¾ç¤ºé®ç½©å±‚
       */
      closeMask() {
        this.maskShow = false;
      },
      /**
       * å…¬ç”¨æ–¹æ³•ï¼Œé®ç½©å±‚ç¦æ­¢ç‚¹å‡»
       */
      disableMask() {
        this.mkclick = false;
      },
      // TODO nvue å–æ¶ˆå†’æ³¡
      clear(e2) {
        e2.stopPropagation();
        this.clearPropagation = true;
      },
      open(direction) {
        if (this.showPopup) {
          return;
        }
        let innerType = ["top", "center", "bottom", "left", "right", "message", "dialog", "share"];
        if (!(direction && innerType.indexOf(direction) !== -1)) {
          direction = this.type;
        }
        if (!this.config[direction]) {
          formatAppLog("error", "at uni_modules/uni-popup/components/uni-popup/uni-popup.vue:298", "ç¼ºå°‘ç±»åž‹ï¼š", direction);
          return;
        }
        this[this.config[direction]]();
        this.$emit("change", {
          show: true,
          type: direction
        });
      },
      close(type) {
        this.showTrans = false;
        this.$emit("change", {
          show: false,
          type: this.type
        });
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          this.showPopup = false;
        }, 300);
      },
      // TODO å¤„ç†å†’æ³¡äº‹ä»¶ï¼Œå¤´æ¡çš„å†’æ³¡äº‹ä»¶æœ‰é—®é¢˜ ï¼Œå…ˆè¿™æ ·å…¼å®¹
      touchstart() {
        this.clearPropagation = false;
      },
      onTap() {
        if (this.clearPropagation) {
          this.clearPropagation = false;
          return;
        }
        this.$emit("maskClick");
        if (!this.mkclick)
          return;
        this.close();
      },
      /**
       * é¡¶éƒ¨å¼¹å‡ºæ ·å¼å¤„ç†
       */
      top(type) {
        this.popupstyle = this.isDesktop ? "fixforpc-top" : "top";
        this.ani = ["slide-top"];
        this.transClass = {
          position: "fixed",
          left: 0,
          right: 0,
          backgroundColor: this.bg,
          borderRadius: this.borderRadius || "0"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
        this.$nextTick(() => {
          if (this.messageChild && this.type === "message") {
            this.messageChild.timerClose();
          }
        });
      },
      /**
       * åº•éƒ¨å¼¹å‡ºæ ·å¼å¤„ç†
       */
      bottom(type) {
        this.popupstyle = "bottom";
        this.ani = ["slide-bottom"];
        this.transClass = {
          position: "fixed",
          left: 0,
          right: 0,
          bottom: 0,
          paddingBottom: this.safeAreaInsets + "px",
          backgroundColor: this.bg,
          borderRadius: this.borderRadius || "0"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
      },
      /**
       * ä¸­é—´å¼¹å‡ºæ ·å¼å¤„ç†
       */
      center(type) {
        this.popupstyle = "center";
        this.ani = ["zoom-out", "fade"];
        this.transClass = {
          position: "fixed",
          display: "flex",
          flexDirection: "column",
          bottom: 0,
          left: 0,
          right: 0,
          top: 0,
          justifyContent: "center",
          alignItems: "center",
          borderRadius: this.borderRadius || "0"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
      },
      left(type) {
        this.popupstyle = "left";
        this.ani = ["slide-left"];
        this.transClass = {
          position: "fixed",
          left: 0,
          bottom: 0,
          top: 0,
          backgroundColor: this.bg,
          borderRadius: this.borderRadius || "0",
          display: "flex",
          flexDirection: "column"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
      },
      right(type) {
        this.popupstyle = "right";
        this.ani = ["slide-right"];
        this.transClass = {
          position: "fixed",
          bottom: 0,
          right: 0,
          top: 0,
          backgroundColor: this.bg,
          borderRadius: this.borderRadius || "0",
          display: "flex",
          flexDirection: "column"
        };
        if (type)
          return;
        this.showPopup = true;
        this.showTrans = true;
      }
    }
  };
  function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_transition = resolveEasycom(vue.resolveDynamicComponent("uni-transition"), __easycom_0$2);
    return $data.showPopup ? (vue.openBlock(), vue.createElementBlock(
      "view",
      {
        key: 0,
        class: vue.normalizeClass(["uni-popup", [$data.popupstyle, $options.isDesktop ? "fixforpc-z-index" : ""]])
      },
      [
        vue.createElementVNode(
          "view",
          {
            onTouchstart: _cache[1] || (_cache[1] = (...args) => $options.touchstart && $options.touchstart(...args))
          },
          [
            $data.maskShow ? (vue.openBlock(), vue.createBlock(_component_uni_transition, {
              key: "1",
              name: "mask",
              "mode-class": "fade",
              styles: $data.maskClass,
              duration: $data.duration,
              show: $data.showTrans,
              onClick: $options.onTap
            }, null, 8, ["styles", "duration", "show", "onClick"])) : vue.createCommentVNode("v-if", true),
            vue.createVNode(_component_uni_transition, {
              key: "2",
              "mode-class": $data.ani,
              name: "content",
              styles: $data.transClass,
              duration: $data.duration,
              show: $data.showTrans,
              onClick: $options.onTap
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode(
                  "view",
                  {
                    class: vue.normalizeClass(["uni-popup__wrapper", [$data.popupstyle]]),
                    style: vue.normalizeStyle($options.getStyles),
                    onClick: _cache[0] || (_cache[0] = (...args) => $options.clear && $options.clear(...args))
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
                  ],
                  6
                  /* CLASS, STYLE */
                )
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["mode-class", "styles", "duration", "show", "onClick"])
          ],
          32
          /* NEED_HYDRATION */
        )
      ],
      2
      /* CLASS */
    )) : vue.createCommentVNode("v-if", true);
  }
  const __easycom_2$1 = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$X], ["__scopeId", "data-v-4dd3c44b"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-popup/components/uni-popup/uni-popup.vue"]]);
  const _sfc_main$X = {
    name: "uniCollapseItem",
    props: {
      // åˆ—è¡¨æ ‡é¢˜
      title: {
        type: String,
        default: ""
      },
      name: {
        type: [Number, String],
        default: ""
      },
      // æ˜¯å¦ç¦ç”¨
      disabled: {
        type: Boolean,
        default: false
      },
      // æ˜¯å¦æ˜¾ç¤ºåŠ¨ç”»,app ç«¯é»˜è®¤ä¸å¼€å¯åŠ¨ç”»ï¼Œå¡é¡¿ä¸¥é‡
      showAnimation: {
        type: Boolean,
        default: false
      },
      // æ˜¯å¦å±•å¼€
      open: {
        type: Boolean,
        default: false
      },
      // ç¼©ç•¥å›¾
      thumb: {
        type: String,
        default: ""
      },
      // æ ‡é¢˜åˆ†éš”çº¿æ˜¾ç¤ºç±»åž‹
      titleBorder: {
        type: String,
        default: "auto"
      },
      border: {
        type: Boolean,
        default: true
      },
      showArrow: {
        type: Boolean,
        default: true
      }
    },
    data() {
      const elId = `Uni_${Math.ceil(Math.random() * 1e6).toString(36)}`;
      return {
        isOpen: false,
        isheight: null,
        height: 0,
        elId,
        nameSync: 0
      };
    },
    watch: {
      open(val) {
        this.isOpen = val;
        this.onClick(val, "init");
      }
    },
    updated(e2) {
      this.$nextTick(() => {
        this.init(true);
      });
    },
    created() {
      this.collapse = this.getCollapse();
      this.oldHeight = 0;
      this.onClick(this.open, "init");
    },
    // TODO vue3
    unmounted() {
      this.__isUnmounted = true;
      this.uninstall();
    },
    mounted() {
      if (!this.collapse)
        return;
      if (this.name !== "") {
        this.nameSync = this.name;
      } else {
        this.nameSync = this.collapse.childrens.length + "";
      }
      if (this.collapse.names.indexOf(this.nameSync) === -1) {
        this.collapse.names.push(this.nameSync);
      } else {
        formatAppLog("warn", "at uni_modules/uni-collapse/components/uni-collapse-item/uni-collapse-item.vue:154", `name å€¼ ${this.nameSync} é‡å¤`);
      }
      if (this.collapse.childrens.indexOf(this) === -1) {
        this.collapse.childrens.push(this);
      }
      this.init();
    },
    methods: {
      init(type) {
        this.getCollapseHeight(type);
      },
      uninstall() {
        if (this.collapse) {
          this.collapse.childrens.forEach((item, index) => {
            if (item === this) {
              this.collapse.childrens.splice(index, 1);
            }
          });
          this.collapse.names.forEach((item, index) => {
            if (item === this.nameSync) {
              this.collapse.names.splice(index, 1);
            }
          });
        }
      },
      onClick(isOpen, type) {
        if (this.disabled)
          return;
        this.isOpen = isOpen;
        if (this.isOpen && this.collapse) {
          this.collapse.setAccordion(this);
        }
        if (type !== "init") {
          this.collapse.onChange(isOpen, this);
        }
      },
      getCollapseHeight(type, index = 0) {
        const views = uni.createSelectorQuery().in(this);
        views.select(`#${this.elId}`).fields({
          size: true
        }, (data) => {
          if (index >= 10)
            return;
          if (!data) {
            index++;
            this.getCollapseHeight(false, index);
            return;
          }
          this.height = data.height;
          this.isheight = true;
          if (type)
            return;
          this.onClick(this.isOpen, "init");
        }).exec();
      },
      getNvueHwight(type) {
        dom.getComponentRect(this.$refs["collapse--hook"], (option) => {
          if (option && option.result && option.size) {
            this.height = option.size.height;
            this.isheight = true;
            if (type)
              return;
            this.onClick(this.open, "init");
          }
        });
      },
      /**
       * èŽ·å–çˆ¶å…ƒç´ å®žä¾‹
       */
      getCollapse(name = "uniCollapse") {
        let parent = this.$parent;
        let parentName = parent.$options.name;
        while (parentName !== name) {
          parent = parent.$parent;
          if (!parent)
            return false;
          parentName = parent.$options.name;
        }
        return parent;
      }
    }
  };
  function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-collapse-item" }, [
      vue.createCommentVNode(" onClick(!isOpen) "),
      vue.createElementVNode(
        "view",
        {
          onClick: _cache[0] || (_cache[0] = ($event) => $options.onClick(!$data.isOpen)),
          class: vue.normalizeClass(["uni-collapse-item__title", { "is-open": $data.isOpen && $props.titleBorder === "auto", "uni-collapse-item-border": $props.titleBorder !== "none" }])
        },
        [
          vue.createElementVNode("view", { class: "uni-collapse-item__title-wrap" }, [
            vue.renderSlot(_ctx.$slots, "title", {}, () => [
              vue.createElementVNode(
                "view",
                {
                  class: vue.normalizeClass(["uni-collapse-item__title-box", { "is-disabled": $props.disabled }])
                },
                [
                  $props.thumb ? (vue.openBlock(), vue.createElementBlock("image", {
                    key: 0,
                    src: $props.thumb,
                    class: "uni-collapse-item__title-img"
                  }, null, 8, ["src"])) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode(
                    "text",
                    { class: "uni-collapse-item__title-text" },
                    vue.toDisplayString($props.title),
                    1
                    /* TEXT */
                  )
                ],
                2
                /* CLASS */
              )
            ], true)
          ]),
          $props.showArrow ? (vue.openBlock(), vue.createElementBlock(
            "view",
            {
              key: 0,
              class: vue.normalizeClass([{ "uni-collapse-item__title-arrow-active": $data.isOpen, "uni-collapse-item--animation": $props.showAnimation === true }, "uni-collapse-item__title-arrow"])
            },
            [
              vue.createVNode(_component_uni_icons, {
                color: $props.disabled ? "#ddd" : "#bbb",
                size: "14",
                type: "bottom"
              }, null, 8, ["color"])
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      ),
      vue.createElementVNode(
        "view",
        {
          class: vue.normalizeClass(["uni-collapse-item__wrap", { "is--transition": $props.showAnimation }]),
          style: vue.normalizeStyle({ height: ($data.isOpen ? $data.height : 0) + "px" })
        },
        [
          vue.createElementVNode("view", {
            id: $data.elId,
            ref: "collapse--hook",
            class: vue.normalizeClass(["uni-collapse-item__wrap-content", { open: $data.isheight, "uni-collapse-item--border": $props.border && $data.isOpen }])
          }, [
            vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 10, ["id"])
        ],
        6
        /* CLASS, STYLE */
      )
    ]);
  }
  const __easycom_3$1 = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$W], ["__scopeId", "data-v-3d2dde9f"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-collapse/components/uni-collapse-item/uni-collapse-item.vue"]]);
  const _sfc_main$W = {
    name: "uniCollapse",
    emits: ["change", "activeItem", "input", "update:modelValue"],
    props: {
      value: {
        type: [String, Array],
        default: ""
      },
      modelValue: {
        type: [String, Array],
        default: ""
      },
      accordion: {
        // æ˜¯å¦å¼€å¯æ‰‹é£Žç´æ•ˆæžœ
        type: [Boolean, String],
        default: false
      }
    },
    data() {
      return {};
    },
    computed: {
      // TODO å…¼å®¹ vue2 å’Œ vue3
      dataValue() {
        let value = typeof this.value === "string" && this.value === "" || Array.isArray(this.value) && this.value.length === 0;
        let modelValue = typeof this.modelValue === "string" && this.modelValue === "" || Array.isArray(this.modelValue) && this.modelValue.length === 0;
        if (value) {
          return this.modelValue;
        }
        if (modelValue) {
          return this.value;
        }
        return this.value;
      }
    },
    watch: {
      dataValue(val) {
        this.setOpen(val);
      }
    },
    created() {
      this.childrens = [];
      this.names = [];
    },
    mounted() {
      this.$nextTick(() => {
        this.setOpen(this.dataValue);
      });
    },
    methods: {
      setOpen(val) {
        let str = typeof val === "string";
        let arr = Array.isArray(val);
        this.childrens.forEach((vm, index) => {
          if (str) {
            if (val === vm.nameSync) {
              if (!this.accordion) {
                formatAppLog("warn", "at uni_modules/uni-collapse/components/uni-collapse/uni-collapse.vue:75", "accordion å±žæ€§ä¸º false ,v-model ç±»åž‹åº”è¯¥ä¸º array");
                return;
              }
              vm.isOpen = true;
            }
          }
          if (arr) {
            val.forEach((v2) => {
              if (v2 === vm.nameSync) {
                if (this.accordion) {
                  formatAppLog("warn", "at uni_modules/uni-collapse/components/uni-collapse/uni-collapse.vue:85", "accordion å±žæ€§ä¸º true ,v-model ç±»åž‹åº”è¯¥ä¸º string");
                  return;
                }
                vm.isOpen = true;
              }
            });
          }
        });
        this.emit(val);
      },
      setAccordion(self2) {
        if (!this.accordion)
          return;
        this.childrens.forEach((vm, index) => {
          if (self2 !== vm) {
            vm.isOpen = false;
          }
        });
      },
      resize() {
        this.childrens.forEach((vm, index) => {
          vm.getCollapseHeight();
        });
      },
      onChange(isOpen, self2) {
        let activeItem = [];
        if (this.accordion) {
          activeItem = isOpen ? self2.nameSync : "";
        } else {
          this.childrens.forEach((vm, index) => {
            if (vm.isOpen) {
              activeItem.push(vm.nameSync);
            }
          });
        }
        this.$emit("change", activeItem);
        this.emit(activeItem);
      },
      emit(val) {
        this.$emit("input", val);
        this.$emit("update:modelValue", val);
      }
    }
  };
  function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-collapse" }, [
      vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ]);
  }
  const __easycom_4 = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$V], ["__scopeId", "data-v-3f050360"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-collapse/components/uni-collapse/uni-collapse.vue"]]);
  const _sfc_main$V = {
    name: "uniDataChecklist",
    mixins: [Ys.mixinDatacom || {}],
    emits: ["input", "update:modelValue", "change"],
    props: {
      mode: {
        type: String,
        default: "default"
      },
      multiple: {
        type: Boolean,
        default: false
      },
      value: {
        type: [Array, String, Number],
        default() {
          return "";
        }
      },
      // TODO vue3
      modelValue: {
        type: [Array, String, Number],
        default() {
          return "";
        }
      },
      localdata: {
        type: Array,
        default() {
          return [];
        }
      },
      min: {
        type: [Number, String],
        default: ""
      },
      max: {
        type: [Number, String],
        default: ""
      },
      wrap: {
        type: Boolean,
        default: false
      },
      icon: {
        type: String,
        default: "left"
      },
      selectedColor: {
        type: String,
        default: ""
      },
      selectedTextColor: {
        type: String,
        default: ""
      },
      emptyText: {
        type: String,
        default: "æš‚æ— æ•°æ®"
      },
      disabled: {
        type: Boolean,
        default: false
      },
      map: {
        type: Object,
        default() {
          return {
            text: "text",
            value: "value"
          };
        }
      }
    },
    watch: {
      localdata: {
        handler(newVal) {
          this.range = newVal;
          this.dataList = this.getDataList(this.getSelectedValue(newVal));
        },
        deep: true
      },
      mixinDatacomResData(newVal) {
        this.range = newVal;
        this.dataList = this.getDataList(this.getSelectedValue(newVal));
      },
      value(newVal) {
        this.dataList = this.getDataList(newVal);
      },
      modelValue(newVal) {
        this.dataList = this.getDataList(newVal);
      }
    },
    data() {
      return {
        dataList: [],
        range: [],
        contentText: {
          contentdown: "æŸ¥çœ‹æ›´å¤š",
          contentrefresh: "åŠ è½½ä¸­",
          contentnomore: "æ²¡æœ‰æ›´å¤š"
        },
        isLocal: true,
        styles: {
          selectedColor: "#2979ff",
          selectedTextColor: "#666"
        },
        isTop: 0
      };
    },
    computed: {
      dataValue() {
        if (this.value === "")
          return this.modelValue;
        if (this.modelValue === "")
          return this.value;
        return this.value;
      }
    },
    created() {
      if (this.localdata && this.localdata.length !== 0) {
        this.isLocal = true;
        this.range = this.localdata;
        this.dataList = this.getDataList(this.getSelectedValue(this.range));
      } else {
        if (this.collection) {
          this.isLocal = false;
          this.loadData();
        }
      }
    },
    methods: {
      loadData() {
        this.mixinDatacomGet().then((res) => {
          this.mixinDatacomResData = res.result.data;
          if (this.mixinDatacomResData.length === 0) {
            this.isLocal = false;
            this.mixinDatacomErrorMessage = this.emptyText;
          } else {
            this.isLocal = true;
          }
        }).catch((err) => {
          this.mixinDatacomErrorMessage = err.message;
        });
      },
      /**
       * èŽ·å–çˆ¶å…ƒç´ å®žä¾‹
       */
      getForm(name = "uniForms") {
        let parent = this.$parent;
        let parentName = parent.$options.name;
        while (parentName !== name) {
          parent = parent.$parent;
          if (!parent)
            return false;
          parentName = parent.$options.name;
        }
        return parent;
      },
      change(e2) {
        const values = e2.detail.value;
        let detail = {
          value: [],
          data: []
        };
        if (this.multiple) {
          this.range.forEach((item) => {
            if (values.includes(item[this.map.value] + "")) {
              detail.value.push(item[this.map.value]);
              detail.data.push(item);
            }
          });
        } else {
          const range = this.range.find((item) => item[this.map.value] + "" === values);
          if (range) {
            detail = {
              value: range[this.map.value],
              data: range
            };
          }
        }
        this.$emit("input", detail.value);
        this.$emit("update:modelValue", detail.value);
        this.$emit("change", {
          detail
        });
        if (this.multiple) {
          this.dataList = this.getDataList(detail.value, true);
        } else {
          this.dataList = this.getDataList(detail.value);
        }
      },
      /**
       * èŽ·å–æ¸²æŸ“çš„æ–°æ•°ç»„
       * @param {Object} value é€‰ä¸­å†…å®¹
       */
      getDataList(value) {
        let dataList = JSON.parse(JSON.stringify(this.range));
        let list = [];
        if (this.multiple) {
          if (!Array.isArray(value)) {
            value = [];
          }
        }
        dataList.forEach((item, index) => {
          item.disabled = item.disable || item.disabled || false;
          if (this.multiple) {
            if (value.length > 0) {
              let have = value.find((val) => val === item[this.map.value]);
              item.selected = have !== void 0;
            } else {
              item.selected = false;
            }
          } else {
            item.selected = value === item[this.map.value];
          }
          list.push(item);
        });
        return this.setRange(list);
      },
      /**
       * å¤„ç†æœ€å¤§æœ€å°å€¼
       * @param {Object} list
       */
      setRange(list) {
        let selectList = list.filter((item) => item.selected);
        let min = Number(this.min) || 0;
        let max = Number(this.max) || "";
        list.forEach((item, index) => {
          if (this.multiple) {
            if (selectList.length <= min) {
              let have = selectList.find((val) => val[this.map.value] === item[this.map.value]);
              if (have !== void 0) {
                item.disabled = true;
              }
            }
            if (selectList.length >= max && max !== "") {
              let have = selectList.find((val) => val[this.map.value] === item[this.map.value]);
              if (have === void 0) {
                item.disabled = true;
              }
            }
          }
          this.setStyles(item, index);
          list[index] = item;
        });
        return list;
      },
      /**
       * è®¾ç½® class
       * @param {Object} item
       * @param {Object} index
       */
      setStyles(item, index) {
        item.styleBackgroud = this.setStyleBackgroud(item);
        item.styleIcon = this.setStyleIcon(item);
        item.styleIconText = this.setStyleIconText(item);
        item.styleRightIcon = this.setStyleRightIcon(item);
      },
      /**
       * èŽ·å–é€‰ä¸­å€¼
       * @param {Object} range
       */
      getSelectedValue(range) {
        if (!this.multiple)
          return this.dataValue;
        let selectedArr = [];
        range.forEach((item) => {
          if (item.selected) {
            selectedArr.push(item[this.map.value]);
          }
        });
        return this.dataValue.length > 0 ? this.dataValue : selectedArr;
      },
      /**
       * è®¾ç½®èƒŒæ™¯æ ·å¼
       */
      setStyleBackgroud(item) {
        let styles = {};
        let selectedColor = this.selectedColor ? this.selectedColor : "#2979ff";
        if (this.selectedColor) {
          if (this.mode !== "list") {
            styles["border-color"] = item.selected ? selectedColor : "#DCDFE6";
          }
          if (this.mode === "tag") {
            styles["background-color"] = item.selected ? selectedColor : "#f5f5f5";
          }
        }
        let classles = "";
        for (let i2 in styles) {
          classles += `${i2}:${styles[i2]};`;
        }
        return classles;
      },
      setStyleIcon(item) {
        let styles = {};
        let classles = "";
        if (this.selectedColor) {
          let selectedColor = this.selectedColor ? this.selectedColor : "#2979ff";
          styles["background-color"] = item.selected ? selectedColor : "#fff";
          styles["border-color"] = item.selected ? selectedColor : "#DCDFE6";
          if (!item.selected && item.disabled) {
            styles["background-color"] = "#F2F6FC";
            styles["border-color"] = item.selected ? selectedColor : "#DCDFE6";
          }
        }
        for (let i2 in styles) {
          classles += `${i2}:${styles[i2]};`;
        }
        return classles;
      },
      setStyleIconText(item) {
        let styles = {};
        let classles = "";
        if (this.selectedColor) {
          let selectedColor = this.selectedColor ? this.selectedColor : "#2979ff";
          if (this.mode === "tag") {
            styles.color = item.selected ? this.selectedTextColor ? this.selectedTextColor : "#fff" : "#666";
          } else {
            styles.color = item.selected ? this.selectedTextColor ? this.selectedTextColor : selectedColor : "#666";
          }
          if (!item.selected && item.disabled) {
            styles.color = "#999";
          }
        }
        for (let i2 in styles) {
          classles += `${i2}:${styles[i2]};`;
        }
        return classles;
      },
      setStyleRightIcon(item) {
        let styles = {};
        let classles = "";
        if (this.mode === "list") {
          styles["border-color"] = item.selected ? this.styles.selectedColor : "#DCDFE6";
        }
        for (let i2 in styles) {
          classles += `${i2}:${styles[i2]};`;
        }
        return classles;
      }
    }
  };
  function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_load_more = resolveEasycom(vue.resolveDynamicComponent("uni-load-more"), __easycom_0$6);
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: "uni-data-checklist",
        style: vue.normalizeStyle({ "margin-top": $data.isTop + "px" })
      },
      [
        !$data.isLocal ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "uni-data-loading"
        }, [
          !_ctx.mixinDatacomErrorMessage ? (vue.openBlock(), vue.createBlock(_component_uni_load_more, {
            key: 0,
            status: "loading",
            iconType: "snow",
            iconSize: 18,
            "content-text": $data.contentText
          }, null, 8, ["content-text"])) : (vue.openBlock(), vue.createElementBlock(
            "text",
            { key: 1 },
            vue.toDisplayString(_ctx.mixinDatacomErrorMessage),
            1
            /* TEXT */
          ))
        ])) : (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          { key: 1 },
          [
            $props.multiple ? (vue.openBlock(), vue.createElementBlock(
              "checkbox-group",
              {
                key: 0,
                class: vue.normalizeClass(["checklist-group", { "is-list": $props.mode === "list" || $props.wrap }]),
                onChange: _cache[0] || (_cache[0] = (...args) => $options.change && $options.change(...args))
              },
              [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList($data.dataList, (item, index) => {
                    return vue.openBlock(), vue.createElementBlock(
                      "label",
                      {
                        class: vue.normalizeClass(["checklist-box", ["is--" + $props.mode, item.selected ? "is-checked" : "", $props.disabled || !!item.disabled ? "is-disable" : "", index !== 0 && $props.mode === "list" ? "is-list-border" : ""]]),
                        style: vue.normalizeStyle(item.styleBackgroud),
                        key: index
                      },
                      [
                        vue.createElementVNode("checkbox", {
                          class: "hidden",
                          hidden: "",
                          disabled: $props.disabled || !!item.disabled,
                          value: item[$props.map.value] + "",
                          checked: item.selected
                        }, null, 8, ["disabled", "value", "checked"]),
                        $props.mode !== "tag" && $props.mode !== "list" || $props.mode === "list" && $props.icon === "left" ? (vue.openBlock(), vue.createElementBlock(
                          "view",
                          {
                            key: 0,
                            class: "checkbox__inner",
                            style: vue.normalizeStyle(item.styleIcon)
                          },
                          [
                            vue.createElementVNode("view", { class: "checkbox__inner-icon" })
                          ],
                          4
                          /* STYLE */
                        )) : vue.createCommentVNode("v-if", true),
                        vue.createElementVNode(
                          "view",
                          {
                            class: vue.normalizeClass(["checklist-content", { "list-content": $props.mode === "list" && $props.icon === "left" }])
                          },
                          [
                            vue.createElementVNode(
                              "text",
                              {
                                class: "checklist-text",
                                style: vue.normalizeStyle(item.styleIconText)
                              },
                              vue.toDisplayString(item[$props.map.text]),
                              5
                              /* TEXT, STYLE */
                            ),
                            $props.mode === "list" && $props.icon === "right" ? (vue.openBlock(), vue.createElementBlock(
                              "view",
                              {
                                key: 0,
                                class: "checkobx__list",
                                style: vue.normalizeStyle(item.styleBackgroud)
                              },
                              null,
                              4
                              /* STYLE */
                            )) : vue.createCommentVNode("v-if", true)
                          ],
                          2
                          /* CLASS */
                        )
                      ],
                      6
                      /* CLASS, STYLE */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              34
              /* CLASS, NEED_HYDRATION */
            )) : (vue.openBlock(), vue.createElementBlock(
              "radio-group",
              {
                key: 1,
                class: vue.normalizeClass(["checklist-group", { "is-list": $props.mode === "list", "is-wrap": $props.wrap }]),
                onChange: _cache[1] || (_cache[1] = (...args) => $options.change && $options.change(...args))
              },
              [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList($data.dataList, (item, index) => {
                    return vue.openBlock(), vue.createElementBlock(
                      "label",
                      {
                        class: vue.normalizeClass(["checklist-box", ["is--" + $props.mode, item.selected ? "is-checked" : "", $props.disabled || !!item.disabled ? "is-disable" : "", index !== 0 && $props.mode === "list" ? "is-list-border" : ""]]),
                        style: vue.normalizeStyle(item.styleBackgroud),
                        key: index
                      },
                      [
                        vue.createElementVNode("radio", {
                          class: "hidden",
                          hidden: "",
                          disabled: $props.disabled || item.disabled,
                          value: item[$props.map.value] + "",
                          checked: item.selected
                        }, null, 8, ["disabled", "value", "checked"]),
                        $props.mode !== "tag" && $props.mode !== "list" || $props.mode === "list" && $props.icon === "left" ? (vue.openBlock(), vue.createElementBlock(
                          "view",
                          {
                            key: 0,
                            class: "radio__inner",
                            style: vue.normalizeStyle(item.styleBackgroud)
                          },
                          [
                            vue.createElementVNode(
                              "view",
                              {
                                class: "radio__inner-icon",
                                style: vue.normalizeStyle(item.styleIcon)
                              },
                              null,
                              4
                              /* STYLE */
                            )
                          ],
                          4
                          /* STYLE */
                        )) : vue.createCommentVNode("v-if", true),
                        vue.createElementVNode(
                          "view",
                          {
                            class: vue.normalizeClass(["checklist-content", { "list-content": $props.mode === "list" && $props.icon === "left" }])
                          },
                          [
                            vue.createElementVNode(
                              "text",
                              {
                                class: "checklist-text",
                                style: vue.normalizeStyle(item.styleIconText)
                              },
                              vue.toDisplayString(item[$props.map.text]),
                              5
                              /* TEXT, STYLE */
                            ),
                            $props.mode === "list" && $props.icon === "right" ? (vue.openBlock(), vue.createElementBlock(
                              "view",
                              {
                                key: 0,
                                style: vue.normalizeStyle(item.styleRightIcon),
                                class: "checkobx__list"
                              },
                              null,
                              4
                              /* STYLE */
                            )) : vue.createCommentVNode("v-if", true)
                          ],
                          2
                          /* CLASS */
                        )
                      ],
                      6
                      /* CLASS, STYLE */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              34
              /* CLASS, NEED_HYDRATION */
            ))
          ],
          64
          /* STABLE_FRAGMENT */
        ))
      ],
      4
      /* STYLE */
    );
  }
  const __easycom_5$1 = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$U], ["__scopeId", "data-v-2f788efd"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-data-checkbox/components/uni-data-checkbox/uni-data-checkbox.vue"]]);
  const _sfc_main$U = {
    name: "uniFormsItem",
    options: {
      virtualHost: true
    },
    provide() {
      return {
        uniFormItem: this
      };
    },
    inject: {
      form: {
        from: "uniForm",
        default: null
      }
    },
    props: {
      // è¡¨å•æ ¡éªŒè§„åˆ™
      rules: {
        type: Array,
        default() {
          return null;
        }
      },
      // è¡¨å•åŸŸçš„å±žæ€§åï¼Œåœ¨ä½¿ç”¨æ ¡éªŒè§„åˆ™æ—¶å¿…å¡«
      name: {
        type: [String, Array],
        default: ""
      },
      required: {
        type: Boolean,
        default: false
      },
      label: {
        type: String,
        default: ""
      },
      // labelçš„å®½åº¦
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      // label å±…ä¸­æ–¹å¼ï¼Œé»˜è®¤ left å–å€¼ left/center/right
      labelAlign: {
        type: String,
        default: ""
      },
      // å¼ºåˆ¶æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
      errorMessage: {
        type: [String, Boolean],
        default: ""
      },
      // 1.4.0 å¼ƒç”¨ï¼Œç»Ÿä¸€ä½¿ç”¨ form çš„æ ¡éªŒæ—¶æœº
      // validateTrigger: {
      // 	type: String,
      // 	default: ''
      // },
      // 1.4.0 å¼ƒç”¨ï¼Œç»Ÿä¸€ä½¿ç”¨ form çš„label ä½ç½®
      // labelPosition: {
      // 	type: String,
      // 	default: ''
      // },
      // 1.4.0 ä»¥ä¸‹å±žæ€§å·²ç»åºŸå¼ƒï¼Œè¯·ä½¿ç”¨  #label æ’æ§½ä»£æ›¿
      leftIcon: String,
      iconColor: {
        type: String,
        default: "#606266"
      }
    },
    data() {
      return {
        errMsg: "",
        userRules: null,
        localLabelAlign: "left",
        localLabelWidth: "70px",
        localLabelPos: "left",
        border: false,
        isFirstBorder: false
      };
    },
    computed: {
      // å¤„ç†é”™è¯¯ä¿¡æ¯
      msg() {
        return this.errorMessage || this.errMsg;
      }
    },
    watch: {
      // è§„åˆ™å‘ç”Ÿå˜åŒ–é€šçŸ¥å­ç»„ä»¶æ›´æ–°
      "form.formRules"(val) {
        this.init();
      },
      "form.labelWidth"(val) {
        this.localLabelWidth = this._labelWidthUnit(val);
      },
      "form.labelPosition"(val) {
        this.localLabelPos = this._labelPosition();
      },
      "form.labelAlign"(val) {
      }
    },
    created() {
      this.init(true);
      if (this.name && this.form) {
        this.$watch(
          () => {
            const val = this.form._getDataValue(this.name, this.form.localData);
            return val;
          },
          (value, oldVal) => {
            const isEqual2 = this.form._isEqual(value, oldVal);
            if (!isEqual2) {
              const val = this.itemSetValue(value);
              this.onFieldChange(val, false);
            }
          },
          {
            immediate: false
          }
        );
      }
    },
    unmounted() {
      this.__isUnmounted = true;
      this.unInit();
    },
    methods: {
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * è®¾ç½®è§„åˆ™ ï¼Œä¸»è¦ç”¨äºŽå°ç¨‹åºè‡ªå®šä¹‰æ£€éªŒè§„åˆ™
       * @param {Array} rules è§„åˆ™æºæ•°æ®
       */
      setRules(rules = null) {
        this.userRules = rules;
        this.init(false);
      },
      // å…¼å®¹è€ç‰ˆæœ¬è¡¨å•ç»„ä»¶
      setValue() {
      },
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * æ ¡éªŒæ•°æ®
       * @param {any} value éœ€è¦æ ¡éªŒçš„æ•°æ®
       * @param {boolean} æ˜¯å¦ç«‹å³æ ¡éªŒ
       * @return {Array|null} æ ¡éªŒå†…å®¹
       */
      async onFieldChange(value, formtrigger = true) {
        const {
          formData,
          localData,
          errShowType,
          validateCheck,
          validateTrigger,
          _isRequiredField,
          _realName
        } = this.form;
        const name = _realName(this.name);
        if (!value) {
          value = this.form.formData[name];
        }
        const ruleLen = this.itemRules.rules && this.itemRules.rules.length;
        if (!this.validator || !ruleLen || ruleLen === 0)
          return;
        const isRequiredField2 = _isRequiredField(this.itemRules.rules || []);
        let result = null;
        if (validateTrigger === "bind" || formtrigger) {
          result = await this.validator.validateUpdate(
            {
              [name]: value
            },
            formData
          );
          if (!isRequiredField2 && (value === void 0 || value === "")) {
            result = null;
          }
          if (result && result.errorMessage) {
            if (errShowType === "undertext") {
              this.errMsg = !result ? "" : result.errorMessage;
            }
            if (errShowType === "toast") {
              uni.showToast({
                title: result.errorMessage || "æ ¡éªŒé”™è¯¯",
                icon: "none"
              });
            }
            if (errShowType === "modal") {
              uni.showModal({
                title: "æç¤º",
                content: result.errorMessage || "æ ¡éªŒé”™è¯¯"
              });
            }
          } else {
            this.errMsg = "";
          }
          validateCheck(result ? result : null);
        } else {
          this.errMsg = "";
        }
        return result ? result : null;
      },
      /**
       * åˆå§‹ç»„ä»¶æ•°æ®
       */
      init(type = false) {
        const {
          validator,
          formRules,
          childrens,
          formData,
          localData,
          _realName,
          labelWidth,
          _getDataValue,
          _setDataValue
        } = this.form || {};
        this.localLabelAlign = this._justifyContent();
        this.localLabelWidth = this._labelWidthUnit(labelWidth);
        this.localLabelPos = this._labelPosition();
        this.form && type && childrens.push(this);
        if (!validator || !formRules)
          return;
        if (!this.form.isFirstBorder) {
          this.form.isFirstBorder = true;
          this.isFirstBorder = true;
        }
        if (this.group) {
          if (!this.group.isFirstBorder) {
            this.group.isFirstBorder = true;
            this.isFirstBorder = true;
          }
        }
        this.border = this.form.border;
        const name = _realName(this.name);
        const itemRule = this.userRules || this.rules;
        if (typeof formRules === "object" && itemRule) {
          formRules[name] = {
            rules: itemRule
          };
          validator.updateSchema(formRules);
        }
        const itemRules = formRules[name] || {};
        this.itemRules = itemRules;
        this.validator = validator;
        this.itemSetValue(_getDataValue(this.name, localData));
      },
      unInit() {
        if (this.form) {
          const {
            childrens,
            formData,
            _realName
          } = this.form;
          childrens.forEach((item, index) => {
            if (item === this) {
              this.form.childrens.splice(index, 1);
              delete formData[_realName(item.name)];
            }
          });
        }
      },
      // è®¾ç½®item çš„å€¼
      itemSetValue(value) {
        const name = this.form._realName(this.name);
        const rules = this.itemRules.rules || [];
        const val = this.form._getValue(name, value, rules);
        this.form._setDataValue(name, this.form.formData, val);
        return val;
      },
      /**
       * ç§»é™¤è¯¥è¡¨å•é¡¹çš„æ ¡éªŒç»“æžœ
       */
      clearValidate() {
        this.errMsg = "";
      },
      // æ˜¯å¦æ˜¾ç¤ºæ˜Ÿå·
      _isRequired() {
        return this.required;
      },
      // å¤„ç†å¯¹é½æ–¹å¼
      _justifyContent() {
        if (this.form) {
          const {
            labelAlign
          } = this.form;
          let labelAli = this.labelAlign ? this.labelAlign : labelAlign;
          if (labelAli === "left")
            return "flex-start";
          if (labelAli === "center")
            return "center";
          if (labelAli === "right")
            return "flex-end";
        }
        return "flex-start";
      },
      // å¤„ç† labelå®½åº¦å•ä½ ,ç»§æ‰¿çˆ¶å…ƒç´ çš„å€¼
      _labelWidthUnit(labelWidth) {
        return this.num2px(this.labelWidth ? this.labelWidth : labelWidth || (this.label ? 70 : "auto"));
      },
      // å¤„ç† label ä½ç½®
      _labelPosition() {
        if (this.form)
          return this.form.labelPosition || "left";
        return "left";
      },
      /**
       * è§¦å‘æ—¶æœº
       * @param {Object} rule å½“å‰è§„åˆ™å†…æ—¶æœº
       * @param {Object} itemRlue å½“å‰ç»„ä»¶æ—¶æœº
       * @param {Object} parentRule çˆ¶ç»„ä»¶æ—¶æœº
       */
      isTrigger(rule, itemRlue, parentRule) {
        if (rule === "submit" || !rule) {
          if (rule === void 0) {
            if (itemRlue !== "bind") {
              if (!itemRlue) {
                return parentRule === "" ? "bind" : "submit";
              }
              return "submit";
            }
            return "bind";
          }
          return "submit";
        }
        return "bind";
      },
      num2px(num) {
        if (typeof num === "number") {
          return `${num}px`;
        }
        return num;
      }
    }
  };
  function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["uni-forms-item", ["is-direction-" + $data.localLabelPos, $data.border ? "uni-forms-item--border" : "", $data.border && $data.isFirstBorder ? "is-first-border" : ""]])
      },
      [
        vue.renderSlot(_ctx.$slots, "label", {}, () => [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["uni-forms-item__label", { "no-label": !$props.label && !$props.required }]),
              style: vue.normalizeStyle({ width: $data.localLabelWidth, justifyContent: $data.localLabelAlign })
            },
            [
              $props.required ? (vue.openBlock(), vue.createElementBlock("text", {
                key: 0,
                class: "is-required"
              }, "*")) : vue.createCommentVNode("v-if", true),
              vue.createElementVNode(
                "text",
                null,
                vue.toDisplayString($props.label),
                1
                /* TEXT */
              )
            ],
            6
            /* CLASS, STYLE */
          )
        ], true),
        vue.createElementVNode("view", { class: "uni-forms-item__content" }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true),
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["uni-forms-item__error", { "msg--active": $options.msg }])
            },
            [
              vue.createElementVNode(
                "text",
                null,
                vue.toDisplayString($options.msg),
                1
                /* TEXT */
              )
            ],
            2
            /* CLASS */
          )
        ])
      ],
      2
      /* CLASS */
    );
  }
  const __easycom_6$1 = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$T], ["__scopeId", "data-v-462874dd"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-forms/components/uni-forms-item/uni-forms-item.vue"]]);
  function obj2strClass(obj) {
    let classess = "";
    for (let key in obj) {
      const val = obj[key];
      if (val) {
        classess += `${key} `;
      }
    }
    return classess;
  }
  function obj2strStyle(obj) {
    let style = "";
    for (let key in obj) {
      const val = obj[key];
      style += `${key}:${val};`;
    }
    return style;
  }
  const _sfc_main$T = {
    name: "uni-easyinput",
    emits: [
      "click",
      "iconClick",
      "update:modelValue",
      "input",
      "focus",
      "blur",
      "confirm",
      "clear",
      "eyes",
      "change",
      "keyboardheightchange"
    ],
    model: {
      prop: "modelValue",
      event: "update:modelValue"
    },
    options: {
      virtualHost: true
    },
    inject: {
      form: {
        from: "uniForm",
        default: null
      },
      formItem: {
        from: "uniFormItem",
        default: null
      }
    },
    props: {
      name: String,
      value: [Number, String],
      modelValue: [Number, String],
      type: {
        type: String,
        default: "text"
      },
      clearable: {
        type: Boolean,
        default: true
      },
      autoHeight: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: " "
      },
      placeholderStyle: String,
      focus: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      maxlength: {
        type: [Number, String],
        default: 140
      },
      confirmType: {
        type: String,
        default: "done"
      },
      clearSize: {
        type: [Number, String],
        default: 24
      },
      inputBorder: {
        type: Boolean,
        default: true
      },
      prefixIcon: {
        type: String,
        default: ""
      },
      suffixIcon: {
        type: String,
        default: ""
      },
      trim: {
        type: [Boolean, String],
        default: false
      },
      cursorSpacing: {
        type: Number,
        default: 0
      },
      passwordIcon: {
        type: Boolean,
        default: true
      },
      adjustPosition: {
        type: Boolean,
        default: true
      },
      primaryColor: {
        type: String,
        default: "#2979ff"
      },
      styles: {
        type: Object,
        default() {
          return {
            color: "#333",
            backgroundColor: "#fff",
            disableColor: "#F7F6F6",
            borderColor: "#e5e5e5"
          };
        }
      },
      errorMessage: {
        type: [String, Boolean],
        default: ""
      }
    },
    data() {
      return {
        focused: false,
        val: "",
        showMsg: "",
        border: false,
        isFirstBorder: false,
        showClearIcon: false,
        showPassword: false,
        focusShow: false,
        localMsg: "",
        isEnter: false
        // ç”¨äºŽåˆ¤æ–­å½“å‰æ˜¯å¦æ˜¯ä½¿ç”¨å›žè½¦æ“ä½œ
      };
    },
    computed: {
      // è¾“å…¥æ¡†å†…æ˜¯å¦æœ‰å€¼
      isVal() {
        const val = this.val;
        if (val || val === 0) {
          return true;
        }
        return false;
      },
      msg() {
        return this.localMsg || this.errorMessage;
      },
      // å› ä¸ºuniappçš„inputç»„ä»¶çš„maxlengthç»„ä»¶å¿…é¡»è¦æ•°å€¼ï¼Œè¿™é‡Œè½¬ä¸ºæ•°å€¼ï¼Œç”¨æˆ·å¯ä»¥ä¼ å…¥å­—ç¬¦ä¸²æ•°å€¼
      inputMaxlength() {
        return Number(this.maxlength);
      },
      // å¤„ç†å¤–å±‚æ ·å¼çš„style
      boxStyle() {
        return `color:${this.inputBorder && this.msg ? "#e43d33" : this.styles.color};`;
      },
      // input å†…å®¹çš„ç±»å’Œæ ·å¼å¤„ç†
      inputContentClass() {
        return obj2strClass({
          "is-input-border": this.inputBorder,
          "is-input-error-border": this.inputBorder && this.msg,
          "is-textarea": this.type === "textarea",
          "is-disabled": this.disabled,
          "is-focused": this.focusShow
        });
      },
      inputContentStyle() {
        const focusColor = this.focusShow ? this.primaryColor : this.styles.borderColor;
        const borderColor = this.inputBorder && this.msg ? "#dd524d" : focusColor;
        return obj2strStyle({
          "border-color": borderColor || "#e5e5e5",
          "background-color": this.disabled ? this.styles.disableColor : this.styles.backgroundColor
        });
      },
      // inputå³ä¾§æ ·å¼
      inputStyle() {
        const paddingRight = this.type === "password" || this.clearable || this.prefixIcon ? "" : "10px";
        return obj2strStyle({
          "padding-right": paddingRight,
          "padding-left": this.prefixIcon ? "" : "10px"
        });
      }
    },
    watch: {
      value(newVal) {
        this.val = newVal;
      },
      modelValue(newVal) {
        this.val = newVal;
      },
      focus(newVal) {
        this.$nextTick(() => {
          this.focused = this.focus;
          this.focusShow = this.focus;
        });
      }
    },
    created() {
      this.init();
      if (this.form && this.formItem) {
        this.$watch("formItem.errMsg", (newVal) => {
          this.localMsg = newVal;
        });
      }
    },
    mounted() {
      this.$nextTick(() => {
        this.focused = this.focus;
        this.focusShow = this.focus;
      });
    },
    methods: {
      /**
       * åˆå§‹åŒ–å˜é‡å€¼
       */
      init() {
        if (this.value || this.value === 0) {
          this.val = this.value;
        } else if (this.modelValue || this.modelValue === 0 || this.modelValue === "") {
          this.val = this.modelValue;
        } else {
          this.val = null;
        }
      },
      /**
       * ç‚¹å‡»å›¾æ ‡æ—¶è§¦å‘
       * @param {Object} type
       */
      onClickIcon(type) {
        this.$emit("iconClick", type);
      },
      /**
       * æ˜¾ç¤ºéšè—å†…å®¹ï¼Œå¯†ç æ¡†æ—¶ç”Ÿæ•ˆ
       */
      onEyes() {
        this.showPassword = !this.showPassword;
        this.$emit("eyes", this.showPassword);
      },
      /**
       * è¾“å…¥æ—¶è§¦å‘
       * @param {Object} event
       */
      onInput(event) {
        let value = event.detail.value;
        if (this.trim) {
          if (typeof this.trim === "boolean" && this.trim) {
            value = this.trimStr(value);
          }
          if (typeof this.trim === "string") {
            value = this.trimStr(value, this.trim);
          }
        }
        if (this.errMsg)
          this.errMsg = "";
        this.val = value;
        this.$emit("input", value);
        this.$emit("update:modelValue", value);
      },
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * èŽ·å–ç„¦ç‚¹æ—¶è§¦å‘
       * @param {Object} event
       */
      onFocus() {
        this.$nextTick(() => {
          this.focused = true;
        });
        this.$emit("focus", null);
      },
      _Focus(event) {
        this.focusShow = true;
        this.$emit("focus", event);
      },
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * å¤±åŽ»ç„¦ç‚¹æ—¶è§¦å‘
       * @param {Object} event
       */
      onBlur() {
        this.focused = false;
        this.$emit("blur", null);
      },
      _Blur(event) {
        event.detail.value;
        this.focusShow = false;
        this.$emit("blur", event);
        if (this.isEnter === false) {
          this.$emit("change", this.val);
        }
        if (this.form && this.formItem) {
          const { validateTrigger } = this.form;
          if (validateTrigger === "blur") {
            this.formItem.onFieldChange();
          }
        }
      },
      /**
       * æŒ‰ä¸‹é”®ç›˜çš„å‘é€é”®
       * @param {Object} e
       */
      onConfirm(e2) {
        this.$emit("confirm", this.val);
        this.isEnter = true;
        this.$emit("change", this.val);
        this.$nextTick(() => {
          this.isEnter = false;
        });
      },
      /**
       * æ¸…ç†å†…å®¹
       * @param {Object} event
       */
      onClear(event) {
        this.val = "";
        this.$emit("input", "");
        this.$emit("update:modelValue", "");
        this.$emit("clear");
      },
      /**
       * é”®ç›˜é«˜åº¦å‘ç”Ÿå˜åŒ–çš„æ—¶å€™è§¦å‘æ­¤äº‹ä»¶
       * å…¼å®¹æ€§ï¼šå¾®ä¿¡å°ç¨‹åº2.7.0+ã€App 3.1.0+
       * @param {Object} event
       */
      onkeyboardheightchange(event) {
        this.$emit("keyboardheightchange", event);
      },
      /**
       * åŽ»é™¤ç©ºæ ¼
       */
      trimStr(str, pos = "both") {
        if (pos === "both") {
          return str.trim();
        } else if (pos === "left") {
          return str.trimLeft();
        } else if (pos === "right") {
          return str.trimRight();
        } else if (pos === "start") {
          return str.trimStart();
        } else if (pos === "end") {
          return str.trimEnd();
        } else if (pos === "all") {
          return str.replace(/\s+/g, "");
        } else if (pos === "none") {
          return str;
        }
        return str;
      }
    }
  };
  function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["uni-easyinput", { "uni-easyinput-error": $options.msg }]),
        style: vue.normalizeStyle($options.boxStyle)
      },
      [
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["uni-easyinput__content", $options.inputContentClass]),
            style: vue.normalizeStyle($options.inputContentStyle)
          },
          [
            $props.prefixIcon ? (vue.openBlock(), vue.createBlock(_component_uni_icons, {
              key: 0,
              class: "content-clear-icon",
              type: $props.prefixIcon,
              color: "#c0c4cc",
              onClick: _cache[0] || (_cache[0] = ($event) => $options.onClickIcon("prefix")),
              size: "22"
            }, null, 8, ["type"])) : vue.createCommentVNode("v-if", true),
            vue.renderSlot(_ctx.$slots, "left", {}, void 0, true),
            $props.type === "textarea" ? (vue.openBlock(), vue.createElementBlock("textarea", {
              key: 1,
              class: vue.normalizeClass(["uni-easyinput__content-textarea", { "input-padding": $props.inputBorder }]),
              name: $props.name,
              value: $data.val,
              placeholder: $props.placeholder,
              placeholderStyle: $props.placeholderStyle,
              disabled: $props.disabled,
              "placeholder-class": "uni-easyinput__placeholder-class",
              maxlength: $options.inputMaxlength,
              focus: $data.focused,
              autoHeight: $props.autoHeight,
              "cursor-spacing": $props.cursorSpacing,
              "adjust-position": $props.adjustPosition,
              onInput: _cache[1] || (_cache[1] = (...args) => $options.onInput && $options.onInput(...args)),
              onBlur: _cache[2] || (_cache[2] = (...args) => $options._Blur && $options._Blur(...args)),
              onFocus: _cache[3] || (_cache[3] = (...args) => $options._Focus && $options._Focus(...args)),
              onConfirm: _cache[4] || (_cache[4] = (...args) => $options.onConfirm && $options.onConfirm(...args)),
              onKeyboardheightchange: _cache[5] || (_cache[5] = (...args) => $options.onkeyboardheightchange && $options.onkeyboardheightchange(...args))
            }, null, 42, ["name", "value", "placeholder", "placeholderStyle", "disabled", "maxlength", "focus", "autoHeight", "cursor-spacing", "adjust-position"])) : (vue.openBlock(), vue.createElementBlock("input", {
              key: 2,
              type: $props.type === "password" ? "text" : $props.type,
              class: "uni-easyinput__content-input",
              style: vue.normalizeStyle($options.inputStyle),
              name: $props.name,
              value: $data.val,
              password: !$data.showPassword && $props.type === "password",
              placeholder: $props.placeholder,
              placeholderStyle: $props.placeholderStyle,
              "placeholder-class": "uni-easyinput__placeholder-class",
              disabled: $props.disabled,
              maxlength: $options.inputMaxlength,
              focus: $data.focused,
              confirmType: $props.confirmType,
              "cursor-spacing": $props.cursorSpacing,
              "adjust-position": $props.adjustPosition,
              onFocus: _cache[6] || (_cache[6] = (...args) => $options._Focus && $options._Focus(...args)),
              onBlur: _cache[7] || (_cache[7] = (...args) => $options._Blur && $options._Blur(...args)),
              onInput: _cache[8] || (_cache[8] = (...args) => $options.onInput && $options.onInput(...args)),
              onConfirm: _cache[9] || (_cache[9] = (...args) => $options.onConfirm && $options.onConfirm(...args)),
              onKeyboardheightchange: _cache[10] || (_cache[10] = (...args) => $options.onkeyboardheightchange && $options.onkeyboardheightchange(...args))
            }, null, 44, ["type", "name", "value", "password", "placeholder", "placeholderStyle", "disabled", "maxlength", "focus", "confirmType", "cursor-spacing", "adjust-position"])),
            $props.type === "password" && $props.passwordIcon ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 3 },
              [
                vue.createCommentVNode(" å¼€å¯å¯†ç æ—¶æ˜¾ç¤ºå°çœ¼ç› "),
                $options.isVal ? (vue.openBlock(), vue.createBlock(_component_uni_icons, {
                  key: 0,
                  class: vue.normalizeClass(["content-clear-icon", { "is-textarea-icon": $props.type === "textarea" }]),
                  type: $data.showPassword ? "eye-slash-filled" : "eye-filled",
                  size: 22,
                  color: $data.focusShow ? $props.primaryColor : "#c0c4cc",
                  onClick: $options.onEyes
                }, null, 8, ["class", "type", "color", "onClick"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : vue.createCommentVNode("v-if", true),
            $props.suffixIcon ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 4 },
              [
                $props.suffixIcon ? (vue.openBlock(), vue.createBlock(_component_uni_icons, {
                  key: 0,
                  class: "content-clear-icon",
                  type: $props.suffixIcon,
                  color: "#c0c4cc",
                  onClick: _cache[11] || (_cache[11] = ($event) => $options.onClickIcon("suffix")),
                  size: "22"
                }, null, 8, ["type"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 5 },
              [
                $props.clearable && $options.isVal && !$props.disabled && $props.type !== "textarea" ? (vue.openBlock(), vue.createBlock(_component_uni_icons, {
                  key: 0,
                  class: vue.normalizeClass(["content-clear-icon", { "is-textarea-icon": $props.type === "textarea" }]),
                  type: "clear",
                  size: $props.clearSize,
                  color: $options.msg ? "#dd524d" : $data.focusShow ? $props.primaryColor : "#c0c4cc",
                  onClick: $options.onClear
                }, null, 8, ["class", "size", "color", "onClick"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )),
            vue.renderSlot(_ctx.$slots, "right", {}, void 0, true)
          ],
          6
          /* CLASS, STYLE */
        )
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const __easycom_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$S], ["__scopeId", "data-v-09fd5285"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-easyinput/components/uni-easyinput/uni-easyinput.vue"]]);
  var pattern = {
    email: /^\S+?@\S+?\.\S+?$/,
    idcard: /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/,
    url: new RegExp(
      "^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$",
      "i"
    )
  };
  const FORMAT_MAPPING = {
    "int": "integer",
    "bool": "boolean",
    "double": "number",
    "long": "number",
    "password": "string"
    // "fileurls": 'array'
  };
  function formatMessage(args, resources = "") {
    var defaultMessage = ["label"];
    defaultMessage.forEach((item) => {
      if (args[item] === void 0) {
        args[item] = "";
      }
    });
    let str = resources;
    for (let key in args) {
      let reg = new RegExp("{" + key + "}");
      str = str.replace(reg, args[key]);
    }
    return str;
  }
  function isEmptyValue(value, type) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (typeof value === "string" && !value) {
      return true;
    }
    if (Array.isArray(value) && !value.length) {
      return true;
    }
    if (type === "object" && !Object.keys(value).length) {
      return true;
    }
    return false;
  }
  const types = {
    integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    string(value) {
      return typeof value === "string";
    },
    number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    "boolean": function(value) {
      return typeof value === "boolean";
    },
    "float": function(value) {
      return types.number(value) && !types.integer(value);
    },
    array(value) {
      return Array.isArray(value);
    },
    object(value) {
      return typeof value === "object" && !types.array(value);
    },
    date(value) {
      return value instanceof Date;
    },
    timestamp(value) {
      if (!this.integer(value) || Math.abs(value).toString().length > 16) {
        return false;
      }
      return true;
    },
    file(value) {
      return typeof value.url === "string";
    },
    email(value) {
      return typeof value === "string" && !!value.match(pattern.email) && value.length < 255;
    },
    url(value) {
      return typeof value === "string" && !!value.match(pattern.url);
    },
    pattern(reg, value) {
      try {
        return new RegExp(reg).test(value);
      } catch (e2) {
        return false;
      }
    },
    method(value) {
      return typeof value === "function";
    },
    idcard(value) {
      return typeof value === "string" && !!value.match(pattern.idcard);
    },
    "url-https"(value) {
      return this.url(value) && value.startsWith("https://");
    },
    "url-scheme"(value) {
      return value.startsWith("://");
    },
    "url-web"(value) {
      return false;
    }
  };
  class RuleValidator {
    constructor(message) {
      this._message = message;
    }
    async validateRule(fieldKey, fieldValue, value, data, allData) {
      var result = null;
      let rules = fieldValue.rules;
      let hasRequired = rules.findIndex((item) => {
        return item.required;
      });
      if (hasRequired < 0) {
        if (value === null || value === void 0) {
          return result;
        }
        if (typeof value === "string" && !value.length) {
          return result;
        }
      }
      var message = this._message;
      if (rules === void 0) {
        return message["default"];
      }
      for (var i2 = 0; i2 < rules.length; i2++) {
        let rule = rules[i2];
        let vt2 = this._getValidateType(rule);
        Object.assign(rule, {
          label: fieldValue.label || `["${fieldKey}"]`
        });
        if (RuleValidatorHelper[vt2]) {
          result = RuleValidatorHelper[vt2](rule, value, message);
          if (result != null) {
            break;
          }
        }
        if (rule.validateExpr) {
          let now2 = Date.now();
          let resultExpr = rule.validateExpr(value, allData, now2);
          if (resultExpr === false) {
            result = this._getMessage(rule, rule.errorMessage || this._message["default"]);
            break;
          }
        }
        if (rule.validateFunction) {
          result = await this.validateFunction(rule, value, data, allData, vt2);
          if (result !== null) {
            break;
          }
        }
      }
      if (result !== null) {
        result = message.TAG + result;
      }
      return result;
    }
    async validateFunction(rule, value, data, allData, vt2) {
      let result = null;
      try {
        let callbackMessage = null;
        const res = await rule.validateFunction(rule, value, allData || data, (message) => {
          callbackMessage = message;
        });
        if (callbackMessage || typeof res === "string" && res || res === false) {
          result = this._getMessage(rule, callbackMessage || res, vt2);
        }
      } catch (e2) {
        result = this._getMessage(rule, e2.message, vt2);
      }
      return result;
    }
    _getMessage(rule, message, vt2) {
      return formatMessage(rule, message || rule.errorMessage || this._message[vt2] || message["default"]);
    }
    _getValidateType(rule) {
      var result = "";
      if (rule.required) {
        result = "required";
      } else if (rule.format) {
        result = "format";
      } else if (rule.arrayType) {
        result = "arrayTypeFormat";
      } else if (rule.range) {
        result = "range";
      } else if (rule.maximum !== void 0 || rule.minimum !== void 0) {
        result = "rangeNumber";
      } else if (rule.maxLength !== void 0 || rule.minLength !== void 0) {
        result = "rangeLength";
      } else if (rule.pattern) {
        result = "pattern";
      } else if (rule.validateFunction) {
        result = "validateFunction";
      }
      return result;
    }
  }
  const RuleValidatorHelper = {
    required(rule, value, message) {
      if (rule.required && isEmptyValue(value, rule.format || typeof value)) {
        return formatMessage(rule, rule.errorMessage || message.required);
      }
      return null;
    },
    range(rule, value, message) {
      const {
        range,
        errorMessage
      } = rule;
      let list = new Array(range.length);
      for (let i2 = 0; i2 < range.length; i2++) {
        const item = range[i2];
        if (types.object(item) && item.value !== void 0) {
          list[i2] = item.value;
        } else {
          list[i2] = item;
        }
      }
      let result = false;
      if (Array.isArray(value)) {
        result = new Set(value.concat(list)).size === list.length;
      } else {
        if (list.indexOf(value) > -1) {
          result = true;
        }
      }
      if (!result) {
        return formatMessage(rule, errorMessage || message["enum"]);
      }
      return null;
    },
    rangeNumber(rule, value, message) {
      if (!types.number(value)) {
        return formatMessage(rule, rule.errorMessage || message.pattern.mismatch);
      }
      let {
        minimum,
        maximum,
        exclusiveMinimum,
        exclusiveMaximum
      } = rule;
      let min = exclusiveMinimum ? value <= minimum : value < minimum;
      let max = exclusiveMaximum ? value >= maximum : value > maximum;
      if (minimum !== void 0 && min) {
        return formatMessage(rule, rule.errorMessage || message["number"][exclusiveMinimum ? "exclusiveMinimum" : "minimum"]);
      } else if (maximum !== void 0 && max) {
        return formatMessage(rule, rule.errorMessage || message["number"][exclusiveMaximum ? "exclusiveMaximum" : "maximum"]);
      } else if (minimum !== void 0 && maximum !== void 0 && (min || max)) {
        return formatMessage(rule, rule.errorMessage || message["number"].range);
      }
      return null;
    },
    rangeLength(rule, value, message) {
      if (!types.string(value) && !types.array(value)) {
        return formatMessage(rule, rule.errorMessage || message.pattern.mismatch);
      }
      let min = rule.minLength;
      let max = rule.maxLength;
      let val = value.length;
      if (min !== void 0 && val < min) {
        return formatMessage(rule, rule.errorMessage || message["length"].minLength);
      } else if (max !== void 0 && val > max) {
        return formatMessage(rule, rule.errorMessage || message["length"].maxLength);
      } else if (min !== void 0 && max !== void 0 && (val < min || val > max)) {
        return formatMessage(rule, rule.errorMessage || message["length"].range);
      }
      return null;
    },
    pattern(rule, value, message) {
      if (!types["pattern"](rule.pattern, value)) {
        return formatMessage(rule, rule.errorMessage || message.pattern.mismatch);
      }
      return null;
    },
    format(rule, value, message) {
      var customTypes = Object.keys(types);
      var format = FORMAT_MAPPING[rule.format] ? FORMAT_MAPPING[rule.format] : rule.format || rule.arrayType;
      if (customTypes.indexOf(format) > -1) {
        if (!types[format](value)) {
          return formatMessage(rule, rule.errorMessage || message.typeError);
        }
      }
      return null;
    },
    arrayTypeFormat(rule, value, message) {
      if (!Array.isArray(value)) {
        return formatMessage(rule, rule.errorMessage || message.typeError);
      }
      for (let i2 = 0; i2 < value.length; i2++) {
        const element = value[i2];
        let formatResult = this.format(rule, element, message);
        if (formatResult !== null) {
          return formatResult;
        }
      }
      return null;
    }
  };
  class SchemaValidator extends RuleValidator {
    constructor(schema, options) {
      super(SchemaValidator.message);
      this._schema = schema;
      this._options = options || null;
    }
    updateSchema(schema) {
      this._schema = schema;
    }
    async validate(data, allData) {
      let result = this._checkFieldInSchema(data);
      if (!result) {
        result = await this.invokeValidate(data, false, allData);
      }
      return result.length ? result[0] : null;
    }
    async validateAll(data, allData) {
      let result = this._checkFieldInSchema(data);
      if (!result) {
        result = await this.invokeValidate(data, true, allData);
      }
      return result;
    }
    async validateUpdate(data, allData) {
      let result = this._checkFieldInSchema(data);
      if (!result) {
        result = await this.invokeValidateUpdate(data, false, allData);
      }
      return result.length ? result[0] : null;
    }
    async invokeValidate(data, all, allData) {
      let result = [];
      let schema = this._schema;
      for (let key in schema) {
        let value = schema[key];
        let errorMessage = await this.validateRule(key, value, data[key], data, allData);
        if (errorMessage != null) {
          result.push({
            key,
            errorMessage
          });
          if (!all)
            break;
        }
      }
      return result;
    }
    async invokeValidateUpdate(data, all, allData) {
      let result = [];
      for (let key in data) {
        let errorMessage = await this.validateRule(key, this._schema[key], data[key], data, allData);
        if (errorMessage != null) {
          result.push({
            key,
            errorMessage
          });
          if (!all)
            break;
        }
      }
      return result;
    }
    _checkFieldInSchema(data) {
      var keys = Object.keys(data);
      var keys2 = Object.keys(this._schema);
      if (new Set(keys.concat(keys2)).size === keys2.length) {
        return "";
      }
      var noExistFields = keys.filter((key) => {
        return keys2.indexOf(key) < 0;
      });
      var errorMessage = formatMessage({
        field: JSON.stringify(noExistFields)
      }, SchemaValidator.message.TAG + SchemaValidator.message["defaultInvalid"]);
      return [{
        key: "invalid",
        errorMessage
      }];
    }
  }
  function Message$1() {
    return {
      TAG: "",
      default: "éªŒè¯é”™è¯¯",
      defaultInvalid: "æäº¤çš„å­—æ®µ{field}åœ¨æ•°æ®åº“ä¸­å¹¶ä¸å­˜åœ¨",
      validateFunction: "éªŒè¯æ— æ•ˆ",
      required: "{label}å¿…å¡«",
      "enum": "{label}è¶…å‡ºèŒƒå›´",
      timestamp: "{label}æ ¼å¼æ— æ•ˆ",
      whitespace: "{label}ä¸èƒ½ä¸ºç©º",
      typeError: "{label}ç±»åž‹æ— æ•ˆ",
      date: {
        format: "{label}æ—¥æœŸ{value}æ ¼å¼æ— æ•ˆ",
        parse: "{label}æ—¥æœŸæ— æ³•è§£æž,{value}æ— æ•ˆ",
        invalid: "{label}æ—¥æœŸ{value}æ— æ•ˆ"
      },
      length: {
        minLength: "{label}é•¿åº¦ä¸èƒ½å°‘äºŽ{minLength}",
        maxLength: "{label}é•¿åº¦ä¸èƒ½è¶…è¿‡{maxLength}",
        range: "{label}å¿…é¡»ä»‹äºŽ{minLength}å’Œ{maxLength}ä¹‹é—´"
      },
      number: {
        minimum: "{label}ä¸èƒ½å°äºŽ{minimum}",
        maximum: "{label}ä¸èƒ½å¤§äºŽ{maximum}",
        exclusiveMinimum: "{label}ä¸èƒ½å°äºŽç­‰äºŽ{minimum}",
        exclusiveMaximum: "{label}ä¸èƒ½å¤§äºŽç­‰äºŽ{maximum}",
        range: "{label}å¿…é¡»ä»‹äºŽ{minimum}and{maximum}ä¹‹é—´"
      },
      pattern: {
        mismatch: "{label}æ ¼å¼ä¸åŒ¹é…"
      }
    };
  }
  SchemaValidator.message = new Message$1();
  const deepCopy = (val) => {
    return JSON.parse(JSON.stringify(val));
  };
  const typeFilter = (format) => {
    return format === "int" || format === "double" || format === "number" || format === "timestamp";
  };
  const getValue = (key, value, rules) => {
    const isRuleNumType = rules.find((val) => val.format && typeFilter(val.format));
    const isRuleBoolType = rules.find((val) => val.format && val.format === "boolean" || val.format === "bool");
    if (!!isRuleNumType) {
      if (!value && value !== 0) {
        value = null;
      } else {
        value = isNumber(Number(value)) ? Number(value) : value;
      }
    }
    if (!!isRuleBoolType) {
      value = isBoolean(value) ? value : false;
    }
    return value;
  };
  const setDataValue = (field, formdata, value) => {
    formdata[field] = value;
    return value || "";
  };
  const getDataValue = (field, data) => {
    return objGet(data, field);
  };
  const realName = (name, data = {}) => {
    const base_name = _basePath(name);
    if (typeof base_name === "object" && Array.isArray(base_name) && base_name.length > 1) {
      const realname = base_name.reduce((a2, b2) => a2 += `#${b2}`, "_formdata_");
      return realname;
    }
    return base_name[0] || name;
  };
  const isRealName = (name) => {
    const reg = /^_formdata_#*/;
    return reg.test(name);
  };
  const rawData = (object = {}, name) => {
    let newData = JSON.parse(JSON.stringify(object));
    let formData = {};
    for (let i2 in newData) {
      let path = name2arr(i2);
      objSet(formData, path, newData[i2]);
    }
    return formData;
  };
  const name2arr = (name) => {
    let field = name.replace("_formdata_#", "");
    field = field.split("#").map((v2) => isNumber(v2) ? Number(v2) : v2);
    return field;
  };
  const objSet = (object, path, value) => {
    if (typeof object !== "object")
      return object;
    _basePath(path).reduce((o2, k, i2, _2) => {
      if (i2 === _2.length - 1) {
        o2[k] = value;
        return null;
      } else if (k in o2) {
        return o2[k];
      } else {
        o2[k] = /^[0-9]{1,}$/.test(_2[i2 + 1]) ? [] : {};
        return o2[k];
      }
    }, object);
    return object;
  };
  function _basePath(path) {
    if (Array.isArray(path))
      return path;
    return path.replace(/\[/g, ".").replace(/\]/g, "").split(".");
  }
  const objGet = (object, path, defaultVal = "undefined") => {
    let newPath = _basePath(path);
    let val = newPath.reduce((o2, k) => {
      return (o2 || {})[k];
    }, object);
    return !val || val !== void 0 ? val : defaultVal;
  };
  const isNumber = (num) => {
    return !isNaN(Number(num));
  };
  const isBoolean = (bool) => {
    return typeof bool === "boolean";
  };
  const isRequiredField = (rules) => {
    let isNoField = false;
    for (let i2 = 0; i2 < rules.length; i2++) {
      const ruleData = rules[i2];
      if (ruleData.required) {
        isNoField = true;
        break;
      }
    }
    return isNoField;
  };
  const isEqual = (a2, b2) => {
    if (a2 === b2) {
      return a2 !== 0 || 1 / a2 === 1 / b2;
    }
    if (a2 == null || b2 == null) {
      return a2 === b2;
    }
    var classNameA = toString.call(a2), classNameB = toString.call(b2);
    if (classNameA !== classNameB) {
      return false;
    }
    switch (classNameA) {
      case "[object RegExp]":
      case "[object String]":
        return "" + a2 === "" + b2;
      case "[object Number]":
        if (+a2 !== +a2) {
          return +b2 !== +b2;
        }
        return +a2 === 0 ? 1 / +a2 === 1 / b2 : +a2 === +b2;
      case "[object Date]":
      case "[object Boolean]":
        return +a2 === +b2;
    }
    if (classNameA == "[object Object]") {
      var propsA = Object.getOwnPropertyNames(a2), propsB = Object.getOwnPropertyNames(b2);
      if (propsA.length != propsB.length) {
        return false;
      }
      for (var i2 = 0; i2 < propsA.length; i2++) {
        var propName = propsA[i2];
        if (a2[propName] !== b2[propName]) {
          return false;
        }
      }
      return true;
    }
    if (classNameA == "[object Array]") {
      if (a2.toString() == b2.toString()) {
        return true;
      }
      return false;
    }
  };
  const _sfc_main$S = {
    name: "uniForms",
    emits: ["validate", "submit"],
    options: {
      virtualHost: true
    },
    props: {
      // å³å°†å¼ƒç”¨
      value: {
        type: Object,
        default() {
          return null;
        }
      },
      // vue3 æ›¿æ¢ value å±žæ€§
      modelValue: {
        type: Object,
        default() {
          return null;
        }
      },
      // 1.4.0 å¼€å§‹å°†ä¸æ”¯æŒ v-model ï¼Œä¸”åºŸå¼ƒ value å’Œ modelValue
      model: {
        type: Object,
        default() {
          return null;
        }
      },
      // è¡¨å•æ ¡éªŒè§„åˆ™
      rules: {
        type: Object,
        default() {
          return {};
        }
      },
      //æ ¡éªŒé”™è¯¯ä¿¡æ¯æç¤ºæ–¹å¼ é»˜è®¤ undertext å–å€¼ [undertext|toast|modal]
      errShowType: {
        type: String,
        default: "undertext"
      },
      // æ ¡éªŒè§¦å‘å™¨æ–¹å¼ é»˜è®¤ bind å–å€¼ [bind|submit]
      validateTrigger: {
        type: String,
        default: "submit"
      },
      // label ä½ç½®ï¼Œé»˜è®¤ left å–å€¼  top/left
      labelPosition: {
        type: String,
        default: "left"
      },
      // label å®½åº¦
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      // label å±…ä¸­æ–¹å¼ï¼Œé»˜è®¤ left å–å€¼ left/center/right
      labelAlign: {
        type: String,
        default: "left"
      },
      border: {
        type: Boolean,
        default: false
      }
    },
    provide() {
      return {
        uniForm: this
      };
    },
    data() {
      return {
        // è¡¨å•æœ¬åœ°å€¼çš„è®°å½•ï¼Œä¸åº”è¯¥ä¸Žä¼ å¦‚çš„å€¼è¿›è¡Œå…³è”
        formData: {},
        formRules: {}
      };
    },
    computed: {
      // è®¡ç®—æ•°æ®æºå˜åŒ–çš„
      localData() {
        const localVal = this.model || this.modelValue || this.value;
        if (localVal) {
          return deepCopy(localVal);
        }
        return {};
      }
    },
    watch: {
      // ç›‘å¬æ•°æ®å˜åŒ– ,æš‚æ—¶ä¸ä½¿ç”¨ï¼Œéœ€è¦å•ç‹¬èµ‹å€¼
      // localData: {},
      // ç›‘å¬è§„åˆ™å˜åŒ–
      rules: {
        handler: function(val, oldVal) {
          this.setRules(val);
        },
        deep: true,
        immediate: true
      }
    },
    created() {
      let getbinddata = getApp().$vm.$.appContext.config.globalProperties.binddata;
      if (!getbinddata) {
        getApp().$vm.$.appContext.config.globalProperties.binddata = function(name, value, formName) {
          if (formName) {
            this.$refs[formName].setValue(name, value);
          } else {
            let formVm;
            for (let i2 in this.$refs) {
              const vm = this.$refs[i2];
              if (vm && vm.$options && vm.$options.name === "uniForms") {
                formVm = vm;
                break;
              }
            }
            if (!formVm)
              return formatAppLog("error", "at uni_modules/uni-forms/components/uni-forms/uni-forms.vue:182", "å½“å‰ uni-froms ç»„ä»¶ç¼ºå°‘ ref å±žæ€§");
            formVm.setValue(name, value);
          }
        };
      }
      this.childrens = [];
      this.inputChildrens = [];
      this.setRules(this.rules);
    },
    methods: {
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * è®¾ç½®è§„åˆ™ ï¼Œä¸»è¦ç”¨äºŽå°ç¨‹åºè‡ªå®šä¹‰æ£€éªŒè§„åˆ™
       * @param {Array} rules è§„åˆ™æºæ•°æ®
       */
      setRules(rules) {
        this.formRules = Object.assign({}, this.formRules, rules);
        this.validator = new SchemaValidator(rules);
      },
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * è®¾ç½®æ•°æ®ï¼Œç”¨äºŽè®¾ç½®è¡¨å•æ•°æ®ï¼Œå…¬å¼€ç»™ç”¨æˆ·ä½¿ç”¨ ï¼Œ ä¸æ”¯æŒåœ¨åŠ¨æ€è¡¨å•ä¸­ä½¿ç”¨
       * @param {Object} key
       * @param {Object} value
       */
      setValue(key, value) {
        let example = this.childrens.find((child) => child.name === key);
        if (!example)
          return null;
        this.formData[key] = getValue(key, value, this.formRules[key] && this.formRules[key].rules || []);
        return example.onFieldChange(this.formData[key]);
      },
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * æ‰‹åŠ¨æäº¤æ ¡éªŒè¡¨å•
       * å¯¹æ•´ä¸ªè¡¨å•è¿›è¡Œæ ¡éªŒçš„æ–¹æ³•ï¼Œå‚æ•°ä¸ºä¸€ä¸ªå›žè°ƒå‡½æ•°ã€‚
       * @param {Array} keepitem ä¿ç•™ä¸å‚ä¸Žæ ¡éªŒçš„å­—æ®µ
       * @param {type} callback æ–¹æ³•å›žè°ƒ
       */
      validate(keepitem, callback) {
        return this.checkAll(this.formData, keepitem, callback);
      },
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * éƒ¨åˆ†è¡¨å•æ ¡éªŒ
       * @param {Array|String} props éœ€è¦æ ¡éªŒçš„å­—æ®µ
       * @param {Function} å›žè°ƒå‡½æ•°
       */
      validateField(props = [], callback) {
        props = [].concat(props);
        let invalidFields = {};
        this.childrens.forEach((item) => {
          const name = realName(item.name);
          if (props.indexOf(name) !== -1) {
            invalidFields = Object.assign({}, invalidFields, {
              [name]: this.formData[name]
            });
          }
        });
        return this.checkAll(invalidFields, [], callback);
      },
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³•
       * ç§»é™¤è¡¨å•é¡¹çš„æ ¡éªŒç»“æžœã€‚ä¼ å…¥å¾…ç§»é™¤çš„è¡¨å•é¡¹çš„ prop å±žæ€§æˆ–è€… prop ç»„æˆçš„æ•°ç»„ï¼Œå¦‚ä¸ä¼ åˆ™ç§»é™¤æ•´ä¸ªè¡¨å•çš„æ ¡éªŒç»“æžœ
       * @param {Array|String} props éœ€è¦ç§»é™¤æ ¡éªŒçš„å­—æ®µ ï¼Œä¸å¡«ä¸ºæ‰€æœ‰
       */
      clearValidate(props = []) {
        props = [].concat(props);
        this.childrens.forEach((item) => {
          if (props.length === 0) {
            item.errMsg = "";
          } else {
            const name = realName(item.name);
            if (props.indexOf(name) !== -1) {
              item.errMsg = "";
            }
          }
        });
      },
      /**
       * å¤–éƒ¨è°ƒç”¨æ–¹æ³• ï¼Œå³å°†åºŸå¼ƒ
       * æ‰‹åŠ¨æäº¤æ ¡éªŒè¡¨å•
       * å¯¹æ•´ä¸ªè¡¨å•è¿›è¡Œæ ¡éªŒçš„æ–¹æ³•ï¼Œå‚æ•°ä¸ºä¸€ä¸ªå›žè°ƒå‡½æ•°ã€‚
       * @param {Array} keepitem ä¿ç•™ä¸å‚ä¸Žæ ¡éªŒçš„å­—æ®µ
       * @param {type} callback æ–¹æ³•å›žè°ƒ
       */
      submit(keepitem, callback, type) {
        for (let i2 in this.dataValue) {
          const itemData = this.childrens.find((v2) => v2.name === i2);
          if (itemData) {
            if (this.formData[i2] === void 0) {
              this.formData[i2] = this._getValue(i2, this.dataValue[i2]);
            }
          }
        }
        if (!type) {
          formatAppLog("warn", "at uni_modules/uni-forms/components/uni-forms/uni-forms.vue:289", "submit æ–¹æ³•å³å°†åºŸå¼ƒï¼Œè¯·ä½¿ç”¨validateæ–¹æ³•ä»£æ›¿ï¼");
        }
        return this.checkAll(this.formData, keepitem, callback, "submit");
      },
      // æ ¡éªŒæ‰€æœ‰
      async checkAll(invalidFields, keepitem, callback, type) {
        if (!this.validator)
          return;
        let childrens = [];
        for (let i2 in invalidFields) {
          const item = this.childrens.find((v2) => realName(v2.name) === i2);
          if (item) {
            childrens.push(item);
          }
        }
        if (!callback && typeof keepitem === "function") {
          callback = keepitem;
        }
        let promise;
        if (!callback && typeof callback !== "function" && Promise) {
          promise = new Promise((resolve, reject) => {
            callback = function(valid, invalidFields2) {
              !valid ? resolve(invalidFields2) : reject(valid);
            };
          });
        }
        let results = [];
        let tempFormData = JSON.parse(JSON.stringify(invalidFields));
        for (let i2 in childrens) {
          const child = childrens[i2];
          let name = realName(child.name);
          const result = await child.onFieldChange(tempFormData[name]);
          if (result) {
            results.push(result);
            if (this.errShowType === "toast" || this.errShowType === "modal")
              break;
          }
        }
        if (Array.isArray(results)) {
          if (results.length === 0)
            results = null;
        }
        if (Array.isArray(keepitem)) {
          keepitem.forEach((v2) => {
            let vName = realName(v2);
            let value = getDataValue(v2, this.localData);
            if (value !== void 0) {
              tempFormData[vName] = value;
            }
          });
        }
        if (type === "submit") {
          this.$emit("submit", {
            detail: {
              value: tempFormData,
              errors: results
            }
          });
        } else {
          this.$emit("validate", results);
        }
        let resetFormData = {};
        resetFormData = rawData(tempFormData, this.name);
        callback && typeof callback === "function" && callback(results, resetFormData);
        if (promise && callback) {
          return promise;
        } else {
          return null;
        }
      },
      /**
       * è¿”å›žvalidateäº‹ä»¶
       * @param {Object} result
       */
      validateCheck(result) {
        this.$emit("validate", result);
      },
      _getValue: getValue,
      _isRequiredField: isRequiredField,
      _setDataValue: setDataValue,
      _getDataValue: getDataValue,
      _realName: realName,
      _isRealName: isRealName,
      _isEqual: isEqual
    }
  };
  function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-forms" }, [
      vue.createElementVNode("form", null, [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ]);
  }
  const __easycom_8 = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$R], ["__scopeId", "data-v-9a1e3c32"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-forms/components/uni-forms/uni-forms.vue"]]);
  const getOrderList = (params) => {
    return request({
      url: `/instruction/search/received/orders`,
      method: "get",
      data: params
    });
  };
  const getWarningList = (params) => {
    return request({
      url: `/instruction/search/received/warnings`,
      method: "get",
      data: params
    });
  };
  const sendWarning = (data) => {
    return request({
      url: `/instruction/send/warning`,
      method: "post",
      data
    });
  };
  const _imports_0$a = "/static/icon/alert.png";
  const _imports_1$4 = "/static/icon/flag.png";
  const _imports_2$2 = "/static/icon/document.png";
  const _imports_3$1 = "/static/icon/tuceng.png";
  const _imports_2$1 = "/static/icon/close.png";
  const _imports_5$1 = "/static/icon/video.png";
  const _imports_6 = "/static/icon/photo.png";
  const _imports_7 = "/static/icon/micro.png";
  const _imports_8 = "/static/icon/delete.png";
  const _imports_10 = "/static/images/none.png";
  const block0 = (Comp) => {
    (Comp.$renderjs || (Comp.$renderjs = [])).push("m");
    (Comp.$renderjsModules || (Comp.$renderjsModules = {}))["m"] = "55b5cda2";
  };
  const recorderManager = uni.getRecorderManager();
  const innerAudioContext = uni.createInnerAudioContext();
  innerAudioContext.autoplay = true;
  const _sfc_main$R = {
    data() {
      return {
        selectedMap: "gaode",
        //å½“å‰åœ°å›¾
        navIndex: 0,
        instruct_none: false,
        alert_none1: false,
        alert_none2: false,
        filePaths: {
          imagePath: "",
          videoPath: "",
          voicePath: ""
        },
        range: [
          {
            value: "1",
            text: "æœªå¼€å§‹"
          },
          {
            value: "2",
            text: "è¿›è¡Œä¸­"
          },
          {
            value: "3",
            text: "å·²å®Œæˆ"
          }
        ],
        alert_form_data: {
          alert_grade: "",
          alert_time: "",
          sender_name: "",
          alert_content: ""
        },
        grades: [
          {
            text: "ä¸€èˆ¬å‘Šè­¦",
            value: "ä¸€èˆ¬å‘Šè­¦"
          },
          {
            text: "ä¸¥é‡å‘Šè­¦",
            value: "ä¸¥é‡å‘Šè­¦"
          },
          {
            text: "ç´§æ€¥å‘Šè­¦",
            value: "ç´§æ€¥å‘Šè­¦"
          }
        ],
        taskItem: {},
        position: {
          longitude: "120.686250",
          latitude: "24.182220"
        },
        map_options: [
          {
            key: "google",
            src: "../../static/icon/google.png",
            htmlSrc: "/static/html/map_gaode.html",
            name: "è°·æ­Œåœ°å›¾"
          },
          {
            key: "gaode",
            src: "../../static/icon/gaode.png",
            htmlSrc: "/static/html/map_gaode.html",
            name: "é«˜å¾·åœ°å›¾"
          },
          {
            key: "baidu",
            src: "../../static/icon/baidu.png",
            htmlSrc: "/static/html/map_baidu.html",
            name: "ç™¾åº¦åœ°å›¾"
          },
          {
            key: "local",
            src: "../../static/icon/offline.png",
            htmlSrc: "/static/html/map_gaode.html",
            name: "ç¦»çº¿åœ°å›¾"
          }
          // ç»§ç»­æ·»åŠ æ›´å¤šå›¾ç‰‡
        ],
        task_instructions: [
          // {
          // 	src: '../../../static/uni.png',
          // 	sender_name: 'admin',
          // 	detail: 'æµ‹è¯•æŒ‡ä»¤1',
          // 	isConfirmed: false
          // },
          // {
          // 	src: '../../../static/uni.png',
          // 	sender_name: 'lihua',
          // 	detail: 'æµ‹è¯•æŒ‡ä»¤2',
          // 	isConfirmed: false
          // },
          // {
          // 	src: '../../../static/uni.png',
          // 	sender_name: 'wanghao',
          // 	detail: 'æµ‹è¯•æŒ‡ä»¤3',
          // 	isConfirmed: false
          // },
        ],
        alert_data: [
          // {
          // 	alert_grade: 'é‡è¦å‘Šè­¦',
          // 	alert_time: '2024.5.1',
          // 	sender_name: 'å¼ ä¸‰',
          // 	alert_content: 'å‘Šè­¦å†…å®¹',
          // 	isConfirmed: false
          // },
          // {
          // 	alert_grade: 'ä¸€èˆ¬å‘Šè­¦',
          // 	alert_time: '2024.2.6',
          // 	sender_name: 'æŽå››',
          // 	alert_content: 'å‘Šè­¦å†…å®¹',
          // 	isConfirmed: false
          // },
          // {
          // 	alert_grade: 'é‡è¦å‘Šè­¦',
          // 	alert_time: '2024.1.3',
          // 	sender_name: 'å¼ ä¸‰',
          // 	alert_content: 'å‘Šè­¦å†…å®¹',
          // 	isConfirmed: false
          // },
          // {
          // 	alert_grade: 'ä¸¥é‡å‘Šè­¦',
          // 	alert_time: '2024.7.9',
          // 	sender_name: 'å¼ ä¸‰',
          // 	alert_content: 'å‘Šè­¦å†…å®¹',
          // 	isConfirmed: false
          // },
        ],
        alert_data_mine: [
          // {
          // 	alert_grade: 'ä¸€èˆ¬å‘Šè­¦',
          // 	alert_time: '2024.5.1',
          // 	sender_name: 'å¼ ä¸‰',
          // 	alert_content: 'å‘Šè­¦å†…å®¹'
          // },
          // {
          // 	alert_grade: 'ä¸€èˆ¬å‘Šè­¦',
          // 	alert_time: '2024.2.6',
          // 	sender_name: 'æŽå››',
          // 	alert_content: 'å‘Šè­¦å†…å®¹'
          // },
          // {
          // 	alert_grade: 'é‡è¦å‘Šè­¦',
          // 	alert_time: '2024.1.3',
          // 	sender_name: 'å¼ ä¸‰',
          // 	alert_content: 'å‘Šè­¦å†…å®¹'
          // },
          // {
          // 	alert_grade: 'ä¸¥é‡å‘Šè­¦',
          // 	alert_time: '2024.7.9',
          // 	sender_name: 'å¼ ä¸‰',
          // 	alert_content: 'å‘Šè­¦å†…å®¹'
          // },
        ],
        // è¡ŒåŠ¨å›žæº¯ï¼Œfalseåœæ­¢ï¼Œtrueæ’­æ”¾
        replay: false,
        query: {
          "param": {
            "curPage": 1,
            "pageSize": 10
          },
          "statuses": [
            "USING",
            "UNUSED",
            "COMING"
          ]
        },
        // geoJsonæ•°æ®
        geoJson: "0"
      };
    },
    // onNavigationBarButtonTap() {
    // 	this.$refs.popup.open('bottom')
    // },
    mounted() {
      uni.showLoading({
        title: "æ­£åœ¨åŠ è½½ä»»åŠ¡",
        mask: true
      });
      searchMission(this.query).then((res) => {
        this.taskItem = res.data.records.map((e2) => ({
          id: e2.id,
          task_name: e2.missionName,
          country: e2.missionCountry,
          position: e2.missionCity,
          start_time: e2.missionStartTime,
          end_time: e2.missionEndTime,
          type: this.getTaskType(e2.missionStartTime, e2.missionEndTime),
          description: e2.missionDescription,
          key: e2.missionPassword,
          latitude: e2.latitude,
          longitude: e2.longitude,
          geoJson: e2.geoJson
        }))[0];
        this.position.latitude = this.taskItem.latitude;
        this.position.longitude = this.taskItem.longitude;
        this.geoJson = this.taskItem.geoJson;
        this.getOrder();
        this.getWarning();
        uni.hideLoading();
      });
    },
    onLoad(options) {
      let self2 = this;
      this.recorderManager.onStop(function(res) {
        self2.filePaths.voicePath = res.tempFilePath;
        uni.uploadFile({
          url: `http://139.196.11.210:8500/communicate/mission/upload/file`,
          filePath: res.tempFilePath,
          name: "file",
          formData: {
            "latitude": "12",
            "longitude": "123",
            "missionId": this.taskItem.id
          },
          header: {
            "Content-Type": "multipart/form-data;",
            "Authorization": "Bearer " + uni.getStorageSync("token")
          },
          success: (uploadFileRes) => {
            const res2 = JSON.parse(uploadFileRes.data);
            if (res2.code === 200) {
              uni.showToast({
                title: "éŸ³é¢‘ä¸Šä¼ æˆåŠŸï¼",
                //å°†å€¼è®¾ç½®ä¸º success æˆ–è€…ç›´æŽ¥ä¸ç”¨å†™iconè¿™ä¸ªå‚æ•°
                icon: "success",
                //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                duration: 2e3
              });
            } else {
              uni.showToast({
                title: "éŸ³é¢‘ä¸Šä¼ å¤±è´¥ï¼",
                icon: "none",
                //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                duration: 2e3
              });
            }
            formatAppLog("log", "at pages/task/task_detail/task_detail.vue:824", uploadFileRes.data);
          }
        });
      });
    },
    methods: {
      take_picture() {
        var self2 = this;
        uni.chooseImage({
          count: 1,
          // é»˜è®¤é€‰æ‹©ä¸€å¼ å›¾ç‰‡
          sourceType: ["camera"],
          // åªå…è®¸ä»Žç›¸æœºæ‹ç…§
          success: function(res) {
            const tempFilePath = res.tempFilePaths[0];
            formatAppLog("log", "at pages/task/task_detail/task_detail.vue:839", "æ‹ç…§æˆåŠŸï¼Œæ–‡ä»¶è·¯å¾„ï¼š", tempFilePath);
            uni.previewImage({
              urls: [tempFilePath]
            });
            uni.uploadFile({
              url: "http://139.196.11.210:8500/communicate/mission/upload/file",
              filePath: tempFilePath,
              name: "files",
              formData: {
                "latitude": "12",
                "longitude": "123",
                "missionId": self2.taskItem.id
              },
              header: {
                "Content-Type": "multipart/form-data;",
                "Authorization": "Bearer " + uni.getStorageSync("token")
              },
              success: (uploadFileRes) => {
                const res2 = JSON.parse(uploadFileRes.data);
                if (res2.code === 200) {
                  uni.showToast({
                    title: "å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼",
                    //å°†å€¼è®¾ç½®ä¸º success æˆ–è€…ç›´æŽ¥ä¸ç”¨å†™iconè¿™ä¸ªå‚æ•°
                    icon: "success",
                    //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                    duration: 2e3
                  });
                } else {
                  uni.showToast({
                    title: "å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼",
                    icon: "none",
                    //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                    duration: 2e3
                  });
                }
                formatAppLog("log", "at pages/task/task_detail/task_detail.vue:877", uploadFileRes.data);
              }
            });
          },
          fail: function(err) {
            formatAppLog("error", "at pages/task/task_detail/task_detail.vue:882", "æ‹ç…§å¤±è´¥ï¼š", err);
          }
        });
      },
      take_video() {
        var self2 = this;
        uni.chooseVideo({
          sourceType: ["camera"],
          // åªå…è®¸ä»Žç›¸æœºå½•åˆ¶
          maxDuration: 60,
          // å½•åƒæ—¶é•¿æœ€å¤§ä¸º60ç§’
          camera: "back",
          // ä½¿ç”¨åŽç½®æ‘„åƒå¤´
          success: function(res) {
            const tempFilePath = res.tempFilePath;
            self2.filePaths.videoPath = res.tempFilePath;
            formatAppLog("log", "at pages/task/task_detail/task_detail.vue:897", "å½•åƒæˆåŠŸï¼Œæ–‡ä»¶è·¯å¾„ï¼š", tempFilePath);
            uni.uploadFile({
              url: `http://139.196.11.210:8500/communicate/mission/upload/file`,
              filePath: tempFilePath,
              name: "file",
              formData: {
                "latitude": "12",
                "longitude": "123",
                "missionId": self2.taskItem.id
              },
              header: {
                "Content-Type": "multipart/form-data;",
                "Authorization": "Bearer " + uni.getStorageSync("token")
              },
              success: (uploadFileRes) => {
                const res2 = JSON.parse(uploadFileRes.data);
                if (res2.code === 200) {
                  uni.showToast({
                    title: "è§†é¢‘ä¸Šä¼ æˆåŠŸï¼",
                    //å°†å€¼è®¾ç½®ä¸º success æˆ–è€…ç›´æŽ¥ä¸ç”¨å†™iconè¿™ä¸ªå‚æ•°
                    icon: "success",
                    //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                    duration: 2e3
                  });
                } else {
                  uni.showToast({
                    title: "è§†é¢‘ä¸Šä¼ å¤±è´¥ï¼",
                    icon: "none",
                    //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                    duration: 2e3
                  });
                }
                formatAppLog("log", "at pages/task/task_detail/task_detail.vue:930", uploadFileRes.data);
              }
            });
          },
          fail: function(err) {
            formatAppLog("error", "at pages/task/task_detail/task_detail.vue:935", "å½•åƒå¤±è´¥ï¼š", err);
          }
        });
      },
      startRecording() {
        formatAppLog("log", "at pages/task/task_detail/task_detail.vue:940", "å¼€å§‹å½•éŸ³");
        recorderManager.start();
        uni.showLoading({
          title: "æ­£åœ¨å½•éŸ³"
        });
      },
      stopRecording() {
        formatAppLog("log", "at pages/task/task_detail/task_detail.vue:949", "å½•éŸ³ç»“æŸ");
        recorderManager.stop();
        uni.hideLoading();
      },
      playVoice() {
        formatAppLog("log", "at pages/task/task_detail/task_detail.vue:954", "æ’­æ”¾å½•éŸ³");
        formatAppLog("log", "at pages/task/task_detail/task_detail.vue:955", "this.voicePath", this.filePaths.voicePath);
        if (this.filePaths.voicePath) {
          this.innerAudioContext.src = this.filePaths.voicePath;
          this.innerAudioContext.play();
        }
      },
      checkIndex(index) {
        this.navIndex = index;
      },
      delete_alert(index) {
        this.alert_data.splice(index, 1);
      },
      delete_alert_mine(index) {
        this.alert_data_mine.splice(index, 1);
      },
      open() {
        this.$refs.popup.open();
      },
      close() {
        this.$refs.popup.close();
      },
      open_alert_form() {
        this.$refs.alert_form_popup.open();
      },
      close_alert_form() {
        this.$refs.alert_form_popup.close();
      },
      open_alert_popup() {
        this.$refs.alert_popup.open();
      },
      close_alert_popup() {
        this.$refs.alert_popup.close();
      },
      open_map_selector() {
        this.$refs.map_selector.open();
      },
      close_map_selector() {
        this.$refs.map_selector.close();
      },
      open_task_instructions() {
        this.$refs.task_instructions.open();
      },
      close_task_instructions() {
        this.$refs.task_instructions.close();
      },
      goToDocument() {
        uni.navigateTo({
          url: `/pages/task/task_detail/document/document?missionId=${this.taskItem.id}`
        });
      },
      goToMainPage() {
        uni.redirectTo({
          url: "/pages/tabBar/tabBar"
        });
      },
      selectImage(value) {
        this.selectedMap = value;
        this.$refs.map_selector.close();
      },
      receive_instruction(index) {
        this.task_instructions[index].isConfirmed = true;
      },
      receive_alert(index) {
        this.alert_data[index].isConfirmed = true;
      },
      isReceived(index) {
        return this.task_instructions[index].isConfirmed ? "å·²æ”¶åˆ°" : "æ”¶åˆ°";
      },
      isReceived_alert(index) {
        return this.alert_data[index].isConfirmed ? "å·²ç¡®è®¤" : "ç¡®è®¤";
      },
      submit(ref) {
        uni.showLoading({
          title: "æ­£åœ¨å‘é€",
          mask: true
        });
        let data = {
          isOrder: false,
          message: this.alert_form_data.alert_content,
          receiverMissionMemberIds: [],
          relatedMissionId: this.taskItem.id
        };
        getMissionDetails({
          missionId: this.taskItem.id
        }).then((res) => {
          if (res.code === 200) {
            sendWarning(data).then((res2) => {
              if (res2.code === 200) {
                uni.showToast({
                  title: "å‘é€æˆåŠŸ",
                  duration: 2e3
                });
              } else {
                uni.showToast({
                  title: "å‘é€å¤±è´¥",
                  icon: "none",
                  duration: 2e3
                });
              }
              uni.hideLoading();
            });
          }
        });
        this.$refs.alert_form_popup.close();
        this.getWarning();
      },
      // è®¾ç½®ç»çº¬åº¦
      // setPoint() {
      // 	this.position.latitude = this.taskItem.latitude;
      // 	this.position.longitude = this.taskItem.longitude;
      // 	__f__('log','at pages/task/task_detail/task_detail.vue:1071',this.position,'position')
      // },
      // setGeoJson() {
      // 	this.geoJson = this.taskItem.geoJson;
      // 	__f__('log','at pages/task/task_detail/task_detail.vue:1075',this.geoJson, 'owner-setGeoJson')
      // },
      // åˆ é™¤ä»»åŠ¡
      deleteMisson() {
        const id = this.taskItem.id;
        uni.showModal({
          title: "æç¤º",
          content: "ç¡®å®šåˆ é™¤ä»»åŠ¡ï¼Ÿ",
          success: function(res) {
            uni.showLoading({
              title: "æ­£åœ¨åˆ é™¤",
              mask: true
            });
            deleteMission(id).then((res2) => {
              uni.hideLoading();
              if (res2.code == 200) {
                uni.showToast({
                  title: "åˆ é™¤æˆåŠŸ",
                  duration: 2e3
                });
              } else {
                uni.showToast({
                  title: res2.msg,
                  duration: 2e3
                });
              }
            });
          }
        });
      },
      setReplay(value) {
        this.replay = value;
      },
      getOrder() {
        getOrderList({
          missionId: this.taskItem.id,
          curPage: 1,
          pageSize: 20
        }).then((res) => {
          if (res.code === 200) {
            this.task_instructions = res.data.records.map((item) => ({
              src: "../../../static/uni.png",
              sender_name: item.user.name,
              detail: item.message,
              isConfirmed: item.isRead
            }));
            if (this.task_instructions.length === 0) {
              this.instruct_none = true;
            } else {
              this.instruct_none = false;
            }
          } else {
            this.instruct_none = true;
          }
        });
      },
      getTaskType(startTime, endTime) {
        const start = new Date(startTime);
        const end = new Date(endTime);
        if (this.currentTime < start) {
          return "1";
        } else if (this.currentTime >= start && this.currentTime <= end) {
          return "2";
        } else {
          return "3";
        }
      },
      getWarning() {
        getWarningList({
          missionId: this.taskItem.id,
          curPage: 1,
          pageSize: 20
        }).then((res) => {
          formatAppLog("log", "at pages/task/task_detail/task_detail.vue:1150", res.data.records, "res");
          if (res.code === 200) {
            uni.getStorageSync("userInfo");
            this.alert_data = res.data.records.map(
              (item) => ({
                alert_grade: "ä¸¥é‡å‘Šè­¦",
                alert_time: item.sendTime,
                sender_name: item.user.name,
                alert_content: item.message,
                isConfirmed: item.isRead
              })
            );
            if (this.alert_data.length === 0) {
              this.alert_none1 = true;
            } else {
              this.alert_none1 = false;
            }
            if (this.alert_data_mine.length === 0) {
              this.alert_none2 = true;
            } else {
              this.alert_none2 = false;
            }
          }
        });
      }
    }
  };
  function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    const _component_uni_data_select = resolveEasycom(vue.resolveDynamicComponent("uni-data-select"), __easycom_1$2);
    const _component_uni_popup = resolveEasycom(vue.resolveDynamicComponent("uni-popup"), __easycom_2$1);
    const _component_uni_collapse_item = resolveEasycom(vue.resolveDynamicComponent("uni-collapse-item"), __easycom_3$1);
    const _component_uni_collapse = resolveEasycom(vue.resolveDynamicComponent("uni-collapse"), __easycom_4);
    const _component_uni_data_checkbox = resolveEasycom(vue.resolveDynamicComponent("uni-data-checkbox"), __easycom_5$1);
    const _component_uni_forms_item = resolveEasycom(vue.resolveDynamicComponent("uni-forms-item"), __easycom_6$1);
    const _component_uni_easyinput = resolveEasycom(vue.resolveDynamicComponent("uni-easyinput"), __easycom_0$1);
    const _component_uni_forms = resolveEasycom(vue.resolveDynamicComponent("uni-forms"), __easycom_8);
    return vue.openBlock(), vue.createElementBlock(
      vue.Fragment,
      null,
      [
        vue.createElementVNode("view", null, [
          vue.createVNode(_component_uni_nav_bar, {
            fixed: true,
            "status-bar": "",
            shadow: "",
            rightIcon: "more-filled",
            onClickRight: $options.open,
            title: "ä»»åŠ¡è¯¦æƒ…"
          }, null, 8, ["onClickRight"])
        ]),
        vue.createCommentVNode(" åœ°å›¾å®¹å™¨ "),
        vue.createElementVNode("view", {
          id: "map_container",
          selectedMap: vue.wp($data.selectedMap),
          "change:selectedMap": _ctx.m.setMapType,
          replay: $data.replay,
          "change:replay": _ctx.m.setReplay,
          position: vue.wp($data.position),
          "change:position": _ctx.m.setPosition,
          geoJson: vue.wp($data.geoJson),
          "change:geoJson": _ctx.m.setGeoJson
        }, null, 8, ["selectedMap", "change:selectedMap", "replay", "change:replay", "position", "change:position", "geoJson", "change:geoJson"]),
        vue.createCommentVNode(" task_detail "),
        vue.createElementVNode("view", { class: "layout_task_detail" }, [
          vue.createCommentVNode(" æŒ‰é’®ç»„ "),
          vue.createElementVNode("view", { class: "condition_icons" }, [
            vue.createCommentVNode(" å·¦ä¾§-é€‰æ‹©ä»»åŠ¡çŠ¶æ€æŒ‰é’® "),
            vue.createElementVNode("view", { class: "condition_selector" }, [
              vue.createVNode(_component_uni_data_select, {
                modelValue: $data.taskItem.type,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.taskItem.type = $event),
                localdata: $data.range,
                clear: false
              }, null, 8, ["modelValue", "localdata"])
            ]),
            vue.createElementVNode("view", { class: "condition_selector" }, [
              vue.createElementVNode("button", {
                class: "mini-btn",
                type: "primary",
                size: "mini",
                onClick: _cache[1] || (_cache[1] = ($event) => $options.setReplay(!$data.replay))
              }, [
                !$data.replay ? (vue.openBlock(), vue.createElementBlock("text", { key: 0 }, " è¡ŒåŠ¨å›žæº¯ ")) : (vue.openBlock(), vue.createElementBlock("text", { key: 1 }, " æ­£åœ¨å›žæº¯ "))
              ])
            ]),
            vue.createCommentVNode(" å³ä¾§æŒ‰é’®ç»„ "),
            vue.createElementVNode("view", { class: "right-button-groups" }, [
              vue.createCommentVNode(" å‘Šè­¦æŒ‰é’® "),
              vue.createElementVNode("view", {
                class: "instructions_alert",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.open_alert_popup && $options.open_alert_popup(...args))
              }, [
                vue.createElementVNode("view", {
                  class: "alert_img",
                  style: { "text-align": "center", "padding-top": "5px" }
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_0$a,
                    style: { "width": "22px", "height": "22px" }
                  })
                ]),
                vue.createElementVNode("view", {
                  class: "text_setting",
                  style: { "text-align": "center" }
                }, [
                  vue.createElementVNode("text", { style: { "color": "#d81e06", "font-size": "small" } }, "å‘Šè­¦")
                ])
              ]),
              vue.createCommentVNode(" æŒ‡ä»¤æŒ‰é’® "),
              vue.createElementVNode("view", {
                class: "instructions_instruct",
                onClick: _cache[3] || (_cache[3] = (...args) => $options.open_task_instructions && $options.open_task_instructions(...args))
              }, [
                vue.createElementVNode("view", {
                  class: "alert_img",
                  style: { "text-align": "center", "padding-top": "5px" }
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_1$4,
                    style: { "width": "22px", "height": "22px" }
                  })
                ]),
                vue.createElementVNode("view", {
                  class: "text_setting",
                  style: { "text-align": "center" }
                }, [
                  vue.createElementVNode("text", { style: { "color": "#3171d3", "font-size": "small" } }, "æŒ‡ä»¤")
                ])
              ]),
              vue.createCommentVNode(" æ–‡ä»¶æŒ‰é’®+å›¾å±‚æŒ‰é’® "),
              vue.createElementVNode("view", { class: "instructions_document" }, [
                vue.createCommentVNode(" æ–‡ä»¶æŒ‰é’® "),
                vue.createElementVNode("view", {
                  class: "document",
                  onClick: _cache[4] || (_cache[4] = (...args) => $options.goToDocument && $options.goToDocument(...args))
                }, [
                  vue.createElementVNode("view", {
                    class: "alert_img",
                    style: { "text-align": "center", "padding-top": "5px" }
                  }, [
                    vue.createElementVNode("image", {
                      src: _imports_2$2,
                      style: { "width": "22px", "height": "22px" }
                    })
                  ]),
                  vue.createElementVNode("view", {
                    class: "text_setting",
                    style: { "text-align": "center" }
                  }, [
                    vue.createElementVNode("text", { style: { "color": "#636363", "font-size": "small" } }, "æ–‡ä»¶")
                  ])
                ]),
                vue.createCommentVNode(" å›¾å±‚æŒ‰é’® "),
                vue.createElementVNode("view", {
                  class: "map_selector",
                  onClick: _cache[5] || (_cache[5] = (...args) => $options.open_map_selector && $options.open_map_selector(...args))
                }, [
                  vue.createElementVNode("view", {
                    class: "alert_img",
                    style: { "text-align": "center", "padding-top": "5px" }
                  }, [
                    vue.createElementVNode("image", {
                      src: _imports_3$1,
                      style: { "width": "22px", "height": "22px" }
                    })
                  ]),
                  vue.createElementVNode("view", {
                    class: "text_setting",
                    style: { "text-align": "center" }
                  }, [
                    vue.createElementVNode("text", { style: { "color": "#636363", "font-size": "small" } }, "å›¾å±‚")
                  ])
                ])
              ])
            ])
          ]),
          vue.createCommentVNode(" è¯¦æƒ…ç•Œé¢å¼¹çª— "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "popup",
                type: "bottom",
                "background-color": "#fff",
                "mask-click": false
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", {
                    class: "detail",
                    style: { "padding": "15px" }
                  }, [
                    vue.createElementVNode("view", { class: "detail_top" }, [
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode(
                          "text",
                          null,
                          vue.toDisplayString($data.taskItem.task_name),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", {
                        style: { "margin-right": "10px" },
                        onClick: _cache[6] || (_cache[6] = (...args) => $options.close && $options.close(...args))
                      }, [
                        vue.createElementVNode("image", {
                          src: _imports_2$1,
                          style: { "width": "15px", "height": "15px" }
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    vue.createElementVNode("view", { class: "detail_info" }, [
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "ä»»åŠ¡åç§°: " + vue.toDisplayString($data.taskItem.task_name),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "ä»»åŠ¡æè¿°: " + vue.toDisplayString($data.taskItem.description),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "ä»»åŠ¡å›½å®¶: " + vue.toDisplayString($data.taskItem.country),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "ä»»åŠ¡åœ°ç‚¹: " + vue.toDisplayString($data.taskItem.position),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "ä»»åŠ¡æ—¶é—´: " + vue.toDisplayString($data.taskItem.start_time) + " - " + vue.toDisplayString($data.taskItem.end_time),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "infos" }, [
                        vue.createElementVNode(
                          "text",
                          null,
                          "ä»»åŠ¡å£ä»¤: " + vue.toDisplayString($data.taskItem.key),
                          1
                          /* TEXT */
                        )
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    vue.createElementVNode("view", { class: "text_setting" }, [
                      vue.createCommentVNode(" å½•åˆ¶è§†é¢‘æŒ‰é’® "),
                      vue.createElementVNode("view", { style: { "margin-right": "50px" } }, [
                        vue.createElementVNode("image", {
                          onClick: _cache[7] || (_cache[7] = ($event) => $options.take_video()),
                          src: _imports_5$1,
                          style: { "width": "30px", "height": "30px" }
                        })
                      ]),
                      vue.createCommentVNode(" æ‹æ‘„ç…§ç‰‡æŒ‰é’® "),
                      vue.createElementVNode("view", { style: { "margin-right": "50px" } }, [
                        vue.createElementVNode("image", {
                          onClick: _cache[8] || (_cache[8] = ($event) => $options.take_picture()),
                          src: _imports_6,
                          style: { "width": "33px", "height": "33px" }
                        })
                      ]),
                      vue.createCommentVNode(" å½•åˆ¶éŸ³é¢‘æŒ‰é’® "),
                      vue.createElementVNode("view", { style: { "margin-right": "50px" } }, [
                        vue.createElementVNode(
                          "image",
                          {
                            onLongpress: _cache[9] || (_cache[9] = ($event) => $options.startRecording()),
                            onTouchend: _cache[10] || (_cache[10] = ($event) => $options.stopRecording()),
                            src: _imports_7,
                            style: { "width": "32px", "height": "32px" }
                          },
                          null,
                          32
                          /* NEED_HYDRATION */
                        )
                      ]),
                      vue.createCommentVNode(" åˆ é™¤ä»»åŠ¡æŒ‰é’® "),
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode("image", {
                          src: _imports_8,
                          style: { "width": "28px", "height": "28px" },
                          onClick: _cache[11] || (_cache[11] = (...args) => $options.deleteMisson && $options.deleteMisson(...args))
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { style: { "height": "50px" } })
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ]),
          vue.createCommentVNode(" å›¾å±‚å¼¹çª— "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "map_selector",
                type: "bottom",
                "background-color": "#fff",
                "mask-click": false
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", {
                    class: "detail",
                    style: { "padding": "15px" }
                  }, [
                    vue.createElementVNode("view", { class: "detail_top" }, [
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode("text", null, "å›¾å±‚åˆ‡æ¢")
                      ]),
                      vue.createElementVNode("view", {
                        style: { "margin-right": "10px" },
                        onClick: _cache[12] || (_cache[12] = (...args) => $options.close_map_selector && $options.close_map_selector(...args))
                      }, [
                        vue.createElementVNode("image", {
                          src: _imports_2$1,
                          style: { "width": "15px", "height": "15px" }
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    vue.createElementVNode("view", { style: { "margin-top": "20px" } }, [
                      vue.createElementVNode("view", { class: "map_icons" }, [
                        (vue.openBlock(true), vue.createElementBlock(
                          vue.Fragment,
                          null,
                          vue.renderList($data.map_options, (item, index) => {
                            return vue.openBlock(), vue.createElementBlock("view", { key: index }, [
                              vue.createElementVNode("view", {
                                class: "map_icon",
                                style: { "margin": "0 15px" }
                              }, [
                                vue.createCommentVNode(` 									<image :class="{ 'selected': selectedIndex === index }" @click="selectImage(index)"\r
										:src=item.src style="width: 55px; height: 55px; border-radius: 15px;"></image> `),
                                vue.createElementVNode("image", {
                                  class: vue.normalizeClass({ "selected": $data.selectedMap === item.key }),
                                  onClick: ($event) => $options.selectImage(item.key),
                                  src: item.src,
                                  style: { "width": "55px", "height": "55px", "border-radius": "15px" }
                                }, null, 10, ["onClick", "src"])
                              ]),
                              vue.createElementVNode("view", { style: { "text-align": "center" } }, [
                                vue.createElementVNode(
                                  "text",
                                  null,
                                  vue.toDisplayString(item.name),
                                  1
                                  /* TEXT */
                                )
                              ])
                            ]);
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ])
                    ]),
                    vue.createElementVNode("view", { style: { "height": "50px" } })
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ]),
          vue.createCommentVNode(" ä»»åŠ¡æŒ‡ä»¤å¼¹çª— "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "task_instructions",
                type: "bottom",
                "background-color": "#fff",
                "mask-click": false
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", {
                    class: "detail",
                    style: { "padding": "15px" }
                  }, [
                    vue.createElementVNode("view", { class: "detail_top" }, [
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode("text", null, "ä»»åŠ¡æŒ‡ä»¤")
                      ]),
                      vue.createElementVNode("view", {
                        style: { "margin-right": "10px" },
                        onClick: _cache[13] || (_cache[13] = (...args) => $options.close_task_instructions && $options.close_task_instructions(...args))
                      }, [
                        vue.createElementVNode("image", {
                          src: _imports_2$1,
                          style: { "width": "15px", "height": "15px" }
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    $data.instruct_none ? (vue.openBlock(), vue.createElementBlock("view", {
                      key: 0,
                      style: { "text-align": "center" }
                    }, [
                      vue.createElementVNode("image", {
                        src: _imports_10,
                        style: { "width": "60%", "height": "60%" },
                        mode: "widthFix"
                      }),
                      vue.createElementVNode("view", null, "æš‚æœªå‘çŽ°ä»»åŠ¡æŒ‡ä»¤")
                    ])) : vue.createCommentVNode("v-if", true),
                    vue.createElementVNode("view", { style: { "margin-top": "20px" } }, [
                      vue.createElementVNode("view", { class: "instructions" }, [
                        (vue.openBlock(true), vue.createElementBlock(
                          vue.Fragment,
                          null,
                          vue.renderList($data.task_instructions, (item, index) => {
                            return vue.openBlock(), vue.createElementBlock("view", {
                              key: index,
                              class: "instructions_item",
                              style: { "display": "flex", "justify-content": "space-between", "align-items": "center", "margin-bottom": "20px" }
                            }, [
                              vue.createElementVNode("view", { style: { "display": "flex" } }, [
                                vue.createElementVNode("view", { style: { "margin-right": "10px" } }, [
                                  vue.createElementVNode("image", {
                                    src: item.src,
                                    style: { "width": "45px", "height": "45px" }
                                  }, null, 8, ["src"])
                                ]),
                                vue.createElementVNode("view", null, [
                                  vue.createElementVNode("view", null, [
                                    vue.createElementVNode(
                                      "text",
                                      null,
                                      vue.toDisplayString(item.sender_name),
                                      1
                                      /* TEXT */
                                    )
                                  ]),
                                  vue.createElementVNode("view", null, [
                                    vue.createElementVNode(
                                      "text",
                                      { style: { "color": "#858585" } },
                                      vue.toDisplayString(item.detail),
                                      1
                                      /* TEXT */
                                    )
                                  ])
                                ])
                              ]),
                              vue.createElementVNode("view", null, [
                                vue.createElementVNode("button", {
                                  onClick: ($event) => $options.receive_instruction(index),
                                  disabled: item.isConfirmed,
                                  class: "mini-btn",
                                  type: "primary",
                                  size: "mini"
                                }, vue.toDisplayString($options.isReceived(index)), 9, ["onClick", "disabled"])
                              ])
                            ]);
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ])
                    ]),
                    vue.createElementVNode("view", { style: { "height": "50px" } })
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ]),
          vue.createCommentVNode(" å‘Šè­¦å¼¹çª— "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "alert_popup",
                type: "bottom",
                "background-color": "#fff"
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", { style: { "padding": "15px" } }, [
                    vue.createElementVNode("view", { class: "detail" }, [
                      vue.createElementVNode("view", { class: "detail_top" }, [
                        vue.createElementVNode("view", null, [
                          vue.createElementVNode("text", null, "å‘Šè­¦åˆ—è¡¨")
                        ]),
                        vue.createElementVNode("view", {
                          style: { "margin-right": "10px" },
                          onClick: _cache[14] || (_cache[14] = (...args) => $options.close_alert_popup && $options.close_alert_popup(...args))
                        }, [
                          vue.createElementVNode("image", {
                            src: _imports_2$1,
                            style: { "width": "15px", "height": "15px" }
                          })
                        ])
                      ]),
                      vue.createElementVNode("view", { class: "divider" })
                    ]),
                    vue.createElementVNode("view", null, [
                      vue.createElementVNode("view", { class: "head-nav" }, [
                        vue.createElementVNode(
                          "view",
                          {
                            class: vue.normalizeClass($data.navIndex == 0 ? "activite" : ""),
                            onClick: _cache[15] || (_cache[15] = ($event) => $options.checkIndex(0)),
                            style: { "width": "50%", "text-align": "center" }
                          },
                          "æŽ¥æ”¶",
                          2
                          /* CLASS */
                        ),
                        vue.createElementVNode(
                          "view",
                          {
                            class: vue.normalizeClass($data.navIndex == 1 ? "activite" : ""),
                            onClick: _cache[16] || (_cache[16] = ($event) => $options.checkIndex(1)),
                            style: { "width": "50%", "text-align": "center" }
                          },
                          "å‘é€",
                          2
                          /* CLASS */
                        )
                      ]),
                      vue.createCommentVNode(" å†…å®¹åˆ‡æ¢ "),
                      $data.navIndex == 0 ? (vue.openBlock(), vue.createElementBlock("view", {
                        key: 0,
                        class: "alert_content"
                      }, [
                        $data.alert_none1 ? (vue.openBlock(), vue.createElementBlock("view", {
                          key: 0,
                          style: { "text-align": "center" }
                        }, [
                          vue.createElementVNode("image", {
                            src: _imports_10,
                            style: { "width": "60%", "height": "60%" },
                            mode: "widthFix"
                          }),
                          vue.createElementVNode("view", null, "æš‚æœªå‘çŽ°å‘Šè­¦ä¿¡æ¯")
                        ])) : vue.createCommentVNode("v-if", true),
                        vue.createVNode(
                          _component_uni_collapse,
                          {
                            ref: "collapse",
                            accordion: ""
                          },
                          {
                            default: vue.withCtx(() => [
                              (vue.openBlock(true), vue.createElementBlock(
                                vue.Fragment,
                                null,
                                vue.renderList($data.alert_data, (item, index) => {
                                  return vue.openBlock(), vue.createBlock(_component_uni_collapse_item, {
                                    key: index,
                                    title: item.alert_content
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createElementVNode("view", {
                                        class: "detail_info",
                                        style: { "margin": "0 15px 5px 0" }
                                      }, [
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "å‘Šè­¦ç­‰çº§: " + vue.toDisplayString(item.alert_grade),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "å‘Šè­¦æ—¶é—´: " + vue.toDisplayString(item.alert_time),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "åˆ›å»ºç”¨æˆ·: " + vue.toDisplayString(item.sender_name),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "å‘Šè­¦å†…å®¹: " + vue.toDisplayString(item.alert_content),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { style: { "text-align": "right" } }, [
                                          vue.createElementVNode("button", {
                                            class: "mini-btn",
                                            type: "warn",
                                            size: "mini",
                                            style: { "margin-right": "10px" },
                                            onClick: ($event) => $options.delete_alert(index)
                                          }, "åˆ é™¤", 8, ["onClick"]),
                                          vue.createElementVNode("button", {
                                            class: "mini-btn",
                                            type: "default",
                                            size: "mini",
                                            onClick: ($event) => $options.receive_alert(index),
                                            disabled: item.isConfirmed
                                          }, vue.toDisplayString($options.isReceived_alert(index)), 9, ["onClick", "disabled"])
                                        ])
                                      ])
                                    ]),
                                    _: 2
                                    /* DYNAMIC */
                                  }, 1032, ["title"]);
                                }),
                                128
                                /* KEYED_FRAGMENT */
                              ))
                            ]),
                            _: 1
                            /* STABLE */
                          },
                          512
                          /* NEED_PATCH */
                        )
                      ])) : vue.createCommentVNode("v-if", true),
                      $data.navIndex == 1 ? (vue.openBlock(), vue.createElementBlock("view", {
                        key: 1,
                        class: "content"
                      }, [
                        $data.alert_none2 ? (vue.openBlock(), vue.createElementBlock("view", {
                          key: 0,
                          style: { "text-align": "center", "margin-bottom": "15px" }
                        }, [
                          vue.createElementVNode("image", {
                            src: _imports_10,
                            style: { "width": "60%", "height": "60%" },
                            mode: "widthFix"
                          }),
                          vue.createElementVNode("view", null, "æš‚æœªå‘çŽ°å‘Šè­¦ä¿¡æ¯")
                        ])) : vue.createCommentVNode("v-if", true),
                        vue.createVNode(
                          _component_uni_collapse,
                          {
                            ref: "collapse",
                            accordion: ""
                          },
                          {
                            default: vue.withCtx(() => [
                              (vue.openBlock(true), vue.createElementBlock(
                                vue.Fragment,
                                null,
                                vue.renderList($data.alert_data_mine, (item, index) => {
                                  return vue.openBlock(), vue.createBlock(_component_uni_collapse_item, {
                                    key: index,
                                    title: item.alert_content
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createElementVNode("view", {
                                        class: "detail_info",
                                        style: { "margin": "0 15px 5px 0" }
                                      }, [
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "å‘Šè­¦ç­‰çº§: " + vue.toDisplayString(item.alert_grade),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "å‘Šè­¦æ—¶é—´: " + vue.toDisplayString(item.alert_time),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "åˆ›å»ºç”¨æˆ·: " + vue.toDisplayString(item.sender_name),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { class: "infos" }, [
                                          vue.createElementVNode(
                                            "text",
                                            null,
                                            "å‘Šè­¦å†…å®¹: " + vue.toDisplayString(item.alert_content),
                                            1
                                            /* TEXT */
                                          )
                                        ]),
                                        vue.createElementVNode("view", { style: { "text-align": "right" } }, [
                                          vue.createElementVNode("button", {
                                            class: "mini-btn",
                                            type: "warn",
                                            size: "mini",
                                            style: { "margin-right": "10px" },
                                            onClick: ($event) => $options.delete_alert_mine(index)
                                          }, "åˆ é™¤", 8, ["onClick"])
                                        ])
                                      ])
                                    ]),
                                    _: 2
                                    /* DYNAMIC */
                                  }, 1032, ["title"]);
                                }),
                                128
                                /* KEYED_FRAGMENT */
                              ))
                            ]),
                            _: 1
                            /* STABLE */
                          },
                          512
                          /* NEED_PATCH */
                        ),
                        vue.createElementVNode("view", null, [
                          vue.createElementVNode("button", {
                            type: "primary",
                            onClick: _cache[17] || (_cache[17] = (...args) => $options.open_alert_form && $options.open_alert_form(...args))
                          }, "å‘å¸ƒå‘Šè­¦")
                        ])
                      ])) : vue.createCommentVNode("v-if", true)
                    ]),
                    vue.createElementVNode("view", { style: { "height": "50px" } })
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ]),
          vue.createCommentVNode(" å‘å¸ƒå‘Šè­¦å¼¹çª— "),
          vue.createElementVNode("view", null, [
            vue.createVNode(
              _component_uni_popup,
              {
                ref: "alert_form_popup",
                type: "dialog"
              },
              {
                default: vue.withCtx(() => [
                  vue.createElementVNode("view", {
                    class: "example",
                    style: { "background": "#fff", "border-radius": "5px", "padding": "10px" }
                  }, [
                    vue.createElementVNode("view", { class: "detail_top" }, [
                      vue.createElementVNode("view", null, [
                        vue.createElementVNode("text", null, "å‘å¸ƒå‘Šè­¦")
                      ]),
                      vue.createElementVNode("view", {
                        style: { "margin-right": "10px" },
                        onClick: _cache[18] || (_cache[18] = (...args) => $options.close_alert_form && $options.close_alert_form(...args))
                      }, [
                        vue.createElementVNode("image", {
                          src: _imports_2$1,
                          style: { "width": "15px", "height": "15px" }
                        })
                      ])
                    ]),
                    vue.createElementVNode("view", { class: "divider" }),
                    vue.createCommentVNode(" åŸºç¡€ç”¨æ³•ï¼Œä¸åŒ…å«æ ¡éªŒè§„åˆ™ "),
                    vue.createVNode(_component_uni_forms, {
                      ref: "alert_form",
                      modelValue: $data.alert_form_data
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_uni_forms_item, {
                          label: "å‘Šè­¦ç­‰çº§",
                          style: { "display": "flex", "align-items": "center" }
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(_component_uni_data_checkbox, {
                              modelValue: $data.alert_form_data.alert_grade,
                              "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => $data.alert_form_data.alert_grade = $event),
                              localdata: $data.grades
                            }, null, 8, ["modelValue", "localdata"])
                          ]),
                          _: 1
                          /* STABLE */
                        }),
                        vue.createVNode(_component_uni_forms_item, { label: "å‘Šè­¦å†…å®¹" }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(_component_uni_easyinput, {
                              type: "textarea",
                              modelValue: $data.alert_form_data.alert_content,
                              "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => $data.alert_form_data.alert_content = $event),
                              placeholder: "è¯·è¾“å…¥å‘Šè­¦å†…å®¹"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                          /* STABLE */
                        })
                      ]),
                      _: 1
                      /* STABLE */
                    }, 8, ["modelValue"]),
                    vue.createElementVNode("button", {
                      type: "primary",
                      onClick: _cache[21] || (_cache[21] = ($event) => $options.submit("alert_form"))
                    }, "æäº¤")
                  ])
                ]),
                _: 1
                /* STABLE */
              },
              512
              /* NEED_PATCH */
            )
          ])
        ])
      ],
      64
      /* STABLE_FRAGMENT */
    );
  }
  if (typeof block0 === "function")
    block0(_sfc_main$R);
  const PagesTaskTaskDetailTaskDetail = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$Q], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/task/task_detail/task_detail.vue"]]);
  const _sfc_main$Q = {
    name: "UniGridItem",
    inject: ["grid"],
    props: {
      index: {
        type: Number,
        default: 0
      }
    },
    data() {
      return {
        column: 0,
        showBorder: true,
        square: true,
        highlight: true,
        left: 0,
        top: 0,
        openNum: 2,
        width: 0,
        borderColor: "#e5e5e5"
      };
    },
    created() {
      this.column = this.grid.column;
      this.showBorder = this.grid.showBorder;
      this.square = this.grid.square;
      this.highlight = this.grid.highlight;
      this.top = this.hor === 0 ? this.grid.hor : this.hor;
      this.left = this.ver === 0 ? this.grid.ver : this.ver;
      this.borderColor = this.grid.borderColor;
      this.grid.children.push(this);
      this.width = this.grid.width;
    },
    beforeDestroy() {
      this.grid.children.forEach((item, index) => {
        if (item === this) {
          this.grid.children.splice(index, 1);
        }
      });
    },
    methods: {
      _onClick() {
        this.grid.change({
          detail: {
            index: this.index
          }
        });
      }
    }
  };
  function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
    return $data.width ? (vue.openBlock(), vue.createElementBlock(
      "view",
      {
        key: 0,
        style: vue.normalizeStyle("width:" + $data.width + ";" + ($data.square ? "height:" + $data.width : "")),
        class: "uni-grid-item"
      },
      [
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass([{ "uni-grid-item--border": $data.showBorder, "uni-grid-item--border-top": $data.showBorder && $props.index < $data.column, "uni-highlight": $data.highlight }, "uni-grid-item__box"]),
            style: vue.normalizeStyle({ "border-right-color": $data.borderColor, "border-bottom-color": $data.borderColor, "border-top-color": $data.borderColor }),
            onClick: _cache[0] || (_cache[0] = (...args) => $options._onClick && $options._onClick(...args))
          },
          [
            vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ],
          6
          /* CLASS, STYLE */
        )
      ],
      4
      /* STYLE */
    )) : vue.createCommentVNode("v-if", true);
  }
  const __easycom_0 = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$P], ["__scopeId", "data-v-7a807eb7"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-grid/components/uni-grid-item/uni-grid-item.vue"]]);
  const _sfc_main$P = {
    name: "UniGrid",
    emits: ["change"],
    props: {
      // æ¯åˆ—æ˜¾ç¤ºä¸ªæ•°
      column: {
        type: Number,
        default: 3
      },
      // æ˜¯å¦æ˜¾ç¤ºè¾¹æ¡†
      showBorder: {
        type: Boolean,
        default: true
      },
      // è¾¹æ¡†é¢œè‰²
      borderColor: {
        type: String,
        default: "#D2D2D2"
      },
      // æ˜¯å¦æ­£æ–¹å½¢æ˜¾ç¤º,é»˜è®¤ä¸º true
      square: {
        type: Boolean,
        default: true
      },
      highlight: {
        type: Boolean,
        default: true
      }
    },
    provide() {
      return {
        grid: this
      };
    },
    data() {
      const elId = `Uni_${Math.ceil(Math.random() * 1e6).toString(36)}`;
      return {
        elId,
        width: 0
      };
    },
    created() {
      this.children = [];
    },
    mounted() {
      this.$nextTick(() => {
        this.init();
      });
    },
    methods: {
      init() {
        setTimeout(() => {
          this._getSize((width) => {
            this.children.forEach((item, index) => {
              item.width = width;
            });
          });
        }, 50);
      },
      change(e2) {
        this.$emit("change", e2);
      },
      _getSize(fn) {
        uni.createSelectorQuery().in(this).select(`#${this.elId}`).boundingClientRect().exec((ret) => {
          this.width = parseInt((ret[0].width - 1) / this.column) + "px";
          fn(this.width);
        });
      }
    }
  };
  function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-grid-wrap" }, [
      vue.createElementVNode("view", {
        id: $data.elId,
        ref: "uni-grid",
        class: vue.normalizeClass(["uni-grid", { "uni-grid--border": $props.showBorder }]),
        style: vue.normalizeStyle({ "border-left-color": $props.borderColor })
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 14, ["id"])
    ]);
  }
  const __easycom_1$1 = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$O], ["__scopeId", "data-v-07acefee"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-grid/components/uni-grid/uni-grid.vue"]]);
  const _sfc_main$O = {
    name: "UniSection",
    emits: ["click"],
    props: {
      type: {
        type: String,
        default: ""
      },
      title: {
        type: String,
        required: true,
        default: ""
      },
      titleFontSize: {
        type: String,
        default: "14px"
      },
      titleColor: {
        type: String,
        default: "#333"
      },
      subTitle: {
        type: String,
        default: ""
      },
      subTitleFontSize: {
        type: String,
        default: "12px"
      },
      subTitleColor: {
        type: String,
        default: "#999"
      },
      padding: {
        type: [Boolean, String],
        default: false
      }
    },
    computed: {
      _padding() {
        if (typeof this.padding === "string") {
          return this.padding;
        }
        return this.padding ? "10px" : "";
      }
    },
    watch: {
      title(newVal) {
        if (uni.report && newVal !== "") {
          uni.report("title", newVal);
        }
      }
    },
    methods: {
      onClick() {
        this.$emit("click");
      }
    }
  };
  function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-section" }, [
      vue.createElementVNode("view", {
        class: "uni-section-header",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
      }, [
        $props.type ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 0,
            class: vue.normalizeClass(["uni-section-header__decoration", $props.type])
          },
          null,
          2
          /* CLASS */
        )) : vue.renderSlot(_ctx.$slots, "decoration", { key: 1 }, void 0, true),
        vue.createElementVNode("view", { class: "uni-section-header__content" }, [
          vue.createElementVNode(
            "text",
            {
              style: vue.normalizeStyle({ "font-size": $props.titleFontSize, "color": $props.titleColor }),
              class: vue.normalizeClass(["uni-section__content-title", { "distraction": !$props.subTitle }])
            },
            vue.toDisplayString($props.title),
            7
            /* TEXT, CLASS, STYLE */
          ),
          $props.subTitle ? (vue.openBlock(), vue.createElementBlock(
            "text",
            {
              key: 0,
              style: vue.normalizeStyle({ "font-size": $props.subTitleFontSize, "color": $props.subTitleColor }),
              class: "uni-section-header__content-sub"
            },
            vue.toDisplayString($props.subTitle),
            5
            /* TEXT, STYLE */
          )) : vue.createCommentVNode("v-if", true)
        ]),
        vue.createElementVNode("view", { class: "uni-section-header__slot-right" }, [
          vue.renderSlot(_ctx.$slots, "right", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode(
        "view",
        {
          class: "uni-section-content",
          style: vue.normalizeStyle({ padding: $options._padding })
        },
        [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ],
        4
        /* STYLE */
      )
    ]);
  }
  const __easycom_2 = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$N], ["__scopeId", "data-v-637fd36b"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-section/components/uni-section/uni-section.vue"]]);
  const _sfc_main$N = {
    props: {
      urls: {
        type: Array,
        required: true,
        default: () => {
          return [];
        }
      }
    },
    data() {
      return {
        show: false,
        current: 0,
        //å½“å‰é¡µ
        scale: 1,
        isZooming: false
        // æ˜¯å¦å¤„äºŽç¼©æ”¾çŠ¶æ€
      };
    },
    methods: {
      getFileName(url) {
        const fileName = url.split("/").pop();
        const nameWithoutExtension = fileName.includes(".") ? fileName.substring(0, fileName.lastIndexOf(".")) : fileName;
        return nameWithoutExtension;
      },
      //æ‰“å¼€
      open(current, index) {
        this.current = index;
        this.show = true;
        this.$emit("open");
      },
      //å…³é—­
      close() {
        if (!this.isZooming) {
          this.show = false;
          this.current = 0;
          this.$emit("close");
        }
      },
      //å›¾ç‰‡æ”¹å˜
      swiperChange(e2) {
        this.current = e2.detail.current;
      },
      //ç›‘å¬é•¿æŒ‰
      onLongpress(e2) {
        this.$emit("onLongpress", e2);
      },
      handleTouchStart() {
        this.isZooming = true;
      },
      handleTouchEnd() {
        this.isZooming = false;
      }
    }
  };
  function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
    return $data.show ? (vue.openBlock(), vue.createElementBlock("view", {
      key: 0,
      class: "previewImage",
      onClick: _cache[3] || (_cache[3] = (...args) => $options.close && $options.close(...args))
    }, [
      $props.urls.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "page"
      }, [
        vue.createElementVNode("view", null, [
          vue.createElementVNode(
            "text",
            { class: "text" },
            vue.toDisplayString($data.current + 1) + " / " + vue.toDisplayString($props.urls.length),
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode("view", { style: { "height": "10px" } }),
        vue.createElementVNode("view", null, [
          vue.createElementVNode(
            "text",
            { class: "text" },
            vue.toDisplayString($options.getFileName($props.urls[$data.current])),
            1
            /* TEXT */
          )
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("swiper", {
        class: "swiper",
        current: $data.current,
        onChange: _cache[0] || (_cache[0] = (...args) => $options.swiperChange && $options.swiperChange(...args)),
        onTouchstart: _cache[1] || (_cache[1] = (...args) => $options.handleTouchStart && $options.handleTouchStart(...args)),
        onTouchend: _cache[2] || (_cache[2] = (...args) => $options.handleTouchEnd && $options.handleTouchEnd(...args))
      }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($props.urls, (item, index) => {
            return vue.openBlock(), vue.createElementBlock("swiper-item", { key: index }, [
              vue.createElementVNode("movable-area", {
                class: "movable-area",
                "scale-area": ""
              }, [
                vue.createElementVNode("movable-view", {
                  class: "movable-view",
                  direction: "all",
                  inertia: true,
                  damping: "100",
                  scale: "true",
                  "scale-min": "1",
                  "scale-max": "4",
                  "scale-value": $data.scale
                }, [
                  vue.createElementVNode("scroll-view", {
                    "scroll-y": "true",
                    class: "uni-scroll-view"
                  }, [
                    vue.createElementVNode("view", { class: "scroll-view" }, [
                      (vue.openBlock(), vue.createElementBlock("image", {
                        key: index,
                        class: "image",
                        src: item,
                        mode: "widthFix",
                        onLongpress: ($event) => $options.onLongpress(item)
                      }, null, 40, ["src", "onLongpress"]))
                    ])
                  ])
                ], 8, ["scale-value"])
              ])
            ]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ], 40, ["current"])
    ])) : vue.createCommentVNode("v-if", true);
  }
  const __easycom_3 = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$M], ["__scopeId", "data-v-fdd21252"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/q-previewImage/components/q-previewImage/q-previewImage.vue"]]);
  const _sfc_main$M = {
    name: "ysh-file-manager",
    props: {},
    data() {
      return {};
    },
    methods: {
      _openFile() {
        this.qxcz();
      },
      qxcz() {
        plus.android.requestPermissions(["android.permission.READ_EXTERNAL_STORAGE"], (e2) => {
          if (e2.deniedAlways.length > 0) {
            uni.showToast({
              title: "æ‚¨æ‹’ç»äº†å­˜å‚¨æƒé™ï¼Œè¯·åŽ»è®¾ç½®-åº”ç”¨å¼€å¯å­˜å‚¨æƒé™ï¼",
              icon: "none",
              duration: 2e3
            });
          }
          if (e2.deniedPresent.length > 0) {
            plus.android.requestPermissions(["android.permission.READ_EXTERNAL_STORAGE"]);
          }
          if (e2.granted.length > 0) {
            this._openFileTemp();
          }
        }, function(e2) {
          formatAppLog("log", "at components/ysh-file-manager/ysh-file-manager.vue:41", "R12133313221" + JSON.stringify(e2));
        });
      },
      _openFileTemp() {
        let CODE_REQUEST = 1e3;
        if (plus.os.name.toLowerCase() != "android") {
          uni.showModal({
            title: "æç¤º",
            content: "ä»…æ”¯æŒAndroidå¹³å°ï¼",
            success: function(res) {
            }
          });
          return false;
        }
        let that = this;
        let main2 = plus.android.runtimeMainActivity();
        let Intent = plus.android.importClass("android.content.Intent");
        let fileIntent = new Intent(Intent.ACTION_GET_CONTENT);
        fileIntent.setType("*/*");
        fileIntent.addCategory(Intent.CATEGORY_OPENABLE);
        main2.onActivityResult = function(requestCode, resultCode, data) {
          let Activity = plus.android.importClass("android.app.Activity");
          let ContentUris = plus.android.importClass("android.content.ContentUris");
          plus.android.importClass("android.database.Cursor");
          let Uri = plus.android.importClass("android.net.Uri");
          let Build = plus.android.importClass("android.os.Build");
          let Environment = plus.android.importClass("android.os.Environment");
          let DocumentsContract = plus.android.importClass("android.provider.DocumentsContract");
          let MediaStore = plus.android.importClass("android.provider.MediaStore");
          let contentResolver = main2.getContentResolver();
          plus.android.importClass(contentResolver);
          let path = "";
          let size = "";
          if (resultCode == Activity.RESULT_OK) {
            let uri = data.getData();
            if ("file" == uri.getScheme().toLowerCase()) {
              path = uri.getPath();
            } else {
              if (Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT) {
                path = getPath(this, uri);
                let FileInputStream = plus.android.importClass("java.io.FileInputStream");
                let fileSize = new FileInputStream(path);
                size = fileSize.available();
                if (size == 0)
                  ;
                else if (size < 1024)
                  ;
                else if (size < 1048576) {
                  (size / 1024).toFixed(2) + "KB";
                } else if (size < 1073741824) {
                  (size / 1048576).toFixed(2) + "MB";
                } else {
                  (size / 1073741824).toFixed(2) + "GB";
                }
              } else {
                path = getRealPathFromURI(uri);
              }
            }
            that.$emit("result", {
              path,
              size
            });
          }
          function getPath(context, uri) {
            let isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
            let scheme = uri.getScheme().toLowerCase();
            if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {
              if (isExternalStorageDocument(uri)) {
                let docId = DocumentsContract.getDocumentId(uri);
                let split = docId.split(":");
                let type = split[0];
                if ("primary" == type.toLowerCase()) {
                  return Environment.getExternalStorageDirectory() + "/" + split[1];
                } else {
                  return "/storage/" + type + "/" + split[1];
                }
              } else if (isDownloadsDocument(uri)) {
                let id = DocumentsContract.getDocumentId(uri);
                if (id.indexOf(":") != -1) {
                  let split = id.split(":");
                  return split[1];
                } else {
                  let contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), id);
                  return getDataColumn(context, contentUri, null, null);
                }
              } else if (isMediaDocument(uri)) {
                let docId = DocumentsContract.getDocumentId(uri);
                let split = docId.split(":");
                let type = split[0];
                let contentUri = null;
                if ("image" == type.toLowerCase()) {
                  contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                } else if ("video" == type.toLowerCase()) {
                  contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
                } else if ("audio" == type.toLowerCase()) {
                  contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
                } else if ("document" == type.toLowerCase()) {
                  contentUri = MediaStore.Files.getContentUri("external");
                }
                let selection = "_id=?";
                let selectionArgs = [split[1]];
                return getDataColumn(context, contentUri, selection, selectionArgs);
              }
            } else if ("content" == scheme) {
              return getDataColumn(context, uri, null, null);
            } else if ("file" == scheme) {
              return uri.getPath();
            }
          }
          function getRealPathFromURI(uri) {
            let res = null;
            let proj = [MediaStore.Images.Media.DATA];
            let cursor = contentResolver.query(uri, proj, null, null, null);
            if (null != cursor && cursor.moveToFirst()) {
              let column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
              res = cursor.getString(column_index);
              cursor.close();
            }
            return res;
          }
          function getDataColumn(context, uri, selection, selectionArgs) {
            let cursor = null;
            let column = "_data";
            let projection = [column];
            cursor = contentResolver.query(uri, projection, selection, selectionArgs, null);
            if (cursor != null && cursor.moveToFirst()) {
              let column_index = cursor.getColumnIndexOrThrow(column);
              return cursor.getString(column_index);
            } else {
              return "";
            }
          }
          function isExternalStorageDocument(uri) {
            return "com.android.externalstorage.documents" == uri.getAuthority() ? true : false;
          }
          function isDownloadsDocument(uri) {
            return "com.android.providers.downloads.documents" == uri.getAuthority() ? true : false;
          }
          function isMediaDocument(uri) {
            return "com.android.providers.media.documents" == uri.getAuthority() ? true : false;
          }
        };
        main2.startActivityForResult(fileIntent, CODE_REQUEST);
      }
    }
  };
  function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view");
  }
  const __easycom_5 = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$L], ["__file", "E:/ä»£ç /new/zk_uniapp/components/ysh-file-manager/ysh-file-manager.vue"]]);
  let platform = "other";
  const _sfc_main$L = {
    name: "UniFab",
    emits: ["fabClick", "trigger"],
    props: {
      pattern: {
        type: Object,
        default() {
          return {};
        }
      },
      horizontal: {
        type: String,
        default: "left"
      },
      vertical: {
        type: String,
        default: "bottom"
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      content: {
        type: Array,
        default() {
          return [];
        }
      },
      show: {
        type: Boolean,
        default: false
      },
      popMenu: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        fabShow: false,
        isShow: false,
        isAndroidNvue: platform === "android",
        styles: {
          color: "#3c3e49",
          selectedColor: "#007AFF",
          backgroundColor: "#fff",
          buttonColor: "#007AFF",
          iconColor: "#fff",
          icon: "plusempty"
        }
      };
    },
    computed: {
      contentWidth(e2) {
        return (this.content.length + 1) * 55 + 15 + "px";
      },
      contentWidthMin() {
        return "55px";
      },
      // åŠ¨æ€è®¡ç®—å®½åº¦
      boxWidth() {
        return this.getPosition(3, "horizontal");
      },
      // åŠ¨æ€è®¡ç®—é«˜åº¦
      boxHeight() {
        return this.getPosition(3, "vertical");
      },
      // è®¡ç®—å·¦ä¸‹ä½ç½®
      leftBottom() {
        return this.getPosition(0, "left", "bottom");
      },
      // è®¡ç®—å³ä¸‹ä½ç½®
      rightBottom() {
        return this.getPosition(0, "right", "bottom");
      },
      // è®¡ç®—å·¦ä¸Šä½ç½®
      leftTop() {
        return this.getPosition(0, "left", "top");
      },
      rightTop() {
        return this.getPosition(0, "right", "top");
      },
      flexDirectionStart() {
        return this.getPosition(1, "vertical", "top");
      },
      flexDirectionEnd() {
        return this.getPosition(1, "vertical", "bottom");
      },
      horizontalLeft() {
        return this.getPosition(2, "horizontal", "left");
      },
      horizontalRight() {
        return this.getPosition(2, "horizontal", "right");
      },
      // è®¡ç®— nvue bottom
      nvueBottom() {
        uni.getSystemInfoSync().windowBottom;
        return 30;
      }
    },
    watch: {
      pattern: {
        handler(val, oldVal) {
          this.styles = Object.assign({}, this.styles, val);
        },
        deep: true
      }
    },
    created() {
      this.isShow = this.show;
      if (this.top === 0) {
        this.fabShow = true;
      }
      this.styles = Object.assign({}, this.styles, this.pattern);
    },
    methods: {
      _onClick() {
        this.$emit("fabClick");
        if (!this.popMenu) {
          return;
        }
        this.isShow = !this.isShow;
      },
      open() {
        this.isShow = true;
      },
      close() {
        this.isShow = false;
      },
      /**
       * æŒ‰é’®ç‚¹å‡»äº‹ä»¶
       */
      _onItemClick(index, item) {
        if (!this.isShow) {
          return;
        }
        this.$emit("trigger", {
          index,
          item
        });
      },
      /**
       * èŽ·å– ä½ç½®ä¿¡æ¯
       */
      getPosition(types2, paramA, paramB) {
        if (types2 === 0) {
          return this.horizontal === paramA && this.vertical === paramB;
        } else if (types2 === 1) {
          return this.direction === paramA && this.vertical === paramB;
        } else if (types2 === 2) {
          return this.direction === paramA && this.horizontal === paramB;
        } else {
          return this.isShow && this.direction === paramA ? this.contentWidth : this.contentWidthMin;
        }
      }
    }
  };
  function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_icons = resolveEasycom(vue.resolveDynamicComponent("uni-icons"), __easycom_0$5);
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-cursor-point" }, [
      $props.popMenu && ($options.leftBottom || $options.rightBottom || $options.leftTop || $options.rightTop) && $props.content.length > 0 ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 0,
          class: vue.normalizeClass([{
            "uni-fab--leftBottom": $options.leftBottom,
            "uni-fab--rightBottom": $options.rightBottom,
            "uni-fab--leftTop": $options.leftTop,
            "uni-fab--rightTop": $options.rightTop
          }, "uni-fab"]),
          style: vue.normalizeStyle($options.nvueBottom)
        },
        [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass([{
                "uni-fab__content--left": $props.horizontal === "left",
                "uni-fab__content--right": $props.horizontal === "right",
                "uni-fab__content--flexDirection": $props.direction === "vertical",
                "uni-fab__content--flexDirectionStart": $options.flexDirectionStart,
                "uni-fab__content--flexDirectionEnd": $options.flexDirectionEnd,
                "uni-fab__content--other-platform": !$data.isAndroidNvue
              }, "uni-fab__content"]),
              style: vue.normalizeStyle({ width: $options.boxWidth, height: $options.boxHeight, backgroundColor: $data.styles.backgroundColor }),
              elevation: "5"
            },
            [
              $options.flexDirectionStart || $options.horizontalLeft ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 0,
                class: "uni-fab__item uni-fab__item--first"
              })) : vue.createCommentVNode("v-if", true),
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList($props.content, (item, index) => {
                  return vue.openBlock(), vue.createElementBlock("view", {
                    key: index,
                    class: vue.normalizeClass([{ "uni-fab__item--active": $data.isShow }, "uni-fab__item"]),
                    onClick: ($event) => $options._onItemClick(index, item)
                  }, [
                    vue.createElementVNode("image", {
                      src: item.active ? item.selectedIconPath : item.iconPath,
                      class: "uni-fab__item-image",
                      mode: "aspectFit"
                    }, null, 8, ["src"]),
                    vue.createElementVNode(
                      "text",
                      {
                        class: "uni-fab__item-text",
                        style: vue.normalizeStyle({ color: item.active ? $data.styles.selectedColor : $data.styles.color })
                      },
                      vue.toDisplayString(item.text),
                      5
                      /* TEXT, STYLE */
                    )
                  ], 10, ["onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              )),
              $options.flexDirectionEnd || $options.horizontalRight ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 1,
                class: "uni-fab__item uni-fab__item--first"
              })) : vue.createCommentVNode("v-if", true)
            ],
            6
            /* CLASS, STYLE */
          )
        ],
        6
        /* CLASS, STYLE */
      )) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode(
        "view",
        {
          class: vue.normalizeClass([{
            "uni-fab__circle--leftBottom": $options.leftBottom,
            "uni-fab__circle--rightBottom": $options.rightBottom,
            "uni-fab__circle--leftTop": $options.leftTop,
            "uni-fab__circle--rightTop": $options.rightTop,
            "uni-fab__content--other-platform": !$data.isAndroidNvue
          }, "uni-fab__circle uni-fab__plus"]),
          style: vue.normalizeStyle({ "background-color": $data.styles.buttonColor, "bottom": $options.nvueBottom }),
          onClick: _cache[0] || (_cache[0] = (...args) => $options._onClick && $options._onClick(...args))
        },
        [
          vue.createVNode(_component_uni_icons, {
            class: vue.normalizeClass(["fab-circle-icon", { "uni-fab__plus--active": $data.isShow && $props.content.length > 0 }]),
            type: $data.styles.icon,
            color: $data.styles.iconColor,
            size: "32"
          }, null, 8, ["type", "color", "class"]),
          vue.createCommentVNode(` <view class="fab-circle-v"  :class="{'uni-fab__plus--active': isShow && content.length > 0}"></view>\r
			<view class="fab-circle-h" :class="{'uni-fab__plus--active': isShow  && content.length > 0}"></view> `)
        ],
        6
        /* CLASS, STYLE */
      )
    ]);
  }
  const __easycom_6 = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$K], ["__scopeId", "data-v-85f34dfc"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-fab/components/uni-fab/uni-fab.vue"]]);
  const _sfc_main$K = {
    data() {
      return {
        context: null,
        currentTime: 0,
        duration: 100,
        status: false
      };
    },
    props: {
      url: String,
      activeColor: {
        type: String,
        default: "#0E7EFC"
      },
      startPic: String,
      endPic: String,
      audioId: [String, Number]
    },
    created() {
      this.context = uni.createInnerAudioContext();
      this.context.src = this.url;
      this.onTimeUpdate();
      this.onCanplay();
      this.onEnded();
      uni.$on("stop", (id) => {
        if (id && id != this.audioId) {
          this.context.stop();
          this.status = false;
        } else if (!id) {
          this.context.stop();
          this.status = false;
        }
      });
    },
    methods: {
      start(id) {
        if (this.status) {
          this.context.pause();
          this.status = !this.status;
        } else {
          uni.$emit("stop", id);
          this.context.play();
          this.status = !this.status;
        }
      },
      onCanplay() {
        this.context.onCanplay(() => {
          this.context.duration;
          setTimeout(() => {
            this.duration = this.context.duration;
          }, 1e3);
        });
      },
      onTimeUpdate() {
        this.context.onTimeUpdate(() => {
          if (!Number.isFinite(this.context.duration)) {
            this.duration = this.context.currentTime + 10;
            this.currentTime = this.context.currentTime;
          } else {
            this.duration = this.context.duration;
            this.currentTime = this.context.currentTime;
          }
        });
      },
      onEnded() {
        this.context.onEnded(() => {
          this.status = false;
          this.currentTime = 0;
        });
      },
      changeAudio(e2) {
        let paused = this.context.paused;
        this.context.pause();
        this.context.seek(e2.detail.value);
        if (!paused) {
          this.context.play();
        }
      },
      getTime(time) {
        let m2 = parseInt(time / 60);
        let s2 = time % 60;
        return this.towNum(m2) + ":" + this.towNum(s2);
      },
      towNum(num) {
        if (num >= 10) {
          return num;
        } else {
          return "0" + num;
        }
      }
    }
  };
  function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      vue.Fragment,
      null,
      [
        vue.createCommentVNode(" éŸ³é¢‘æ’­æ”¾å™¨ç»„ä»¶ "),
        $props.url ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "flex justify-between align-center audio"
        }, [
          vue.createElementVNode("view", {
            class: "mr-3",
            onClick: _cache[0] || (_cache[0] = ($event) => $options.start($props.audioId))
          }, [
            vue.withDirectives(vue.createElementVNode("image", {
              src: $props.startPic,
              class: "icon"
            }, null, 8, ["src"]), [
              [vue.vShow, !$data.status]
            ]),
            vue.withDirectives(vue.createElementVNode("image", {
              src: $props.endPic,
              class: "icon"
            }, null, 8, ["src"]), [
              [vue.vShow, $data.status]
            ])
          ]),
          vue.createElementVNode("view", { class: "flex-1" }, [
            vue.createElementVNode("slider", {
              onChange: _cache[1] || (_cache[1] = (...args) => $options.changeAudio && $options.changeAudio(...args)),
              activeColor: $props.activeColor,
              min: 0,
              max: $data.duration.toFixed(0),
              value: $data.currentTime.toFixed(0),
              step: 0.1
            }, null, 40, ["activeColor", "max", "value"])
          ]),
          vue.createElementVNode(
            "view",
            { class: "ml-3" },
            vue.toDisplayString($options.getTime(Math.round($data.currentTime))),
            1
            /* TEXT */
          )
        ])) : vue.createCommentVNode("v-if", true)
      ],
      2112
      /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
    );
  }
  const freeAudio = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$J], ["__scopeId", "data-v-615c0603"], ["__file", "E:/ä»£ç /new/zk_uniapp/components/chengpeng-audio/free-audio.vue"]]);
  const _imports_0$9 = "/static/icon/take_video.png";
  const _imports_1$3 = "/static/icon/audio.png";
  const _sfc_main$J = {
    components: { freeAudio, yshFileManager: __easycom_5 },
    data() {
      return {
        missionId: "",
        fileInfo: [],
        pattern: {
          color: "#7A7E83",
          backgroundColor: "#fff",
          selectedColor: "#007AFF",
          buttonColor: "#007AFF",
          iconColor: "#fff"
        },
        horizontal: "right",
        vertical: "bottom",
        direction: "horizontal",
        isFullScreen: false,
        videoPlay: false,
        videoUrl: "",
        audioUrl: "",
        imgPath: [
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
          // '../../../../static/images/taiwan_map.jpg',
        ],
        videoPath: [
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
          // '../../../../static/videos/VID20241104093724.mp4',
        ],
        audioPath: [],
        content: [
          {
            iconPath: "../../../../static/icon/å›¾ç‰‡-é€‰ä¸­.png",
            selectedIconPath: "../../../../static/icon/å›¾ç‰‡-é€‰ä¸­.png",
            text: "ä¸Šä¼ å›¾ç‰‡",
            active: false
          },
          {
            iconPath: "../../../../static/icon/video.png",
            selectedIconPath: "../../../../static/icon/video.png",
            text: "ä¸Šä¼ è§†é¢‘",
            active: false
          },
          {
            iconPath: "../../../../static/icon/document_select.png",
            selectedIconPath: "../../../../static/icon/document_select.png",
            text: "å…¶ä»–æ–‡ä»¶",
            active: false
          }
        ],
        video_src: "",
        image_src: [],
        FileTypes: [
          { type: "å›¾ç‰‡", iconName: "image" },
          { type: "è§†é¢‘", iconName: "camera" },
          { type: "éŸ³é¢‘", iconName: "mic" }
        ],
        videoContext: uni.createVideoContext("myVideo", this)
        // è¿™ä¸ªæ˜¯å®žä¾‹å¯¹è±¡
      };
    },
    mounted() {
      this.initializeDocuments();
    },
    onLoad(options) {
      if (options.missionId) {
        this.missionId = options.missionId;
      } else {
        formatAppLog("error", "at pages/task/task_detail/document/document.vue:149", "æ²¡æœ‰ä¼ é€’ç±»åž‹å‚æ•°");
      }
    },
    methods: {
      initializeDocuments() {
        uni.showLoading({
          title: "æ­£åœ¨åŠ è½½æ–‡ä»¶",
          mask: true
        });
        getMissionFileById(this.missionId, 1, 100).then((res) => {
          formatAppLog("log", "at pages/task/task_detail/document/document.vue:159", "res", res);
          this.fileInfo = res.data.missionFiles.records;
          uni.hideLoading();
          if (this.fileInfo != null && this.fileInfo != "") {
            this.fileInfo.forEach((item, index) => {
              getFileUrl(item.id).then((res2) => {
                switch (item.fileType) {
                  case "mp3":
                    this.audioPath.push(res2.data);
                    break;
                  case "png":
                    this.imgPath.push(res2.data);
                    break;
                  case "jpg":
                    this.imgPath.push(res2.data);
                    break;
                  case "mp4":
                    this.videoPath.push(res2.data);
                    break;
                }
              });
            });
          }
        });
      },
      uploadFile() {
        this.$refs.filemanager._openFile();
      },
      getFileName(url) {
        const fileName = url.split("/").pop();
        const nameWithoutExtension = fileName.includes(".") ? fileName.substring(0, fileName.lastIndexOf(".")) : fileName;
        return nameWithoutExtension;
      },
      preview(url, index) {
        this.$refs.previewImage.open(url, index);
      },
      screenChange(e2) {
        this.isFullScreen = e2.detail.fullScreen;
        if (!this.isFullScreen) {
          this.videoPlay = false;
          this.videoContext.stop();
        }
      },
      // è§¦å‘å…¨å±æ’­æ”¾çš„ç‚¹å‡»äº‹ä»¶
      async videoShow(item) {
        this.videoPlay = true;
        this.videoUrl = item;
        this.videoContext.requestFullScreen({ direction: 0 });
        this.videoContext.play();
      },
      openVideo() {
        this.videoPlay = true;
      },
      openAudioPopup(index) {
        this.$refs.audioPopup.open();
        this.audioUrl = this.audioPath[index];
        formatAppLog("log", "at pages/task/task_detail/document/document.vue:226", "url", this.audioPath);
      },
      clickMask() {
        this.$refs.audioPopup.close();
        uni.$emit("stop");
      },
      trigger(e2) {
        if (e2.item.text === "ä¸Šä¼ å›¾ç‰‡") {
          this.uploadImage();
        } else if (e2.item.text === "ä¸Šä¼ è§†é¢‘") {
          this.uploadVideo();
        } else if (e2.item.text === "å…¶ä»–æ–‡ä»¶") {
          this.uploadFile();
        }
      },
      handleResult(fileInfo) {
        formatAppLog("log", "at pages/task/task_detail/document/document.vue:242", "fileInfoPath", fileInfo.path);
        uni.uploadFile({
          url: `http://139.196.11.210:8500/communicate/mission/upload/file`,
          filePath: fileInfo.path,
          name: "files",
          formData: {
            "latitude": "12",
            "longitude": "123",
            "missionId": this.missionId
          },
          header: {
            "Content-Type": "multipart/form-data;",
            "Authorization": "Bearer " + uni.getStorageSync("token")
          },
          success: (uploadFileRes) => {
            const res = JSON.parse(uploadFileRes.data);
            if (res.code === 200) {
              uni.showToast({
                title: "æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼",
                //å°†å€¼è®¾ç½®ä¸º success æˆ–è€…ç›´æŽ¥ä¸ç”¨å†™iconè¿™ä¸ªå‚æ•°
                icon: "success",
                //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                duration: 2e3
              });
            } else {
              uni.showToast({
                title: "æ–‡ä»¶ä¸Šä¼ å¤±è´¥ï¼",
                icon: "none",
                //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                duration: 2e3
              });
            }
            formatAppLog("log", "at pages/task/task_detail/document/document.vue:274", uploadFileRes.data);
          }
        });
      },
      uploadVideo: function() {
        var self2 = this;
        uni.chooseVideo({
          sourceType: ["camera", "album"],
          success: function(res) {
            const tempFilePath = res.tempFilePath;
            formatAppLog("log", "at pages/task/task_detail/document/document.vue:284", "tempFilePath", tempFilePath);
            formatAppLog("log", "at pages/task/task_detail/document/document.vue:285", "id", self2.missionId);
            uni.uploadFile({
              url: `http://139.196.11.210:8500/communicate/mission/upload/file`,
              filePath: tempFilePath,
              name: "files",
              formData: {
                "latitude": "12",
                "longitude": "123",
                "missionId": self2.missionId
              },
              header: {
                "Content-Type": "multipart/form-data;",
                "Authorization": "Bearer " + uni.getStorageSync("token")
              },
              success: (uploadFileRes) => {
                const res2 = JSON.parse(uploadFileRes.data);
                if (res2.code === 200) {
                  uni.showToast({
                    title: "è§†é¢‘ä¸Šä¼ æˆåŠŸï¼",
                    //å°†å€¼è®¾ç½®ä¸º success æˆ–è€…ç›´æŽ¥ä¸ç”¨å†™iconè¿™ä¸ªå‚æ•°
                    icon: "success",
                    //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                    duration: 2e3
                  });
                } else {
                  uni.showToast({
                    title: "è§†é¢‘ä¸Šä¼ å¤±è´¥ï¼",
                    icon: "none",
                    //æ˜¾ç¤ºæŒç»­æ—¶é—´ä¸º 2ç§’
                    duration: 2e3
                  });
                }
                formatAppLog("log", "at pages/task/task_detail/document/document.vue:318", uploadFileRes.data);
              }
            });
          }
        });
      },
      uploadImage: function() {
        var self2 = this;
        uni.chooseImage({
          count: 6,
          //é»˜è®¤9
          sizeType: ["original", "compressed"],
          //å¯ä»¥æŒ‡å®šæ˜¯åŽŸå›¾è¿˜æ˜¯åŽ‹ç¼©å›¾ï¼Œé»˜è®¤äºŒè€…éƒ½æœ‰
          sourceType: ["album", "camera"],
          success: function(res) {
            let ok = 0;
            let index = 0;
            const length = res.tempFilePaths.length;
            for (const tempFilePath of res.tempFilePaths) {
              uni.uploadFile({
                url: "http://139.196.11.210:8500/communicate/mission/upload/file",
                filePath: tempFilePath,
                name: "files",
                formData: {
                  "latitude": "12",
                  "longitude": "123",
                  "missionId": self2.missionId
                },
                header: {
                  "Content-Type": "multipart/form-data;",
                  "Authorization": "Bearer " + uni.getStorageSync("token")
                },
                success: (uploadFileRes) => {
                  index = index + 1;
                  if (uploadFileRes.statusCode === 200) {
                    ok = ok + 1;
                  }
                  if (ok === length) {
                    uni.showToast({
                      title: "ä¸Šä¼ æˆåŠŸï¼",
                      icon: "success",
                      duration: 2e3
                    });
                  }
                  if (index === length && ok < length) {
                    const fail = length - ok;
                    uni.showToast({
                      title: fail + "å¼ ä¸Šä¼ å¤±è´¥ï¼",
                      icon: "none",
                      duration: 2e3
                    });
                  }
                }
              });
            }
          }
        });
      }
    }
  };
  function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_grid_item = resolveEasycom(vue.resolveDynamicComponent("uni-grid-item"), __easycom_0);
    const _component_uni_grid = resolveEasycom(vue.resolveDynamicComponent("uni-grid"), __easycom_1$1);
    const _component_uni_section = resolveEasycom(vue.resolveDynamicComponent("uni-section"), __easycom_2);
    const _component_q_previewImage = resolveEasycom(vue.resolveDynamicComponent("q-previewImage"), __easycom_3);
    const _component_free_audio = vue.resolveComponent("free-audio");
    const _component_uni_popup = resolveEasycom(vue.resolveDynamicComponent("uni-popup"), __easycom_2$1);
    const _component_ysh_file_manager = resolveEasycom(vue.resolveDynamicComponent("ysh-file-manager"), __easycom_5);
    const _component_uni_fab = resolveEasycom(vue.resolveDynamicComponent("uni-fab"), __easycom_6);
    return vue.openBlock(), vue.createElementBlock("view", { style: { "background": "#fff" } }, [
      vue.createElementVNode("view", { style: { "padding": "0 0 10px 7px", "box-sizing": "border-box" } }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($data.FileTypes, (file, file_index) => {
            return vue.openBlock(), vue.createBlock(_component_uni_section, {
              key: file_index,
              title: file.type,
              type: "line"
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(
                  _component_uni_grid,
                  {
                    column: 4,
                    "show-border": false
                  },
                  {
                    default: vue.withCtx(() => [
                      vue.createCommentVNode(" å›¾ç‰‡ "),
                      file_index === 0 ? (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        { key: 0 },
                        vue.renderList($data.imgPath, (item, index) => {
                          return vue.openBlock(), vue.createBlock(
                            _component_uni_grid_item,
                            { key: index },
                            {
                              default: vue.withCtx(() => [
                                vue.createElementVNode("view", { style: { "border-radius": "3px", "width": "83px", "height": "83px", "display": "flex", "align-items": "center", "justify-content": "center" } }, [
                                  vue.createElementVNode("image", {
                                    src: item,
                                    onClick: ($event) => $options.preview(item, index),
                                    style: { "width": "83px", "height": "83px" }
                                  }, null, 8, ["src", "onClick"])
                                ])
                              ]),
                              _: 2
                              /* DYNAMIC */
                            },
                            1024
                            /* DYNAMIC_SLOTS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      )) : vue.createCommentVNode("v-if", true),
                      vue.createCommentVNode(" è§†é¢‘ "),
                      file_index === 1 ? (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        vue.renderList($data.videoPath, (item, index) => {
                          return vue.openBlock(), vue.createBlock(
                            _component_uni_grid_item,
                            { key: index },
                            {
                              default: vue.withCtx(() => [
                                vue.createElementVNode("view", { style: { "background-color": "black", "border-radius": "3px", "width": "83px", "height": "83px", "display": "flex", "align-items": "center", "justify-content": "center" } }, [
                                  vue.createElementVNode("image", {
                                    onTouchstart: _cache[0] || (_cache[0] = ($event) => $options.openVideo()),
                                    onClick: ($event) => $options.videoShow(item),
                                    src: _imports_0$9,
                                    style: { "width": "50px", "height": "50px" }
                                  }, null, 40, ["onClick"])
                                ])
                              ]),
                              _: 2
                              /* DYNAMIC */
                            },
                            1024
                            /* DYNAMIC_SLOTS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      )) : vue.createCommentVNode("v-if", true),
                      file_index === 2 ? (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        { key: 2 },
                        vue.renderList($data.audioPath, (item, index) => {
                          return vue.openBlock(), vue.createBlock(
                            _component_uni_grid_item,
                            { key: index },
                            {
                              default: vue.withCtx(() => [
                                vue.createElementVNode("view", { style: { "background-color": "lightgrey", "border-radius": "3px", "width": "83px", "height": "83px", "display": "flex", "align-items": "center", "justify-content": "center" } }, [
                                  vue.createElementVNode("image", {
                                    onClick: ($event) => $options.openAudioPopup(index),
                                    src: _imports_1$3,
                                    style: { "width": "35px", "height": "35px" }
                                  }, null, 8, ["onClick"])
                                ])
                              ]),
                              _: 2
                              /* DYNAMIC */
                            },
                            1024
                            /* DYNAMIC_SLOTS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      )) : vue.createCommentVNode("v-if", true)
                    ]),
                    _: 2
                    /* DYNAMIC */
                  },
                  1024
                  /* DYNAMIC_SLOTS */
                )
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["title"]);
          }),
          128
          /* KEYED_FRAGMENT */
        )),
        vue.createCommentVNode(" å›¾ç‰‡é¢„è§ˆç»„ä»¶ "),
        vue.createVNode(_component_q_previewImage, {
          ref: "previewImage",
          urls: $data.imgPath,
          onOnLongpress: _cache[1] || (_cache[1] = () => {
          }),
          onOpen: _cache[2] || (_cache[2] = () => {
          }),
          onClose: _cache[3] || (_cache[3] = () => {
          })
        }, null, 8, ["urls"]),
        vue.createCommentVNode(" è§†é¢‘é¢„è§ˆç•Œé¢ "),
        $data.videoPlay ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, [
          vue.createElementVNode("video", {
            id: "myVideo",
            src: $data.videoUrl,
            onFullscreenchange: _cache[4] || (_cache[4] = (...args) => $options.screenChange && $options.screenChange(...args)),
            style: { "height": "1px", "width": "1px" },
            controls: "",
            autoplay: ""
          }, null, 40, ["src"])
        ])) : vue.createCommentVNode("v-if", true)
      ]),
      vue.createCommentVNode(" éŸ³é¢‘é¢„è§ˆå¼¹çª— "),
      vue.createVNode(
        _component_uni_popup,
        {
          ref: "audioPopup",
          type: "bottom",
          onMaskClick: _cache[6] || (_cache[6] = ($event) => $options.clickMask())
        },
        {
          default: vue.withCtx(() => [
            vue.createElementVNode("view", { style: { "background": "#fff", "border-radius": "5px", "padding": "10px" } }, [
              vue.createElementVNode("view", { style: { "display": "flex", "justify-content": "space-between" } }, [
                vue.createElementVNode("view", null, [
                  vue.createElementVNode(
                    "text",
                    null,
                    vue.toDisplayString($options.getFileName($data.audioUrl)),
                    1
                    /* TEXT */
                  )
                ]),
                vue.createElementVNode("view", {
                  style: { "margin-right": "10px" },
                  onClick: _cache[5] || (_cache[5] = ($event) => $options.clickMask())
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_2$1,
                    style: { "width": "15px", "height": "15px" }
                  })
                ])
              ]),
              vue.createElementVNode("view", { class: "divider" }),
              vue.createCommentVNode(" æ”¯æŒmp3ã€oggç­‰ "),
              $data.audioUrl ? (vue.openBlock(), vue.createBlock(_component_free_audio, {
                key: 0,
                startPic: "../../../../static/icon/take_video.png",
                endPic: "../../../../static/icon/pause.png",
                audioId: "audio1",
                url: $data.audioUrl
              }, null, 8, ["url"])) : vue.createCommentVNode("v-if", true)
            ])
          ]),
          _: 1
          /* STABLE */
        },
        512
        /* NEED_PATCH */
      ),
      vue.createCommentVNode(" æ–‡ä»¶ä¸Šä¼  "),
      vue.createVNode(_component_ysh_file_manager, {
        ref: "filemanager",
        onResult: $options.handleResult
      }, null, 8, ["onResult"]),
      vue.createElementVNode("view", { style: { "background-color": "#fff" } }, [
        vue.createVNode(_component_uni_fab, {
          pattern: $data.pattern,
          content: $data.content,
          horizontal: $data.horizontal,
          vertical: $data.vertical,
          direction: $data.direction,
          onTrigger: $options.trigger
        }, null, 8, ["pattern", "content", "horizontal", "vertical", "direction", "onTrigger"])
      ])
    ]);
  }
  const PagesTaskTaskDetailDocumentDocument = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$I], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/task/task_detail/document/document.vue"]]);
  const _sfc_main$I = {
    data() {
      return {};
    },
    mounted() {
      const subNVue = uni.getSubNVueById("condition_icons");
      subNVue.show("none", 300, function() {
        formatAppLog("log", "at pages/task/task_detail/baidu_map/baidu_map.vue:20", subNVue, "subNVue");
        subNVue.setStyle({
          top: "0px",
          bottom: "0px",
          left: "0px",
          right: "0px",
          zIndex: 999
        });
        formatAppLog("log", "at pages/task/task_detail/baidu_map/baidu_map.vue:28", "open success");
      });
    },
    methods: {}
  };
  function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "map-container" }, [
      vue.createElementVNode("web-view", { src: "/static/html/map_baidu.html" })
    ]);
  }
  const PagesTaskTaskDetailBaiduMapBaiduMap = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$H], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/task/task_detail/baidu_map/baidu_map.vue"]]);
  const _sfc_main$H = {
    name: "OptionPicker",
    props: {
      title: String,
      options: Array,
      selectedValue: String
    },
    methods: {
      selectOption(value) {
        this.$emit("select", value);
      }
    }
  };
  function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "picker-wrapper" }, [
      vue.createElementVNode("view", {
        class: "picker-overlay",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("close"))
      }, [
        vue.createElementVNode("view", {
          class: "picker-content",
          onClick: _cache[2] || (_cache[2] = vue.withModifiers(() => {
          }, ["stop"]))
        }, [
          vue.createElementVNode("view", { class: "picker-header" }, [
            vue.createElementVNode(
              "text",
              { class: "picker-title" },
              vue.toDisplayString($props.title),
              1
              /* TEXT */
            ),
            vue.createElementVNode("text", {
              class: "picker-close",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
            }, "Ã—")
          ]),
          vue.createElementVNode("view", { class: "picker-options" }, [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($props.options, (option) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  key: option.value,
                  class: vue.normalizeClass(["picker-option", { "selected": $props.selectedValue === option.value }]),
                  onClick: ($event) => $options.selectOption(option.value)
                }, [
                  vue.createElementVNode(
                    "text",
                    null,
                    vue.toDisplayString(option.label),
                    1
                    /* TEXT */
                  )
                ], 10, ["onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          vue.createElementVNode("view", { class: "picker-footer" }, [
            vue.createElementVNode("button", {
              class: "picker-btn",
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close"))
            }, "å–æ¶ˆ")
          ])
        ])
      ])
    ]);
  }
  const OptionPicker = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$G], ["__scopeId", "data-v-2798e3c8"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/profile/OptionPicker.vue"]]);
  const _imports_0$8 = "/static/my/ç¼–è¾‘.svg";
  const _imports_1$2 = "/static/my/å±•å¼€.svg";
  const _sfc_main$G = {
    __name: "profile",
    setup(__props, { expose: __expose }) {
      __expose();
      const userStore = useUserStore();
      const userData = vue.computed(() => userStore.getUserData());
      const locationSharing = vue.ref(false);
      const showConfirmDialog = vue.ref(false);
      const confirmMessage = vue.ref("");
      const deleteType = vue.ref("");
      const selectedStorageStrategy = vue.ref("7å¤©");
      const storageOptions = [
        { label: "7å¤©", value: "7å¤©" },
        { label: "15å¤©", value: "15å¤©" },
        { label: "30å¤©", value: "30å¤©" }
      ];
      const selectedLocationInterval = vue.ref("5åˆ†é’Ÿ");
      const locationIntervalOptions = [
        { label: "1åˆ†é’Ÿ", value: "1åˆ†é’Ÿ" },
        { label: "5åˆ†é’Ÿ", value: "5åˆ†é’Ÿ" },
        { label: "10åˆ†é’Ÿ", value: "10åˆ†é’Ÿ" },
        { label: "30åˆ†é’Ÿ", value: "30åˆ†é’Ÿ" }
      ];
      const showPicker = vue.ref(false);
      const pickerTitle = vue.ref("");
      const pickerOptions = vue.ref([]);
      const pickerSelectedValue = vue.ref("");
      const pickerType = vue.ref("");
      const settingItems = vue.reactive([
        { label: "å®šä½ä¿¡æ¯å›žä¼ é—´éš”", value: "5åˆ†é’Ÿ" },
        { label: "æ–‡ä»¶æœ¬åœ°å­˜å‚¨ç­–ç•¥", value: "7å¤©" },
        { label: "ä¿®æ”¹å¯†ç ", value: "" }
      ]);
      const loadUserData = async () => {
        if (!userData.value.id) {
          const userInfo = uni.getStorageSync("userInfo");
          if (userInfo && typeof userInfo === "object") {
            userStore.setUserData(userInfo);
          }
        }
      };
      vue.onMounted(() => {
        loadUserData();
      });
      onShow(() => {
        loadUserData().catch((error) => {
          formatAppLog("error", "at pages/profile/profile.vue:163", "onShow ä¸­å‡ºçŽ°é”™è¯¯:", error);
        });
      });
      const onSettingItemClick = (item) => {
        if (item.label === "æ–‡ä»¶æœ¬åœ°å­˜å‚¨ç­–ç•¥") {
          openPicker("storage", "æ–‡ä»¶æœ¬åœ°å­˜å‚¨ç­–ç•¥", storageOptions, selectedStorageStrategy.value);
        } else if (item.label === "å®šä½ä¿¡æ¯å›žä¼ é—´éš”") {
          openPicker("location", "å®šä½ä¿¡æ¯å›žä¼ é—´éš”", locationIntervalOptions, selectedLocationInterval.value);
        } else if (item.label === "ä¿®æ”¹å¯†ç ") {
          uni.navigateTo({
            url: "/pages/forgetPassword/forgetPassword"
          });
        }
      };
      const openPicker = (type, title, options, selectedValue) => {
        pickerType.value = type;
        pickerTitle.value = title;
        pickerOptions.value = options;
        pickerSelectedValue.value = selectedValue;
        showPicker.value = true;
      };
      const closePicker = () => {
        showPicker.value = false;
      };
      const selectOption = (value) => {
        if (pickerType.value === "storage") {
          selectedStorageStrategy.value = value;
          settingItems.find((item) => item.label === "æ–‡ä»¶æœ¬åœ°å­˜å‚¨ç­–ç•¥").value = value;
        } else if (pickerType.value === "location") {
          selectedLocationInterval.value = value;
          settingItems.find((item) => item.label === "å®šä½ä¿¡æ¯å›žä¼ é—´éš”").value = value;
        }
        closePicker();
      };
      const showDeleteConfirm = (type) => {
        deleteType.value = type;
        confirmMessage.value = type === "chat" ? "ç¡®å®šåˆ é™¤èŠå¤©è®°å½•å—ï¼Ÿ" : "æ‚¨ç¡®è®¤è¦åˆ é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿ";
        showConfirmDialog.value = true;
      };
      const cancelDelete = () => {
        showConfirmDialog.value = false;
      };
      const confirmDelete = () => {
        if (deleteType.value === "chat") {
          formatAppLog("log", "at pages/profile/profile.vue:214", "èŠå¤©è®°å½•å·²åˆ é™¤");
        } else {
          formatAppLog("log", "at pages/profile/profile.vue:216", "æ‰€æœ‰æ•°æ®å·²åˆ é™¤");
        }
        showConfirmDialog.value = false;
      };
      const performLogout = async () => {
        uni.showLoading({
          title: "æ­£åœ¨é€€å‡ºç™»å½•",
          mask: true
        });
        try {
          if (uni.getStorageSync("token")) {
            await logout();
          }
        } catch (error) {
          formatAppLog("error", "at pages/profile/profile.vue:232", "é€€å‡ºç™»å½•å¤±è´¥:", error);
        } finally {
          uni.removeStorageSync("token");
          uni.removeStorageSync("userInfo");
          userStore.clearUserData();
          uni.redirectTo({
            url: "/pages/login/camouflageLogin/camouflageLogin"
          });
          uni.hideLoading();
        }
      };
      const onLocationSharingChange = (e2) => {
        locationSharing.value = e2.detail.value;
      };
      const __returned__ = { userStore, userData, locationSharing, showConfirmDialog, confirmMessage, deleteType, selectedStorageStrategy, storageOptions, selectedLocationInterval, locationIntervalOptions, showPicker, pickerTitle, pickerOptions, pickerSelectedValue, pickerType, settingItems, loadUserData, onSettingItemClick, openPicker, closePicker, selectOption, showDeleteConfirm, cancelDelete, confirmDelete, performLogout, onLocationSharingChange, ref: vue.ref, reactive: vue.reactive, onMounted: vue.onMounted, computed: vue.computed, get onShow() {
        return onShow;
      }, OptionPicker, get useUserStore() {
        return useUserStore;
      }, get logout() {
        return logout;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    return vue.openBlock(), vue.createElementBlock("view", { class: "container" }, [
      vue.createElementVNode("view", null, [
        vue.createVNode(_component_uni_nav_bar, {
          fixed: true,
          "status-bar": "",
          title: "æˆ‘çš„"
        })
      ]),
      vue.createCommentVNode(" ç”¨æˆ·å¤´åƒã€å§“åã€ç”¨æˆ·åå’Œç”µè¯ "),
      vue.createElementVNode("view", { class: "user-info" }, [
        vue.createElementVNode("image", {
          class: "avatar",
          src: $setup.userData.avatarUrl || "/static/my/é»˜è®¤å¤´åƒ.svg"
        }, null, 8, ["src"]),
        vue.createElementVNode("view", { class: "user-details" }, [
          vue.createElementVNode("view", { class: "name-container" }, [
            vue.createElementVNode(
              "text",
              { class: "name" },
              vue.toDisplayString($setup.userData.name || "æœªè®¾ç½®"),
              1
              /* TEXT */
            ),
            vue.createElementVNode("image", {
              class: "edit-icon",
              src: _imports_0$8
            })
          ]),
          vue.createElementVNode("view", { class: "info-item" }, [
            vue.createElementVNode("text", { class: "info-label" }, "ç”¨æˆ·åï¼š"),
            vue.createElementVNode(
              "text",
              { class: "info-value" },
              vue.toDisplayString($setup.userData.account || "æœªè®¾ç½®"),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", { class: "info-item" }, [
            vue.createElementVNode("text", { class: "info-label" }, "æ‰‹æœºï¼š"),
            vue.createElementVNode(
              "text",
              { class: "info-value" },
              vue.toDisplayString($setup.userData.phone || "æœªè®¾ç½®"),
              1
              /* TEXT */
            )
          ])
        ])
      ]),
      vue.createCommentVNode(" ä½ç½®å…±äº«å¼€å…³ "),
      vue.createElementVNode("view", { class: "switch-item" }, [
        vue.createElementVNode("text", null, "æ˜¯å¦å¼€å¯ä½ç½®å…±äº«"),
        vue.createElementVNode("switch", {
          color: "#4285f4",
          checked: $setup.locationSharing,
          onChange: $setup.onLocationSharingChange
        }, null, 40, ["checked"])
      ]),
      vue.createCommentVNode(" è®¾ç½®åˆ—è¡¨ "),
      vue.createElementVNode("view", { class: "setting-list" }, [
        vue.createElementVNode("view", {
          class: "setting-item",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.onSettingItemClick($setup.settingItems[0]))
        }, [
          vue.createElementVNode("text", null, "å®šä½ä¿¡æ¯å›žä¼ é—´éš”"),
          vue.createElementVNode("view", { class: "setting-value" }, [
            vue.createElementVNode(
              "text",
              { class: "setting-value-text" },
              vue.toDisplayString($setup.selectedLocationInterval),
              1
              /* TEXT */
            ),
            vue.createElementVNode("image", {
              class: "expand-icon",
              src: _imports_1$2
            })
          ])
        ]),
        vue.createElementVNode("view", {
          class: "setting-item",
          onClick: _cache[1] || (_cache[1] = ($event) => $setup.onSettingItemClick($setup.settingItems[1]))
        }, [
          vue.createElementVNode("text", null, "æ–‡ä»¶æœ¬åœ°å­˜å‚¨ç­–ç•¥"),
          vue.createElementVNode("view", { class: "setting-value" }, [
            vue.createElementVNode(
              "text",
              { class: "setting-value-text" },
              vue.toDisplayString($setup.selectedStorageStrategy),
              1
              /* TEXT */
            ),
            vue.createElementVNode("image", {
              class: "expand-icon",
              src: _imports_1$2
            })
          ])
        ]),
        vue.createElementVNode("view", {
          class: "setting-item",
          onClick: _cache[2] || (_cache[2] = ($event) => $setup.onSettingItemClick($setup.settingItems[2]))
        }, [
          vue.createElementVNode("text", null, "ä¿®æ”¹å¯†ç "),
          vue.createElementVNode("view", { class: "setting-value" }, [
            vue.createElementVNode("image", {
              class: "expand-icon",
              src: _imports_1$2
            })
          ])
        ])
      ]),
      vue.createCommentVNode(" åˆ é™¤èŠå¤©è®°å½•æŒ‰é’® "),
      vue.createElementVNode("view", {
        class: "delete-chat",
        onClick: _cache[3] || (_cache[3] = ($event) => $setup.showDeleteConfirm("chat"))
      }, [
        vue.createElementVNode("text", null, "åˆ é™¤èŠå¤©è®°å½•")
      ]),
      vue.createElementVNode("view", {
        class: "delete-all",
        onClick: _cache[4] || (_cache[4] = ($event) => $setup.showDeleteConfirm("all"))
      }, [
        vue.createElementVNode("text", null, "ä¸€é”®åˆ é™¤")
      ]),
      vue.createCommentVNode(" é€€å‡ºç™»å½•æŒ‰é’® "),
      vue.createElementVNode("view", {
        class: "logout",
        onClick: $setup.performLogout
      }, [
        vue.createElementVNode("text", null, "é€€å‡ºç™»å½•")
      ]),
      vue.createCommentVNode(" ç¡®è®¤å¯¹è¯æ¡† "),
      $setup.showConfirmDialog ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "dialog-overlay"
      }, [
        vue.createElementVNode("view", { class: "dialog-content" }, [
          vue.createElementVNode("view", { class: "dialog-body" }, [
            vue.createElementVNode(
              "text",
              null,
              vue.toDisplayString($setup.confirmMessage),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", { class: "dialog-footer" }, [
            vue.createElementVNode("button", {
              class: "dialog-btn cancel-btn",
              onClick: $setup.cancelDelete
            }, "å–æ¶ˆ"),
            vue.createElementVNode("button", {
              class: "dialog-btn confirm-btn",
              onClick: $setup.confirmDelete
            }, "ç¡®è®¤")
          ])
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" é€‰é¡¹é€‰æ‹©å™¨ "),
      $setup.showPicker ? (vue.openBlock(), vue.createBlock($setup["OptionPicker"], {
        key: 1,
        title: $setup.pickerTitle,
        options: $setup.pickerOptions,
        selectedValue: $setup.pickerSelectedValue,
        onSelect: $setup.selectOption,
        onClose: $setup.closePicker
      }, null, 8, ["title", "options", "selectedValue"])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const PagesProfileProfile = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$F], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/profile/profile.vue"]]);
  const _sfc_main$F = {
    name: "SystemMessage",
    // å®šä¹‰ç»„ä»¶çš„å±žæ€§
    props: {
      message: {
        type: Object,
        required: true
      }
    }
  };
  function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "message-item system-message" }, [
      vue.createElementVNode("view", { class: "avatar-container" }, [
        vue.createElementVNode("view", { class: "system-icon" }, [
          vue.createElementVNode("text", null, "ðŸ“¢")
        ]),
        $props.message.notificationCount > 0 ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 0,
            class: "avatar-badge"
          },
          vue.toDisplayString($props.message.notificationCount),
          1
          /* TEXT */
        )) : vue.createCommentVNode("v-if", true)
      ]),
      vue.createElementVNode("view", { class: "message-content-wrapper" }, [
        vue.createElementVNode("view", { class: "message-content" }, [
          vue.createElementVNode(
            "view",
            { class: "message-title" },
            vue.toDisplayString($props.message.title),
            1
            /* TEXT */
          ),
          vue.createElementVNode(
            "view",
            { class: "message-preview" },
            vue.toDisplayString($props.message.preview),
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode(
          "view",
          { class: "message-date" },
          vue.toDisplayString($props.message.date),
          1
          /* TEXT */
        )
      ])
    ]);
  }
  const SystemMessage = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$E], ["__scopeId", "data-v-75911b46"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/MainComponents/SystemMessage.vue"]]);
  const _sfc_main$E = {
    name: "GroupAvatar",
    props: {
      // å¤´åƒæ•°ç»„
      avatar: {
        type: Array,
        required: true
      }
    },
    computed: {
      // è®¡ç®—è¦æ˜¾ç¤ºçš„å¤´åƒæº
      avatarSources() {
        return this.avatar.slice(0, 4);
      }
    }
  };
  function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "group-avatar" }, [
      (vue.openBlock(true), vue.createElementBlock(
        vue.Fragment,
        null,
        vue.renderList($options.avatarSources, (src, index) => {
          return vue.openBlock(), vue.createElementBlock("image", {
            key: index,
            src,
            class: "avatar-image"
          }, null, 8, ["src"]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]);
  }
  const GroupAvatar = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$D], ["__scopeId", "data-v-911ba5e2"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/MainComponents/GroupAvatar.vue"]]);
  const getCurrentDate = () => {
    const now2 = /* @__PURE__ */ new Date();
    const month = now2.getMonth() + 1;
    const day = now2.getDate();
    return `${month}æœˆ${day}æ—¥`;
  };
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const now2 = /* @__PURE__ */ new Date();
    const diffDays = Math.floor((now2 - date) / (1e3 * 60 * 60 * 24));
    if (diffDays === 0) {
      return formatTime(date);
    } else if (diffDays === 1) {
      return "æ˜¨å¤©";
    } else if (diffDays < 7) {
      const weekdays = ["å‘¨æ—¥", "å‘¨ä¸€", "å‘¨äºŒ", "å‘¨ä¸‰", "å‘¨å››", "å‘¨äº”", "å‘¨å…­"];
      return weekdays[date.getDay()];
    } else {
      const month = date.getMonth() + 1;
      const day = date.getDate();
      return `${month}æœˆ${day}æ—¥`;
    }
  };
  const formatTime = (date) => {
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");
    return `${hours}:${minutes}`;
  };
  const createDemoMessages = () => vue.ref([
    // {
    //   id: '1',
    //   name: 'å¼ ä¸‰',
    //   avatar: ['/static/avatar/avatar1.png'],
    //   preview: 'ä½ å¥½ï¼Œæœ€è¿‘æ€Žä¹ˆæ ·ï¼Ÿ',
    //   date: '2024-11-25T10:00:00',
    //   type: 'single',
    //   unreadCount: 2
    // },
    // {
    //   id: '2',
    //   name: 'é¡¹ç›®è®¨è®ºç¾¤',
    //   avatar: ['/static/avatar/group1.png', '/static/avatar/group2.png', '/static/avatar/group3.png'],
    //   preview: 'ä¸‹å‘¨ä¸€å¼€ä¼šï¼Œè¯·å¤§å®¶å‡†æ—¶å‚åŠ ',
    //   date: '2024-11-24T15:30:00',
    //   type: 'group',
    //   unreadCount: 5
    // }
  ]);
  const createCombinedMessages = (demoMessages, realMessages) => vue.computed(() => [...demoMessages.value, ...realMessages.value]);
  const createTotalMessageCount = (combinedMessages) => vue.computed(() => {
    const totalUnread = combinedMessages.value.reduce((sum, message) => sum + (message.unreadCount || 0), 0);
    return combinedMessages.value.length + totalUnread;
  });
  const createSystemMessage = () => vue.computed(() => ({
    title: "æŽ¨é€æ¶ˆæ¯",
    preview: "ç³»ç»Ÿç‰ˆæœ¬æ›´æ–°",
    date: getCurrentDate(),
    notificationCount: Math.floor(Math.random() * 20) + 1
    // éšæœºç”Ÿæˆ1-20çš„æœªè¯»æ•°
  }));
  const getAvatarSrc = (avatar, defaultAvatarPath) => {
    return Array.isArray(avatar) ? avatar[0] : avatar || defaultAvatarPath;
  };
  const _sfc_main$D = {
    name: "MessageItem",
    components: {
      GroupAvatar
    },
    // å®šä¹‰ç»„ä»¶çš„å±žæ€§
    props: {
      message: {
        type: Object,
        required: true
      }
    },
    setup() {
      return {
        getAvatarSrc,
        formatDate
      };
    }
  };
  function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_group_avatar = vue.resolveComponent("group-avatar");
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["message-item", { "personal-chat": !$props.message.group, "group-chat": $props.message.group }]),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $props.message))
      },
      [
        vue.createElementVNode("view", { class: "avatar-container" }, [
          vue.createCommentVNode(" æ ¹æ®æ¶ˆæ¯ç±»åž‹æ˜¾ç¤ºç¾¤ç»„å¤´åƒæˆ–ä¸ªäººå¤´åƒ "),
          $props.message.group ? (vue.openBlock(), vue.createBlock(_component_group_avatar, {
            key: 0,
            avatar: [$props.message.avatarUrl],
            class: "avatar"
          }, null, 8, ["avatar"])) : (vue.openBlock(), vue.createElementBlock("image", {
            key: 1,
            src: $setup.getAvatarSrc($props.message.avatarUrl),
            class: "avatar",
            mode: "aspectFill"
          }, null, 8, ["src"])),
          vue.createCommentVNode(" æ˜¾ç¤ºæœªè¯»æ¶ˆæ¯æ•°é‡ "),
          $props.message.unreadCount > 0 ? (vue.openBlock(), vue.createElementBlock(
            "view",
            {
              key: 2,
              class: "avatar-badge"
            },
            vue.toDisplayString($props.message.unreadCount),
            1
            /* TEXT */
          )) : vue.createCommentVNode("v-if", true)
        ]),
        vue.createElementVNode("view", { class: "message-content-wrapper" }, [
          vue.createElementVNode("view", { class: "message-content" }, [
            vue.createElementVNode(
              "view",
              { class: "message-title" },
              vue.toDisplayString($props.message.group ? $props.message.groupName : $props.message.userName || $props.message.name),
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "view",
              { class: "message-preview" },
              vue.toDisplayString($props.message.latestMessage || $props.message.preview),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode(
            "view",
            { class: "message-date" },
            vue.toDisplayString($setup.formatDate($props.message.sendTime || $props.message.date)),
            1
            /* TEXT */
          )
        ])
      ],
      2
      /* CLASS */
    );
  }
  const MessageItem = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$C], ["__scopeId", "data-v-d65c0997"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/MainComponents/MessageItem.vue"]]);
  const useMainInterfaceStore = defineStore("mainInterface", () => {
    const cachedMessages = vue.ref([]);
    const lastUpdateTime = vue.ref(null);
    const isInitialized = vue.ref(false);
    function setCachedMessages(messages2) {
      cachedMessages.value = messages2;
      lastUpdateTime.value = Date.now();
      isInitialized.value = true;
    }
    function getCachedMessages() {
      return cachedMessages.value;
    }
    function updateCachedMessages(newMessages) {
      newMessages.forEach((newMsg) => {
        const index = cachedMessages.value.findIndex((msg) => msg.id === newMsg.id);
        if (index !== -1) {
          cachedMessages.value[index] = { ...cachedMessages.value[index], ...newMsg };
        } else {
          cachedMessages.value.push(newMsg);
        }
      });
      lastUpdateTime.value = Date.now();
    }
    function clearCache() {
      cachedMessages.value = [];
      lastUpdateTime.value = null;
      isInitialized.value = false;
    }
    return {
      cachedMessages,
      lastUpdateTime,
      isInitialized,
      setCachedMessages,
      getCachedMessages,
      updateCachedMessages,
      clearCache
    };
  });
  const calculateScrollViewHeight = () => {
    const systemInfo = uni.getSystemInfoSync();
    const headerHeight = 44;
    const tabBarHeight = 50;
    return systemInfo.windowHeight - headerHeight - tabBarHeight;
  };
  const getChatList = (missionId) => {
    if (!missionId) {
      formatAppLog("log", "at utils/api/message.js:10", "getChatList éœ€è¦ missionId å‚æ•°");
      return Promise.reject(new Error("getChatList éœ€è¦ missionId å‚æ•°"));
    }
    return request({
      url: `/message/chatList`,
      method: "get",
      data: { missionId }
    });
  };
  const sendMessageToUser = (data) => {
    formatAppLog("log", "at utils/api/message.js:23", "å‘é€æ¶ˆæ¯", data);
    return request({
      url: "/message/send/user",
      method: "post",
      data: {
        isPosition: data.isPosition !== void 0 ? data.isPosition : false,
        isSelfDestruct: data.isSelfDestruct !== void 0 ? data.isSelfDestruct : false,
        message: data.message,
        recipientId: data.recipientId,
        relatedMissionId: data.missionId[0]
      }
    });
  };
  const sendFilesToUser = (data) => {
    return new Promise((resolve, reject) => {
      if (!data.files || data.files.length === 0) {
        reject(new Error("æ²¡æœ‰è¦ä¸Šä¼ çš„æ–‡ä»¶"));
        return;
      }
      const file = data.files[0];
      const uploadTask = uni.uploadFile({
        url: backendHost + "/message/send/files",
        // æ›´æ–°ä¸ºæ­£ç¡®çš„åŽç«¯ä¸Šä¼ æŽ¥å£åœ°å€
        filePath: file.path || file,
        name: "files",
        header: {
          Authorization: "Bearer " + uni.getStorageSync("token")
        },
        formData: {
          isGroup: data.isGroup,
          isSelfDestruct: data.isSelfDestruct,
          latitude: data.latitude,
          longitude: data.longitude,
          missionId: data.missionId,
          receptionId: data.receptionId,
          voiceMessage: data.voiceMessage !== void 0 ? data.voiceMessage : false
        },
        success: (uploadFileRes) => {
          formatAppLog("log", "at utils/api/message.js:64", "æœåŠ¡å™¨åŽŸå§‹å“åº”:", uploadFileRes);
          if (uploadFileRes.statusCode === 404) {
            reject(new Error("æœåŠ¡å™¨ç«¯ç‚¹æœªæ‰¾åˆ° (404)"));
            return;
          }
          if (uploadFileRes.statusCode !== 200) {
            reject(new Error(`æœåŠ¡å™¨è¿”å›žé”™è¯¯çŠ¶æ€ç : ${uploadFileRes.statusCode}`));
            return;
          }
          try {
            let response;
            if (typeof uploadFileRes.data === "string" && uploadFileRes.data.trim() !== "") {
              response = JSON.parse(uploadFileRes.data);
            } else if (typeof uploadFileRes.data === "object") {
              response = uploadFileRes.data;
            } else {
              throw new Error("æœåŠ¡å™¨è¿”å›žäº†ç©ºå“åº”æˆ–æ— æ•ˆçš„JSON");
            }
            formatAppLog("log", "at utils/api/message.js:82", "è§£æžåŽçš„å“åº”:", response);
            resolve(response);
          } catch (error) {
            formatAppLog("log", "at utils/api/message.js:85", "è§£æžæœåŠ¡å™¨å“åº”å¤±è´¥:", error);
            reject(new Error("è§£æžæœåŠ¡å™¨å“åº”å¤±è´¥"));
          }
        },
        fail: (error) => {
          formatAppLog("log", "at utils/api/message.js:90", "ä¸Šä¼ å¤±è´¥:", error);
          reject(error);
        }
      });
      uploadTask.onProgressUpdate((res) => {
        formatAppLog("log", "at utils/api/message.js:96", "ä¸Šä¼ è¿›åº¦", res.progress);
        formatAppLog("log", "at utils/api/message.js:97", "å·²ç»ä¸Šä¼ çš„æ•°æ®é•¿åº¦", res.totalBytesSent);
        formatAppLog("log", "at utils/api/message.js:98", "é¢„æœŸéœ€è¦ä¸Šä¼ çš„æ•°æ®æ€»é•¿åº¦", res.totalBytesExpectedToSend);
      });
    });
  };
  const getHistoryChatMessages = (data) => {
    return request({
      url: "/message/read/single",
      method: "post",
      data: {
        from: data.from,
        to: data.to,
        opponentId: data.opponentId,
        relatedMissionId: data.missionId[0]
      }
    });
  };
  const readSelfDestructMessage = (data) => {
    return request({
      url: "/message/read/selfDestruct/message",
      method: "post",
      data: {
        isGroup: data.isGroup,
        messageId: data.messageId,
        messageType: data.messageType
      }
    });
  };
  const getMissionAddressBook = (missionid) => {
    useUserStore();
    return request({
      // url: `/mission/address/book?missionId=${userStore.missionId}`,
      url: `/mission/address/book?missionId=` + missionid,
      method: "get"
    });
  };
  const sendGroupMessage = (data) => {
    return request({
      url: "/message/send/group",
      method: "post",
      data: {
        isGroupAnnouncement: data.isGroupAnnouncement !== void 0 ? data.isGroupAnnouncement : false,
        isPosition: data.isPosition !== void 0 ? data.isPosition : false,
        isSelfDestruct: data.isSelfDestruct !== void 0 ? data.isSelfDestruct : false,
        message: data.message,
        recipientId: data.recipientId,
        relatedMissionId: data.missionId
      }
    });
  };
  const getGroupChatMessages = (data) => {
    return request({
      url: "/message/read/group",
      method: "post",
      data: {
        from: data.from,
        opponentId: data.opponentId,
        to: data.to,
        relatedMissionId: data.missionId
      }
    });
  };
  const getGroupBasicInfo = (groupId) => {
    if (!groupId) {
      formatAppLog("log", "at utils/api/message.js:177", "getGroupBasicInfo éœ€è¦ groupId å‚æ•°");
      return Promise.reject(new Error("getGroupBasicInfo éœ€è¦ groupId å‚æ•°"));
    }
    return request({
      url: `/group/get/basicInf?groupId=${groupId}`,
      method: "get"
    });
  };
  const getUserBasicInfo = (userId) => {
    if (!userId) {
      formatAppLog("log", "at utils/api/message.js:188", "getUserBasicInfo éœ€è¦ userId å‚æ•°");
      return Promise.reject(new Error("getUserBasicInfo éœ€è¦ userId å‚æ•°"));
    }
    return request({
      url: `/user/search/basicInf?id=${userId}`,
      method: "get"
    });
  };
  const fetchChatList = async (missionId) => {
    formatAppLog("log", "at pages/message/MainComposables/chatApi.js:6", "æ­£åœ¨èŽ·å–èŠå¤©åˆ—è¡¨ï¼Œä½¿ç”¨çš„ missionId:", missionId);
    if (!missionId) {
      formatAppLog("log", "at pages/message/MainComposables/chatApi.js:8", "fetchChatList ä¸­ missionId æœªè®¾ç½®");
      return null;
    }
    try {
      const response = await getChatList(missionId);
      if (response.code === 200) {
        const messages2 = response.data.map((item) => ({
          ...item,
          avatar: item.avatar || "/static/message/é»˜è®¤å¤´åƒ.png",
          preview: item.latestMessage,
          date: item.sendTime
        }));
        formatAppLog("log", "at pages/message/MainComposables/chatApi.js:20", "èŽ·å–åˆ°çš„èŠå¤©åˆ—è¡¨:", messages2);
        return messages2;
      } else {
        formatAppLog("log", "at pages/message/MainComposables/chatApi.js:23", "èŽ·å–èŠå¤©åˆ—è¡¨å¤±è´¥:", response.msg);
        return null;
      }
    } catch (error) {
      formatAppLog("log", "at pages/message/MainComposables/chatApi.js:27", "èŽ·å–èŠå¤©åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯:", error);
      return null;
    }
  };
  function useMessageList() {
    const userStore = useUserStore();
    const mainInterfaceStore = useMainInterfaceStore();
    const missionId = vue.ref("");
    const realMessages = vue.ref([]);
    const scrollViewHeight = vue.ref(0);
    const isLoading = vue.ref(false);
    const demoMessages = createDemoMessages();
    const combinedMessages = createCombinedMessages(demoMessages, realMessages);
    const totalMessageCount = createTotalMessageCount(combinedMessages);
    const systemMessage = createSystemMessage();
    const openChat = (message) => {
      const chatInfo = {
        id: message.group ? message.groupId : message.id || message.userId,
        name: message.group ? message.groupName : message.name || message.userName,
        avatar: message.avatarUrl || "/static/message/é»˜è®¤å¤´åƒ.png",
        type: message.group ? "group" : "single",
        missionId: missionId.value
      };
      uni.setStorageSync("chatQuery", JSON.stringify(chatInfo));
      uni.navigateTo({
        url: "/pages/message/chat",
        success: (res) => {
          if (res.eventChannel && res.eventChannel.emit) {
            res.eventChannel.emit("chatInfo", { chatInfo });
            formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:44", "é€šè¿‡ eventChannel å‘é€ chatInfo");
          } else {
            formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:46", "eventChannel ä¸å¯ç”¨ï¼Œå°†ä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„æ•°æ®");
          }
        },
        fail: (err) => {
          formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:50", "å¯¼èˆªåˆ°èŠå¤©é¡µé¢å¤±è´¥:", JSON.stringify(err));
        }
      });
    };
    const loadMessages = async () => {
      missionId.value = userStore.state.missionId;
      scrollViewHeight.value = calculateScrollViewHeight();
      if (mainInterfaceStore.isInitialized) {
        realMessages.value = mainInterfaceStore.getCachedMessages();
      }
      await fetchAndUpdateMessages();
    };
    const fetchAndUpdateMessages = async () => {
      try {
        const newMessages = await fetchChatList(missionId.value);
        if (newMessages) {
          const hasChanges = compareMessages(newMessages, realMessages.value);
          if (hasChanges) {
            mainInterfaceStore.setCachedMessages(newMessages);
            realMessages.value = newMessages;
          } else {
            formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:81", "æ¶ˆæ¯åˆ—è¡¨æ— å˜åŒ–");
          }
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:85", "èŽ·å–èŠå¤©åˆ—è¡¨å¤±è´¥:", JSON.stringify(error));
      }
    };
    const compareMessages = (newMessages, oldMessages) => {
      if (newMessages.length !== oldMessages.length)
        return true;
      for (let i2 = 0; i2 < newMessages.length; i2++) {
        if (JSON.stringify(newMessages[i2]) !== JSON.stringify(oldMessages[i2])) {
          return true;
        }
      }
      return false;
    };
    vue.onMounted(loadMessages);
    vue.onActivated(() => {
      formatAppLog("log", "at pages/message/MainComposables/useMessageList.js:103", "æ¶ˆæ¯ç»„ä»¶è¢«æ¿€æ´»");
      loadMessages();
    });
    return {
      combinedMessages,
      totalMessageCount,
      systemMessage,
      scrollViewHeight,
      isLoading,
      openChat,
      fetchAndUpdateMessages
    };
  }
  const _sfc_main$C = vue.defineComponent({
    name: "Messages",
    components: {
      SystemMessage,
      MessageItem
    },
    setup() {
      const {
        combinedMessages,
        totalMessageCount,
        systemMessage,
        scrollViewHeight,
        openChat,
        fetchAndUpdateMessages
      } = useMessageList();
      const refreshPage = () => {
        formatAppLog("log", "at pages/message/main.vue:52", "åˆ·æ–°main.vueé¡µé¢");
        fetchAndUpdateMessages();
      };
      vue.onMounted(() => {
        uni.$on("refreshMainPage", refreshPage);
      });
      vue.onUnmounted(() => {
        uni.$off("refreshMainPage", refreshPage);
      });
      return {
        combinedMessages,
        totalMessageCount,
        systemMessage,
        scrollViewHeight,
        openChat,
        refreshPage
      };
    }
  });
  function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    const _component_SystemMessage = vue.resolveComponent("SystemMessage");
    const _component_MessageItem = vue.resolveComponent("MessageItem");
    return vue.openBlock(), vue.createElementBlock("view", { class: "messages-container" }, [
      vue.createElementVNode("view", null, [
        vue.createVNode(_component_uni_nav_bar, {
          fixed: true,
          "status-bar": "",
          rightIcon: "search",
          onClickRight: _cache[0] || (_cache[0] = () => {
          }),
          title: "æ¶ˆæ¯"
        })
      ]),
      vue.createElementVNode("view", { class: "messages-view" }, [
        vue.createElementVNode("view", { class: "messages-header" }, [
          vue.createElementVNode(
            "text",
            { class: "header-title" },
            "æ¶ˆæ¯(" + vue.toDisplayString(_ctx.totalMessageCount) + ")",
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode(
          "scroll-view",
          {
            class: "messages-list",
            "scroll-y": "",
            "enable-flex": "",
            style: vue.normalizeStyle({ height: _ctx.scrollViewHeight + "px" })
          },
          [
            vue.createCommentVNode(" ç³»ç»Ÿæ¶ˆæ¯ "),
            vue.createVNode(_component_SystemMessage, { message: _ctx.systemMessage }, null, 8, ["message"]),
            vue.createCommentVNode(" æ¶ˆæ¯åˆ—è¡¨ "),
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(_ctx.combinedMessages, (message, index) => {
                return vue.openBlock(), vue.createBlock(_component_MessageItem, {
                  key: message.id || index,
                  message,
                  onClick: ($event) => _ctx.openChat(message)
                }, null, 8, ["message", "onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          4
          /* STYLE */
        )
      ])
    ]);
  }
  const PagesMessageMain = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$B], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/main.vue"]]);
  const _imports_0$7 = "/static/message/è¿”å›ž.png";
  const _sfc_main$B = {
    name: "ChatHeader",
    components: {},
    props: {
      chatInfo: {
        type: Object,
        required: true
      }
    }
  };
  function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "chat-header" }, [
      vue.createElementVNode("div", {
        class: "uni-page-head-hd",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("goBack"))
      }, [
        vue.createElementVNode("div", { class: "uni-page-head-btn" }, [
          vue.createElementVNode("image", {
            src: _imports_0$7,
            class: "back-icon",
            mode: "aspectFit"
          })
        ])
      ]),
      vue.createElementVNode("view", { class: "chat-title-container" }, [
        vue.createElementVNode(
          "text",
          { class: "chat-title" },
          vue.toDisplayString($props.chatInfo.name),
          1
          /* TEXT */
        )
      ]),
      vue.createElementVNode("text", { class: "menu-button" }, "...")
    ]);
  }
  const ChatHeader = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$A], ["__scopeId", "data-v-120ff10e"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatHeader.vue"]]);
  const gaodeApiKey = "fc598a079d7d9cf5f54ecec04b17e414";
  const gaodeSecurityKey = "93849873dba769e7b6235a79330ae7f7";
  const AMAP_KEY = gaodeApiKey;
  const AMAP_API_URL = "https://restapi.amap.com/v3/staticmap?";
  const _sfc_main$A = {
    name: "LocationMessage",
    props: {
      content: {
        type: Object,
        required: true
      }
    },
    methods: {
      openMap(location2) {
        if (!location2 || !location2.latitude || !location2.longitude) {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/LocationMessage.vue:32", "æ— æ•ˆçš„ä½ç½®æ•°æ®:", location2);
          return;
        }
        uni.openLocation({
          latitude: parseFloat(location2.latitude),
          longitude: parseFloat(location2.longitude),
          name: location2.name,
          address: location2.address,
          success: function() {
            formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/LocationMessage.vue:41", "æˆåŠŸæ‰“å¼€åœ°å›¾");
          },
          fail: function(error) {
            formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/LocationMessage.vue:44", "æ‰“å¼€åœ°å›¾å¤±è´¥:", error);
          }
        });
      },
      getStaticMapUrl(location2) {
        return `${AMAP_API_URL}location=${location2.longitude},${location2.latitude}&zoom=14&size=480*240&scale=2&markers=mid,,A:${location2.longitude},${location2.latitude}&key=${AMAP_KEY}`;
      }
    }
  };
  function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "location-bubble",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.openMap($props.content))
    }, [
      vue.createElementVNode(
        "view",
        { class: "location-title" },
        vue.toDisplayString($props.content.name),
        1
        /* TEXT */
      ),
      vue.createElementVNode(
        "view",
        { class: "location-address" },
        vue.toDisplayString($props.content.address),
        1
        /* TEXT */
      ),
      vue.createElementVNode("view", { class: "location-map" }, [
        vue.createElementVNode("image", {
          class: "map-image",
          src: $options.getStaticMapUrl($props.content),
          mode: "aspectFill"
        }, null, 8, ["src"])
      ])
    ]);
  }
  const LocationMessage = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$z], ["__scopeId", "data-v-820a3722"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageComponent/LocationMessage.vue"]]);
  const _sfc_main$z = {
    name: "ImageMessage",
    props: {
      content: {
        type: String,
        required: true
      }
    },
    methods: {
      previewImage(url) {
        uni.previewImage({
          urls: [url],
          current: url
        });
      }
    }
  };
  function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("image", {
      src: $props.content,
      mode: "widthFix",
      class: "message-image",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.previewImage($props.content))
    }, null, 8, ["src"]);
  }
  const ImageMessage = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$y], ["__scopeId", "data-v-2115df62"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageComponent/ImageMessage.vue"]]);
  const _imports_0$6 = "/assets/text.bd3c6783.png";
  const _imports_1$1 = "/assets/docx.b7b68f84.png";
  const _imports_2 = "/assets/jpg.3e4bf7f6.png";
  const _imports_3 = "/assets/png.ea62ff77.png";
  const _imports_4 = "/assets/pptx.feb4199f.png";
  const _imports_5 = "/assets/xlsx.ceae1396.png";
  const _sfc_main$y = {
    name: "FileMessage",
    props: {
      content: {
        type: String,
        required: true
      },
      messageType: {
        type: String,
        required: true
      }
    }
  };
  function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "file-bubble" }, [
      vue.createElementVNode(
        "view",
        { class: "file-name" },
        vue.toDisplayString($props.content),
        1
        /* TEXT */
      ),
      $props.messageType.toUpperCase() === "TEXT" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 0,
        src: _imports_0$6,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "DOCX" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 1,
        src: _imports_1$1,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "JPG" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 2,
        src: _imports_2,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "PNG" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 3,
        src: _imports_3,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "PPTX" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 4,
        src: _imports_4,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : $props.messageType.toUpperCase() === "XLSX" ? (vue.openBlock(), vue.createElementBlock("image", {
        key: 5,
        src: _imports_5,
        class: "file-type-icon",
        mode: "aspectFit"
      })) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const FileMessage = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$x], ["__scopeId", "data-v-ba23d37a"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageComponent/FileMessage.vue"]]);
  const _sfc_main$x = {
    __name: "VoiceMessageBubble",
    props: {
      content: {
        type: Object,
        required: true,
        default: () => ({
          url: "",
          duration: 0,
          isSelf: false
        })
      }
    },
    setup(__props, { expose: __expose }) {
      __expose();
      const props = __props;
      const isPlaying = vue.ref(false);
      const audioDuration = vue.ref(0);
      let audioContext = null;
      const formatDuration = (duration) => {
        return Math.round(duration || 0);
      };
      const beforeAudioRecordOrPlay2 = (type) => {
        const globalData = getApp().globalData;
        const audioPlaying = globalData.audioPlaying;
        const audioRecording = globalData.audioRecording;
        if (audioPlaying || audioRecording) {
          uni.showToast({
            title: audioPlaying ? "è¯·å…ˆæš‚åœå…¶ä»–éŸ³é¢‘æ’­æ”¾" : "è¯·å…ˆç»“æŸå…¶ä»–å½•éŸ³",
            icon: "none"
          });
          return false;
        } else {
          if (type === "play") {
            globalData.audioPlaying = true;
          } else if (type === "record") {
            globalData.audioRecording = true;
          } else {
            formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:64", `æ— æ•ˆçš„ç±»åž‹: ${type}`);
            return false;
          }
          return true;
        }
      };
      const afterAudioPlay = () => {
        getApp().globalData.audioPlaying = false;
      };
      const checkAudioFileExists = (url) => {
        return new Promise((resolve, reject) => {
          uni.downloadFile({
            url,
            success: (res) => {
              if (res.statusCode === 200) {
                resolve(true);
              } else {
                reject(new Error(`éŸ³é¢‘æ–‡ä»¶ä¸‹è½½å¤±è´¥ï¼ŒçŠ¶æ€ç ï¼š${res.statusCode}`));
              }
            },
            fail: (err) => {
              reject(new Error(`éŸ³é¢‘æ–‡ä»¶æ£€æŸ¥å¤±è´¥ï¼š${err.errMsg}`));
            }
          });
        });
      };
      const createAudioContext = async () => {
        if (audioContext) {
          audioContext.destroy();
        }
        if (!props.content.url) {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:101", "éŸ³é¢‘ URL æœªå®šä¹‰");
          uni.showToast({
            title: "éŸ³é¢‘æ–‡ä»¶ä¸å­˜åœ¨",
            icon: "none"
          });
          return null;
        }
        try {
          await checkAudioFileExists(props.content.url);
        } catch (error) {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:112", "éŸ³é¢‘æ–‡ä»¶æ£€æŸ¥å¤±è´¥:", error);
          uni.showToast({
            title: "éŸ³é¢‘æ–‡ä»¶ä¸å¯ç”¨",
            icon: "none"
          });
          return null;
        }
        audioContext = uni.createInnerAudioContext();
        audioContext.src = props.content.url;
        audioContext.onCanplay(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:124", "éŸ³é¢‘å¯ä»¥æ’­æ”¾");
          audioDuration.value = audioContext.duration || props.content.duration || 0;
        });
        audioContext.onPlay(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:129", "éŸ³é¢‘å¼€å§‹æ’­æ”¾");
          isPlaying.value = true;
        });
        audioContext.onEnded(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:134", "éŸ³é¢‘æ’­æ”¾ç»“æŸ");
          isPlaying.value = false;
          afterAudioPlay();
        });
        audioContext.onError((res) => {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:140", "éŸ³é¢‘æ’­æ”¾é”™è¯¯:", res.errMsg, res.errCode);
          uni.showToast({
            title: "æ’­æ”¾å¤±è´¥: " + res.errMsg,
            icon: "none"
          });
          isPlaying.value = false;
          afterAudioPlay();
        });
        audioContext.onWaiting(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:150", "éŸ³é¢‘åŠ è½½ä¸­...");
        });
        return audioContext;
      };
      const bubbleStyle = vue.computed(() => {
        const minWidth = 120;
        const maxWidth = 300;
        const widthPerSecond = 10;
        const duration = audioDuration.value || 0;
        let width = minWidth + duration * widthPerSecond;
        width = Math.min(width, maxWidth);
        return {
          width: `${width}rpx`
        };
      });
      const togglePlay = async () => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:173", "togglePlay è¢«è°ƒç”¨");
        if (!audioContext) {
          audioContext = await createAudioContext();
        }
        if (!audioContext) {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:178", "æ— æ³•åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡");
          return;
        }
        if (isPlaying.value) {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:183", "åœæ­¢æ’­æ”¾");
          audioContext.stop();
          isPlaying.value = false;
          afterAudioPlay();
        } else {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:188", "å¼€å§‹æ’­æ”¾");
          if (beforeAudioRecordOrPlay2("play")) {
            try {
              await audioContext.play();
            } catch (error) {
              formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:193", "æ’­æ”¾éŸ³é¢‘å¤±è´¥:", error);
              uni.showToast({
                title: "æ’­æ”¾å¤±è´¥ï¼Œè¯·é‡è¯•",
                icon: "none"
              });
              isPlaying.value = false;
              afterAudioPlay();
            }
          }
        }
      };
      vue.onMounted(async () => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:206", "VoiceMessageBubble ç»„ä»¶å·²æŒ‚è½½");
        audioContext = await createAudioContext();
      });
      vue.onUnmounted(() => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue:211", "VoiceMessageBubble ç»„ä»¶å³å°†å¸è½½");
        if (audioContext) {
          audioContext.destroy();
        }
      });
      vue.watch(() => props.content, async (newContent) => {
        if (newContent.url !== (audioContext == null ? void 0 : audioContext.src)) {
          audioContext = await createAudioContext();
        }
        audioDuration.value = newContent.duration || 0;
      }, { deep: true });
      const __returned__ = { props, isPlaying, audioDuration, get audioContext() {
        return audioContext;
      }, set audioContext(v2) {
        audioContext = v2;
      }, formatDuration, beforeAudioRecordOrPlay: beforeAudioRecordOrPlay2, afterAudioPlay, checkAudioFileExists, createAudioContext, bubbleStyle, togglePlay, ref: vue.ref, onMounted: vue.onMounted, onUnmounted: vue.onUnmounted, watch: vue.watch, computed: vue.computed };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["voice-message-bubble", [
          $props.content.isSelf ? "self" : "friend",
          $setup.isPlaying ? "playing" : ""
        ]]),
        style: vue.normalizeStyle($setup.bubbleStyle),
        onClick: $setup.togglePlay
      },
      [
        vue.createElementVNode("view", { class: "audio-icon" }, [
          vue.createElementVNode("view", { class: "speaker-waves" }, [
            (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(3, (i2) => {
                return vue.createElementVNode("view", {
                  class: "wave",
                  key: i2
                });
              }),
              64
              /* STABLE_FRAGMENT */
            ))
          ])
        ]),
        vue.createElementVNode(
          "text",
          { class: "duration" },
          vue.toDisplayString($setup.formatDuration($setup.audioDuration)) + '"',
          1
          /* TEXT */
        )
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const VoiceMessageBubble = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$w], ["__scopeId", "data-v-021f7c82"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageComponent/VoiceMessageBubble.vue"]]);
  const _sfc_main$w = {
    name: "BurnAfterReadingMessage",
    props: {
      content: {
        type: Object,
        required: true
      }
    },
    methods: {
      viewBurnAfterReading(message) {
        this.$emit("view-burn-after-reading", message);
      }
    }
  };
  function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "burn-after-reading",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.viewBurnAfterReading($props.content))
    }, [
      vue.createElementVNode("image", {
        src: $props.content.mosaicPath,
        mode: "widthFix",
        class: "message-image"
      }, null, 8, ["src"]),
      vue.createElementVNode("text", { class: "burn-after-reading-text" }, "é˜…åŽå³ç„š")
    ]);
  }
  const BurnAfterReadingMessage = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$v], ["__scopeId", "data-v-6349b1a8"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageComponent/BurnAfterReadingMessage.vue"]]);
  const _sfc_main$v = {
    name: "AudioMessage",
    props: {
      content: {
        type: String,
        required: true
      },
      messageType: {
        type: String,
        required: true
      }
    },
    data() {
      return {
        isPlaying: false,
        duration: 0,
        currentTime: 0,
        audioContext: null,
        updateInterval: null,
        isMuted: false,
        previousVolume: 1
      };
    },
    computed: {
      isAudioFile() {
        return this.messageType === "AUDIO";
      },
      progress() {
        return this.duration > 0 ? this.currentTime / this.duration * 100 : 0;
      }
    },
    mounted() {
      if (this.isAudioFile) {
        this.initAudioContext();
      }
    },
    methods: {
      formatDuration(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
      },
      togglePlay() {
        if (this.isPlaying) {
          this.audioContext.pause();
          clearInterval(this.updateInterval);
        } else {
          this.audioContext.play();
          this.updateInterval = setInterval(this.updateProgress, 1e3);
        }
        this.isPlaying = !this.isPlaying;
      },
      initAudioContext() {
        this.audioContext = uni.createInnerAudioContext();
        this.audioContext.src = this.content;
        this.audioContext.playbackRate = 1;
        this.audioContext.onCanplay(() => {
          this.getDuration();
        });
        this.audioContext.onEnded(() => {
          this.isPlaying = false;
          this.currentTime = 0;
          clearInterval(this.updateInterval);
        });
        this.audioContext.onError((res) => {
          formatAppLog("error", "at pages/message/ChatComponent/MessageComponent/AudioMessage.vue:112", "éŸ³é¢‘é”™è¯¯:", res.errMsg);
          uni.showToast({
            title: "éŸ³é¢‘æ’­æ”¾é”™è¯¯",
            icon: "none"
          });
        });
      },
      getDuration() {
        const checkDuration = () => {
          if (this.audioContext.duration > 0) {
            this.duration = this.audioContext.duration;
          } else {
            setTimeout(checkDuration, 100);
          }
        };
        checkDuration();
      },
      updateProgress() {
        if (this.audioContext) {
          this.currentTime = this.audioContext.currentTime;
        }
      },
      seekAudio(event) {
        if (!this.audioContext)
          return;
        const rect = event.target.getBoundingClientRect();
        const clickPosition = event.clientX - rect.left;
        const percentage = clickPosition / rect.width * 100;
        const newTime = percentage / 100 * this.duration;
        this.audioContext.seek(newTime);
        this.currentTime = newTime;
      },
      toggleMute() {
        if (!this.audioContext)
          return;
        if (this.isMuted) {
          this.audioContext.volume = this.previousVolume;
        } else {
          this.previousVolume = this.audioContext.volume;
          this.audioContext.volume = 0;
        }
        this.isMuted = !this.isMuted;
      }
    },
    beforeDestroy() {
      if (this.audioContext) {
        this.audioContext.destroy();
      }
      clearInterval(this.updateInterval);
    }
  };
  function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "audio-message" }, [
      $options.isAudioFile ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "audio-player"
      }, [
        vue.createElementVNode("view", { class: "player-container" }, [
          vue.createElementVNode("view", {
            class: "play-pause-button",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.togglePlay && $options.togglePlay(...args))
          }, [
            !$data.isPlaying ? (vue.openBlock(), vue.createElementBlock("svg", {
              key: 0,
              class: "play-icon",
              viewBox: "0 0 24 24",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg"
            }, [
              vue.createElementVNode("path", {
                d: "M8 5.14v14.72L19 12 8 5.14z",
                fill: "currentColor"
              })
            ])) : (vue.openBlock(), vue.createElementBlock("svg", {
              key: 1,
              class: "pause-icon",
              viewBox: "0 0 24 24",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg"
            }, [
              vue.createElementVNode("path", {
                d: "M8 5h3v14H8V5zm5 0h3v14h-3V5z",
                fill: "currentColor"
              })
            ]))
          ]),
          vue.createElementVNode("view", { class: "time-progress" }, [
            vue.createElementVNode("view", { class: "time-display" }, [
              vue.createElementVNode(
                "text",
                null,
                vue.toDisplayString($options.formatDuration($data.currentTime)),
                1
                /* TEXT */
              ),
              vue.createElementVNode("text", { class: "duration-separator" }, "/"),
              vue.createElementVNode(
                "text",
                null,
                vue.toDisplayString($options.formatDuration($data.duration)),
                1
                /* TEXT */
              )
            ]),
            vue.createElementVNode("view", {
              class: "progress-bar",
              onClick: _cache[1] || (_cache[1] = (...args) => $options.seekAudio && $options.seekAudio(...args))
            }, [
              vue.createElementVNode(
                "view",
                {
                  class: "progress",
                  style: vue.normalizeStyle({ width: `${$options.progress}%` })
                },
                null,
                4
                /* STYLE */
              )
            ])
          ]),
          vue.createElementVNode("view", { class: "controls" }, [
            vue.createElementVNode("view", {
              class: "volume-control",
              onClick: _cache[2] || (_cache[2] = (...args) => $options.toggleMute && $options.toggleMute(...args))
            }, [
              !$data.isMuted ? (vue.openBlock(), vue.createElementBlock("svg", {
                key: 0,
                class: "volume-icon",
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
              }, [
                vue.createElementVNode("path", {
                  d: "M16 9.5c.83.27 1.5 1.34 1.5 2.5s-.67 2.23-1.5 2.5",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-linecap": "round"
                }),
                vue.createElementVNode("path", {
                  d: "M3 11v2h2l3.5 3.5V7.5L5 11H3z",
                  fill: "currentColor"
                })
              ])) : (vue.openBlock(), vue.createElementBlock("svg", {
                key: 1,
                class: "volume-icon",
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
              }, [
                vue.createElementVNode("path", {
                  d: "M3 11v2h2l3.5 3.5V7.5L5 11H3z",
                  fill: "currentColor"
                }),
                vue.createElementVNode("path", {
                  d: "M14 9l-2 2m0 0l-2 2m2-2l2 2m-2-2l-2-2",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-linecap": "round"
                })
              ]))
            ])
          ])
        ])
      ])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const AudioMessage = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$u], ["__scopeId", "data-v-3578ca20"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageComponent/AudioMessage.vue"]]);
  const _imports_0$5 = "/static/message/ä¿¡å°.png";
  const _sfc_main$u = {
    name: "BurnAfterReadingTextMessage",
    props: {
      // æ¶ˆæ¯ID
      messageId: {
        type: String,
        required: true
      },
      // æ˜¯å¦ä¸ºç¾¤ç»„æ¶ˆæ¯
      isGroup: {
        type: Boolean,
        default: false
      }
    },
    emits: ["message-deleted"],
    setup(props, { emit }) {
      const revealed = vue.ref(false);
      const revealedContent = vue.ref("");
      const countdown = vue.ref(10);
      let countdownTimer = null;
      const viewBurnAfterReading = async () => {
        if (revealed.value)
          return;
        try {
          const response = await readSelfDestructMessage({
            isGroup: props.isGroup,
            messageId: props.messageId,
            messageType: "MESSAGE"
          });
          if (response.code === 200) {
            revealed.value = true;
            revealedContent.value = response.data.content || response.data;
            startCountdown();
          }
        } catch (error) {
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue:60", "è¯»å–é˜…åŽå³ç„šæ¶ˆæ¯å¤±è´¥:", error);
        }
      };
      const startCountdown = () => {
        countdownTimer = setInterval(() => {
          countdown.value--;
          if (countdown.value === 0) {
            clearInterval(countdownTimer);
            revealed.value = false;
            revealedContent.value = "";
            emit("message-deleted", props.messageId);
            formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue:73", "é˜…åŽå³ç„šæ¶ˆæ¯å€’è®¡æ—¶ç»“æŸï¼Œå·²è§¦å‘åˆ é™¤äº‹ä»¶");
          }
        }, 1e3);
      };
      vue.onUnmounted(() => {
        if (countdownTimer) {
          clearInterval(countdownTimer);
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue:82", "ç»„ä»¶å¸è½½ï¼Œæ¸…é™¤å®šæ—¶å™¨");
        }
        if (revealed.value && countdown.value > 0) {
          emit("message-deleted", props.messageId);
          formatAppLog("log", "at pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue:86", "ç»„ä»¶å¸è½½æ—¶æ¶ˆæ¯ä»åœ¨æ˜¾ç¤ºï¼Œè§¦å‘åˆ é™¤äº‹ä»¶");
        }
      });
      return {
        revealed,
        revealedContent,
        countdown,
        viewBurnAfterReading
      };
    }
  };
  function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "burn-after-reading-text",
      onClick: _cache[0] || (_cache[0] = (...args) => $setup.viewBurnAfterReading && $setup.viewBurnAfterReading(...args))
    }, [
      !$setup.revealed ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "burn-button"
      }, [
        vue.createElementVNode("image", {
          src: _imports_0$5,
          class: "envelope-icon",
          mode: "aspectFit"
        }),
        vue.createElementVNode("text", { class: "burn-text" }, "é˜…åŽå³ç„š")
      ])) : (vue.openBlock(), vue.createElementBlock("view", {
        key: 1,
        class: "revealed-message"
      }, [
        vue.createElementVNode(
          "text",
          { class: "revealed-content" },
          vue.toDisplayString($setup.revealedContent),
          1
          /* TEXT */
        ),
        vue.createElementVNode(
          "view",
          { class: "countdown" },
          vue.toDisplayString($setup.countdown) + "s",
          1
          /* TEXT */
        )
      ]))
    ]);
  }
  const BurnAfterReadingTextMessage = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$t], ["__scopeId", "data-v-9ce853fb"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageComponent/BurnAfterReadingTextMessage.vue"]]);
  const _imports_0$4 = "/static/message/é»˜è®¤å¤´åƒ.png";
  const _sfc_main$t = {
    name: "Message",
    components: {
      LocationMessage,
      ImageMessage,
      FileMessage,
      VoiceMessageBubble,
      BurnAfterReadingMessage,
      AudioMessage,
      BurnAfterReadingTextMessage
    },
    props: {
      // æ¶ˆæ¯å¯¹è±¡
      message: {
        type: Object,
        required: true
      },
      // æ˜¯å¦ä¸ºç¾¤èŠ
      isGroup: {
        type: Boolean,
        default: false
      }
    },
    emits: ["view-burn-after-reading", "message-deleted"],
    setup(props, { emit }) {
      const userStore = useUserStore();
      const formatTime2 = (timestamp) => {
        if (!timestamp)
          return "æ— æ•ˆæ—¥æœŸ";
        const date = new Date(timestamp);
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours().toString().padStart(2, "0");
        const minutes = date.getMinutes().toString().padStart(2, "0");
        return `${month}-${day} ${hours}:${minutes}`;
      };
      const viewBurnAfterReading = (message) => {
        emit("view-burn-after-reading", message);
      };
      const handleMessageDeleted = (messageId) => {
        emit("message-deleted", messageId);
      };
      const readStatusData = vue.computed(() => {
        if (!props.isGroup || !props.message.groupMessageUserReadVO) {
          return { readCount: 0, groupMessageUserReadVO: [] };
        }
        const groupMessageUserReadVO = props.message.groupMessageUserReadVO;
        const readCount = groupMessageUserReadVO.filter((user) => user.isRead).length;
        return { readCount, groupMessageUserReadVO };
      });
      const getReadCount = vue.computed(() => readStatusData.value.readCount);
      const handleReadCountClick = () => {
        formatAppLog("log", "at pages/message/ChatComponent/Message.vue:150", "å¤„ç†å·²è¯»äººæ•°ç‚¹å‡»äº‹ä»¶");
        const messageData = {
          // ç¾¤æ¶ˆæ¯ç”¨æˆ·é˜…è¯»çŠ¶æ€
          groupMessageUserReadVO: readStatusData.value.groupMessageUserReadVO,
          // å‘é€è€…åç§°
          senderName: props.message.senderName,
          // æ¶ˆæ¯å†…å®¹
          content: props.message.content,
          // æ¶ˆæ¯å‘é€æ—¶é—´æˆ³
          timestamp: props.message.timestamp,
          // æ¶ˆæ¯ç±»åž‹ï¼ˆå¦‚text, image, fileç­‰ï¼‰
          type: props.message.type,
          // æ¶ˆæ¯ç±»åž‹ï¼ˆå¦‚MESSAGE, SYSTEMç­‰ï¼‰
          messageType: props.message.messageType,
          // æ˜¯å¦ä¸ºé˜…åŽå³ç„šæ¶ˆæ¯
          selfDestruct: props.message.selfDestruct,
          // æ¶ˆæ¯ID
          id: props.message.id
        };
        formatAppLog("log", "at pages/message/ChatComponent/Message.vue:172", "å‡†å¤‡å†™å…¥ç¼“å­˜çš„æ¶ˆæ¯æ•°æ®:", messageData);
        try {
          uni.setStorageSync("messageReadStatusData", JSON.stringify(messageData));
          formatAppLog("log", "at pages/message/ChatComponent/Message.vue:177", "æ¶ˆæ¯æ•°æ®å·²æˆåŠŸå†™å…¥ç¼“å­˜");
        } catch (error) {
          formatAppLog("error", "at pages/message/ChatComponent/Message.vue:179", "å†™å…¥ç¼“å­˜å¤±è´¥:", error);
          uni.showToast({
            title: "ä¿å­˜æ¶ˆæ¯æ•°æ®å¤±è´¥",
            icon: "none"
          });
          return;
        }
        uni.navigateTo({
          url: "/pages/message/ChatComponent/MessageReadStatus",
          success: (res) => {
            formatAppLog("log", "at pages/message/ChatComponent/Message.vue:191", "æˆåŠŸè·³è½¬åˆ°æ¶ˆæ¯å·²è¯»çŠ¶æ€é¡µé¢");
          },
          fail: (err) => {
            formatAppLog("error", "at pages/message/ChatComponent/Message.vue:194", "è·³è½¬åˆ°æ¶ˆæ¯å·²è¯»çŠ¶æ€é¡µé¢å¤±è´¥:", err);
            uni.showToast({
              title: "é¡µé¢è·³è½¬å¤±è´¥",
              icon: "none"
            });
          }
        });
      };
      return {
        formatTime: formatTime2,
        viewBurnAfterReading,
        handleMessageDeleted,
        userStore,
        getReadCount,
        handleReadCountClick
      };
    }
  };
  function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_LocationMessage = vue.resolveComponent("LocationMessage");
    const _component_ImageMessage = vue.resolveComponent("ImageMessage");
    const _component_FileMessage = vue.resolveComponent("FileMessage");
    const _component_VoiceMessageBubble = vue.resolveComponent("VoiceMessageBubble");
    const _component_AudioMessage = vue.resolveComponent("AudioMessage");
    const _component_BurnAfterReadingMessage = vue.resolveComponent("BurnAfterReadingMessage");
    const _component_BurnAfterReadingTextMessage = vue.resolveComponent("BurnAfterReadingTextMessage");
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["message", [$props.message.userType]])
      },
      [
        vue.createElementVNode(
          "view",
          { class: "message-time" },
          vue.toDisplayString($setup.formatTime($props.message.timestamp)),
          1
          /* TEXT */
        ),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["message-content", { "self-message": $props.message.userType === "self" }])
          },
          [
            vue.createElementVNode("view", { class: "avatar-container" }, [
              vue.createElementVNode("image", {
                src: _imports_0$4,
                class: "avatar",
                mode: "aspectFill"
              }),
              $props.isGroup && $props.message.userType === "other" ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 0,
                class: "sender-name"
              })) : vue.createCommentVNode("v-if", true)
            ]),
            vue.createElementVNode("view", { class: "content-wrapper" }, [
              $props.message.userType === "friend" ? (vue.openBlock(), vue.createElementBlock(
                "view",
                {
                  key: 0,
                  class: "friend-name"
                },
                vue.toDisplayString($props.message.name),
                1
                /* TEXT */
              )) : vue.createCommentVNode("v-if", true),
              vue.createElementVNode("view", { class: "content-container" }, [
                vue.createElementVNode(
                  "view",
                  {
                    class: vue.normalizeClass(["content", {
                      "location-content": $props.message.type === "location",
                      "file-message": $props.message.type === "file",
                      "message-image": $props.message.type === "image",
                      "voice-message": $props.message.type === "voice_message",
                      "audio-message": $props.message.type === "audio",
                      "burn-after-reading": $props.message.selfDestruct && $props.message.messageType === "MESSAGE"
                    }])
                  },
                  [
                    vue.createCommentVNode(" æ ¹æ®æ¶ˆæ¯ç±»åž‹æ¸²æŸ“ä¸åŒçš„ç»„ä»¶ "),
                    $props.message.type === "location" ? (vue.openBlock(), vue.createBlock(_component_LocationMessage, {
                      key: 0,
                      content: $props.message.content
                    }, null, 8, ["content"])) : $props.message.type === "image" ? (vue.openBlock(), vue.createBlock(_component_ImageMessage, {
                      key: 1,
                      content: $props.message.content
                    }, null, 8, ["content"])) : $props.message.type === "file" ? (vue.openBlock(), vue.createBlock(_component_FileMessage, {
                      key: 2,
                      content: $props.message.content,
                      messageType: $props.message.messageType
                    }, null, 8, ["content", "messageType"])) : $props.message.type === "voice_message" ? (vue.openBlock(), vue.createBlock(_component_VoiceMessageBubble, {
                      key: 3,
                      content: {
                        url: $props.message.content,
                        duration: $props.message.duration,
                        isSelf: $props.message.userType === "self"
                      }
                    }, null, 8, ["content"])) : $props.message.type === "audio" ? (vue.openBlock(), vue.createBlock(_component_AudioMessage, {
                      key: 4,
                      content: $props.message.content,
                      messageType: $props.message.messageType
                    }, null, 8, ["content", "messageType"])) : $props.message.type === "burn-after-reading" ? (vue.openBlock(), vue.createBlock(_component_BurnAfterReadingMessage, {
                      key: 5,
                      content: $props.message.content,
                      onViewBurnAfterReading: $setup.viewBurnAfterReading
                    }, null, 8, ["content", "onViewBurnAfterReading"])) : $props.message.selfDestruct && $props.message.messageType === "MESSAGE" ? (vue.openBlock(), vue.createBlock(_component_BurnAfterReadingTextMessage, {
                      key: 6,
                      messageId: $props.message.id,
                      isGroup: $props.isGroup,
                      onMessageDeleted: $setup.handleMessageDeleted
                    }, null, 8, ["messageId", "isGroup", "onMessageDeleted"])) : (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 7 },
                      [
                        vue.createTextVNode(
                          vue.toDisplayString($props.message.content || ""),
                          1
                          /* TEXT */
                        )
                      ],
                      64
                      /* STABLE_FRAGMENT */
                    ))
                  ],
                  2
                  /* CLASS */
                ),
                vue.createCommentVNode(" å·²è¯»äººæ•°æŒ‡ç¤ºå™¨ "),
                $props.isGroup ? (vue.openBlock(), vue.createElementBlock(
                  "view",
                  {
                    key: 0,
                    class: vue.normalizeClass(["read-count", { "read-count-self": $props.message.userType === "self" }]),
                    onClick: _cache[0] || (_cache[0] = (...args) => $setup.handleReadCountClick && $setup.handleReadCountClick(...args))
                  },
                  vue.toDisplayString($setup.getReadCount),
                  3
                  /* TEXT, CLASS */
                )) : $props.message.userType === "self" ? (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 1 },
                  [
                    vue.createCommentVNode(" ç§èŠæ¶ˆæ¯é˜…è¯»çŠ¶æ€ "),
                    vue.createElementVNode(
                      "view",
                      {
                        class: vue.normalizeClass(["read-status", { "read": $props.message.isRead, "unread": !$props.message.isRead }])
                      },
                      vue.toDisplayString($props.message.isRead ? "å·²è¯»" : "æœªè¯»"),
                      3
                      /* TEXT, CLASS */
                    )
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                )) : vue.createCommentVNode("v-if", true)
              ])
            ]),
            vue.createCommentVNode(" æ¶ˆæ¯çŠ¶æ€ï¼ˆä»…å¯¹è‡ªå·±å‘é€çš„æ¶ˆæ¯æ˜¾ç¤ºï¼‰ "),
            $props.message.userType === "self" ? (vue.openBlock(), vue.createElementBlock("view", {
              key: 0,
              class: "message-status"
            }, [
              $props.message.status === "sending" ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 0,
                class: "loading-icon"
              })) : $props.message.status === "failed" ? (vue.openBlock(), vue.createElementBlock("view", {
                key: 1,
                class: "failed-icon"
              }, "!")) : vue.createCommentVNode("v-if", true)
            ])) : vue.createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        )
      ],
      2
      /* CLASS */
    );
  }
  const Message = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$s], ["__scopeId", "data-v-1cea873d"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/Message.vue"]]);
  const _sfc_main$s = {
    name: "MessageList",
    components: {
      Message
    },
    props: {
      messages: {
        type: Array,
        required: true
      },
      scrollTop: {
        type: Number,
        default: 0
      },
      isGroup: {
        type: Boolean,
        default: false
      },
      onMessageDeleted: {
        type: Function,
        required: true
      }
    },
    data() {
      return {
        showLoadMore: false,
        internalScrollTop: 0,
        scrollViewHeight: 0,
        lastContentHeight: 0,
        isScrolling: false
        // æ ‡è®°æ˜¯å¦æ­£åœ¨æ»šåŠ¨
      };
    },
    watch: {
      messages: {
        handler(newMessages, oldMessages) {
          this.$nextTick(async () => {
            const newContentHeight = await this.getContentHeight();
            if (!oldMessages || newMessages.length > oldMessages.length) {
              if (!oldMessages || newMessages.length - oldMessages.length === 1 && newMessages[newMessages.length - 1].userType === "self") {
                this.scrollToBottom(true);
              } else {
                const heightDifference = newContentHeight - this.lastContentHeight;
                formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:80", "åŠ è½½æ›´å¤šæ¶ˆæ¯ï¼Œä¿æŒä½ç½®ã€‚é«˜åº¦å·®:", heightDifference);
                if (heightDifference > 0) {
                  this.setScrollTop(this.internalScrollTop + heightDifference);
                }
              }
            }
            this.lastContentHeight = newContentHeight;
          });
        },
        immediate: true
      }
    },
    mounted() {
      formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:93", "MessageListç»„ä»¶æŒ‚è½½");
      this.initScrollViewHeight();
      this.getContentHeight().then((height) => {
        this.lastContentHeight = height;
        this.$nextTick(() => {
          this.scrollToBottom(true);
        });
      });
    },
    methods: {
      initScrollViewHeight() {
        const query = uni.createSelectorQuery().in(this);
        query.select(".message-list-container").boundingClientRect((data) => {
          if (data) {
            this.scrollViewHeight = data.height;
            formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:108", "æ»šåŠ¨è§†å›¾é«˜åº¦åˆå§‹åŒ–:", this.scrollViewHeight);
          }
        }).exec();
      },
      async getContentHeight() {
        return new Promise((resolve) => {
          const query = uni.createSelectorQuery().in(this);
          query.select(".message-list-content").boundingClientRect((data) => {
            if (data) {
              resolve(data.height);
            } else {
              formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:119", "æ— æ³•èŽ·å–å†…å®¹é«˜åº¦");
              resolve(0);
            }
          }).exec();
        });
      },
      onScroll(event) {
        if (this.isScrolling)
          return;
        const { scrollTop, scrollHeight } = event.detail;
        this.showLoadMore = scrollTop < 50;
        this.$emit("scroll", event);
      },
      handleLoadMore() {
        formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:135", "è§¦å‘åŠ è½½æ›´å¤š");
        this.$emit("load-more");
      },
      async scrollToBottom(force = false) {
        if (this.isScrolling && !force) {
          formatAppLog("log", "at pages/message/ChatComponent/MessageList.vue:140", "å·²åœ¨æ»šåŠ¨ä¸­ï¼Œè·³è¿‡");
          return;
        }
        this.isScrolling = true;
        try {
          const contentHeight = await this.getContentHeight();
          const scrollTop = Math.max(0, contentHeight - this.scrollViewHeight);
          this.setScrollTop(scrollTop);
          await new Promise((resolve) => setTimeout(resolve, 100));
          this.setScrollTop(scrollTop);
        } finally {
          setTimeout(() => {
            this.isScrolling = false;
          }, 200);
        }
      },
      setScrollTop(value) {
        this.internalScrollTop = value;
      }
    }
  };
  function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_message = vue.resolveComponent("message");
    return vue.openBlock(), vue.createElementBlock("view", { class: "message-list-container" }, [
      vue.createElementVNode("scroll-view", {
        class: "scroll-view",
        "scroll-y": "",
        "scroll-top": $data.internalScrollTop,
        onScroll: _cache[2] || (_cache[2] = (...args) => $options.onScroll && $options.onScroll(...args)),
        style: vue.normalizeStyle({ height: $data.scrollViewHeight + "px" })
      }, [
        vue.createCommentVNode(" åŠ è½½æ›´å¤šæŒ‰é’® "),
        $data.showLoadMore ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "load-more-button",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.handleLoadMore && $options.handleLoadMore(...args))
        }, [
          vue.createElementVNode("text", { class: "load-more-text" }, "ç‚¹å‡»åŠ è½½æ›´å¤š")
        ])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("view", { class: "message-list-content" }, [
          vue.createCommentVNode(" éåŽ†æ¶ˆæ¯åˆ—è¡¨ï¼Œæ¸²æŸ“æ¯æ¡æ¶ˆæ¯ "),
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($props.messages, (item, index) => {
              return vue.openBlock(), vue.createBlock(_component_message, {
                key: item.id || index,
                id: `message-${index}`,
                message: item,
                "is-group": $props.isGroup,
                onViewBurnAfterReading: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("view-burn-after-reading", $event)),
                onMessageDeleted: $props.onMessageDeleted
              }, null, 8, ["id", "message", "is-group", "onMessageDeleted"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ], 44, ["scroll-top"])
    ]);
  }
  const MessageList = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$r], ["__scopeId", "data-v-dee4eb4b"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageList.vue"]]);
  const _sfc_main$r = {
    name: "AttachmentMenu",
    data() {
      return {
        // é™„ä»¶é€‰é¡¹é…ç½®
        attachOptions: [
          { icon: "/static/message/ç›¸å†Œ.png", label: "ç›¸å†Œ", action: "album" },
          { icon: "/static/message/æ‹æ‘„.png", label: "æ‹æ‘„", action: "camera" },
          { icon: "/static/message/è§†é¢‘é€šè¯.png", label: "è§†é¢‘é€šè¯", action: "video-call" },
          { icon: "/static/message/æ–‡ä»¶ä¼ è¾“.png", label: "æ–‡ä»¶ä¼ è¾“", action: "file" },
          { icon: "/static/message/é˜…åŽå³ç„š.png", label: "é˜…åŽå³ç„š", action: "burn-after-reading" },
          { icon: "/static/message/ä½ç½®.png", label: "ä½ç½®", action: "location" }
        ]
      };
    },
    methods: {
      // å¤„ç†é™„ä»¶é¡¹ç‚¹å‡»
      handleAttachItem(action) {
        this.$emit("attach", action);
        this.$emit("close");
      }
    }
  };
  function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "attach-menu" }, [
      vue.createElementVNode("view", { class: "attach-row" }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($data.attachOptions.slice(0, 4), (option) => {
            return vue.openBlock(), vue.createElementBlock("view", {
              key: option.action,
              class: "attach-option",
              onClick: ($event) => $options.handleAttachItem(option.action)
            }, [
              vue.createElementVNode("view", { class: "icon-wrapper" }, [
                vue.createElementVNode("image", {
                  src: option.icon,
                  class: "attach-icon",
                  mode: "aspectFit"
                }, null, 8, ["src"])
              ]),
              vue.createElementVNode(
                "text",
                { class: "attach-label" },
                vue.toDisplayString(option.label),
                1
                /* TEXT */
              )
            ], 8, ["onClick"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]),
      vue.createElementVNode("view", { class: "attach-row second-row" }, [
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($data.attachOptions.slice(4, 6), (option) => {
            return vue.openBlock(), vue.createElementBlock("view", {
              key: option.action,
              class: "attach-option",
              onClick: ($event) => $options.handleAttachItem(option.action)
            }, [
              vue.createElementVNode("view", { class: "icon-wrapper" }, [
                vue.createElementVNode("image", {
                  src: option.icon,
                  class: "attach-icon",
                  mode: "aspectFit"
                }, null, 8, ["src"])
              ]),
              vue.createElementVNode(
                "text",
                { class: "attach-label" },
                vue.toDisplayString(option.label),
                1
                /* TEXT */
              )
            ], 8, ["onClick"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ])
    ]);
  }
  const AttachmentMenu = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$q], ["__scopeId", "data-v-00ea5aaf"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/AttachmentMenu.vue"]]);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n2) {
    if (n2.__esModule)
      return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a2 = function a3() {
        if (this instanceof a3) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a2.prototype = f2.prototype;
    } else
      a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k) {
      var d2 = Object.getOwnPropertyDescriptor(n2, k);
      Object.defineProperty(a2, k, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n2[k];
        }
      });
    });
    return a2;
  }
  var cryptoJs = { exports: {} };
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var core = { exports: {} };
  const __viteBrowserExternal = new Proxy({}, {
    get(_2, key) {
      throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${key}" in client code.  See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
    }
  });
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  var hasRequiredCore;
  function requireCore() {
    if (hasRequiredCore)
      return core.exports;
    hasRequiredCore = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory();
        }
      })(commonjsGlobal, function() {
        var CryptoJS2 = CryptoJS2 || function(Math2, undefined$1) {
          var crypto;
          if (typeof window !== "undefined" && $inject_window_crypto) {
            crypto = $inject_window_crypto;
          }
          if (typeof self !== "undefined" && self.crypto) {
            crypto = self.crypto;
          }
          if (typeof globalThis !== "undefined" && globalThis.crypto) {
            crypto = globalThis.crypto;
          }
          if (!crypto && typeof window !== "undefined" && window.msCrypto) {
            crypto = window.msCrypto;
          }
          if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
            crypto = commonjsGlobal.crypto;
          }
          if (!crypto && typeof commonjsRequire === "function") {
            try {
              crypto = require$$0;
            } catch (err) {
            }
          }
          var cryptoSecureRandomInt = function() {
            if (crypto) {
              if (typeof crypto.getRandomValues === "function") {
                try {
                  return crypto.getRandomValues(new Uint32Array(1))[0];
                } catch (err) {
                }
              }
              if (typeof crypto.randomBytes === "function") {
                try {
                  return crypto.randomBytes(4).readInt32LE();
                } catch (err) {
                }
              }
            }
            throw new Error("Native crypto module could not be used to get secure random number.");
          };
          var create = Object.create || /* @__PURE__ */ function() {
            function F2() {
            }
            return function(obj) {
              var subtype;
              F2.prototype = obj;
              subtype = new F2();
              F2.prototype = null;
              return subtype;
            };
          }();
          var C2 = {};
          var C_lib = C2.lib = {};
          var Base = C_lib.Base = /* @__PURE__ */ function() {
            return {
              /**
               * Creates a new object that inherits from this object.
               *
               * @param {Object} overrides Properties to copy into the new object.
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         field: 'value',
               *
               *         method: function () {
               *         }
               *     });
               */
              extend: function(overrides) {
                var subtype = create(this);
                if (overrides) {
                  subtype.mixIn(overrides);
                }
                if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                  subtype.init = function() {
                    subtype.$super.init.apply(this, arguments);
                  };
                }
                subtype.init.prototype = subtype;
                subtype.$super = this;
                return subtype;
              },
              /**
               * Extends this object and runs the init method.
               * Arguments to create() will be passed to init().
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var instance = MyType.create();
               */
              create: function() {
                var instance = this.extend();
                instance.init.apply(instance, arguments);
                return instance;
              },
              /**
               * Initializes a newly created object.
               * Override this method to add some logic when your objects are created.
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         init: function () {
               *             // ...
               *         }
               *     });
               */
              init: function() {
              },
              /**
               * Copies properties into this object.
               *
               * @param {Object} properties The properties to mix in.
               *
               * @example
               *
               *     MyType.mixIn({
               *         field: 'value'
               *     });
               */
              mixIn: function(properties) {
                for (var propertyName in properties) {
                  if (properties.hasOwnProperty(propertyName)) {
                    this[propertyName] = properties[propertyName];
                  }
                }
                if (properties.hasOwnProperty("toString")) {
                  this.toString = properties.toString;
                }
              },
              /**
               * Creates a copy of this object.
               *
               * @return {Object} The clone.
               *
               * @example
               *
               *     var clone = instance.clone();
               */
              clone: function() {
                return this.init.prototype.extend(this);
              }
            };
          }();
          var WordArray = C_lib.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of 32-bit words.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.create();
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined$1) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 4;
              }
            },
            /**
             * Converts this word array to a string.
             *
             * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
             *
             * @return {string} The stringified word array.
             *
             * @example
             *
             *     var string = wordArray + '';
             *     var string = wordArray.toString();
             *     var string = wordArray.toString(CryptoJS.enc.Utf8);
             */
            toString: function(encoder) {
              return (encoder || Hex).stringify(this);
            },
            /**
             * Concatenates a word array to this word array.
             *
             * @param {WordArray} wordArray The word array to append.
             *
             * @return {WordArray} This word array.
             *
             * @example
             *
             *     wordArray1.concat(wordArray2);
             */
            concat: function(wordArray) {
              var thisWords = this.words;
              var thatWords = wordArray.words;
              var thisSigBytes = this.sigBytes;
              var thatSigBytes = wordArray.sigBytes;
              this.clamp();
              if (thisSigBytes % 4) {
                for (var i2 = 0; i2 < thatSigBytes; i2++) {
                  var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                  thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
                }
              } else {
                for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                  thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
                }
              }
              this.sigBytes += thatSigBytes;
              return this;
            },
            /**
             * Removes insignificant bits.
             *
             * @example
             *
             *     wordArray.clamp();
             */
            clamp: function() {
              var words = this.words;
              var sigBytes = this.sigBytes;
              words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
              words.length = Math2.ceil(sigBytes / 4);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {WordArray} The clone.
             *
             * @example
             *
             *     var clone = wordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone.words = this.words.slice(0);
              return clone;
            },
            /**
             * Creates a word array filled with random bytes.
             *
             * @param {number} nBytes The number of random bytes to generate.
             *
             * @return {WordArray} The random word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.random(16);
             */
            random: function(nBytes) {
              var words = [];
              for (var i2 = 0; i2 < nBytes; i2 += 4) {
                words.push(cryptoSecureRandomInt());
              }
              return new WordArray.init(words, nBytes);
            }
          });
          var C_enc = C2.enc = {};
          var Hex = C_enc.Hex = {
            /**
             * Converts a word array to a hex string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The hex string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var hexChars = [];
              for (var i2 = 0; i2 < sigBytes; i2++) {
                var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 15).toString(16));
              }
              return hexChars.join("");
            },
            /**
             * Converts a hex string to a word array.
             *
             * @param {string} hexStr The hex string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
             */
            parse: function(hexStr) {
              var hexStrLength = hexStr.length;
              var words = [];
              for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
                words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
              }
              return new WordArray.init(words, hexStrLength / 2);
            }
          };
          var Latin1 = C_enc.Latin1 = {
            /**
             * Converts a word array to a Latin1 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Latin1 string.
             *
             * @static
             *
             * @example
             *
             *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var latin1Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2++) {
                var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                latin1Chars.push(String.fromCharCode(bite));
              }
              return latin1Chars.join("");
            },
            /**
             * Converts a Latin1 string to a word array.
             *
             * @param {string} latin1Str The Latin1 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
             */
            parse: function(latin1Str) {
              var latin1StrLength = latin1Str.length;
              var words = [];
              for (var i2 = 0; i2 < latin1StrLength; i2++) {
                words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
              }
              return new WordArray.init(words, latin1StrLength);
            }
          };
          var Utf8 = C_enc.Utf8 = {
            /**
             * Converts a word array to a UTF-8 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-8 string.
             *
             * @static
             *
             * @example
             *
             *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
             */
            stringify: function(wordArray) {
              try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
              } catch (e2) {
                throw new Error("Malformed UTF-8 data");
              }
            },
            /**
             * Converts a UTF-8 string to a word array.
             *
             * @param {string} utf8Str The UTF-8 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
             */
            parse: function(utf8Str) {
              return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
            }
          };
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
            /**
             * Resets this block algorithm's data buffer to its initial state.
             *
             * @example
             *
             *     bufferedBlockAlgorithm.reset();
             */
            reset: function() {
              this._data = new WordArray.init();
              this._nDataBytes = 0;
            },
            /**
             * Adds new data to this block algorithm's buffer.
             *
             * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
             *
             * @example
             *
             *     bufferedBlockAlgorithm._append('data');
             *     bufferedBlockAlgorithm._append(wordArray);
             */
            _append: function(data) {
              if (typeof data == "string") {
                data = Utf8.parse(data);
              }
              this._data.concat(data);
              this._nDataBytes += data.sigBytes;
            },
            /**
             * Processes available data blocks.
             *
             * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
             *
             * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
             *
             * @return {WordArray} The processed data.
             *
             * @example
             *
             *     var processedData = bufferedBlockAlgorithm._process();
             *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
             */
            _process: function(doFlush) {
              var processedWords;
              var data = this._data;
              var dataWords = data.words;
              var dataSigBytes = data.sigBytes;
              var blockSize = this.blockSize;
              var blockSizeBytes = blockSize * 4;
              var nBlocksReady = dataSigBytes / blockSizeBytes;
              if (doFlush) {
                nBlocksReady = Math2.ceil(nBlocksReady);
              } else {
                nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
              }
              var nWordsReady = nBlocksReady * blockSize;
              var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
              if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                  this._doProcessBlock(dataWords, offset);
                }
                processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
              }
              return new WordArray.init(processedWords, nBytesReady);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = bufferedBlockAlgorithm.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone._data = this._data.clone();
              return clone;
            },
            _minBufferSize: 0
          });
          C_lib.Hasher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             */
            cfg: Base.extend(),
            /**
             * Initializes a newly created hasher.
             *
             * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
             *
             * @example
             *
             *     var hasher = CryptoJS.algo.SHA256.create();
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
              this.reset();
            },
            /**
             * Resets this hasher to its initial state.
             *
             * @example
             *
             *     hasher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Updates this hasher with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {Hasher} This hasher.
             *
             * @example
             *
             *     hasher.update('message');
             *     hasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._append(messageUpdate);
              this._process();
              return this;
            },
            /**
             * Finalizes the hash computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The hash.
             *
             * @example
             *
             *     var hash = hasher.finalize();
             *     var hash = hasher.finalize('message');
             *     var hash = hasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              if (messageUpdate) {
                this._append(messageUpdate);
              }
              var hash = this._doFinalize();
              return hash;
            },
            blockSize: 512 / 32,
            /**
             * Creates a shortcut function to a hasher's object interface.
             *
             * @param {Hasher} hasher The hasher to create a helper for.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
             */
            _createHelper: function(hasher) {
              return function(message, cfg) {
                return new hasher.init(cfg).finalize(message);
              };
            },
            /**
             * Creates a shortcut function to the HMAC's object interface.
             *
             * @param {Hasher} hasher The hasher to use in this HMAC helper.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
             */
            _createHmacHelper: function(hasher) {
              return function(message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
              };
            }
          });
          var C_algo = C2.algo = {};
          return C2;
        }(Math);
        return CryptoJS2;
      });
    })(core);
    return core.exports;
  }
  var x64Core = { exports: {} };
  var hasRequiredX64Core;
  function requireX64Core() {
    if (hasRequiredX64Core)
      return x64Core.exports;
    hasRequiredX64Core = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(undefined$1) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var X32WordArray = C_lib.WordArray;
          var C_x64 = C2.x64 = {};
          C_x64.Word = Base.extend({
            /**
             * Initializes a newly created 64-bit word.
             *
             * @param {number} high The high 32 bits.
             * @param {number} low The low 32 bits.
             *
             * @example
             *
             *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
             */
            init: function(high, low) {
              this.high = high;
              this.low = low;
            }
            /**
             * Bitwise NOTs this word.
             *
             * @return {X64Word} A new x64-Word object after negating.
             *
             * @example
             *
             *     var negated = x64Word.not();
             */
            // not: function () {
            // var high = ~this.high;
            // var low = ~this.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ANDs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to AND with this word.
             *
             * @return {X64Word} A new x64-Word object after ANDing.
             *
             * @example
             *
             *     var anded = x64Word.and(anotherX64Word);
             */
            // and: function (word) {
            // var high = this.high & word.high;
            // var low = this.low & word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to OR with this word.
             *
             * @return {X64Word} A new x64-Word object after ORing.
             *
             * @example
             *
             *     var ored = x64Word.or(anotherX64Word);
             */
            // or: function (word) {
            // var high = this.high | word.high;
            // var low = this.low | word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise XORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to XOR with this word.
             *
             * @return {X64Word} A new x64-Word object after XORing.
             *
             * @example
             *
             *     var xored = x64Word.xor(anotherX64Word);
             */
            // xor: function (word) {
            // var high = this.high ^ word.high;
            // var low = this.low ^ word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the left.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftL(25);
             */
            // shiftL: function (n) {
            // if (n < 32) {
            // var high = (this.high << n) | (this.low >>> (32 - n));
            // var low = this.low << n;
            // } else {
            // var high = this.low << (n - 32);
            // var low = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the right.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftR(7);
             */
            // shiftR: function (n) {
            // if (n < 32) {
            // var low = (this.low >>> n) | (this.high << (32 - n));
            // var high = this.high >>> n;
            // } else {
            // var low = this.high >>> (n - 32);
            // var high = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Rotates this word n bits to the left.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotL(25);
             */
            // rotL: function (n) {
            // return this.shiftL(n).or(this.shiftR(64 - n));
            // },
            /**
             * Rotates this word n bits to the right.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotR(7);
             */
            // rotR: function (n) {
            // return this.shiftR(n).or(this.shiftL(64 - n));
            // },
            /**
             * Adds this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to add with this word.
             *
             * @return {X64Word} A new x64-Word object after adding.
             *
             * @example
             *
             *     var added = x64Word.add(anotherX64Word);
             */
            // add: function (word) {
            // var low = (this.low + word.low) | 0;
            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
            // var high = (this.high + word.high + carry) | 0;
            // return X64Word.create(high, low);
            // }
          });
          C_x64.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.x64.WordArray.create();
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ]);
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ], 10);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined$1) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 8;
              }
            },
            /**
             * Converts this 64-bit word array to a 32-bit word array.
             *
             * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
             *
             * @example
             *
             *     var x32WordArray = x64WordArray.toX32();
             */
            toX32: function() {
              var x64Words = this.words;
              var x64WordsLength = x64Words.length;
              var x32Words = [];
              for (var i2 = 0; i2 < x64WordsLength; i2++) {
                var x64Word = x64Words[i2];
                x32Words.push(x64Word.high);
                x32Words.push(x64Word.low);
              }
              return X32WordArray.create(x32Words, this.sigBytes);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {X64WordArray} The clone.
             *
             * @example
             *
             *     var clone = x64WordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              var words = clone.words = this.words.slice(0);
              var wordsLength = words.length;
              for (var i2 = 0; i2 < wordsLength; i2++) {
                words[i2] = words[i2].clone();
              }
              return clone;
            }
          });
        })();
        return CryptoJS2;
      });
    })(x64Core);
    return x64Core.exports;
  }
  var libTypedarrays = { exports: {} };
  var hasRequiredLibTypedarrays;
  function requireLibTypedarrays() {
    if (hasRequiredLibTypedarrays)
      return libTypedarrays.exports;
    hasRequiredLibTypedarrays = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          if (typeof ArrayBuffer != "function") {
            return;
          }
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var superInit = WordArray.init;
          var subInit = WordArray.init = function(typedArray) {
            if (typedArray instanceof ArrayBuffer) {
              typedArray = new Uint8Array(typedArray);
            }
            if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
              typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
            }
            if (typedArray instanceof Uint8Array) {
              var typedArrayByteLength = typedArray.byteLength;
              var words = [];
              for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
                words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
              }
              superInit.call(this, words, typedArrayByteLength);
            } else {
              superInit.apply(this, arguments);
            }
          };
          subInit.prototype = WordArray;
        })();
        return CryptoJS2.lib.WordArray;
      });
    })(libTypedarrays);
    return libTypedarrays.exports;
  }
  var encUtf16 = { exports: {} };
  var hasRequiredEncUtf16;
  function requireEncUtf16() {
    if (hasRequiredEncUtf16)
      return encUtf16.exports;
    hasRequiredEncUtf16 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C2.enc;
          C_enc.Utf16 = C_enc.Utf16BE = {
            /**
             * Converts a word array to a UTF-16 BE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 BE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 2) {
                var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 BE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 BE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i2 = 0; i2 < utf16StrLength; i2++) {
                words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          C_enc.Utf16LE = {
            /**
             * Converts a word array to a UTF-16 LE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 LE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 2) {
                var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 LE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 LE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i2 = 0; i2 < utf16StrLength; i2++) {
                words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          function swapEndian(word) {
            return word << 8 & 4278255360 | word >>> 8 & 16711935;
          }
        })();
        return CryptoJS2.enc.Utf16;
      });
    })(encUtf16);
    return encUtf16.exports;
  }
  var encBase64 = { exports: {} };
  var hasRequiredEncBase64;
  function requireEncBase64() {
    if (hasRequiredEncBase64)
      return encBase64.exports;
    hasRequiredEncBase64 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C2.enc;
          C_enc.Base64 = {
            /**
             * Converts a word array to a Base64 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Base64 string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map2 = this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 3) {
                var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
                var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j2 = 0; j2 < 4 && i2 + j2 * 0.75 < sigBytes; j2++) {
                  base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64 string to a word array.
             *
             * @param {string} base64Str The Base64 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
             */
            parse: function(base64Str) {
              var base64StrLength = base64Str.length;
              var map2 = this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j2 = 0; j2 < map2.length; j2++) {
                  reverseMap[map2.charCodeAt(j2)] = j2;
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i2 = 0; i2 < base64StrLength; i2++) {
              if (i2 % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS2.enc.Base64;
      });
    })(encBase64);
    return encBase64.exports;
  }
  var encBase64url = { exports: {} };
  var hasRequiredEncBase64url;
  function requireEncBase64url() {
    if (hasRequiredEncBase64url)
      return encBase64url.exports;
    hasRequiredEncBase64url = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C2.enc;
          C_enc.Base64url = {
            /**
             * Converts a word array to a Base64url string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {string} The Base64url string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
             */
            stringify: function(wordArray, urlSafe) {
              if (urlSafe === void 0) {
                urlSafe = true;
              }
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map2 = urlSafe ? this._safe_map : this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 3) {
                var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
                var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j2 = 0; j2 < 4 && i2 + j2 * 0.75 < sigBytes; j2++) {
                  base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64url string to a word array.
             *
             * @param {string} base64Str The Base64url string.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
             */
            parse: function(base64Str, urlSafe) {
              if (urlSafe === void 0) {
                urlSafe = true;
              }
              var base64StrLength = base64Str.length;
              var map2 = urlSafe ? this._safe_map : this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j2 = 0; j2 < map2.length; j2++) {
                  reverseMap[map2.charCodeAt(j2)] = j2;
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i2 = 0; i2 < base64StrLength; i2++) {
              if (i2 % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS2.enc.Base64url;
      });
    })(encBase64url);
    return encBase64url.exports;
  }
  var md5 = { exports: {} };
  var hasRequiredMd5;
  function requireMd5() {
    if (hasRequiredMd5)
      return md5.exports;
    hasRequiredMd5 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(Math2) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C2.algo;
          var T2 = [];
          (function() {
            for (var i2 = 0; i2 < 64; i2++) {
              T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
            }
          })();
          var MD5 = C_algo.MD5 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878
              ]);
            },
            _doProcessBlock: function(M2, offset) {
              for (var i2 = 0; i2 < 16; i2++) {
                var offset_i = offset + i2;
                var M_offset_i = M2[offset_i];
                M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H2 = this._hash.words;
              var M_offset_0 = M2[offset + 0];
              var M_offset_1 = M2[offset + 1];
              var M_offset_2 = M2[offset + 2];
              var M_offset_3 = M2[offset + 3];
              var M_offset_4 = M2[offset + 4];
              var M_offset_5 = M2[offset + 5];
              var M_offset_6 = M2[offset + 6];
              var M_offset_7 = M2[offset + 7];
              var M_offset_8 = M2[offset + 8];
              var M_offset_9 = M2[offset + 9];
              var M_offset_10 = M2[offset + 10];
              var M_offset_11 = M2[offset + 11];
              var M_offset_12 = M2[offset + 12];
              var M_offset_13 = M2[offset + 13];
              var M_offset_14 = M2[offset + 14];
              var M_offset_15 = M2[offset + 15];
              var a2 = H2[0];
              var b2 = H2[1];
              var c2 = H2[2];
              var d2 = H2[3];
              a2 = FF(a2, b2, c2, d2, M_offset_0, 7, T2[0]);
              d2 = FF(d2, a2, b2, c2, M_offset_1, 12, T2[1]);
              c2 = FF(c2, d2, a2, b2, M_offset_2, 17, T2[2]);
              b2 = FF(b2, c2, d2, a2, M_offset_3, 22, T2[3]);
              a2 = FF(a2, b2, c2, d2, M_offset_4, 7, T2[4]);
              d2 = FF(d2, a2, b2, c2, M_offset_5, 12, T2[5]);
              c2 = FF(c2, d2, a2, b2, M_offset_6, 17, T2[6]);
              b2 = FF(b2, c2, d2, a2, M_offset_7, 22, T2[7]);
              a2 = FF(a2, b2, c2, d2, M_offset_8, 7, T2[8]);
              d2 = FF(d2, a2, b2, c2, M_offset_9, 12, T2[9]);
              c2 = FF(c2, d2, a2, b2, M_offset_10, 17, T2[10]);
              b2 = FF(b2, c2, d2, a2, M_offset_11, 22, T2[11]);
              a2 = FF(a2, b2, c2, d2, M_offset_12, 7, T2[12]);
              d2 = FF(d2, a2, b2, c2, M_offset_13, 12, T2[13]);
              c2 = FF(c2, d2, a2, b2, M_offset_14, 17, T2[14]);
              b2 = FF(b2, c2, d2, a2, M_offset_15, 22, T2[15]);
              a2 = GG(a2, b2, c2, d2, M_offset_1, 5, T2[16]);
              d2 = GG(d2, a2, b2, c2, M_offset_6, 9, T2[17]);
              c2 = GG(c2, d2, a2, b2, M_offset_11, 14, T2[18]);
              b2 = GG(b2, c2, d2, a2, M_offset_0, 20, T2[19]);
              a2 = GG(a2, b2, c2, d2, M_offset_5, 5, T2[20]);
              d2 = GG(d2, a2, b2, c2, M_offset_10, 9, T2[21]);
              c2 = GG(c2, d2, a2, b2, M_offset_15, 14, T2[22]);
              b2 = GG(b2, c2, d2, a2, M_offset_4, 20, T2[23]);
              a2 = GG(a2, b2, c2, d2, M_offset_9, 5, T2[24]);
              d2 = GG(d2, a2, b2, c2, M_offset_14, 9, T2[25]);
              c2 = GG(c2, d2, a2, b2, M_offset_3, 14, T2[26]);
              b2 = GG(b2, c2, d2, a2, M_offset_8, 20, T2[27]);
              a2 = GG(a2, b2, c2, d2, M_offset_13, 5, T2[28]);
              d2 = GG(d2, a2, b2, c2, M_offset_2, 9, T2[29]);
              c2 = GG(c2, d2, a2, b2, M_offset_7, 14, T2[30]);
              b2 = GG(b2, c2, d2, a2, M_offset_12, 20, T2[31]);
              a2 = HH(a2, b2, c2, d2, M_offset_5, 4, T2[32]);
              d2 = HH(d2, a2, b2, c2, M_offset_8, 11, T2[33]);
              c2 = HH(c2, d2, a2, b2, M_offset_11, 16, T2[34]);
              b2 = HH(b2, c2, d2, a2, M_offset_14, 23, T2[35]);
              a2 = HH(a2, b2, c2, d2, M_offset_1, 4, T2[36]);
              d2 = HH(d2, a2, b2, c2, M_offset_4, 11, T2[37]);
              c2 = HH(c2, d2, a2, b2, M_offset_7, 16, T2[38]);
              b2 = HH(b2, c2, d2, a2, M_offset_10, 23, T2[39]);
              a2 = HH(a2, b2, c2, d2, M_offset_13, 4, T2[40]);
              d2 = HH(d2, a2, b2, c2, M_offset_0, 11, T2[41]);
              c2 = HH(c2, d2, a2, b2, M_offset_3, 16, T2[42]);
              b2 = HH(b2, c2, d2, a2, M_offset_6, 23, T2[43]);
              a2 = HH(a2, b2, c2, d2, M_offset_9, 4, T2[44]);
              d2 = HH(d2, a2, b2, c2, M_offset_12, 11, T2[45]);
              c2 = HH(c2, d2, a2, b2, M_offset_15, 16, T2[46]);
              b2 = HH(b2, c2, d2, a2, M_offset_2, 23, T2[47]);
              a2 = II(a2, b2, c2, d2, M_offset_0, 6, T2[48]);
              d2 = II(d2, a2, b2, c2, M_offset_7, 10, T2[49]);
              c2 = II(c2, d2, a2, b2, M_offset_14, 15, T2[50]);
              b2 = II(b2, c2, d2, a2, M_offset_5, 21, T2[51]);
              a2 = II(a2, b2, c2, d2, M_offset_12, 6, T2[52]);
              d2 = II(d2, a2, b2, c2, M_offset_3, 10, T2[53]);
              c2 = II(c2, d2, a2, b2, M_offset_10, 15, T2[54]);
              b2 = II(b2, c2, d2, a2, M_offset_1, 21, T2[55]);
              a2 = II(a2, b2, c2, d2, M_offset_8, 6, T2[56]);
              d2 = II(d2, a2, b2, c2, M_offset_15, 10, T2[57]);
              c2 = II(c2, d2, a2, b2, M_offset_6, 15, T2[58]);
              b2 = II(b2, c2, d2, a2, M_offset_13, 21, T2[59]);
              a2 = II(a2, b2, c2, d2, M_offset_4, 6, T2[60]);
              d2 = II(d2, a2, b2, c2, M_offset_11, 10, T2[61]);
              c2 = II(c2, d2, a2, b2, M_offset_2, 15, T2[62]);
              b2 = II(b2, c2, d2, a2, M_offset_9, 21, T2[63]);
              H2[0] = H2[0] + a2 | 0;
              H2[1] = H2[1] + b2 | 0;
              H2[2] = H2[2] + c2 | 0;
              H2[3] = H2[3] + d2 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
              var nBitsTotalL = nBitsTotal;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash = this._hash;
              var H2 = hash.words;
              for (var i2 = 0; i2 < 4; i2++) {
                var H_i = H2[i2];
                H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function FF(a2, b2, c2, d2, x, s2, t2) {
            var n2 = a2 + (b2 & c2 | ~b2 & d2) + x + t2;
            return (n2 << s2 | n2 >>> 32 - s2) + b2;
          }
          function GG(a2, b2, c2, d2, x, s2, t2) {
            var n2 = a2 + (b2 & d2 | c2 & ~d2) + x + t2;
            return (n2 << s2 | n2 >>> 32 - s2) + b2;
          }
          function HH(a2, b2, c2, d2, x, s2, t2) {
            var n2 = a2 + (b2 ^ c2 ^ d2) + x + t2;
            return (n2 << s2 | n2 >>> 32 - s2) + b2;
          }
          function II(a2, b2, c2, d2, x, s2, t2) {
            var n2 = a2 + (c2 ^ (b2 | ~d2)) + x + t2;
            return (n2 << s2 | n2 >>> 32 - s2) + b2;
          }
          C2.MD5 = Hasher._createHelper(MD5);
          C2.HmacMD5 = Hasher._createHmacHelper(MD5);
        })(Math);
        return CryptoJS2.MD5;
      });
    })(md5);
    return md5.exports;
  }
  var sha1 = { exports: {} };
  var hasRequiredSha1;
  function requireSha1() {
    if (hasRequiredSha1)
      return sha1.exports;
    hasRequiredSha1 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C2.algo;
          var W2 = [];
          var SHA1 = C_algo.SHA1 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
              ]);
            },
            _doProcessBlock: function(M2, offset) {
              var H2 = this._hash.words;
              var a2 = H2[0];
              var b2 = H2[1];
              var c2 = H2[2];
              var d2 = H2[3];
              var e2 = H2[4];
              for (var i2 = 0; i2 < 80; i2++) {
                if (i2 < 16) {
                  W2[i2] = M2[offset + i2] | 0;
                } else {
                  var n2 = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
                  W2[i2] = n2 << 1 | n2 >>> 31;
                }
                var t2 = (a2 << 5 | a2 >>> 27) + e2 + W2[i2];
                if (i2 < 20) {
                  t2 += (b2 & c2 | ~b2 & d2) + 1518500249;
                } else if (i2 < 40) {
                  t2 += (b2 ^ c2 ^ d2) + 1859775393;
                } else if (i2 < 60) {
                  t2 += (b2 & c2 | b2 & d2 | c2 & d2) - 1894007588;
                } else {
                  t2 += (b2 ^ c2 ^ d2) - 899497514;
                }
                e2 = d2;
                d2 = c2;
                c2 = b2 << 30 | b2 >>> 2;
                b2 = a2;
                a2 = t2;
              }
              H2[0] = H2[0] + a2 | 0;
              H2[1] = H2[1] + b2 | 0;
              H2[2] = H2[2] + c2 | 0;
              H2[3] = H2[3] + d2 | 0;
              H2[4] = H2[4] + e2 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C2.SHA1 = Hasher._createHelper(SHA1);
          C2.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        })();
        return CryptoJS2.SHA1;
      });
    })(sha1);
    return sha1.exports;
  }
  var sha256 = { exports: {} };
  var hasRequiredSha256;
  function requireSha256() {
    if (hasRequiredSha256)
      return sha256.exports;
    hasRequiredSha256 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(Math2) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C2.algo;
          var H2 = [];
          var K2 = [];
          (function() {
            function isPrime(n3) {
              var sqrtN = Math2.sqrt(n3);
              for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n3 % factor)) {
                  return false;
                }
              }
              return true;
            }
            function getFractionalBits(n3) {
              return (n3 - (n3 | 0)) * 4294967296 | 0;
            }
            var n2 = 2;
            var nPrime = 0;
            while (nPrime < 64) {
              if (isPrime(n2)) {
                if (nPrime < 8) {
                  H2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
                }
                K2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
                nPrime++;
              }
              n2++;
            }
          })();
          var W2 = [];
          var SHA256 = C_algo.SHA256 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init(H2.slice(0));
            },
            _doProcessBlock: function(M2, offset) {
              var H3 = this._hash.words;
              var a2 = H3[0];
              var b2 = H3[1];
              var c2 = H3[2];
              var d2 = H3[3];
              var e2 = H3[4];
              var f2 = H3[5];
              var g2 = H3[6];
              var h2 = H3[7];
              for (var i2 = 0; i2 < 64; i2++) {
                if (i2 < 16) {
                  W2[i2] = M2[offset + i2] | 0;
                } else {
                  var gamma0x = W2[i2 - 15];
                  var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                  var gamma1x = W2[i2 - 2];
                  var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                  W2[i2] = gamma0 + W2[i2 - 7] + gamma1 + W2[i2 - 16];
                }
                var ch = e2 & f2 ^ ~e2 & g2;
                var maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
                var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
                var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
                var t1 = h2 + sigma1 + ch + K2[i2] + W2[i2];
                var t2 = sigma0 + maj;
                h2 = g2;
                g2 = f2;
                f2 = e2;
                e2 = d2 + t1 | 0;
                d2 = c2;
                c2 = b2;
                b2 = a2;
                a2 = t1 + t2 | 0;
              }
              H3[0] = H3[0] + a2 | 0;
              H3[1] = H3[1] + b2 | 0;
              H3[2] = H3[2] + c2 | 0;
              H3[3] = H3[3] + d2 | 0;
              H3[4] = H3[4] + e2 | 0;
              H3[5] = H3[5] + f2 | 0;
              H3[6] = H3[6] + g2 | 0;
              H3[7] = H3[7] + h2 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C2.SHA256 = Hasher._createHelper(SHA256);
          C2.HmacSHA256 = Hasher._createHmacHelper(SHA256);
        })(Math);
        return CryptoJS2.SHA256;
      });
    })(sha256);
    return sha256.exports;
  }
  var sha224 = { exports: {} };
  var hasRequiredSha224;
  function requireSha224() {
    if (hasRequiredSha224)
      return sha224.exports;
    hasRequiredSha224 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireSha256());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var C_algo = C2.algo;
          var SHA256 = C_algo.SHA256;
          var SHA224 = C_algo.SHA224 = SHA256.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                3238371032,
                914150663,
                812702999,
                4144912697,
                4290775857,
                1750603025,
                1694076839,
                3204075428
              ]);
            },
            _doFinalize: function() {
              var hash = SHA256._doFinalize.call(this);
              hash.sigBytes -= 4;
              return hash;
            }
          });
          C2.SHA224 = SHA256._createHelper(SHA224);
          C2.HmacSHA224 = SHA256._createHmacHelper(SHA224);
        })();
        return CryptoJS2.SHA224;
      });
    })(sha224);
    return sha224.exports;
  }
  var sha512 = { exports: {} };
  var hasRequiredSha512;
  function requireSha512() {
    if (hasRequiredSha512)
      return sha512.exports;
    hasRequiredSha512 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireX64Core());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Hasher = C_lib.Hasher;
          var C_x64 = C2.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C2.algo;
          function X64Word_create() {
            return X64Word.create.apply(X64Word, arguments);
          }
          var K2 = [
            X64Word_create(1116352408, 3609767458),
            X64Word_create(1899447441, 602891725),
            X64Word_create(3049323471, 3964484399),
            X64Word_create(3921009573, 2173295548),
            X64Word_create(961987163, 4081628472),
            X64Word_create(1508970993, 3053834265),
            X64Word_create(2453635748, 2937671579),
            X64Word_create(2870763221, 3664609560),
            X64Word_create(3624381080, 2734883394),
            X64Word_create(310598401, 1164996542),
            X64Word_create(607225278, 1323610764),
            X64Word_create(1426881987, 3590304994),
            X64Word_create(1925078388, 4068182383),
            X64Word_create(2162078206, 991336113),
            X64Word_create(2614888103, 633803317),
            X64Word_create(3248222580, 3479774868),
            X64Word_create(3835390401, 2666613458),
            X64Word_create(4022224774, 944711139),
            X64Word_create(264347078, 2341262773),
            X64Word_create(604807628, 2007800933),
            X64Word_create(770255983, 1495990901),
            X64Word_create(1249150122, 1856431235),
            X64Word_create(1555081692, 3175218132),
            X64Word_create(1996064986, 2198950837),
            X64Word_create(2554220882, 3999719339),
            X64Word_create(2821834349, 766784016),
            X64Word_create(2952996808, 2566594879),
            X64Word_create(3210313671, 3203337956),
            X64Word_create(3336571891, 1034457026),
            X64Word_create(3584528711, 2466948901),
            X64Word_create(113926993, 3758326383),
            X64Word_create(338241895, 168717936),
            X64Word_create(666307205, 1188179964),
            X64Word_create(773529912, 1546045734),
            X64Word_create(1294757372, 1522805485),
            X64Word_create(1396182291, 2643833823),
            X64Word_create(1695183700, 2343527390),
            X64Word_create(1986661051, 1014477480),
            X64Word_create(2177026350, 1206759142),
            X64Word_create(2456956037, 344077627),
            X64Word_create(2730485921, 1290863460),
            X64Word_create(2820302411, 3158454273),
            X64Word_create(3259730800, 3505952657),
            X64Word_create(3345764771, 106217008),
            X64Word_create(3516065817, 3606008344),
            X64Word_create(3600352804, 1432725776),
            X64Word_create(4094571909, 1467031594),
            X64Word_create(275423344, 851169720),
            X64Word_create(430227734, 3100823752),
            X64Word_create(506948616, 1363258195),
            X64Word_create(659060556, 3750685593),
            X64Word_create(883997877, 3785050280),
            X64Word_create(958139571, 3318307427),
            X64Word_create(1322822218, 3812723403),
            X64Word_create(1537002063, 2003034995),
            X64Word_create(1747873779, 3602036899),
            X64Word_create(1955562222, 1575990012),
            X64Word_create(2024104815, 1125592928),
            X64Word_create(2227730452, 2716904306),
            X64Word_create(2361852424, 442776044),
            X64Word_create(2428436474, 593698344),
            X64Word_create(2756734187, 3733110249),
            X64Word_create(3204031479, 2999351573),
            X64Word_create(3329325298, 3815920427),
            X64Word_create(3391569614, 3928383900),
            X64Word_create(3515267271, 566280711),
            X64Word_create(3940187606, 3454069534),
            X64Word_create(4118630271, 4000239992),
            X64Word_create(116418474, 1914138554),
            X64Word_create(174292421, 2731055270),
            X64Word_create(289380356, 3203993006),
            X64Word_create(460393269, 320620315),
            X64Word_create(685471733, 587496836),
            X64Word_create(852142971, 1086792851),
            X64Word_create(1017036298, 365543100),
            X64Word_create(1126000580, 2618297676),
            X64Word_create(1288033470, 3409855158),
            X64Word_create(1501505948, 4234509866),
            X64Word_create(1607167915, 987167468),
            X64Word_create(1816402316, 1246189591)
          ];
          var W2 = [];
          (function() {
            for (var i2 = 0; i2 < 80; i2++) {
              W2[i2] = X64Word_create();
            }
          })();
          var SHA512 = C_algo.SHA512 = Hasher.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(1779033703, 4089235720),
                new X64Word.init(3144134277, 2227873595),
                new X64Word.init(1013904242, 4271175723),
                new X64Word.init(2773480762, 1595750129),
                new X64Word.init(1359893119, 2917565137),
                new X64Word.init(2600822924, 725511199),
                new X64Word.init(528734635, 4215389547),
                new X64Word.init(1541459225, 327033209)
              ]);
            },
            _doProcessBlock: function(M2, offset) {
              var H2 = this._hash.words;
              var H0 = H2[0];
              var H1 = H2[1];
              var H22 = H2[2];
              var H3 = H2[3];
              var H4 = H2[4];
              var H5 = H2[5];
              var H6 = H2[6];
              var H7 = H2[7];
              var H0h = H0.high;
              var H0l = H0.low;
              var H1h = H1.high;
              var H1l = H1.low;
              var H2h = H22.high;
              var H2l = H22.low;
              var H3h = H3.high;
              var H3l = H3.low;
              var H4h = H4.high;
              var H4l = H4.low;
              var H5h = H5.high;
              var H5l = H5.low;
              var H6h = H6.high;
              var H6l = H6.low;
              var H7h = H7.high;
              var H7l = H7.low;
              var ah = H0h;
              var al = H0l;
              var bh = H1h;
              var bl = H1l;
              var ch = H2h;
              var cl = H2l;
              var dh = H3h;
              var dl = H3l;
              var eh = H4h;
              var el = H4l;
              var fh = H5h;
              var fl = H5l;
              var gh = H6h;
              var gl = H6l;
              var hh = H7h;
              var hl = H7l;
              for (var i2 = 0; i2 < 80; i2++) {
                var Wil;
                var Wih;
                var Wi = W2[i2];
                if (i2 < 16) {
                  Wih = Wi.high = M2[offset + i2 * 2] | 0;
                  Wil = Wi.low = M2[offset + i2 * 2 + 1] | 0;
                } else {
                  var gamma0x = W2[i2 - 15];
                  var gamma0xh = gamma0x.high;
                  var gamma0xl = gamma0x.low;
                  var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                  var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                  var gamma1x = W2[i2 - 2];
                  var gamma1xh = gamma1x.high;
                  var gamma1xl = gamma1x.low;
                  var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                  var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                  var Wi7 = W2[i2 - 7];
                  var Wi7h = Wi7.high;
                  var Wi7l = Wi7.low;
                  var Wi16 = W2[i2 - 16];
                  var Wi16h = Wi16.high;
                  var Wi16l = Wi16.low;
                  Wil = gamma0l + Wi7l;
                  Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                  Wil = Wil + gamma1l;
                  Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                  Wil = Wil + Wi16l;
                  Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                  Wi.high = Wih;
                  Wi.low = Wil;
                }
                var chh = eh & fh ^ ~eh & gh;
                var chl = el & fl ^ ~el & gl;
                var majh = ah & bh ^ ah & ch ^ bh & ch;
                var majl = al & bl ^ al & cl ^ bl & cl;
                var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                var Ki = K2[i2];
                var Kih = Ki.high;
                var Kil = Ki.low;
                var t1l = hl + sigma1l;
                var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                var t1l = t1l + chl;
                var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                var t1l = t1l + Kil;
                var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                var t1l = t1l + Wil;
                var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                var t2l = sigma0l + majl;
                var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                hh = gh;
                hl = gl;
                gh = fh;
                gl = fl;
                fh = eh;
                fl = el;
                el = dl + t1l | 0;
                eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                dh = ch;
                dl = cl;
                ch = bh;
                cl = bl;
                bh = ah;
                bl = al;
                al = t1l + t2l | 0;
                ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
              }
              H0l = H0.low = H0l + al;
              H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
              H1l = H1.low = H1l + bl;
              H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
              H2l = H22.low = H2l + cl;
              H22.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
              H3l = H3.low = H3l + dl;
              H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
              H4l = H4.low = H4l + el;
              H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
              H5l = H5.low = H5l + fl;
              H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
              H6l = H6.low = H6l + gl;
              H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
              H7l = H7.low = H7l + hl;
              H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              var hash = this._hash.toX32();
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            },
            blockSize: 1024 / 32
          });
          C2.SHA512 = Hasher._createHelper(SHA512);
          C2.HmacSHA512 = Hasher._createHmacHelper(SHA512);
        })();
        return CryptoJS2.SHA512;
      });
    })(sha512);
    return sha512.exports;
  }
  var sha384 = { exports: {} };
  var hasRequiredSha384;
  function requireSha384() {
    if (hasRequiredSha384)
      return sha384.exports;
    hasRequiredSha384 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireX64Core(), requireSha512());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_x64 = C2.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C2.algo;
          var SHA512 = C_algo.SHA512;
          var SHA384 = C_algo.SHA384 = SHA512.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(3418070365, 3238371032),
                new X64Word.init(1654270250, 914150663),
                new X64Word.init(2438529370, 812702999),
                new X64Word.init(355462360, 4144912697),
                new X64Word.init(1731405415, 4290775857),
                new X64Word.init(2394180231, 1750603025),
                new X64Word.init(3675008525, 1694076839),
                new X64Word.init(1203062813, 3204075428)
              ]);
            },
            _doFinalize: function() {
              var hash = SHA512._doFinalize.call(this);
              hash.sigBytes -= 16;
              return hash;
            }
          });
          C2.SHA384 = SHA512._createHelper(SHA384);
          C2.HmacSHA384 = SHA512._createHmacHelper(SHA384);
        })();
        return CryptoJS2.SHA384;
      });
    })(sha384);
    return sha384.exports;
  }
  var sha3 = { exports: {} };
  var hasRequiredSha3;
  function requireSha3() {
    if (hasRequiredSha3)
      return sha3.exports;
    hasRequiredSha3 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireX64Core());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(Math2) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_x64 = C2.x64;
          var X64Word = C_x64.Word;
          var C_algo = C2.algo;
          var RHO_OFFSETS = [];
          var PI_INDEXES = [];
          var ROUND_CONSTANTS = [];
          (function() {
            var x = 1, y2 = 0;
            for (var t2 = 0; t2 < 24; t2++) {
              RHO_OFFSETS[x + 5 * y2] = (t2 + 1) * (t2 + 2) / 2 % 64;
              var newX = y2 % 5;
              var newY = (2 * x + 3 * y2) % 5;
              x = newX;
              y2 = newY;
            }
            for (var x = 0; x < 5; x++) {
              for (var y2 = 0; y2 < 5; y2++) {
                PI_INDEXES[x + 5 * y2] = y2 + (2 * x + 3 * y2) % 5 * 5;
              }
            }
            var LFSR = 1;
            for (var i2 = 0; i2 < 24; i2++) {
              var roundConstantMsw = 0;
              var roundConstantLsw = 0;
              for (var j2 = 0; j2 < 7; j2++) {
                if (LFSR & 1) {
                  var bitPosition = (1 << j2) - 1;
                  if (bitPosition < 32) {
                    roundConstantLsw ^= 1 << bitPosition;
                  } else {
                    roundConstantMsw ^= 1 << bitPosition - 32;
                  }
                }
                if (LFSR & 128) {
                  LFSR = LFSR << 1 ^ 113;
                } else {
                  LFSR <<= 1;
                }
              }
              ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
            }
          })();
          var T2 = [];
          (function() {
            for (var i2 = 0; i2 < 25; i2++) {
              T2[i2] = X64Word.create();
            }
          })();
          var SHA3 = C_algo.SHA3 = Hasher.extend({
            /**
             * Configuration options.
             *
             * @property {number} outputLength
             *   The desired number of bits in the output hash.
             *   Only values permitted are: 224, 256, 384, 512.
             *   Default: 512
             */
            cfg: Hasher.cfg.extend({
              outputLength: 512
            }),
            _doReset: function() {
              var state = this._state = [];
              for (var i2 = 0; i2 < 25; i2++) {
                state[i2] = new X64Word.init();
              }
              this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
            },
            _doProcessBlock: function(M2, offset) {
              var state = this._state;
              var nBlockSizeLanes = this.blockSize / 2;
              for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
                var M2i = M2[offset + 2 * i2];
                var M2i1 = M2[offset + 2 * i2 + 1];
                M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                var lane = state[i2];
                lane.high ^= M2i1;
                lane.low ^= M2i;
              }
              for (var round = 0; round < 24; round++) {
                for (var x = 0; x < 5; x++) {
                  var tMsw = 0, tLsw = 0;
                  for (var y2 = 0; y2 < 5; y2++) {
                    var lane = state[x + 5 * y2];
                    tMsw ^= lane.high;
                    tLsw ^= lane.low;
                  }
                  var Tx = T2[x];
                  Tx.high = tMsw;
                  Tx.low = tLsw;
                }
                for (var x = 0; x < 5; x++) {
                  var Tx4 = T2[(x + 4) % 5];
                  var Tx1 = T2[(x + 1) % 5];
                  var Tx1Msw = Tx1.high;
                  var Tx1Lsw = Tx1.low;
                  var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                  var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                  for (var y2 = 0; y2 < 5; y2++) {
                    var lane = state[x + 5 * y2];
                    lane.high ^= tMsw;
                    lane.low ^= tLsw;
                  }
                }
                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                  var tMsw;
                  var tLsw;
                  var lane = state[laneIndex];
                  var laneMsw = lane.high;
                  var laneLsw = lane.low;
                  var rhoOffset = RHO_OFFSETS[laneIndex];
                  if (rhoOffset < 32) {
                    tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                    tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                  } else {
                    tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                    tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                  }
                  var TPiLane = T2[PI_INDEXES[laneIndex]];
                  TPiLane.high = tMsw;
                  TPiLane.low = tLsw;
                }
                var T0 = T2[0];
                var state0 = state[0];
                T0.high = state0.high;
                T0.low = state0.low;
                for (var x = 0; x < 5; x++) {
                  for (var y2 = 0; y2 < 5; y2++) {
                    var laneIndex = x + 5 * y2;
                    var lane = state[laneIndex];
                    var TLane = T2[laneIndex];
                    var Tx1Lane = T2[(x + 1) % 5 + 5 * y2];
                    var Tx2Lane = T2[(x + 2) % 5 + 5 * y2];
                    lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                    lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                  }
                }
                var lane = state[0];
                var roundConstant = ROUND_CONSTANTS[round];
                lane.high ^= roundConstant.high;
                lane.low ^= roundConstant.low;
              }
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              var blockSizeBits = this.blockSize * 32;
              dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
              dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
              data.sigBytes = dataWords.length * 4;
              this._process();
              var state = this._state;
              var outputLengthBytes = this.cfg.outputLength / 8;
              var outputLengthLanes = outputLengthBytes / 8;
              var hashWords = [];
              for (var i2 = 0; i2 < outputLengthLanes; i2++) {
                var lane = state[i2];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                hashWords.push(laneLsw);
                hashWords.push(laneMsw);
              }
              return new WordArray.init(hashWords, outputLengthBytes);
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              var state = clone._state = this._state.slice(0);
              for (var i2 = 0; i2 < 25; i2++) {
                state[i2] = state[i2].clone();
              }
              return clone;
            }
          });
          C2.SHA3 = Hasher._createHelper(SHA3);
          C2.HmacSHA3 = Hasher._createHmacHelper(SHA3);
        })(Math);
        return CryptoJS2.SHA3;
      });
    })(sha3);
    return sha3.exports;
  }
  var ripemd160 = { exports: {} };
  var hasRequiredRipemd160;
  function requireRipemd160() {
    if (hasRequiredRipemd160)
      return ripemd160.exports;
    hasRequiredRipemd160 = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        /** @preserve
        				(c) 2012 by CÃ©dric Mesnil. All rights reserved.
        
        				Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
        
        				    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        				    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
        
        				THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        				*/
        (function(Math2) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C2.algo;
          var _zl = WordArray.create([
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            7,
            4,
            13,
            1,
            10,
            6,
            15,
            3,
            12,
            0,
            9,
            5,
            2,
            14,
            11,
            8,
            3,
            10,
            14,
            4,
            9,
            15,
            8,
            1,
            2,
            7,
            0,
            6,
            13,
            11,
            5,
            12,
            1,
            9,
            11,
            10,
            0,
            8,
            12,
            4,
            13,
            3,
            7,
            15,
            14,
            5,
            6,
            2,
            4,
            0,
            5,
            9,
            7,
            12,
            2,
            10,
            14,
            1,
            3,
            8,
            11,
            6,
            15,
            13
          ]);
          var _zr = WordArray.create([
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
          ]);
          var _sl = WordArray.create([
            11,
            14,
            15,
            12,
            5,
            8,
            7,
            9,
            11,
            13,
            14,
            15,
            6,
            7,
            9,
            8,
            7,
            6,
            8,
            13,
            11,
            9,
            7,
            15,
            7,
            12,
            15,
            9,
            11,
            7,
            13,
            12,
            11,
            13,
            6,
            7,
            14,
            9,
            13,
            15,
            14,
            8,
            13,
            6,
            5,
            12,
            7,
            5,
            11,
            12,
            14,
            15,
            14,
            15,
            9,
            8,
            9,
            14,
            5,
            6,
            8,
            6,
            5,
            12,
            9,
            15,
            5,
            11,
            6,
            8,
            13,
            12,
            5,
            12,
            13,
            14,
            11,
            8,
            5,
            6
          ]);
          var _sr = WordArray.create([
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
          ]);
          var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
          var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
          var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
            _doReset: function() {
              this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            },
            _doProcessBlock: function(M2, offset) {
              for (var i2 = 0; i2 < 16; i2++) {
                var offset_i = offset + i2;
                var M_offset_i = M2[offset_i];
                M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H2 = this._hash.words;
              var hl = _hl.words;
              var hr = _hr.words;
              var zl = _zl.words;
              var zr = _zr.words;
              var sl = _sl.words;
              var sr = _sr.words;
              var al, bl, cl, dl, el;
              var ar, br, cr, dr, er;
              ar = al = H2[0];
              br = bl = H2[1];
              cr = cl = H2[2];
              dr = dl = H2[3];
              er = el = H2[4];
              var t2;
              for (var i2 = 0; i2 < 80; i2 += 1) {
                t2 = al + M2[offset + zl[i2]] | 0;
                if (i2 < 16) {
                  t2 += f1(bl, cl, dl) + hl[0];
                } else if (i2 < 32) {
                  t2 += f2(bl, cl, dl) + hl[1];
                } else if (i2 < 48) {
                  t2 += f3(bl, cl, dl) + hl[2];
                } else if (i2 < 64) {
                  t2 += f4(bl, cl, dl) + hl[3];
                } else {
                  t2 += f5(bl, cl, dl) + hl[4];
                }
                t2 = t2 | 0;
                t2 = rotl(t2, sl[i2]);
                t2 = t2 + el | 0;
                al = el;
                el = dl;
                dl = rotl(cl, 10);
                cl = bl;
                bl = t2;
                t2 = ar + M2[offset + zr[i2]] | 0;
                if (i2 < 16) {
                  t2 += f5(br, cr, dr) + hr[0];
                } else if (i2 < 32) {
                  t2 += f4(br, cr, dr) + hr[1];
                } else if (i2 < 48) {
                  t2 += f3(br, cr, dr) + hr[2];
                } else if (i2 < 64) {
                  t2 += f2(br, cr, dr) + hr[3];
                } else {
                  t2 += f1(br, cr, dr) + hr[4];
                }
                t2 = t2 | 0;
                t2 = rotl(t2, sr[i2]);
                t2 = t2 + er | 0;
                ar = er;
                er = dr;
                dr = rotl(cr, 10);
                cr = br;
                br = t2;
              }
              t2 = H2[1] + cl + dr | 0;
              H2[1] = H2[2] + dl + er | 0;
              H2[2] = H2[3] + el + ar | 0;
              H2[3] = H2[4] + al + br | 0;
              H2[4] = H2[0] + bl + cr | 0;
              H2[0] = t2;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash = this._hash;
              var H2 = hash.words;
              for (var i2 = 0; i2 < 5; i2++) {
                var H_i = H2[i2];
                H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function f1(x, y2, z2) {
            return x ^ y2 ^ z2;
          }
          function f2(x, y2, z2) {
            return x & y2 | ~x & z2;
          }
          function f3(x, y2, z2) {
            return (x | ~y2) ^ z2;
          }
          function f4(x, y2, z2) {
            return x & z2 | y2 & ~z2;
          }
          function f5(x, y2, z2) {
            return x ^ (y2 | ~z2);
          }
          function rotl(x, n2) {
            return x << n2 | x >>> 32 - n2;
          }
          C2.RIPEMD160 = Hasher._createHelper(RIPEMD160);
          C2.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
        })();
        return CryptoJS2.RIPEMD160;
      });
    })(ripemd160);
    return ripemd160.exports;
  }
  var hmac = { exports: {} };
  var hasRequiredHmac;
  function requireHmac() {
    if (hasRequiredHmac)
      return hmac.exports;
    hasRequiredHmac = 1;
    (function(module, exports) {
      (function(root, factory) {
        {
          module.exports = factory(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var C_enc = C2.enc;
          var Utf8 = C_enc.Utf8;
          var C_algo = C2.algo;
          C_algo.HMAC = Base.extend({
            /**
             * Initializes a newly created HMAC.
             *
             * @param {Hasher} hasher The hash algorithm to use.
             * @param {WordArray|string} key The secret key.
             *
             * @example
             *
             *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
             */
            init: function(hasher, key) {
              hasher = this._hasher = new hasher.init();
              if (typeof key == "string") {
                key = Utf8.parse(key);
              }
              var hasherBlockSize = hasher.blockSize;
              var hasherBlockSizeBytes = hasherBlockSize * 4;
              if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
              }
              key.clamp();
              var oKey = this._oKey = key.clone();
              var iKey = this._iKey = key.clone();
              var oKeyWords = oKey.words;
              var iKeyWords = iKey.words;
              for (var i2 = 0; i2 < hasherBlockSize; i2++) {
                oKeyWords[i2] ^= 1549556828;
                iKeyWords[i2] ^= 909522486;
              }
              oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
              this.reset();
            },
            /**
             * Resets this HMAC to its initial state.
             *
             * @example
             *
             *     hmacHasher.reset();
             */
            reset: function() {
              var hasher = this._hasher;
              hasher.reset();
              hasher.update(this._iKey);
            },
            /**
             * Updates this HMAC with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {HMAC} This HMAC instance.
             *
             * @example
             *
             *     hmacHasher.update('message');
             *     hmacHasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._hasher.update(messageUpdate);
              return this;
            },
            /**
             * Finalizes the HMAC computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The HMAC.
             *
             * @example
             *
             *     var hmac = hmacHasher.finalize();
             *     var hmac = hmacHasher.finalize('message');
             *     var hmac = hmacHasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              var hasher = this._hasher;
              var innerHash = hasher.finalize(messageUpdate);
              hasher.reset();
              var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
              return hmac2;
            }
          });
        })();
      });
    })(hmac);
    return hmac.exports;
  }
  var pbkdf2 = { exports: {} };
  var hasRequiredPbkdf2;
  function requirePbkdf2() {
    if (hasRequiredPbkdf2)
      return pbkdf2.exports;
    hasRequiredPbkdf2 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireSha256(), requireHmac());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C2.algo;
          var SHA256 = C_algo.SHA256;
          var HMAC = C_algo.HMAC;
          var PBKDF2 = C_algo.PBKDF2 = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hasher to use. Default: SHA256
             * @property {number} iterations The number of iterations to perform. Default: 250000
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: SHA256,
              iterations: 25e4
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.PBKDF2.create();
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt) {
              var cfg = this.cfg;
              var hmac2 = HMAC.create(cfg.hasher, password);
              var derivedKey = WordArray.create();
              var blockIndex = WordArray.create([1]);
              var derivedKeyWords = derivedKey.words;
              var blockIndexWords = blockIndex.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                var block = hmac2.update(salt).finalize(blockIndex);
                hmac2.reset();
                var blockWords = block.words;
                var blockWordsLength = blockWords.length;
                var intermediate = block;
                for (var i2 = 1; i2 < iterations; i2++) {
                  intermediate = hmac2.finalize(intermediate);
                  hmac2.reset();
                  var intermediateWords = intermediate.words;
                  for (var j2 = 0; j2 < blockWordsLength; j2++) {
                    blockWords[j2] ^= intermediateWords[j2];
                  }
                }
                derivedKey.concat(block);
                blockIndexWords[0]++;
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C2.PBKDF2 = function(password, salt, cfg) {
            return PBKDF2.create(cfg).compute(password, salt);
          };
        })();
        return CryptoJS2.PBKDF2;
      });
    })(pbkdf2);
    return pbkdf2.exports;
  }
  var evpkdf = { exports: {} };
  var hasRequiredEvpkdf;
  function requireEvpkdf() {
    if (hasRequiredEvpkdf)
      return evpkdf.exports;
    hasRequiredEvpkdf = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireSha1(), requireHmac());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C2.algo;
          var MD5 = C_algo.MD5;
          var EvpKDF = C_algo.EvpKDF = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hash algorithm to use. Default: MD5
             * @property {number} iterations The number of iterations to perform. Default: 1
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: MD5,
              iterations: 1
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.EvpKDF.create();
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Derives a key from a password.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt) {
              var block;
              var cfg = this.cfg;
              var hasher = cfg.hasher.create();
              var derivedKey = WordArray.create();
              var derivedKeyWords = derivedKey.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                if (block) {
                  hasher.update(block);
                }
                block = hasher.update(password).finalize(salt);
                hasher.reset();
                for (var i2 = 1; i2 < iterations; i2++) {
                  block = hasher.finalize(block);
                  hasher.reset();
                }
                derivedKey.concat(block);
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C2.EvpKDF = function(password, salt, cfg) {
            return EvpKDF.create(cfg).compute(password, salt);
          };
        })();
        return CryptoJS2.EvpKDF;
      });
    })(evpkdf);
    return evpkdf.exports;
  }
  var cipherCore = { exports: {} };
  var hasRequiredCipherCore;
  function requireCipherCore() {
    if (hasRequiredCipherCore)
      return cipherCore.exports;
    hasRequiredCipherCore = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEvpkdf());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.lib.Cipher || function(undefined$1) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
          var C_enc = C2.enc;
          C_enc.Utf8;
          var Base64 = C_enc.Base64;
          var C_algo = C2.algo;
          var EvpKDF = C_algo.EvpKDF;
          var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             *
             * @property {WordArray} iv The IV to use for this operation.
             */
            cfg: Base.extend(),
            /**
             * Creates this cipher in encryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
             */
            createEncryptor: function(key, cfg) {
              return this.create(this._ENC_XFORM_MODE, key, cfg);
            },
            /**
             * Creates this cipher in decryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
             */
            createDecryptor: function(key, cfg) {
              return this.create(this._DEC_XFORM_MODE, key, cfg);
            },
            /**
             * Initializes a newly created cipher.
             *
             * @param {number} xformMode Either the encryption or decryption transormation mode constant.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
             */
            init: function(xformMode, key, cfg) {
              this.cfg = this.cfg.extend(cfg);
              this._xformMode = xformMode;
              this._key = key;
              this.reset();
            },
            /**
             * Resets this cipher to its initial state.
             *
             * @example
             *
             *     cipher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Adds data to be encrypted or decrypted.
             *
             * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
             *
             * @return {WordArray} The data after processing.
             *
             * @example
             *
             *     var encrypted = cipher.process('data');
             *     var encrypted = cipher.process(wordArray);
             */
            process: function(dataUpdate) {
              this._append(dataUpdate);
              return this._process();
            },
            /**
             * Finalizes the encryption or decryption process.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
             *
             * @return {WordArray} The data after final processing.
             *
             * @example
             *
             *     var encrypted = cipher.finalize();
             *     var encrypted = cipher.finalize('data');
             *     var encrypted = cipher.finalize(wordArray);
             */
            finalize: function(dataUpdate) {
              if (dataUpdate) {
                this._append(dataUpdate);
              }
              var finalProcessedData = this._doFinalize();
              return finalProcessedData;
            },
            keySize: 128 / 32,
            ivSize: 128 / 32,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            /**
             * Creates shortcut functions to a cipher's object interface.
             *
             * @param {Cipher} cipher The cipher to create a helper for.
             *
             * @return {Object} An object with encrypt and decrypt shortcut functions.
             *
             * @static
             *
             * @example
             *
             *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
             */
            _createHelper: /* @__PURE__ */ function() {
              function selectCipherStrategy(key) {
                if (typeof key == "string") {
                  return PasswordBasedCipher;
                } else {
                  return SerializableCipher;
                }
              }
              return function(cipher) {
                return {
                  encrypt: function(message, key, cfg) {
                    return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                  },
                  decrypt: function(ciphertext, key, cfg) {
                    return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                  }
                };
              };
            }()
          });
          C_lib.StreamCipher = Cipher.extend({
            _doFinalize: function() {
              var finalProcessedBlocks = this._process(true);
              return finalProcessedBlocks;
            },
            blockSize: 1
          });
          var C_mode = C2.mode = {};
          var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
            /**
             * Creates this mode for encryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
             */
            createEncryptor: function(cipher, iv) {
              return this.Encryptor.create(cipher, iv);
            },
            /**
             * Creates this mode for decryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
             */
            createDecryptor: function(cipher, iv) {
              return this.Decryptor.create(cipher, iv);
            },
            /**
             * Initializes a newly created mode.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
             */
            init: function(cipher, iv) {
              this._cipher = cipher;
              this._iv = iv;
            }
          });
          var CBC = C_mode.CBC = function() {
            var CBC2 = BlockCipherMode.extend();
            CBC2.Encryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);
                this._prevBlock = words.slice(offset, offset + blockSize);
              }
            });
            CBC2.Decryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var thisBlock = words.slice(offset, offset + blockSize);
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);
                this._prevBlock = thisBlock;
              }
            });
            function xorBlock(words, offset, blockSize) {
              var block;
              var iv = this._iv;
              if (iv) {
                block = iv;
                this._iv = undefined$1;
              } else {
                block = this._prevBlock;
              }
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= block[i2];
              }
            }
            return CBC2;
          }();
          var C_pad = C2.pad = {};
          var Pkcs7 = C_pad.Pkcs7 = {
            /**
             * Pads data using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to pad.
             * @param {number} blockSize The multiple that the data should be padded to.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
             */
            pad: function(data, blockSize) {
              var blockSizeBytes = blockSize * 4;
              var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
              var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
              var paddingWords = [];
              for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
                paddingWords.push(paddingWord);
              }
              var padding = WordArray.create(paddingWords, nPaddingBytes);
              data.concat(padding);
            },
            /**
             * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to unpad.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.unpad(wordArray);
             */
            unpad: function(data) {
              var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
              data.sigBytes -= nPaddingBytes;
            }
          };
          C_lib.BlockCipher = Cipher.extend({
            /**
             * Configuration options.
             *
             * @property {Mode} mode The block mode to use. Default: CBC
             * @property {Padding} padding The padding strategy to use. Default: Pkcs7
             */
            cfg: Cipher.cfg.extend({
              mode: CBC,
              padding: Pkcs7
            }),
            reset: function() {
              var modeCreator;
              Cipher.reset.call(this);
              var cfg = this.cfg;
              var iv = cfg.iv;
              var mode = cfg.mode;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                modeCreator = mode.createEncryptor;
              } else {
                modeCreator = mode.createDecryptor;
                this._minBufferSize = 1;
              }
              if (this._mode && this._mode.__creator == modeCreator) {
                this._mode.init(this, iv && iv.words);
              } else {
                this._mode = modeCreator.call(mode, this, iv && iv.words);
                this._mode.__creator = modeCreator;
              }
            },
            _doProcessBlock: function(words, offset) {
              this._mode.processBlock(words, offset);
            },
            _doFinalize: function() {
              var finalProcessedBlocks;
              var padding = this.cfg.padding;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                padding.pad(this._data, this.blockSize);
                finalProcessedBlocks = this._process(true);
              } else {
                finalProcessedBlocks = this._process(true);
                padding.unpad(finalProcessedBlocks);
              }
              return finalProcessedBlocks;
            },
            blockSize: 128 / 32
          });
          var CipherParams = C_lib.CipherParams = Base.extend({
            /**
             * Initializes a newly created cipher params object.
             *
             * @param {Object} cipherParams An object with any of the possible cipher parameters.
             *
             * @example
             *
             *     var cipherParams = CryptoJS.lib.CipherParams.create({
             *         ciphertext: ciphertextWordArray,
             *         key: keyWordArray,
             *         iv: ivWordArray,
             *         salt: saltWordArray,
             *         algorithm: CryptoJS.algo.AES,
             *         mode: CryptoJS.mode.CBC,
             *         padding: CryptoJS.pad.PKCS7,
             *         blockSize: 4,
             *         formatter: CryptoJS.format.OpenSSL
             *     });
             */
            init: function(cipherParams) {
              this.mixIn(cipherParams);
            },
            /**
             * Converts this cipher params object to a string.
             *
             * @param {Format} formatter (Optional) The formatting strategy to use.
             *
             * @return {string} The stringified cipher params.
             *
             * @throws Error If neither the formatter nor the default formatter is set.
             *
             * @example
             *
             *     var string = cipherParams + '';
             *     var string = cipherParams.toString();
             *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
             */
            toString: function(formatter) {
              return (formatter || this.formatter).stringify(this);
            }
          });
          var C_format = C2.format = {};
          var OpenSSLFormatter = C_format.OpenSSL = {
            /**
             * Converts a cipher params object to an OpenSSL-compatible string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The OpenSSL-compatible string.
             *
             * @static
             *
             * @example
             *
             *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              var wordArray;
              var ciphertext = cipherParams.ciphertext;
              var salt = cipherParams.salt;
              if (salt) {
                wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
              } else {
                wordArray = ciphertext;
              }
              return wordArray.toString(Base64);
            },
            /**
             * Converts an OpenSSL-compatible string to a cipher params object.
             *
             * @param {string} openSSLStr The OpenSSL-compatible string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
             */
            parse: function(openSSLStr) {
              var salt;
              var ciphertext = Base64.parse(openSSLStr);
              var ciphertextWords = ciphertext.words;
              if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                salt = WordArray.create(ciphertextWords.slice(2, 4));
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
              }
              return CipherParams.create({ ciphertext, salt });
            }
          };
          var SerializableCipher = C_lib.SerializableCipher = Base.extend({
            /**
             * Configuration options.
             *
             * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
             */
            cfg: Base.extend({
              format: OpenSSLFormatter
            }),
            /**
             * Encrypts a message.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, key, cfg) {
              cfg = this.cfg.extend(cfg);
              var encryptor = cipher.createEncryptor(key, cfg);
              var ciphertext = encryptor.finalize(message);
              var cipherCfg = encryptor.cfg;
              return CipherParams.create({
                ciphertext,
                key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
              });
            },
            /**
             * Decrypts serialized ciphertext.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, key, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
              return plaintext;
            },
            /**
             * Converts serialized ciphertext to CipherParams,
             * else assumed CipherParams already and returns ciphertext unchanged.
             *
             * @param {CipherParams|string} ciphertext The ciphertext.
             * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
             *
             * @return {CipherParams} The unserialized ciphertext.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
             */
            _parse: function(ciphertext, format) {
              if (typeof ciphertext == "string") {
                return format.parse(ciphertext, this);
              } else {
                return ciphertext;
              }
            }
          });
          var C_kdf = C2.kdf = {};
          var OpenSSLKdf = C_kdf.OpenSSL = {
            /**
             * Derives a key and IV from a password.
             *
             * @param {string} password The password to derive from.
             * @param {number} keySize The size in words of the key to generate.
             * @param {number} ivSize The size in words of the IV to generate.
             * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
             *
             * @return {CipherParams} A cipher params object with the key, IV, and salt.
             *
             * @static
             *
             * @example
             *
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
             */
            execute: function(password, keySize, ivSize, salt, hasher) {
              if (!salt) {
                salt = WordArray.random(64 / 8);
              }
              if (!hasher) {
                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
              } else {
                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
              }
              var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
              key.sigBytes = keySize * 4;
              return CipherParams.create({ key, iv, salt });
            }
          };
          var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
            /**
             * Configuration options.
             *
             * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
             */
            cfg: SerializableCipher.cfg.extend({
              kdf: OpenSSLKdf
            }),
            /**
             * Encrypts a message using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, password, cfg) {
              cfg = this.cfg.extend(cfg);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
              cfg.iv = derivedParams.iv;
              var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
              ciphertext.mixIn(derivedParams);
              return ciphertext;
            },
            /**
             * Decrypts serialized ciphertext using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, password, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
              cfg.iv = derivedParams.iv;
              var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
              return plaintext;
            }
          });
        }();
      });
    })(cipherCore);
    return cipherCore.exports;
  }
  var modeCfb = { exports: {} };
  var hasRequiredModeCfb;
  function requireModeCfb() {
    if (hasRequiredModeCfb)
      return modeCfb.exports;
    hasRequiredModeCfb = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.mode.CFB = function() {
          var CFB = CryptoJS2.lib.BlockCipherMode.extend();
          CFB.Encryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CFB.Decryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = thisBlock;
            }
          });
          function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
            var keystream;
            var iv = this._iv;
            if (iv) {
              keystream = iv.slice(0);
              this._iv = void 0;
            } else {
              keystream = this._prevBlock;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
          return CFB;
        }();
        return CryptoJS2.mode.CFB;
      });
    })(modeCfb);
    return modeCfb.exports;
  }
  var modeCtr = { exports: {} };
  var hasRequiredModeCtr;
  function requireModeCtr() {
    if (hasRequiredModeCtr)
      return modeCtr.exports;
    hasRequiredModeCtr = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.mode.CTR = function() {
          var CTR = CryptoJS2.lib.BlockCipherMode.extend();
          var Encryptor = CTR.Encryptor = CTR.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          CTR.Decryptor = Encryptor;
          return CTR;
        }();
        return CryptoJS2.mode.CTR;
      });
    })(modeCtr);
    return modeCtr.exports;
  }
  var modeCtrGladman = { exports: {} };
  var hasRequiredModeCtrGladman;
  function requireModeCtrGladman() {
    if (hasRequiredModeCtrGladman)
      return modeCtrGladman.exports;
    hasRequiredModeCtrGladman = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        /** @preserve
         * Counter block mode compatible with  Dr Brian Gladman fileenc.c
         * derived from CryptoJS.mode.CTR
         * Jan Hruby jhruby.web@gmail.com
         */
        CryptoJS2.mode.CTRGladman = function() {
          var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
          function incWord(word) {
            if ((word >> 24 & 255) === 255) {
              var b1 = word >> 16 & 255;
              var b2 = word >> 8 & 255;
              var b3 = word & 255;
              if (b1 === 255) {
                b1 = 0;
                if (b2 === 255) {
                  b2 = 0;
                  if (b3 === 255) {
                    b3 = 0;
                  } else {
                    ++b3;
                  }
                } else {
                  ++b2;
                }
              } else {
                ++b1;
              }
              word = 0;
              word += b1 << 16;
              word += b2 << 8;
              word += b3;
            } else {
              word += 1 << 24;
            }
            return word;
          }
          function incCounter(counter) {
            if ((counter[0] = incWord(counter[0])) === 0) {
              counter[1] = incWord(counter[1]);
            }
            return counter;
          }
          var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              incCounter(counter);
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          CTRGladman.Decryptor = Encryptor;
          return CTRGladman;
        }();
        return CryptoJS2.mode.CTRGladman;
      });
    })(modeCtrGladman);
    return modeCtrGladman.exports;
  }
  var modeOfb = { exports: {} };
  var hasRequiredModeOfb;
  function requireModeOfb() {
    if (hasRequiredModeOfb)
      return modeOfb.exports;
    hasRequiredModeOfb = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.mode.OFB = function() {
          var OFB = CryptoJS2.lib.BlockCipherMode.extend();
          var Encryptor = OFB.Encryptor = OFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var keystream = this._keystream;
              if (iv) {
                keystream = this._keystream = iv.slice(0);
                this._iv = void 0;
              }
              cipher.encryptBlock(keystream, 0);
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          OFB.Decryptor = Encryptor;
          return OFB;
        }();
        return CryptoJS2.mode.OFB;
      });
    })(modeOfb);
    return modeOfb.exports;
  }
  var modeEcb = { exports: {} };
  var hasRequiredModeEcb;
  function requireModeEcb() {
    if (hasRequiredModeEcb)
      return modeEcb.exports;
    hasRequiredModeEcb = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.mode.ECB = function() {
          var ECB = CryptoJS2.lib.BlockCipherMode.extend();
          ECB.Encryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.encryptBlock(words, offset);
            }
          });
          ECB.Decryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.decryptBlock(words, offset);
            }
          });
          return ECB;
        }();
        return CryptoJS2.mode.ECB;
      });
    })(modeEcb);
    return modeEcb.exports;
  }
  var padAnsix923 = { exports: {} };
  var hasRequiredPadAnsix923;
  function requirePadAnsix923() {
    if (hasRequiredPadAnsix923)
      return padAnsix923.exports;
    hasRequiredPadAnsix923 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.AnsiX923 = {
          pad: function(data, blockSize) {
            var dataSigBytes = data.sigBytes;
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
            var lastBytePos = dataSigBytes + nPaddingBytes - 1;
            data.clamp();
            data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
            data.sigBytes += nPaddingBytes;
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS2.pad.Ansix923;
      });
    })(padAnsix923);
    return padAnsix923.exports;
  }
  var padIso10126 = { exports: {} };
  var hasRequiredPadIso10126;
  function requirePadIso10126() {
    if (hasRequiredPadIso10126)
      return padIso10126.exports;
    hasRequiredPadIso10126 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.Iso10126 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            data.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS2.pad.Iso10126;
      });
    })(padIso10126);
    return padIso10126.exports;
  }
  var padIso97971 = { exports: {} };
  var hasRequiredPadIso97971;
  function requirePadIso97971() {
    if (hasRequiredPadIso97971)
      return padIso97971.exports;
    hasRequiredPadIso97971 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.Iso97971 = {
          pad: function(data, blockSize) {
            data.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
            CryptoJS2.pad.ZeroPadding.pad(data, blockSize);
          },
          unpad: function(data) {
            CryptoJS2.pad.ZeroPadding.unpad(data);
            data.sigBytes--;
          }
        };
        return CryptoJS2.pad.Iso97971;
      });
    })(padIso97971);
    return padIso97971.exports;
  }
  var padZeropadding = { exports: {} };
  var hasRequiredPadZeropadding;
  function requirePadZeropadding() {
    if (hasRequiredPadZeropadding)
      return padZeropadding.exports;
    hasRequiredPadZeropadding = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.ZeroPadding = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            data.clamp();
            data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
          },
          unpad: function(data) {
            var dataWords = data.words;
            var i2 = data.sigBytes - 1;
            for (var i2 = data.sigBytes - 1; i2 >= 0; i2--) {
              if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
                data.sigBytes = i2 + 1;
                break;
              }
            }
          }
        };
        return CryptoJS2.pad.ZeroPadding;
      });
    })(padZeropadding);
    return padZeropadding.exports;
  }
  var padNopadding = { exports: {} };
  var hasRequiredPadNopadding;
  function requirePadNopadding() {
    if (hasRequiredPadNopadding)
      return padNopadding.exports;
    hasRequiredPadNopadding = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        CryptoJS2.pad.NoPadding = {
          pad: function() {
          },
          unpad: function() {
          }
        };
        return CryptoJS2.pad.NoPadding;
      });
    })(padNopadding);
    return padNopadding.exports;
  }
  var formatHex = { exports: {} };
  var hasRequiredFormatHex;
  function requireFormatHex() {
    if (hasRequiredFormatHex)
      return formatHex.exports;
    hasRequiredFormatHex = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function(undefined$1) {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var CipherParams = C_lib.CipherParams;
          var C_enc = C2.enc;
          var Hex = C_enc.Hex;
          var C_format = C2.format;
          C_format.Hex = {
            /**
             * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The hexadecimally encoded string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              return cipherParams.ciphertext.toString(Hex);
            },
            /**
             * Converts a hexadecimally encoded ciphertext string to a cipher params object.
             *
             * @param {string} input The hexadecimally encoded string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
             */
            parse: function(input) {
              var ciphertext = Hex.parse(input);
              return CipherParams.create({ ciphertext });
            }
          };
        })();
        return CryptoJS2.format.Hex;
      });
    })(formatHex);
    return formatHex.exports;
  }
  var aes = { exports: {} };
  var hasRequiredAes;
  function requireAes() {
    if (hasRequiredAes)
      return aes.exports;
    hasRequiredAes = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C2.algo;
          var SBOX = [];
          var INV_SBOX = [];
          var SUB_MIX_0 = [];
          var SUB_MIX_1 = [];
          var SUB_MIX_2 = [];
          var SUB_MIX_3 = [];
          var INV_SUB_MIX_0 = [];
          var INV_SUB_MIX_1 = [];
          var INV_SUB_MIX_2 = [];
          var INV_SUB_MIX_3 = [];
          (function() {
            var d2 = [];
            for (var i2 = 0; i2 < 256; i2++) {
              if (i2 < 128) {
                d2[i2] = i2 << 1;
              } else {
                d2[i2] = i2 << 1 ^ 283;
              }
            }
            var x = 0;
            var xi = 0;
            for (var i2 = 0; i2 < 256; i2++) {
              var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
              sx = sx >>> 8 ^ sx & 255 ^ 99;
              SBOX[x] = sx;
              INV_SBOX[sx] = x;
              var x2 = d2[x];
              var x4 = d2[x2];
              var x8 = d2[x4];
              var t2 = d2[sx] * 257 ^ sx * 16843008;
              SUB_MIX_0[x] = t2 << 24 | t2 >>> 8;
              SUB_MIX_1[x] = t2 << 16 | t2 >>> 16;
              SUB_MIX_2[x] = t2 << 8 | t2 >>> 24;
              SUB_MIX_3[x] = t2;
              var t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
              INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
              INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
              INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
              INV_SUB_MIX_3[sx] = t2;
              if (!x) {
                x = xi = 1;
              } else {
                x = x2 ^ d2[d2[d2[x8 ^ x2]]];
                xi ^= d2[d2[xi]];
              }
            }
          })();
          var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var AES = C_algo.AES = BlockCipher.extend({
            _doReset: function() {
              var t2;
              if (this._nRounds && this._keyPriorReset === this._key) {
                return;
              }
              var key = this._keyPriorReset = this._key;
              var keyWords = key.words;
              var keySize = key.sigBytes / 4;
              var nRounds = this._nRounds = keySize + 6;
              var ksRows = (nRounds + 1) * 4;
              var keySchedule = this._keySchedule = [];
              for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                  keySchedule[ksRow] = keyWords[ksRow];
                } else {
                  t2 = keySchedule[ksRow - 1];
                  if (!(ksRow % keySize)) {
                    t2 = t2 << 8 | t2 >>> 24;
                    t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                    t2 ^= RCON[ksRow / keySize | 0] << 24;
                  } else if (keySize > 6 && ksRow % keySize == 4) {
                    t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  }
                  keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
                }
              }
              var invKeySchedule = this._invKeySchedule = [];
              for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;
                if (invKsRow % 4) {
                  var t2 = keySchedule[ksRow];
                } else {
                  var t2 = keySchedule[ksRow - 4];
                }
                if (invKsRow < 4 || ksRow <= 4) {
                  invKeySchedule[invKsRow] = t2;
                } else {
                  invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
                }
              }
            },
            encryptBlock: function(M2, offset) {
              this._doCryptBlock(M2, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
            },
            decryptBlock: function(M2, offset) {
              var t2 = M2[offset + 1];
              M2[offset + 1] = M2[offset + 3];
              M2[offset + 3] = t2;
              this._doCryptBlock(M2, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
              var t2 = M2[offset + 1];
              M2[offset + 1] = M2[offset + 3];
              M2[offset + 3] = t2;
            },
            _doCryptBlock: function(M2, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
              var nRounds = this._nRounds;
              var s0 = M2[offset] ^ keySchedule[0];
              var s1 = M2[offset + 1] ^ keySchedule[1];
              var s2 = M2[offset + 2] ^ keySchedule[2];
              var s3 = M2[offset + 3] ^ keySchedule[3];
              var ksRow = 4;
              for (var round = 1; round < nRounds; round++) {
                var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
              }
              var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
              var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
              var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
              var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
              M2[offset] = t0;
              M2[offset + 1] = t1;
              M2[offset + 2] = t2;
              M2[offset + 3] = t3;
            },
            keySize: 256 / 32
          });
          C2.AES = BlockCipher._createHelper(AES);
        })();
        return CryptoJS2.AES;
      });
    })(aes);
    return aes.exports;
  }
  var tripledes = { exports: {} };
  var hasRequiredTripledes;
  function requireTripledes() {
    if (hasRequiredTripledes)
      return tripledes.exports;
    hasRequiredTripledes = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var WordArray = C_lib.WordArray;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C2.algo;
          var PC1 = [
            57,
            49,
            41,
            33,
            25,
            17,
            9,
            1,
            58,
            50,
            42,
            34,
            26,
            18,
            10,
            2,
            59,
            51,
            43,
            35,
            27,
            19,
            11,
            3,
            60,
            52,
            44,
            36,
            63,
            55,
            47,
            39,
            31,
            23,
            15,
            7,
            62,
            54,
            46,
            38,
            30,
            22,
            14,
            6,
            61,
            53,
            45,
            37,
            29,
            21,
            13,
            5,
            28,
            20,
            12,
            4
          ];
          var PC2 = [
            14,
            17,
            11,
            24,
            1,
            5,
            3,
            28,
            15,
            6,
            21,
            10,
            23,
            19,
            12,
            4,
            26,
            8,
            16,
            7,
            27,
            20,
            13,
            2,
            41,
            52,
            31,
            37,
            47,
            55,
            30,
            40,
            51,
            45,
            33,
            48,
            44,
            49,
            39,
            56,
            34,
            53,
            46,
            42,
            50,
            36,
            29,
            32
          ];
          var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
          var SBOX_P = [
            {
              0: 8421888,
              268435456: 32768,
              536870912: 8421378,
              805306368: 2,
              1073741824: 512,
              1342177280: 8421890,
              1610612736: 8389122,
              1879048192: 8388608,
              2147483648: 514,
              2415919104: 8389120,
              2684354560: 33280,
              2952790016: 8421376,
              3221225472: 32770,
              3489660928: 8388610,
              3758096384: 0,
              4026531840: 33282,
              134217728: 0,
              402653184: 8421890,
              671088640: 33282,
              939524096: 32768,
              1207959552: 8421888,
              1476395008: 512,
              1744830464: 8421378,
              2013265920: 2,
              2281701376: 8389120,
              2550136832: 33280,
              2818572288: 8421376,
              3087007744: 8389122,
              3355443200: 8388610,
              3623878656: 32770,
              3892314112: 514,
              4160749568: 8388608,
              1: 32768,
              268435457: 2,
              536870913: 8421888,
              805306369: 8388608,
              1073741825: 8421378,
              1342177281: 33280,
              1610612737: 512,
              1879048193: 8389122,
              2147483649: 8421890,
              2415919105: 8421376,
              2684354561: 8388610,
              2952790017: 33282,
              3221225473: 514,
              3489660929: 8389120,
              3758096385: 32770,
              4026531841: 0,
              134217729: 8421890,
              402653185: 8421376,
              671088641: 8388608,
              939524097: 512,
              1207959553: 32768,
              1476395009: 8388610,
              1744830465: 2,
              2013265921: 33282,
              2281701377: 32770,
              2550136833: 8389122,
              2818572289: 514,
              3087007745: 8421888,
              3355443201: 8389120,
              3623878657: 0,
              3892314113: 33280,
              4160749569: 8421378
            },
            {
              0: 1074282512,
              16777216: 16384,
              33554432: 524288,
              50331648: 1074266128,
              67108864: 1073741840,
              83886080: 1074282496,
              100663296: 1073758208,
              117440512: 16,
              134217728: 540672,
              150994944: 1073758224,
              167772160: 1073741824,
              184549376: 540688,
              201326592: 524304,
              218103808: 0,
              234881024: 16400,
              251658240: 1074266112,
              8388608: 1073758208,
              25165824: 540688,
              41943040: 16,
              58720256: 1073758224,
              75497472: 1074282512,
              92274688: 1073741824,
              109051904: 524288,
              125829120: 1074266128,
              142606336: 524304,
              159383552: 0,
              176160768: 16384,
              192937984: 1074266112,
              209715200: 1073741840,
              226492416: 540672,
              243269632: 1074282496,
              260046848: 16400,
              268435456: 0,
              285212672: 1074266128,
              301989888: 1073758224,
              318767104: 1074282496,
              335544320: 1074266112,
              352321536: 16,
              369098752: 540688,
              385875968: 16384,
              402653184: 16400,
              419430400: 524288,
              436207616: 524304,
              452984832: 1073741840,
              469762048: 540672,
              486539264: 1073758208,
              503316480: 1073741824,
              520093696: 1074282512,
              276824064: 540688,
              293601280: 524288,
              310378496: 1074266112,
              327155712: 16384,
              343932928: 1073758208,
              360710144: 1074282512,
              377487360: 16,
              394264576: 1073741824,
              411041792: 1074282496,
              427819008: 1073741840,
              444596224: 1073758224,
              461373440: 524304,
              478150656: 0,
              494927872: 16400,
              511705088: 1074266128,
              528482304: 540672
            },
            {
              0: 260,
              1048576: 0,
              2097152: 67109120,
              3145728: 65796,
              4194304: 65540,
              5242880: 67108868,
              6291456: 67174660,
              7340032: 67174400,
              8388608: 67108864,
              9437184: 67174656,
              10485760: 65792,
              11534336: 67174404,
              12582912: 67109124,
              13631488: 65536,
              14680064: 4,
              15728640: 256,
              524288: 67174656,
              1572864: 67174404,
              2621440: 0,
              3670016: 67109120,
              4718592: 67108868,
              5767168: 65536,
              6815744: 65540,
              7864320: 260,
              8912896: 4,
              9961472: 256,
              11010048: 67174400,
              12058624: 65796,
              13107200: 65792,
              14155776: 67109124,
              15204352: 67174660,
              16252928: 67108864,
              16777216: 67174656,
              17825792: 65540,
              18874368: 65536,
              19922944: 67109120,
              20971520: 256,
              22020096: 67174660,
              23068672: 67108868,
              24117248: 0,
              25165824: 67109124,
              26214400: 67108864,
              27262976: 4,
              28311552: 65792,
              29360128: 67174400,
              30408704: 260,
              31457280: 65796,
              32505856: 67174404,
              17301504: 67108864,
              18350080: 260,
              19398656: 67174656,
              20447232: 0,
              21495808: 65540,
              22544384: 67109120,
              23592960: 256,
              24641536: 67174404,
              25690112: 65536,
              26738688: 67174660,
              27787264: 65796,
              28835840: 67108868,
              29884416: 67109124,
              30932992: 67174400,
              31981568: 4,
              33030144: 65792
            },
            {
              0: 2151682048,
              65536: 2147487808,
              131072: 4198464,
              196608: 2151677952,
              262144: 0,
              327680: 4198400,
              393216: 2147483712,
              458752: 4194368,
              524288: 2147483648,
              589824: 4194304,
              655360: 64,
              720896: 2147487744,
              786432: 2151678016,
              851968: 4160,
              917504: 4096,
              983040: 2151682112,
              32768: 2147487808,
              98304: 64,
              163840: 2151678016,
              229376: 2147487744,
              294912: 4198400,
              360448: 2151682112,
              425984: 0,
              491520: 2151677952,
              557056: 4096,
              622592: 2151682048,
              688128: 4194304,
              753664: 4160,
              819200: 2147483648,
              884736: 4194368,
              950272: 4198464,
              1015808: 2147483712,
              1048576: 4194368,
              1114112: 4198400,
              1179648: 2147483712,
              1245184: 0,
              1310720: 4160,
              1376256: 2151678016,
              1441792: 2151682048,
              1507328: 2147487808,
              1572864: 2151682112,
              1638400: 2147483648,
              1703936: 2151677952,
              1769472: 4198464,
              1835008: 2147487744,
              1900544: 4194304,
              1966080: 64,
              2031616: 4096,
              1081344: 2151677952,
              1146880: 2151682112,
              1212416: 0,
              1277952: 4198400,
              1343488: 4194368,
              1409024: 2147483648,
              1474560: 2147487808,
              1540096: 64,
              1605632: 2147483712,
              1671168: 4096,
              1736704: 2147487744,
              1802240: 2151678016,
              1867776: 4160,
              1933312: 2151682048,
              1998848: 4194304,
              2064384: 4198464
            },
            {
              0: 128,
              4096: 17039360,
              8192: 262144,
              12288: 536870912,
              16384: 537133184,
              20480: 16777344,
              24576: 553648256,
              28672: 262272,
              32768: 16777216,
              36864: 537133056,
              40960: 536871040,
              45056: 553910400,
              49152: 553910272,
              53248: 0,
              57344: 17039488,
              61440: 553648128,
              2048: 17039488,
              6144: 553648256,
              10240: 128,
              14336: 17039360,
              18432: 262144,
              22528: 537133184,
              26624: 553910272,
              30720: 536870912,
              34816: 537133056,
              38912: 0,
              43008: 553910400,
              47104: 16777344,
              51200: 536871040,
              55296: 553648128,
              59392: 16777216,
              63488: 262272,
              65536: 262144,
              69632: 128,
              73728: 536870912,
              77824: 553648256,
              81920: 16777344,
              86016: 553910272,
              90112: 537133184,
              94208: 16777216,
              98304: 553910400,
              102400: 553648128,
              106496: 17039360,
              110592: 537133056,
              114688: 262272,
              118784: 536871040,
              122880: 0,
              126976: 17039488,
              67584: 553648256,
              71680: 16777216,
              75776: 17039360,
              79872: 537133184,
              83968: 536870912,
              88064: 17039488,
              92160: 128,
              96256: 553910272,
              100352: 262272,
              104448: 553910400,
              108544: 0,
              112640: 553648128,
              116736: 16777344,
              120832: 262144,
              124928: 537133056,
              129024: 536871040
            },
            {
              0: 268435464,
              256: 8192,
              512: 270532608,
              768: 270540808,
              1024: 268443648,
              1280: 2097152,
              1536: 2097160,
              1792: 268435456,
              2048: 0,
              2304: 268443656,
              2560: 2105344,
              2816: 8,
              3072: 270532616,
              3328: 2105352,
              3584: 8200,
              3840: 270540800,
              128: 270532608,
              384: 270540808,
              640: 8,
              896: 2097152,
              1152: 2105352,
              1408: 268435464,
              1664: 268443648,
              1920: 8200,
              2176: 2097160,
              2432: 8192,
              2688: 268443656,
              2944: 270532616,
              3200: 0,
              3456: 270540800,
              3712: 2105344,
              3968: 268435456,
              4096: 268443648,
              4352: 270532616,
              4608: 270540808,
              4864: 8200,
              5120: 2097152,
              5376: 268435456,
              5632: 268435464,
              5888: 2105344,
              6144: 2105352,
              6400: 0,
              6656: 8,
              6912: 270532608,
              7168: 8192,
              7424: 268443656,
              7680: 270540800,
              7936: 2097160,
              4224: 8,
              4480: 2105344,
              4736: 2097152,
              4992: 268435464,
              5248: 268443648,
              5504: 8200,
              5760: 270540808,
              6016: 270532608,
              6272: 270540800,
              6528: 270532616,
              6784: 8192,
              7040: 2105352,
              7296: 2097160,
              7552: 0,
              7808: 268435456,
              8064: 268443656
            },
            {
              0: 1048576,
              16: 33555457,
              32: 1024,
              48: 1049601,
              64: 34604033,
              80: 0,
              96: 1,
              112: 34603009,
              128: 33555456,
              144: 1048577,
              160: 33554433,
              176: 34604032,
              192: 34603008,
              208: 1025,
              224: 1049600,
              240: 33554432,
              8: 34603009,
              24: 0,
              40: 33555457,
              56: 34604032,
              72: 1048576,
              88: 33554433,
              104: 33554432,
              120: 1025,
              136: 1049601,
              152: 33555456,
              168: 34603008,
              184: 1048577,
              200: 1024,
              216: 34604033,
              232: 1,
              248: 1049600,
              256: 33554432,
              272: 1048576,
              288: 33555457,
              304: 34603009,
              320: 1048577,
              336: 33555456,
              352: 34604032,
              368: 1049601,
              384: 1025,
              400: 34604033,
              416: 1049600,
              432: 1,
              448: 0,
              464: 34603008,
              480: 33554433,
              496: 1024,
              264: 1049600,
              280: 33555457,
              296: 34603009,
              312: 1,
              328: 33554432,
              344: 1048576,
              360: 1025,
              376: 34604032,
              392: 33554433,
              408: 34603008,
              424: 0,
              440: 34604033,
              456: 1049601,
              472: 1024,
              488: 33555456,
              504: 1048577
            },
            {
              0: 134219808,
              1: 131072,
              2: 134217728,
              3: 32,
              4: 131104,
              5: 134350880,
              6: 134350848,
              7: 2048,
              8: 134348800,
              9: 134219776,
              10: 133120,
              11: 134348832,
              12: 2080,
              13: 0,
              14: 134217760,
              15: 133152,
              2147483648: 2048,
              2147483649: 134350880,
              2147483650: 134219808,
              2147483651: 134217728,
              2147483652: 134348800,
              2147483653: 133120,
              2147483654: 133152,
              2147483655: 32,
              2147483656: 134217760,
              2147483657: 2080,
              2147483658: 131104,
              2147483659: 134350848,
              2147483660: 0,
              2147483661: 134348832,
              2147483662: 134219776,
              2147483663: 131072,
              16: 133152,
              17: 134350848,
              18: 32,
              19: 2048,
              20: 134219776,
              21: 134217760,
              22: 134348832,
              23: 131072,
              24: 0,
              25: 131104,
              26: 134348800,
              27: 134219808,
              28: 134350880,
              29: 133120,
              30: 2080,
              31: 134217728,
              2147483664: 131072,
              2147483665: 2048,
              2147483666: 134348832,
              2147483667: 133152,
              2147483668: 32,
              2147483669: 134348800,
              2147483670: 134217728,
              2147483671: 134219808,
              2147483672: 134350880,
              2147483673: 134217760,
              2147483674: 134219776,
              2147483675: 0,
              2147483676: 133120,
              2147483677: 2080,
              2147483678: 131104,
              2147483679: 134350848
            }
          ];
          var SBOX_MASK = [
            4160749569,
            528482304,
            33030144,
            2064384,
            129024,
            8064,
            504,
            2147483679
          ];
          var DES = C_algo.DES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keyBits = [];
              for (var i2 = 0; i2 < 56; i2++) {
                var keyBitPos = PC1[i2] - 1;
                keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
              }
              var subKeys = this._subKeys = [];
              for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                var subKey = subKeys[nSubKey] = [];
                var bitShift = BIT_SHIFTS[nSubKey];
                for (var i2 = 0; i2 < 24; i2++) {
                  subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                  subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
                }
                subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                for (var i2 = 1; i2 < 7; i2++) {
                  subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
                }
                subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
              }
              var invSubKeys = this._invSubKeys = [];
              for (var i2 = 0; i2 < 16; i2++) {
                invSubKeys[i2] = subKeys[15 - i2];
              }
            },
            encryptBlock: function(M2, offset) {
              this._doCryptBlock(M2, offset, this._subKeys);
            },
            decryptBlock: function(M2, offset) {
              this._doCryptBlock(M2, offset, this._invSubKeys);
            },
            _doCryptBlock: function(M2, offset, subKeys) {
              this._lBlock = M2[offset];
              this._rBlock = M2[offset + 1];
              exchangeLR.call(this, 4, 252645135);
              exchangeLR.call(this, 16, 65535);
              exchangeRL.call(this, 2, 858993459);
              exchangeRL.call(this, 8, 16711935);
              exchangeLR.call(this, 1, 1431655765);
              for (var round = 0; round < 16; round++) {
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;
                var f2 = 0;
                for (var i2 = 0; i2 < 8; i2++) {
                  f2 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f2;
              }
              var t2 = this._lBlock;
              this._lBlock = this._rBlock;
              this._rBlock = t2;
              exchangeLR.call(this, 1, 1431655765);
              exchangeRL.call(this, 8, 16711935);
              exchangeRL.call(this, 2, 858993459);
              exchangeLR.call(this, 16, 65535);
              exchangeLR.call(this, 4, 252645135);
              M2[offset] = this._lBlock;
              M2[offset + 1] = this._rBlock;
            },
            keySize: 64 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          function exchangeLR(offset, mask) {
            var t2 = (this._lBlock >>> offset ^ this._rBlock) & mask;
            this._rBlock ^= t2;
            this._lBlock ^= t2 << offset;
          }
          function exchangeRL(offset, mask) {
            var t2 = (this._rBlock >>> offset ^ this._lBlock) & mask;
            this._lBlock ^= t2;
            this._rBlock ^= t2 << offset;
          }
          C2.DES = BlockCipher._createHelper(DES);
          var TripleDES = C_algo.TripleDES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
              }
              var key1 = keyWords.slice(0, 2);
              var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
              var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
              this._des1 = DES.createEncryptor(WordArray.create(key1));
              this._des2 = DES.createEncryptor(WordArray.create(key2));
              this._des3 = DES.createEncryptor(WordArray.create(key3));
            },
            encryptBlock: function(M2, offset) {
              this._des1.encryptBlock(M2, offset);
              this._des2.decryptBlock(M2, offset);
              this._des3.encryptBlock(M2, offset);
            },
            decryptBlock: function(M2, offset) {
              this._des3.decryptBlock(M2, offset);
              this._des2.encryptBlock(M2, offset);
              this._des1.decryptBlock(M2, offset);
            },
            keySize: 192 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          C2.TripleDES = BlockCipher._createHelper(TripleDES);
        })();
        return CryptoJS2.TripleDES;
      });
    })(tripledes);
    return tripledes.exports;
  }
  var rc4 = { exports: {} };
  var hasRequiredRc4;
  function requireRc4() {
    if (hasRequiredRc4)
      return rc4.exports;
    hasRequiredRc4 = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C2.algo;
          var RC4 = C_algo.RC4 = StreamCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keySigBytes = key.sigBytes;
              var S2 = this._S = [];
              for (var i2 = 0; i2 < 256; i2++) {
                S2[i2] = i2;
              }
              for (var i2 = 0, j2 = 0; i2 < 256; i2++) {
                var keyByteIndex = i2 % keySigBytes;
                var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                j2 = (j2 + S2[i2] + keyByte) % 256;
                var t2 = S2[i2];
                S2[i2] = S2[j2];
                S2[j2] = t2;
              }
              this._i = this._j = 0;
            },
            _doProcessBlock: function(M2, offset) {
              M2[offset] ^= generateKeystreamWord.call(this);
            },
            keySize: 256 / 32,
            ivSize: 0
          });
          function generateKeystreamWord() {
            var S2 = this._S;
            var i2 = this._i;
            var j2 = this._j;
            var keystreamWord = 0;
            for (var n2 = 0; n2 < 4; n2++) {
              i2 = (i2 + 1) % 256;
              j2 = (j2 + S2[i2]) % 256;
              var t2 = S2[i2];
              S2[i2] = S2[j2];
              S2[j2] = t2;
              keystreamWord |= S2[(S2[i2] + S2[j2]) % 256] << 24 - n2 * 8;
            }
            this._i = i2;
            this._j = j2;
            return keystreamWord;
          }
          C2.RC4 = StreamCipher._createHelper(RC4);
          var RC4Drop = C_algo.RC4Drop = RC4.extend({
            /**
             * Configuration options.
             *
             * @property {number} drop The number of keystream words to drop. Default 192
             */
            cfg: RC4.cfg.extend({
              drop: 192
            }),
            _doReset: function() {
              RC4._doReset.call(this);
              for (var i2 = this.cfg.drop; i2 > 0; i2--) {
                generateKeystreamWord.call(this);
              }
            }
          });
          C2.RC4Drop = StreamCipher._createHelper(RC4Drop);
        })();
        return CryptoJS2.RC4;
      });
    })(rc4);
    return rc4.exports;
  }
  var rabbit = { exports: {} };
  var hasRequiredRabbit;
  function requireRabbit() {
    if (hasRequiredRabbit)
      return rabbit.exports;
    hasRequiredRabbit = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C2.algo;
          var S2 = [];
          var C_ = [];
          var G2 = [];
          var Rabbit = C_algo.Rabbit = StreamCipher.extend({
            _doReset: function() {
              var K2 = this._key.words;
              var iv = this.cfg.iv;
              for (var i2 = 0; i2 < 4; i2++) {
                K2[i2] = (K2[i2] << 8 | K2[i2] >>> 24) & 16711935 | (K2[i2] << 24 | K2[i2] >>> 8) & 4278255360;
              }
              var X2 = this._X = [
                K2[0],
                K2[3] << 16 | K2[2] >>> 16,
                K2[1],
                K2[0] << 16 | K2[3] >>> 16,
                K2[2],
                K2[1] << 16 | K2[0] >>> 16,
                K2[3],
                K2[2] << 16 | K2[1] >>> 16
              ];
              var C3 = this._C = [
                K2[2] << 16 | K2[2] >>> 16,
                K2[0] & 4294901760 | K2[1] & 65535,
                K2[3] << 16 | K2[3] >>> 16,
                K2[1] & 4294901760 | K2[2] & 65535,
                K2[0] << 16 | K2[0] >>> 16,
                K2[2] & 4294901760 | K2[3] & 65535,
                K2[1] << 16 | K2[1] >>> 16,
                K2[3] & 4294901760 | K2[0] & 65535
              ];
              this._b = 0;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
              for (var i2 = 0; i2 < 8; i2++) {
                C3[i2] ^= X2[i2 + 4 & 7];
              }
              if (iv) {
                var IV = iv.words;
                var IV_0 = IV[0];
                var IV_1 = IV[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i22 & 4294901760;
                var i3 = i22 << 16 | i0 & 65535;
                C3[0] ^= i0;
                C3[1] ^= i1;
                C3[2] ^= i22;
                C3[3] ^= i3;
                C3[4] ^= i0;
                C3[5] ^= i1;
                C3[6] ^= i22;
                C3[7] ^= i3;
                for (var i2 = 0; i2 < 4; i2++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M2, offset) {
              var X2 = this._X;
              nextState.call(this);
              S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
              S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
              S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
              S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
              for (var i2 = 0; i2 < 4; i2++) {
                S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
                M2[offset + i2] ^= S2[i2];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X2 = this._X;
            var C3 = this._C;
            for (var i2 = 0; i2 < 8; i2++) {
              C_[i2] = C3[i2];
            }
            C3[0] = C3[0] + 1295307597 + this._b | 0;
            C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i2 = 0; i2 < 8; i2++) {
              var gx = X2[i2] + C3[i2];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G2[i2] = gh ^ gl;
            }
            X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
            X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
            X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
            X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
            X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
            X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
            X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
            X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
          }
          C2.Rabbit = StreamCipher._createHelper(Rabbit);
        })();
        return CryptoJS2.Rabbit;
      });
    })(rabbit);
    return rabbit.exports;
  }
  var rabbitLegacy = { exports: {} };
  var hasRequiredRabbitLegacy;
  function requireRabbitLegacy() {
    if (hasRequiredRabbitLegacy)
      return rabbitLegacy.exports;
    hasRequiredRabbitLegacy = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C2.algo;
          var S2 = [];
          var C_ = [];
          var G2 = [];
          var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
            _doReset: function() {
              var K2 = this._key.words;
              var iv = this.cfg.iv;
              var X2 = this._X = [
                K2[0],
                K2[3] << 16 | K2[2] >>> 16,
                K2[1],
                K2[0] << 16 | K2[3] >>> 16,
                K2[2],
                K2[1] << 16 | K2[0] >>> 16,
                K2[3],
                K2[2] << 16 | K2[1] >>> 16
              ];
              var C3 = this._C = [
                K2[2] << 16 | K2[2] >>> 16,
                K2[0] & 4294901760 | K2[1] & 65535,
                K2[3] << 16 | K2[3] >>> 16,
                K2[1] & 4294901760 | K2[2] & 65535,
                K2[0] << 16 | K2[0] >>> 16,
                K2[2] & 4294901760 | K2[3] & 65535,
                K2[1] << 16 | K2[1] >>> 16,
                K2[3] & 4294901760 | K2[0] & 65535
              ];
              this._b = 0;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
              for (var i2 = 0; i2 < 8; i2++) {
                C3[i2] ^= X2[i2 + 4 & 7];
              }
              if (iv) {
                var IV = iv.words;
                var IV_0 = IV[0];
                var IV_1 = IV[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i22 & 4294901760;
                var i3 = i22 << 16 | i0 & 65535;
                C3[0] ^= i0;
                C3[1] ^= i1;
                C3[2] ^= i22;
                C3[3] ^= i3;
                C3[4] ^= i0;
                C3[5] ^= i1;
                C3[6] ^= i22;
                C3[7] ^= i3;
                for (var i2 = 0; i2 < 4; i2++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M2, offset) {
              var X2 = this._X;
              nextState.call(this);
              S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
              S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
              S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
              S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
              for (var i2 = 0; i2 < 4; i2++) {
                S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
                M2[offset + i2] ^= S2[i2];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X2 = this._X;
            var C3 = this._C;
            for (var i2 = 0; i2 < 8; i2++) {
              C_[i2] = C3[i2];
            }
            C3[0] = C3[0] + 1295307597 + this._b | 0;
            C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i2 = 0; i2 < 8; i2++) {
              var gx = X2[i2] + C3[i2];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G2[i2] = gh ^ gl;
            }
            X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
            X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
            X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
            X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
            X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
            X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
            X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
            X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
          }
          C2.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
        })();
        return CryptoJS2.RabbitLegacy;
      });
    })(rabbitLegacy);
    return rabbitLegacy.exports;
  }
  var blowfish = { exports: {} };
  var hasRequiredBlowfish;
  function requireBlowfish() {
    if (hasRequiredBlowfish)
      return blowfish.exports;
    hasRequiredBlowfish = 1;
    (function(module, exports) {
      (function(root, factory, undef) {
        {
          module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        (function() {
          var C2 = CryptoJS2;
          var C_lib = C2.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C2.algo;
          const N2 = 16;
          const ORIG_P = [
            608135816,
            2242054355,
            320440878,
            57701188,
            2752067618,
            698298832,
            137296536,
            3964562569,
            1160258022,
            953160567,
            3193202383,
            887688300,
            3232508343,
            3380367581,
            1065670069,
            3041331479,
            2450970073,
            2306472731
          ];
          const ORIG_S = [
            [
              3509652390,
              2564797868,
              805139163,
              3491422135,
              3101798381,
              1780907670,
              3128725573,
              4046225305,
              614570311,
              3012652279,
              134345442,
              2240740374,
              1667834072,
              1901547113,
              2757295779,
              4103290238,
              227898511,
              1921955416,
              1904987480,
              2182433518,
              2069144605,
              3260701109,
              2620446009,
              720527379,
              3318853667,
              677414384,
              3393288472,
              3101374703,
              2390351024,
              1614419982,
              1822297739,
              2954791486,
              3608508353,
              3174124327,
              2024746970,
              1432378464,
              3864339955,
              2857741204,
              1464375394,
              1676153920,
              1439316330,
              715854006,
              3033291828,
              289532110,
              2706671279,
              2087905683,
              3018724369,
              1668267050,
              732546397,
              1947742710,
              3462151702,
              2609353502,
              2950085171,
              1814351708,
              2050118529,
              680887927,
              999245976,
              1800124847,
              3300911131,
              1713906067,
              1641548236,
              4213287313,
              1216130144,
              1575780402,
              4018429277,
              3917837745,
              3693486850,
              3949271944,
              596196993,
              3549867205,
              258830323,
              2213823033,
              772490370,
              2760122372,
              1774776394,
              2652871518,
              566650946,
              4142492826,
              1728879713,
              2882767088,
              1783734482,
              3629395816,
              2517608232,
              2874225571,
              1861159788,
              326777828,
              3124490320,
              2130389656,
              2716951837,
              967770486,
              1724537150,
              2185432712,
              2364442137,
              1164943284,
              2105845187,
              998989502,
              3765401048,
              2244026483,
              1075463327,
              1455516326,
              1322494562,
              910128902,
              469688178,
              1117454909,
              936433444,
              3490320968,
              3675253459,
              1240580251,
              122909385,
              2157517691,
              634681816,
              4142456567,
              3825094682,
              3061402683,
              2540495037,
              79693498,
              3249098678,
              1084186820,
              1583128258,
              426386531,
              1761308591,
              1047286709,
              322548459,
              995290223,
              1845252383,
              2603652396,
              3431023940,
              2942221577,
              3202600964,
              3727903485,
              1712269319,
              422464435,
              3234572375,
              1170764815,
              3523960633,
              3117677531,
              1434042557,
              442511882,
              3600875718,
              1076654713,
              1738483198,
              4213154764,
              2393238008,
              3677496056,
              1014306527,
              4251020053,
              793779912,
              2902807211,
              842905082,
              4246964064,
              1395751752,
              1040244610,
              2656851899,
              3396308128,
              445077038,
              3742853595,
              3577915638,
              679411651,
              2892444358,
              2354009459,
              1767581616,
              3150600392,
              3791627101,
              3102740896,
              284835224,
              4246832056,
              1258075500,
              768725851,
              2589189241,
              3069724005,
              3532540348,
              1274779536,
              3789419226,
              2764799539,
              1660621633,
              3471099624,
              4011903706,
              913787905,
              3497959166,
              737222580,
              2514213453,
              2928710040,
              3937242737,
              1804850592,
              3499020752,
              2949064160,
              2386320175,
              2390070455,
              2415321851,
              4061277028,
              2290661394,
              2416832540,
              1336762016,
              1754252060,
              3520065937,
              3014181293,
              791618072,
              3188594551,
              3933548030,
              2332172193,
              3852520463,
              3043980520,
              413987798,
              3465142937,
              3030929376,
              4245938359,
              2093235073,
              3534596313,
              375366246,
              2157278981,
              2479649556,
              555357303,
              3870105701,
              2008414854,
              3344188149,
              4221384143,
              3956125452,
              2067696032,
              3594591187,
              2921233993,
              2428461,
              544322398,
              577241275,
              1471733935,
              610547355,
              4027169054,
              1432588573,
              1507829418,
              2025931657,
              3646575487,
              545086370,
              48609733,
              2200306550,
              1653985193,
              298326376,
              1316178497,
              3007786442,
              2064951626,
              458293330,
              2589141269,
              3591329599,
              3164325604,
              727753846,
              2179363840,
              146436021,
              1461446943,
              4069977195,
              705550613,
              3059967265,
              3887724982,
              4281599278,
              3313849956,
              1404054877,
              2845806497,
              146425753,
              1854211946
            ],
            [
              1266315497,
              3048417604,
              3681880366,
              3289982499,
              290971e4,
              1235738493,
              2632868024,
              2414719590,
              3970600049,
              1771706367,
              1449415276,
              3266420449,
              422970021,
              1963543593,
              2690192192,
              3826793022,
              1062508698,
              1531092325,
              1804592342,
              2583117782,
              2714934279,
              4024971509,
              1294809318,
              4028980673,
              1289560198,
              2221992742,
              1669523910,
              35572830,
              157838143,
              1052438473,
              1016535060,
              1802137761,
              1753167236,
              1386275462,
              3080475397,
              2857371447,
              1040679964,
              2145300060,
              2390574316,
              1461121720,
              2956646967,
              4031777805,
              4028374788,
              33600511,
              2920084762,
              1018524850,
              629373528,
              3691585981,
              3515945977,
              2091462646,
              2486323059,
              586499841,
              988145025,
              935516892,
              3367335476,
              2599673255,
              2839830854,
              265290510,
              3972581182,
              2759138881,
              3795373465,
              1005194799,
              847297441,
              406762289,
              1314163512,
              1332590856,
              1866599683,
              4127851711,
              750260880,
              613907577,
              1450815602,
              3165620655,
              3734664991,
              3650291728,
              3012275730,
              3704569646,
              1427272223,
              778793252,
              1343938022,
              2676280711,
              2052605720,
              1946737175,
              3164576444,
              3914038668,
              3967478842,
              3682934266,
              1661551462,
              3294938066,
              4011595847,
              840292616,
              3712170807,
              616741398,
              312560963,
              711312465,
              1351876610,
              322626781,
              1910503582,
              271666773,
              2175563734,
              1594956187,
              70604529,
              3617834859,
              1007753275,
              1495573769,
              4069517037,
              2549218298,
              2663038764,
              504708206,
              2263041392,
              3941167025,
              2249088522,
              1514023603,
              1998579484,
              1312622330,
              694541497,
              2582060303,
              2151582166,
              1382467621,
              776784248,
              2618340202,
              3323268794,
              2497899128,
              2784771155,
              503983604,
              4076293799,
              907881277,
              423175695,
              432175456,
              1378068232,
              4145222326,
              3954048622,
              3938656102,
              3820766613,
              2793130115,
              2977904593,
              26017576,
              3274890735,
              3194772133,
              1700274565,
              1756076034,
              4006520079,
              3677328699,
              720338349,
              1533947780,
              354530856,
              688349552,
              3973924725,
              1637815568,
              332179504,
              3949051286,
              53804574,
              2852348879,
              3044236432,
              1282449977,
              3583942155,
              3416972820,
              4006381244,
              1617046695,
              2628476075,
              3002303598,
              1686838959,
              431878346,
              2686675385,
              1700445008,
              1080580658,
              1009431731,
              832498133,
              3223435511,
              2605976345,
              2271191193,
              2516031870,
              1648197032,
              4164389018,
              2548247927,
              300782431,
              375919233,
              238389289,
              3353747414,
              2531188641,
              2019080857,
              1475708069,
              455242339,
              2609103871,
              448939670,
              3451063019,
              1395535956,
              2413381860,
              1841049896,
              1491858159,
              885456874,
              4264095073,
              4001119347,
              1565136089,
              3898914787,
              1108368660,
              540939232,
              1173283510,
              2745871338,
              3681308437,
              4207628240,
              3343053890,
              4016749493,
              1699691293,
              1103962373,
              3625875870,
              2256883143,
              3830138730,
              1031889488,
              3479347698,
              1535977030,
              4236805024,
              3251091107,
              2132092099,
              1774941330,
              1199868427,
              1452454533,
              157007616,
              2904115357,
              342012276,
              595725824,
              1480756522,
              206960106,
              497939518,
              591360097,
              863170706,
              2375253569,
              3596610801,
              1814182875,
              2094937945,
              3421402208,
              1082520231,
              3463918190,
              2785509508,
              435703966,
              3908032597,
              1641649973,
              2842273706,
              3305899714,
              1510255612,
              2148256476,
              2655287854,
              3276092548,
              4258621189,
              236887753,
              3681803219,
              274041037,
              1734335097,
              3815195456,
              3317970021,
              1899903192,
              1026095262,
              4050517792,
              356393447,
              2410691914,
              3873677099,
              3682840055
            ],
            [
              3913112168,
              2491498743,
              4132185628,
              2489919796,
              1091903735,
              1979897079,
              3170134830,
              3567386728,
              3557303409,
              857797738,
              1136121015,
              1342202287,
              507115054,
              2535736646,
              337727348,
              3213592640,
              1301675037,
              2528481711,
              1895095763,
              1721773893,
              3216771564,
              62756741,
              2142006736,
              835421444,
              2531993523,
              1442658625,
              3659876326,
              2882144922,
              676362277,
              1392781812,
              170690266,
              3921047035,
              1759253602,
              3611846912,
              1745797284,
              664899054,
              1329594018,
              3901205900,
              3045908486,
              2062866102,
              2865634940,
              3543621612,
              3464012697,
              1080764994,
              553557557,
              3656615353,
              3996768171,
              991055499,
              499776247,
              1265440854,
              648242737,
              3940784050,
              980351604,
              3713745714,
              1749149687,
              3396870395,
              4211799374,
              3640570775,
              1161844396,
              3125318951,
              1431517754,
              545492359,
              4268468663,
              3499529547,
              1437099964,
              2702547544,
              3433638243,
              2581715763,
              2787789398,
              1060185593,
              1593081372,
              2418618748,
              4260947970,
              69676912,
              2159744348,
              86519011,
              2512459080,
              3838209314,
              1220612927,
              3339683548,
              133810670,
              1090789135,
              1078426020,
              1569222167,
              845107691,
              3583754449,
              4072456591,
              1091646820,
              628848692,
              1613405280,
              3757631651,
              526609435,
              236106946,
              48312990,
              2942717905,
              3402727701,
              1797494240,
              859738849,
              992217954,
              4005476642,
              2243076622,
              3870952857,
              3732016268,
              765654824,
              3490871365,
              2511836413,
              1685915746,
              3888969200,
              1414112111,
              2273134842,
              3281911079,
              4080962846,
              172450625,
              2569994100,
              980381355,
              4109958455,
              2819808352,
              2716589560,
              2568741196,
              3681446669,
              3329971472,
              1835478071,
              660984891,
              3704678404,
              4045999559,
              3422617507,
              3040415634,
              1762651403,
              1719377915,
              3470491036,
              2693910283,
              3642056355,
              3138596744,
              1364962596,
              2073328063,
              1983633131,
              926494387,
              3423689081,
              2150032023,
              4096667949,
              1749200295,
              3328846651,
              309677260,
              2016342300,
              1779581495,
              3079819751,
              111262694,
              1274766160,
              443224088,
              298511866,
              1025883608,
              3806446537,
              1145181785,
              168956806,
              3641502830,
              3584813610,
              1689216846,
              3666258015,
              3200248200,
              1692713982,
              2646376535,
              4042768518,
              1618508792,
              1610833997,
              3523052358,
              4130873264,
              2001055236,
              3610705100,
              2202168115,
              4028541809,
              2961195399,
              1006657119,
              2006996926,
              3186142756,
              1430667929,
              3210227297,
              1314452623,
              4074634658,
              4101304120,
              2273951170,
              1399257539,
              3367210612,
              3027628629,
              1190975929,
              2062231137,
              2333990788,
              2221543033,
              2438960610,
              1181637006,
              548689776,
              2362791313,
              3372408396,
              3104550113,
              3145860560,
              296247880,
              1970579870,
              3078560182,
              3769228297,
              1714227617,
              3291629107,
              3898220290,
              166772364,
              1251581989,
              493813264,
              448347421,
              195405023,
              2709975567,
              677966185,
              3703036547,
              1463355134,
              2715995803,
              1338867538,
              1343315457,
              2802222074,
              2684532164,
              233230375,
              2599980071,
              2000651841,
              3277868038,
              1638401717,
              4028070440,
              3237316320,
              6314154,
              819756386,
              300326615,
              590932579,
              1405279636,
              3267499572,
              3150704214,
              2428286686,
              3959192993,
              3461946742,
              1862657033,
              1266418056,
              963775037,
              2089974820,
              2263052895,
              1917689273,
              448879540,
              3550394620,
              3981727096,
              150775221,
              3627908307,
              1303187396,
              508620638,
              2975983352,
              2726630617,
              1817252668,
              1876281319,
              1457606340,
              908771278,
              3720792119,
              3617206836,
              2455994898,
              1729034894,
              1080033504
            ],
            [
              976866871,
              3556439503,
              2881648439,
              1522871579,
              1555064734,
              1336096578,
              3548522304,
              2579274686,
              3574697629,
              3205460757,
              3593280638,
              3338716283,
              3079412587,
              564236357,
              2993598910,
              1781952180,
              1464380207,
              3163844217,
              3332601554,
              1699332808,
              1393555694,
              1183702653,
              3581086237,
              1288719814,
              691649499,
              2847557200,
              2895455976,
              3193889540,
              2717570544,
              1781354906,
              1676643554,
              2592534050,
              3230253752,
              1126444790,
              2770207658,
              2633158820,
              2210423226,
              2615765581,
              2414155088,
              3127139286,
              673620729,
              2805611233,
              1269405062,
              4015350505,
              3341807571,
              4149409754,
              1057255273,
              2012875353,
              2162469141,
              2276492801,
              2601117357,
              993977747,
              3918593370,
              2654263191,
              753973209,
              36408145,
              2530585658,
              25011837,
              3520020182,
              2088578344,
              530523599,
              2918365339,
              1524020338,
              1518925132,
              3760827505,
              3759777254,
              1202760957,
              3985898139,
              3906192525,
              674977740,
              4174734889,
              2031300136,
              2019492241,
              3983892565,
              4153806404,
              3822280332,
              352677332,
              2297720250,
              60907813,
              90501309,
              3286998549,
              1016092578,
              2535922412,
              2839152426,
              457141659,
              509813237,
              4120667899,
              652014361,
              1966332200,
              2975202805,
              55981186,
              2327461051,
              676427537,
              3255491064,
              2882294119,
              3433927263,
              1307055953,
              942726286,
              933058658,
              2468411793,
              3933900994,
              4215176142,
              1361170020,
              2001714738,
              2830558078,
              3274259782,
              1222529897,
              1679025792,
              2729314320,
              3714953764,
              1770335741,
              151462246,
              3013232138,
              1682292957,
              1483529935,
              471910574,
              1539241949,
              458788160,
              3436315007,
              1807016891,
              3718408830,
              978976581,
              1043663428,
              3165965781,
              1927990952,
              4200891579,
              2372276910,
              3208408903,
              3533431907,
              1412390302,
              2931980059,
              4132332400,
              1947078029,
              3881505623,
              4168226417,
              2941484381,
              1077988104,
              1320477388,
              886195818,
              18198404,
              3786409e3,
              2509781533,
              112762804,
              3463356488,
              1866414978,
              891333506,
              18488651,
              661792760,
              1628790961,
              3885187036,
              3141171499,
              876946877,
              2693282273,
              1372485963,
              791857591,
              2686433993,
              3759982718,
              3167212022,
              3472953795,
              2716379847,
              445679433,
              3561995674,
              3504004811,
              3574258232,
              54117162,
              3331405415,
              2381918588,
              3769707343,
              4154350007,
              1140177722,
              4074052095,
              668550556,
              3214352940,
              367459370,
              261225585,
              2610173221,
              4209349473,
              3468074219,
              3265815641,
              314222801,
              3066103646,
              3808782860,
              282218597,
              3406013506,
              3773591054,
              379116347,
              1285071038,
              846784868,
              2669647154,
              3771962079,
              3550491691,
              2305946142,
              453669953,
              1268987020,
              3317592352,
              3279303384,
              3744833421,
              2610507566,
              3859509063,
              266596637,
              3847019092,
              517658769,
              3462560207,
              3443424879,
              370717030,
              4247526661,
              2224018117,
              4143653529,
              4112773975,
              2788324899,
              2477274417,
              1456262402,
              2901442914,
              1517677493,
              1846949527,
              2295493580,
              3734397586,
              2176403920,
              1280348187,
              1908823572,
              3871786941,
              846861322,
              1172426758,
              3287448474,
              3383383037,
              1655181056,
              3139813346,
              901632758,
              1897031941,
              2986607138,
              3066810236,
              3447102507,
              1393639104,
              373351379,
              950779232,
              625454576,
              3124240540,
              4148612726,
              2007998917,
              544563296,
              2244738638,
              2330496472,
              2058025392,
              1291430526,
              424198748,
              50039436,
              29584100,
              3605783033,
              2429876329,
              2791104160,
              1057563949,
              3255363231,
              3075367218,
              3463963227,
              1469046755,
              985887462
            ]
          ];
          var BLOWFISH_CTX = {
            pbox: [],
            sbox: []
          };
          function F2(ctx, x) {
            let a2 = x >> 24 & 255;
            let b2 = x >> 16 & 255;
            let c2 = x >> 8 & 255;
            let d2 = x & 255;
            let y2 = ctx.sbox[0][a2] + ctx.sbox[1][b2];
            y2 = y2 ^ ctx.sbox[2][c2];
            y2 = y2 + ctx.sbox[3][d2];
            return y2;
          }
          function BlowFish_Encrypt(ctx, left, right) {
            let Xl = left;
            let Xr = right;
            let temp;
            for (let i2 = 0; i2 < N2; ++i2) {
              Xl = Xl ^ ctx.pbox[i2];
              Xr = F2(ctx, Xl) ^ Xr;
              temp = Xl;
              Xl = Xr;
              Xr = temp;
            }
            temp = Xl;
            Xl = Xr;
            Xr = temp;
            Xr = Xr ^ ctx.pbox[N2];
            Xl = Xl ^ ctx.pbox[N2 + 1];
            return { left: Xl, right: Xr };
          }
          function BlowFish_Decrypt(ctx, left, right) {
            let Xl = left;
            let Xr = right;
            let temp;
            for (let i2 = N2 + 1; i2 > 1; --i2) {
              Xl = Xl ^ ctx.pbox[i2];
              Xr = F2(ctx, Xl) ^ Xr;
              temp = Xl;
              Xl = Xr;
              Xr = temp;
            }
            temp = Xl;
            Xl = Xr;
            Xr = temp;
            Xr = Xr ^ ctx.pbox[1];
            Xl = Xl ^ ctx.pbox[0];
            return { left: Xl, right: Xr };
          }
          function BlowFishInit(ctx, key, keysize) {
            for (let Row = 0; Row < 4; Row++) {
              ctx.sbox[Row] = [];
              for (let Col = 0; Col < 256; Col++) {
                ctx.sbox[Row][Col] = ORIG_S[Row][Col];
              }
            }
            let keyIndex = 0;
            for (let index = 0; index < N2 + 2; index++) {
              ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
              keyIndex++;
              if (keyIndex >= keysize) {
                keyIndex = 0;
              }
            }
            let Data1 = 0;
            let Data2 = 0;
            let res = 0;
            for (let i2 = 0; i2 < N2 + 2; i2 += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.pbox[i2] = Data1;
              ctx.pbox[i2 + 1] = Data2;
            }
            for (let i2 = 0; i2 < 4; i2++) {
              for (let j2 = 0; j2 < 256; j2 += 2) {
                res = BlowFish_Encrypt(ctx, Data1, Data2);
                Data1 = res.left;
                Data2 = res.right;
                ctx.sbox[i2][j2] = Data1;
                ctx.sbox[i2][j2 + 1] = Data2;
              }
            }
            return true;
          }
          var Blowfish = C_algo.Blowfish = BlockCipher.extend({
            _doReset: function() {
              if (this._keyPriorReset === this._key) {
                return;
              }
              var key = this._keyPriorReset = this._key;
              var keyWords = key.words;
              var keySize = key.sigBytes / 4;
              BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
            },
            encryptBlock: function(M2, offset) {
              var res = BlowFish_Encrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
              M2[offset] = res.left;
              M2[offset + 1] = res.right;
            },
            decryptBlock: function(M2, offset) {
              var res = BlowFish_Decrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
              M2[offset] = res.left;
              M2[offset + 1] = res.right;
            },
            blockSize: 64 / 32,
            keySize: 128 / 32,
            ivSize: 64 / 32
          });
          C2.Blowfish = BlockCipher._createHelper(Blowfish);
        })();
        return CryptoJS2.Blowfish;
      });
    })(blowfish);
    return blowfish.exports;
  }
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      return CryptoJS2;
    });
  })(cryptoJs);
  var cryptoJsExports = cryptoJs.exports;
  const CryptoJS = /* @__PURE__ */ getDefaultExportFromCjs(cryptoJsExports);
  function signRequest(params) {
    const sortedParams = Object.keys(params).sort().map((key) => `${key}=${params[key]}`).join("&");
    const signStr = `${sortedParams}${gaodeSecurityKey}`;
    const sign = CryptoJS.MD5(signStr).toString();
    return `${sortedParams}&sig=${sign}`;
  }
  const _imports_0$3 = "/static/icons/check.png";
  const AMAP_API = "https://restapi.amap.com/v3";
  const _sfc_main$q = {
    name: "LocationSharing",
    props: {
      recipientId: {
        type: String,
        required: true
      },
      missionId: {
        type: String,
        required: true
      }
    },
    data() {
      return {
        currentLocation: {
          latitude: 39.909604,
          longitude: 116.397228
        },
        searchKeyword: "",
        markers: [],
        nearbyPOIs: [],
        selectedPOI: null,
        searchDebounceTimer: null
      };
    },
    mounted() {
      this.getCurrentLocation();
      this.hideMessageInput();
    },
    beforeDestroy() {
      this.showMessageInput();
    },
    methods: {
      getCurrentLocation() {
        uni.getLocation({
          type: "gcj02",
          success: (res) => {
            this.currentLocation = {
              latitude: res.latitude,
              longitude: res.longitude
            };
            this.updateMarkers();
            this.searchNearbyPOIs();
          },
          fail: (err) => {
            formatAppLog("error", "at pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue:103", "èŽ·å–ä½ç½®å¤±è´¥:", err);
            uni.showToast({
              title: "èŽ·å–ä½ç½®å¤±è´¥ï¼Œè¯·æ£€æŸ¥å®šä½æƒé™",
              icon: "none"
            });
          }
        });
      },
      updateMarkers() {
        this.markers = [{
          id: 1,
          latitude: this.currentLocation.latitude,
          longitude: this.currentLocation.longitude,
          iconPath: "/static/icons/location-blue.png",
          width: 32,
          height: 32
        }];
        if (this.selectedPOI) {
          this.markers.push({
            id: 2,
            latitude: this.selectedPOI.location.split(",")[1],
            longitude: this.selectedPOI.location.split(",")[0],
            iconPath: "/static/icons/location-red.png",
            width: 32,
            height: 32
          });
        }
      },
      async searchNearbyPOIs(keyword = "") {
        try {
          const location2 = `${this.currentLocation.longitude},${this.currentLocation.latitude}`;
          const params = {
            key: gaodeApiKey,
            location: location2,
            keywords: keyword,
            radius: 1e3,
            extensions: "all"
          };
          const signedParams = signRequest(params);
          const url = `${AMAP_API}/place/around?${signedParams}`;
          const response = await uni.request({
            url,
            method: "GET"
          });
          if (response.data.status === "1") {
            this.nearbyPOIs = response.data.pois.map((poi) => ({
              id: poi.id,
              name: poi.name,
              address: poi.address,
              location: poi.location,
              distance: poi.distance
            }));
          } else {
            throw new Error(response.data.info || "æœªçŸ¥é”™è¯¯");
          }
        } catch (error) {
          formatAppLog("error", "at pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue:162", "æœç´¢ä½ç½®å¤±è´¥:", error);
          let errorMessage = "æœç´¢ä½ç½®å¤±è´¥ï¼Œè¯·ç¨åŽé‡è¯•";
          if (error.message === "USERKEY_PLAT_NOMATCH") {
            errorMessage = "APIå¯†é’¥é…ç½®é”™è¯¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜";
          }
          uni.showToast({
            title: errorMessage,
            icon: "none"
          });
        }
      },
      handleSearch(event) {
        if (this.searchDebounceTimer) {
          clearTimeout(this.searchDebounceTimer);
        }
        this.searchDebounceTimer = setTimeout(() => {
          this.searchNearbyPOIs(event.detail.value);
        }, 500);
      },
      selectLocation(poi) {
        this.selectedPOI = poi;
        this.updateMarkers();
      },
      async handleMapTap(e2) {
        const { latitude, longitude } = e2.detail;
        try {
          const params = {
            key: gaodeApiKey,
            location: `${longitude},${latitude}`
          };
          const signedParams = signRequest(params);
          const url = `${AMAP_API}/geocode/regeo?${signedParams}`;
          const response = await uni.request({ url });
          if (response.data.status === "1") {
            const regeocode = response.data.regeocode;
            this.selectedPOI = {
              id: Date.now().toString(),
              name: regeocode.formatted_address,
              address: regeocode.addressComponent.street + regeocode.addressComponent.streetNumber,
              location: `${longitude},${latitude}`
            };
            this.updateMarkers();
          } else {
            throw new Error(response.data.info || "èŽ·å–åœ°å€ä¿¡æ¯å¤±è´¥");
          }
        } catch (error) {
          formatAppLog("error", "at pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue:210", "èŽ·å–åœ°å€ä¿¡æ¯å¤±è´¥:", error);
          uni.showToast({
            title: "èŽ·å–åœ°å€ä¿¡æ¯å¤±è´¥ï¼Œè¯·é‡è¯•",
            icon: "none"
          });
        }
      },
      handleComplete() {
        if (!this.selectedPOI) {
          uni.showToast({
            title: "è¯·é€‰æ‹©ä½ç½®",
            icon: "none"
          });
          return;
        }
        const locationData = {
          latitude: parseFloat(this.selectedPOI.location.split(",")[1]),
          longitude: parseFloat(this.selectedPOI.location.split(",")[0]),
          name: this.selectedPOI.name,
          address: this.selectedPOI.address,
          type: "location"
        };
        formatAppLog("log", "at pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue:234", "LocationSharing: å‘é€ä½ç½®æ•°æ®", locationData);
        this.$emit("location-selected", locationData);
        this.$emit("close");
      },
      formatDistance(distance) {
        if (distance < 1e3) {
          return `${distance}ç±³`;
        }
        return `${(distance / 1e3).toFixed(1)}åƒç±³`;
      },
      hideMessageInput() {
        this.$emit("hide-message-input", true);
        uni.$emit("hide-chat-input", true);
      },
      showMessageInput() {
        this.$emit("show-message-input");
      }
    }
  };
  function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "location-sharing" }, [
      vue.createCommentVNode(" åœ°å›¾å®¹å™¨ "),
      vue.createElementVNode("view", { class: "map-container" }, [
        vue.createElementVNode("map", {
          id: "locationMap",
          class: "map",
          latitude: $data.currentLocation.latitude,
          longitude: $data.currentLocation.longitude,
          markers: $data.markers,
          scale: 16,
          "show-location": "",
          onTap: _cache[0] || (_cache[0] = (...args) => $options.handleMapTap && $options.handleMapTap(...args))
        }, null, 40, ["latitude", "longitude", "markers"])
      ]),
      vue.createCommentVNode(" å¤´éƒ¨æœç´¢æ å’Œå®ŒæˆæŒ‰é’® "),
      vue.createElementVNode("view", { class: "header" }, [
        vue.createElementVNode("view", { class: "search-bar" }, [
          vue.withDirectives(vue.createElementVNode(
            "input",
            {
              type: "text",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.searchKeyword = $event),
              placeholder: "æœç´¢åœ°ç‚¹",
              onInput: _cache[2] || (_cache[2] = (...args) => $options.handleSearch && $options.handleSearch(...args))
            },
            null,
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vue.vModelText, $data.searchKeyword]
          ])
        ]),
        vue.createElementVNode("button", {
          class: "complete-btn",
          onClick: _cache[3] || (_cache[3] = (...args) => $options.handleComplete && $options.handleComplete(...args))
        }, "å®Œæˆ")
      ]),
      vue.createCommentVNode(" ä½ç½®åˆ—è¡¨ "),
      vue.createElementVNode("view", { class: "location-list" }, [
        vue.createElementVNode("scroll-view", {
          "scroll-y": "",
          class: "scroll-view"
        }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($data.nearbyPOIs, (poi, index) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                key: index,
                class: vue.normalizeClass(["location-item", { "location-item-selected": $data.selectedPOI && $data.selectedPOI.id === poi.id }]),
                onClick: ($event) => $options.selectLocation(poi)
              }, [
                vue.createElementVNode(
                  "view",
                  { class: "location-name" },
                  vue.toDisplayString(poi.name),
                  1
                  /* TEXT */
                ),
                vue.createElementVNode(
                  "view",
                  { class: "location-address" },
                  vue.toDisplayString(poi.address),
                  1
                  /* TEXT */
                ),
                poi.distance ? (vue.openBlock(), vue.createElementBlock(
                  "view",
                  {
                    key: 0,
                    class: "location-distance"
                  },
                  vue.toDisplayString($options.formatDistance(poi.distance)),
                  1
                  /* TEXT */
                )) : vue.createCommentVNode("v-if", true),
                $data.selectedPOI && $data.selectedPOI.id === poi.id ? (vue.openBlock(), vue.createElementBlock("view", {
                  key: 1,
                  class: "location-check"
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_0$3,
                    class: "check-icon"
                  })
                ])) : vue.createCommentVNode("v-if", true)
              ], 10, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])
    ]);
  }
  const LocationSharing = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$p], ["__scopeId", "data-v-5719cec1"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/LocationSharing.vue"]]);
  const _sfc_main$p = {
    name: "ToggleVoiceButton",
    props: {
      isVoiceInputActive: {
        type: Boolean,
        required: true
      },
      isBurnAfterReadingMode: {
        type: Boolean,
        default: false
      }
    },
    emits: ["toggle-voice-input"],
    methods: {
      getButtonImage() {
        if (this.isBurnAfterReadingMode) {
          return this.isVoiceInputActive ? "/static/message/fire-é”®ç›˜.png" : "/static/message/fire-è¯­éŸ³.png";
        } else {
          return this.isVoiceInputActive ? "/static/message/é”®ç›˜.png" : "/static/message/è¯­éŸ³.png";
        }
      }
    }
  };
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("image", {
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("toggle-voice-input")),
      src: $options.getButtonImage(),
      class: "toggle-button"
    }, null, 8, ["src"]);
  }
  const ToggleVoiceButton = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$o], ["__scopeId", "data-v-4e00339e"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/ToggleVoiceButton.vue"]]);
  const _sfc_main$o = {
    name: "VoiceRecordButton",
    props: {
      isRecording: {
        type: Boolean,
        default: false
      },
      voiceStatus: {
        type: Object,
        default: () => ({
          status: "ready",
          duration: 0,
          volume: 0
        })
      },
      startVoiceRecord: {
        type: Function,
        required: true
      },
      stopVoiceRecord: {
        type: Function,
        required: true
      }
    },
    methods: {
      formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${String(minutes).padStart(2, "0")}:${String(remainingSeconds).padStart(2, "0")}`;
      },
      startRecording() {
        this.startVoiceRecord();
      },
      stopRecording() {
        this.stopVoiceRecord();
      }
    }
  };
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "voice-record-container" }, [
      vue.createElementVNode(
        "view",
        {
          onTouchstart: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $options.startRecording && $options.startRecording(...args), ["prevent"])),
          onTouchend: _cache[1] || (_cache[1] = vue.withModifiers((...args) => $options.stopRecording && $options.stopRecording(...args), ["prevent"])),
          onTouchcancel: _cache[2] || (_cache[2] = vue.withModifiers((...args) => $options.stopRecording && $options.stopRecording(...args), ["prevent"])),
          class: "record-button"
        },
        [
          vue.createElementVNode("text", { class: "record-text" }, "æŒ‰ä½ è¯´è¯")
        ],
        32
        /* NEED_HYDRATION */
      ),
      $props.isRecording ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "voice-overlay"
      }, [
        vue.createElementVNode("view", { class: "voice-popup" }, [
          vue.createElementVNode(
            "view",
            { class: "voice-time" },
            vue.toDisplayString($options.formatTime($props.voiceStatus.duration)),
            1
            /* TEXT */
          ),
          vue.createElementVNode("view", { class: "voice-hint" }, "æ¾å¼€ ç»“æŸ")
        ])
      ])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const VoiceInputButton = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$n], ["__scopeId", "data-v-595166a0"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/VoiceInputButton.vue"]]);
  const _sfc_main$n = {
    name: "TextInput",
    props: {
      modelValue: {
        type: String,
        default: ""
      }
    },
    emits: ["update:modelValue", "send"],
    methods: {
      // æ›´æ–°è¾“å…¥å€¼
      updateValue(event) {
        const value = event.detail != void 0 ? event.detail.value : event.target.value;
        formatAppLog("log", "at pages/message/ChatComponent/ChatInputAreaComponent/TextInput.vue:28", event.detail, "value");
        this.$emit("update:modelValue", value || "");
      },
      // å‘é€æ¶ˆæ¯
      sendMessage() {
        this.$emit("send");
      }
    }
  };
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("input", {
      type: "text",
      class: "text-input",
      placeholder: "è¾“å…¥æ¶ˆæ¯...",
      value: $props.modelValue,
      onInput: _cache[0] || (_cache[0] = (...args) => $options.updateValue && $options.updateValue(...args)),
      onConfirm: _cache[1] || (_cache[1] = (...args) => $options.sendMessage && $options.sendMessage(...args))
    }, null, 40, ["value"]);
  }
  const TextInput = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$m], ["__scopeId", "data-v-c73de84a"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/TextInput.vue"]]);
  const _sfc_main$m = {
    name: "AttachButton",
    emits: ["click"],
    props: {
      isBurnAfterReadingMode: {
        type: Boolean,
        default: false
      }
    }
  };
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "attach-button",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
    }, [
      vue.createElementVNode("image", {
        src: $props.isBurnAfterReadingMode ? "/static/message/fire-å±•å¼€å¯¹è¯å·¥å…·.png" : "/static/message/å±•å¼€å¯¹è¯å·¥å…·.png",
        class: "attach-icon"
      }, null, 8, ["src"])
    ]);
  }
  const AttachButton = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$l], ["__scopeId", "data-v-a6f5c486"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/AttachButton.vue"]]);
  const _sfc_main$l = {
    name: "SendButton",
    emits: ["click"],
    methods: {
      sendMessage() {
        this.$emit("click");
      }
    }
  };
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "send-button",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.sendMessage && $options.sendMessage(...args))
    }, [
      vue.createElementVNode("text", { class: "send-text" }, "å‘é€")
    ]);
  }
  const SendButton = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$k], ["__scopeId", "data-v-ab1b8027"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatInputAreaComponent/SendButton.vue"]]);
  function afterAudioRecord() {
    getApp().globalData.audioRecording = false;
  }
  function beforeAudioRecordOrPlay(type) {
    const audioPlaying = getApp().globalData.audioPlaying;
    const audioRecording = getApp().globalData.audioRecording;
    if (audioPlaying || audioRecording) {
      uni.showToast({
        title: audioPlaying ? "è¯·å…ˆæš‚åœå…¶ä»–éŸ³é¢‘æ’­æ”¾" : "è¯·å…ˆç»“æŸå…¶ä»–å½•éŸ³",
        icon: "none"
      });
      return false;
    } else {
      if (type === "play") {
        getApp().globalData.audioPlaying = true;
      } else if (type === "record") {
        getApp().globalData.audioRecording = true;
      } else {
        throw new Error("type Error", type);
      }
      return true;
    }
  }
  function useVoiceInput(onFileSelected) {
    const isRecording = vue.ref(false);
    const recordAuth = vue.ref(false);
    const duration = vue.ref(6e5);
    const tempFilePath = vue.ref("");
    const time = vue.ref(0);
    const voiceAllTime = vue.ref(0);
    const playStatus = vue.ref(0);
    const recordImg = vue.ref("/static/images/icon_record.png");
    const voiceStatus = vue.reactive({
      status: "ready",
      duration: 0,
      volume: 0
    });
    let recorderManager2 = null;
    let timer = null;
    vue.onMounted(() => {
      initRecorderManager();
    });
    vue.onUnmounted(() => {
      if (recorderManager2) {
        recorderManager2.onStop(() => {
        });
        recorderManager2.onError(() => {
        });
      }
      stopTimer();
    });
    function initRecorderManager() {
      if (typeof uni !== "undefined" && uni.getRecorderManager) {
        recorderManager2 = uni.getRecorderManager();
        if (recorderManager2) {
          recorderManager2.onStart((e2) => onStart(e2));
          recorderManager2.onPause((e2) => onPause(e2));
          recorderManager2.onResume((e2) => onResume(e2));
          recorderManager2.onInterruptionBegin((e2) => onInterruptionBegin(e2));
          recorderManager2.onInterruptionEnd((e2) => onInterruptionEnd(e2));
          recorderManager2.onError((e2) => onError(e2));
          recorderManager2.onStop((e2) => onStop(e2));
          formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:80", "å½•éŸ³ç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸ");
        } else {
          formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:82", "èŽ·å–å½•éŸ³ç®¡ç†å™¨å®žä¾‹å¤±è´¥");
        }
      } else {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:85", "å½“å‰å¹³å°ä¸æ”¯æŒå½•éŸ³ç®¡ç†å™¨");
      }
    }
    function startVoiceRecord() {
      if (!recorderManager2) {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:92", "å½•éŸ³ç®¡ç†å™¨æœªåˆå§‹åŒ–");
        uni.showToast({
          title: "å½•éŸ³åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥",
          icon: "none"
        });
        return;
      }
      if (recordImg.value === "/static/images/icon_record.png" && beforeAudioRecordOrPlay("record")) {
        resetTimer();
        recorderManager2.start({
          duration: duration.value,
          format: "mp3",
          sampleRate: 22050
        });
      } else if (recordImg.value === "/static/images/icon_recording.png") {
        stopVoiceRecord();
      }
    }
    function stopVoiceRecord() {
      if (!recorderManager2) {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:116", "å½•éŸ³ç®¡ç†å™¨æœªåˆå§‹åŒ–");
        return;
      }
      recorderManager2.stop();
      afterAudioRecord();
    }
    function onStart(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:126", "å¼€å§‹å½•éŸ³", e2);
      recordImg.value = "/static/images/icon_recording.png";
      isRecording.value = true;
      voiceStatus.status = "recording";
      startTimer();
    }
    function onPause(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:135", "å½•éŸ³æš‚åœ", e2);
      afterAudioRecord();
      stopTimer();
    }
    function onResume(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:142", "å½•éŸ³æ¢å¤", e2);
      startTimer();
    }
    function onStop(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:148", "å½•éŸ³ç»“æŸ", e2);
      recordImg.value = "/static/images/icon_record.png";
      isRecording.value = false;
      voiceStatus.status = "ready";
      tempFilePath.value = e2.tempFilePath;
      time.value = Math.round(e2.duration / 1e3);
      voiceAllTime.value = time.value;
      voiceStatus.duration = time.value;
      stopTimer();
      uploadMp3Action(e2);
    }
    function onInterruptionBegin(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:162", "å½•éŸ³å› ä¸ºå—åˆ°ç³»ç»Ÿå ç”¨è€Œè¢«ä¸­æ–­", e2);
      stopTimer();
    }
    function onInterruptionEnd(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:168", "å½•éŸ³ä¸­æ–­ç»“æŸ", e2);
      startTimer();
    }
    function onError(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:174", "å½•éŸ³é”™è¯¯", e2);
      uni.showToast({
        title: "å½•éŸ³å¤±è´¥ï¼Œè¯·é‡è¯•",
        icon: "none"
      });
      stopTimer();
      resetTimer();
    }
    function startTimer() {
      if (!timer) {
        timer = setInterval(() => {
          time.value++;
          voiceStatus.duration = time.value;
        }, 1e3);
      }
    }
    function stopTimer() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
    }
    function resetTimer() {
      stopTimer();
      time.value = 0;
      voiceStatus.duration = 0;
    }
    function uploadMp3Action(e2) {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:210", "ä¸Šä¼ MP3ï¼Œå®Œæ•´çš„äº‹ä»¶å¯¹è±¡:", JSON.stringify(e2));
      if (!e2 || !e2.tempFilePath) {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useVoiceInput.js:213", "å½•éŸ³æ–‡ä»¶è·¯å¾„ç¼ºå¤±:", e2);
        uni.showToast({
          title: "å½•éŸ³æ–‡ä»¶ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•",
          icon: "none"
        });
        return;
      }
      const fileInfo = {
        type: "voice",
        path: e2.tempFilePath,
        duration: time.value,
        size: e2.fileSize,
        fromVoiceInput: true
      };
      formatAppLog("log", "at pages/message/ChatComponent/composables/useVoiceInput.js:229", "å‡†å¤‡å‘é€çš„æ–‡ä»¶ä¿¡æ¯:", JSON.stringify(fileInfo));
      onFileSelected(fileInfo);
    }
    return {
      isRecording,
      recordAuth,
      duration,
      tempFilePath,
      time,
      voiceAllTime,
      playStatus,
      voiceStatus,
      recordImg,
      startVoiceRecord,
      stopVoiceRecord
    };
  }
  function useAttachmentHandling(emit, props) {
    const showLocationSharing = vue.ref(false);
    const isBurnAfterReadingMode = vue.ref(false);
    const attachItem = (action, data) => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:12", "é™„ä»¶é¡¹è¢«é€‰æ‹©:", action);
      switch (action) {
        case "file":
          chooseAndSendFile();
          break;
        case "album":
          chooseAndSendPhoto();
          break;
        case "burn-after-reading":
          toggleBurnAfterReadingMode();
          break;
        case "camera":
          takePhoto();
          break;
        case "location":
          openLocationSharing();
          break;
        case "video-call":
          emit("video-call", action);
          break;
        default:
          emit("attach", action);
      }
      if (action !== "location" && action !== "file" && action !== "burn-after-reading") {
        emit("toggle-attach-menu", false);
      }
    };
    const chooseAndSendPhoto = async () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:45", "é€‰æ‹©ç…§ç‰‡æ–¹æ³•è¢«è°ƒç”¨");
      try {
        const imageRes = await new Promise((resolve, reject) => {
          uni.chooseImage({
            count: 1,
            success: (res) => {
              formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:51", "å›¾ç‰‡é€‰æ‹©æˆåŠŸ:", JSON.stringify(res));
              resolve(res);
            },
            fail: (err) => {
              formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:55", "å›¾ç‰‡é€‰æ‹©å¤±è´¥:", err);
              reject(err);
            }
          });
        });
        const tempFilePath = imageRes.tempFilePaths[0];
        const fileName = tempFilePath.split("/").pop();
        formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:63", "é€‰æ‹©çš„å›¾ç‰‡å:", fileName);
        emit("file-selected", {
          type: "image",
          path: tempFilePath,
          name: fileName,
          recipientId: props.recipientId,
          missionId: props.missionId,
          isBurnAfterReading: isBurnAfterReadingMode.value
        });
        emit("toggle-attach-menu", false);
      } catch (error) {
        formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:75", "é€‰æ‹©å›¾ç‰‡æ—¶å‡ºé”™:", error);
        showToast("é€‰æ‹©å¤±è´¥ï¼Œè¯·é‡è¯•");
      }
    };
    const takePhoto = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:82", "æ‹æ‘„ç…§ç‰‡");
      uni.chooseImage({
        count: 1,
        sourceType: ["camera"],
        success: (res) => {
          const tempFilePath = res.tempFilePaths[0];
          emit("file-selected", {
            type: "image",
            path: tempFilePath,
            name: "camera_photo.jpg",
            recipientId: props.recipientId,
            missionId: props.missionId,
            isBurnAfterReading: isBurnAfterReadingMode.value
          });
        },
        fail: (err) => {
          formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:98", "æ‹ç…§å¤±è´¥:", err);
          showToast("æ‹ç…§å¤±è´¥");
        }
      });
    };
    const openLocationSharing = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:106", "æ‰“å¼€ä½ç½®åˆ†äº«");
      showLocationSharing.value = true;
      emit("toggle-attach-menu", false);
    };
    const closeLocationSharing = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:113", "å…³é—­ä½ç½®åˆ†äº«");
      showLocationSharing.value = false;
    };
    const handleLocationSelected = (location2) => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:119", "ä½ç½®è¢«é€‰æ‹©:", JSON.stringify(location2));
      emit("send-message", {
        type: "location",
        content: location2,
        missionId: props.missionId,
        isBurnAfterReading: isBurnAfterReadingMode.value
      });
      closeLocationSharing();
    };
    const chooseAndSendFile = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:131", "é€‰æ‹©æ–‡ä»¶");
      chooseFileApp();
    };
    const chooseFileApp = () => {
      plus.io.resolveLocalFileSystemURL(
        "_doc/",
        (entry) => {
          entry.createReader().readEntries(
            (entries) => {
              const fileList = entries.filter((entry2) => !entry2.isDirectory);
              if (fileList.length > 0) {
                const selectedFile = fileList[0];
                handleFileSelected(selectedFile.fullPath, selectedFile.name, "file");
              } else {
                showToast("æ²¡æœ‰å¯é€‰æ‹©çš„æ–‡ä»¶");
              }
            },
            (e2) => {
              formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:160", "è¯»å–æ–‡ä»¶å¤¹å¤±è´¥:", e2);
              showToast("è¯»å–æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•");
            }
          );
        },
        (e2) => {
          formatAppLog("error", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:166", "è§£æžæ–‡ä»¶ç³»ç»ŸURLå¤±è´¥:", e2);
          showToast("æ— æ³•è®¿é—®æ–‡ä»¶ç³»ç»Ÿï¼Œè¯·é‡è¯•");
        }
      );
    };
    const handleFileSelected = (tempFilePath, fileName, type) => {
      emit("file-selected", {
        type,
        path: tempFilePath,
        name: fileName,
        recipientId: props.recipientId,
        missionId: props.missionId,
        isBurnAfterReading: isBurnAfterReadingMode.value
      });
      emit("toggle-attach-menu", false);
    };
    const toggleBurnAfterReadingMode = () => {
      isBurnAfterReadingMode.value = !isBurnAfterReadingMode.value;
      formatAppLog("log", "at pages/message/ChatComponent/composables/useAttachmentHandling.js:206", "é˜…åŽå³ç„šæ¨¡å¼å·²åˆ‡æ¢:", isBurnAfterReadingMode.value);
      emit("toggle-burn-after-reading", isBurnAfterReadingMode.value);
    };
    const showToast = (message) => {
      uni.showToast({
        title: message,
        icon: "none"
      });
    };
    return {
      showLocationSharing,
      attachItem,
      handleFileSelected,
      chooseAndSendFile,
      openLocationSharing,
      closeLocationSharing,
      handleLocationSelected,
      isBurnAfterReadingMode,
      toggleBurnAfterReadingMode
    };
  }
  function useMessageSending(newMessage, emit, props) {
    const sendMessage = () => {
      formatAppLog("log", "at pages/message/ChatComponent/composables/useMessageSending.js:5", "sendMessage æ–¹æ³•è¢«è°ƒç”¨");
      if (typeof newMessage.value !== "string" || !newMessage.value.trim()) {
        formatAppLog("log", "at pages/message/ChatComponent/composables/useMessageSending.js:8", "æ¶ˆæ¯ä¸ºç©ºæˆ–ä¸æ˜¯å­—ç¬¦ä¸²ï¼Œä¸å‘é€");
        return;
      }
      const messageData = {
        content: newMessage.value,
        type: "text",
        recipientId: props.recipientId,
        missionId: props.missionId
      };
      formatAppLog("log", "at pages/message/ChatComponent/composables/useMessageSending.js:19", "å‡†å¤‡å‘é€æ¶ˆæ¯:", messageData);
      emit("send-message", messageData);
      newMessage.value = "";
    };
    return {
      sendMessage
    };
  }
  const _sfc_main$k = {
    name: "ChatInputArea",
    components: {
      AttachmentMenu,
      LocationSharing,
      ToggleVoiceButton,
      VoiceInputButton,
      TextInput,
      AttachButton,
      SendButton
    },
    props: {
      modelValue: {
        type: Boolean,
        default: false
      },
      recipientId: {
        type: String,
        required: true
      },
      missionId: {
        type: [String, Array],
        required: true
      },
      initialBurnAfterReadingMode: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: "è¯·è¾“å…¥æ¶ˆæ¯"
      }
    },
    emits: ["send-message", "update:modelValue", "attach", "video-call", "file-selected", "toggle-burn-after-reading"],
    setup(props, { emit }) {
      const newMessage = vue.ref("");
      const showLocationSharing = vue.ref(false);
      const isVoiceInputActive = vue.ref(false);
      const isBurnAfterReadingMode = vue.ref(props.initialBurnAfterReadingMode);
      const isAttachMenuVisible = vue.ref(false);
      const isSending = vue.ref(false);
      const inputPlaceholder = vue.computed(() => {
        return isBurnAfterReadingMode.value ? "é˜…åŽå³ç„šæ¨¡å¼å·²å¼€å¯" : props.placeholder;
      });
      const handleVoiceFileSelected = (fileInfo) => {
        if (fileInfo && typeof fileInfo === "object" && fileInfo.fromVoiceInput) {
          if (!fileInfo.path) {
            uni.showToast({
              title: "è¯­éŸ³æ–‡ä»¶ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•",
              icon: "none"
            });
            return;
          }
          emit("file-selected", fileInfo);
        }
      };
      const {
        isRecording,
        recordAuth,
        duration,
        voiceStatus,
        startVoiceRecord,
        stopVoiceRecord
      } = useVoiceInput(handleVoiceFileSelected);
      const {
        attachItem: handleAttachItem,
        handleFileSelected,
        openLocationSharing,
        closeLocationSharing,
        handleLocationSelected,
        showLocationSharing: locationSharingState,
        isBurnAfterReadingMode: burnMode,
        toggleBurnAfterReadingMode
      } = useAttachmentHandling(emit, props);
      const { sendMessage: sendMessageHandler } = useMessageSending(newMessage, emit, props);
      const sendMessage = async () => {
        if (isSending.value || newMessage.value.trim().length === 0)
          return;
        isSending.value = true;
        try {
          await sendMessageHandler();
          newMessage.value = "";
        } catch (error) {
          formatAppLog("log", "at pages/message/ChatComponent/ChatInputArea.vue:171", "å‘é€æ¶ˆæ¯å¤±è´¥");
        } finally {
          isSending.value = false;
        }
        closeAttachMenu();
      };
      const toggleVoiceInput = () => {
        isVoiceInputActive.value = !isVoiceInputActive.value;
        closeAttachMenu();
      };
      const toggleAttachMenu = () => {
        isAttachMenuVisible.value = !isAttachMenuVisible.value;
        emit("update:modelValue", isAttachMenuVisible.value);
      };
      const closeAttachMenu = () => {
        isAttachMenuVisible.value = false;
        emit("update:modelValue", false);
      };
      vue.watch(() => props.recipientId, (newVal) => {
        if (!newVal) {
          showLocationSharing.value = false;
        }
      });
      vue.watch(locationSharingState, (newVal) => {
        showLocationSharing.value = newVal;
      });
      vue.watch(burnMode, (newVal) => {
        isBurnAfterReadingMode.value = newVal;
        emit("toggle-burn-after-reading", newVal);
      });
      vue.watch(isBurnAfterReadingMode, (newVal) => {
        emit("toggle-burn-after-reading", newVal);
      });
      vue.watch(() => props.initialBurnAfterReadingMode, (newVal) => {
        isBurnAfterReadingMode.value = newVal;
      });
      vue.watch(() => props.modelValue, (newValue) => {
        isAttachMenuVisible.value = newValue;
      });
      return {
        newMessage,
        showLocationSharing,
        isVoiceInputActive,
        isRecording,
        recordAuth,
        duration,
        voiceStatus,
        toggleVoiceInput,
        startVoiceRecord,
        stopVoiceRecord,
        sendMessage,
        toggleAttachMenu,
        closeAttachMenu,
        handleAttachItem,
        handleFileSelected,
        openLocationSharing,
        closeLocationSharing,
        handleLocationSelected,
        isBurnAfterReadingMode,
        toggleBurnAfterReadingMode,
        isAttachMenuVisible,
        inputPlaceholder,
        isSending
      };
    }
  };
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_attachment_menu = vue.resolveComponent("attachment-menu");
    const _component_toggle_voice_button = vue.resolveComponent("toggle-voice-button");
    const _component_voice_input_button = vue.resolveComponent("voice-input-button");
    const _component_text_input = vue.resolveComponent("text-input");
    const _component_attach_button = vue.resolveComponent("attach-button");
    const _component_send_button = vue.resolveComponent("send-button");
    const _component_location_sharing = vue.resolveComponent("location-sharing");
    return vue.openBlock(), vue.createElementBlock("view", { class: "chat-input-wrapper" }, [
      vue.createElementVNode("view", { class: "chat-content" }, [
        vue.createCommentVNode(" é™„ä»¶èœå• "),
        $setup.isAttachMenuVisible ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "attachment-menu"
        }, [
          vue.createVNode(_component_attachment_menu, {
            onAttach: $setup.handleAttachItem,
            onClose: $setup.closeAttachMenu
          }, null, 8, ["onAttach", "onClose"])
        ])) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" è¾“å…¥åŒºåŸŸ "),
        vue.createElementVNode("view", { class: "input-container" }, [
          vue.createElementVNode("view", { class: "chat-input" }, [
            vue.createCommentVNode(" è¯­éŸ³/é”®ç›˜åˆ‡æ¢æŒ‰é’® "),
            vue.createVNode(_component_toggle_voice_button, {
              "is-voice-input-active": $setup.isVoiceInputActive,
              "is-burn-after-reading-mode": $setup.isBurnAfterReadingMode,
              onToggleVoiceInput: $setup.toggleVoiceInput
            }, null, 8, ["is-voice-input-active", "is-burn-after-reading-mode", "onToggleVoiceInput"]),
            vue.createCommentVNode(" è¯­éŸ³å½•éŸ³æŒ‰é’® "),
            $setup.isVoiceInputActive ? (vue.openBlock(), vue.createBlock(_component_voice_input_button, {
              key: 0,
              "is-recording": $setup.isRecording,
              "voice-status": $setup.voiceStatus,
              "start-voice-record": $setup.startVoiceRecord,
              "stop-voice-record": $setup.stopVoiceRecord,
              class: "input-item"
            }, null, 8, ["is-recording", "voice-status", "start-voice-record", "stop-voice-record"])) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" æ–‡æœ¬è¾“å…¥æ¡† "),
                vue.createVNode(_component_text_input, {
                  modelValue: $setup.newMessage,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.newMessage = $event),
                  onSend: $setup.sendMessage,
                  placeholder: $setup.inputPlaceholder,
                  disabled: $setup.isSending,
                  class: "input-item"
                }, null, 8, ["modelValue", "onSend", "placeholder", "disabled"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )),
            vue.createCommentVNode(" é™„ä»¶æŒ‰é’® "),
            vue.createVNode(_component_attach_button, {
              onClick: $setup.toggleAttachMenu,
              "is-burn-after-reading-mode": $setup.isBurnAfterReadingMode
            }, null, 8, ["onClick", "is-burn-after-reading-mode"]),
            vue.createCommentVNode(" å‘é€æŒ‰é’® "),
            !$setup.isVoiceInputActive && ($setup.isAttachMenuVisible || $setup.newMessage.trim().length > 0) ? (vue.openBlock(), vue.createBlock(_component_send_button, {
              key: 2,
              onClick: $setup.sendMessage,
              disabled: $setup.isSending
            }, null, 8, ["onClick", "disabled"])) : vue.createCommentVNode("v-if", true)
          ])
        ])
      ]),
      vue.createCommentVNode(" ä½ç½®å…±äº«ç»„ä»¶ "),
      $setup.showLocationSharing ? (vue.openBlock(), vue.createBlock(_component_location_sharing, {
        key: 0,
        "recipient-id": $props.recipientId,
        "mission-id": $props.missionId,
        onLocationSelected: $setup.handleLocationSelected,
        onClose: $setup.closeLocationSharing
      }, null, 8, ["recipient-id", "mission-id", "onLocationSelected", "onClose"])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const ChatInputArea = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j], ["__scopeId", "data-v-e8a570ad"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ChatInputArea.vue"]]);
  const _sfc_main$j = {
    name: "ScrollToBottomButton",
    props: {
      show: {
        type: Boolean,
        default: false
      }
    }
  };
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return $props.show ? (vue.openBlock(), vue.createElementBlock("view", {
      key: 0,
      class: "scroll-to-bottom",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
    }, [
      vue.createElementVNode("text", { class: "scroll-to-bottom-icon" }, "â†“")
    ])) : vue.createCommentVNode("v-if", true);
  }
  const ScrollToBottomButton = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i], ["__scopeId", "data-v-92969997"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/ScrollToBottomButton.vue"]]);
  const _sfc_main$i = {
    name: "LoadingAnimation"
  };
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", { class: "loading-animation" }, [
      vue.createElementVNode("div", { class: "spinner" }),
      vue.createElementVNode("p", null, "æ­£åœ¨åŠ è½½æ¶ˆæ¯...")
    ]);
  }
  const LoadingAnimation$1 = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$h], ["__scopeId", "data-v-c7ff4daf"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/LoadingAnimation.vue"]]);
  const usePeerStore = defineStore("peerStore", {
    state() {
      return {
        /**
         * æœ¬åœ°å¯¹ç­‰ä½“å¯¹è±¡
         */
        localPeer: void 0,
        /**
         * æ­£åœ¨é€šè¯çš„æ•°æ®è¿žæŽ¥å¯¹è±¡
         */
        dataConnection: void 0,
        /**
         * æ­£åœ¨é€šè¯çš„åª’ä½“è¿žæŽ¥å¯¹è±¡
         */
        mediaConnection: void 0,
        /**
         * æ˜¯å¦æ¿€æ´»é€šçŸ¥
         */
        activateNotification: false,
        /**
         * è§†é¢‘é€šè¯æŒ‡ä»¤æžšä¸¾å€¼
         */
        instruction: {
          /**
           * è¯·æ±‚è§†é¢‘é€šè¯
           */
          request: 1,
          /**
           * æ‹’ç»è§†é¢‘é€šè¯
           */
          reject: 2,
          /**
           * æŽ¥å—è§†é¢‘é€šè¯
           */
          accept: 3,
          /**
           * å–æ¶ˆè§†é¢‘é€šè¯
           */
          cancel: 4,
          /**
           * æ­£å¸¸æŒ‚æ–­
           */
          ringOff: 5,
          /**
           * å¿™ç¢ŒæŒ‚æ–­
           */
          busy: 6
        }
      };
    }
  });
  const useFriendStore = defineStore("friendStore", {
    state() {
      return {
        onlineList: []
      };
    }
  });
  const useGroupStore = defineStore("group", () => {
    const state = vue.reactive({
      groupInfo: null
    });
    function setGroupInfo(groupData) {
      state.groupInfo = groupData;
    }
    function clearGroupInfo() {
      state.groupInfo = null;
    }
    function getGroupInfo() {
      return { ...state.groupInfo };
    }
    return { state, setGroupInfo, clearGroupInfo, getGroupInfo };
  });
  function useChatInitialization() {
    vue.ref(null);
    const userStore = useUserStore();
    const groupStore = useGroupStore();
    const fetchAndStoreGroupInfo = async (groupId) => {
      try {
        const response = await getGroupBasicInfo(groupId);
        if (response.code === 200) {
          const groupInfo = response.data;
          groupStore.setGroupInfo({
            id: groupInfo.id,
            groupName: groupInfo.groupName,
            groupMembers: groupInfo.groupMembers
          });
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:23", "èŽ·å–ç¾¤ç»„ä¿¡æ¯å¤±è´¥:", response.msg);
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:26", "èŽ·å–ç¾¤ç»„ä¿¡æ¯æ—¶å‘ç”Ÿé”™è¯¯:", JSON.stringify(error));
      }
    };
    const goBack = () => {
      uni.navigateBack({
        success: () => {
          uni.$emit("updateTabBarActiveTab", 1);
        },
        fail: (err) => {
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:37", "è¿”å›žå¤±è´¥:", JSON.stringify(err));
          uni.reLaunch({
            url: "/pages/tabBar/tabBar",
            success: () => {
              uni.$emit("updateTabBarActiveTab", 1);
            }
          });
        }
      });
    };
    const setupChatInfo = async (eventChannel, vm) => {
      if (!eventChannel) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:51", "äº‹ä»¶é€šé“æœªå®šä¹‰");
        return;
      }
      eventChannel.on("chatInfo", async (data) => {
        if (!data || !data.chatInfo) {
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:57", "æŽ¥æ”¶åˆ°çš„èŠå¤©ä¿¡æ¯æ— æ•ˆ:", JSON.stringify(data));
          return;
        }
        try {
          vm.chatInfo.value = {
            ...vm.chatInfo.value,
            ...data.chatInfo
          };
          if (!vm.chatInfo.value.missionId) {
            vm.chatInfo.value.missionId = userStore.state.missionId.toString();
          } else if (Array.isArray(vm.chatInfo.value.missionId)) {
            vm.chatInfo.value.missionId = vm.chatInfo.value.missionId.join(",");
          }
          if (vm.chatInfo.value.type === "group") {
            await fetchAndStoreGroupInfo(vm.chatInfo.value.id);
          }
          uni.setStorageSync("chatQuery", JSON.stringify(vm.chatInfo.value));
          vm.loadHistoryMessages();
          vm.$nextTick(() => {
            vm.scrollToBottom();
          });
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:89", "èŠå¤©åˆå§‹åŒ–:", {
            èŠå¤©ID: vm.chatInfo.value.id,
            èŠå¤©ç±»åž‹: vm.chatInfo.value.type,
            ä»»åŠ¡ID: vm.chatInfo.value.missionId
          });
        } catch (error) {
          formatAppLog("log", "at pages/message/ChatComposables/useChatInitialization.js:95", "å¤„ç† chatInfo æ—¶å‘ç”Ÿé”™è¯¯:", JSON.stringify(error));
        }
      });
    };
    return {
      goBack,
      setupChatInfo
    };
  }
  function useMessageHandling(chatInfo, list, currentFrom, currentTo, hasMoreMessages, scrollToBottom) {
    const userStore = useUserStore();
    const groupStore = useGroupStore();
    let isLoadingHistory = false;
    let lastLoadTime = 0;
    const LOAD_COOLDOWN = 5e3;
    const sendMessage = async (message) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:21", "å¼€å§‹å‘é€æ¶ˆæ¯:", message);
      if (message.content && chatInfo.value && chatInfo.value.id) {
        try {
          let response;
          const messageData = {
            message: typeof message.content === "object" ? JSON.stringify(message.content) : message.content,
            recipientId: chatInfo.value.id,
            messageType: message.type || "text",
            missionId: chatInfo.value.missionId,
            isPosition: message.type === "location",
            isSelfDestruct: chatInfo.value.isBurnAfterReadingMode
          };
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:34", "å‡†å¤‡å‘é€æ¶ˆæ¯æ•°æ®:", messageData);
          if (chatInfo.value.type === "group") {
            formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:37", "å‘é€ç¾¤èŠæ¶ˆæ¯");
            response = await sendGroupMessage({
              ...messageData,
              isGroupAnnouncement: false
            });
          } else {
            formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:43", "å‘é€ç§èŠæ¶ˆæ¯");
            response = await sendMessageToUser(messageData);
          }
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:47", "æ¶ˆæ¯å‘é€å“åº”:", response);
          if (response.code === 200) {
            const sentMessage = {
              ...response.data,
              selfDestruct: response.data.selfDestruct,
              content: message.content,
              userType: "self",
              timestamp: /* @__PURE__ */ new Date(),
              type: message.type || "text",
              messageType: message.type === "text" ? "MESSAGE" : message.type.toUpperCase()
            };
            handleMessageSent(sentMessage);
            await updateMessageList();
            vue.nextTick(() => {
              scrollToBottom();
            });
          } else {
            throw new Error(response.msg || "å‘é€æ¶ˆæ¯å¤±è´¥");
          }
        } catch (error) {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:68", "å‘é€æ¶ˆæ¯å¤±è´¥:", error);
        }
      } else {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:71", "æ¶ˆæ¯å†…å®¹ä¸ºç©ºæˆ– chatInfo æœªæ­£ç¡®åˆå§‹åŒ–");
      }
    };
    const handleMessageSent = (sentMessage) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:76", "æ·»åŠ å·²å‘é€æ¶ˆæ¯åˆ°åˆ—è¡¨");
      list.value.push(sentMessage);
    };
    const handleMessageFailed = (failedMessage) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:81", "å¤„ç†æ¶ˆæ¯å‘é€å¤±è´¥:", failedMessage);
    };
    const loadHistoryMessages = async (isLoadingMore = false, newFrom = null, newTo = null) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:86", "å¼€å§‹åŠ è½½åŽ†å²æ¶ˆæ¯");
      const now2 = Date.now();
      if (isLoadingHistory || now2 - lastLoadTime < LOAD_COOLDOWN) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:89", "è·³è¿‡åŠ è½½åŽ†å²æ¶ˆæ¯ï¼šæ­£åœ¨åŠ è½½æˆ–å†·å´ä¸­");
        return;
      }
      isLoadingHistory = true;
      lastLoadTime = now2;
      if (!chatInfo.value || !chatInfo.value.id || !chatInfo.value.missionId) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:97", "èŠå¤©ä¿¡æ¯ä¸å®Œæ•´ï¼Œæ— æ³•åŠ è½½åŽ†å²æ¶ˆæ¯");
        hasMoreMessages.value = false;
        isLoadingHistory = false;
        return false;
      }
      const from = newFrom !== null ? newFrom : currentFrom.value;
      const to = newTo !== null ? newTo : currentTo.value;
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:106", "åŠ è½½åŽ†å²æ¶ˆæ¯å‚æ•°:", { from, to, isLoadingMore });
      try {
        let response;
        if (chatInfo.value.type === "group") {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:111", "åŠ è½½ç¾¤èŠåŽ†å²æ¶ˆæ¯");
          response = await getGroupChatMessages({
            opponentId: chatInfo.value.id,
            from,
            to
          });
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:118", "åŠ è½½ç§èŠåŽ†å²æ¶ˆæ¯");
          response = await getHistoryChatMessages({
            opponentId: chatInfo.value.id,
            from,
            to,
            missionId: chatInfo.value.missionId
          });
        }
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:127", "åŽ†å²æ¶ˆæ¯åŠ è½½å“åº”:", response);
        if (response.code === 200) {
          let newMessages;
          if (chatInfo.value.type === "group") {
            newMessages = response.data.groupMessageVOS.reverse().map((msg) => mapGroupMessage(msg));
          } else {
            newMessages = response.data.messageVOList.reverse().map((msg) => mapPrivateMessage(msg));
          }
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:137", "æ–°æ¶ˆæ¯æ•°é‡:", newMessages.length);
          if (isLoadingMore) {
            formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:140", "æ·»åŠ æ–°æ¶ˆæ¯åˆ°åˆ—è¡¨å‰ç«¯");
            list.value = [...newMessages, ...list.value];
          } else {
            formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:143", "æ›¿æ¢æ•´ä¸ªæ¶ˆæ¯åˆ—è¡¨");
            list.value = newMessages;
          }
          hasMoreMessages.value = newMessages.length === to - from + 1;
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:148", "æ˜¯å¦æœ‰æ›´å¤šæ¶ˆæ¯:", hasMoreMessages.value);
          currentFrom.value = from;
          currentTo.value = to;
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:153", "æ›´æ–°åŽçš„æ¶ˆæ¯åˆ—è¡¨é•¿åº¦:", list.value.length);
          if (!isLoadingMore) {
            vue.nextTick(() => {
              scrollToBottom();
            });
          }
          return true;
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:163", "åŠ è½½åŽ†å²æ¶ˆæ¯å¤±è´¥:", response.msg);
          hasMoreMessages.value = false;
          uni.showToast({
            title: "åŠ è½½åŽ†å²æ¶ˆæ¯å¤±è´¥",
            icon: "none"
          });
          return false;
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:172", "åŠ è½½åŽ†å²æ¶ˆæ¯å‡ºé”™:", error);
        hasMoreMessages.value = false;
        uni.showToast({
          title: "ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åŽé‡è¯•",
          icon: "none"
        });
        return false;
      } finally {
        isLoadingHistory = false;
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:181", "åŽ†å²æ¶ˆæ¯åŠ è½½å®Œæˆï¼Œæ¶ˆæ¯åˆ—è¡¨:", list.value);
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:182", "åŽ†å²æ¶ˆæ¯åŠ è½½å®Œæˆ");
      }
    };
    const updateMessageList = async () => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:187", "å¼€å§‹æ›´æ–°æ¶ˆæ¯åˆ—è¡¨");
      if (isLoadingHistory) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:189", "æ­£åœ¨åŠ è½½åŽ†å²æ¶ˆæ¯ï¼Œè·³è¿‡æ›´æ–°");
        return;
      }
      try {
        const latestMessageId = list.value.length > 0 ? list.value[list.value.length - 1].id : null;
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:195", "æœ€æ–°æ¶ˆæ¯ID:", latestMessageId);
        let response;
        if (chatInfo.value.type === "group") {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:199", "æ›´æ–°ç¾¤èŠæ¶ˆæ¯åˆ—è¡¨");
          response = await getGroupChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            // å¢žåŠ èŽ·å–çš„æ¶ˆæ¯æ•°é‡
            lastMessageId: latestMessageId
          });
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:207", "æ›´æ–°ç§èŠæ¶ˆæ¯åˆ—è¡¨");
          response = await getHistoryChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            // å¢žåŠ èŽ·å–çš„æ¶ˆæ¯æ•°é‡
            missionId: chatInfo.value.missionId,
            lastMessageId: latestMessageId
          });
        }
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:217", "æ›´æ–°æ¶ˆæ¯åˆ—è¡¨å“åº”:", response);
        if (response.code === 200) {
          let newMessages;
          if (chatInfo.value.type === "group") {
            newMessages = response.data.groupMessageVOS.reverse().map((msg) => mapGroupMessage(msg));
          } else {
            newMessages = response.data.messageVOList.reverse().map((msg) => mapPrivateMessage(msg));
          }
          const mergedMessages = [...list.value, ...newMessages];
          const uniqueMessages = Array.from(new Map(mergedMessages.map((item) => [item.id, item])).values());
          list.value = uniqueMessages.sort((a2, b2) => new Date(a2.timestamp) - new Date(b2.timestamp));
          vue.nextTick(() => {
            scrollToBottom();
          });
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:236", "æ²¡æœ‰æ–°æ¶ˆæ¯æˆ–èŽ·å–å¤±è´¥");
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:239", "æ›´æ–°æ¶ˆæ¯åˆ—è¡¨å‡ºé”™:", error);
      }
    };
    const mapPrivateMessage = (msg) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:244", "æ˜ å°„ç§èŠæ¶ˆæ¯:", msg);
      let content = msg.message;
      let type = msg.messageType.toLowerCase();
      if (content === null) {
        content = "";
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:250", "è­¦å‘Š: æ¶ˆæ¯å†…å®¹ä¸ºç©º", msg);
      }
      if (type === "position") {
        try {
          content = JSON.parse(msg.message);
          type = "location";
        } catch (e2) {
          formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:258", "è§£æžä½ç½®æ•°æ®å¤±è´¥:", e2);
        }
      } else if (type === "image") {
        content = msg.previewUrl || msg.message;
      } else if (type === "text" && msg.message.toLowerCase().endsWith(".txt")) {
        type = "file";
      } else if (type === "audio" || type === "voice_message") {
        content = msg.previewUrl || msg.message;
      }
      const mappedMessage = {
        id: msg.id,
        content,
        userType: msg.senderId === chatInfo.value.id ? "other" : "self",
        avatar: (() => {
          if (msg.senderId === chatInfo.value.id) {
            return chatInfo.value.avatar && chatInfo.value.avatar[0] ? chatInfo.value.avatar[0] : "";
          } else {
            const userInfo = userStore.state.userInfo;
            return userInfo && userInfo.avatarUrl ? userInfo.avatarUrl : chatInfo.value._selfAvatar || "";
          }
        })(),
        timestamp: new Date(msg.sendTime),
        type,
        isRead: msg.isRead,
        messageType: msg.messageType,
        selfDestruct: msg.selfDestruct
      };
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:287", "æ˜ å°„åŽçš„ç§èŠæ¶ˆæ¯:", mappedMessage);
      return mappedMessage;
    };
    const mapGroupMessage = (msg) => {
      let content = msg.message;
      let type = msg.messageType.toLowerCase();
      if (content === null) {
        content = "";
      }
      if (type === "position") {
        try {
          content = JSON.parse(msg.message);
          type = "location";
        } catch (e2) {
        }
      } else if (type === "image") {
        content = msg.previewUrl || msg.message;
      } else if (type === "text" && msg.message.toLowerCase().endsWith(".txt")) {
        type = "file";
      } else if (type === "audio" || type === "voice_message") {
        content = msg.previewUrl || msg.message;
      }
      const groupInfo = groupStore.state.groupInfo;
      let avatar = chatInfo.value._selfAvatar || "";
      let senderName = "æœªçŸ¥ç”¨æˆ·";
      if (groupInfo && groupInfo.groupMembers) {
        const sender = groupInfo.groupMembers.find((member) => member.userId === msg.senderId);
        if (sender) {
          avatar = sender.avatarUrl || "";
          senderName = sender.userName || "æœªçŸ¥ç”¨æˆ·";
        }
      }
      const mappedMessage = {
        id: msg.id,
        content,
        userType: userStore.state.id === msg.senderId ? "self" : "other",
        avatar,
        timestamp: new Date(msg.sendTime),
        type,
        isRead: Array.isArray(msg.groupMessageUserReadVO) && msg.groupMessageUserReadVO.some((user) => user.userId === chatInfo.value.id && user.isRead),
        messageType: msg.messageType,
        selfDestruct: msg.selfDestruct,
        senderName,
        senderId: msg.senderId,
        groupMessageUserReadVO: Array.isArray(msg.groupMessageUserReadVO) ? msg.groupMessageUserReadVO : []
      };
      return mappedMessage;
    };
    const handleFileSelected = async (fileInfo) => {
      var _a, _b;
      if (!fileInfo || typeof fileInfo !== "object") {
        uni.showToast({
          title: "æ–‡ä»¶ä¿¡æ¯æ— æ•ˆï¼Œè¯·é‡è¯•",
          icon: "none"
        });
        return;
      }
      if (!fileInfo.path) {
        uni.showToast({
          title: "æ–‡ä»¶è·¯å¾„ç¼ºå¤±ï¼Œè¯·é‡è¯•",
          icon: "none"
        });
        return;
      }
      try {
        const response = await sendFilesToUser({
          files: [fileInfo.path],
          isGroup: chatInfo.value.type === "group",
          isSelfDestruct: chatInfo.value.isBurnAfterReadingMode || false,
          latitude: ((_a = chatInfo.value.currentLocation) == null ? void 0 : _a.latitude) || "0",
          longitude: ((_b = chatInfo.value.currentLocation) == null ? void 0 : _b.longitude) || "0",
          missionId: chatInfo.value.missionId,
          receptionId: chatInfo.value.id,
          voiceMessage: fileInfo.fromVoiceInput || false
        });
        if (response.code === 200) {
          await updateMessageList();
          vue.nextTick(() => {
            scrollToBottom();
          });
        } else {
          throw new Error(response.msg || "å‘é€æ–‡ä»¶æ¶ˆæ¯å¤±è´¥");
        }
      } catch (error) {
        uni.showToast({
          title: "å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•",
          icon: "none"
        });
      }
    };
    const handleMessageDeleted = (messageId) => {
      formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:392", "å¤„ç†æ¶ˆæ¯åˆ é™¤:", messageId);
      const index = list.value.findIndex((msg) => msg.id === messageId);
      if (index !== -1) {
        list.value.splice(index, 1);
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:396", "æ¶ˆæ¯å·²ä»Žåˆ—è¡¨ä¸­åˆ é™¤");
      } else {
        formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:398", "æœªæ‰¾åˆ°è¦åˆ é™¤çš„æ¶ˆæ¯");
      }
    };
    const getCurrentLocation = () => {
      return new Promise((resolve) => {
        uni.getLocation({
          type: "gcj02",
          success: (res) => {
            resolve({
              latitude: res.latitude.toString(),
              longitude: res.longitude.toString()
            });
          },
          fail: () => {
            Toast({
              message: "èŽ·å–ä½ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®",
              type: "fail"
            });
            resolve({
              latitude: "0",
              longitude: "0"
            });
          },
          timeout: 2e3
        });
      });
    };
    formatAppLog("log", "at pages/message/ChatComposables/useMessageHandling.js:425", "æ¶ˆæ¯å¤„ç†æ¨¡å—åˆå§‹åŒ–å®Œæˆ");
    return {
      getCurrentLocation,
      sendMessage,
      handleMessageFailed,
      loadHistoryMessages,
      updateMessageList,
      handleFileSelected,
      handleMessageDeleted
    };
  }
  const throttle = (func, delay) => {
    let lastCall = 0;
    return function(...args) {
      const now2 = (/* @__PURE__ */ new Date()).getTime();
      if (now2 - lastCall < delay)
        return;
      lastCall = now2;
      return func.apply(this, args);
    };
  };
  function useUiInteractions({
    messageListRef,
    isScrolledToBottom,
    showScrollToBottom,
    showNewMessageTip,
    hasNewMessages,
    isLoading,
    currentFrom,
    currentTo,
    loadHistoryMessages,
    showAttachMenu,
    hasMoreMessages
  }) {
    const messageList = vue.ref([]);
    const isNearTop = vue.ref(false);
    const scrollThreshold = 100;
    const isInitialized = vue.ref(false);
    const loadMoreMessages = async () => {
      formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:33", "å¼€å§‹åŠ è½½æ›´å¤šæ¶ˆæ¯");
      if (!hasMoreMessages.value || !messageListRef.value || isLoading.value) {
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:35", "æ— æ³•åŠ è½½æ›´å¤šæ¶ˆæ¯:", {
          hasMoreMessages: hasMoreMessages.value,
          messageListRef: !!messageListRef.value,
          isLoading: isLoading.value
        });
        return;
      }
      isLoading.value = true;
      try {
        const oldScrollHeight = messageListRef.value.scrollHeight;
        await loadHistoryMessages(true, currentFrom.value - 10, currentFrom.value);
        await vue.nextTick();
        const newScrollHeight = messageListRef.value.scrollHeight;
        const heightDifference = newScrollHeight - oldScrollHeight;
        if (heightDifference > 0) {
          messageListRef.value.scrollTop = heightDifference;
        }
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:55", "åŠ è½½æ›´å¤šæ¶ˆæ¯å®Œæˆ:", { é«˜åº¦å·®: heightDifference });
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:57", "åŠ è½½æ›´å¤šæ¶ˆæ¯æ—¶å‡ºé”™:", error);
      } finally {
        isLoading.value = false;
      }
    };
    const onScroll = throttle(() => {
      if (!messageListRef.value || !isInitialized.value)
        return;
      const { scrollTop, scrollHeight, clientHeight } = messageListRef.value;
      const isNearTopNow = scrollTop < scrollThreshold;
      const isNearBottomNow = scrollTop + clientHeight >= scrollHeight - 20;
      formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:71", "æ»šåŠ¨è¯¦æƒ…:", {
        æ»šåŠ¨ä½ç½®: scrollTop,
        å†…å®¹é«˜åº¦: scrollHeight,
        å¯è§†åŒºåŸŸé«˜åº¦: clientHeight,
        è·ç¦»é¡¶éƒ¨é˜ˆå€¼: scrollThreshold,
        æ˜¯å¦æŽ¥è¿‘é¡¶éƒ¨: isNearTopNow,
        æ˜¯å¦æŽ¥è¿‘åº•éƒ¨: isNearBottomNow,
        ä¹‹å‰æ˜¯å¦æŽ¥è¿‘é¡¶éƒ¨: isNearTop.value,
        ä¹‹å‰æ˜¯å¦æ»šåŠ¨åˆ°åº•éƒ¨: isScrolledToBottom.value
      });
      if (isNearTopNow !== isNearTop.value) {
        isNearTop.value = isNearTopNow;
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:84", "æŽ¥è¿‘é¡¶éƒ¨çŠ¶æ€æ”¹å˜:", isNearTopNow);
        if (isNearTopNow && hasMoreMessages.value && !isLoading.value) {
          formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:86", "è§¦å‘åŠ è½½æ›´å¤šæ¶ˆæ¯");
          loadMoreMessages();
        }
      }
      if (isNearBottomNow !== isScrolledToBottom.value) {
        isScrolledToBottom.value = isNearBottomNow;
        formatAppLog("log", "at pages/message/ChatComposables/useUiInteractions.js:93", "æŽ¥è¿‘åº•éƒ¨çŠ¶æ€æ”¹å˜:", isNearBottomNow);
        if (isNearBottomNow) {
          showScrollToBottom.value = false;
          showNewMessageTip.value = false;
          hasNewMessages.value = false;
        }
      }
    }, 200);
    const scrollToBottom = () => {
      if (messageListRef.value) {
        messageListRef.value.scrollTop = messageListRef.value.scrollHeight;
        showScrollToBottom.value = false;
        showNewMessageTip.value = false;
        hasNewMessages.value = false;
        isScrolledToBottom.value = true;
      }
    };
    const initialize = () => {
      if (messageListRef.value) {
        isInitialized.value = true;
        messageListRef.value.addEventListener("scroll", onScroll);
        scrollToBottom();
      }
    };
    const cleanup = () => {
      if (messageListRef.value) {
        messageListRef.value.removeEventListener("scroll", onScroll);
      }
    };
    vue.onMounted(() => {
      vue.nextTick(() => {
        initialize();
      });
    });
    vue.watch(messageList, () => {
      vue.nextTick(() => {
        if (isScrolledToBottom.value) {
          scrollToBottom();
        }
      });
    });
    return {
      messageList,
      loadMoreMessages,
      scrollToBottom,
      onScroll,
      isNearTop,
      initialize,
      cleanup
    };
  }
  function useVideoCallHandling(vm) {
    return {
      // æ‰“å¼€è§†é¢‘é€šè¯é¡µé¢
      openVideoPage(action) {
        uni.navigateTo({
          url: `/pages/message/video-call?calleePeerId=${vm.chatInfo.id}`
        });
      },
      // æ‹’ç»è§†é¢‘é€šè¯
      rejectVideoCall() {
        formatAppLog("log", "at pages/message/ChatComposables/useVideoCallHandling.js:13", "æ‹’ç»è§†é¢‘é€šè¯ï¼ŒpeerStore çŠ¶æ€:", vm.peerStore);
        vm.peerStore.dataConnection.send({
          instruction: vm.peerStore.instruction.reject
        });
        vm.peerStore.dataConnection = void 0;
        vm.peerStore.activateNotification = false;
      },
      // æŽ¥å—è§†é¢‘é€šè¯
      acceptVideoCall() {
        formatAppLog("log", "at pages/message/ChatComposables/useVideoCallHandling.js:23", "æŽ¥å—è§†é¢‘é€šè¯ï¼ŒpeerStore çŠ¶æ€:", vm.peerStore);
        vm.peerStore.activateNotification = false;
        uni.showLoading({
          title: "ç­‰å¾…å¯¹æ–¹è¿žæŽ¥...",
          mask: true
        });
        let cancel = watch(() => vm.peerStore.mediaConnection, (newValue) => {
          if (newValue) {
            uni.hideLoading();
            cancel();
            uni.navigateTo({
              url: "/pages/message/video-answer"
            });
          }
        }, { immediate: true });
        vm.peerStore.dataConnection.send({
          instruction: vm.peerStore.instruction.accept
        });
      }
    };
  }
  function useSelfDestructMessageHandling(vm) {
    const deleteMessage = (messageId) => {
      const index = vm.list.findIndex((msg) => msg.id === messageId);
      if (index !== -1) {
        vm.list.splice(index, 1);
      }
    };
    const handleSelfDestructMessage = async (message) => {
      try {
        const decryptedMessage = decryptMessage(message);
        await processMessage(decryptedMessage);
        if (message.userType === "other" && message.selfDestruct) {
          await readSelfDestructMessage({
            isGroup: vm.chatInfo.type === "group",
            messageId: message.id,
            messageType: message.messageType
          });
          setTimeout(() => {
            deleteMessage(message.id);
          }, 1e4);
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useSelfDestructMessageHandling.js:35", "è‡ªæ¯æ¶ˆæ¯å¤„ç†é”™è¯¯:", { æ¶ˆæ¯ID: message.id, é”™è¯¯: error.message });
      }
    };
    const decryptMessage = (message) => {
      return "å·²è§£å¯†çš„æ¶ˆæ¯";
    };
    const processMessage = async (decryptedMessage) => {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    };
    return {
      handleSelfDestructMessage
    };
  }
  function useChatDataManagement(chatInfo, list) {
    const userStore = useUserStore();
    const groupStore = useGroupStore();
    useWebSocket();
    vue.ref(false);
    vue.ref(false);
    const isLoadingGroupInfo = vue.ref(false);
    const missionId = vue.ref(userStore.state.missionId[0]);
    const getCacheKey = () => `chat_${chatInfo.value.type}_${chatInfo.value.id}`;
    const loadCachedData = () => {
      const cacheKey = getCacheKey();
      const cachedData = uni.getStorageSync(cacheKey);
      return cachedData ? JSON.parse(cachedData) : null;
    };
    const saveCachedData = (data) => {
      const cacheKey = getCacheKey();
      uni.setStorageSync(cacheKey, JSON.stringify(data));
    };
    const fetchAndUpdateData = async () => {
      formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:40", "å¼€å§‹èŽ·å–å¹¶æ›´æ–°æ•°æ®:", {
        èŠå¤©ç±»åž‹: chatInfo.value.type,
        ç¾¤ç»„ä¿¡æ¯: groupStore.state.groupInfo,
        ä»»åŠ¡ID: missionId.value
      });
      try {
        if (chatInfo.value.type === "group") {
          await loadAndCacheGroupMembers(chatInfo.value.id);
        }
        let response;
        if (chatInfo.value.type === "group") {
          response = await getGroupChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            missionId: missionId.value
          });
        } else {
          response = await getHistoryChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            missionId: chatInfo.value.missionId,
            relatedMissionId: missionId.value
          });
        }
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:69", "èŽ·å–æ¶ˆæ¯å“åº”:", response);
        if (response.code === 200) {
          let newMessages;
          if (chatInfo.value.type === "group") {
            newMessages = await Promise.all(response.data.groupMessageVOS.reverse().map((msg) => mapGroupMessage(msg)));
          } else {
            newMessages = await Promise.all(response.data.messageVOList.reverse().map((msg) => mapPrivateMessage(msg)));
          }
          formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:79", "æ–°æ¶ˆæ¯åˆ—è¡¨:", newMessages);
          list.value = newMessages;
          saveCachedData(newMessages);
          return newMessages;
        } else {
          formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:84", "èŽ·å–æ¶ˆæ¯å¤±è´¥:", response.msg);
        }
      } catch (error) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:87", "èŽ·å–æ–°æ¶ˆæ¯å‡ºé”™:", error);
      }
    };
    const mapPrivateMessage = async (msg) => {
      let content = msg.content || msg.message;
      let type = (msg.type || msg.messageType || "").toLowerCase();
      if (!type) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:98", "è­¦å‘Š: æ¶ˆæ¯ç±»åž‹æœªå®šä¹‰", msg);
        type = "unknown";
      }
      if (type === "position") {
        try {
          content = JSON.parse(content);
          type = "location";
        } catch (e2) {
          formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:107", "è§£æžä½ç½®æ•°æ®å¤±è´¥:", e2);
        }
      } else if (type === "image") {
        content = msg.previewUrl || content;
      } else if (type === "text" && (content || "").toLowerCase().endsWith(".txt")) {
        type = "file";
      } else if (type === "audio" || type === "video" || type === "voice_message") {
        content = msg.previewUrl || content;
      }
      const userInfo = await loadAndCacheUserInfo(msg.senderId);
      const avatarUrl = userInfo ? userInfo.avatarUrl : msg.senderId === chatInfo.value.id ? chatInfo.value.avatar && chatInfo.value.avatar[0] ? chatInfo.value.avatar[0] : "" : chatInfo.value._selfAvatar || "";
      const mappedMessage = {
        id: msg.id,
        content,
        userType: msg.senderId === chatInfo.value.id ? "other" : "self",
        avatar: avatarUrl,
        timestamp: new Date(msg.date || msg.sendTime),
        type,
        isRead: msg.isRead,
        messageType: msg.type || msg.messageType,
        selfDestruct: msg.selfDestruct
      };
      return mappedMessage;
    };
    const mapGroupMessage = (msg) => {
      formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:144", "å¼€å§‹æ˜ å°„ç¾¤èŠæ¶ˆæ¯:", msg);
      let content = msg.message || msg.content;
      let type = (msg.messageType || msg.type || "").toLowerCase();
      if (!type) {
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:149", "è­¦å‘Š: ç¾¤èŠæ¶ˆæ¯ç±»åž‹æœªå®šä¹‰", msg);
        type = "unknown";
      }
      if (type === "position") {
        try {
          content = JSON.parse(content);
          type = "location";
        } catch (e2) {
          formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:158", "è§£æžä½ç½®æ•°æ®å¤±è´¥:", e2);
        }
      } else if (type === "image") {
        content = msg.previewUrl || content;
      } else if (type === "text" && (content || "").toLowerCase().endsWith(".txt")) {
        type = "file";
      } else if (type === "audio" || type === "video" || type === "voice_message") {
        content = msg.previewUrl || content;
      }
      const groupInfo = groupStore.state.groupInfo;
      let avatar = chatInfo.value._selfAvatar;
      let senderName = "æœªçŸ¥ç”¨æˆ·";
      if (groupInfo && groupInfo.groupMembers) {
        const sender = groupInfo.groupMembers.find((member) => member.userId === msg.senderId);
        if (sender) {
          avatar = sender.avatarUrl || "";
          senderName = sender.userName || "æœªçŸ¥ç”¨æˆ·";
        }
      } else {
        formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:180", "ç¾¤ç»„ä¿¡æ¯ä¸å®Œæ•´æˆ–æœªæ‰¾åˆ°å‘é€è€…");
      }
      const mappedMessage = {
        id: msg.id,
        content,
        userType: userStore.state.id === msg.senderId ? "self" : "other",
        avatar,
        timestamp: new Date(msg.sendTime || msg.date),
        type,
        isRead: Array.isArray(msg.groupMessageUserReadVO) && msg.groupMessageUserReadVO.some((user) => user.userId === chatInfo.value.id && user.isRead),
        messageType: msg.messageType || msg.type,
        selfDestruct: msg.selfDestruct || msg.isSelfDestruct,
        senderName,
        senderId: msg.senderId,
        groupMessageUserReadVO: Array.isArray(msg.groupMessageUserReadVO) ? msg.groupMessageUserReadVO : []
      };
      formatAppLog("log", "at pages/message/ChatComposables/useChatDataManagement.js:200", "ç¾¤èŠæ¶ˆæ¯æ˜ å°„ç»“æžœ:", mappedMessage);
      return mappedMessage;
    };
    const loadAndCacheGroupMembers = async (groupId) => {
      if (isLoadingGroupInfo.value) {
        return;
      }
      isLoadingGroupInfo.value = true;
      const cacheKey = `group_members_${groupId}`;
      const cachedMembers = uni.getStorageSync(cacheKey);
      if (cachedMembers) {
        groupStore.setGroupInfo(JSON.parse(cachedMembers));
      }
      try {
        const response = await getGroupBasicInfo(groupId);
        if (response.code === 200) {
          const groupInfo = {
            id: response.data.id,
            groupName: response.data.groupName,
            groupMembers: response.data.groupMembers
          };
          groupStore.setGroupInfo(groupInfo);
          uni.setStorageSync(cacheKey, JSON.stringify(groupInfo));
          return groupInfo;
        } else {
          return cachedMembers ? JSON.parse(cachedMembers) : null;
        }
      } catch (error) {
        formatAppLog("error", "at pages/message/ChatComposables/useChatDataManagement.js:233", "åŠ è½½ç¾¤ç»„æˆå‘˜ä¿¡æ¯å¤±è´¥:", error);
        return cachedMembers ? JSON.parse(cachedMembers) : null;
      } finally {
        isLoadingGroupInfo.value = false;
      }
    };
    const loadAndCacheUserInfo = async (userId) => {
      const cacheKey = `user_info_${userId}`;
      const cachedUserInfo = uni.getStorageSync(cacheKey);
      if (cachedUserInfo) {
        return JSON.parse(cachedUserInfo);
      }
      try {
        const response = await getUserBasicInfo(userId);
        if (response.code === 200) {
          const userInfo = response.data;
          uni.setStorageSync(cacheKey, JSON.stringify(userInfo));
          return userInfo;
        } else {
          return null;
        }
      } catch (error) {
        formatAppLog("error", "at pages/message/ChatComposables/useChatDataManagement.js:259", "åŠ è½½ç”¨æˆ·ä¿¡æ¯å¤±è´¥:", error);
        return null;
      }
    };
    const insertNewMessage = (newMessage) => {
      list.value.push(newMessage);
      saveCachedData(list.value);
    };
    const handleWebSocketMessage = async (message) => {
      if (message.sessionId === chatInfo.value.id || message.senderId === chatInfo.value.id) {
        if (!message.type) {
          return;
        }
        const isGroupMessage = chatInfo.value.type === "group";
        let mappedMessage;
        if (isGroupMessage) {
          const messageWithReadInfo = {
            ...message,
            groupMessageUserReadVO: message.groupMessageUserReadVO || [],
            messageType: message.type,
            sendTime: message.date
          };
          mappedMessage = mapGroupMessage(messageWithReadInfo);
        } else {
          mappedMessage = await mapPrivateMessage(message);
        }
        if (mappedMessage) {
          list.value.push(mappedMessage);
          saveCachedData(list.value);
        }
      }
    };
    const initWebSocketListener = () => {
      uni.$on("newChatMessage", handleWebSocketMessage);
    };
    const cleanupWebSocketListener = () => {
      uni.$off("newChatMessage", handleWebSocketMessage);
    };
    const updateMessageReadStatus = (messageId, isRead) => {
      const messageIndex = list.value.findIndex((msg) => msg.id === messageId);
      if (messageIndex !== -1) {
        list.value[messageIndex].isRead = isRead;
        saveCachedData(list.value);
      }
    };
    const deleteMessage = (messageId) => {
      const messageIndex = list.value.findIndex((msg) => msg.id === messageId);
      if (messageIndex !== -1) {
        list.value.splice(messageIndex, 1);
        saveCachedData(list.value);
      }
    };
    const updateMessageContent = (messageId, newContent) => {
      const messageIndex = list.value.findIndex((msg) => msg.id === messageId);
      if (messageIndex !== -1) {
        list.value[messageIndex].content = newContent;
        saveCachedData(list.value);
      }
    };
    const loadMoreHistoryMessages = async (oldestMessageId) => {
      try {
        let response;
        if (chatInfo.value.type === "group") {
          response = await getGroupChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            lastMessageId: oldestMessageId
          });
        } else {
          response = await getHistoryChatMessages({
            opponentId: chatInfo.value.id,
            from: 0,
            to: 20,
            missionId: chatInfo.value.missionId,
            lastMessageId: oldestMessageId,
            relatedMissionId: missionId.value
          });
        }
        if (response.code === 200) {
          let olderMessages;
          if (chatInfo.value.type === "group") {
            olderMessages = await Promise.all(response.data.groupMessageVOS.reverse().map((msg) => mapGroupMessage(msg)));
          } else {
            olderMessages = await Promise.all(response.data.messageVOList.reverse().map((msg) => mapPrivateMessage(msg)));
          }
          list.value = [...olderMessages, ...list.value];
          saveCachedData(list.value);
          return olderMessages;
        }
      } catch (error) {
        formatAppLog("error", "at pages/message/ChatComposables/useChatDataManagement.js:372", "åŠ è½½æ›´å¤šåŽ†å²æ¶ˆæ¯å¤±è´¥:", error);
      }
    };
    return {
      loadCachedData,
      saveCachedData,
      fetchAndUpdateData,
      loadAndCacheGroupMembers,
      isLoadingGroupInfo,
      insertNewMessage,
      handleWebSocketMessage,
      initWebSocketListener,
      cleanupWebSocketListener,
      loadAndCacheUserInfo,
      updateMessageReadStatus,
      deleteMessage,
      updateMessageContent,
      loadMoreHistoryMessages
    };
  }
  const _sfc_main$h = {
    name: "Chat",
    components: {
      ChatHeader,
      MessageList,
      ChatInputArea,
      ScrollToBottomButton,
      LoadingAnimation: LoadingAnimation$1
    },
    setup() {
      const chatInfo = vue.ref({
        id: "",
        name: "",
        avatar: "",
        type: "single",
        missionId: "",
        isBurnAfterReadingMode: false
      });
      const list = vue.ref([]);
      const showAttachMenu = vue.ref(false);
      const showScrollToBottom = vue.ref(false);
      const showNewMessageTip = vue.ref(false);
      const hasNewMessages = vue.ref(false);
      const isScrolledToBottom = vue.ref(true);
      const currentFrom = vue.ref(0);
      const currentTo = vue.ref(10);
      const hasMoreMessages = vue.ref(true);
      const isLoading = vue.ref(false);
      const peerStore = usePeerStore();
      const friendStore = useFriendStore();
      useUserStore();
      const isBurnAfterReadingMode = vue.ref(false);
      const messageListRef = vue.ref(null);
      const chatInputAreaRef = vue.ref(null);
      const {
        goBack,
        setupChatInfo
      } = useChatInitialization();
      const {
        sendMessage,
        handleMessageFailed,
        loadHistoryMessages,
        updateMessageList,
        handleFileSelected,
        handleMessageDeleted
      } = useMessageHandling(chatInfo, list, currentFrom, currentTo, hasMoreMessages, () => scrollToBottom());
      const {
        handleAttachment,
        handleOverlayClick,
        scrollToBottom: originalScrollToBottom,
        // Rename to avoid conflict
        onScroll,
        loadMoreMessages,
        toggleBurnAfterReadingMode
      } = useUiInteractions({
        messageListRef,
        isScrolledToBottom,
        showScrollToBottom,
        showNewMessageTip,
        hasNewMessages,
        isLoading,
        currentFrom,
        currentTo,
        loadHistoryMessages,
        showAttachMenu,
        hasMoreMessages
      });
      const {
        openVideoPage,
        acceptVideoCall,
        rejectVideoCall
      } = useVideoCallHandling();
      const {
        handleSelfDestructMessage
      } = useSelfDestructMessageHandling();
      const {
        loadCachedData,
        saveCachedData,
        fetchAndUpdateData,
        loadAndCacheGroupMembers,
        initWebSocketListener,
        cleanupWebSocketListener
      } = useChatDataManagement(chatInfo, list);
      const isInitialLoading = vue.ref(true);
      const hasCachedMessages = vue.ref(false);
      const initializeChat = async () => {
        formatAppLog("log", "at pages/message/chat.vue:199", "å¼€å§‹åˆå§‹åŒ–èŠå¤©");
        if (chatInfo.value && chatInfo.value.id) {
          isInitialLoading.value = true;
          formatAppLog("log", "at pages/message/chat.vue:202", "å°è¯•åŠ è½½ç¼“å­˜æ•°æ®");
          const cachedData = await loadCachedData();
          if (cachedData) {
            formatAppLog("log", "at pages/message/chat.vue:206", "æ‰¾åˆ°ç¼“å­˜æ•°æ®ï¼Œé•¿åº¦:", cachedData.length);
            hasCachedMessages.value = true;
            list.value = cachedData;
            vue.nextTick(() => {
              scrollToBottom();
              formatAppLog("log", "at pages/message/chat.vue:211", "ä½¿ç”¨ç¼“å­˜æ•°æ®åŽæ»šåŠ¨åˆ°åº•éƒ¨");
            });
          } else {
            formatAppLog("log", "at pages/message/chat.vue:214", "æ²¡æœ‰æ‰¾åˆ°ç¼“å­˜æ•°æ®");
            hasCachedMessages.value = false;
          }
          if (chatInfo.value.type === "group") {
            formatAppLog("log", "at pages/message/chat.vue:219", "èŽ·å–ç¾¤åŸºæœ¬ä¿¡æ¯");
            await loadAndCacheGroupMembers(chatInfo.value.id);
          }
          formatAppLog("log", "at pages/message/chat.vue:223", "å¼€å§‹èŽ·å–æœ€æ–°æ¶ˆæ¯");
          try {
            const newMessages = await fetchAndUpdateData();
            if (newMessages) {
              list.value = newMessages;
              vue.nextTick(() => {
                scrollToBottom();
                formatAppLog("log", "at pages/message/chat.vue:230", "åŠ è½½æ–°æ¶ˆæ¯åŽæ»šåŠ¨åˆ°åº•éƒ¨");
              });
            }
          } catch (error) {
            formatAppLog("log", "at pages/message/chat.vue:234", "èŽ·å–æœ€æ–°æ¶ˆæ¯å¤±è´¥:", error);
            uni.showToast({
              title: "åŠ è½½æ¶ˆæ¯å¤±è´¥ï¼Œè¯·é‡è¯•",
              icon: "none"
            });
          }
          isInitialLoading.value = false;
          formatAppLog("log", "at pages/message/chat.vue:242", "åˆå§‹åŠ è½½å®Œæˆï¼ŒisInitialLoading è®¾ç½®ä¸º false");
          formatAppLog("log", "at pages/message/chat.vue:244", "èŠå¤©åˆå§‹åŒ–å®Œæˆ:", {
            ç¼“å­˜æ•°æ®: !!cachedData,
            ç¼“å­˜æ•°æ®é•¿åº¦: cachedData ? cachedData.length : 0,
            åŽ†å²æ¶ˆæ¯é•¿åº¦: list.value.length
          });
        } else {
          formatAppLog("log", "at pages/message/chat.vue:250", "èŠå¤©ä¿¡æ¯æ— æ•ˆï¼Œæ— æ³•åˆå§‹åŒ–");
          isInitialLoading.value = false;
        }
      };
      const fetchLocation = () => {
        uni.getLocation({
          type: "gcj02",
          success: (res) => {
            currentLocation.value = {
              latitude: res.latitude.toString(),
              longitude: res.longitude.toString()
            };
          },
          fail: () => {
            currentLocation.value = { latitude: "0", longitude: "0" };
          },
          timeout: 1e3
        });
      };
      const handleBurnAfterReadingToggle = (isActive) => {
        chatInfo.value.isBurnAfterReadingMode = isActive;
        formatAppLog("log", "at pages/message/chat.vue:274", "é˜…åŽå³ç„šæ¨¡å¼åˆ‡æ¢:", isActive);
      };
      vue.watch(chatInfo, async (newChatInfo) => {
        formatAppLog("log", "at pages/message/chat.vue:279", "èŠå¤©ä¿¡æ¯å˜åŒ–:", newChatInfo);
        if (newChatInfo && newChatInfo.id) {
          await initializeChat();
        }
      }, { deep: true, immediate: true });
      vue.onMounted(() => {
        formatAppLog("log", "at pages/message/chat.vue:286", "èŠå¤©ç»„ä»¶æŒ‚è½½");
        const pages2 = getCurrentPages();
        const currentPage = pages2[pages2.length - 1];
        let eventChannel;
        const query = uni.getStorageSync("chatQuery");
        if (currentPage && currentPage.$getAppWebview) {
          eventChannel = currentPage.$getAppWebview().eventChannel;
        } else if (currentPage && currentPage.getOpenerEventChannel) {
          eventChannel = currentPage.getOpenerEventChannel();
        } else if (uni && uni.getEnterOptionsSync) {
          const enterOptions = uni.getEnterOptionsSync();
          eventChannel = enterOptions.eventChannel;
        }
        const initializeChatFromData = (data) => {
          formatAppLog("log", "at pages/message/chat.vue:303", "åˆå§‹åŒ–èŠå¤©æ•°æ®:", data);
          if (data && data.chatInfo) {
            chatInfo.value = {
              ...chatInfo.value,
              ...data.chatInfo
            };
            formatAppLog("log", "at pages/message/chat.vue:309", "ä½¿ç”¨æŽ¥æ”¶åˆ°çš„èŠå¤©ä¿¡æ¯åˆå§‹åŒ–èŠå¤©");
            initializeChat();
          } else {
            formatAppLog("log", "at pages/message/chat.vue:312", "æŽ¥æ”¶åˆ°çš„èŠå¤©ä¿¡æ¯æ— æ•ˆ");
            isInitialLoading.value = false;
            uni.showToast({
              title: "æ— æ³•åŠ è½½èŠå¤©ä¿¡æ¯",
              icon: "none"
            });
            setTimeout(() => {
              formatAppLog("log", "at pages/message/chat.vue:319", "æ— æ³•åŠ ï¿½ï¿½ï¿½èŠå¤©ä¿¡æ¯ï¼Œè¿”å›žä¸Šä¸€é¡µ");
              uni.navigateBack();
            }, 2e3);
          }
        };
        if (eventChannel) {
          formatAppLog("log", "at pages/message/chat.vue:326", "æ‰¾åˆ°äº‹ä»¶é€šé“ï¼Œè®¾ç½®èŠå¤©ä¿¡æ¯");
          eventChannel.on("chatInfo", initializeChatFromData);
        } else if (query) {
          formatAppLog("log", "at pages/message/chat.vue:329", "ä»Žå­˜å‚¨ä¸­æ‰¾åˆ°èŠå¤©ä¿¡æ¯");
          const parsedQuery = JSON.parse(query);
          initializeChatFromData({ chatInfo: parsedQuery });
        } else {
          formatAppLog("log", "at pages/message/chat.vue:333", "æ— æ³•åŠ è½½èŠå¤©ä¿¡æ¯");
          isInitialLoading.value = false;
          uni.showToast({
            title: "æ— æ³•åŠ è½½èŠå¤©ä¿¡æ¯",
            icon: "none"
          });
          setTimeout(() => {
            formatAppLog("log", "at pages/message/chat.vue:340", "æ— æ³•åŠ è½½èŠå¤©ä¿¡æ¯ï¼Œè¿”å›žä¸Šä¸€é¡µ");
            uni.navigateBack();
          }, 2e3);
        }
        formatAppLog("log", "at pages/message/chat.vue:344", "èŠå¤©ç»„ä»¶æŒ‚è½½å®Œæˆ:", {
          æœ‰äº‹ä»¶é€šé“: !!eventChannel,
          å­˜å‚¨ä¸­æœ‰èŠå¤©ä¿¡æ¯: !!query
        });
        fetchLocation();
        initWebSocketListener();
      });
      vue.onUnmounted(() => {
        cleanupWebSocketListener();
      });
      const handleMessageListClick = (event) => {
        formatAppLog("log", "at pages/message/chat.vue:359", "æ¶ˆæ¯åˆ—è¡¨è¢«ç‚¹å‡»");
        event.stopPropagation();
        showAttachMenu.value = false;
      };
      const handlePageClick = (event) => {
        const chatInputArea = chatInputAreaRef.value;
        if (chatInputArea && chatInputArea.$el && event.target instanceof Node) {
          if (!chatInputArea.$el.contains(event.target)) {
            showAttachMenu.value = false;
          }
        }
      };
      const handleMessageSent = () => {
        formatAppLog("log", "at pages/message/chat.vue:376", "æ¶ˆæ¯å·²å‘é€ï¼Œå‡†å¤‡æ»šåŠ¨åˆ°åº•éƒ¨");
        vue.nextTick(() => {
          if (messageListRef.value) {
            messageListRef.value.scrollToBottom(true);
          }
        });
      };
      const toggleAttachMenu = (value) => {
        formatAppLog("log", "at pages/message/chat.vue:385", "åˆ‡æ¢é™„ä»¶èœå•çŠ¶æ€:", value);
        showAttachMenu.value = value;
      };
      const currentLocation = vue.ref({ latitude: "0", longitude: "0" });
      const scrollToBottom = () => {
        vue.nextTick(() => {
          if (messageListRef.value && messageListRef.value.scrollToBottom) {
            messageListRef.value.scrollToBottom();
          }
        });
      };
      return {
        chatInfo,
        list,
        showAttachMenu,
        showScrollToBottom,
        showNewMessageTip,
        hasNewMessages,
        isScrolledToBottom,
        currentFrom,
        currentTo,
        hasMoreMessages,
        isLoading,
        peerStore,
        friendStore,
        isBurnAfterReadingMode,
        messageListRef,
        goBack,
        sendMessage,
        handleMessageFailed,
        loadHistoryMessages,
        updateMessageList,
        handleFileSelected,
        handleAttachment,
        handleOverlayClick,
        scrollToBottom,
        onScroll,
        loadMoreMessages,
        toggleBurnAfterReadingMode,
        openVideoPage,
        acceptVideoCall,
        rejectVideoCall,
        handleSelfDestructMessage,
        initializeChat,
        handleBurnAfterReadingToggle,
        handleMessageDeleted,
        loadCachedData,
        saveCachedData,
        fetchAndUpdateData,
        loadAndCacheGroupMembers,
        isInitialLoading,
        hasCachedMessages,
        handleMessageListClick,
        handleMessageSent,
        handlePageClick,
        toggleAttachMenu,
        currentLocation,
        chatInputAreaRef
      };
    }
  };
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_ChatHeader = vue.resolveComponent("ChatHeader");
    const _component_MessageList = vue.resolveComponent("MessageList");
    const _component_LoadingAnimation = vue.resolveComponent("LoadingAnimation");
    const _component_ChatInputArea = vue.resolveComponent("ChatInputArea");
    const _component_ScrollToBottomButton = vue.resolveComponent("ScrollToBottomButton");
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "chat-page",
      onClick: _cache[4] || (_cache[4] = vue.withModifiers((...args) => $setup.handlePageClick && $setup.handlePageClick(...args), ["stop"]))
    }, [
      vue.createCommentVNode(" èŠå¤©å¤´éƒ¨ "),
      vue.createVNode(_component_ChatHeader, {
        "chat-info": $setup.chatInfo,
        onGoBack: $setup.goBack
      }, null, 8, ["chat-info", "onGoBack"]),
      vue.createCommentVNode(" æ¶ˆæ¯åˆ—è¡¨ - æ·»åŠ ç‚¹å‡»å¤„ç† "),
      !$setup.isInitialLoading || $setup.hasCachedMessages ? (vue.openBlock(), vue.createBlock(_component_MessageList, {
        key: 0,
        ref: "messageListRef",
        messages: $setup.list,
        "is-group": $setup.chatInfo.type === "group",
        onLoadMore: $setup.loadMoreMessages,
        onScroll: $setup.onScroll,
        onMessageDeleted: $setup.handleMessageDeleted,
        onClick: $setup.handleMessageListClick,
        class: "message-list"
      }, null, 8, ["messages", "is-group", "onLoadMore", "onScroll", "onMessageDeleted", "onClick"])) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" åŠ è½½åŠ¨ç”» "),
      $setup.isInitialLoading && !$setup.hasCachedMessages ? (vue.openBlock(), vue.createBlock(_component_LoadingAnimation, { key: 1 })) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" èŠå¤©è¾“å…¥åŒºåŸŸ "),
      vue.createVNode(_component_ChatInputArea, {
        modelValue: $setup.showAttachMenu,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.showAttachMenu = $event),
        onSendMessage: $setup.sendMessage,
        onMessageFailed: $setup.handleMessageFailed,
        onAttach: $setup.handleAttachment,
        onVideoCall: $setup.openVideoPage,
        onFileSelected: $setup.handleFileSelected,
        onToggleBurnAfterReading: $setup.handleBurnAfterReadingToggle,
        onMessageSent: $setup.handleMessageSent,
        recipientId: $setup.chatInfo && $setup.chatInfo.id || "",
        missionId: $setup.chatInfo && $setup.chatInfo.missionId,
        "initial-burn-after-reading-mode": $setup.chatInfo && $setup.chatInfo.isBurnAfterReadingMode,
        onToggleAttachMenu: $setup.toggleAttachMenu,
        ref: "chatInputAreaRef"
      }, null, 8, ["modelValue", "onSendMessage", "onMessageFailed", "onAttach", "onVideoCall", "onFileSelected", "onToggleBurnAfterReading", "onMessageSent", "recipientId", "missionId", "initial-burn-after-reading-mode", "onToggleAttachMenu"]),
      vue.createCommentVNode(" æ»šåŠ¨åˆ°åº•éƒ¨æŒ‰é’® "),
      vue.createVNode(_component_ScrollToBottomButton, {
        show: $setup.showScrollToBottom,
        onClick: vue.withModifiers($setup.scrollToBottom, ["stop"])
      }, null, 8, ["show", "onClick"]),
      vue.createCommentVNode(" æ–°æ¶ˆæ¯æç¤º "),
      $setup.showNewMessageTip ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 2,
        class: "new-message-tip",
        onClick: _cache[1] || (_cache[1] = vue.withModifiers((...args) => $setup.scrollToBottom && $setup.scrollToBottom(...args), ["stop"]))
      }, " æ–°æ¶ˆæ¯ ")) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" æ¥ç”µæé†’ "),
      $setup.peerStore.activateNotification ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 3,
        class: "modal"
      }, [
        vue.createElementVNode("view", null, [
          vue.createElementVNode(
            "text",
            null,
            vue.toDisplayString((_a = $setup.peerStore.dataConnection) == null ? void 0 : _a.peer) + " é‚€è¯·ä½ è§†é¢‘é€šè¯",
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode("view", { class: "modal-content" }, [
          vue.createElementVNode("button", {
            onClick: _cache[2] || (_cache[2] = (...args) => $setup.acceptVideoCall && $setup.acceptVideoCall(...args)),
            type: "default"
          }, "æŽ¥å¬"),
          vue.createElementVNode("button", {
            onClick: _cache[3] || (_cache[3] = (...args) => $setup.rejectVideoCall && $setup.rejectVideoCall(...args)),
            type: "warn"
          }, "æ‹’ç»")
        ])
      ])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const PagesMessageChat = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$g], ["__scopeId", "data-v-013fa921"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/chat.vue"]]);
  const useContactsStore = defineStore("contacts", {
    state: () => ({
      groupVOList: [],
      // ç¾¤ç»„åˆ—è¡¨
      userInformationVOList: [],
      // ç”¨æˆ·ä¿¡æ¯åˆ—è¡¨
      selectedContact: null,
      // å½“å‰é€‰ä¸­çš„è”ç³»äºº
      isInitialized: false,
      // æ˜¯å¦å·²åˆå§‹åŒ–
      contactsUpdateCounter: 0
      // è”ç³»äººæ›´æ–°è®¡æ•°å™¨
    }),
    actions: {
      // è®¾ç½®ç¾¤ç»„åˆ—è¡¨
      setGroupVOList(groupVOList) {
        this.groupVOList = groupVOList;
      },
      // è®¾ç½®ç”¨æˆ·ä¿¡æ¯åˆ—è¡¨
      setUserInformationVOList(userInformationVOList) {
        this.userInformationVOList = userInformationVOList;
      },
      // è®¾ç½®é€‰ä¸­çš„è”ç³»äºº
      setSelectedContact(contact) {
        this.selectedContact = contact;
      },
      // è®¾ç½®åˆå§‹åŒ–çŠ¶æ€
      setInitialized(value) {
        this.isInitialized = value;
      },
      // å¢žåŠ è”ç³»äººæ›´æ–°è®¡æ•°å™¨
      incrementContactsUpdateCounter() {
        this.contactsUpdateCounter++;
        formatAppLog("log", "at pages/contacts/store/contactsStore.js:32", "è”ç³»äººæ›´æ–°è®¡æ•°å™¨å·²å¢žåŠ ");
      }
    }
  });
  const _sfc_main$g = {
    name: "GroupChatList",
    props: {
      // ç¾¤èŠåˆ—è¡¨æ•°æ®
      groupVOList: {
        type: Array,
        required: true
      }
    },
    setup(props, { emit }) {
      const groupList = vue.ref(props.groupVOList);
      const expanded = vue.ref(true);
      const toggleGroup = () => {
        expanded.value = !expanded.value;
      };
      const enterGroupChat = (group) => {
        emit("enter-group-chat", group);
      };
      return {
        groupList,
        expanded,
        toggleGroup,
        enterGroupChat
      };
    }
  };
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "group-chat-list" }, [
      vue.createElementVNode("view", { class: "group" }, [
        vue.createElementVNode("view", {
          class: "group-header",
          onClick: _cache[0] || (_cache[0] = (...args) => $setup.toggleGroup && $setup.toggleGroup(...args))
        }, [
          vue.createElementVNode(
            "text",
            { class: "group-title" },
            "ç¾¤èŠ (" + vue.toDisplayString($setup.groupList.length) + "ä¸ª)",
            1
            /* TEXT */
          ),
          vue.createElementVNode(
            "text",
            {
              class: vue.normalizeClass(["group-arrow", { "expanded": $setup.expanded }])
            },
            "â€º",
            2
            /* CLASS */
          )
        ]),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["group-content", { "expanded": $setup.expanded }])
          },
          [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.groupList, (group) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  key: group.id,
                  class: "contact-item",
                  onClick: ($event) => $setup.enterGroupChat(group)
                }, [
                  vue.createElementVNode("image", {
                    src: group.avatar || "/static/default-group-avatar.png",
                    class: "avatar",
                    mode: "aspectFill"
                  }, null, 8, ["src"]),
                  vue.createElementVNode("view", { class: "contact-info" }, [
                    vue.createElementVNode(
                      "text",
                      { class: "contact-name" },
                      vue.toDisplayString(group.groupName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "text",
                      { class: "contact-title" },
                      vue.toDisplayString(group.groupMembers.length) + "äºº",
                      1
                      /* TEXT */
                    )
                  ])
                ], 8, ["onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        )
      ])
    ]);
  }
  const GroupChatList = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f], ["__scopeId", "data-v-382e9af6"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/components/Contacts/GroupChatList.vue"]]);
  const _sfc_main$f = {
    name: "UserList",
    props: {
      // ç”¨æˆ·åˆ—è¡¨æ•°æ®
      userInformationVOList: {
        type: Array,
        required: true
      }
    },
    setup(props, { emit }) {
      const departmentList = vue.ref([]);
      const initDepartmentList = () => {
        const departments = {};
        props.userInformationVOList.forEach((user) => {
          if (!departments[user.departmentName]) {
            departments[user.departmentName] = {
              name: user.departmentName,
              users: [],
              expanded: true
              // é»˜è®¤å±•å¼€
            };
          }
          departments[user.departmentName].users.push(user);
        });
        departmentList.value = Object.values(departments);
      };
      initDepartmentList();
      const toggleGroup = (department) => {
        department.expanded = !department.expanded;
      };
      const selectUser = (user) => {
        emit("select-user", user);
      };
      return {
        departmentList,
        toggleGroup,
        selectUser
      };
    }
  };
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "user-list" }, [
      (vue.openBlock(true), vue.createElementBlock(
        vue.Fragment,
        null,
        vue.renderList($setup.departmentList, (department) => {
          return vue.openBlock(), vue.createElementBlock("view", {
            key: department.name,
            class: "group"
          }, [
            vue.createElementVNode("view", {
              class: "group-header",
              onClick: ($event) => $setup.toggleGroup(department)
            }, [
              vue.createElementVNode(
                "text",
                { class: "group-title" },
                vue.toDisplayString(department.name) + " (" + vue.toDisplayString(department.users.length) + "äºº)",
                1
                /* TEXT */
              ),
              vue.createElementVNode(
                "text",
                {
                  class: vue.normalizeClass(["group-arrow", { "expanded": department.expanded }])
                },
                "â€º",
                2
                /* CLASS */
              )
            ], 8, ["onClick"]),
            vue.createElementVNode(
              "view",
              {
                class: vue.normalizeClass(["group-content", { "expanded": department.expanded }])
              },
              [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(department.users, (user) => {
                    return vue.openBlock(), vue.createElementBlock("view", {
                      key: user.id,
                      class: "contact-item",
                      onClick: ($event) => $setup.selectUser(user)
                    }, [
                      vue.createElementVNode("image", {
                        src: user.avatarUrl || "/static/default-avatar.png",
                        class: "avatar",
                        mode: "aspectFill"
                      }, null, 8, ["src"]),
                      vue.createElementVNode("view", { class: "contact-info" }, [
                        vue.createElementVNode(
                          "text",
                          { class: "contact-name" },
                          vue.toDisplayString(user.name),
                          1
                          /* TEXT */
                        ),
                        vue.createElementVNode(
                          "text",
                          { class: "contact-title" },
                          vue.toDisplayString(user.departmentName || "æˆå‘˜"),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createCommentVNode(" åœ¨çº¿çŠ¶æ€æŒ‡ç¤ºå™¨ "),
                      vue.createElementVNode(
                        "view",
                        {
                          class: vue.normalizeClass(["status-indicator", user.online ? "online" : "offline"])
                        },
                        null,
                        2
                        /* CLASS */
                      )
                    ], 8, ["onClick"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              2
              /* CLASS */
            )
          ]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]);
  }
  const UserList = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e], ["__scopeId", "data-v-e47a5fe3"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/components/Contacts/UserList.vue"]]);
  const _sfc_main$e = {
    name: "Avatar",
    props: {
      src: {
        type: String,
        default: "/static/message/é»˜è®¤å¤´åƒ.png"
      },
      size: {
        type: Number,
        default: 40
      }
    }
  };
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("image", {
      class: "avatar",
      src: $props.src,
      style: vue.normalizeStyle({ width: `${$props.size}px`, height: `${$props.size}px` }),
      mode: "aspectFill"
    }, null, 12, ["src"]);
  }
  const Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d], ["__scopeId", "data-v-148945a0"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/components/shared/Avatar.vue"]]);
  const _sfc_main$d = {
    name: "ContactInfo",
    components: {
      Avatar
    },
    props: {
      contact: {
        type: Object,
        required: true
      }
    }
  };
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_avatar = vue.resolveComponent("avatar");
    return vue.openBlock(), vue.createElementBlock("view", { class: "main-info" }, [
      vue.createElementVNode("view", { class: "profile-section" }, [
        vue.createVNode(_component_avatar, {
          src: $props.contact.avatarUrl,
          size: 65
        }, null, 8, ["src"]),
        vue.createElementVNode("view", { class: "info-section" }, [
          vue.createElementVNode("view", { class: "name-section" }, [
            vue.createElementVNode(
              "text",
              { class: "name" },
              vue.toDisplayString($props.contact.name),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", { class: "badge-section" }, [
              vue.createElementVNode(
                "text",
                { class: "badge" },
                vue.toDisplayString($props.contact.title),
                1
                /* TEXT */
              )
            ])
          ]),
          vue.createElementVNode("view", { class: "details-section" }, [
            vue.createElementVNode("view", { class: "detail-item" }, [
              vue.createElementVNode("text", { class: "detail-label" }, "ç”¨æˆ·å"),
              vue.createElementVNode(
                "text",
                { class: "detail-value" },
                vue.toDisplayString($props.contact.username),
                1
                /* TEXT */
              )
            ]),
            vue.createElementVNode("view", { class: "detail-item" }, [
              vue.createElementVNode("text", { class: "detail-label" }, "è®¾å¤‡IP"),
              vue.createElementVNode(
                "text",
                { class: "detail-value" },
                vue.toDisplayString($props.contact.ip),
                1
                /* TEXT */
              )
            ])
          ])
        ])
      ])
    ]);
  }
  const ContactInfo = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c], ["__scopeId", "data-v-e72bb083"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/components/ContactDetail/ContactInfo.vue"]]);
  const _sfc_main$c = {
    __name: "ContactDetailView",
    setup(__props, { expose: __expose }) {
      __expose();
      const userStore = useUserStore();
      const contact = vue.ref({
        id: "",
        name: "",
        avatarUrl: "",
        departmentName: "",
        online: false,
        missionId: ""
      });
      vue.onMounted(() => {
        const pages2 = getCurrentPages();
        const currentPage = pages2[pages2.length - 1];
        const options = currentPage.$page ? currentPage.$page.options : currentPage.options;
        const { user, missionId: pageMissionId } = options;
        if (user) {
          try {
            const decodedUser = JSON.parse(decodeURIComponent(user));
            contact.value = {
              ...decodedUser,
              missionId: pageMissionId || userStore.state.missionId[0]
            };
            formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:54", "è”ç³»äººè¯¦æƒ…:", contact.value);
          } catch (error) {
            formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:56", "è§£æžç”¨æˆ·æ•°æ®å¤±è´¥:", error);
          }
        } else {
          formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:59", "æœªæŽ¥æ”¶åˆ°ç”¨æˆ·æ•°æ®");
        }
        formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:62", "è”ç³»äººè¯¦æƒ…é¡µé¢å·²åŠ è½½");
      });
      const handleMessage = () => {
        formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:67", "æ­£åœ¨è·³è½¬åˆ°èŠå¤©ç•Œé¢");
        const chatInfo = {
          id: contact.value.id,
          name: contact.value.name,
          avatar: contact.value.avatarUrl,
          type: "single",
          missionId: contact.value.missionId,
          isBurnAfterReadingMode: false
        };
        uni.navigateTo({
          url: "/pages/message/chat",
          success: (res) => {
            if (res.eventChannel && res.eventChannel.emit) {
              res.eventChannel.emit("chatInfo", { chatInfo });
              formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:82", "é€šè¿‡ eventChannel å‘é€ chatInfo");
            } else {
              formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:84", "eventChannel ä¸å¯ç”¨ï¼Œå°†ä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„æ•°æ®");
              uni.setStorageSync("chatQuery", JSON.stringify(chatInfo));
            }
          },
          fail: (error) => {
            formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:89", "è·³è½¬åˆ°èŠå¤©ç•Œé¢å¤±è´¥:", error);
          }
        });
      };
      const handleClearHistory = () => {
        formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:96", "æ­£åœ¨å¤„ç†æ¸…é™¤åŽ†å²");
      };
      const handleDelete = () => {
        formatAppLog("log", "at pages/contacts/components/ContactDetail/ContactDetailView.vue:102", "æ­£åœ¨å¤„ç†åˆ é™¤è”ç³»äºº");
      };
      const __returned__ = { userStore, contact, handleMessage, handleClearHistory, handleDelete, ref: vue.ref, onMounted: vue.onMounted, ContactInfo, get useUserStore() {
        return useUserStore;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "contact-detail-view" }, [
      vue.createCommentVNode(" æ˜¾ç¤ºè”ç³»äººä¿¡æ¯ "),
      vue.createVNode($setup["ContactInfo"], { contact: $setup.contact }, null, 8, ["contact"]),
      vue.createCommentVNode(" æ˜¾ç¤ºéƒ¨é—¨å’Œåœ¨çº¿çŠ¶æ€ "),
      vue.createElementVNode("view", { class: "additional-info" }, [
        vue.createElementVNode(
          "text",
          null,
          "éƒ¨é—¨ï¼š" + vue.toDisplayString($setup.contact.departmentName),
          1
          /* TEXT */
        ),
        vue.createElementVNode(
          "text",
          null,
          "çŠ¶æ€ï¼š" + vue.toDisplayString($setup.contact.online ? "åœ¨çº¿" : "ç¦»çº¿"),
          1
          /* TEXT */
        )
      ]),
      vue.createCommentVNode(" æ“ä½œæŒ‰é’® "),
      vue.createElementVNode("view", { class: "action-buttons" }, [
        vue.createElementVNode("button", { onClick: $setup.handleMessage }, "å‘é€æ¶ˆæ¯"),
        vue.createElementVNode("button", { onClick: $setup.handleClearHistory }, "æ¸…é™¤åŽ†å²"),
        vue.createElementVNode("button", {
          onClick: $setup.handleDelete,
          class: "delete-button"
        }, "åˆ é™¤è”ç³»äºº")
      ])
    ]);
  }
  const PagesContactsComponentsContactDetailContactDetailView = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b], ["__scopeId", "data-v-e5781576"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/components/ContactDetail/ContactDetailView.vue"]]);
  const _imports_0$2 = "/static/message/ç¾¤èŠ.png";
  const _sfc_main$b = {
    name: "DropdownMenu",
    props: {
      visible: {
        type: Boolean,
        default: false
      }
    },
    emits: ["group-chat", "add-friend"],
    setup(props, { emit }) {
      const handleGroupChat = () => {
        emit("group-chat");
      };
      const handleAddFriend = () => {
        emit("add-friend");
      };
      return {
        handleGroupChat,
        handleAddFriend
      };
    }
  };
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
      "div",
      { class: "dropdown-container" },
      [
        vue.createElementVNode("div", { class: "dropdown-menu" }, [
          vue.createElementVNode("div", {
            class: "dropdown-item",
            onClick: _cache[0] || (_cache[0] = (...args) => $setup.handleGroupChat && $setup.handleGroupChat(...args))
          }, [
            vue.createElementVNode("image", {
              src: _imports_0$2,
              class: "item-icon",
              mode: "aspectFit"
            }),
            vue.createElementVNode("text", { class: "item-text" }, "å‘èµ·ç¾¤èŠ")
          ]),
          vue.createCommentVNode(' <div class="dropdown-item" @click="handleAddFriend">\r\n        <image src="/static/message/æ·»åŠ å¥½å‹.png" class="item-icon" mode="aspectFit"></image>\r\n        <text class="item-text">æ·»åŠ æœ‹å‹</text>\r\n      </div> ')
        ])
      ],
      512
      /* NEED_PATCH */
    )), [
      [vue.vShow, $props.visible]
    ]);
  }
  const DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a], ["__scopeId", "data-v-805b46fa"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/components/shared/DropdownMenu.vue"]]);
  const _sfc_main$a = {
    name: "LoadingAnimation"
  };
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "loading-animation" }, [
      vue.createElementVNode("view", { class: "dot" }),
      vue.createElementVNode("view", { class: "dot" }),
      vue.createElementVNode("view", { class: "dot" })
    ]);
  }
  const LoadingAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$9], ["__scopeId", "data-v-a646be00"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/components/shared/LoadingAnimation.vue"]]);
  function useContacts() {
    formatAppLog("log", "at pages/contacts/composables/useContacts.js:8", "useContacts ç»„åˆå¼å‡½æ•°è¢«è°ƒç”¨");
    const contactsStore = useContactsStore();
    const userStore = useUserStore();
    const loading = vue.ref(false);
    const isUpdating = vue.ref(false);
    const showDropdown = vue.ref(false);
    const missionId = vue.computed(() => userStore.state.missionId[0]);
    const groupVOList = vue.computed(() => contactsStore.groupVOList);
    const userInformationVOList = vue.computed(() => contactsStore.userInformationVOList);
    const computedMissionId = vue.computed(() => {
      return Array.isArray(userStore.state.missionId) ? userStore.state.missionId.join(",") : userStore.state.missionId || "";
    });
    async function initContacts() {
      formatAppLog("log", "at pages/contacts/composables/useContacts.js:31", "initContacts å‡½æ•°è¢«è°ƒç”¨");
      if (loading.value)
        return;
      loading.value = true;
      try {
        loadCachedData();
        fetchLatestData();
      } catch (error) {
        formatAppLog("log", "at pages/contacts/composables/useContacts.js:42", "åˆå§‹åŒ–è”ç³»äººæ•°æ®å‡ºé”™:", error);
      } finally {
        loading.value = false;
      }
    }
    function loadCachedData() {
      const cachedData = uni.getStorageSync("contactsData");
      if (cachedData) {
        const parsedData = JSON.parse(cachedData);
        contactsStore.setGroupVOList(parsedData.groupVOList);
        contactsStore.setUserInformationVOList(parsedData.userInformationVOList);
        formatAppLog("log", "at pages/contacts/composables/useContacts.js:55", "å·²åŠ è½½ç¼“å­˜çš„è”ç³»äººæ•°æ®");
      }
    }
    async function fetchLatestData() {
      if (!missionId.value) {
        formatAppLog("log", "at pages/contacts/composables/useContacts.js:62", "ç­‰å¾… missionId è¢«è®¾ç½®");
        return;
      }
      try {
        isUpdating.value = true;
        const response = await getMissionAddressBook(missionId.value);
        if (response.code === 200) {
          const newData = response.data;
          const hasChanges = compareData(newData);
          if (hasChanges) {
            updateData(newData);
            formatAppLog("log", "at pages/contacts/composables/useContacts.js:74", "è”ç³»äººæ•°æ®å·²æ›´æ–°");
          } else {
            formatAppLog("log", "at pages/contacts/composables/useContacts.js:76", "è”ç³»äººæ•°æ®æ— å˜åŒ–");
          }
        } else {
          throw new Error(response.msg || "èŽ·å–é€šè®¯å½•å¤±è´¥");
        }
      } catch (error) {
        formatAppLog("log", "at pages/contacts/composables/useContacts.js:82", "èŽ·å–æœ€æ–°è”ç³»äººæ•°æ®å‡ºé”™:", error);
      } finally {
        isUpdating.value = false;
      }
    }
    function compareData(newData) {
      const oldGroupVOList = contactsStore.groupVOList;
      const oldUserInformationVOList = contactsStore.userInformationVOList;
      return JSON.stringify(newData.groupVOList) !== JSON.stringify(oldGroupVOList) || JSON.stringify(newData.userInformationVOList) !== JSON.stringify(oldUserInformationVOList);
    }
    function updateData(newData) {
      contactsStore.setGroupVOList(newData.groupVOList);
      contactsStore.setUserInformationVOList(newData.userInformationVOList);
      uni.setStorageSync("contactsData", JSON.stringify(newData));
    }
    const toggleDropdown = () => {
      showDropdown.value = !showDropdown.value;
    };
    const handleContainerClick = () => {
      if (showDropdown.value) {
        showDropdown.value = false;
      }
    };
    return {
      loading,
      isUpdating,
      missionId,
      groupVOList,
      userInformationVOList,
      computedMissionId,
      showDropdown,
      initContacts,
      toggleDropdown,
      handleContainerClick
    };
  }
  function useContactNavigation() {
    useUserStore();
    const handleSearch = () => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:7", "æœç´¢æŒ‰é’®è¢«ç‚¹å‡»");
    };
    const handleGroupChat = () => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:11", "å‘èµ·ç¾¤èŠè¢«ç‚¹å‡»");
      uni.navigateTo({
        url: "/pages/contacts/pages/contacts/create-group-chat/index"
      });
    };
    const handleAddFriend = () => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:18", "æ·»åŠ æœ‹å‹è¢«ç‚¹å‡»");
    };
    const enterGroupChat = (group, missionId) => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:22", "æ­£åœ¨è·³è½¬åˆ°ç¾¤èŠç•Œé¢:", group);
      const chatInfo = {
        id: group.id,
        name: group.groupName,
        avatar: group.avatar || "/static/default-group-avatar.png",
        type: "group",
        missionId,
        isBurnAfterReadingMode: false
      };
      uni.navigateTo({
        url: "/pages/message/chat",
        success: (res) => {
          if (res.eventChannel && res.eventChannel.emit) {
            res.eventChannel.emit("chatInfo", { chatInfo });
            formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:37", "é€šè¿‡ eventChannel å‘é€ chatInfo");
          } else {
            formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:39", "eventChannel ä¸å¯ç”¨ï¼Œå°†ä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„æ•°æ®");
            uni.setStorageSync("chatQuery", JSON.stringify(chatInfo));
          }
        },
        fail: (err) => {
          formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:44", "å¯¼èˆªåˆ°èŠå¤©é¡µé¢å¤±è´¥:", err);
        }
      });
    };
    const selectUser = (user, missionId) => {
      formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:50", "é€‰æ‹©ç”¨æˆ·:", user);
      const userString = encodeURIComponent(JSON.stringify(user));
      uni.navigateTo({
        url: `/pages/contacts/components/ContactDetail/ContactDetailView?user=${userString}&missionId=${missionId}`,
        fail: (error) => {
          formatAppLog("log", "at pages/contacts/composables/useContactNavigation.js:55", "å¯¼èˆªåˆ°è”ç³»äººè¯¦æƒ…é¡µé¢å¤±è´¥:", error);
        }
      });
    };
    return {
      handleSearch,
      handleGroupChat,
      handleAddFriend,
      enterGroupChat,
      selectUser
    };
  }
  const _imports_0$1 = "/static/message/æœç´¢.png";
  const _imports_1 = "/static/message/å±•å¼€å¯¹è¯å·¥å…·.png";
  const _sfc_main$9 = {
    name: "Contacts",
    components: {
      GroupChatList,
      UserList,
      ContactDetailView: PagesContactsComponentsContactDetailContactDetailView,
      DropdownMenu,
      LoadingAnimation
    },
    setup() {
      formatAppLog("log", "at pages/contacts/pages/contacts.vue:89", "è”ç³»äººç»„ä»¶è®¾ç½®å‡½æ•°è¢«è°ƒç”¨");
      const contactsStore = useContactsStore();
      const {
        initContacts,
        loading,
        isUpdating,
        missionId,
        groupVOList,
        userInformationVOList,
        computedMissionId,
        showDropdown,
        toggleDropdown,
        handleContainerClick
      } = useContacts();
      const {
        handleSearch,
        handleGroupChat,
        handleAddFriend,
        enterGroupChat,
        selectUser
      } = useContactNavigation();
      const selectedContact = vue.ref(null);
      vue.onMounted(() => {
        formatAppLog("log", "at pages/contacts/pages/contacts.vue:114", "è”ç³»äººç»„ä»¶æŒ‚è½½é’©å­è¢«è°ƒç”¨");
        initContacts();
      });
      vue.onActivated(() => {
        formatAppLog("log", "at pages/contacts/pages/contacts.vue:119", "è”ç³»äººé¡µé¢è¢«æ¿€æ´»");
        initContacts();
      });
      vue.watch(() => missionId.value, (newMissionId) => {
        if (newMissionId) {
          formatAppLog("log", "at pages/contacts/pages/contacts.vue:125", "ä»»åŠ¡IDå·²æ›´æ”¹ï¼Œé‡æ–°åˆå§‹åŒ–è”ç³»äºº");
          initContacts();
        }
      });
      vue.watch(() => contactsStore.contactsUpdateCounter, () => {
        formatAppLog("log", "at pages/contacts/pages/contacts.vue:131", "è”ç³»äººæ•°æ®å·²æ›´æ–°ï¼Œé‡æ–°åˆå§‹åŒ–è”ç³»äºº");
        initContacts();
      });
      const closeContactDetail = () => {
        selectedContact.value = null;
      };
      return {
        groupVOList,
        userInformationVOList,
        selectedContact,
        showDropdown,
        loading,
        isUpdating,
        missionId,
        computedMissionId,
        closeContactDetail,
        handleSearch,
        toggleDropdown,
        handleContainerClick,
        handleGroupChat,
        handleAddFriend,
        enterGroupChat,
        selectUser
      };
    }
  };
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    const _component_dropdown_menu = vue.resolveComponent("dropdown-menu");
    const _component_loading_animation = vue.resolveComponent("loading-animation");
    const _component_group_chat_list = vue.resolveComponent("group-chat-list");
    const _component_user_list = vue.resolveComponent("user-list");
    const _component_contact_detail_view = vue.resolveComponent("contact-detail-view");
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "contacts-container",
      onClick: _cache[4] || (_cache[4] = (...args) => $setup.handleContainerClick && $setup.handleContainerClick(...args))
    }, [
      vue.createCommentVNode(" é¡¶éƒ¨å¯¼èˆªæ  "),
      vue.createVNode(_component_uni_nav_bar, {
        fixed: true,
        "status-bar": "",
        "right-icon": "search",
        onClickRight: $setup.handleSearch,
        title: "é€šè®¯å½•"
      }, {
        right: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "nav-right" }, [
            vue.createElementVNode("image", {
              class: "nav-icon",
              src: _imports_0$1,
              mode: "aspectFit",
              onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $setup.handleSearch && $setup.handleSearch(...args), ["stop"]))
            }),
            vue.createElementVNode("image", {
              class: "nav-icon",
              src: _imports_1,
              mode: "aspectFit",
              onClick: _cache[1] || (_cache[1] = vue.withModifiers((...args) => $setup.toggleDropdown && $setup.toggleDropdown(...args), ["stop"]))
            })
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["onClickRight"]),
      vue.createCommentVNode(" ä¸‹æ‹‰èœå• "),
      vue.createVNode(_component_dropdown_menu, {
        visible: $setup.showDropdown,
        onGroupChat: $setup.handleGroupChat,
        onAddFriend: $setup.handleAddFriend
      }, null, 8, ["visible", "onGroupChat", "onAddFriend"]),
      vue.createElementVNode("view", { class: "content-wrapper" }, [
        vue.createCommentVNode(" åŠ è½½åŠ¨ç”» "),
        $setup.loading ? (vue.openBlock(), vue.createBlock(_component_loading_animation, { key: 0 })) : (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          { key: 1 },
          [
            vue.createCommentVNode(" ç¾¤èŠåˆ—è¡¨ç»„ä»¶ "),
            $setup.groupVOList.length > 0 ? (vue.openBlock(), vue.createBlock(_component_group_chat_list, {
              key: 0,
              groupVOList: $setup.groupVOList,
              onEnterGroupChat: _cache[2] || (_cache[2] = (group) => $setup.enterGroupChat(group, $setup.computedMissionId))
            }, null, 8, ["groupVOList"])) : (vue.openBlock(), vue.createElementBlock("view", {
              key: 1,
              class: "empty-state"
            }, "æš‚æ— ç¾¤èŠ")),
            vue.createCommentVNode(" ç”¨æˆ·åˆ—è¡¨ç»„ä»¶ "),
            $setup.userInformationVOList.length > 0 ? (vue.openBlock(), vue.createBlock(_component_user_list, {
              key: 2,
              userInformationVOList: $setup.userInformationVOList,
              onSelectUser: _cache[3] || (_cache[3] = (user) => $setup.selectUser(user, $setup.missionId))
            }, null, 8, ["userInformationVOList"])) : (vue.openBlock(), vue.createElementBlock("view", {
              key: 3,
              class: "empty-state"
            }, "æš‚æ— è”ç³»äºº"))
          ],
          64
          /* STABLE_FRAGMENT */
        ))
      ]),
      vue.createCommentVNode(" è”ç³»äººè¯¦æƒ…ç»„ä»¶ "),
      $setup.selectedContact ? (vue.openBlock(), vue.createBlock(_component_contact_detail_view, {
        key: 0,
        contact: $setup.selectedContact,
        onClose: $setup.closeContactDetail
      }, null, 8, ["contact", "onClose"])) : vue.createCommentVNode("v-if", true)
    ]);
  }
  const PagesContactsPagesContacts = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8], ["__scopeId", "data-v-15b516a0"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/pages/contacts.vue"]]);
  const _sfc_main$8 = {
    name: "TabBar",
    components: {
      MainPage: PagesProfileProfile,
      Messages: PagesMessageMain,
      Contacts: PagesContactsPagesContacts,
      TaskDetail: PagesTaskTaskDetailTaskDetail
    },
    data() {
      return {
        currentTab: 0,
        tabs: [
          {
            icon_nochoice: "../../static/tabBar/é¦–é¡µ-æœªé€‰ä¸­.png",
            icon_choice: "../../static/tabBar/é¦–é¡µ-é€‰ä¸­.png",
            label: "é¦–é¡µ"
          },
          {
            icon_nochoice: "../../static/tabBar/é€šè®¯å½•-æœªé€‰ä¸­.png",
            icon_choice: "../../static/tabBar/é€šè®¯å½•-é€‰ä¸­.png",
            label: "é€šè®¯å½•"
          },
          {
            icon_nochoice: "../../static/tabBar/ä»»åŠ¡-æœªé€‰ä¸­.png",
            icon_choice: "../../static/tabBar/ä»»åŠ¡-é€‰ä¸­.png",
            label: "ä»»åŠ¡"
          },
          {
            icon_nochoice: "../../static/tabBar/æˆ‘çš„-æœªé€‰ä¸­.png",
            icon_choice: "../../static/tabBar/æˆ‘çš„-é€‰ä¸­.png",
            label: "æˆ‘çš„"
          }
        ]
      };
    },
    methods: {
      onTabClick(index) {
        this.currentTab = index;
      },
      hideTabBar() {
        if (this.$refs.tabBar) {
          this.$refs.tabBar.style.display = "none";
        }
      },
      showTabBar() {
        if (this.$refs.tabBar) {
          this.$refs.tabBar.style.display = "flex";
        }
      }
    }
  };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TaskDetail = vue.resolveComponent("TaskDetail");
    const _component_messages = vue.resolveComponent("messages");
    const _component_main_page = vue.resolveComponent("main-page");
    const _component_contacts = vue.resolveComponent("contacts");
    return vue.openBlock(), vue.createElementBlock("view", { class: "main-container" }, [
      vue.createCommentVNode(" ä¸»è¦å†…å®¹åŒºåŸŸ "),
      vue.createElementVNode("view", { class: "content-area" }, [
        $data.currentTab === 2 ? (vue.openBlock(), vue.createBlock(_component_TaskDetail, { key: 0 })) : $data.currentTab === 0 ? (vue.openBlock(), vue.createBlock(_component_messages, { key: 1 })) : $data.currentTab === 3 ? (vue.openBlock(), vue.createBlock(_component_main_page, { key: 2 })) : $data.currentTab === 1 ? (vue.openBlock(), vue.createBlock(_component_contacts, { key: 3 })) : (vue.openBlock(), vue.createElementBlock("view", {
          key: 4,
          class: "placeholder-content"
        }, [
          vue.createElementVNode(
            "text",
            null,
            "è¿™æ˜¯" + vue.toDisplayString(["é¦–é¡µ", "", "", ""][$data.currentTab]) + "çš„å†…å®¹",
            1
            /* TEXT */
          )
        ]))
      ]),
      vue.createCommentVNode(" åº•éƒ¨å¯¼èˆªæ  "),
      vue.createElementVNode(
        "view",
        {
          class: "tab-bar",
          ref: "tabBar"
        },
        [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($data.tabs, (tab, index) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                key: index,
                class: "tab-item",
                onClick: ($event) => $options.onTabClick(index)
              }, [
                vue.createElementVNode("image", {
                  src: $data.currentTab === index ? tab.icon_choice : tab.icon_nochoice,
                  class: "tab-icon",
                  mode: "aspectFit"
                }, null, 8, ["src"]),
                vue.createElementVNode(
                  "text",
                  {
                    class: vue.normalizeClass(["tab-text", { "active": $data.currentTab === index }])
                  },
                  vue.toDisplayString(tab.label),
                  3
                  /* TEXT, CLASS */
                )
              ], 8, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        512
        /* NEED_PATCH */
      )
    ]);
  }
  const PagesTabBarTabBar = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/tabBar/tabBar.vue"]]);
  const poster = "/static/icon/poster.gif";
  const _sfc_main$7 = {
    __name: "video-call",
    setup(__props, { expose: __expose }) {
      __expose();
      let mainVideo = vue.ref();
      let secondaryVideo = vue.ref();
      let localUserMedia = vue.ref();
      let peerStore = usePeerStore();
      let isConnected = vue.ref(false);
      vue.onMounted((options) => {
        getLocalUserMedia({ audio: true, video: true }).then(
          (userMedia) => {
            let videoElement = document.getElementsByTagName("video")[0];
            videoElement.srcObject = userMedia;
            localUserMedia.value = userMedia;
            peerStore.dataConnection = peerStore.localPeer.connect(options.calleePeerId);
            peerStore.dataConnection.on("data", (data) => {
              var _a, _b, _c;
              if (data.instruction === peerStore.instruction.accept) {
                peerStore.mediaConnection = peerStore.localPeer.call(options.calleePeerId, localUserMedia.value);
                peerStore.mediaConnection.on("stream", (userMedia2) => {
                  mainVideo.value.srcObject = userMedia2;
                  mainVideo.value.muted = false;
                  secondaryVideo.value.srcObject = localUserMedia.value;
                  secondaryVideo.value.muted = true;
                  isConnected.value = true;
                  uni.showToast({
                    title: "connected"
                  });
                });
              } else if (data.instruction === peerStore.instruction.busy) {
                peerStore.dataConnection.close();
                peerStore.dataConnection = void 0;
                for (let track of (_a = localUserMedia.value) == null ? void 0 : _a.getTracks()) {
                  track.stop();
                }
                uni.showToast({
                  title: "the other party is busy on the line",
                  icon: "none"
                });
                uni.navigateBack();
              } else if (data.instruction === peerStore.instruction.reject) {
                peerStore.dataConnection.close();
                peerStore.dataConnection = void 0;
                for (let track of (_b = localUserMedia.value) == null ? void 0 : _b.getTracks()) {
                  track.stop();
                }
                uni.showToast({
                  title: "the other party refused",
                  icon: "none"
                });
                uni.navigateBack();
              } else if (data.instruction === peerStore.instruction.ringOff) {
                peerStore.dataConnection.close();
                peerStore.dataConnection = void 0;
                peerStore.mediaConnection.close();
                peerStore.mediaConnection = void 0;
                for (let track of (_c = localUserMedia.value) == null ? void 0 : _c.getTracks()) {
                  track.stop();
                }
                uni.showToast({
                  title: "the other party has hung up",
                  icon: "none"
                });
                uni.navigateBack();
              }
            });
            peerStore.dataConnection.on("open", () => {
              peerStore.dataConnection.send({
                instruction: peerStore.instruction.request
              });
            });
          }
        ).catch((e2) => {
          uni.showToast({
            title: "èŽ·å–æ‘„åƒå¤´å¤±è´¥ï¼",
            icon: "none"
          });
          formatAppLog("log", "at pages/message/video-call.vue:120", e2);
        });
      });
      function getLocalUserMedia(constrains) {
        if (navigator.mediaDevices.getUserMedia) {
          return navigator.mediaDevices.getUserMedia(constrains);
        } else if (navigator.webkitGetUserMedia) {
          return navigator.webkitGetUserMedia(constrains);
        } else if (navigator.mozGetUserMedia) {
          return navigator.mozGetUserMedia(constrains);
        } else if (navigator.getUserMedia) {
          return navigator.getUserMedia(constrains);
        }
        throw new Error("unable to get user media");
      }
      function cancelVideoCall() {
        var _a, _b;
        for (let track of (_a = localUserMedia.value) == null ? void 0 : _a.getTracks()) {
          track.stop();
        }
        (_b = peerStore.dataConnection) == null ? void 0 : _b.send({
          instruction: peerStore.instruction.cancel
        });
        peerStore.dataConnection = void 0;
        uni.navigateBack();
      }
      function ringOffVideoCall() {
        var _a;
        for (let track of (_a = localUserMedia.value) == null ? void 0 : _a.getTracks()) {
          track.stop();
        }
        peerStore.dataConnection.send({
          instruction: peerStore.instruction.ringOff
        });
        peerStore.dataConnection = void 0;
        peerStore.mediaConnection = void 0;
        uni.navigateBack();
      }
      const __returned__ = { get mainVideo() {
        return mainVideo;
      }, set mainVideo(v2) {
        mainVideo = v2;
      }, get secondaryVideo() {
        return secondaryVideo;
      }, set secondaryVideo(v2) {
        secondaryVideo = v2;
      }, get localUserMedia() {
        return localUserMedia;
      }, set localUserMedia(v2) {
        localUserMedia = v2;
      }, get peerStore() {
        return peerStore;
      }, set peerStore(v2) {
        peerStore = v2;
      }, get isConnected() {
        return isConnected;
      }, set isConnected(v2) {
        isConnected = v2;
      }, getLocalUserMedia, cancelVideoCall, ringOffVideoCall, get poster() {
        return poster;
      }, get usePeerStore() {
        return usePeerStore;
      }, onMounted: vue.onMounted, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createCommentVNode(" è§†é¢‘ç”»é¢ "),
      vue.createElementVNode("video", {
        class: "main-video",
        ref: "mainVideo",
        poster: $setup.poster,
        autoplay: ""
      }, null, 8, ["poster"]),
      vue.createElementVNode("video", {
        class: "secondary-video",
        ref: "secondaryVideo",
        poster: $setup.poster,
        autoplay: ""
      }, null, 8, ["poster"]),
      vue.createElementVNode("section", { class: "buttom-bar" }, [
        $setup.isConnected ? (vue.openBlock(), vue.createElementBlock("button", {
          key: 0,
          type: "warn",
          onClick: $setup.ringOffVideoCall
        })) : (vue.openBlock(), vue.createElementBlock("button", {
          key: 1,
          type: "warn",
          onClick: $setup.cancelVideoCall
        }))
      ])
    ]);
  }
  const PagesMessageVideoCall = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/video-call.vue"]]);
  const _sfc_main$6 = {
    data() {
      return {};
    },
    methods: {}
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view");
  }
  const PagesMessageChatComponentCallReminder = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$5], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/CallReminder.vue"]]);
  const _sfc_main$5 = {
    __name: "video-answer",
    setup(__props, { expose: __expose }) {
      __expose();
      let mainVideo = vue.ref();
      let secondaryVideo = vue.ref();
      let localUserMedia = vue.ref();
      let peerStore = usePeerStore();
      let router = useRouter();
      let isConnected = vue.ref(false);
      vue.onMounted(() => {
        getLocalUserMedia({ audio: true, video: true }).then((userMedia) => {
          mainVideo.value.srcObject = userMedia;
          localUserMedia.value = userMedia;
          peerStore.mediaConnection.answer(localUserMedia.value);
          peerStore.mediaConnection.on("stream", (remoteUserMedia) => {
            mainVideo.value.srcObject = remoteUserMedia;
            secondaryVideo.value.srcObject = localUserMedia.value;
            isConnected.value = true;
            uni.showToast({
              title: "connected"
            });
          });
        }).catch(() => {
          uni.showToast({
            title: "failed to obtain local video media",
            icon: "none"
          });
          uni.navigateBack();
        });
      });
      let cancel = vue.watch(() => [peerStore.dataConnection, peerStore.mediaConnection], ([dataConnection, mediaConnection]) => {
        if (dataConnection === void 0 && mediaConnection === void 0) {
          cancel();
          if (localUserMedia.value) {
            for (let track of localUserMedia.value.getTracks()) {
              track.stop();
            }
          }
          uni.showToast({
            title: "the other party has hung up"
          });
          uni.navigateBack();
        }
      }, { immediate: true });
      function getLocalUserMedia(constrains) {
        if (navigator.mediaDevices.getUserMedia) {
          return navigator.mediaDevices.getUserMedia(constrains);
        } else if (navigator.webkitGetUserMedia) {
          return navigator.webkitGetUserMedia(constrains);
        } else if (navigator.mozGetUserMedia) {
          return navigator.mozGetUserMedia(constrains);
        } else if (navigator.getUserMedia) {
          return navigator.getUserMedia(constrains);
        }
        throw new Error("unable to get user media");
      }
      function ringOffVideoCall() {
        var _a;
        cancel();
        for (let track of (_a = localUserMedia.value) == null ? void 0 : _a.getTracks()) {
          track.stop();
        }
        peerStore.dataConnection.send({
          instruction: peerStore.instruction.ringOff
        });
        peerStore.dataConnection = void 0;
        peerStore.mediaConnection = void 0;
        uni.navigateBack();
      }
      const __returned__ = { get mainVideo() {
        return mainVideo;
      }, set mainVideo(v2) {
        mainVideo = v2;
      }, get secondaryVideo() {
        return secondaryVideo;
      }, set secondaryVideo(v2) {
        secondaryVideo = v2;
      }, get localUserMedia() {
        return localUserMedia;
      }, set localUserMedia(v2) {
        localUserMedia = v2;
      }, get peerStore() {
        return peerStore;
      }, set peerStore(v2) {
        peerStore = v2;
      }, get router() {
        return router;
      }, set router(v2) {
        router = v2;
      }, get isConnected() {
        return isConnected;
      }, set isConnected(v2) {
        isConnected = v2;
      }, get cancel() {
        return cancel;
      }, set cancel(v2) {
        cancel = v2;
      }, getLocalUserMedia, ringOffVideoCall, get poster() {
        return poster;
      }, get usePeerStore() {
        return usePeerStore;
      }, onMounted: vue.onMounted, ref: vue.ref, watch: vue.watch };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_button = vue.resolveComponent("van-button");
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createElementVNode("section", { class: "container" }, [
        vue.createElementVNode("video", {
          class: "main-video",
          ref: "mainVideo",
          poster: $setup.poster,
          autoplay: ""
        }, null, 8, ["poster"]),
        vue.createElementVNode("video", {
          class: "secondary-video",
          ref: "secondaryVideo",
          poster: $setup.poster,
          autoplay: ""
        }, null, 8, ["poster"]),
        vue.createElementVNode("section", { class: "bottom-bar" }, [
          $setup.isConnected ? (vue.openBlock(), vue.createBlock(_component_van_button, {
            key: 0,
            type: "danger",
            block: "",
            onClick: $setup.ringOffVideoCall
          }, {
            default: vue.withCtx(() => [
              vue.createTextVNode(" æŒ‚æ–­è§†é¢‘é€šè¯ ")
            ]),
            _: 1
            /* STABLE */
          })) : vue.createCommentVNode("v-if", true)
        ])
      ])
    ]);
  }
  const PagesMessageVideoAnswer = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/video-answer.vue"]]);
  const _imports_0 = "/static/icon/å…³é—­.png";
  const _sfc_main$4 = {
    __name: "inputAccount",
    setup(__props, { expose: __expose }) {
      __expose();
      const { connect } = useWebSocket();
      const userStore = useUserStore();
      const autoLogin = vue.ref(false);
      const statusBarHeight = uni.getSystemInfoSync().statusBarHeight;
      const username = vue.ref("liuyuqi");
      const password = vue.ref("iecas.123");
      const backToFirstPage = () => {
        uni.navigateBack();
      };
      const goToTask = () => {
        uni.reLaunch({
          url: "/pages/tabBar/tabBar"
        });
      };
      const checkLogin = () => {
        uni.showLoading({
          title: "æ­£åœ¨ç™»å½•",
          mask: true
        });
        login({
          account: username.value,
          password: password.value
        }).then((res) => {
          if (res.code === 200) {
            uni.setStorageSync("username", username.value);
            uni.setStorageSync("password", password.value);
            uni.setStorageSync("token", res.data.token);
            formatAppLog("log", "at pages/login/camouflageLogin/inputAccount/inputAccount.vue:61", res.data.missionId, "res.data.missionId");
            const userData = {
              id: res.data.id,
              account: res.data.account,
              name: res.data.name,
              department: res.data.department,
              role: res.data.role,
              phone: res.data.phone,
              created: res.data.created,
              avatar: res.data.avatar,
              avatarUrl: res.data.avatarUrl,
              token: res.data.token,
              status: res.data.status,
              missionId: res.data.missionId || ""
              // æ·»åŠ  missionIdï¼Œå¦‚æžœä¸å­˜åœ¨åˆ™è®¾ä¸ºç©ºå­—ç¬¦ä¸²
            };
            userStore.setUserData(userData);
            connect(res.data.id, res.data.token);
            uni.setStorageSync("userInfo", userData);
            formatAppLog("log", "at pages/login/camouflageLogin/inputAccount/inputAccount.vue:85", "ç™»å½•æˆåŠŸã€‚ç”¨æˆ·æ•°æ®:", userData);
            formatAppLog("log", "at pages/login/camouflageLogin/inputAccount/inputAccount.vue:86", "ä¿å­˜çš„ missionId:", userData.missionId);
            uni.hideLoading();
            uni.showToast({
              title: "ç™»å½•æˆåŠŸ",
              duration: 2e3
            }).then(() => {
              goToTask();
            });
          } else {
            throw new Error(res.message || "ç™»å½•å¤±è´¥");
          }
        }).catch((error) => {
          formatAppLog("error", "at pages/login/camouflageLogin/inputAccount/inputAccount.vue:99", "ç™»å½•å¤±è´¥:", error);
          uni.hideLoading();
          uni.showToast({
            title: error.message || "ç™»å½•å¤±è´¥",
            icon: "none",
            duration: 2e3
          });
        });
      };
      const __returned__ = { connect, userStore, autoLogin, statusBarHeight, username, password, backToFirstPage, goToTask, checkLogin, ref: vue.ref, onMounted: vue.onMounted, get login() {
        return login;
      }, get useUserStore() {
        return useUserStore;
      }, useWebSocket };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_easyinput = resolveEasycom(vue.resolveDynamicComponent("uni-easyinput"), __easycom_0$1);
    return vue.openBlock(), vue.createElementBlock("view", {
      class: "inputAccountPage",
      style: { "padding": "0 15px 0 15px" }
    }, [
      vue.createElementVNode("view", { class: "inputAccountContent" }, [
        vue.createElementVNode("view", { class: "statusBarInput" }),
        vue.createElementVNode("view", { class: "inputAccountHeader" }, [
          vue.createCommentVNode(" æŽ¨ç‰¹logo "),
          vue.createElementVNode("view", { class: "inputAccountHeaderLeft" }, [
            vue.createElementVNode("image", {
              onClick: $setup.backToFirstPage,
              src: _imports_0,
              style: { "width": "20px", "height": "20px" }
            })
          ]),
          vue.createElementVNode("view", { class: "inputAccountHeaderMiddle" }, [
            vue.createElementVNode("image", {
              src: _imports_1$6,
              style: { "width": "25px", "height": "25px" }
            })
          ])
        ]),
        vue.createElementVNode("view", null, [
          vue.createElementVNode("view", { style: { "text-align": "left", "margin-top": "30px" } }, [
            vue.createElementVNode("text", { style: { "letter-spacing": "3px", "font-size": "50rpx", "font-family": "fantasy", "font-weight": "550", "width": "75%" } }, "è¦å¼€å§‹ä½¿ç”¨ï¼Œè¯·å…ˆè¾“å…¥ä½ çš„æ‰‹æœºå·ç ã€é‚®ç®±åœ°å€æˆ–@ç”¨æˆ·åã€‚")
          ]),
          vue.createElementVNode("view", { style: { "margin-top": "20px" } }, [
            vue.createVNode(_component_uni_easyinput, {
              class: "inputValue",
              trim: "all",
              modelValue: $setup.username,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.username = $event),
              placeholder: "æ‰‹æœºå·ç /é‚®ä»¶åœ°å€æˆ–ç”¨æˆ·å"
            }, null, 8, ["modelValue"])
          ]),
          vue.createElementVNode("view", { style: { "margin-top": "20px" } }, [
            vue.createVNode(_component_uni_easyinput, {
              class: "inputValue",
              type: "password",
              trim: "all",
              modelValue: $setup.password,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.password = $event),
              placeholder: "å¯†ç "
            }, null, 8, ["modelValue"])
          ])
        ])
      ]),
      vue.createElementVNode("view", { class: "inputAccountFooter" }, [
        vue.createElementVNode("button", {
          onClick: $setup.checkLogin,
          style: { "background": "black", "border-radius": "30px", "color": "white" }
        }, "ä¸‹ä¸€æ­¥")
      ])
    ]);
  }
  const PagesLoginCamouflageLoginInputAccountInputAccount = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/login/camouflageLogin/inputAccount/inputAccount.vue"]]);
  const popup = {
    data() {
      return {};
    },
    created() {
      this.popup = this.getParent();
    },
    methods: {
      /**
       * èŽ·å–çˆ¶å…ƒç´ å®žä¾‹
       */
      getParent(name = "uniPopup") {
        let parent = this.$parent;
        let parentName = parent.$options.name;
        while (parentName !== name) {
          parent = parent.$parent;
          if (!parent)
            return false;
          parentName = parent.$options.name;
        }
        return parent;
      }
    }
  };
  const en = {
    "uni-popup.cancel": "cancel",
    "uni-popup.ok": "ok",
    "uni-popup.placeholder": "pleace enter",
    "uni-popup.title": "Hint",
    "uni-popup.shareTitle": "Share to"
  };
  const zhHans = {
    "uni-popup.cancel": "å–æ¶ˆ",
    "uni-popup.ok": "ç¡®å®š",
    "uni-popup.placeholder": "è¯·è¾“å…¥",
    "uni-popup.title": "æç¤º",
    "uni-popup.shareTitle": "åˆ†äº«åˆ°"
  };
  const zhHant = {
    "uni-popup.cancel": "å–æ¶ˆ",
    "uni-popup.ok": "ç¢ºå®š",
    "uni-popup.placeholder": "è«‹è¼¸å…¥",
    "uni-popup.title": "æç¤º",
    "uni-popup.shareTitle": "åˆ†äº«åˆ°"
  };
  const messages = {
    en,
    "zh-Hans": zhHans,
    "zh-Hant": zhHant
  };
  const {
    t
  } = initVueI18n(messages);
  const _sfc_main$3 = {
    name: "uniPopupDialog",
    mixins: [popup],
    emits: ["confirm", "close", "update:modelValue", "input"],
    props: {
      inputType: {
        type: String,
        default: "text"
      },
      showClose: {
        type: Boolean,
        default: true
      },
      modelValue: {
        type: [Number, String],
        default: ""
      },
      placeholder: {
        type: [String, Number],
        default: ""
      },
      type: {
        type: String,
        default: "error"
      },
      mode: {
        type: String,
        default: "base"
      },
      title: {
        type: String,
        default: ""
      },
      content: {
        type: String,
        default: ""
      },
      beforeClose: {
        type: Boolean,
        default: false
      },
      cancelText: {
        type: String,
        default: ""
      },
      confirmText: {
        type: String,
        default: ""
      },
      maxlength: {
        type: Number,
        default: -1
      },
      focus: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        dialogType: "error",
        val: ""
      };
    },
    computed: {
      okText() {
        return this.confirmText || t("uni-popup.ok");
      },
      closeText() {
        return this.cancelText || t("uni-popup.cancel");
      },
      placeholderText() {
        return this.placeholder || t("uni-popup.placeholder");
      },
      titleText() {
        return this.title || t("uni-popup.title");
      }
    },
    watch: {
      type(val) {
        this.dialogType = val;
      },
      mode(val) {
        if (val === "input") {
          this.dialogType = "info";
        }
      },
      value(val) {
        if (this.maxlength != -1 && this.mode === "input") {
          this.val = val.slice(0, this.maxlength);
        } else {
          this.val = val;
        }
      },
      val(val) {
        this.$emit("update:modelValue", val);
      }
    },
    created() {
      this.popup.disableMask();
      if (this.mode === "input") {
        this.dialogType = "info";
        this.val = this.value;
        this.val = this.modelValue;
      } else {
        this.dialogType = this.type;
      }
    },
    methods: {
      /**
       * ç‚¹å‡»ç¡®è®¤æŒ‰é’®
       */
      onOk() {
        if (this.mode === "input") {
          this.$emit("confirm", this.val);
        } else {
          this.$emit("confirm");
        }
        if (this.beforeClose)
          return;
        this.popup.close();
      },
      /**
       * ç‚¹å‡»å–æ¶ˆæŒ‰é’®
       */
      closeDialog() {
        this.$emit("close");
        if (this.beforeClose)
          return;
        this.popup.close();
      },
      close() {
        this.popup.close();
      }
    }
  };
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "uni-popup-dialog" }, [
      vue.createElementVNode("view", { class: "uni-dialog-title" }, [
        vue.createElementVNode(
          "text",
          {
            class: vue.normalizeClass(["uni-dialog-title-text", ["uni-popup__" + $data.dialogType]])
          },
          vue.toDisplayString($options.titleText),
          3
          /* TEXT, CLASS */
        )
      ]),
      $props.mode === "base" ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "uni-dialog-content"
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, () => [
          vue.createElementVNode(
            "text",
            { class: "uni-dialog-content-text" },
            vue.toDisplayString($props.content),
            1
            /* TEXT */
          )
        ], true)
      ])) : (vue.openBlock(), vue.createElementBlock("view", {
        key: 1,
        class: "uni-dialog-content"
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, () => [
          vue.withDirectives(vue.createElementVNode("input", {
            class: "uni-dialog-input",
            maxlength: $props.maxlength,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.val = $event),
            type: $props.inputType,
            placeholder: $options.placeholderText,
            focus: $props.focus
          }, null, 8, ["maxlength", "type", "placeholder", "focus"]), [
            [vue.vModelDynamic, $data.val]
          ])
        ], true)
      ])),
      vue.createElementVNode("view", { class: "uni-dialog-button-group" }, [
        $props.showClose ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "uni-dialog-button",
          onClick: _cache[1] || (_cache[1] = (...args) => $options.closeDialog && $options.closeDialog(...args))
        }, [
          vue.createElementVNode(
            "text",
            { class: "uni-dialog-button-text" },
            vue.toDisplayString($options.closeText),
            1
            /* TEXT */
          )
        ])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["uni-dialog-button", $props.showClose ? "uni-border-left" : ""]),
            onClick: _cache[2] || (_cache[2] = (...args) => $options.onOk && $options.onOk(...args))
          },
          [
            vue.createElementVNode(
              "text",
              { class: "uni-dialog-button-text uni-button-color" },
              vue.toDisplayString($options.okText),
              1
              /* TEXT */
            )
          ],
          2
          /* CLASS */
        )
      ])
    ]);
  }
  const __easycom_1 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2], ["__scopeId", "data-v-d78c88b7"], ["__file", "E:/ä»£ç /new/zk_uniapp/uni_modules/uni-popup/components/uni-popup-dialog/uni-popup-dialog.vue"]]);
  const DoubleUnicodePrefixReg = /^[\uD800-\uDBFF]$/;
  const DoubleUnicodeSuffixReg = /^[\uDC00-\uDFFF]$/;
  const DoubleUnicodeReg = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var Probability;
  (function(Probability2) {
    Probability2[Probability2["Unknown"] = 1e-13] = "Unknown";
    Probability2[Probability2["Rule"] = 1e-12] = "Rule";
    Probability2[Probability2["DICT"] = 2e-8] = "DICT";
    Probability2[Probability2["Surname"] = 1] = "Surname";
    Probability2[Probability2["Custom"] = 1] = "Custom";
  })(Probability || (Probability = {}));
  const Priority = {
    Normal: 1,
    Surname: 10,
    Custom: 100
  };
  function stringLength(text) {
    var _a;
    return text.length - (((_a = text.match(DoubleUnicodeReg)) === null || _a === void 0 ? void 0 : _a.length) || 0);
  }
  function splitString(text) {
    const result = [];
    let i2 = 0;
    while (i2 < text.length) {
      const char = text[i2];
      if (DoubleUnicodePrefixReg.test(char) && DoubleUnicodeSuffixReg.test(text[i2 + 1])) {
        result.push(text.substring(i2, i2 + 2));
        i2 += 2;
      } else {
        result.push(char);
        i2 += 1;
      }
    }
    return result;
  }
  class FastDictFactory {
    constructor() {
      this.NumberDICT = [];
      this.StringDICT = /* @__PURE__ */ new Map();
    }
    get(word) {
      if (word.length > 1) {
        return this.StringDICT.get(word);
      } else {
        const code = word.charCodeAt(0);
        return this.NumberDICT[code];
      }
    }
    set(word, pinyin2) {
      if (word.length > 1) {
        this.StringDICT.set(word, pinyin2);
      } else {
        const code = word.charCodeAt(0);
        this.NumberDICT[code] = pinyin2;
      }
    }
    clear() {
      this.NumberDICT = [];
      this.StringDICT.clear();
    }
  }
  const map = {
    "bÇŽng pÃ¡ng pÄng": ["è†€"],
    lÃ­ng: [
      "ã€‡",
      "ä¼¶",
      "å‡Œ",
      "åˆ¢",
      "å›¹",
      "å½",
      "å¤Œ",
      "å§ˆ",
      "å©ˆ",
      "å­",
      "å²º",
      "å½¾",
      "æŽ•",
      "æ˜¤",
      "æœŽ",
      "æŸƒ",
      "æ£‚",
      "æ«º",
      "æ¬ž",
      "æ³ ",
      "æ·©",
      "æ¾ª",
      "çµ",
      "ç‡¯",
      "çˆ§",
      "ç‹‘",
      "çŽ²",
      "çŒ",
      "ç“´",
      "çšŠ",
      "ç ±",
      "ç¥¾",
      "ç§¢",
      "ç«›",
      "ç¬­",
      "ç´·",
      "ç¶¾",
      "ç»«",
      "ç¾",
      "ç¾š",
      "ç¿Ž",
      "è†",
      "èˆ²",
      "è‹“",
      "è±",
      "è“¤",
      "è”†",
      "è•¶",
      "è›‰",
      "è¡‘",
      "è£¬",
      "è©…",
      "è·‰",
      "è»¨",
      "è¼˜",
      "é…ƒ",
      "é†½",
      "éˆ´",
      "éŒ‚",
      "é“ƒ",
      "é–",
      "é™µ",
      "é›¶",
      "éœŠ",
      "éœ—",
      "éœ›",
      "éœ",
      "éˆ",
      "é§–",
      "é­¿",
      "é¯ª",
      "é²®",
      "é´’",
      "é¸°",
      "é¹·",
      "éº¢",
      "é½¡",
      "é½¢",
      "é¾„",
      "é¾—",
      "ã¥„"
    ],
    yÄ«: [
      "ä¸€",
      "ä¹Š",
      "ä¼Š",
      "ä¾",
      "åŒ»",
      "åš",
      "å’¿",
      "å™«",
      "å£±",
      "å£¹",
      "å¤",
      "å«›",
      "å¬„",
      "å¼Œ",
      "æ–",
      "æ’Ž",
      "æª¹",
      "æ¯‰",
      "æ´¢",
      "æ¸",
      "æ¼ª",
      "ç‘¿",
      "ç•©",
      "ç¥Ž",
      "ç¦•",
      "ç¨¦",
      "ç¹„",
      "è›œ",
      "è¡¤",
      "è­©",
      "è¾·",
      "éƒ¼",
      "é†«",
      "éŠ¥",
      "é“±",
      "é·–",
      "é¹¥",
      "é»Ÿ",
      "é»³"
    ],
    "dÄ«ng zhÄ“ng": ["ä¸"],
    "kÇŽo qiÇŽo yÃº": ["ä¸‚"],
    qÄ«: [
      "ä¸ƒ",
      "å€›",
      "åƒ›",
      "å‡„",
      "å˜",
      "å¢„",
      "å¨¸",
      "æ‚½",
      "æ…¼",
      "æ…½",
      "æˆš",
      "æ¿",
      "æŸ’",
      "æ¡¤",
      "æ¡¼",
      "æ£²",
      "æ¦¿",
      "æ¬º",
      "æ²",
      "æ·’",
      "æ¼†",
      "ç´ª",
      "ç·€",
      "è‹",
      "è¤„",
      "è«†",
      "è¿‰",
      "éƒª",
      "éš",
      "éœ‹",
      "é­Œ",
      "é¶ˆ"
    ],
    shÃ ng: ["ä¸„", "å°™", "å°š", "æ¦", "ç·”", "ç»±"],
    xiÃ : [
      "ä¸…",
      "ä¸‹",
      "ä¹¤",
      "åœ·",
      "å¤",
      "å¤“",
      "æ‡—",
      "æ¢º",
      "ç–œ",
      "ç±",
      "ç½…",
      "éŽ¼",
      "é¬"
    ],
    hÇŽn: ["ä¸†", "å–Š", "æµ«", "ç½•", "è±ƒ", "ã˜Ž"],
    "wÃ n mÃ²": ["ä¸‡"],
    zhÃ ng: [
      "ä¸ˆ",
      "ä»—",
      "å¢‡",
      "å¶‚",
      "å¸",
      "å¸³",
      "å¹›",
      "æ‰™",
      "æ–",
      "æ¶±",
      "ç—®",
      "ç˜¬",
      "ç˜´",
      "çž•",
      "ç²€",
      "èƒ€",
      "è„¹",
      "è³¬",
      "è´¦",
      "éšœ"
    ],
    sÄn: ["ä¸‰", "åŽ", "å", "å¼Ž", "æ¯µ", "æ¯¶", "æ¯¿", "çŠ™", "é¬–"],
    "shÃ ng shÇŽng shang": ["ä¸Š"],
    "qÃ­ jÄ«": ["ä¸Œ", "å…¶", "å¥‡"],
    "bÃ¹ fÇ’u": ["ä¸"],
    "yÇ” yÃ¹ yÃº": ["ä¸Ž"],
    miÇŽn: [
      "ä¸",
      "å­",
      "å…",
      "å†•",
      "å‹‰",
      "å‹”",
      "å–•",
      "å¨©",
      "æ„",
      "æ±…",
      "æ²”",
      "æ¹Ž",
      "çŒ",
      "ç·¬",
      "ç¼…",
      "è…¼",
      "è‘‚",
      "é¦",
      "é®¸",
      "ð©¾ƒ"
    ],
    gÃ i: [
      "ä¸",
      "ä¹¢",
      "åŒƒ",
      "åŒ„",
      "æˆ¤",
      "æ¦‚",
      "æ§©",
      "æ§ª",
      "æº‰",
      "æ¼‘",
      "ç“‚",
      "è‘¢",
      "éˆ£",
      "é’™",
      "ð¬®¿"
    ],
    chÇ’u: ["ä¸‘", "ä¸’", "ä¾´", "åœ", "æ½", "çž…", "çŸ", "é†œ", "é­—"],
    zhuÄn: [
      "ä¸“",
      "å€",
      "å«¥",
      "å°‚",
      "å°ˆ",
      "ç‘¼",
      "ç”Ž",
      "ç –",
      "ç£—",
      "ç£š",
      "èŸ¤",
      "è«¯",
      "é„Ÿ",
      "é¡“",
      "é¢›",
      "é±„",
      "ä"
    ],
    "qiÄ› jÅ«": ["ä¸”"],
    pÄ«: [
      "ä¸•",
      "ä¼“",
      "ä¼¾",
      "å™¼",
      "å¯",
      "å²¯",
      "æ†µ",
      "æ‰¹",
      "æŠ«",
      "ç‚‹",
      "ç‹‰",
      "ç‹“",
      "ç ’",
      "ç£‡",
      "ç¤”",
      "ç¤•",
      "ç§›",
      "ç§ ",
      "è€š",
      "è±¾",
      "é‚³",
      "éˆš",
      "é‰Ÿ",
      "éŠ”",
      "éŒƒ",
      "éŒ",
      "éœ¹",
      "é§“",
      "é«¬",
      "é­¾",
      "ð¬³µ"
    ],
    shÃ¬: [
      "ä¸–",
      "ä¸—",
      "äºŠ",
      "äº‹",
      "ä»•",
      "ä¾",
      "å†Ÿ",
      "åŠ¿",
      "å‹¢",
      "å‹",
      "å‘©",
      "å—œ",
      "å™¬",
      "å£«",
      "å¥­",
      "å¬•",
      "å®¤",
      "å¸‚",
      "å¼",
      "å¼‘",
      "å¼’",
      "æ€",
      "æƒ",
      "æˆº",
      "æ‹­",
      "æ“",
      "æ˜¯",
      "æ˜°",
      "æž¾",
      "æŸ¿",
      "æ »",
      "æ¾¨",
      "çƒ’",
      "ç…¶",
      "çœ‚",
      "çœŽ",
      "çœ¡",
      "ç—",
      "ç¤º",
      "ç¤»",
      "ç­®",
      "ç°­",
      "èˆ",
      "èˆ“",
      "è¥«",
      "è¦–",
      "è§†",
      "è§¢",
      "è©¦",
      "èª“",
      "è«¡",
      "è¬š",
      "è¯•",
      "è°¥",
      "è²°",
      "è´³",
      "è»¾",
      "è½¼",
      "é€",
      "é¾",
      "é‡ˆ",
      "é‡Š",
      "é‡‹",
      "éˆ°",
      "é‰ƒ",
      "é‰½",
      "é“ˆ",
      "é£¾",
      "é¤™",
      "é¤",
      "é¥°",
      "é°˜",
      "ä¡",
      "ð¬¤Š"
    ],
    qiÅ«: [
      "ä¸˜",
      "ä¸ ",
      "åµ",
      "åª",
      "æ˜",
      "æ·",
      "æ¥¸",
      "ç§‹",
      "ç§Œ",
      "ç©",
      "ç¯",
      "ç·§",
      "è©",
      "è˜’",
      "èš¯",
      "èµ",
      "èŸ—",
      "è ¤",
      "è¶¥",
      "é‚±",
      "éž¦",
      "éž§",
      "é°Œ",
      "é°",
      "é³…",
      "é¶–",
      "é¹™",
      "é¾"
    ],
    bÇng: [
      "ä¸™",
      "å±›",
      "æ€²",
      "æŠ¦",
      "æ˜ž",
      "æ˜º",
      "æŸ„",
      "æ£…",
      "ç‚³",
      "ç¦€",
      "ç§‰",
      "ç¨Ÿ",
      "è‹ª",
      "è›ƒ",
      "é‚´",
      "éˆµ",
      "é™ƒ",
      "éž†",
      "é¤…",
      "é¤ ",
      "é¥¼"
    ],
    yÃ¨: [
      "ä¸š",
      "äº±",
      "åƒ·",
      "å¢·",
      "å¤œ",
      "å¶ª",
      "å¶«",
      "æŠ´",
      "æ™",
      "æ“›",
      "æ“ª",
      "æ“«",
      "æ™”",
      "æ›„",
      "æ›…",
      "æ›—",
      "æ›³",
      "æ›µ",
      "æž¼",
      "æž½",
      "æ¥­",
      "æ´‚",
      "æ¶²",
      "æ¾²",
      "çƒ¨",
      "ç‡",
      "çˆ—",
      "ç’",
      "çš£",
      "çž±",
      "çž¸",
      "ç¤",
      "è…‹",
      "è‘‰",
      "è¬",
      "è°’",
      "é‚º",
      "é„´",
      "é±",
      "é·",
      "é¥",
      "é¨",
      "é ",
      "é¡µ",
      "é¤£",
      "é¥",
      "é¦Œ",
      "é©œ",
      "éµº",
      "é¸ˆ"
    ],
    cÃ³ng: [
      "ä¸›",
      "ä»Ž",
      "å¢",
      "å©ƒ",
      "å­®",
      "å¾“",
      "å¾”",
      "å¾–",
      "æ‚°",
      "æ¨·",
      "æ¬‰",
      "æ·™",
      "ç‡",
      "çˆœ",
      "ç®",
      "è—‚",
      "èª´",
      "è³¨",
      "è³©",
      "éŒ"
    ],
    dÅng: [
      "ä¸œ",
      "å€²",
      "å†¬",
      "å’š",
      "åŸ¬",
      "å²½",
      "å´¬",
      "å¾š",
      "æ˜¸",
      "æ±",
      "æ°¡",
      "æ°­",
      "æ¶·",
      "ç¬—",
      "è‹³",
      "è„",
      "è€",
      "é®—",
      "é¯Ÿ",
      "é¶‡",
      "é¶«",
      "é¸«",
      "é¼•",
      "ð¬Ÿ½"
    ],
    sÄ«: [
      "ä¸",
      "ä¿¬",
      "å‡˜",
      "åŽ®",
      "å¸",
      "å’",
      "å˜¶",
      "å™",
      "åª¤",
      "å»",
      "æ–",
      "æ’•",
      "æ–¯",
      "æ¥’",
      "æ³€",
      "æ¾Œ",
      "ç‡",
      "ç¦—",
      "ç¦ ",
      "ç§",
      "ç³¹",
      "çµ²",
      "ç·¦",
      "çºŸ",
      "ç¼Œ",
      "ç½³",
      "è•¬",
      "è™’",
      "è›³",
      "èœ¤",
      "èž„",
      "èŸ–",
      "èŸ´",
      "é‰°",
      "éŠ¯",
      "é¶",
      "é",
      "é”¶",
      "é¢¸",
      "é£”",
      "é¨¦",
      "é·¥",
      "é¸¶",
      "é¼¶",
      "ãŸƒ"
    ],
    chÃ©ng: [
      "ä¸ž",
      "å‘ˆ",
      "åŸŽ",
      "åŸ•",
      "å ˜",
      "å¡",
      "å¡–",
      "å®¬",
      "å³¸",
      "æƒ©",
      "æ‡²",
      "æˆ",
      "æ‰¿",
      "æŒ°",
      "æŽ",
      "æ¨",
      "æž¨",
      "æ£–",
      "æ©™",
      "æª™",
      "æ´†",
      "æº—",
      "æ¾‚",
      "çµ",
      "ç¹",
      "ç•»",
      "ç¨‹",
      "çªš",
      "ç­¬",
      "çµ¾",
      "è„­",
      "è¿",
      "èª ",
      "è¯š",
      "éƒ•",
      "é…²",
      "é‹®",
      "é“–",
      "é¨¬",
      "é¯Ž"
    ],
    diÅ«: ["ä¸Ÿ", "ä¸¢", "éŠ©", "é“¥"],
    liÇŽng: [
      "ä¸¡",
      "ä¸¤",
      "å…©",
      "å”¡",
      "å•¢",
      "æŽš",
      "ç·‰",
      "è„¼",
      "èœ½",
      "è£²",
      "é­‰",
      "é­Ž",
      "ð¬œ¯"
    ],
    yÇ’u: [
      "ä¸£",
      "å£",
      "å‹",
      "æ¢„",
      "æ¹µ",
      "ç‰–",
      "ç¦‰",
      "ç¾‘",
      "èˆ",
      "è‹ƒ",
      "èŽ ",
      "èœ",
      "é…‰",
      "éŠª",
      "é“•",
      "é»"
    ],
    yÃ¡n: [
      "ä¸¥",
      "åŽ³",
      "å•±",
      "å–¦",
      "åš´",
      "å¡©",
      "å£›",
      "å£§",
      "å¦",
      "å§¸",
      "å¨«",
      "å¨®",
      "å²©",
      "åµ’",
      "åµ“",
      "å·Œ",
      "å·–",
      "å·—",
      "å»¶",
      "æ…",
      "æ˜–",
      "æ¥Œ",
      "æª",
      "æ«©",
      "æ¬•",
      "æ²¿",
      "ç‚Ž",
      "ç‚",
      "ç‹¿",
      "ç‚",
      "ç›",
      "ç¢ž",
      "ç­µ",
      "ç°·",
      "èŽš",
      "è”…",
      "è™¤",
      "èœ’",
      "è¨€",
      "è¨",
      "è¨®",
      "è©½",
      "è® ",
      "éƒ”",
      "é–†",
      "é–»",
      "é—«",
      "é˜Ž",
      "é¡",
      "é¡”",
      "é¢œ",
      "é¹½",
      "éº£",
      "ð«„§"
    ],
    bÃ¬ng: [
      "ä¸¦",
      "ä½µ",
      "å€‚",
      "å‚¡",
      "åžª",
      "æ‘’",
      "æ ¤",
      "ç—…",
      "çª‰",
      "ç«",
      "èª",
      "é",
      "é®©"
    ],
    "sÃ ng sÄng": ["ä¸§"],
    gÇ”n: [
      "ä¸¨",
      "æƒƒ",
      "æ»š",
      "æ»¾",
      "ç£™",
      "ç·„",
      "ç»²",
      "è“˜",
      "è”‰",
      "è¡®",
      "è¢ž",
      "è¼¥",
      "è¾Š",
      "é®Œ",
      "é¯€",
      "é²§"
    ],
    jiÅ«: [
      "ä¸©",
      "å‹¼",
      "å•¾",
      "æª",
      "æ«",
      "æœ»",
      "ç©¶",
      "ç³¾",
      "çº ",
      "è›",
      "èµ³",
      "é˜„",
      "é¬",
      "é¬®",
      "é³©",
      "é¸ "
    ],
    "gÃ¨ gÄ›": ["ä¸ª", "å€‹", "å„"],
    yÄ: [
      "ä¸«",
      "åœ§",
      "å­²",
      "åº˜",
      "æŠ¼",
      "æž’",
      "æ¡ ",
      "æ¤",
      "éŒ",
      "éš",
      "é´‰",
      "é´¨",
      "éµ¶",
      "é¸¦",
      "é¸­"
    ],
    pÃ¡n: [
      "ä¸¬",
      "åª»",
      "å¹‹",
      "æ§ƒ",
      "æ´€",
      "ç€Š",
      "çˆ¿",
      "ç›˜",
      "ç›¤",
      "ç£",
      "ç¸",
      "è’°",
      "èŸ ",
      "è¹’",
      "è¹£",
      "éŽœ",
      "éž¶"
    ],
    "zhÅng zhÃ²ng": ["ä¸­"],
    jÇ: [
      "ä¸®",
      "å¦€",
      "å·±",
      "æˆŸ",
      "æŒ¤",
      "æŽŽ",
      "æ’ ",
      "æ“ ",
      "æ©¶",
      "æ³²",
      "çŠ±",
      "è„Š",
      "è™®",
      "èŸ£",
      "é­¢",
      "é±¾",
      "éº‚"
    ],
    jiÃ¨: [
      "ä¸¯",
      "ä»‹",
      "å€Ÿ",
      "å”¶",
      "å º",
      "å±†",
      "å±Š",
      "å²•",
      "åºŽ",
      "å¾£",
      "æˆ’",
      "æ¥",
      "çŠ—",
      "çŽ ",
      "ç¾",
      "ç•Œ",
      "ç•",
      "ç–¥",
      "ç Ž",
      "èš§",
      "è›¶",
      "è¡¸",
      "è¤¯",
      "èª¡",
      "è¯«",
      "éŽ…",
      "éª±",
      "é­ª"
    ],
    fÄ“ng: [
      "ä¸°",
      "ä»¹",
      "å‘",
      "åƒ¼",
      "å‡¨",
      "å‡¬",
      "å‡®",
      "å¦¦",
      "å¯·",
      "å°",
      "å³¯",
      "å³°",
      "å´¶",
      "æž«",
      "æ¥“",
      "æª’",
      "æ²£",
      "æ²¨",
      "æ¸¢",
      "çƒ",
      "çƒ½",
      "çŠŽ",
      "çŒ¦",
      "ç’",
      "ç–¯",
      "ç˜‹",
      "ç›½",
      "ç œ",
      "ç¢¸",
      "ç¯ˆ",
      "è˜´",
      "èœ‚",
      "è ­",
      "è±",
      "é„·",
      "é…†",
      "é‹’",
      "éŽ½",
      "é ",
      "é”‹",
      "éœ»",
      "éŠ",
      "é£Œ",
      "éº·"
    ],
    "guÃ n kuÃ ng": ["ä¸±"],
    chuÃ n: ["ä¸²", "æ±Œ", "çŽ”", "è³—", "é‡§", "é’"],
    chÇŽn: [
      "ä¸³",
      "äº§",
      "å†",
      "å‰·",
      "å›…",
      "åµ¼",
      "æ—µ",
      "æµ",
      "æ»»",
      "ç›",
      "ç”¢",
      "ç”£",
      "ç°…",
      "è’‡",
      "è•†",
      "è«‚",
      "è­‚",
      "è®‡",
      "è°„",
      "éŸ",
      "é“²",
      "é–³",
      "é—¡",
      "é˜",
      "éª£",
      "ð¬Š¤"
    ],
    lÃ­n: [
      "ä¸´",
      "å†§",
      "å££",
      "å´Š",
      "å¶™",
      "æ–´",
      "æ™½",
      "æš½",
      "æž—",
      "æ½¾",
      "ç€¶",
      "ç‡",
      "ç³",
      "ç’˜",
      "çžµ",
      "ç¢„",
      "ç£·",
      "ç²¦",
      "ç²¼",
      "ç¹—",
      "ç¿·",
      "è‡¨",
      "è½”",
      "è¾š",
      "é´",
      "é‚»",
      "é„°",
      "é»",
      "é˜¾",
      "éš£",
      "éœ–",
      "é©Ž",
      "é±—",
      "é³ž",
      "éº",
      "éºŸ",
      "ð¬´Š",
      "ð¬­¸"
    ],
    zhuÃ³: [
      "ä¸µ",
      "åŠ…",
      "å“",
      "å•„",
      "åœ´",
      "å¦°",
      "å¨º",
      "æ’¯",
      "æ“†",
      "æ“¢",
      "æ–«",
      "æ–®",
      "æ–±",
      "æ–²",
      "æ–µ",
      "æ™«",
      "æ¤“",
      "æµŠ",
      "æµž",
      "æ¿",
      "ç¼",
      "çƒµ",
      "ç¸",
      "ç¡º",
      "ç¦š",
      "çª¡",
      "ç±—",
      "ç±±",
      "ç½¬",
      "èŒ",
      "è —",
      "è ¿",
      "è«",
      "è«‘",
      "è¬¶",
      "è¯¼",
      "é…Œ",
      "é²",
      "é•¯",
      "éµ«",
      "é·Ÿ",
      "ä“¬",
      "ð¬¸¦"
    ],
    zhÇ”: [
      "ä¸¶",
      "ä¸»",
      "åŠ¯",
      "å˜±",
      "å›‘",
      "å®”",
      "å¸¾",
      "æ‹„",
      "æ¸š",
      "æ¿",
      "ç…‘",
      "ç…®",
      "ç‡",
      "çž©",
      "çŸš",
      "ç½œ",
      "è©",
      "é™¼",
      "é¸€",
      "éºˆ",
      "ð¬£ž"
    ],
    bÄ: [
      "ä¸·",
      "ä»ˆ",
      "å…«",
      "å­",
      "å“µ",
      "å¤¿",
      "å²œ",
      "å·´",
      "æŒ",
      "æœ³",
      "çŽ",
      "ç–¤",
      "ç¬†",
      "ç²‘",
      "ç¾“",
      "èŠ­",
      "èš†",
      "è±",
      "é‡Ÿ"
    ],
    wÃ¡n: [
      "ä¸¸",
      "åˆ“",
      "å®Œ",
      "å²",
      "æŠ",
      "æ–",
      "æ±",
      "çƒ·",
      "çŽ©",
      "ç“",
      "ç¬‚",
      "ç´ˆ",
      "çº¨",
      "ç¿«",
      "èŠ„",
      "è²¦",
      "é ‘",
      "é¡½"
    ],
    dÄn: [
      "ä¸¹",
      "å‹¯",
      "åŒ°",
      "å˜",
      "å¦‰",
      "åª…",
      "æ®š",
      "æ®«",
      "ç””",
      "çœˆ",
      "ç ƒ",
      "ç®ª",
      "ç°ž",
      "è€¼",
      "è€½",
      "èƒ",
      "è¸",
      "è¤",
      "è¥Œ",
      "èº­",
      "éƒ¸",
      "é„²",
      "é…–",
      "é •"
    ],
    "wÃ¨i wÃ©i": ["ä¸º"],
    "jÇng dÇŽn": ["ä¸¼"],
    "lÃ¬ lÃ­": ["ä¸½"],
    jÇ”: [
      "ä¸¾",
      "å¼†",
      "æŒ™",
      "æ“§",
      "æ¤‡",
      "æ¦‰",
      "æ¦˜",
      "æ«¸",
      "æ¬…",
      "çŸ©",
      "ç­¥",
      "è¥",
      "èˆ‰",
      "èŽ’",
      "è’Ÿ",
      "è¥·",
      "è¸½",
      "é½Ÿ",
      "é¾ƒ"
    ],
    piÄ›: ["ä¸¿", "è‹¤", "é…", "ð¬­¯"],
    fÃº: [
      "ä¹€",
      "ä¼",
      "ä¿˜",
      "å‡«",
      "åˆœ",
      "åŒ",
      "å’ˆ",
      "å“¹",
      "åž˜",
      "å­š",
      "å²ª",
      "å·¿",
      "å¸—",
      "å¹…",
      "å¹ž",
      "å¼—",
      "å½¿",
      "æ€«",
      "æ‰¶",
      "æŸ«",
      "æ ¿",
      "æ¡´",
      "æ°Ÿ",
      "æ³­",
      "æµ®",
      "æ¶ª",
      "æ¾“",
      "ç‚¥",
      "çŽ¸",
      "ç”¶",
      "ç•‰",
      "ç™",
      "ç¥“",
      "ç¦",
      "ç¨ª",
      "ç¬¦",
      "ç®™",
      "ç´±",
      "ç´¼",
      "çµ¥",
      "ç¶",
      "ç»‚",
      "ç»‹",
      "ç½˜",
      "ç½¦",
      "ç¿‡",
      "è‰€",
      "èŠ™",
      "èŠ£",
      "è‹»",
      "èŒ€",
      "èŒ¯",
      "è”",
      "è‘",
      "è™™",
      "èš¨",
      "èœ‰",
      "è ",
      "è¢š",
      "è¢±",
      "è¥†",
      "è¥¥",
      "è«¨",
      "è±§",
      "è¸¾",
      "è¼»",
      "è¾",
      "éƒ›",
      "é‰˜",
      "é‰œ",
      "éŸ",
      "éŸ¨",
      "é¢«",
      "é«´",
      "é®„",
      "é®²",
      "é³§",
      "é³¬",
      "é´”",
      "éµ©",
      "é»»"
    ],
    "yÃ­ jÃ­": ["ä¹"],
    yÃ¬: [
      "ä¹‚",
      "ä¹‰",
      "äº„",
      "äº¦",
      "äº¿",
      "ä¼‡",
      "ä¼¿",
      "ä½¾",
      "ä¿‹",
      "å„„",
      "å…¿",
      "åˆˆ",
      "åŠ“",
      "åŠ®",
      "å‹š",
      "å‹©",
      "åŒ‡",
      "å‘“",
      "å‘­",
      "å‘¹",
      "å”ˆ",
      "å›ˆ",
      "åœ›",
      "å„",
      "åž¼",
      "åŸ¸",
      "å¥•",
      "å«•",
      "å¬‘",
      "å¯±",
      "å±¹",
      "å³„",
      "å¶§",
      "å¸Ÿ",
      "å¸ ",
      "å¹†",
      "å»™",
      "å¼‚",
      "å¼ˆ",
      "å¼‹",
      "å½¹",
      "å¿†",
      "æ€ˆ",
      "æ€¿",
      "æ‚’",
      "æ„",
      "æ†¶",
      "æ‡Œ",
      "æ‡¿",
      "æŠ‘",
      "æŒ¹",
      "æ•¡",
      "æ˜“",
      "æ™¹",
      "æ›€",
      "æ›Ž",
      "æ™",
      "æž",
      "æ£­",
      "æ¦",
      "æ§¸",
      "æª",
      "æ­",
      "æ®”",
      "æ®ª",
      "æ®¹",
      "æ¯…",
      "æµ‚",
      "æµ¥",
      "æµ³",
      "æ¹™",
      "æº¢",
      "æ½©",
      "æ¾º",
      "ç€·",
      "ç‚ˆ",
      "ç„²",
      "ç† ",
      "ç†¤",
      "ç†¼",
      "ç‡š",
      "ç‡¡",
      "ç‡±",
      "çˆ",
      "çŽ´",
      "ç•°",
      "ç–«",
      "ç—¬",
      "ç˜—",
      "ç˜ž",
      "ç˜±",
      "ç™”",
      "ç›Š",
      "çž–",
      "ç©“",
      "ç«©",
      "ç¯’",
      "ç¸Š",
      "ç¹¶",
      "ç¹¹",
      "ç»Ž",
      "ç¼¢",
      "ç¾©",
      "ç¾¿",
      "ç¿Š",
      "ç¿Œ",
      "ç¿³",
      "ç¿¼",
      "è€´",
      "è‚„",
      "è‚Š",
      "è†‰",
      "è‡†",
      "è‰—",
      "è‰º",
      "èŠ…",
      "è‹…",
      "èŸ",
      "è“º",
      "è–",
      "è—™",
      "è—",
      "è˜™",
      "è™‰",
      "èœ´",
      "èž ",
      "è¡ª",
      "è¢£",
      "è£”",
      "è£›",
      "è¤¹",
      "è¥¼",
      "è¨²",
      "è¨³",
      "è©",
      "è©£",
      "èª¼",
      "è­¯",
      "è­°",
      "è®›",
      "è®®",
      "è¯‘",
      "è¯£",
      "è°Š",
      "è±™",
      "è±›",
      "è±·",
      "è²–",
      "è´€",
      "è·‡",
      "è½¶",
      "é€¸",
      "é‚‘",
      "é„“",
      "é†·",
      "é‡´",
      "éˆ ",
      "éŽ°",
      "é¿",
      "é•’",
      "é•±",
      "é˜£",
      "éš¿",
      "éœ¬",
      "é¥",
      "é§…",
      "é©›",
      "é©¿",
      "éª®",
      "é®¨",
      "é¶‚",
      "é¶ƒ",
      "é¶",
      "é·",
      "é·Š",
      "é·§",
      "é·¾",
      "é¸ƒ",
      "é¹",
      "é¹¢",
      "é»“",
      "é½¸",
      "ð¬¬©",
      "ã‘Š",
      "ð«„·",
      "ð¬Ÿ"
    ],
    nÇŽi: ["ä¹ƒ", "å€·", "å¥¶", "å¬­", "å»¼", "æ°–", "ç–“", "è‰¿", "è¿º", "é‡¢"],
    wÇ”: [
      "ä¹„",
      "äº”",
      "ä»µ",
      "ä¼",
      "ä¾®",
      "å€µ",
      "å„›",
      "åˆ",
      "å•Ž",
      "å¦©",
      "å¨¬",
      "å«µ",
      "åº‘",
      "å»¡",
      "å¿¤",
      "æ€ƒ",
      "æ†®",
      "æ‘€",
      "æ­¦",
      "æ½•",
      "ç†“",
      "ç‰¾",
      "çŽ",
      "ç·",
      "ç‘¦",
      "ç”’",
      "ç¢”",
      "èˆž",
      "èºŒ",
      "è¿•",
      "é€œ",
      "é™š",
      "éµ¡",
      "é¹‰",
      "ð£²˜"
    ],
    jiÇ”: [
      "ä¹…",
      "ä¹†",
      "ä¹",
      "ä¹£",
      "å¥º",
      "æ¦",
      "æ±£",
      "ç¸",
      "çŽ–",
      "ç´¤",
      "èˆ",
      "é…’",
      "é•¹",
      "éŸ­",
      "éŸ®"
    ],
    "tuÅ zhÃ©": ["ä¹‡", "æ”", "é¦²"],
    "me mÃ³ ma yÄo": ["ä¹ˆ"],
    zhÄ«: [
      "ä¹‹",
      "å€",
      "å®",
      "å·µ",
      "æ˜",
      "æ”¯",
      "æ €",
      "æ¢”",
      "æ¤¥",
      "æ¦°",
      "æ±",
      "æ³œ",
      "ç–·",
      "ç¥—",
      "ç¥¬",
      "ç§“",
      "ç¨™",
      "ç¶•",
      "è‚¢",
      "èƒ‘",
      "èƒ",
      "è„‚",
      "èŠ",
      "è˜µ",
      "èœ˜",
      "è¡¼",
      "éš»",
      "é³·",
      "é´²",
      "é¼…",
      "ð¦­œ"
    ],
    "wÅ« wÃ¹": ["ä¹Œ"],
    zhÃ : [
      "ä¹",
      "å’¤",
      "å®±",
      "æ¾",
      "æ¦¨",
      "æº ",
      "ç—„",
      "èš±",
      "è©",
      "è¯ˆ",
      "é†¡",
      "éœ…",
      "äƒŽ"
    ],
    hÅ«: [
      "ä¹Ž",
      "ä¹¯",
      "åŒ¢",
      "åŒ«",
      "å‘¼",
      "å”¿",
      "å˜‘",
      "åž€",
      "å¯£",
      "å¹ ",
      "å¿½",
      "æƒš",
      "æ˜’",
      "æ­‘",
      "æ³˜",
      "æ·´",
      "æ»¹",
      "çƒ€",
      "è‹¸",
      "è™",
      "è™–",
      "è¬¼",
      "è»¤",
      "è½·",
      "é›"
    ],
    fÃ¡: [
      "ä¹",
      "ä¼",
      "å‚ ",
      "åº",
      "åž¡",
      "å¢¢",
      "å§‚",
      "æ °",
      "æµŒ",
      "çž‚",
      "ç¬©",
      "ç­",
      "ç½š",
      "ç½°",
      "ç½¸",
      "è—…",
      "é–¥",
      "é˜€"
    ],
    "lÃ¨ yuÃ¨ yÃ o lÃ o": ["ä¹", "æ¨‚"],
    yÃ­n: [
      "ä¹‘",
      "åŸ",
      "å™–",
      "åšš",
      "åœ",
      "åž ",
      "å¤¤",
      "å©¬",
      "å¯…",
      "å³¾",
      "å´Ÿ",
      "å´¯",
      "æª­",
      "æ®¥",
      "æ³¿",
      "æ·«",
      "æ»›",
      "çƒŽ",
      "çŠ¾",
      "ç‹º",
      "ç’Œ",
      "ç¡",
      "ç¢’",
      "è¶",
      "è”©",
      "è¨”",
      "è¨š",
      "è¨¡",
      "èª¾",
      "é„ž",
      "éˆ",
      "éŠ€",
      "é“¶",
      "éœª",
      "é·£",
      "é½¦"
    ],
    pÄ«ng: ["ä¹’", "ä¿œ", "å¨‰", "æ¶„", "ç”¹", "ç ¯", "è ", "è‰µ", "é ©"],
    pÄng: ["ä¹“", "æ»‚", "èƒ®", "è†–", "é›±", "éœ¶"],
    qiÃ¡o: [
      "ä¹”",
      "ä¾¨",
      "åƒ‘",
      "å«¶",
      "æ†”",
      "æ¡¥",
      "æ§—",
      "æ¨µ",
      "æ©‹",
      "æ«µ",
      "çŠž",
      "çž§",
      "ç¡š",
      "ç¤„",
      "è",
      "èž",
      "è•Ž",
      "è—®",
      "è­™",
      "è¶«",
      "éˆ",
      "éž’",
      "éž½",
      "é¡¦"
    ],
    hÇ”: ["ä¹•", "ç¥", "è€", "è™Ž", "è™", "éŒ¿", "é¯±"],
    guÄi: ["ä¹–"],
    "chÃ©ng shÃ¨ng": ["ä¹—", "ä¹˜", "å¨"],
    yÇ: [
      "ä¹™",
      "ä¹›",
      "ä»¥",
      "å€š",
      "å¯",
      "å¬Ÿ",
      "å´º",
      "å·²",
      "åº¡",
      "æ‰†",
      "æ”º",
      "æ•¼",
      "æ—‘",
      "æ—–",
      "æª¥",
      "çŸ£",
      "ç¤’",
      "ç¬–",
      "èˆ£",
      "è‰¤",
      "è‹¡",
      "è‹¢",
      "èš",
      "èž˜",
      "èŸ»",
      "è£¿",
      "è¸¦",
      "è¼¢",
      "è½™",
      "é€˜",
      "é…",
      "é‡”",
      "éˆ˜",
      "é‰¯",
      "é’‡",
      "é¡—",
      "é³¦",
      "é½®",
      "ð«–®",
      "ð¬ºˆ"
    ],
    "hÃ¡o yÇ": ["ä¹š"],
    "niÃ¨ miÄ“": ["ä¹œ"],
    qÇ: [
      "ä¹ž",
      "ä¼",
      "å¯",
      "å”˜",
      "å•“",
      "å•”",
      "å•Ÿ",
      "å©",
      "å±º",
      "æž",
      "æ£¨",
      "çŽ˜",
      "ç›€",
      "ç¶º",
      "ç»®",
      "èŠ‘",
      "è«¬",
      "èµ·",
      "é‚”",
      "é—™"
    ],
    yÄ›: ["ä¹Ÿ", "å†¶", "å˜¢", "åŸœ", "å£„", "æ¼œ", "é‡Ž"],
    xÃ­: [
      "ä¹ ",
      "å–º",
      "åª³",
      "å¶",
      "å¸­",
      "æ¤º",
      "æª„",
      "æ¼",
      "ç¿’",
      "è“†",
      "è¢­",
      "è¥²",
      "è¦¡",
      "è§‹",
      "è¬µ",
      "è¶˜",
      "éƒ‹",
      "éŽ´",
      "éš°",
      "éœ«",
      "é£",
      "é¨±",
      "é¨½",
      "é©¨",
      "é°¼",
      "é³›",
      "ð …¤",
      "ð«˜¬"
    ],
    xiÄng: [
      "ä¹¡",
      "åŽ¢",
      "å»‚",
      "å¿€",
      "æ¥¿",
      "æ¬€",
      "æ¹˜",
      "ç“–",
      "ç¨¥",
      "ç®±",
      "ç·—",
      "ç¼ƒ",
      "è†·",
      "èŠ—",
      "è«",
      "è‘™",
      "è–Œ",
      "è¥„",
      "éƒ·",
      "é„‰",
      "é„Š",
      "é„•",
      "é‘²",
      "é•¶",
      "é¦™",
      "é©¤",
      "éª§",
      "é±œ",
      "éº˜",
      "ð¬™‹"
    ],
    shÅ«: [
      "ä¹¦",
      "å€",
      "å€",
      "å„µ",
      "å”",
      "å§",
      "å°—",
      "æŠ’",
      "æŽ“",
      "æ‘…",
      "æ”„",
      "æ›¸",
      "æž¢",
      "æ¢³",
      "æ¨ž",
      "æ®Š",
      "æ®³",
      "æ¯¹",
      "æ¯º",
      "æ·‘",
      "ç€­",
      "ç„‚",
      "ç–Ž",
      "ç–",
      "ç´“",
      "ç¶€",
      "çº¾",
      "èˆ’",
      "è½",
      "è”¬",
      "è¸ˆ",
      "è»—",
      "è¼¸",
      "è¾“",
      "é„ƒ",
      "é™Ž",
      "é®›",
      "éµ¨"
    ],
    dÇ’u: ["ä¹§", "æŠ–", "æž“", "èšª", "éˆ„", "é˜§", "é™¡"],
    shÇ: [
      "ä¹¨",
      "ä½¿",
      "å…˜",
      "å²",
      "å§‹",
      "å®©",
      "å±Ž",
      "æ¦",
      "çŸ¢",
      "ç¬¶",
      "è±•",
      "é‰‚",
      "é§›",
      "é©¶"
    ],
    jÄ«: [
      "ä¹©",
      "åƒŸ",
      "å‡»",
      "åˆ‰",
      "åˆ",
      "å‰ž",
      "å½",
      "å”§",
      "å–ž",
      "å—˜",
      "å˜°",
      "åœ¾",
      "åŸº",
      "å¢¼",
      "å§¬",
      "å±",
      "åµ†",
      "åµ‡",
      "æ’ƒ",
      "æ“Š",
      "æœž",
      "æœº",
      "æž…",
      "æ¨­",
      "æ©Ÿ",
      "æ¯„",
      "æ¿€",
      "çŠ„",
      "çŽ‘",
      "ç’£",
      "ç•¸",
      "ç•¿",
      "ç™ª",
      "çŸ¶",
      "ç£¯",
      "ç§¯",
      "ç©",
      "ç¬„",
      "ç­“",
      "ç®•",
      "ç°Š",
      "ç·",
      "ç¾",
      "ç¾‡",
      "ç¾ˆ",
      "è€­",
      "è‚Œ",
      "èŠ¨",
      "è™€",
      "è¦‰",
      "è¦Š",
      "è­",
      "è­¤",
      "è®¥",
      "è³«",
      "è³·",
      "èµ",
      "è·»",
      "è¸‘",
      "èº‹",
      "èº¸",
      "éŠˆ",
      "éŒ¤",
      "é–",
      "é‘‡",
      "é‘™",
      "éš®",
      "é›ž",
      "éž¿",
      "éŸ²",
      "é£¢",
      "é¥‘",
      "é¥¥",
      "é­•",
      "é³®",
      "é¶",
      "é¶º",
      "é·„",
      "é¸„",
      "é¸¡",
      "é½Ž",
      "é½",
      "é½‘",
      "ð¬¯€",
      "ð«“¯",
      "ð«“¹",
      "ð«Œ€"
    ],
    nÃ¡ng: ["ä¹ª", "åš¢", "æ¬œ", "è °", "é¥¢"],
    jiÄ: [
      "ä¹«",
      "ä½³",
      "å‚¢",
      "åŠ ",
      "å˜‰",
      "æŠ¸",
      "æž·",
      "æ¢œ",
      "æ¯ ",
      "æ³‡",
      "æµƒ",
      "æµ¹",
      "çŠŒ",
      "çŒ³",
      "çˆ",
      "ç—‚",
      "ç¬³",
      "ç³˜",
      "è€ž",
      "è…µ",
      "è‘­",
      "è¢ˆ",
      "è±­",
      "è²‘",
      "è·",
      "è¿¦",
      "é‰«",
      "éŽµ",
      "é•“",
      "é´",
      "éºš",
      "ð¬‚©"
    ],
    jÃ¹: [
      "ä¹¬",
      "å€¨",
      "å€¶",
      "å…·",
      "å‰§",
      "åŠ‡",
      "å‹®",
      "åŸ§",
      "åŸ¾",
      "å£‰",
      "å§–",
      "å±¦",
      "å±¨",
      "å² ",
      "å·¨",
      "å·ª",
      "æ€‡",
      "æƒ§",
      "æ„³",
      "æ‡…",
      "æ‡¼",
      "æ‹’",
      "æ‹ ",
      "æ˜›",
      "æ­«",
      "æ´°",
      "æ¾½",
      "ç‚¬",
      "çƒ¥",
      "çŠ‹",
      "ç§¬",
      "çª­",
      "çª¶",
      "ç°´",
      "ç²”",
      "è€Ÿ",
      "èš",
      "è™¡",
      "èš·",
      "è©Ž",
      "è®µ",
      "è±¦",
      "è·",
      "è¸ž",
      "èº†",
      "é½",
      "é‚­",
      "é†µ",
      "é‰…",
      "é»",
      "é’œ",
      "é¢¶",
      "é£“",
      "é§",
      "é®”"
    ],
    shÃ­: [
      "ä¹­",
      "å",
      "åŸ˜",
      "å¡’",
      "å§¼",
      "å®ž",
      "å®Ÿ",
      "å¯”",
      "å¯¦",
      "å³•",
      "åµµ",
      "æ—¶",
      "æ—¹",
      "æ™‚",
      "æ¦¯",
      "æ¹œ",
      "æº¡",
      "ç‚»",
      "ç¥",
      "ç«",
      "èš€",
      "è•",
      "è¾»",
      "éˆ",
      "é‰",
      "é£ ",
      "é¥£",
      "é®–",
      "é°£",
      "é²¥",
      "é¼«",
      "é¼­"
    ],
    mÇŽo: ["ä¹®", "å†‡", "å¯", "å³", "æˆ¼", "æ˜´", "æ³–", "ç¬·", "è“©", "é‰š", "é“†"],
    mÇŽi: ["ä¹°", "å˜ª", "è¬", "è•’", "è²·", "é·¶"],
    luÃ n: ["ä¹±", "äº‚", "é‡ "],
    rÇ”: ["ä¹³", "æ“©", "æ±", "è‚—", "è¾±", "é„"],
    xuÃ©: [
      "ä¹´",
      "å­¦",
      "å­¸",
      "å³ƒ",
      "å¶¨",
      "æ–ˆ",
      "æ³¶",
      "æ¾©",
      "ç‡¢",
      "ç©´",
      "èŒ“",
      "è¢•",
      "è¸…",
      "é·½",
      "é¸´"
    ],
    yÇŽn: [
      "ä¶®",
      "ä¹µ",
      "ä¿¨",
      "åƒ",
      "å„¼",
      "å…–",
      "å…—",
      "åŽ£",
      "åŽ´",
      "å™ž",
      "å­",
      "åµƒ",
      "å·˜",
      "å·š",
      "å¼‡",
      "æ„",
      "æˆ­",
      "æ‰Š",
      "æŠ",
      "æŽ©",
      "æœ",
      "æ›®",
      "æ¤¼",
      "æª¿",
      "æ²‡",
      "æ¸·",
      "æ¼”",
      "ç°",
      "ç”—",
      "çœ¼",
      "ç½¨",
      "è’",
      "è˜",
      "è¡",
      "è¤—",
      "èº½",
      "éƒ",
      "éƒ¾",
      "éš’",
      "é¡©",
      "é­‡",
      "é­˜",
      "é°‹",
      "é¶ ",
      "é»¡",
      "é»¤",
      "é»¬",
      "é»­",
      "é»¶",
      "é¼´",
      "é¼¹",
      "é½´",
      "é¾‘",
      "ð¬¸˜",
      "ð¬™‚",
      "ðª©˜"
    ],
    fÇ”: [
      "ä¹¶",
      "ä¿Œ",
      "ä¿›",
      "ä¿¯",
      "åºœ",
      "å¼£",
      "æŠš",
      "æ‹Š",
      "æ’«",
      "æ–§",
      "æ¤¨",
      "æ»",
      "ç„¤",
      "ç”«",
      "ç›™",
      "ç° ",
      "è…",
      "è…‘",
      "èœ…",
      "è¼”",
      "è¾…",
      "éƒ™",
      "é‡œ",
      "é‡¡",
      "é˜",
      "é «",
      "é¬´",
      "é»¼",
      "ã•®",
      "ð«–¯"
    ],
    shÄ: [
      "ä¹·",
      "å”¦",
      "æ€",
      "æ¡¬",
      "æ®º",
      "æ¯®",
      "çŒ€",
      "ç—§",
      "ç ‚",
      "ç¡°",
      "ç´—",
      "ç¹º",
      "çº±",
      "è”±",
      "è£Ÿ",
      "éŽ©",
      "é“©",
      "é–·",
      "é«¿",
      "é­¦",
      "é¯Š",
      "é¯‹",
      "é²¨"
    ],
    nÇŽ: ["ä¹¸", "é›«"],
    qiÃ¡n: [
      "ä¹¹",
      "äº",
      "ä»±",
      "å‚",
      "å‰",
      "å¢˜",
      "åªŠ",
      "å²’",
      "æ‹‘",
      "æŽ®",
      "æ¦©",
      "æ©¬",
      "æ­¬",
      "æ½›",
      "æ½œ",
      "æ¿³",
      "çŠ",
      "ç®",
      "è‘¥",
      "è™”",
      "è»¡",
      "éˆ",
      "é‰—",
      "éŠ­",
      "éŒ¢",
      "éŽ†",
      "é’¤",
      "é’±",
      "é’³",
      "é¬",
      "é¨š",
      "é¨",
      "é°¬",
      "é»”",
      "é»š"
    ],
    suÇ’: [
      "ä¹º",
      "å”¢",
      "å—©",
      "æ‰€",
      "æš›",
      "æº‘",
      "æº¹",
      "ç",
      "ç‘",
      "ç‘£",
      "ç´¢",
      "è¤¨",
      "éŽ–",
      "éŽ»",
      "é",
      "é”"
    ],
    yÃº: [
      "ä¹»",
      "äºŽ",
      "äº",
      "ä¼ƒ",
      "ä½™",
      "å £",
      "å ¬",
      "å¦¤",
      "å¨›",
      "å¨¯",
      "å¨±",
      "å¬©",
      "å´³",
      "åµŽ",
      "åµ›",
      "æ„š",
      "æ‰µ",
      "æ„",
      "æ—Ÿ",
      "æ¥¡",
      "æ¥°",
      "æ¦†",
      "æ¬¤",
      "æ­ˆ",
      "æ­Ÿ",
      "æ­¶",
      "æ¸”",
      "æ¸",
      "æ¹¡",
      "æ¼",
      "æ¾ž",
      "ç‰",
      "ç‹³",
      "çŽ—",
      "çŽ™",
      "ç‘œ",
      "ç’µ",
      "ç›‚",
      "ç®",
      "çª¬",
      "ç«½",
      "ç±…",
      "ç¾­",
      "è…´",
      "è‡¾",
      "èˆ",
      "èˆ†",
      "è‰…",
      "èŒ°",
      "è®",
      "è¸",
      "è•",
      "è˜›",
      "è™ž",
      "è™¶",
      "è“",
      "èž¸",
      "è¡§",
      "è¤•",
      "è¦¦",
      "è§Ž",
      "è«›",
      "è¬£",
      "è°€",
      "è¸°",
      "è¼¿",
      "è½",
      "é€¾",
      "é‚˜",
      "é…‘",
      "é",
      "éš…",
      "é›“",
      "é›©",
      "é¤˜",
      "é¦€",
      "é¨Ÿ",
      "éª¬",
      "é«ƒ",
      "é­š",
      "é­£",
      "é®½",
      "é¯²",
      "é°…",
      "é±¼",
      "é· ",
      "é¸†",
      "é½µ"
    ],
    zhÃ¹: [
      "ä¹¼",
      "ä¼«",
      "ä½‡",
      "ä½",
      "å¾",
      "å¢¸",
      "å£´",
      "åµ€",
      "æ‹€",
      "æ¼",
      "æŸ±",
      "æ¨¦",
      "æ®¶",
      "æ³¨",
      "ç‚·",
      "ç–°",
      "çœ",
      "ç¥",
      "ç¥©",
      "ç«š",
      "ç­¯",
      "ç®¸",
      "ç¯«",
      "ç°—",
      "ç´µ",
      "ç´¸",
      "çº»",
      "ç¾œ",
      "ç¿¥",
      "è‹Ž",
      "èŽ‡",
      "è›€",
      "è¨»",
      "è²¯",
      "è´®",
      "è·“",
      "è»´",
      "é‰’",
      "é‹³",
      "é‘„",
      "é“¸",
      "é¦µ",
      "é§",
      "é©»"
    ],
    zhÄ›: ["ä¹½", "è€…", "è¤¶", "è¥µ", "èµ­", "è¸·", "éº", "é”—"],
    "qiÃ¡n gÄn": ["ä¹¾"],
    "zhÃ¬ luÃ n": ["ä¹¿"],
    guÄ«: [
      "äº€",
      "åœ­",
      "å¦«",
      "åª¯",
      "å«¢",
      "å¬€",
      "å¸°",
      "å½’",
      "æ‘«",
      "æ¤",
      "æ§»",
      "æ§¼",
      "æ«·",
      "æ­¸",
      "çª",
      "ç‘°",
      "ç’",
      "ç“Œ",
      "çšˆ",
      "çž¡",
      "ç¡…",
      "èŒ¥",
      "è˜¬",
      "è¦",
      "è§„",
      "é‚½",
      "éƒŒ",
      "é–¨",
      "é—º",
      "é¨©",
      "é¬¶",
      "é¬¹"
    ],
    "lÇn lÃ¬n": ["äºƒ"],
    juÃ©: [
      "äº…",
      "å†³",
      "åˆ”",
      "åŠ‚",
      "åŒ·",
      "åŽ¥",
      "å™Š",
      "å­’",
      "å­“",
      "å´›",
      "å´«",
      "å¶¥",
      "å½",
      "æ† ",
      "æ†°",
      "æˆ„",
      "æŠ‰",
      "æŒ—",
      "æŽ˜",
      "æ”«",
      "æ¡·",
      "æ©›",
      "æ©œ",
      "æ¬®",
      "æ°’",
      "æ±º",
      "ç",
      "ç„³",
      "ç†¦",
      "çˆ‘",
      "çˆ´",
      "çˆµ",
      "ç—",
      "çŽƒ",
      "çŽ¦",
      "çŽ¨",
      "ç",
      "ç‘´",
      "ç˜š",
      "çŸ",
      "çŸ¡",
      "ç „",
      "çµ•",
      "çµ¶",
      "ç»",
      "è‡„",
      "èŠµ",
      "è•",
      "è•¨",
      "è™³",
      "èŸ¨",
      "èŸ©",
      "è§–",
      "è§®",
      "è§¼",
      "è¨£",
      "è­Ž",
      "è¯€",
      "è°²",
      "è²œ",
      "èµ½",
      "è¶‰",
      "è¹·",
      "èº©",
      "éˆŒ",
      "é",
      "é",
      "é’",
      "é•¢",
      "é´‚",
      "é´ƒ",
      "é·¢",
      "ð«˜",
      "ãµ",
      "ð«”Ž"
    ],
    "le liÇŽo": ["äº†"],
    "gÃ¨ mÄ": ["äº‡"],
    "yÇ” yÃº": ["äºˆ", "æ‡™"],
    zhÄ“ng: [
      "äº‰",
      "ä½‚",
      "å‡§",
      "å§ƒ",
      "åªœ",
      "å³¥",
      "å´",
      "å´¢",
      "å¾",
      "å¾°",
      "ç‚¡",
      "çƒ",
      "çˆ­",
      "ç‹°",
      "çŒ™",
      "ç™¥",
      "çœ",
      "ç",
      "çœ",
      "ç­",
      "ç®",
      "ç¯œ",
      "è‡",
      "è„€",
      "è’¸",
      "è¸­",
      "é‰¦",
      "éŒš",
      "é³",
      "é¬‡"
    ],
    Ã¨r: ["äºŒ", "åˆµ", "å’¡", "å¼", "å¼", "æ¨²", "èª€", "è²®", "è²³", "è´°", "é«¶"],
    chÃ¹: [
      "äº",
      "å‚—",
      "å„Š",
      "æ€µ",
      "æ†·",
      "æ",
      "æ–¶",
      "æ­œ",
      "ç¿",
      "ç¡",
      "çŸ—",
      "ç«Œ",
      "çµ€",
      "ç»Œ",
      "è‡…",
      "è§¦",
      "è§¸",
      "è±–",
      "é„",
      "é–¦",
      "é»œ"
    ],
    kuÄ«: ["äº", "åˆ²", "å²¿", "å·‹", "ç›”", "çª¥", "çªº", "è§", "è™§", "é—š", "é¡"],
    yÃºn: [
      "äº‘",
      "ä¼",
      "å‹»",
      "åŒ€",
      "å›©",
      "å¦˜",
      "æ„ª",
      "æŠ£",
      "æ˜€",
      "æ©’",
      "æ²„",
      "æ¶¢",
      "æº³",
      "æ¾",
      "ç†‰",
      "ç•‡",
      "ç§",
      "ç­¼",
      "ç¯”",
      "ç´œ",
      "ç¸œ",
      "çº­",
      "è€˜",
      "èŠ¸",
      "è’·",
      "è•“",
      "éƒ§",
      "é„–",
      "é‹†",
      "é›²"
    ],
    hÃ¹: [
      "äº’",
      "å†±",
      "å—€",
      "åš›",
      "å©Ÿ",
      "å«­",
      "å«®",
      "å²µ",
      "å¸",
      "å¼–",
      "æ€™",
      "æˆ¶",
      "æˆ·",
      "æˆ¸",
      "æˆ½",
      "æ‰ˆ",
      "æŠ¤",
      "æ˜ˆ",
      "æ§´",
      "æ²",
      "æ²ª",
      "æ»¬",
      "ç†©",
      "ç“ ",
      "ç¥œ",
      "ç¬",
      "ç°„",
      "ç²",
      "ç¶”",
      "è”°",
      "è­·",
      "è±°",
      "é„ ",
      "é™",
      "é €",
      "é±¯",
      "é³ ",
      "é³¸",
      "é¸Œ",
      "é¹±"
    ],
    qÃ­: [
      "äº“",
      "å‰˜",
      "åŸ¼",
      "å²",
      "å²“",
      "å´Ž",
      "åµœ",
      "æ„­",
      "æŽ‘",
      "æ–‰",
      "æ–Š",
      "æ—‚",
      "æ——",
      "æ£Š",
      "æ£‹",
      "æª±",
      "æ«€",
      "æ­§",
      "æ·‡",
      "æ¿",
      "çŒ‰",
      "çŽ‚",
      "ç¦",
      "çª",
      "ç’‚",
      "ç•¦",
      "ç–§",
      "ç¢",
      "ç¢•",
      "ç¥",
      "ç¥ˆ",
      "ç¥º",
      "ç¦¥",
      "ç«’",
      "ç°¯",
      "ç°±",
      "ç±",
      "ç²¸",
      "ç¶¥",
      "ç¶¦",
      "è‚µ",
      "è„",
      "è‡",
      "è‰©",
      "èŠª",
      "è",
      "è•",
      "è•²",
      "è—„",
      "è˜„",
      "èš‘",
      "èšš",
      "è›´",
      "èœ",
      "èœž",
      "èž§",
      "è ",
      "è¤€",
      "è»",
      "é„¿",
      "é‡®",
      "éŒ¡",
      "é”œ",
      "é™­",
      "é Ž",
      "é¢€",
      "é¨Ž",
      "é¨",
      "é¨¹",
      "éª",
      "éª‘",
      "é¬",
      "é¬¿",
      "é¯•",
      "é°­",
      "é²¯",
      "é³",
      "éµ¸",
      "é¶€",
      "éº’",
      "éº¡",
      "ð¨™¸",
      "ð¬¨‚",
      "ä“«"
    ],
    jÇng: [
      "äº•",
      "å„†",
      "åˆ­",
      "å‰„",
      "å“",
      "å®‘",
      "å¹œ",
      "æ†¬",
      "æš»",
      "æ®Œ",
      "æ±«",
      "æ±¬",
      "æ¾‹",
      "ç’„",
      "ç’Ÿ",
      "ç’¥",
      "ç©½",
      "è‚¼",
      "èŸ¼",
      "è­¦",
      "é˜±",
      "é š",
      "é ¸"
    ],
    sÃ¬: [
      "äº–",
      "ä½€",
      "ä¾¡",
      "å„©",
      "å…•",
      "å—£",
      "å››",
      "å§’",
      "å¨°",
      "å­ ",
      "å¯º",
      "å·³",
      "æŸ¶",
      "æ¦¹",
      "æ±œ",
      "æ³—",
      "æ³¤",
      "æ´",
      "æ´ ",
      "æ¶˜",
      "ç€ƒ",
      "ç‰­",
      "ç¥€",
      "ç¦©",
      "ç«¢",
      "ç¬¥",
      "è€œ",
      "è‚‚",
      "è‚†",
      "è•¼",
      "è¦—",
      "è²„",
      "é‡²",
      "éˆ¶",
      "éˆ»",
      "é£¤",
      "é£¼",
      "é¥²",
      "é§Ÿ",
      "é¨ƒ",
      "é©·"
    ],
    suÃ¬: [
      "äº—",
      "å¬˜",
      "å²",
      "åµ—",
      "æ—ž",
      "æª–",
      "æ­²",
      "æ­³",
      "æ¾»",
      "ç…«",
      "ç‡§",
      "ç’²",
      "ç •",
      "ç¢Ž",
      "ç¥Ÿ",
      "ç¦­",
      "ç©‚",
      "ç©—",
      "ç©Ÿ",
      "ç¹€",
      "ç¹",
      "ç¹¸",
      "è¥š",
      "èª¶",
      "è­¢",
      "è°‡",
      "è³¥",
      "é‚ƒ",
      "é†",
      "é©",
      "éš§",
      "éŸ¢",
      "ð«Ÿ¦",
      "ð¬­¼"
    ],
    gÃ¨n: ["äº˜", "äº™", "æ¯", "æ„", "èŒ›"],
    yÃ : [
      "äºš",
      "äºœ",
      "ä¿¹",
      "å†´",
      "åŠœ",
      "åœ”",
      "åœ ",
      "åŸ¡",
      "å¨…",
      "å©­",
      "æ ",
      "æ°©",
      "æ°¬",
      "çŠ½",
      "ç ‘",
      "ç¨",
      "è",
      "è¥¾",
      "è¦€",
      "è¨",
      "è®¶",
      "è¿“",
      "é½¾"
    ],
    "xiÄ“ suÃ²": ["äº›"],
    "qÃ­ zhÄi": ["äº", "é½Š"],
    "yÄ yÃ ": ["äºž", "åŽ‹", "åž­", "å£“", "é“”"],
    "jÃ­ qÃ¬": ["äºŸ", "ç„"],
    tÃ³u: ["äº ", "æŠ•", "é ­", "éª°"],
    "wÃ¡ng wÃº": ["äº¡"],
    "kÃ ng hÃ¡ng gÄng": ["äº¢"],
    dÃ : ["äº£", "çœ”"],
    jiÄo: [
      "äº¤",
      "åƒ¬",
      "å¨‡",
      "å¬Œ",
      "å³§",
      "å¶•",
      "å¶£",
      "æ†",
      "æ¤’",
      "æµ‡",
      "æ¾†",
      "ç„¦",
      "ç¤",
      "ç©š",
      "ç°¥",
      "èƒ¶",
      "è† ",
      "è†²",
      "èŒ­",
      "èŒ®",
      "è•‰",
      "è™ ",
      "è›Ÿ",
      "èŸ­",
      "è·¤",
      "è½‡",
      "éƒŠ",
      "éŽ",
      "é©•",
      "éª„",
      "é®«",
      "é²›",
      "éµ",
      "é·¦",
      "é·®",
      "é¹ª",
      "ä´”"
    ],
    hÃ i: ["äº¥", "å—", "å®³", "æ°¦", "é¤€", "é¥š", "é§­", "é§´", "éª‡"],
    "hÄ“ng pÄ“ng": ["äº¨"],
    mÇ”: [
      "äº©",
      "å§†",
      "å³”",
      "æ‹‡",
      "æ¯",
      "ç‰¡",
      "ç‰³",
      "ç•‚",
      "ç•†",
      "ç•’",
      "ç•",
      "ç•ž",
      "ç•®",
      "ç ª",
      "èƒŸ",
      "è¸‡",
      "é‰§",
      "ð¬­",
      "ð§¿¹"
    ],
    ye: ["äºª"],
    xiÇŽng: [
      "äº«",
      "äº¯",
      "å“",
      "æƒ³",
      "æ™‘",
      "èšƒ",
      "è ",
      "éŸ¿",
      "é£¨",
      "é¤‰",
      "é¥—",
      "é¥·",
      "é®",
      "é¯—",
      "é±¶",
      "é²ž"
    ],
    jÄ«ng: [
      "äº¬",
      "äº°",
      "å…¢",
      "å•",
      "å™",
      "å©›",
      "æƒŠ",
      "æ—Œ",
      "æ—",
      "æ™¶",
      "æ©¸",
      "æ³¾",
      "æ¶‡",
      "çŒ„",
      "ç›",
      "ç§”",
      "ç¨‰",
      "ç²³",
      "ç²¾",
      "çµŒ",
      "ç¶“",
      "ç¶¡",
      "è™",
      "è…ˆ",
      "èŒŽ",
      "è†",
      "èŠ",
      "è",
      "è‘",
      "é©š",
      "é¯¨",
      "é²¸",
      "é¶",
      "é¶„",
      "éº–",
      "éº ",
      "é¼±",
      "ä´–"
    ],
    tÃ­ng: [
      "äº­",
      "åœ",
      "å©·",
      "åµ‰",
      "åº­",
      "å»·",
      "æ¥Ÿ",
      "æ¦³",
      "ç­³",
      "è¤",
      "èŽ›",
      "è‘¶",
      "èœ“",
      "è",
      "è«ª",
      "é‚’",
      "éœ†",
      "é¼®",
      "ä—´"
    ],
    liÃ ng: ["äº®", "å–¨", "æ‚¢", "æ™¾", "æ¹¸", "è«’", "è°…", "è¼Œ", "è¼›", "è¾†", "é„"],
    "qÄ«n qÃ¬ng": ["äº²", "è¦ª"],
    bÃ³: [
      "äº³",
      "ä»¢",
      "ä¾¼",
      "åƒ°",
      "åš",
      "å¸›",
      "æ„½",
      "æ‡ª",
      "æŒ¬",
      "æ",
      "æ¬‚",
      "æµ¡",
      "æ·¿",
      "æ¸¤",
      "ç…¿",
      "ç‰”",
      "ç‹›",
      "ç“",
      "ç¤´",
      "ç§¡",
      "ç®”",
      "ç°™",
      "ç³ª",
      "èƒ‰",
      "è„–",
      "è†Š",
      "èˆ¶",
      "è‰Š",
      "è¡",
      "è‘§",
      "è¢¯",
      "è¥",
      "è¥®",
      "è¬ˆ",
      "è¸£",
      "éƒ£",
      "éˆ¸",
      "é‰‘",
      "é‹",
      "éŽ›",
      "é‘®",
      "é’¹",
      "é“‚",
      "é•ˆ",
      "é¤º",
      "é¦Ž",
      "é¦›",
      "é¦ž",
      "é§",
      "é§®",
      "é©³",
      "é«†",
      "éµ“",
      "é¹"
    ],
    yÃ²u: [
      "äº´",
      "ä½‘",
      "ä½¦",
      "ä¾‘",
      "åˆ",
      "å³",
      "å“Š",
      "å”€",
      "å›¿",
      "å§·",
      "å®¥",
      "å³Ÿ",
      "å¹¼",
      "ç‹–",
      "ç¥",
      "èš´",
      "èª˜",
      "è¯±",
      "è²",
      "è¿¶",
      "é…­",
      "é‡‰",
      "é¼¬"
    ],
    xiÃ¨: [
      "äºµ",
      "ä¼³",
      "åž",
      "å°",
      "åƒ",
      "å¨",
      "å¸",
      "å™§",
      "å¡®",
      "å¤‘",
      "åªŸ",
      "å±‘",
      "å±§",
      "å»¨",
      "å¾¢",
      "æ‡ˆ",
      "æš¬",
      "æ¢°",
      "æ¦",
      "æ¦­",
      "æ³»",
      "æ´©",
      "æ¸«",
      "æ¾¥",
      "ç€‰",
      "ç€£",
      "çº",
      "ç‚§",
      "ç‚¨",
      "ç‡®",
      "çˆ•",
      "ç¬",
      "ç¥„",
      "ç¦¼",
      "ç³",
      "ç´²",
      "çµ",
      "çµ¬",
      "ç¹²",
      "çºˆ",
      "ç»",
      "ç¼·",
      "è–¢",
      "è–¤",
      "èŸ¹",
      "è ",
      "è¤‰",
      "è¤»",
      "è¬",
      "è°¢",
      "èºž",
      "é‚‚",
      "é¾",
      "éŸ°",
      "é½‚",
      "é½˜",
      "é½›",
      "é½¥",
      "ð¬¹¼",
      "ð¤«‰"
    ],
    "dÇŽn dÃ n": ["äº¶", "é¦¾"],
    liÃ¡n: [
      "äº·",
      "åŠ†",
      "åŒ²",
      "åŒ³",
      "å—¹",
      "å™’",
      "å¥",
      "å¥©",
      "å«¾",
      "å¸˜",
      "å»‰",
      "æ€œ",
      "æ†",
      "æ¶Ÿ",
      "æ¼£",
      "æ¿‚",
      "æ¿“",
      "ç€®",
      "ç†‘",
      "ç‡«",
      "ç°¾",
      "ç±¢",
      "ç±¨",
      "ç¸º",
      "ç¿´",
      "è”",
      "è¨",
      "è«",
      "è®",
      "è¯",
      "è‡",
      "èŽ²",
      "è“®",
      "è–•",
      "èžŠ",
      "è Š",
      "è£¢",
      "è¤³",
      "è¦",
      "è¬°",
      "è¹¥",
      "è¿ž",
      "é€£",
      "éŽŒ",
      "é®",
      "é•°",
      "é¬‘",
      "é°±",
      "é²¢"
    ],
    duÇ’: [
      "äº¸",
      "å“š",
      "åš²",
      "åŸµ",
      "å´œ",
      "æœµ",
      "æœ¶",
      "ç¶ž",
      "ç¼",
      "è¶“",
      "èº±",
      "èº²",
      "è»ƒ"
    ],
    "wÄ›i mÃ©n": ["äº¹", "æ––"],
    rÃ©n: ["äºº", "äº»", "ä»", "å£¬", "å¿ˆ", "å¿Ž", "æœ²", "ç§‚", "èŠ¢", "é­œ", "éµ€"],
    jÃ­: [
      "äº¼",
      "äº½",
      "ä¼‹",
      "ä½¶",
      "å®",
      "å™",
      "å³",
      "å½",
      "åŠ",
      "å",
      "å‰",
      "å ²",
      "å¡‰",
      "å§ž",
      "å«‰",
      "å²Œ",
      "åµ´",
      "å¶¯",
      "å½¶",
      "å¿£",
      "æ€¥",
      "æ„±",
      "æˆ¢",
      "æ¤",
      "æž",
      "æ£˜",
      "æ¥«",
      "æ¥µ",
      "æ§‰",
      "æª",
      "æ®›",
      "æ±²",
      "æ¹’",
      "æ½—",
      "ç–¾",
      "ç˜ ",
      "çš",
      "ç¬ˆ",
      "ç®¿",
      "ç±",
      "ç´š",
      "çº§",
      "è†Œ",
      "è‰¥",
      "è’º",
      "è•€",
      "è•º",
      "è",
      "èž",
      "è¥‹",
      "è§™",
      "è°»",
      "è¸–",
      "è¹",
      "èº¤",
      "è¼¯",
      "è½š",
      "è¾‘",
      "éƒ†",
      "éŠ¡",
      "é“",
      "é¶",
      "é›†",
      "é›§",
      "éœµ",
      "é¹¡",
      "ã´”"
    ],
    wÃ¡ng: ["äº¾", "ä»¼", "å…¦", "èŽ£", "èšŸ"],
    "shÃ©n shÃ­": ["ä»€"],
    lÃ¨: [
      "ä»‚",
      "å»",
      "å¿‡",
      "æ°»",
      "æ³",
      "çŽ",
      "ç ³",
      "ç°•",
      "è‰»",
      "é˜ž",
      "éŸ·",
      "é¤Ž",
      "é°³",
      "é±³",
      "é³“"
    ],
    dÄ«ng: ["ä»ƒ", "å®", "å¸„", "çŽŽ", "ç–”", "ç›¯", "è€µ", "è™°", "éª"],
    zÃ¨: ["ä»„", "å´±", "åº‚", "æ‘", "æ˜ƒ", "æ˜—", "æ±„"],
    "jÇn jÃ¬n": ["ä»…", "åƒ…", "å«¤"],
    "pÃº pÅ«": ["ä»†"],
    "chÃ³u qiÃº": ["ä»‡"],
    zhÇŽng: ["ä»‰", "å¹¥", "æŽŒ", "ç¤ƒ"],
    jÄ«n: [
      "ä»Š",
      "å »",
      "å·¾",
      "æƒ",
      "æ–¤",
      "æ´¥",
      "ç’",
      "ç»",
      "ç’¡",
      "ç ›",
      "ç­‹",
      "è•",
      "è¡¿",
      "è¥Ÿ",
      "è§”",
      "é‡‘",
      "é‡’",
      "é‡¿",
      "é’…",
      "é¹¶",
      "é»…",
      "ð¬¬±"
    ],
    bÄ«ng: ["ä»Œ", "ä»’", "å…µ", "å†«", "å†°", "æŽ¤", "æ°·", "é‹²"],
    rÃ©ng: ["ä»", "ç¤½", "èŠ¿", "è¾¸", "é™¾"],
    fÃ³: ["ä»", "å²", "æ¢»"],
    "jÄ«n sÇŽn": ["ä»"],
    lÃºn: [
      "ä»‘",
      "ä¼¦",
      "ä¾–",
      "å€«",
      "å›µ",
      "åœ‡",
      "å©¨",
      "å´˜",
      "å´™",
      "æ£†",
      "æ²¦",
      "æ·ª",
      "ç£®",
      "è…€",
      "è•",
      "èœ¦",
      "è¸š",
      "è¼ª",
      "è½®",
      "éŒ€",
      "é™¯",
      "é¯©",
      "ð¬¬­"
    ],
    cÄng: [
      "ä»“",
      "ä»º",
      "å€‰",
      "å‡”",
      "åµ¢",
      "æ²§",
      "æ»„",
      "æ¿¸",
      "çŠ",
      "èˆ±",
      "è‰™",
      "è‹",
      "è’¼",
      "èž¥",
      "é¸§"
    ],
    "zÇŽi zÇ zÄ«": ["ä»”"],
    tÄ: ["ä»–", "å¡Œ", "å®ƒ", "æ¦™", "æº»", "ç‰ ", "ç¥‚", "è¤Ÿ", "è¶¿", "é¢", "é—§"],
    fÃ¹: [
      "ä»˜",
      "å©",
      "å‚…",
      "å†¨",
      "å‰¯",
      "å’",
      "å¿",
      "å¤",
      "å¦‡",
      "å©¦",
      "åª",
      "å¬”",
      "å¯Œ",
      "å¾©",
      "æ¤±",
      "ç¥”",
      "ç¦£",
      "ç«Ž",
      "ç·®",
      "ç¸›",
      "ç¼š",
      "è…¹",
      "è¯",
      "è•§",
      "èš¹",
      "è›—",
      "èœ",
      "è®",
      "è¢",
      "è¤‡",
      "è¦„",
      "è¦†",
      "è¨ƒ",
      "è©‚",
      "è®£",
      "è² ",
      "è³¦",
      "è³»",
      "è´Ÿ",
      "èµ‹",
      "èµ™",
      "èµ´",
      "è¼¹",
      "é‘",
      "é¢",
      "é˜œ",
      "é™„",
      "é¦¥",
      "é§™",
      "é©¸",
      "é®’",
      "é°’",
      "é²‹",
      "é³†",
      "ã³‡"
    ],
    xiÄn: [
      "ä»™",
      "ä»š",
      "ä½¡",
      "åƒŠ",
      "åƒ²",
      "å…ˆ",
      "å˜•",
      "å¥¾",
      "å±³",
      "å»¯",
      "å¿º",
      "æ†¸",
      "æŽ€",
      "æš¹",
      "æ´",
      "æ°™",
      "ç—",
      "ç¥†",
      "ç§ˆ",
      "ç±¼",
      "ç¹Š",
      "çºŽ",
      "çº–",
      "è‹®",
      "è¤¼",
      "è¥³",
      "è·¹",
      "è¹®",
      "èºš",
      "é…°",
      "é",
      "é”¨",
      "éŸ¯",
      "éŸ±",
      "é¦¦",
      "é±»",
      "é¶±",
      "ð¬¸£"
    ],
    "tuÅ chÃ  duÃ³": ["ä»›"],
    hÃ³ng: [
      "ä»œ",
      "å°",
      "åž¬",
      "å¦…",
      "å¨‚",
      "å®",
      "å®–",
      "å¼˜",
      "å½‹",
      "æ±¯",
      "æ³“",
      "æ´ª",
      "æµ¤",
      "æ¸±",
      "æ½‚",
      "çŽ’",
      "çŽœ",
      "ç«‘",
      "ç«¤",
      "ç¯Š",
      "ç² ",
      "ç´˜",
      "ç´­",
      "ç¶‹",
      "çº®",
      "ç¿ƒ",
      "ç¿",
      "è€¾",
      "è‹°",
      "è­",
      "è‘’",
      "è‘“",
      "è°¹",
      "è°¼",
      "éˆœ",
      "é‰·",
      "é‹",
      "é–Ž",
      "é—³",
      "éœ",
      "éœŸ",
      "éžƒ",
      "é­Ÿ",
      "é´»",
      "é¸¿",
      "é»‰",
      "é»Œ",
      "ð«Ÿ¹",
      "ð¬­Ž"
    ],
    tÃ³ng: [
      "ä»",
      "ä½Ÿ",
      "å“ƒ",
      "å³‚",
      "å³",
      "åº",
      "å½¤",
      "æ™",
      "æ›ˆ",
      "æ¡",
      "æ°ƒ",
      "æµµ",
      "æ½¼",
      "çŠ",
      "çž",
      "çœ®",
      "çž³",
      "ç ¼",
      "ç§±",
      "ç«¥",
      "ç²¡",
      "è†§",
      "èŒ¼",
      "èš’",
      "è©·",
      "èµ¨",
      "é…®",
      "é‰–",
      "é‰µ",
      "éŠ…",
      "é“œ",
      "é¤‡",
      "é®¦",
      "é²–",
      "ð«£",
      "ð¦’"
    ],
    rÃ¨n: [
      "ä»ž",
      "ä»­",
      "åˆƒ",
      "åˆ„",
      "å¦Š",
      "å§™",
      "å±»",
      "å²ƒ",
      "æ‰¨",
      "ç‰£",
      "ç¥",
      "ç´‰",
      "ç´",
      "çµ",
      "çº«",
      "çº´",
      "è‚•",
      "è…",
      "è¡½",
      "è¢µ",
      "è¨’",
      "èª",
      "è®¤",
      "è®±",
      "è»”",
      "è½«",
      "éˆ“",
      "é­",
      "é±",
      "éŸŒ",
      "éŸ§",
      "é£ª",
      "é¤",
      "é¥ª"
    ],
    qiÄn: [
      "ä»Ÿ",
      "ä½¥",
      "åƒ‰",
      "åƒ",
      "åœ²",
      "å¥·",
      "å­¯",
      "å²",
      "æ‚­",
      "æ„†",
      "æ…³",
      "æ‰¦",
      "æ‹ª",
      "æ´",
      "æ’",
      "æ”",
      "æ”‘",
      "æ”“",
      "æ„",
      "æ«",
      "æ±˜",
      "æ±§",
      "ç‰µ",
      "ç‰½",
      "ç«",
      "ç­¾",
      "ç°½",
      "ç±–",
      "ç±¤",
      "ç²",
      "èŠŠ",
      "èŒ¾",
      "èšˆ",
      "è¤°",
      "è«",
      "è¬™",
      "è°¦",
      "è°¸",
      "è¿",
      "é·",
      "é‡º",
      "éˆ†",
      "é‰›",
      "é²",
      "é’Ž",
      "é˜¡",
      "éŸ†",
      "é¡…",
      "é¨«",
      "éªž",
      "é¬œ",
      "é¬",
      "éµ®",
      "é¹"
    ],
    "gÇŽn hÃ n": ["ä» "],
    "yÃ¬ gÄ“": ["ä»¡"],
    dÃ i: [
      "ä»£",
      "ä¾¢",
      "å‡",
      "åžˆ",
      "åŸ­",
      "å²±",
      "å¸’",
      "å¸¦",
      "å¸¯",
      "å¸¶",
      "å»—",
      "æ€ ",
      "æˆ´",
      "æ›ƒ",
      "æŸ‹",
      "æ®†",
      "ç€»",
      "çŽ³",
      "ç‘‡",
      "ç”™",
      "ç°¤",
      "ç´¿",
      "ç·¿",
      "ç»",
      "è‰œ",
      "è³",
      "è¢‹",
      "è¥¶",
      "è²£",
      "è´·",
      "è¹›",
      "è»‘",
      "è»š",
      "è»©",
      "è½ª",
      "è¿¨",
      "éœ´",
      "é†",
      "é´",
      "é»›",
      "é»±"
    ],
    "lÃ¬ng lÃ­ng lÇng": ["ä»¤"],
    chÃ o: ["ä»¦", "è€–", "è§˜"],
    "chÃ¡ng zhÇŽng": ["ä»§", "å…", "é•·", "é•¿"],
    sÄ: ["ä»¨"],
    chÃ¡ng: [
      "ä»©",
      "å¿",
      "å„Ÿ",
      "å˜—",
      "åš",
      "å«¦",
      "å°",
      "å¸¸",
      "å¾œ",
      "ç‘º",
      "ç“º",
      "ç”ž",
      "è‚ ",
      "è…¸",
      "è†“",
      "è‹Œ",
      "è‡",
      "é•¸",
      "é±¨",
      "é²¿"
    ],
    yÃ­: [
      "ä»ª",
      "ä¾‡",
      "å„€",
      "å†",
      "åŒœ",
      "å’¦",
      "åœ¯",
      "å¤·",
      "å§¨",
      "å®",
      "å®œ",
      "å®§",
      "å¯²",
      "å³“",
      "å¶¬",
      "å¶·",
      "å·¸",
      "å½›",
      "å½œ",
      "å½",
      "å½ž",
      "æ€¡",
      "æž",
      "æ‰…",
      "æš†",
      "æ ˜",
      "æ¤¬",
      "æ¤¸",
      "æ²‚",
      "æ´Ÿ",
      "ç†ª",
      "ç“µ",
      "ç—",
      "ç§»",
      "ç°ƒ",
      "ç±Ž",
      "ç¾ ",
      "èƒ°",
      "è“",
      "è›¦",
      "èž”",
      "è§º",
      "è¬»",
      "è²½",
      "è´»",
      "è· ",
      "è¿»",
      "éº",
      "é”",
      "é ‰",
      "é ¤",
      "é ¥",
      "é¡Š",
      "é¢",
      "é¥´",
      "é®§",
      "é´º"
    ],
    mÃ¹: [
      "ä»«",
      "å‡©",
      "å‹Ÿ",
      "å¢“",
      "å¹•",
      "å¹™",
      "æ…”",
      "æ…•",
      "æš®",
      "æš¯",
      "æœ¨",
      "æ¥˜",
      "æ¯£",
      "æ²",
      "ç‚‘",
      "ç‰§",
      "ç‹‡",
      "ç›®",
      "ç¦",
      "ç©†",
      "è‰’",
      "è‹œ",
      "èŽ¯",
      "èšž",
      "é‰¬",
      "é’¼",
      "é›®",
      "éœ‚"
    ],
    "men mÃ©n": ["ä»¬"],
    fÇŽn: ["ä»®", "å", "æ©Ž", "è¿”"],
    "chÃ o miÇŽo": ["ä»¯"],
    "yÇŽng Ã¡ng": ["ä»°"],
    zhÃ²ng: [
      "ä»²",
      "ä¼—",
      "å ¹",
      "å¦•",
      "åª‘",
      "ç‹†",
      "çœ¾",
      "ç¥Œ",
      "ç­—",
      "èŒ½",
      "èš›",
      "è¡†",
      "è¡¶",
      "è«¥"
    ],
    "pÇ pÃ­": ["ä»³"],
    wÃ²: [
      "ä»´",
      "å“",
      "å§",
      "åª‰",
      "å¹„",
      "æ¡",
      "æ¥ƒ",
      "æ²ƒ",
      "æ¸¥",
      "æ¿£",
      "ç“",
      "çžƒ",
      "ç¡ª",
      "è‚Ÿ",
      "è…›",
      "è‡¥",
      "é½·",
      "é¾Œ"
    ],
    jiÃ n: [
      "ä»¶",
      "ä¿´",
      "å¥",
      "åƒ­",
      "å‰‘",
      "å‰£",
      "å‰±",
      "åŠ",
      "åŠŽ",
      "åŠ’",
      "åŠ”",
      "å¢¹",
      "å¯‹",
      "å»º",
      "å¾¤",
      "æ“¶",
      "æ—”",
      "æ¥—",
      "æ¯½",
      "æ´Š",
      "æ¶§",
      "æ¾—",
      "ç‰®",
      "ç”",
      "çž·",
      "ç£µ",
      "ç¤€",
      "ç®­",
      "ç³‹",
      "ç¹",
      "è…±",
      "è‡¶",
      "èˆ°",
      "è‰¦",
      "è",
      "è–¦",
      "è¦¸",
      "è«“",
      "è««",
      "è­›",
      "è°",
      "è³Ž",
      "è³¤",
      "è´±",
      "è¶",
      "è·µ",
      "è¸",
      "è¸º",
      "è½ž",
      "é‰´",
      "é³",
      "éµ",
      "é±",
      "é‘‘",
      "é‘’",
      "é‘¬",
      "é‘³",
      "é”®",
      "é–“",
      "é¤ž",
      "é¥¯",
      "ð¬£¡"
    ],
    "jiÃ  jiÃ¨ jie": ["ä»·"],
    "yÇŽo fÃ³": ["ä»¸"],
    "rÃ¨n rÃ©n": ["ä»»"],
    "fÃ¨n bÄ«n": ["ä»½"],
    dÄ«: [
      "ä»¾",
      "ä½Ž",
      "å•²",
      "åŸž",
      "å ¤",
      "å²»",
      "å½½",
      "æ¨€",
      "æ»´",
      "ç£¾",
      "ç§ª",
      "ç¾",
      "è¢›",
      "è¶†",
      "éš„",
      "éž®",
      "äƒ…"
    ],
    fÇŽng: [
      "ä»¿",
      "å€£",
      "æ—Š",
      "æ˜‰",
      "æ˜˜",
      "ç“¬",
      "çœ†",
      "ç´¡",
      "çºº",
      "èˆ«",
      "è¨ª",
      "è®¿",
      "é«£",
      "é¶­"
    ],
    zhÅng: [
      "ä¼€",
      "åˆ£",
      "å¦",
      "å¹’",
      "å½¸",
      "å¿ ",
      "æŸŠ",
      "æ±·",
      "æ³ˆ",
      "ç‚‚",
      "ç›…",
      "ç±¦",
      "çµ‚",
      "ç»ˆ",
      "èˆ¯",
      "è” ",
      "èœ™",
      "èž¤",
      "èž½",
      "è¡³",
      "è¡·",
      "è¹±",
      "éˆ¡",
      "é¾",
      "é˜",
      "é’Ÿ",
      "é”º",
      "é´¤",
      "é¼¨"
    ],
    pÃ¨i: [
      "ä¼‚",
      "ä½©",
      "å§µ",
      "å¸”",
      "æ–¾",
      "æ—†",
      "æ²›",
      "æµ¿",
      "ç®",
      "è“œ",
      "è½¡",
      "è¾”",
      "é…",
      "éœˆ",
      "é¦·"
    ],
    diÃ o: [
      "ä¼„",
      "åŠ",
      "å¼”",
      "æŽ‰",
      "ç˜¹",
      "ç›„",
      "çªŽ",
      "çªµ",
      "ç«¨",
      "è¨‹",
      "é‡£",
      "éˆŸ",
      "éŠ±",
      "é‹½",
      "é‘ƒ",
      "é’“",
      "é“ž",
      "é›¿",
      "é­¡"
    ],
    dÃ¹n: [
      "ä¼…",
      "æ½¡",
      "ç‚–",
      "ç‡‰",
      "ç›¾",
      "ç ˜",
      "ç¢·",
      "è¸²",
      "é€‡",
      "é",
      "é¯",
      "éˆ",
      "é’"
    ],
    wÄ›n: ["ä¼†", "åˆŽ", "å»", "å‘…", "æŠ†", "æ¡½", "ç¨³", "ç©", "ç©©", "ç´Š", "è‚³", "è„—"],
    xÇn: ["ä¼ˆ"],
    kÃ ng: ["ä¼‰", "åŒŸ", "å›¥", "æŠ—", "ç‚•", "éˆ§", "é’ª"],
    Ã i: [
      "ä¼Œ",
      "åƒ¾",
      "å¡§",
      "å£’",
      "å«’",
      "å¬¡",
      "æ„›",
      "æ‡“",
      "æš§",
      "æ›–",
      "çˆ±",
      "ç‘·",
      "ç’¦",
      "çš§",
      "çž¹",
      "ç ¹",
      "ç¡‹",
      "ç¢",
      "ç¤™",
      "è–†",
      "è­º",
      "è³¹",
      "é‘€",
      "éš˜",
      "é‰",
      "é¤²",
      "é¦¤",
      "é±«",
      "é´±"
    ],
    "jÃ¬ qÃ­": ["ä¼Ž", "è–º"],
    "xiÅ« xÇ”": ["ä¼‘"],
    "jÃ¬n yÃ­n": ["ä¼’"],
    dÇŽn: [
      "ä¼”",
      "åˆ",
      "æ’¢",
      "çŽ¬",
      "ç“­",
      "ç´ž",
      "èƒ†",
      "è†½",
      "è¡´",
      "è³§",
      "èµ•",
      "é»•",
      "ð¬˜˜"
    ],
    fÅ«: [
      "ä¼•",
      "å‘‹",
      "å¨",
      "å­µ",
      "å°ƒ",
      "æ€¤",
      "æ‡¯",
      "æ•·",
      "æ—‰",
      "çŽž",
      "ç †",
      "ç¨ƒ",
      "ç­Ÿ",
      "ç³",
      "ç¶’",
      "è‚¤",
      "è†š",
      "è‚",
      "è´",
      "è¡­",
      "è¶º",
      "è·—",
      "é‚ž",
      "é„œ",
      "é…œ",
      "éˆ‡",
      "éº©",
      "éº¬",
      "éº±",
      "éº¸",
      "ð«“§"
    ],
    tÇŽng: [
      "ä¼–",
      "å‚¥",
      "å„»",
      "åŸ«",
      "æˆƒ",
      "æ›­",
      "çˆ£",
      "çŸ˜",
      "èºº",
      "éŽ²",
      "é’‚",
      "é•‹"
    ],
    yÅu: [
      "ä¼˜",
      "å„ª",
      "å‘¦",
      "åš˜",
      "å³³",
      "å¹½",
      "å¿§",
      "æ‚ ",
      "æ†‚",
      "æ”¸",
      "æ«Œ",
      "æ»º",
      "ç€€",
      "çº‹",
      "ç¾ª",
      "è€°",
      "é€Œ",
      "é„¾",
      "éº€"
    ],
    huÇ’: ["ä¼™", "å¤¥", "ç«", "ç…·", "é‚©", "éˆ¥", "é’¬"],
    "huÃ¬ kuÃ i": ["ä¼š", "æœƒ", "æµ", "ç’¯"],
    yÇ”: [
      "ä¼›",
      "ä¿",
      "ä¿£",
      "åŠ",
      "å‚´",
      "åŒ¬",
      "å™³",
      "åœ„",
      "åœ‰",
      "å®‡",
      "å¯™",
      "å±¿",
      "å¶¼",
      "åº¾",
      "æŒ§",
      "æ•”",
      "æ–ž",
      "æ¥€",
      "ç‘€",
      "ç˜",
      "ç¥¤",
      "ç¦¹",
      "ç©¥",
      "çª³",
      "ç¾½",
      "èˆ‡",
      "è­",
      "è²",
      "é„…",
      "é ¨",
      "éºŒ",
      "é½¬",
      "é¾‰",
      "ãº„"
    ],
    cuÃ¬: [
      "ä¼œ",
      "å•›",
      "å¿°",
      "æ‚´",
      "æ¯³",
      "æ·¬",
      "ç„ ",
      "ç–©",
      "ç˜",
      "ç«",
      "ç²‹",
      "ç²¹",
      "ç´£",
      "ç¶·",
      "ç¿†",
      "ç¿ ",
      "è„ƒ",
      "è„†",
      "è„º",
      "è†¬",
      "è†µ",
      "è‡Ž",
      "èƒ",
      "è¥Š",
      "é¡‡"
    ],
    sÇŽn: ["ä¼ž", "å‚˜", "ç³¤", "ç¹–", "é¥Š", "é¦“"],
    wÄ›i: [
      "ä¼Ÿ",
      "ä¼ª",
      "å‰",
      "å½",
      "åƒž",
      "å„°",
      "å¨“",
      "å¯ª",
      "å±—",
      "å´£",
      "å¶‰",
      "å¾«",
      "æ„‡",
      "æ¤",
      "æš",
      "æ¢¶",
      "æ´§",
      "æµ˜",
      "æ¸¨",
      "ç‚œ",
      "ç…’",
      "çŒ¥",
      "çŽ®",
      "ç‘‹",
      "ç—¿",
      "ç·¯",
      "çº¬",
      "è…²",
      "è‰‰",
      "èŠ›",
      "è‹‡",
      "è±",
      "èŽ",
      "è‘¦",
      "è’",
      "è”¿",
      "èœ¼",
      "è«‰",
      "è¯¿",
      "è¸“",
      "é¡",
      "éŸ‘",
      "éŸ™",
      "éŸ¡",
      "éŸª",
      "é  ",
      "é¢¹",
      "éª©",
      "éªª",
      "éª«",
      "é®ª",
      "é²”",
      "ð«‡­",
      "ð¬€©",
      "ð¬±Ÿ"
    ],
    "chuÃ¡n zhuÃ n": ["ä¼ ", "å‚³"],
    "chÄ“ jÅ«": ["ä¼¡", "ä¿¥", "è½¦"],
    "jÅ« chÄ“": ["è»Š"],
    yÃ¡: [
      "ä¼¢",
      "åŽ‘",
      "åŽ“",
      "å ",
      "å²ˆ",
      "å´•",
      "å´–",
      "æ¶¯",
      "æ¼„",
      "ç‰™",
      "çŽ¡",
      "çŠ",
      "çš",
      "ç¬Œ",
      "èŠ½",
      "èšœ",
      "è¡™",
      "é½–"
    ],
    qiÃ n: [
      "ä¼£",
      "ä¿”",
      "å€©",
      "å„™",
      "åˆ‹",
      "å£",
      "å¬±",
      "æ‚“",
      "æ£ˆ",
      "æ¤ ",
      "æ§§",
      "æ¬ ",
      "æ­‰",
      "çš˜",
      "ç¯",
      "ç¯Ÿ",
      "ç¸´",
      "èŠ¡",
      "è’¨",
      "è”³",
      "è¼¤",
      "ð¬˜¬"
    ],
    shÄng: [
      "ä¼¤",
      "å‚·",
      "å•†",
      "å¢’",
      "æ…¯",
      "æ®‡",
      "æ®¤",
      "æ»³",
      "æ¼¡",
      "ç†µ",
      "è”",
      "èžª",
      "è§ž",
      "è§´",
      "è¬ª",
      "é¬º"
    ],
    chÄng: [
      "ä¼¥",
      "å€€",
      "å¨¼",
      "æ˜Œ",
      "æ¤™",
      "æ·",
      "çŒ–",
      "ç©",
      "è–",
      "è£®",
      "éŒ©",
      "é” ",
      "é–¶",
      "é˜Š",
      "é¯§",
      "é²³",
      "é¼š"
    ],
    "chen cÄng": ["ä¼§"],
    xÃ¹n: [
      "ä¼¨",
      "ä¾š",
      "å‚",
      "å™€",
      "å·º",
      "å·½",
      "å¾‡",
      "æ„»",
      "æ®‰",
      "æ®¾",
      "æ±›",
      "æ½ ",
      "ç‹¥",
      "è•ˆ",
      "è¨Š",
      "è¨“",
      "è¨™",
      "è®­",
      "è®¯",
      "è¿…",
      "è¿¿",
      "é€Š",
      "éœ",
      "é‘‚",
      "é¡¨",
      "é¦´",
      "é©¯"
    ],
    xÃ¬n: ["ä¼©", "å›Ÿ", "å­ž", "è„ª", "èˆ‹", "è¡…", "è¨«", "é‡", "é˜ ", "é¡–"],
    chÇ: [
      "ä¼¬",
      "ä¾ˆ",
      "å¶",
      "åº",
      "å‘Ž",
      "åž‘",
      "æ¥",
      "æ­¯",
      "è€»",
      "è‚”",
      "èƒ£",
      "èš‡",
      "è£­",
      "è¤«",
      "è±‰",
      "é‰¹",
      "é½’",
      "é½¿"
    ],
    "xiÃ¡n xuÃ¡n": ["ä¼­"],
    "nÃº nÇ”": ["ä¼®"],
    "bÃ³ bÇŽi": ["ä¼¯"],
    "gÅ« gÃ¹": ["ä¼°"],
    nÇ: ["ä¼±", "ä½ ", "å„ž", "å­´", "æ‹Ÿ", "æ“¬", "æ—Ž", "æ™²", "ç‹”", "è‹¨", "è–¿", "éš¬"],
    "nÃ¬ nÃ­": ["ä¼²"],
    bÃ n: [
      "ä¼´",
      "åŠž",
      "åŠ",
      "å§…",
      "æ€‘",
      "æ‰®",
      "ç“£",
      "ç§š",
      "çµ†",
      "ç»Š",
      "è¾¦",
      "é‰¡",
      "é½"
    ],
    xÃ¹: [
      "ä¼µ",
      "ä¾",
      "å‹–",
      "å‹—",
      "å¹",
      "å™",
      "åž¿",
      "å£»",
      "å©¿",
      "åº",
      "æ¤",
      "æ•",
      "æ•˜",
      "æ—­",
      "æ˜«",
      "æœ‚",
      "æ§’",
      "æ¬°",
      "æ®ˆ",
      "æ±¿",
      "æ²€",
      "æ´«",
      "æº†",
      "æ¼µ",
      "æ½Š",
      "çƒ…",
      "çƒ¼",
      "ç…¦",
      "ç",
      "ç¬",
      "ç›¢",
      "çž",
      "ç¨¸",
      "çµ®",
      "ç¶š",
      "ç·’",
      "ç·–",
      "çºŒ",
      "ç»ª",
      "ç»­",
      "è“",
      "èŸ",
      "è“„",
      "è—š",
      "è¨¹",
      "è³‰",
      "é…—",
      "é Š",
      "é±®",
      "ã³š"
    ],
    zhÃ²u: [
      "ä¼·",
      "åƒ½",
      "å†‘",
      "å‘ª",
      "å’’",
      "å’®",
      "å®™",
      "æ˜¼",
      "æ™",
      "ç”ƒ",
      "çš±",
      "çšº",
      "ç±€",
      "ç±’",
      "ç±•",
      "ç²™",
      "ç´‚",
      "ç¸",
      "çº£",
      "ç»‰",
      "èƒ„",
      "è®",
      "è‘¤",
      "è©‹",
      "é…Ž",
      "é§Ž",
      "é©Ÿ",
      "éª¤",
      "ã¤˜",
      "ã‘‡"
    ],
    shÄ“n: [
      "ä¼¸",
      "ä¾",
      "å…Ÿ",
      "å‘»",
      "å ”",
      "å¦½",
      "å¨ ",
      "å±¾",
      "å³·",
      "æ‰Ÿ",
      "æ•’",
      "æ›‘",
      "æŸ›",
      "æ° ",
      "æ·±",
      "ç‡Š",
      "ç…",
      "ç”¡",
      "ç”§",
      "ç”³",
      "çœ’",
      "ç ·",
      "ç©¼",
      "ç±¶",
      "ç±¸",
      "ç³‚",
      "ç´³",
      "ç»…",
      "ç½™",
      "ç½§",
      "è‘ ",
      "è“¡",
      "è”˜",
      "è–“",
      "è£‘",
      "è¨·",
      "è©µ",
      "è¯œ",
      "èº«",
      "é§ª",
      "é¯“",
      "é¯µ",
      "é°º",
      "é²¹",
      "éµ¢",
      "ð¬³½"
    ],
    qÅ«: [
      "ä¼¹",
      "ä½‰",
      "åŒ¤",
      "å‘¿",
      "å¥",
      "å±ˆ",
      "å²–",
      "å²´",
      "å¶‡",
      "æ†ˆ",
      "æŠ¾",
      "æ•º",
      "æµ€",
      "ç…€",
      "ç¥›",
      "ç­",
      "ç²¬",
      "èƒ ",
      "è›†",
      "è›",
      "è¢ª",
      "è¦»",
      "è©˜",
      "è¯Ž",
      "è¶",
      "èº¯",
      "è»€",
      "é˜¹",
      "é§†",
      "é§ˆ",
      "é©…",
      "é©±",
      "é«·",
      "é­¼",
      "é°¸",
      "é±‹",
      "é¶Œ",
      "éº¯",
      "éº´",
      "éº¹",
      "é»¢",
      "ã­•",
      "ðª¨°",
      "ä“›"
    ],
    "sÃ¬ cÃ¬": ["ä¼º"],
    bÄ“ng: ["ä¼»", "å˜£", "å¥Ÿ", "å´©", "åµ­", "é–"],
    "sÃ¬ shÃ¬": ["ä¼¼"],
    "jiÄ qiÃ© gÄ": ["ä¼½"],
    "yÇ chÃ¬": ["ä½"],
    "diÃ n tiÃ¡n": ["ä½ƒ", "é’¿"],
    "hÄn gÃ n": ["ä½„"],
    mÃ i: [
      "ä½…",
      "åŠ¢",
      "å‹±",
      "å–",
      "å”›",
      "å£²",
      "è„ˆ",
      "è¡‡",
      "è³£",
      "è¿ˆ",
      "é‚",
      "éœ¡",
      "éœ¢",
      "éº¥",
      "éº¦",
      "é¿"
    ],
    dÃ n: [
      "ä½†",
      "åƒ¤",
      "å•–",
      "å•—",
      "å•¿",
      "å™‰",
      "åšª",
      "å¸Ž",
      "æ†º",
      "æ—¦",
      "æŸ¦",
      "æ°®",
      "æ²Š",
      "æ³¹",
      "æ·¡",
      "ç‹š",
      "ç–",
      "ç™š",
      "ç¦«",
      "çªž",
      "è……",
      "è",
      "è“ž",
      "è›‹",
      "èœ‘",
      "è§›",
      "è¨‘",
      "èª•",
      "è¯ž",
      "è´‰",
      "éœ®",
      "é¤¤",
      "é¥",
      "é§³",
      "é«§",
      "é´ ",
      "ð«¢¸"
    ],
    bÃ¹: [
      "ä½ˆ",
      "å‹",
      "å¥",
      "å’˜",
      "åŸ—",
      "åŸ ",
      "å¸ƒ",
      "å»",
      "æ€–",
      "æ‚‘",
      "æ­¥",
      "æ­¨",
      "æ­©",
      "ç“¿",
      "ç¯°",
      "è¹",
      "è”€",
      "è¸„",
      "éƒ¨",
      "éƒ¶",
      "éˆˆ",
      "é’š",
      "é¤¢"
    ],
    bÇ: [
      "ä½Š",
      "ä¿¾",
      "åŒ•",
      "å¤¶",
      "å¦£",
      "å½¼",
      "æœ¼",
      "æŸ€",
      "æ¯”",
      "æ¯ž",
      "æ²˜",
      "ç–•",
      "ç§•",
      "ç¬”",
      "ç­†",
      "ç²ƒ",
      "è›",
      "èˆ­",
      "è²",
      "é„™"
    ],
    "zhÄo shÃ o": ["ä½‹"],
    cÇ: ["ä½Œ", "æ­¤", "æ³š", "çš‰", "ð«š–"],
    wÃ¨i: [
      "ä½",
      "å«",
      "å‘³",
      "å–‚",
      "å¢›",
      "åª¦",
      "æ…°",
      "æ‡€",
      "æœª",
      "æ¸­",
      "ç…Ÿ",
      "ç†­",
      "çŠš",
      "çŒ¬",
      "ç•",
      "ç·­",
      "ç½»",
      "èƒƒ",
      "è‹¿",
      "è‹",
      "è—¯",
      "è˜¶",
      "èŸ",
      "èž±",
      "è¡›",
      "è¡ž",
      "è¤½",
      "è¬‚",
      "è®†",
      "è®",
      "è°“",
      "èº—",
      "èº›",
      "è»Ž",
      "è½Š",
      "é",
      "éœ¨",
      "é¤§",
      "é¤µ",
      "é¥–",
      "é­",
      "é®‡",
      "é³š"
    ],
    zuÇ’: ["ä½", "å·¦", "ç¹“"],
    yÇŽng: [
      "ä½’",
      "å‚Ÿ",
      "å…»",
      "å±",
      "å²Ÿ",
      "æ…ƒ",
      "æ‡©",
      "æ”",
      "æ°§",
      "æ°±",
      "ç‚´",
      "ç—’",
      "ç™¢",
      "ç¤¢",
      "ç´»",
      "è†",
      "è»®",
      "é¤Š",
      "é§š"
    ],
    "tÇ tÄ«": ["ä½“", "é«”"],
    zhÃ n: [
      "ä½”",
      "å¡",
      "å¶˜",
      "æˆ˜",
      "æˆ¦",
      "æˆ°",
      "æ ˆ",
      "æ¡Ÿ",
      "æ£§",
      "æ¹›",
      "ç«™",
      "ç¶»",
      "ç»½",
      "èš",
      "è˜¸",
      "è™¥",
      "è™¦",
      "è­§",
      "è½",
      "é©"
    ],
    "hÃ© hÄ“ hÃ¨": ["ä½•"],
    bÃ¬: [
      "ä½–",
      "å’‡",
      "å“”",
      "å—¶",
      "å’",
      "å ›",
      "å£",
      "å¥°",
      "å¦¼",
      "å©¢",
      "å¬–",
      "å¸",
      "å¹£",
      "å¹¤",
      "åº‡",
      "åº³",
      "å»¦",
      "å¼Š",
      "å¼»",
      "å¼¼",
      "å½ƒ",
      "å¿…",
      "æ€­",
      "æ„Š",
      "æ„Ž",
      "æ•",
      "æ–ƒ",
      "æ¢",
      "æ¯•",
      "æ¯–",
      "æ¯™",
      "æ¹¢",
      "æ»—",
      "æ»­",
      "æ½·",
      "ç…",
      "ç†š",
      "ç‹´",
      "ç˜",
      "ç™",
      "çŒ",
      "ç’§",
      "ç•€",
      "ç•¢",
      "ç–ª",
      "ç—¹",
      "ç—º",
      "çš•",
      "ç¤",
      "ç¢§",
      "ç­š",
      "ç®…",
      "ç®†",
      "ç¯¦",
      "ç¯³",
      "ç²Š",
      "ç¶¼",
      "ç¸ª",
      "ç¹´",
      "ç½¼",
      "è…·",
      "è‹¾",
      "èœ",
      "è†",
      "èž",
      "è“–",
      "è“½",
      "è”½",
      "è–œ",
      "èœŒ",
      "è¢",
      "è¥…",
      "è¥ž",
      "è¥£",
      "è§±",
      "è©–",
      "è¯",
      "è²±",
      "è´”",
      "èµ‘",
      "è·¸",
      "è¹•",
      "èºƒ",
      "èº„",
      "é¿",
      "é‚²",
      "é„¨",
      "é„ª",
      "é‰",
      "éŽ",
      "é´",
      "é“‹",
      "é–‡",
      "é–‰",
      "é–Ÿ",
      "é—­",
      "é™›",
      "éŸ ",
      "é£¶",
      "é¥†",
      "é¦",
      "é§œ",
      "é©†",
      "é«€",
      "é­“",
      "é®…",
      "é·",
      "é·©",
      "é¼Š"
    ],
    tuÃ³: [
      "ä½—",
      "å¨",
      "å ¶",
      "å²®",
      "æ§–",
      "æ©",
      "æ²±",
      "ç £",
      "ç ¤",
      "ç¢¢",
      "ç´½",
      "è©‘",
      "è·Ž",
      "é…¡",
      "é˜¤",
      "é™€",
      "é™",
      "é§",
      "é§ž",
      "é¨¨",
      "é©’",
      "é©",
      "é©¼",
      "é®€",
      "é´•",
      "é¸µ",
      "é¼‰",
      "é¼",
      "é¼§",
      "ð¬¶"
    ],
    shÃ©: ["ä½˜", "èˆŒ", "è™µ", "è›¥"],
    "yÃ¬ diÃ©": ["ä½š", "æ˜³", "æ³†", "è»¼"],
    "fÃ³ fÃº bÃ¬ bÃ³": ["ä½›"],
    "zuÃ² zuÅ": ["ä½œ"],
    gÅu: [
      "ä½",
      "æ²Ÿ",
      "æº",
      "ç—€",
      "ç¯",
      "ç°¼",
      "ç·±",
      "ç¼‘",
      "è¢§",
      "è¤ ",
      "éˆŽ",
      "é‰¤",
      "é’©",
      "éž²",
      "éŸ"
    ],
    nÃ¬ng: ["ä½ž", "ä¾«", "å€¿", "å¯•", "æ³ž", "æ¾", "æ¿˜"],
    qÃº: [
      "ä½¢",
      "åŠ¬",
      "æˆµ",
      "æ–ª",
      "æ¬‹",
      "æ¬”",
      "æ°",
      "æ·­",
      "çˆ",
      "çˆ ",
      "ç’–",
      "ç’©",
      "ç™¯",
      "ç£²",
      "ç±§",
      "çµ‡",
      "èƒŠ",
      "è‡ž",
      "èƒ",
      "è‘‹",
      "è•–",
      "è˜§",
      "èŸ",
      "è ·",
      "è ¼",
      "è¡",
      "è¡¢",
      "èº£",
      "è»¥",
      "é‘º",
      "é´",
      "é¸œ",
      "é¸²",
      "é¼©"
    ],
    "yÅng yÃ²ng": ["ä½£"],
    wÇŽ: ["ä½¤", "å’“", "ç ™", "é‚·"],
    kÇŽ: ["ä½§", "åž°", "èƒ©", "è£ƒ", "é‰²"],
    bÄo: [
      "ä½¨",
      "å‹¹",
      "åŒ…",
      "å­¢",
      "ç…²",
      "ç¬£",
      "èƒž",
      "è‹ž",
      "è•”",
      "è£¦",
      "è¤’",
      "è¥ƒ",
      "é—",
      "é½™",
      "é¾…"
    ],
    "huÃ¡i huÃ­": ["ä½ª"],
    "gÃ© hÃ¨": ["ä½«"],
    lÇŽo: [
      "ä½¬",
      "å’¾",
      "æ…",
      "æ ³",
      "ç‹«",
      "ç¯",
      "ç¡“",
      "è€",
      "è€‚",
      "è–",
      "è›¯",
      "è½‘",
      "éŠ ",
      "é“‘",
      "é®±"
    ],
    xiÃ¡ng: ["ä½­", "åº ", "æ ™", "ç¥¥", "çµ´", "ç¿”", "è©³", "è·­"],
    gÃ©: [
      "ä½®",
      "åŒŒ",
      "å‘„",
      "å—",
      "å¡¥",
      "æ„…",
      "æŒŒ",
      "æ¿",
      "æ§…",
      "æ«Š",
      "æ»†",
      "è†ˆ",
      "è‡µ",
      "èŒ–",
      "è§¡",
      "è«½",
      "è¼µ",
      "è½•",
      "é–£",
      "é˜",
      "éš”",
      "éž·",
      "éŸ",
      "éŸš",
      "é¨”",
      "éª¼",
      "é®¯"
    ],
    yÃ¡ng: [
      "ä½¯",
      "åŠ·",
      "åžŸ",
      "å´¸",
      "å¾‰",
      "æ‰¬",
      "æš",
      "æ•­",
      "æ—¸",
      "æ˜œ",
      "æš˜",
      "æ¨",
      "æ¥Š",
      "æ´‹",
      "ç‚€",
      "çœ",
      "ç–¡",
      "ç˜",
      "çœ»",
      "è›˜",
      "è«¹",
      "è¼°",
      "éš",
      "é’–",
      "é˜¦",
      "é˜³",
      "é™½",
      "éœ·",
      "é¢º",
      "é£",
      "é°‘",
      "é´¹",
      "é¸‰"
    ],
    bÇŽi: ["ä½°", "æ­", "æ‘†", "æ“º", "æ ¢", "ç™¾", "ç«¡", "ç²¨", "è¥¬"],
    fÇŽ: ["ä½±", "å³œ", "æ³•", "ç‹", "ç ", "é…"],
    mÇng: ["ä½²", "å‡•", "å§³", "æ…", "é…©"],
    "Ã¨r nÃ i": ["ä½´"],
    hÄ›n: ["ä½·", "å¾ˆ", "ç‹ ", "è©ª", "ð¬£³"],
    huÃ³: ["ä½¸", "æ´»"],
    guÇ: [
      "ä½¹",
      "åŒ¦",
      "åŒ­",
      "åŽ¬",
      "åž",
      "å§½",
      "å®„",
      "åº‹",
      "åºª",
      "æ‘",
      "æ™·",
      "æ¹€",
      "ç™¸",
      "ç¥ª",
      "ç°‹",
      "è›«",
      "èŸ¡",
      "è§¤",
      "è©­",
      "è¯¡",
      "è»Œ",
      "è½¨",
      "é™’",
      "é¬¼"
    ],
    quÃ¡n: [
      "ä½º",
      "å…¨",
      "å•³",
      "åŸ¢",
      "å§¾",
      "å³‘",
      "å·",
      "æ‹³",
      "æ¼",
      "æƒ",
      "æ¥¾",
      "æ¨©",
      "æ¬Š",
      "æ³‰",
      "æ´¤",
      "æ¹¶",
      "ç‰·",
      "çŠˆ",
      "ç‘”",
      "ç—Š",
      "ç¡‚",
      "ç­Œ",
      "ç¸“",
      "èƒ",
      "è‘²",
      "èœ·",
      "è ¸",
      "è§ ",
      "è©®",
      "è¯ ",
      "è·§",
      "è¸¡",
      "è¼‡",
      "è¾",
      "é†›",
      "éŠ“",
      "é“¨",
      "é—Ž",
      "é¡´",
      "é¢§",
      "é§©",
      "é¨¡",
      "é¬ˆ",
      "é°",
      "é³ˆ",
      "é½¤"
    ],
    tiÄo: ["ä½»", "åº£", "æ—«", "ç¥§", "èŽ"],
    jiÇŽo: [
      "ä½¼",
      "å„Œ",
      "å­‚",
      "æŒ¢",
      "æ…",
      "æ’Ÿ",
      "æ’¹",
      "æ”ª",
      "æ•«",
      "æ•½",
      "æ•¿",
      "æ™ˆ",
      "æšž",
      "æ›’",
      "çš",
      "ç‡ž",
      "ç‹¡",
      "ç’¬",
      "çšŽ",
      "çš¦",
      "çµž",
      "çº",
      "ç»ž",
      "è…³",
      "è‡«",
      "èŸœ",
      "è­‘",
      "è³‹",
      "è¸‹",
      "é‰¸",
      "é“°",
      "é¤ƒ",
      "é¥º",
      "é±Ž",
      "é¾£"
    ],
    cÃ¬: [
      "ä½½",
      "åˆ¾",
      "åº›",
      "æœ¿",
      "æ ¨",
      "æ¬¡",
      "çµ˜",
      "èŒ¦",
      "èŽ¿",
      "è›“",
      "èž†",
      "è³œ",
      "èµ"
    ],
    xÃ­ng: [
      "ä¾€",
      "åˆ‘",
      "å“˜",
      "åž‹",
      "å¨™",
      "å½¢",
      "æ´",
      "ç¡Ž",
      "è›µ",
      "é‚¢",
      "éƒ‰",
      "éˆƒ",
      "é‰¶",
      "éŠ’",
      "é’˜",
      "é“",
      "é™‰",
      "é™˜",
      "é¤³",
      "ð«°›"
    ],
    tuÅ: [
      "ä¾‚",
      "å’ƒ",
      "å’œ",
      "åœ«",
      "æ‰˜",
      "æ‹•",
      "æ‹–",
      "æ±‘",
      "è„«",
      "è„±",
      "èŽŒ",
      "è¢¥",
      "è¨—",
      "è®¬",
      "é£¥",
      "é¥¦",
      "é­ ",
      "é®µ"
    ],
    kÇŽn: ["ä¾ƒ", "å˜", "å†š", "åŽ", "æƒ‚", "ç ", "èŽ°", "è¼¡", "è½—", "é¡‘"],
    zhÃ­: [
      "ä¾„",
      "å€¤",
      "å€¼",
      "åŸ´",
      "åŸ·",
      "å§ª",
      "å¬‚",
      "æˆ ",
      "æ‰§",
      "æ‘­",
      "æ¤",
      "æ¨´",
      "æ·”",
      "æ¼",
      "ç›´",
      "ç¦ƒ",
      "çµ·",
      "ç¸¶",
      "è€",
      "èŒ",
      "è·",
      "è†±",
      "èŸ™",
      "è·–",
      "è¸¯",
      "è¹ ",
      "èº‘",
      "è»„",
      "é‡ž",
      "é¦½"
    ],
    gÄi: [
      "ä¾…",
      "åž“",
      "å§Ÿ",
      "å³",
      "æ™",
      "ç•¡",
      "ç¥´",
      "è„",
      "è©²",
      "è¯¥",
      "è±¥",
      "è³…",
      "è³Œ",
      "èµ…",
      "é™”"
    ],
    lÃ¡i: [
      "ä¾†",
      "ä¿«",
      "å€ˆ",
      "å´ƒ",
      "å´",
      "åº²",
      "æ¥",
      "æ¢¾",
      "æ£¶",
      "æ¶ž",
      "æ·¶",
      "çŒ",
      "çœ",
      "ç­™",
      "ç®‚",
      "èŽ±",
      "èŠ",
      "é€¨",
      "éƒ²",
      "éŒ¸",
      "é“¼",
      "é¨‹",
      "é¯ ",
      "é¶†",
      "éº³"
    ],
    kuÇŽ: ["ä¾‰", "å’µ", "åž®", "éŠ™"],
    gÅng: [
      "ä¾Š",
      "å…¬",
      "åŠŸ",
      "åŒ‘",
      "åŒ”",
      "å¡¨",
      "å®«",
      "å®®",
      "å·¥",
      "å¹Š",
      "å¼“",
      "æ­",
      "æ”»",
      "æ›",
      "ç¢½",
      "ç³¼",
      "ç³¿",
      "è‚±",
      "è§¥",
      "è§µ",
      "èº¬",
      "èº³",
      "é«¸",
      "é¾”",
      "é¾š",
      "ä¢¼"
    ],
    lÃ¬: [
      "ä¾‹",
      "ä¿",
      "ä¿ª",
      "å‚ˆ",
      "å„®",
      "å„·",
      "å‡“",
      "åˆ©",
      "åŠ›",
      "åŠ±",
      "å‹µ",
      "åŽ†",
      "åŽ‰",
      "åŽ¤",
      "åŽ¯",
      "åŽ²",
      "å“",
      "å",
      "å‘–",
      "å”Ž",
      "å”³",
      "åš¦",
      "å›‡",
      "åœ",
      "å¡›",
      "å£¢",
      "å¨³",
      "å©¯",
      "å±´",
      "å²¦",
      "æ‚§",
      "æ‚·",
      "æ…„",
      "æˆ¾",
      "æ®",
      "æš¦",
      "æ›†",
      "æ›ž",
      "æœ¸",
      "æž¥",
      "æ ƒ",
      "æ —",
      "æ ›",
      "æªª",
      "æ«”",
      "æ«ª",
      "æ¬",
      "æ­´",
      "æ­·",
      "æ²¥",
      "æ²´",
      "æ¶–",
      "æº§",
      "æ¿¿",
      "ç€",
      "çˆ",
      "çŠ¡",
      "çŒ",
      "ç•",
      "ç‘®",
      "ç“…",
      "ç“‘",
      "ç“¥",
      "ç–¬",
      "ç—¢",
      "ç™§",
      "ç›­",
      "ç™",
      "ç …",
      "ç º",
      "ç ¾",
      "ç£¿",
      "ç¤ª",
      "ç¤«",
      "ç¤°",
      "ç¦²",
      "ç§",
      "ç«‹",
      "ç¬ ",
      "ç¯¥",
      "ç²’",
      "ç²",
      "ç³²",
      "è„·",
      "è‹ˆ",
      "èŒ˜",
      "è”",
      "èŽ…",
      "èŽ‰",
      "è’š",
      "è’ž",
      "è—¶",
      "èš¸",
      "è›Ž",
      "è› ",
      "èœ§",
      "è·",
      "è ‡",
      "è £",
      "è©ˆ",
      "è®ˆ",
      "èµ²",
      "è½¢",
      "è½£",
      "è½¹",
      "é…ˆ",
      "é‰",
      "éš¶",
      "éš·",
      "é›³",
      "é‚",
      "é‹",
      "é¬",
      "é³¨",
      "é´—",
      "é·…",
      "éºœ",
      "ð«µ·",
      "ð¬›"
    ],
    yÄ«n: [
      "ä¾Œ",
      "å‡",
      "å–‘",
      "å™¾",
      "å›™",
      "å› ",
      "åž”",
      "å ™",
      "å§»",
      "å©£",
      "æ„”",
      "æ…‡",
      "æ ¶",
      "æ°¤",
      "æ´‡",
      "æºµ",
      "æ¿¦",
      "ç˜–",
      "ç¦‹",
      "ç§µ",
      "ç­ƒ",
      "çµª",
      "ç·¸",
      "èŒµ",
      "è’‘",
      "è”­",
      "è£€",
      "è«²",
      "éŠ¦",
      "é“Ÿ",
      "é—‰",
      "é˜¥",
      "é˜´",
      "é™°",
      "é™»",
      "éš‚",
      "éœ’",
      "éœ ",
      "éž‡",
      "éŸ³",
      "éŸ¾",
      "é§°",
      "éªƒ",
      "é½—",
      "ð¬˜¡",
      "ð¬¤‡",
      "ð¬®±"
    ],
    mÇ: [
      "ä¾Ž",
      "å­Š",
      "å¼­",
      "æ•‰",
      "æ´£",
      "æ¸³",
      "ç–",
      "ç±³",
      "ç²Ž",
      "ç¾‹",
      "è„’",
      "èŠˆ",
      "è‘ž",
      "è”",
      "éŠ¤"
    ],
    zhÅ«: [
      "ä¾",
      "æ ª",
      "æ§ ",
      "æ©¥",
      "æ«§",
      "æ««",
      "æ´™",
      "æ½´",
      "ç€¦",
      "çŒª",
      "ç ",
      "ç¡ƒ",
      "ç§¼",
      "çµ‘",
      "èŒ±",
      "è•",
      "è››",
      "è«",
      "è ©",
      "è¢¾",
      "èª…",
      "è«¸",
      "è¯›",
      "è¯¸",
      "è±¬",
      "è·¦",
      "é‚¾",
      "éŠ–",
      "é“¢",
      "é§¯",
      "é®¢",
      "é¯º",
      "é´¸",
      "é¼„"
    ],
    Än: [
      "ä¾’",
      "å£",
      "åª•",
      "å®‰",
      "å³–",
      "åºµ",
      "æ¡‰",
      "æ°¨",
      "ç›¦",
      "ç›«",
      "è…¤",
      "è´",
      "è»",
      "è‘Š",
      "è“­",
      "èª",
      "è«³",
      "è°™",
      "éžŒ",
      "éž",
      "éŸ½",
      "é¦£",
      "é®Ÿ",
      "éµª",
      "é¶•",
      "é¹Œ",
      "ð©½¾"
    ],
    lÃ¹: [
      "ä¾“",
      "åƒ‡",
      "å‹Ž",
      "å‹ ",
      "åœ¥",
      "å´",
      "å¡¶",
      "å¨½",
      "å³",
      "å»˜",
      "å½”",
      "å½•",
      "æˆ®",
      "æ‘",
      "æ¤‚",
      "æ¨š",
      "æ·•",
      "æ·¥",
      "æ¸Œ",
      "æ¼‰",
      "æ½ž",
      "ç­",
      "ç’",
      "ç”ª",
      "ç›",
      "ç©",
      "ç¡‰",
      "ç¥¿",
      "ç¦„",
      "ç¨‘",
      "ç©‹",
      "ç®“",
      "ç°",
      "ç°¬",
      "ç°µ",
      "ç°¶",
      "ç±™",
      "ç²¶",
      "è”",
      "è•—",
      "è™‚",
      "èž°",
      "è³‚",
      "èµ‚",
      "è¶¢",
      "è·¯",
      "è¸›",
      "è¹—",
      "è¼…",
      "è½†",
      "è¾‚",
      "è¾˜",
      "é€¯",
      "é†",
      "éŒ„",
      "éŒ²",
      "éŒ´",
      "é´",
      "é™¸",
      "é¨„",
      "é¨¼",
      "é¯¥",
      "é´¼",
      "éµ¦",
      "éµ±",
      "é·º",
      "é¹­",
      "é¹¿",
      "éº“",
      "ð«˜§"
    ],
    mÃ³u: ["ä¾”", "åŠº", "æˆ", "çœ¸", "è›‘", "è¬€", "è°‹", "è¸Ž", "éª", "é´¾", "éº°"],
    Ã©r: [
      "ä¾•",
      "å„¿",
      "å…",
      "å…’",
      "å³",
      "æ ­",
      "æ´",
      "ç²«",
      "è€Œ",
      "èƒ¹",
      "è‹",
      "è¢»",
      "è¼€",
      "è½œ",
      "é™‘",
      "éš­",
      "é«µ",
      "é®ž",
      "é²•",
      "é´¯",
      "é¸¸"
    ],
    "dÃ²ng tÇ’ng tÃ³ng": ["ä¾—"],
    chÃ : ["ä¾˜", "å¥¼", "å§¹", "å²”", "æ±Š", "è©«", "è¯§"],
    chÃ¬: [
      "ä¾™",
      "å‚º",
      "å‹…",
      "å‹‘",
      "å±",
      "å•»",
      "å½³",
      "æœ",
      "æ…—",
      "æ†",
      "æ‡˜",
      "æŠ¶",
      "æ••",
      "æ–¥",
      "æ˜",
      "æ¹",
      "ç»",
      "ç‚½",
      "çƒ¾",
      "ç†¾",
      "ç—“",
      "ç—¸",
      "ç˜›",
      "ç¿„",
      "ç¿…",
      "ç¿¤",
      "ç¿¨",
      "è…Ÿ",
      "èµ¤",
      "è¶©",
      "é«",
      "é‰“",
      "é›´",
      "é£­",
      "é¥¬",
      "é¶’",
      "é·˜"
    ],
    "gÃ²ng gÅng": ["ä¾›", "å…±"],
    zhÅu: [
      "ä¾œ",
      "å‘¨",
      "å–Œ",
      "å·ž",
      "å¾Ÿ",
      "æ´²",
      "æ·",
      "ç‚¿",
      "çƒ",
      "ç˜",
      "çŸª",
      "èˆŸ",
      "è¬…",
      "è­¸",
      "è¯Œ",
      "è³™",
      "èµ’",
      "è¼ˆ",
      "è¼–",
      "è¾€",
      "é€±",
      "éƒ®",
      "éŠ‚",
      "éœŒ",
      "é§²",
      "é¨†",
      "éµƒ",
      "é¸¼"
    ],
    rÃº: [
      "ä¾ž",
      "å„’",
      "åš…",
      "å¦‚",
      "å¬¬",
      "å­º",
      "å¸¤",
      "æ›˜",
      "æ¡‡",
      "æ¸ª",
      "æ¿¡",
      "ç­Ž",
      "èŒ¹",
      "è• ",
      "è–·",
      "è¡",
      "è •",
      "è¢½",
      "è¥¦",
      "é‚š",
      "é†¹",
      "éŠ£",
      "é“·",
      "é¡¬",
      "é¢¥",
      "é±¬",
      "é´‘",
      "é´½"
    ],
    "jiÃ n cÃºn": ["ä¾Ÿ"],
    xiÃ¡: [
      "ä¾ ",
      "ä¿ ",
      "åŒ£",
      "å³¡",
      "å³½",
      "æ•®",
      "æš‡",
      "æŸ™",
      "ç‚ ",
      "çƒš",
      "ç‹Ž",
      "ç‹­",
      "ç‹¹",
      "ç¨",
      "ç‘•",
      "ç¡–",
      "ç¡¤",
      "ç¢¬",
      "ç¥«",
      "ç­ª",
      "ç¸–",
      "ç¿ˆ",
      "èˆ",
      "èˆº",
      "è•¸",
      "èµ®",
      "è½„",
      "è¾–",
      "é",
      "éœ",
      "éŽ‹",
      "é™œ",
      "é™¿",
      "éœž",
      "é¨¢",
      "é­»",
      "é¶·",
      "é» "
    ],
    lÇš: [
      "ä¾£",
      "ä¾¶",
      "å„¢",
      "å•",
      "å‘‚",
      "å±¡",
      "å±¢",
      "å±¥",
      "æŒ”",
      "æ›",
      "æ—…",
      "æ¢ ",
      "ç„’",
      "ç¥£",
      "ç¨†",
      "ç©­",
      "çµ½",
      "ç¸·",
      "ç¼•",
      "è†‚",
      "è†",
      "è¤›",
      "è¤¸",
      "éƒ˜",
      "é‹",
      "é“"
    ],
    ta: ["ä¾¤"],
    "jiÇŽo yÃ¡o": ["ä¾¥", "åƒ¥", "å¾º"],
    zhÄ“n: [
      "ä¾¦",
      "åµ",
      "å¯Š",
      "å¸§",
      "å¸ª",
      "å¹€",
      "æ¸",
      "æ–Ÿ",
      "æ¡¢",
      "æ¥¨",
      "æ¦›",
      "æ¨¼",
      "æ®",
      "æµˆ",
      "æ¹ž",
      "æ½§",
      "æ¾µ",
      "ç‰",
      "ç",
      "çŽ",
      "ç‘§",
      "ç”„",
      "çœž",
      "çœŸ",
      "ç §",
      "ç¢ª",
      "ç¥¯",
      "ç¦Ž",
      "ç¦›",
      "ç®´",
      "èƒ—",
      "è‡»",
      "è‘´",
      "è’–",
      "è“",
      "è–½",
      "è²ž",
      "è´ž",
      "è½ƒ",
      "é‰",
      "é…™",
      "é‡",
      "é‰",
      "éŒ±",
      "é¼",
      "é’ˆ",
      "é±µ"
    ],
    "cÃ¨ zÃ¨ zhÄi": ["ä¾§", "å´"],
    kuÃ i: [
      "ä¾©",
      "å„ˆ",
      "å‡·",
      "å“™",
      "å™²",
      "åœ¦",
      "å—",
      "å¡Š",
      "å·œ",
      "å»¥",
      "å¿«",
      "æ—",
      "æ¬³",
      "ç‹¯",
      "çª",
      "ç­·",
      "ç³©",
      "è„",
      "è†¾",
      "éƒ",
      "é„¶",
      "é± ",
      "é²™"
    ],
    chÃ¡i: ["ä¾ª", "å„•", "å–", "æŸ´", "çŠ²", "ç¥¡", "è±º"],
    nÃ³ng: [
      "ä¾¬",
      "å„‚",
      "å†œ",
      "å“",
      "å™¥",
      "æª‚",
      "æ¬",
      "æµ“",
      "æ¿ƒ",
      "ç‡¶",
      "ç¦¯",
      "ç§¾",
      "ç© ",
      "è„“",
      "è†¿",
      "è•½",
      "è¥›",
      "è­¨",
      "è¾²",
      "è¾³",
      "é†²",
      "é¬ž",
      "ð¬ª©"
    ],
    jÇn: [
      "ä¾­",
      "å„˜",
      "åº",
      "åŽª",
      "å·¹",
      "æ§¿",
      "æ¼Œ",
      "ç‘¾",
      "ç´§",
      "ç·Š",
      "è«",
      "è“³",
      "è¬¹",
      "è°¨",
      "éŒ¦",
      "é”¦",
      "é¥‰",
      "é¦‘"
    ],
    "hÃ³u hÃ²u": ["ä¾¯", "çŸ¦"],
    jiÇ’ng: [
      "ä¾°",
      "åƒ’",
      "å†",
      "å›§",
      "æ³‚",
      "æ¾ƒ",
      "ç‚¯",
      "çƒ±",
      "ç…š",
      "ç…›",
      "ç†²",
      "ç‡›",
      "çª˜",
      "ç¶—",
      "è¤§",
      "è¿¥",
      "é€ˆ",
      "é¡ˆ",
      "é¢Ž",
      "äŒ¹"
    ],
    "chÄ›ng tÇng": ["ä¾±"],
    "zhÃ¨n zhÄ“n": ["ä¾²", "æ•"],
    zuÃ²: [
      "ä¾³",
      "åš",
      "å”‘",
      "å",
      "å²",
      "å²ž",
      "åº§",
      "ç¥š",
      "ç³³",
      "èƒ™",
      "è‘ƒ",
      "è‘„",
      "è“™",
      "è¢",
      "é˜¼"
    ],
    qÄ«n: [
      "ä¾µ",
      "å…“",
      "åª‡",
      "åµš",
      "å¶”",
      "æ¬½",
      "è¡¾",
      "èª›",
      "é’¦",
      "é¡‰",
      "é§¸",
      "éªŽ",
      "é®¼"
    ],
    jÃº: [
      "ä¾·",
      "å•¹",
      "å©…",
      "å±€",
      "å·ˆ",
      "æ¤ˆ",
      "æ©˜",
      "æ³¦",
      "æ·—",
      "æ¹¨",
      "ç„—",
      "çŠ‘",
      "ç‹Š",
      "ç²·",
      "èŠ",
      "è˜œ",
      "è¶œ",
      "è·¼",
      "è¹«",
      "è¼‚",
      "éƒ¹",
      "é–°",
      "é§¶",
      "é©§",
      "éµ™",
      "éµ´",
      "é¶ª",
      "é¼°",
      "é¼³",
      "ä´—"
    ],
    "shÃ¹ dÅu": ["ä¾¸"],
    tÇng: [
      "ä¾¹",
      "åœ¢",
      "å¨—",
      "æŒº",
      "æ¶",
      "çƒ¶",
      "ç½",
      "è„¡",
      "è‰‡",
      "èª”",
      "é ²",
      "é¢‹"
    ],
    shÃ¨n: [
      "ä¾º",
      "æ„¼",
      "æ…Ž",
      "æ˜š",
      "æ¶",
      "æ¸—",
      "æ»²",
      "ç˜†",
      "ç˜®",
      "çœ˜",
      "ç¥³",
      "è‚¾",
      "èƒ‚",
      "è„¤",
      "è…Ž",
      "èœƒ",
      "èœ„",
      "é‹ "
    ],
    "tuÃ¬ tuÃ³": ["ä¾»"],
    nÃ¡n: [
      "ä¾½",
      "å–ƒ",
      "å¨š",
      "æŠ©",
      "æš”",
      "æž",
      "æŸŸ",
      "æ¥ ",
      "ç”·",
      "ç•˜",
      "èŽ®",
      "è³",
      "é–"
    ],
    xiÄo: [
      "ä¾¾",
      "å““",
      "å˜µ",
      "åš»",
      "å›‚",
      "å©‹",
      "å®¯",
      "å®µ",
      "åº¨",
      "å½‡",
      "æ±",
      "æž­",
      "æžµ",
      "æ¢Ÿ",
      "æ«¹",
      "æ­Š",
      "æ¯Š",
      "æ¶ˆ",
      "æ½‡",
      "ç€Ÿ",
      "ç±",
      "ç²",
      "çƒ‹",
      "ç„‡",
      "çŒ‡",
      "ç¢",
      "ç—š",
      "ç—Ÿ",
      "ç¡",
      "ç¡£",
      "çª™",
      "ç®«",
      "ç°˜",
      "ç°«",
      "ç¶ƒ",
      "ç»¡",
      "ç¿›",
      "è†®",
      "è§",
      "è•­",
      "è™ˆ",
      "è™“",
      "èŸ‚",
      "èŸ",
      "èŸ°",
      "è ¨",
      "è¸ƒ",
      "é€",
      "éŠ·",
      "é”€",
      "éœ„",
      "é¢µ",
      "é©",
      "éª",
      "é«‡",
      "é«",
      "é­ˆ",
      "é´ž",
      "é´µ",
      "é·",
      "é¸®"
    ],
    "biÃ n piÃ¡n": ["ä¾¿", "ç·¶", "ç¼"],
    tuÇ: ["ä¿€", "è…¿", "è¹†", "éª½"],
    xÃ¬: [
      "ä¿‚",
      "åŒ¸",
      "åŒ",
      "å‘¬",
      "å¢",
      "å±ƒ",
      "å±“",
      "å±­",
      "å¿¥",
      "æ€¬",
      "æ„",
      "æ¤ž",
      "æ½",
      "æ½Ÿ",
      "æ¾™",
      "ç†‚",
      "çŠ”",
      "ç£¶",
      "ç¦Š",
      "ç´°",
      "ç¶Œ",
      "ç¸˜",
      "ç»†",
      "ç»¤",
      "èˆƒ",
      "èˆ„",
      "è•®",
      "è™©",
      "è¡‹",
      "è¦¤",
      "èµ©",
      "è¶‡",
      "éƒ¤",
      "é‡³",
      "é˜‹",
      "éš™",
      "éšŸ",
      "éœ¼",
      "é¤¼",
      "é¥©",
      "é¬©",
      "é»–"
    ],
    cÃ¹: [
      "ä¿ƒ",
      "åª¨",
      "æ†±",
      "çŒ",
      "ç˜„",
      "ç˜¯",
      "ç°‡",
      "ç¸¬",
      "è„¨",
      "è”Ÿ",
      "èªŽ",
      "è¶—",
      "è¸§",
      "è¸¿",
      "è¹™",
      "è¹´",
      "è¹µ",
      "é†‹",
      "é¡£",
      "é¼€"
    ],
    Ã©: [
      "ä¿„",
      "å›®",
      "å¨¥",
      "å³‰",
      "å³¨",
      "å³©",
      "æ¶",
      "ç´",
      "çš’",
      "ç‹",
      "ç£€",
      "èŽª",
      "è¨›",
      "èª",
      "è­Œ",
      "è®¹",
      "è¿—",
      "éˆ‹",
      "é‹¨",
      "é”‡",
      "é Ÿ",
      "é¡",
      "é¢",
      "é­¤",
      "éµ",
      "éµž",
      "é¹…"
    ],
    qiÃº: [
      "ä¿…",
      "å´",
      "å”’",
      "å›š",
      "å´·",
      "å·¯",
      "å·°",
      "æ‰",
      "æ¢‚",
      "æ®",
      "æ¯¬",
      "æ±‚",
      "æ±“",
      "æ³…",
      "æµ—",
      "æ¹­",
      "ç…ª",
      "çŠ°",
      "çŽŒ",
      "çƒ",
      "ç’†",
      "çš³",
      "ç›š",
      "ç´Œ",
      "çµ¿",
      "è‚",
      "èŠ",
      "èŽ",
      "è™¬",
      "è™¯",
      "è›·",
      "è£˜",
      "è§“",
      "è§©",
      "è¨„",
      "è¨…",
      "è³•",
      "èµ‡",
      "é€Ž",
      "é€‘",
      "é’",
      "é…‹",
      "é‡š",
      "é‡»",
      "éŠ¶",
      "é „",
      "é®‚",
      "é¯„",
      "é°½",
      "é¼½",
      "ð¨±‡"
    ],
    xÃº: ["ä¿†", "å¾", "ç¦‘"],
    "guÃ ng kuÄng": ["ä¿‡"],
    kÃ¹: [
      "ä¿ˆ",
      "å–¾",
      "åš³",
      "åº“",
      "åº«",
      "å»¤",
      "ç˜”",
      "çµ",
      "ç»”",
      "è¢´",
      "è£¤",
      "è¤²",
      "é…·"
    ],
    wÃ¹: [
      "ä¿‰",
      "åŠ¡",
      "å‹™",
      "å‹¿",
      "å¼",
      "åž",
      "å¡¢",
      "å¥¦",
      "å©º",
      "å¯¤",
      "å±¼",
      "å²‰",
      "åµ¨",
      "å¿¢",
      "æ‚ž",
      "æ‚Ÿ",
      "æ‚®",
      "æˆŠ",
      "æ‰¤",
      "æ™¤",
      "æŒ",
      "æº©",
      "ç„",
      "ç†ƒ",
      "ç‰©",
      "ç—¦",
      "çŸ¹",
      "çª¹",
      "ç²…",
      "è˜",
      "èª¤",
      "è¯¯",
      "é‹ˆ",
      "é˜¢",
      "éš–",
      "é›¾",
      "éœš",
      "éœ§",
      "é°",
      "é¨–",
      "éª›",
      "é¶©",
      "é¹œ",
      "é¼¿",
      "é½€"
    ],
    jÃ¹n: [
      "ä¿Š",
      "å„",
      "å‘",
      "åŸˆ",
      "å¯¯",
      "å³»",
      "æ‡",
      "æƒ",
      "æ”Ÿ",
      "æ™™",
      "æ£ž",
      "ç‡‡",
      "çº",
      "ç•¯",
      "ç«£",
      "ç®Ÿ",
      "èœ ",
      "è³",
      "éƒ¡",
      "é™–",
      "é¤•",
      "é¦‚",
      "é§¿",
      "éª",
      "éµ”",
      "éµ•",
      "éµ˜",
      "äƒ"
    ],
    liÃ¡ng: [
      "ä¿",
      "å¢š",
      "æ¢",
      "æ¤‹",
      "æ¨‘",
      "ç²®",
      "ç²±",
      "ç³§",
      "è‰¯",
      "è¼¬",
      "è¾Œ",
      "ð«Ÿ…"
    ],
    zÇ”: ["ä¿Ž", "å”¨", "çˆ¼", "ç¥–", "çµ„", "ç»„", "è©›", "è¯…", "éŽº", "é˜»", "é»"],
    "qiÃ o xiÃ o": ["ä¿"],
    yÇ’ng: [
      "ä¿‘",
      "å‹‡",
      "å‹ˆ",
      "å’",
      "åŸ‡",
      "å¡Ž",
      "åµ±",
      "å½®",
      "æ€º",
      "æ¿",
      "æ‚€",
      "æƒ¥",
      "æ„‘",
      "æ„¹",
      "æ…‚",
      "æŸ¡",
      "æ ",
      "æ°¸",
      "æ³³",
      "æ¹§",
      "ç”¬",
      "è›¹",
      "è© ",
      "è¸Š",
      "è¸´",
      "é¯’",
      "é²¬"
    ],
    hÃ¹n: ["ä¿’", "å€±", "åœ‚", "å°¡", "æ…", "æŽ", "æº·", "ç„", "ç´", "è§¨", "è«¢", "è¯¨"],
    jÃ¬ng: [
      "ä¿“",
      "å‚¹",
      "å¢ƒ",
      "å¦Œ",
      "å©™",
      "å©§",
      "å¼ª",
      "å¼³",
      "å¾„",
      "å¾‘",
      "æ•¬",
      "æ›”",
      "æ¡±",
      "æ¢·",
      "æµ„",
      "ç€ž",
      "ç",
      "ç—‰",
      "ç—™",
      "ç«ž",
      "ç«Ÿ",
      "ç««",
      "ç«¶",
      "ç«¸",
      "èƒ«",
      "è„›",
      "èŽ–",
      "èª©",
      "è¸",
      "è¿³",
      "é€•",
      "é¡",
      "é•œ",
      "é–",
      "é™",
      "éœ",
      "éµ›"
    ],
    sÃ n: ["ä¿•", "é–"],
    pÄ›i: ["ä¿–"],
    sÃº: ["ä¿—"],
    xÄ«: [
      "ä¿™",
      "åƒ–",
      "å…®",
      "å‡ž",
      "å¥",
      "åŽ€",
      "å¸",
      "å”",
      "å”½",
      "å˜»",
      "å™",
      "åš±",
      "å¤•",
      "å¥š",
      "å¬†",
      "å¬‰",
      "å±–",
      "åµ ",
      "å·‡",
      "å¸Œ",
      "å¾†",
      "å¾¯",
      "æ¯",
      "æ‚‰",
      "æ‚•",
      "æƒ",
      "æƒœ",
      "æ˜”",
      "æ™ž",
      "æ™°",
      "æ™³",
      "æ›¦",
      "æž",
      "æ¡¸",
      "æ¦½",
      "æ¨¨",
      "æ©€",
      "æ¬·",
      "æ°¥",
      "æ±",
      "æµ ",
      "æ·…",
      "æ¸“",
      "æºª",
      "çƒ¯",
      "ç„",
      "ç„ˆ",
      "ç„Ÿ",
      "ç†„",
      "ç†ˆ",
      "ç†™",
      "ç†¹",
      "ç†º",
      "ç†»",
      "ç‡¨",
      "çˆ”",
      "ç‰º",
      "çŠ€",
      "çŠ ",
      "çŠ§",
      "ç‹",
      "ç˜œ",
      "çš™",
      "çŽ",
      "çž¦",
      "çŸ½",
      "ç¡’",
      "ç£Ž",
      "ç¤‚",
      "ç¨€",
      "ç©¸",
      "çª¸",
      "ç²ž",
      "ç³¦",
      "ç·†",
      "ç¹¥",
      "ç¾²",
      "ç¿•",
      "ç¿–",
      "è‚¸",
      "è‚¹",
      "è†",
      "èˆ¾",
      "èŽƒ",
      "è¥",
      "è’ ",
      "èœ¥",
      "èž…",
      "èŸ‹",
      "è µ",
      "è¥¿",
      "è§¹",
      "è§½",
      "è§¿",
      "è­†",
      "è°¿",
      "è±€",
      "è±¨",
      "è±¯",
      "è²•",
      "èµ¥",
      "é‚œ",
      "é„Ž",
      "é……",
      "é†¯",
      "é‡¸",
      "éŒ«",
      "é­",
      "éŠ",
      "é‘´",
      "é”¡",
      "éšµ",
      "é¤",
      "é¥Ž",
      "é¥»",
      "é¯‘",
      "éµ—",
      "é¸‚",
      "é¼·"
    ],
    lÇ: [
      "ä¿š",
      "å¨Œ",
      "å³¢",
      "å³²",
      "æŽ",
      "æ¬š",
      "æµ¬",
      "æ¾§",
      "ç†",
      "ç¤¼",
      "ç¦®",
      "ç²´",
      "è£",
      "è£¡",
      "è±Š",
      "é€¦",
      "é‚",
      "é†´",
      "é‹°",
      "é”‚",
      "é¯‰",
      "é±§",
      "é±±",
      "é²¤",
      "é³¢"
    ],
    bÇŽo: [
      "ä¿",
      "å ¢",
      "åª¬",
      "å®",
      "å¯š",
      "å¯³",
      "å¯¶",
      "ç¤",
      "ç·¥",
      "è‘†",
      "è—µ",
      "è¤“",
      "è³²",
      "éŒ",
      "é£¹",
      "é£½",
      "é¥±",
      "é§‚",
      "é³µ",
      "é´‡",
      "é¸¨"
    ],
    "yÃº shÃ¹ yÃ¹": ["ä¿ž"],
    "sÃ¬ qÃ­": ["ä¿Ÿ"],
    "xÃ¬n shÄ“n": ["ä¿¡"],
    xiÅ«: [
      "ä¿¢",
      "ä¿®",
      "å’»",
      "åº¥",
      "æ¨‡",
      "çƒŒ",
      "ç¾ž",
      "è„™",
      "è„©",
      "è‡¹",
      "è²…",
      "éŠ",
      "éŽ€",
      "é£",
      "é¥ˆ",
      "é¦",
      "é«¤",
      "é«¹",
      "é®´",
      "é±ƒ",
      "éµ‚",
      "é¸º",
      "ä—›"
    ],
    dÃ¬: [
      "ä¿¤",
      "å™",
      "åƒ€",
      "åŸŠ",
      "å¢‘",
      "å¢¬",
      "å¨£",
      "å¸",
      "æ€Ÿ",
      "æ—³",
      "æ¢Š",
      "ç„",
      "çŽ“",
      "ç”‹",
      "çœ±",
      "ç‡",
      "ç¢²",
      "ç¥¶",
      "ç¦˜",
      "ç¬¬",
      "ç· ",
      "ç¼”",
      "è…£",
      "è‚",
      "è’‚",
      "è”•",
      "èƒ",
      "è­",
      "èž®",
      "è«¦",
      "è°›",
      "è¸¶",
      "é€’",
      "é€“",
      "éž",
      "é°",
      "é‰ª",
      "ð¤§›",
      "ä—–"
    ],
    chÃ³u: [
      "ä¿¦",
      "å„”",
      "å¬¦",
      "æƒ†",
      "æ„",
      "æ‡¤",
      "æ ¦",
      "ç‡½",
      "ç•´",
      "ç–‡",
      "çš—",
      "ç¨ ",
      "ç­¹",
      "ç±Œ",
      "çµ’",
      "ç¶¢",
      "ç»¸",
      "è—",
      "è©¶",
      "è®Ž",
      "è®",
      "è¸Œ",
      "èºŠ",
      "é…§",
      "é…¬",
      "é†»",
      "é›”",
      "é› ",
      "é›¦"
    ],
    zhÃ¬: [
      "ä¿§",
      "å«",
      "å„¨",
      "åˆ¶",
      "åŠ•",
      "åž",
      "å¨¡",
      "å¯˜",
      "å¸™",
      "å¸œ",
      "å¹Ÿ",
      "åº¢",
      "åº¤",
      "å»Œ",
      "å½˜",
      "å¾",
      "å¾",
      "å¿—",
      "å¿®",
      "æ‡¥",
      "æ‡«",
      "æŒƒ",
      "æŒš",
      "æŽ·",
      "æ‘¯",
      "æ“²",
      "æ—˜",
      "æ™Š",
      "æ™º",
      "æ ‰",
      "æ¡Ž",
      "æ¢½",
      "æ«",
      "æ«›",
      "æ²»",
      "æ´·",
      "æ»",
      "æ»ž",
      "æ»¯",
      "æ½Œ",
      "ç€„",
      "ç‚™",
      "ç†«",
      "ç‹¾",
      "çŒ˜",
      "ç’",
      "ç“†",
      "ç—”",
      "ç—£",
      "ç¤©",
      "ç¥‘",
      "ç§©",
      "ç§·",
      "ç¨š",
      "ç¨º",
      "ç©‰",
      "çª’",
      "ç´©",
      "ç·»",
      "ç½®",
      "ç¿",
      "è†£",
      "è‡³",
      "è‡´",
      "èŠ–",
      "è›­",
      "è¢Ÿ",
      "è¢ ",
      "è£½",
      "è¦Ÿ",
      "è§—",
      "è§¯",
      "è§¶",
      "èªŒ",
      "è±‘",
      "è±’",
      "è²­",
      "è³ª",
      "è´„",
      "è´¨",
      "è´½",
      "è·±",
      "è¸¬",
      "èº“",
      "è¼Š",
      "è½¾",
      "éƒ…",
      "éŠ",
      "é‹•",
      "é‘•",
      "é“š",
      "é”§",
      "é™Ÿ",
      "éš²",
      "é›‰",
      "é§¤",
      "é¨­",
      "é¨º",
      "é©‡",
      "éª˜",
      "é¯¯",
      "é´™",
      "é·™",
      "é¸·",
      "ð¬ƒŠ"
    ],
    "liÇŽ liÇŽng": ["ä¿©"],
    jiÇŽn: [
      "ä¿­",
      "å€¹",
      "å„‰",
      "å‡",
      "å‰ª",
      "å ¿",
      "å¼¿",
      "å½…",
      "æˆ©",
      "æˆ¬",
      "æ‹£",
      "æŒ¸",
      "æ¡",
      "æ€",
      "æ’¿",
      "æž§",
      "æŸ¬",
      "æ¢˜",
      "æ£€",
      "æ¤œ",
      "æª¢",
      "æ¸›",
      "æ¹•",
      "ç€½",
      "ç‘",
      "ç‘",
      "çž¼",
      "ç¡·",
      "ç¢±",
      "ç¤†",
      "ç¬•",
      "ç­§",
      "ç®€",
      "ç°¡",
      "çµ¸",
      "ç¹­",
      "ç¿¦",
      "èŒ§",
      "è—†",
      "è ’",
      "è£¥",
      "è¥‡",
      "è¥‰",
      "è¥º",
      "è©ƒ",
      "è¬‡",
      "è¬­",
      "è­¾",
      "è°«",
      "è¶¼",
      "è¹‡",
      "é—",
      "é¬‹",
      "é°Ž",
      "é¹¸",
      "é¹»",
      "é¹¼"
    ],
    huÃ²: [
      "ä¿°",
      "å’Ÿ",
      "åš¯",
      "åš¿",
      "å¥¯",
      "å½ ",
      "æƒ‘",
      "æˆ–",
      "æ“­",
      "æ—¤",
      "æ›¤",
      "æª´",
      "æ²Ž",
      "æ¹±",
      "ç€–",
      "ç²",
      "ç™¨",
      "çœ“",
      "çŸ",
      "ç¥¸",
      "ç¦",
      "ç©«",
      "çª¢",
      "è€¯",
      "è‡›",
      "è‰§",
      "èŽ·",
      "è’¦",
      "è—¿",
      "è –",
      "è¬‹",
      "è²¨",
      "è´§",
      "éƒ",
      "é‘Š",
      "é•¬",
      "é›˜",
      "éœ",
      "éƒ",
      "éŸ„",
      "ã¸Œ"
    ],
    "jÃ¹ jÅ«": ["ä¿±", "æ®", "é‹¸", "é”¯"],
    xiÃ o: [
      "ä¿²",
      "å‚š",
      "åŠ¹",
      "å’²",
      "å“®",
      "å•¸",
      "å˜‹",
      "å˜¨",
      "å˜¯",
      "å­",
      "æ•ˆ",
      "æ–…",
      "æ–†",
      "æ­—",
      "æ¶",
      "ç†½",
      "ç¬‘",
      "è©¨",
      "èªŸ"
    ],
    pÃ¡i: ["ä¿³", "å¾˜", "ç‰Œ", "çŠ¤", "çŒ…", "ç°°", "ç°²", "è¼«"],
    biÃ o: ["ä¿µ", "é°¾", "é³”"],
    "chÃ¹ tÃ¬": ["ä¿¶"],
    fÃ¨i: [
      "ä¿·",
      "å‰•",
      "åŽž",
      "å ",
      "å±",
      "åºŸ",
      "å»ƒ",
      "å»¢",
      "æ˜²",
      "æ›Š",
      "æ« ",
      "æ²¸",
      "æ¿·",
      "ç‹’",
      "ç™ˆ",
      "è‚º",
      "è‰",
      "è²»",
      "è´¹",
      "é¨",
      "é•„",
      "é™«",
      "é…",
      "é¼£"
    ],
    fÃ¨ng: ["ä¿¸", "å‡¤", "å¥‰", "æ¹—", "ç„¨", "ç…ˆ", "è³µ", "èµ—", "é³¯", "é³³", "é´Œ"],
    ÇŽn: ["ä¿º", "å”µ", "åŸ¯", "æž", "ç½¯", "éŠ¨", "é“µ"],
    bÃ¨i: [
      "ä¿»",
      "å€",
      "å",
      "å¹",
      "å‚™",
      "åƒƒ",
      "å¤‡",
      "æ‚–",
      "æƒ«",
      "æ„‚",
      "æ†Š",
      "æ˜",
      "æ¢–",
      "ç„™",
      "ç‰¬",
      "çŠ•",
      "ç‹ˆ",
      "ç‹½",
      "ç¼",
      "ç²",
      "ç¢š",
      "ç¦™",
      "ç³’",
      "è‹",
      "è““",
      "è›½",
      "è¤™",
      "è²",
      "è´",
      "è»°",
      "è¼©",
      "è¾ˆ",
      "é‚¶",
      "éƒ¥",
      "é„",
      "é‹‡",
      "é¾",
      "é’¡",
      "éž",
      "éž´",
      "ð¬‡™"
    ],
    yÃ¹: [
      "ä¿¼",
      "å„¥",
      "å–…",
      "å–©",
      "å–»",
      "åŸŸ",
      "å ‰",
      "å¦ª",
      "å«—",
      "å¯“",
      "å³ª",
      "å¶Ž",
      "åº½",
      "å½§",
      "å¾¡",
      "æ„ˆ",
      "æ…¾",
      "æˆ«",
      "æ˜±",
      "æ£›",
      "æ£œ",
      "æ£«",
      "æ«²",
      "æ¬Ž",
      "æ¬",
      "æ¬²",
      "æ¯“",
      "æµ´",
      "æ·¯",
      "æ»ª",
      "æ½",
      "æ¾¦",
      "çª",
      "ç„´",
      "ç…œ",
      "ç‡",
      "ç‡ ",
      "çˆ©",
      "ç‹±",
      "ç„",
      "çŽ‰",
      "ç™",
      "ç˜‰",
      "ç™’",
      "ç ¡",
      "ç¡¢",
      "ç¡²",
      "ç¤‡",
      "ç¤–",
      "ç¤œ",
      "ç¦¦",
      "ç§—",
      "ç¨¢",
      "ç¨¶",
      "ç¯½",
      "ç±ž",
      "ç±²",
      "ç²–",
      "ç·Ž",
      "ç½­",
      "è¿",
      "è‚€",
      "è‰ˆ",
      "èŠ‹",
      "èŠŒ",
      "èŒŸ",
      "è’®",
      "è“£",
      "è“¹",
      "è•·",
      "è˜Œ",
      "èœŸ",
      "èœ®",
      "è¢¬",
      "è£•",
      "èª‰",
      "è«­",
      "è­½",
      "è°•",
      "è±«",
      "è»‰",
      "è¼",
      "é€³",
      "é‡",
      "é¹",
      "éƒ",
      "é†§",
      "éˆº",
      "é‹Š",
      "éŒ¥",
      "é­",
      "é’°",
      "é–¾",
      "é˜ˆ",
      "é›¤",
      "éœ±",
      "é ",
      "é¢„",
      "é£«",
      "é¥‡",
      "é¥«",
      "é¦­",
      "é©ˆ",
      "é©­",
      "é¬°",
      "é¬±",
      "é¬»",
      "é­Š",
      "é±Š",
      "é³¿",
      "é´¥",
      "é´§",
      "é´ª",
      "éµ’",
      "é·¸",
      "é¸’",
      "é¹†",
      "é¹¬"
    ],
    xÄ«n: [
      "ä¿½",
      "å™º",
      "å¦¡",
      "å¬œ",
      "å»ž",
      "å¿ƒ",
      "å¿„",
      "å¿»",
      "æƒž",
      "æ–°",
      "æ˜•",
      "æº",
      "æ¬£",
      "æ­†",
      "ç‚˜",
      "ç›º",
      "è–ª",
      "è¨¢",
      "è¾›",
      "é‚¤",
      "éˆŠ",
      "é‹…",
      "é‘«",
      "é”Œ",
      "é¦¨",
      "é¦«",
      "äœ£",
      "ð«··"
    ],
    "hÇ” chÃ­": ["ä¿¿"],
    jiÃ¹: [
      "å€ƒ",
      "åƒ¦",
      "åŒ“",
      "åŒ›",
      "åŒ¶",
      "åŽ©",
      "å’Ž",
      "å°±",
      "å»„",
      "å»",
      "å»",
      "æ…¦",
      "æ„",
      "æ•‘",
      "æ—§",
      "æŸ©",
      "æŸ¾",
      "æ¡•",
      "æ¬",
      "æ®§",
      "ç–š",
      "è‡¼",
      "èˆ…",
      "èˆŠ",
      "é¯¦",
      "é·²",
      "é¹«",
      "éº”",
      "é½¨",
      "ã ‡"
    ],
    yÃ¡o: [
      "å€„",
      "å‚œ",
      "å—‚",
      "åžš",
      "å ¯",
      "å§š",
      "åª±",
      "å°§",
      "å°­",
      "å³£",
      "å¶¢",
      "å¶¤",
      "å¾­",
      "æº",
      "æ–",
      "æ‘‡",
      "æ‘¿",
      "æšš",
      "æ¦£",
      "çƒ‘",
      "çˆ»",
      "çŒº",
      "ç§",
      "ç‘¤",
      "ç‘¶",
      "ç£˜",
      "çª‘",
      "çª¯",
      "çª°",
      "è‚´",
      "è˜¨",
      "è¬ ",
      "è¬¡",
      "è°£",
      "è»º",
      "è½º",
      "é™",
      "é¥",
      "é‚Ž",
      "é¡¤",
      "é¢»",
      "é£–",
      "é¤†",
      "é¤š",
      "é°©",
      "é±™",
      "é³"
    ],
    "cuÃ¬ zÃº": ["å€…"],
    "liÇŽng liÇŽ": ["å€†"],
    wÇŽn: [
      "å€‡",
      "å”",
      "å©‰",
      "æƒ‹",
      "æŒ½",
      "æ™š",
      "æ™¥",
      "æ™©",
      "æ™¼",
      "æ¢š",
      "æ¤€",
      "ç¬",
      "ç•¹",
      "çš–",
      "ç›Œ",
      "ç¢—",
      "ç¶©",
      "ç¶°",
      "ç»¾",
      "è„˜",
      "è–",
      "è¸ ",
      "è¼“",
      "é‹”"
    ],
    zÇ’ng: [
      "å€Š",
      "å¬",
      "å‚¯",
      "åµ¸",
      "æ€»",
      "æƒ£",
      "æ´",
      "æƒ",
      "æ‘ ",
      "ç‡ª",
      "ç·",
      "ç·«",
      "ç¸‚",
      "ç¸½",
      "è“—"
    ],
    guÄn: [
      "å€Œ",
      "å…³",
      "å®˜",
      "æ£º",
      "ç˜",
      "ç™",
      "çª¤",
      "è’„",
      "é–¢",
      "é——",
      "é—œ",
      "é°¥",
      "é±ž",
      "é³"
    ],
    tiÇŽn: [
      "å€Ž",
      "å”º",
      "å¿",
      "æ‚¿",
      "æ™ª",
      "æ®„",
      "æ·Ÿ",
      "ç“",
      "è…†",
      "èˆ”",
      "è¦¥",
      "è§",
      "è³Ÿ",
      "éŒª",
      "é¤‚"
    ],
    mÃ©n: ["å€‘", "æ‰ª", "æ«", "ç’Š", "è›", "è™‹", "é†", "é’”", "é–€", "é–…", "é—¨", "ð«ž©"],
    "dÇŽo dÃ o": ["å€’"],
    "tÃ¡n tÃ n": ["å€“", "åŸ®"],
    "juÃ¨ juÃ©": ["å€”"],
    chuÃ­: [
      "å€•",
      "åž‚",
      "åŸ€",
      "æ¶",
      "æ¥",
      "æ¡˜",
      "æ£°",
      "æ§Œ",
      "ç® ",
      "è…„",
      "è™",
      "éŒ˜",
      "éŽš",
      "é”¤",
      "é™²",
      "é¡€"
    ],
    xÃ¬ng: [
      "å€–",
      "å§“",
      "å©ž",
      "å¬¹",
      "å¹¸",
      "æ€§",
      "æ‚»",
      "æ",
      "æ¶¬",
      "ç·ˆ",
      "è‡–",
      "è‡",
      "èŽ•",
      "è‘•"
    ],
    pÃ©ng: [
      "å€—",
      "å‚°",
      "å¡œ",
      "å¡³",
      "å¼¸",
      "æ†‰",
      "æ€",
      "æœ‹",
      "æ£š",
      "æ¤–",
      "æ¨¥",
      "ç¡¼",
      "ç¨",
      "ç«¼",
      "ç¯·",
      "çº„",
      "è†¨",
      "èŠƒ",
      "è“¬",
      "è˜•",
      "èŸš",
      "èŸ›",
      "è¢¶",
      "è¼£",
      "éŒ‹",
      "é‘",
      "éŸ¸",
      "éŸ¼",
      "é¨¯",
      "é«¼",
      "é¬…",
      "é¬”",
      "éµ¬",
      "é¹"
    ],
    "tÇŽng chÃ¡ng": ["å€˜"],
    hÃ²u: [
      "å€™",
      "åŽš",
      "åŽ",
      "åž•",
      "å  ",
      "å¾Œ",
      "æ´‰",
      "èŒ©",
      "è±ž",
      "é€…",
      "éƒˆ",
      "é®œ",
      "é±Ÿ",
      "é²Ž",
      "é²˜"
    ],
    tÃ¬: [
      "å€œ",
      "å‰ƒ",
      "åš",
      "åš”",
      "å±‰",
      "å±œ",
      "æ‚Œ",
      "æ‚",
      "æƒ•",
      "æƒ–",
      "æˆ»",
      "æŽ¦",
      "æ›¿",
      "æœ‘",
      "æ­’",
      "æ®¢",
      "æ¶•",
      "ç“‹",
      "ç¬¹",
      "ç±Š",
      "è–™",
      "è¤…",
      "é€–",
      "é€·",
      "é«°",
      "é¬€",
      "é¬„"
    ],
    gÃ n: [
      "å€",
      "å‡Ž",
      "å¹¹",
      "æ¦¦",
      "æªŠ",
      "æ·¦",
      "ç¨",
      "ç›°",
      "ç´º",
      "ç»€",
      "è©Œ",
      "è´‘",
      "èµ£",
      "éª­",
      "ã½"
    ],
    "liÃ ng jÃ¬ng": ["å€ž", "é“"],
    suÄ«: [
      "å€ ",
      "å“¸",
      "å¤Š",
      "æ»–",
      "æ¿‰",
      "çœ­",
      "ç¢",
      "èŠ•",
      "è½",
      "è¾",
      "è™½",
      "é›–",
      "éž–"
    ],
    "chÃ ng chÄng": ["å€¡"],
    jiÃ©: [
      "å€¢",
      "å¼",
      "å‚‘",
      "åˆ¦",
      "åˆ§",
      "åˆ¼",
      "åŠ«",
      "åŠ¼",
      "å©",
      "åª",
      "å©•",
      "åª«",
      "å­‘",
      "å²Š",
      "å´¨",
      "åµ¥",
      "å¶»",
      "å·€",
      "å¹¯",
      "æˆª",
      "æ·",
      "æŽ¶",
      "æ“®",
      "æ˜…",
      "æ¢",
      "æ°",
      "æ¡€",
      "æ¡",
      "æ¥¬",
      "æ¥¶",
      "æ¦¤",
      "æ´",
      "æ»",
      "æ½”",
      "ç‹¤",
      "ç«",
      "ç¤",
      "ç«­",
      "ç¯€",
      "ç¾¯",
      "èŽ­",
      "è“µ",
      "è›£",
      "èœ",
      "è ˜",
      "è ž",
      "è ½",
      "è¡±",
      "è¢º",
      "è¨",
      "è©°",
      "èª±",
      "è®¦",
      "è¸•",
      "è¿¼",
      "é‰£",
      "é»",
      "é•¼",
      "é ¡",
      "é®š",
      "é²’",
      "ã›ƒ"
    ],
    "kÇ’ng kÅng": ["å€¥"],
    juÃ n: [
      "å€¦",
      "åŠµ",
      "å¥†",
      "æ…»",
      "æ¡Š",
      "æ·ƒ",
      "ç‹·",
      "ç§",
      "çœ·",
      "çŠ",
      "ç ",
      "çµ­",
      "çµ¹",
      "ç»¢",
      "ç½¥",
      "ç¾‚",
      "è…ƒ",
      "è”¨",
      "é„„",
      "é¤‹"
    ],
    zÅng: [
      "å€§",
      "å «",
      "å®—",
      "åµ",
      "åµ•",
      "æƒ¾",
      "æœ¡",
      "æ£•",
      "æ¤¶",
      "ç†§",
      "çŒ£",
      "ç£«",
      "ç·ƒ",
      "ç¿ª",
      "è…™",
      "è‘¼",
      "è¬",
      "è±µ",
      "è¸¨",
      "è¸ª",
      "è¹¤",
      "é",
      "é‘",
      "é¨Œ",
      "é¨£",
      "éª”",
      "é¬ƒ",
      "é¬‰",
      "é¬·",
      "é¯®",
      "é¯¼"
    ],
    nÃ­: [
      "å€ª",
      "å­",
      "åŸ¿",
      "å°¼",
      "å±”",
      "æ€©",
      "æ·£",
      "çŒŠ",
      "ç±¾",
      "è£",
      "èš­",
      "èœº",
      "è§¬",
      "è²Ž",
      "è·œ",
      "è¼—",
      "éƒ³",
      "éˆ®",
      "é“Œ",
      "éœ“",
      "é¦œ",
      "é¯¢",
      "é²µ",
      "éº‘",
      "é½¯",
      "ð«",
      "ð« œ"
    ],
    zhuÅ: [
      "å€¬",
      "æ‹™",
      "æ‰",
      "æ¡Œ",
      "æ¢²",
      "æ£",
      "æ£³",
      "æ§•",
      "æ¶¿",
      "çª§",
      "é¯",
      "ä¦ƒ"
    ],
    "wÅ wÄ“i": ["å€­"],
    luÇ’: ["å€®", "å‰†", "æ›ª", "ç˜°", "ç™³", "è‡", "è“", "è ƒ", "è£¸", "èº¶"],
    sÅng: [
      "å€¯",
      "å‡‡",
      "å¨€",
      "å´§",
      "åµ©",
      "åºº",
      "æ†½",
      "æ¾",
      "æž€",
      "æž©",
      "æŸ—",
      "æ¢¥",
      "æª§",
      "æ·ž",
      "æ¿",
      "ç¡¹",
      "è˜",
      "é¬†"
    ],
    lÃ¨ng: ["å€°", "å Ž", "æ„£", "ç–", "è¸œ"],
    zÃ¬: [
      "å€³",
      "å‰š",
      "å­—",
      "æ£",
      "æ¸",
      "æ¼¬",
      "ç‰¸",
      "çœ¥",
      "çœ¦",
      "èƒ”",
      "èƒ¾",
      "è‡ª",
      "èŒ¡",
      "è¢"
    ],
    bÃ¨n: ["å€´", "åŒ", "æ¹", "æ’ª", "æ¸€", "ç¬¨", "é€©"],
    cÇŽi: ["å€¸", "å•‹", "å©‡", "å½©", "æŽ¡", "æ£Œ", "æ¯", "ç¬", "ç¶µ", "è·´", "è¸©"],
    zhÃ i: ["å€º", "å‚µ", "å¯¨", "ç˜µ", "ç ¦"],
    yÄ“: ["å€»", "å”", "å™Ž", "æ“¨", "æš", "æ¤°", "æ­‹", "æ½±", "è ®"],
    shÃ : ["å€½", "å”¼", "å–¢", "æ­ƒ", "ç®‘", "ç¿œ", "ç¿£", "è", "é–¯", "éœŽ"],
    qÄ«ng: [
      "å€¾",
      "å‚¾",
      "å¿",
      "åœŠ",
      "å¯ˆ",
      "æ°¢",
      "æ°«",
      "æ·¸",
      "æ¸…",
      "èœ»",
      "è»½",
      "è¼•",
      "è½»",
      "éƒ¬",
      "éŒ†",
      "é‘‹",
      "é‘",
      "é’",
      "é¯–"
    ],
    yÄ«ng: [
      "å€",
      "å˜¤",
      "å™Ÿ",
      "åš¶",
      "å©´",
      "åª–",
      "å«ˆ",
      "å¬°",
      "å­†",
      "å­¾",
      "æ„¥",
      "æ’„",
      "æ”–",
      "æœ ",
      "æ¡œ",
      "æ¨±",
      "æ«»",
      "æ¸¶",
      "ç…",
      "ç±",
      "ç‘›",
      "ç’Ž",
      "ç“”",
      "ç”‡",
      "ç”–",
      "ç¢¤",
      "ç¤¯",
      "ç·“",
      "çº“",
      "ç»¬",
      "ç¼¨",
      "ç½‚",
      "ç½ƒ",
      "ç½Œ",
      "è†º",
      "è‹±",
      "èŽº",
      "è˜¡",
      "è§",
      "è ³",
      "è¤®",
      "è­»",
      "è³",
      "è»ˆ",
      "é‘",
      "é”³",
      "éœ™",
      "éŸº",
      "é´¬",
      "é¶‘",
      "é¶§",
      "é¶¯",
      "é·ª",
      "é·¹",
      "é¸Ž",
      "é¸š",
      "é¹¦",
      "é¹°",
      "ä“¨"
    ],
    "chÄ“ng chÃ¨n": ["å", "çˆ¯"],
    ruÇŽn: ["å„", "æœŠ", "ç‘Œ", "ç“€", "ç¢", "ç¤", "è…", "è»Ÿ", "è¼­", "è½¯", "é˜®"],
    "zhÃ²ng tÃ³ng": ["å…"],
    chÇ”n: ["å†", "æƒ·", "ç¶", "è¶", "è ¢", "è³°"],
    "jiÇŽ jiÃ ": ["å‡"],
    "jÃ¬ jiÃ©": ["åˆ"],
    "bÇng bÃ¬ng": ["å‹"],
    ruÃ²: [
      "åŒ",
      "å’",
      "åµ¶",
      "å¼±",
      "æ¥‰",
      "ç„«",
      "çˆ‡",
      "ç®¬",
      "ç¯›",
      "è’»",
      "é„€",
      "é°™",
      "é°¯",
      "é¶¸"
    ],
    tÃ­: [
      "å",
      "åŽ—",
      "å•¼",
      "å—",
      "å´¹",
      "æ¼½",
      "ç‘…",
      "ç¼",
      "ç¦µ",
      "ç¨Š",
      "ç·¹",
      "ç¼‡",
      "ç½¤",
      "è•›",
      "è¤†",
      "è¬•",
      "è¶§",
      "è¹„",
      "è¹",
      "é†",
      "é—",
      "é¡Œ",
      "é¢˜",
      "é¨ ",
      "é®·",
      "é¯·",
      "é³€",
      "éµœ",
      "é·¤",
      "é¹ˆ",
      "ð«˜¨"
    ],
    wÄ“i: [
      "åŽ",
      "å±",
      "å–´",
      "å¨",
      "åª™",
      "å¶¶",
      "å·",
      "å¾®",
      "æ„„",
      "æ‹",
      "æ»",
      "æ¤³",
      "æ¥²",
      "æº¦",
      "çƒ“",
      "ç…¨",
      "ç‡°",
      "ç™“",
      "ç¸…",
      "è‘¨",
      "è‘³",
      "è–‡",
      "èœ²",
      "è›",
      "è¦£",
      "è©´",
      "é€¶",
      "éš‡",
      "éšˆ",
      "éœº",
      "é°ƒ",
      "é°„",
      "é³‚"
    ],
    piÄn: ["å", "å›¨", "åª¥", "æ¥„", "çŠ", "ç¯‡", "ç¿©", "é‚"],
    yÃ n: [
      "å",
      "åŽŒ",
      "åŽ­",
      "å”",
      "å–­",
      "åšˆ",
      "åš¥",
      "å °",
      "å¦Ÿ",
      "å§²",
      "å¬Š",
      "å¬¿",
      "å®´",
      "å½¥",
      "å½¦",
      "æ•¥",
      "æ™",
      "æš¥",
      "æ›•",
      "æ›£",
      "æ»Ÿ",
      "çŽ",
      "ç”",
      "ç§",
      "ç©",
      "ç„”",
      "ç„°",
      "ç„±",
      "ç†–",
      "ç‡„",
      "ç‰ª",
      "çŒ’",
      "ç š",
      "ç¡¯",
      "è‰³",
      "è‰¶",
      "è‰·",
      "è¦Ž",
      "è§ƒ",
      "è§¾",
      "è«º",
      "è®Œ",
      "è®ž",
      "è°š",
      "è°³",
      "è±“",
      "è±”",
      "è´‹",
      "è´—",
      "èµ",
      "è»…",
      "é…€",
      "é…½",
      "é†¼",
      "é‡…",
      "é›",
      "é¤",
      "é¥œ",
      "é¨",
      "é¨“",
      "é¨´",
      "é©—",
      "é© ",
      "éªŒ",
      "é¬³",
      "é³«",
      "é´ˆ",
      "é´³",
      "é·ƒ",
      "é·°",
      "é½ž"
    ],
    "tÇŽng dÃ ng": ["å’"],
    Ã¨: [
      "å”",
      "åŒŽ",
      "å¾",
      "åŽ„",
      "å‘",
      "å’¢",
      "å™©",
      "åž©",
      "å Š",
      "å ®",
      "å²‹",
      "å´¿",
      "å»…",
      "æ‚ª",
      "æ„•",
      "æˆ¹",
      "æ‰¼",
      "æ¤",
      "æ¹",
      "æ“œ",
      "æ«®",
      "æ­ž",
      "æ­º",
      "æ¹‚",
      "ç§",
      "ç ˆ",
      "ç ",
      "ç¡†",
      "è…­",
      "è‹Š",
      "è¼",
      "è•š",
      "èš…",
      "è",
      "è¦¨",
      "è«¤",
      "è®",
      "è°”",
      "è±Ÿ",
      "è»›",
      "è»¶",
      "è½­",
      "éŒ",
      "é",
      "é»",
      "é„‚",
      "éˆª",
      "é”",
      "é‘©",
      "é”·",
      "é˜¨",
      "é˜¸",
      "é ž",
      "é¡Ž",
      "é¢š",
      "é¤“",
      "é¤©",
      "é¥¿",
      "é°",
      "é°ª",
      "é±·",
      "é³„",
      "é¶š",
      "é¹—",
      "é½ƒ",
      "é½¶",
      "ð««‡",
      "ð¥”²"
    ],
    xiÃ©: [
      "å•",
      "å‹°",
      "å",
      "å”",
      "å—‹",
      "åž¥",
      "å¥Š",
      "æŠ",
      "æ„¶",
      "æ‹¹",
      "æº",
      "æ’·",
      "æ“•",
      "æ“·",
      "æ”œ",
      "æ–œ",
      "æ—ª",
      "ç†",
      "ç‡²",
      "ç¶Š",
      "ç·³",
      "ç¸€",
      "ç¼¬",
      "ç¿“",
      "èƒ",
      "è„…",
      "è„‡",
      "è„‹",
      "è†Ž",
      "è¢",
      "è¡º",
      "è¥­",
      "è«§",
      "è®—",
      "è°",
      "éž‹",
      "éžµ",
      "é¾¤",
      "ã™¦"
    ],
    chÄ›: ["å–", "æ‰¯", "æ’¦"],
    shÄ›ng: ["å—", "æ¸»", "çœš"],
    chÄ: [
      "å›",
      "å—",
      "æ‰ ",
      "æŒ¿",
      "æ’",
      "æ·",
      "ç–€",
      "è‡¿",
      "è‰–",
      "éŠŸ",
      "é¤",
      "é”¸",
      "é¤·"
    ],
    huÃ¡ng: [
      "åŸ",
      "å‡°",
      "å–¤",
      "å ­",
      "å¢´",
      "åª“",
      "å´²",
      "å¾¨",
      "æƒ¶",
      "æ¥»",
      "æ¹Ÿ",
      "ç…Œ",
      "çš",
      "ç‘",
      "ç’œ",
      "ç™€",
      "çš‡",
      "ç£º",
      "ç©”",
      "ç¯",
      "ç°§",
      "è‰Ž",
      "è‘Ÿ",
      "è—",
      "èŸ¥",
      "è«»",
      "è¶ª",
      "é‘",
      "é ",
      "é„",
      "é”½",
      "éš",
      "éŸ¹",
      "é¤­",
      "é¨œ",
      "é°‰",
      "é±‘",
      "é³‡",
      "é·¬",
      "é»ƒ",
      "é»„",
      "ð¨±‘"
    ],
    yÇŽo: [
      "å ",
      "å’¬",
      "å©¹",
      "å®Ž",
      "å²†",
      "æ³",
      "æŸ¼",
      "æ¦š",
      "æº”",
      "ç‹•",
      "çª…",
      "çªˆ",
      "èˆ€",
      "è‹­",
      "é—„",
      "é¨•",
      "é·•",
      "é½©"
    ],
    "chÇ’u qiÃ o": ["å¢"],
    yÃ³u: [
      "å¤",
      "å°¤",
      "åº®",
      "æ€£",
      "æ²‹",
      "æ²¹",
      "æµŸ",
      "æ¸¸",
      "çŠ¹",
      "çŒ¶",
      "çŒ·",
      "ç”±",
      "ç–£",
      "ç§ž",
      "è‚¬",
      "èŽœ",
      "èŽ¸",
      "è••",
      "èš°",
      "è£",
      "è¨§",
      "è¼",
      "è¼¶",
      "é€°",
      "éŠ",
      "é‚®",
      "éƒµ",
      "éˆ¾",
      "é“€",
      "é§€",
      "é­·",
      "é®‹",
      "é±¿",
      "é²‰",
      "ð¬¨Ž"
    ],
    xÅ«: [
      "å¦",
      "å¢Ÿ",
      "åª­",
      "å¬ƒ",
      "æ¥ˆ",
      "æ¬¨",
      "æ­”",
      "ç‡¸",
      "ç–ž",
      "ç›±",
      "ç¶‡",
      "ç¸ƒ",
      "ç¹»",
      "èƒ¥",
      "è•¦",
      "è™—",
      "è™š",
      "è™›",
      "è‘",
      "è£‡",
      "è¨",
      "è¨±",
      "è«",
      "è­ƒ",
      "è°ž",
      "é‘",
      "éœ€",
      "é ˆ",
      "é¡»",
      "é¡¼",
      "é©‰",
      "é¬š",
      "é­†",
      "é­–",
      "ð¬£™",
      "ð¦ˆ¡"
    ],
    zhÄ: [
      "å§",
      "å“³",
      "æŠ¯",
      "æŒ“",
      "æ¸",
      "æ‘£",
      "æ¨",
      "æ¸£",
      "çš¶",
      "è§°",
      "è­‡",
      "é½„",
      "é½‡"
    ],
    cÄ«: ["å¨", "ç–µ", "è €", "è¶€", "éª´", "é«Š", "é½¹"],
    bÄ«: ["åª", "å±„", "æ¥…", "æ¯´", "è±", "é€¼", "é°", "é²¾", "éµ–"],
    xÃºn: [
      "å±",
      "å™š",
      "å¯»",
      "å°‹",
      "å³‹",
      "å·¡",
      "å»µ",
      "å¾ª",
      "æ‚",
      "æ—",
      "æ”³",
      "æ—¬",
      "æŠ",
      "æ ’",
      "æ¡ª",
      "æ¨³",
      "æ´µ",
      "æµ”",
      "æ½¯",
      "ç‡…",
      "ç‡–",
      "ç£",
      "ç’•",
      "ç•ƒ",
      "ç´ƒ",
      "è€",
      "èŸ³",
      "è©¢",
      "è¯¢",
      "é„©",
      "é±",
      "é±˜",
      "é²Ÿ",
      "ð¬˜“",
      "ð¬©½",
      "ð¬¤",
      "ð¬Šˆ"
    ],
    "cÄi sÄ«": ["å²"],
    duÄn: ["å³", "åª", "ç«¯", "è¤", "é´"],
    Ç’u: ["å¶", "å˜", "å˜”", "è€¦", "è…¢", "è•…", "è—•", "ð¬‰¼", "ð ™¶"],
    tÅu: ["å·", "å¸", "é®"],
    "zÃ¡n zÃ¡ zÇŽ": ["åº"],
    "lÇš lÃ³u": ["å»", "åƒ‚"],
    fÃ¨n: [
      "å¾",
      "åƒ¨",
      "å¥‹",
      "å¥®",
      "å¼…",
      "å¿¿",
      "æ„¤",
      "æ†¤",
      "ç€µ",
      "çž“",
      "ç§Ž",
      "ç²ª",
      "ç³ž",
      "è†¹",
      "é±",
      "é²¼"
    ],
    "kuÇ guÄ«": ["å‚€"],
    sÇ’u: ["å‚", "åœ", "åŸ", "å—¾", "æ«¢", "çž", "è–®", "è—ª"],
    "zhÃ¬ sÄ« tÃ­": ["å‚‚"],
    sÃ¹: [
      "å‚ƒ",
      "åƒ³",
      "å—‰",
      "å¡",
      "å¡‘",
      "å¤™",
      "å«Š",
      "æ„«",
      "æ†Ÿ",
      "æ¦¡",
      "æ¨Ž",
      "æ¨•",
      "æ®",
      "æ³",
      "æ¶‘",
      "æº¯",
      "æº¸",
      "æ½š",
      "æ½¥",
      "çŽŠ",
      "çŸ",
      "ç’›",
      "ç°Œ",
      "ç²›",
      "ç²Ÿ",
      "ç´ ",
      "ç¸¤",
      "è‚ƒ",
      "è‚…",
      "è††",
      "è”Œ",
      "è——",
      "è§«",
      "è¨´",
      "è¬–",
      "è¯‰",
      "è°¡",
      "è¶š",
      "è¹œ",
      "é€Ÿ",
      "é¡",
      "é¬",
      "é‹‰",
      "é¤—",
      "é©Œ",
      "éª•",
      "é±",
      "é·«",
      "é¹”",
      "ð«—§"
    ],
    xiÄ: ["å‚„", "ç…†", "çžŽ", "è™²", "è°º", "é¢¬", "é°•"],
    "yuÃ n yuÃ¡n": ["å‚†", "åª›"],
    rÇ’ng: ["å‚‡", "å†—", "å®‚", "æ°„", "è»µ"],
    nÃ¹: ["å‚‰", "æ€’"],
    yÃ¹n: [
      "å‚Š",
      "å­•",
      "æ½",
      "æƒ²",
      "æ„ ",
      "æ…",
      "æžŸ",
      "è…ª",
      "è•´",
      "è–€",
      "è—´",
      "è˜Š",
      "è¤ž",
      "è²Ÿ",
      "è¿",
      "é‹",
      "éƒ“",
      "é„†",
      "é…",
      "é†–",
      "é†ž",
      "éŸ—",
      "éŸž",
      "éŸµ",
      "éŸ»",
      "é¤«"
    ],
    "gÃ²u jiÇŽng": ["å‚‹"],
    mÃ : ["å‚Œ", "å˜œ", "æ¦ª", "ç°", "ç¥ƒ", "ç¦¡", "ç½µ", "é–", "é§¡", "éª‚", "é¬•"],
    bÃ ng: [
      "å‚",
      "å¡",
      "æ£’",
      "çŽ¤",
      "ç¨–",
      "è‰•",
      "è’¡",
      "èœ¯",
      "è¬—",
      "è°¤",
      "éŽŠ",
      "é•‘"
    ],
    diÄn: [
      "å‚Ž",
      "åŽ§",
      "åµ®",
      "å·…",
      "å·“",
      "å·”",
      "æŽ‚",
      "æ”§",
      "æ•",
      "æ§‡",
      "æ»‡",
      "ç™«",
      "ç™²",
      "è¹Ž",
      "é¡š",
      "é¡›",
      "é¢ ",
      "é½»"
    ],
    tÃ¡ng: [
      "å‚",
      "å”",
      "å•º",
      "å£",
      "å ‚",
      "å¡˜",
      "æª",
      "æ£ ",
      "æ¦¶",
      "æº",
      "æ¼Ÿ",
      "ç…»",
      "ç‘­",
      "ç£„",
      "ç¦Ÿ",
      "ç¯–",
      "ç³ƒ",
      "ç³–",
      "ç³›",
      "è†…",
      "è†›",
      "è“Ž",
      "èž—",
      "èž³",
      "èµ¯",
      "è¸¼",
      "é„Œ",
      "é†£",
      "éŽ•",
      "éšš",
      "é¤¹",
      "é¥„",
      "é¶¶",
      "ä£˜"
    ],
    hÃ o: [
      "å‚",
      "å“ ",
      "æ",
      "æ˜Š",
      "æ˜¦",
      "æ™§",
      "æš ",
      "æš¤",
      "æš­",
      "æ›",
      "æµ©",
      "æ·",
      "æ¾”",
      "ç",
      "ç",
      "çš“",
      "çšœ",
      "çšž",
      "çš¡",
      "çš¥",
      "è€—",
      "è•",
      "è–ƒ",
      "è™Ÿ",
      "é„—",
      "é¡¥",
      "é¢¢",
      "é°"
    ],
    "xÄ« xÃ¬": ["å‚’"],
    shÄn: [
      "å‚“",
      "åˆ ",
      "åˆª",
      "å‰¼",
      "åœ¸",
      "å±±",
      "æŒ»",
      "æ§",
      "æŸµ",
      "æª†",
      "æ½¸",
      "æ¾˜",
      "ç…½",
      "ç‹¦",
      "çŠ",
      "ç¬˜",
      "ç¸¿",
      "ç¾´",
      "ç¾¶",
      "è„ ",
      "èˆ¢",
      "èŠŸ",
      "è¡«",
      "è·š",
      "è»•",
      "é‚–",
      "é–Š",
      "é¯…"
    ],
    "qiÃ n jiÄn": ["å‚”"],
    "quÃ¨ juÃ©": ["å‚•", "åŸ†"],
    "cÄng chen": ["å‚–"],
    rÃ³ng: [
      "å‚›",
      "åª¶",
      "å«†",
      "å¬«",
      "å®¹",
      "å³µ",
      "åµ˜",
      "å¶¸",
      "æˆŽ",
      "æˆ",
      "æ›§",
      "æ „",
      "æ¦•",
      "æ¦®",
      "æ¦µ",
      "æ¯§",
      "æº¶",
      "ç€œ",
      "çƒ¿",
      "ç†”",
      "ç‹¨",
      "ç‘¢",
      "ç©",
      "çµ¨",
      "ç»’",
      "ç¾¢",
      "è‚œ",
      "èŒ™",
      "èŒ¸",
      "è£",
      "è“‰",
      "è¾",
      "èž",
      "èžŽ",
      "è ‘",
      "è¤£",
      "éŽ”",
      "é••",
      "é§¥"
    ],
    "tÃ  tÃ n": ["å‚"],
    suÅ: [
      "å‚ž",
      "å”†",
      "å—",
      "å—¦",
      "å¨‘",
      "æ‘",
      "æ¡«",
      "æ¢­",
      "çƒ",
      "ç°‘",
      "ç°”",
      "ç¾§",
      "èŽ",
      "è“‘",
      "è¶–",
      "é®»"
    ],
    dÇŽi: ["å‚£", "æ­¹"],
    zÃ i: ["å‚¤", "å„Ž", "å†", "åœ¨", "æ‰—", "æ´…", "è¼‰", "é…¨"],
    gÇ”: [
      "å‚¦",
      "å¤",
      "å•’",
      "å°³",
      "æ„²",
      "æ¦–",
      "æ¦¾",
      "æ±©",
      "æ·ˆ",
      "æ¿²",
      "ç€”",
      "ç‰¯",
      "çš·",
      "çš¼",
      "ç›¬",
      "çž½",
      "ç©€",
      "ç½Ÿ",
      "ç¾–",
      "è‚¡",
      "è„µ",
      "è‡Œ",
      "è–£",
      "è›Š",
      "è ±",
      "è©",
      "è¯‚",
      "è½‚",
      "é€§",
      "éˆ·",
      "é’´",
      "é¤¶",
      "é¦‰",
      "é¼“",
      "é¼”",
      "ð¦™¶"
    ],
    bÄ«n: [
      "å‚§",
      "å®¾",
      "å½¬",
      "æ–Œ",
      "æ¤•",
      "æ»¨",
      "æ¿’",
      "æ¿±",
      "æ¿µ",
      "ç€•",
      "ç¹½",
      "ç¼¤",
      "è™¨",
      "è±©",
      "è±³",
      "è³“",
      "è³”",
      "é‚ ",
      "é‘Œ",
      "é•”",
      "éœ¦",
      "é¡®"
    ],
    chÇ”: [
      "å‚¨",
      "å„²",
      "æµ",
      "æ¤˜",
      "æ¥š",
      "æ¥®",
      "æªš",
      "æ¿‹",
      "ç’´",
      "ç¡€",
      "ç¤Ž",
      "ç¦‡",
      "è™•",
      "é½­",
      "é½¼",
      "ð¬º“"
    ],
    nuÃ³: ["å‚©", "å„º", "æŒª", "æ¢›", "æ© "],
    "cÄn cÃ n": ["å‚ª"],
    lÄ›i: [
      "å‚«",
      "å„¡",
      "åŽ½",
      "åž’",
      "å¡",
      "å£˜",
      "å£¨",
      "æ«",
      "ç…",
      "ç™—",
      "çŸ‹",
      "ç£Š",
      "ç¤¨",
      "è€’",
      "è•Œ",
      "è•¾",
      "è—Ÿ",
      "è˜½",
      "è ",
      "èª„",
      "è®„",
      "è¯”",
      "é‘¸",
      "é¸“"
    ],
    cuÄ«: ["å‚¬", "å‡—", "å¢”", "å´”", "åµŸ", "æ…›", "æ‘§", "æ¦±", "ç•", "ç£ª", "é™"],
    yÅng: [
      "å‚­",
      "å—ˆ",
      "å¢‰",
      "å£…",
      "å«ž",
      "åº¸",
      "å»±",
      "æ…µ",
      "æ‹¥",
      "æ“",
      "æ»½",
      "ç‰",
      "ç‰…",
      "ç—ˆ",
      "ç™•",
      "ç™°",
      "è‡ƒ",
      "é‚•",
      "éƒº",
      "é„˜",
      "éž",
      "é•›",
      "é›",
      "é›",
      "é¥”",
      "é±…",
      "é³™",
      "é·›"
    ],
    "zÄo cÃ¡o": ["å‚®"],
    sÇ’ng: ["å‚±", "åµ·", "æ€‚", "æ‚š", "æ„¯", "æ…«", "ç«¦", "è€¸", "è³", "é§·", "ã§"],
    Ã o: [
      "å‚²",
      "å³",
      "åž‡",
      "å¢º",
      "å¥¡",
      "å«¯",
      "å²™",
      "å²°",
      "å¶´",
      "æ‡Š",
      "æ“™",
      "æ¾³",
      "éŠ",
      "é©",
      "éªœ"
    ],
    "qÄ« cÃ²u": ["å‚¶"],
    chuÇŽng: ["å‚¸", "ç£¢", "é—–", "é—¯"],
    shÇŽ: ["å‚»", "å„"],
    hÃ n: [
      "å‚¼",
      "åž¾",
      "æ‚",
      "æ†¾",
      "æ‰ž",
      "æ",
      "æ’–",
      "æ’¼",
      "æ—±",
      "æ™˜",
      "æšµ",
      "æ±‰",
      "æ¶†",
      "æ¼¢",
      "ç€š",
      "ç„Š",
      "çŒ‚",
      "çš”",
      "ç…",
      "ç¿°",
      "èŽŸ",
      "è¡",
      "è›¿",
      "èœ­",
      "èž’",
      "è­€",
      "è¼š",
      "é‡¬",
      "éŠ²",
      "é‹Ž",
      "é›—",
      "é ·",
      "é¡„",
      "é¢”",
      "é§»",
      "é¶¾"
    ],
    zhÄng: [
      "å‚½",
      "å«œ",
      "å¼ ",
      "å¼µ",
      "å½°",
      "æ…ž",
      "æš²",
      "æ¨Ÿ",
      "æ¼³",
      "ç",
      "ç’‹",
      "ç« ",
      "ç²»",
      "è”",
      "èŸ‘",
      "é§",
      "é„£",
      "é±",
      "é¤¦",
      "é¨¿",
      "é±†",
      "éºž"
    ],
    "yÄn yÃ n": ["å‚¿", "å¢•", "å¬®"],
    "piÃ o biÄo": ["åƒ„", "éª "],
    liÃ n: [
      "åƒ†",
      "å œ",
      "åª¡",
      "æ‹",
      "æˆ€",
      "æ¥",
      "æ®“",
      "æ®®",
      "æ¹…",
      "æ½‹",
      "æ¾°",
      "ç€²",
      "ç‚¼",
      "ç…‰",
      "ç‘“",
      "ç·´",
      "çºž",
      "ç»ƒ",
      "è°",
      "éŒ¬",
      "éŠ",
      "éˆ",
      "é“¾",
      "é°Š",
      "ð¬¶ "
    ],
    mÃ n: [
      "ãµ˜",
      "åƒˆ",
      "å¢",
      "å¹”",
      "æ…¢",
      "æ›¼",
      "æ¼«",
      "æ¾·",
      "ç†³",
      "çŒ",
      "ç¸µ",
      "ç¼¦",
      "è”„",
      "è˜°",
      "é„¤",
      "é",
      "é•˜",
      "ð¬œ¬"
    ],
    "tÃ n tÇŽn": ["åƒ‹"],
    yÃ­ng: [
      "åƒŒ",
      "å–¶",
      "å¡‹",
      "å¬´",
      "æ”",
      "æ¥¹",
      "æ«¿",
      "æº",
      "æº‹",
      "æ»¢",
      "æ½†",
      "æ¿™",
      "æ¿š",
      "æ¿´",
      "ç€…",
      "ç€›",
      "ç€ ",
      "ç€¯",
      "ç",
      "çœ",
      "ç†’",
      "ç‡Ÿ",
      "ç‘©",
      "ç›",
      "ç›ˆ",
      "ç¦œ",
      "ç±",
      "ç±¯",
      "ç¸ˆ",
      "èŒ”",
      "è§",
      "èŽ¹",
      "è¤",
      "è¥",
      "è¦",
      "è¾",
      "è“¥",
      "è—€",
      "è›",
      "è‡",
      "è¿",
      "èž¢",
      "è …",
      "è¬",
      "è´",
      "èµ¢",
      "è¿Ž",
      "éŽ£"
    ],
    dÃ²ng: [
      "åƒ",
      "å†»",
      "å‡",
      "åŠ¨",
      "å‹•",
      "å§›",
      "æˆ™",
      "æŒ",
      "æ ‹",
      "æ£Ÿ",
      "æ¹©",
      "ç¡",
      "èƒ¨",
      "èƒ´",
      "è…–",
      "è¿µ",
      "éœ˜",
      "é§§"
    ],
    zhuÃ n: [
      "åƒŽ",
      "å•­",
      "å›€",
      "å Ÿ",
      "æ’°",
      "ç·",
      "ç‘‘",
      "ç¯†",
      "è…ž",
      "è’ƒ",
      "è¥ˆ",
      "è­”",
      "é¥Œ",
      "é¦”"
    ],
    xiÃ ng: [
      "åƒ",
      "å‹¨",
      "å‘",
      "åš®",
      "å§ ",
      "å¶‘",
      "æ›",
      "æ©¡",
      "ç¦",
      "ç¼¿",
      "èŸ“",
      "è¡–",
      "è¥",
      "è±¡",
      "éŒ",
      "é …",
      "é¡¹",
      "é±Œ"
    ],
    shÃ n: [
      "åƒ",
      "å–„",
      "å¢ ",
      "å¢¡",
      "å¬—",
      "æ“…",
      "æ•¾",
      "æ¤«",
      "æ¨¿",
      "æ­š",
      "æ±•",
      "ç—",
      "ç–",
      "ç£°",
      "ç¹•",
      "ç¼®",
      "è†³",
      "èŸ®",
      "èŸº",
      "è¨•",
      "è¬†",
      "è­±",
      "è®ª",
      "è´",
      "èµ¡",
      "èµ¸",
      "é„¯",
      "é¥",
      "é¥",
      "é¨¸",
      "éªŸ",
      "é±“",
      "é±”",
      "é³",
      "ð«®ƒ"
    ],
    "tuÃ­ tuÇ": ["åƒ“"],
    zÇ”n: ["åƒ”", "å™‚", "æ’™", "è­"],
    pÃº: [
      "åƒ•",
      "åŒ",
      "åœ¤",
      "å¢£",
      "æ¿®",
      "ç›",
      "ç’ž",
      "çž¨",
      "ç©™",
      "èŽ†",
      "è",
      "è©",
      "è‘¡",
      "è’±",
      "è’²",
      "è´Œ",
      "é…º",
      "é·",
      "é•¤"
    ],
    lÃ¡o: [
      "åƒ—",
      "åŠ³",
      "åŠ´",
      "å‹ž",
      "å“°",
      "å´‚",
      "å¶—",
      "æ†¥",
      "æœ¥",
      "æµ¶",
      "ç‰¢",
      "ç—¨",
      "ç™†",
      "çª‚",
      "ç°©",
      "é†ª",
      "é’",
      "é“¹",
      "é¡Ÿ",
      "é«",
      "ð«­¼"
    ],
    chÇŽng: ["åƒ˜", "åŽ°", "å» ", "æ•ž", "æ˜¶", "æ°…", "é‹¹", "ð¬¬®"],
    guÄng: [
      "åƒ™",
      "å…‰",
      "å’£",
      "åž™",
      "å§¯",
      "æ´¸",
      "ç®",
      "ç‚—",
      "ç‚š",
      "ç‚›",
      "çƒ¡",
      "ç–",
      "èƒ±",
      "èŒª",
      "è¼„",
      "éŠ§",
      "é»†",
      "ð¨ˆ"
    ],
    liÃ¡o: [
      "åƒš",
      "å˜¹",
      "å«½",
      "å¯¥",
      "å¯®",
      "å°ž",
      "å±ª",
      "åµº",
      "å¶š",
      "å¶›",
      "å»«",
      "æ†€",
      "æ•¹",
      "æš¸",
      "æ©‘",
      "ç ",
      "ç’™",
      "ç–—",
      "ç™‚",
      "ç«‚",
      "ç°",
      "ç¹š",
      "ç¼­",
      "èŠ",
      "è†‹",
      "è†«",
      "è—”",
      "èŸŸ",
      "è±‚",
      "è³¿",
      "è¹˜",
      "è¾½",
      "é¼",
      "é£‰",
      "é«Ž",
      "é·¯",
      "é¹©"
    ],
    dÃ¨ng: ["åƒœ", "å‡³", "å¢±", "å¶", "æ«ˆ", "çžª", "ç£´", "è¦´", "é‚“", "é„§", "éš¥"],
    "chÃ¡n zhÃ n zhuÃ n": ["åƒ"],
    bÅ: [
      "åƒ ",
      "å¶“",
      "æ‹¨",
      "æ’¥",
      "æ’­",
      "æ³¢",
      "æºŠ",
      "çŽ»",
      "ç™¶",
      "ç›‹",
      "ç µ",
      "ç¢†",
      "ç¤¡",
      "ç¼½",
      "è ",
      "è¢°",
      "è¹³",
      "é‰¢",
      "é’µ",
      "é¤‘",
      "é¥½",
      "é©‹",
      "é±",
      "ð¬­›"
    ],
    huÃ¬: [
      "åƒ¡",
      "åŒ¯",
      "å‰",
      "å–™",
      "å˜’",
      "åš–",
      "åœš",
      "å¬’",
      "å¯­",
      "å±¶",
      "å±·",
      "å½—",
      "å½™",
      "å½š",
      "å¾»",
      "æš",
      "æµ",
      "æƒ ",
      "æ…§",
      "æ†“",
      "æ‡³",
      "æ™¦",
      "æš³",
      "æ§¥",
      "æ©ž",
      "æª…",
      "æ«˜",
      "æ±‡",
      "æ³‹",
      "æ»™",
      "æ½“",
      "çƒ©",
      "ç‡´",
      "ç©",
      "ç’¤",
      "çžº",
      "ç¡Š",
      "ç§½",
      "ç©¢",
      "ç¯²",
      "çµµ",
      "ç¹ª",
      "ç»˜",
      "ç¿™",
      "ç¿½",
      "èŸ",
      "è”§",
      "è•™",
      "è–ˆ",
      "è–‰",
      "èŸª",
      "è©¯",
      "èª¨",
      "è«±",
      "è­“",
      "è­¿",
      "è®³",
      "è¯²",
      "è³„",
      "è´¿",
      "é¬",
      "é— ",
      "é˜“",
      "é§",
      "é ®",
      "é¡ª",
      "é¢’",
      "é¤¯",
      "ð¬¤",
      "ð¬­¬"
    ],
    chuÇŽn: ["åƒ¢", "å–˜", "èˆ›", "èˆ", "è¸³"],
    "tiÄ› jiÃ n": ["åƒ£"],
    sÄ“ng: ["åƒ§", "é¬™"],
    xiÃ n: [
      "åƒ©",
      "åƒ´",
      "å“¯",
      "åž·",
      "å¡ª",
      "å§­",
      "å¨Š",
      "å®ª",
      "å²˜",
      "å³´",
      "æ†²",
      "æ’Š",
      "æ™›",
      "æ©Œ",
      "æ©º",
      "æ¶€",
      "ç€—",
      "çŒ®",
      "ç»",
      "çŽ°",
      "ç¾",
      "çœŒ",
      "ç",
      "ç²¯",
      "ç³®",
      "çµ¤",
      "ç¶«",
      "ç·š",
      "çº¿",
      "ç¼",
      "ç¾¡",
      "ç¾¨",
      "è…º",
      "è‡”",
      "è‡½",
      "è‹‹",
      "èŽ§",
      "èª¢",
      "è±",
      "é‹§",
      "éŒŽ",
      "é™",
      "é™¥",
      "é™·",
      "éœ°",
      "é¤¡",
      "é¦…",
      "éº²",
      "é¼¸",
      "ð¬€ª",
      "ðª¾¢"
    ],
    "yÃ¹ jÃº": ["åƒª"],
    "Ã¨ wÅ«": ["åƒ«"],
    "tÃ³ng zhuÃ ng": ["åƒ®"],
    lÇn: [
      "åƒ¯",
      "å‡›",
      "å‡œ",
      "å»©",
      "å»ª",
      "æ‡",
      "æ‡”",
      "æ’›",
      "æª",
      "æª©",
      "æ¾Ÿ",
      "ç™›",
      "ç™"
    ],
    gÃ¹: [
      "åƒ±",
      "å‡…",
      "å›º",
      "å Œ",
      "å´“",
      "å´®",
      "æ•…",
      "æ¢",
      "æ£",
      "ç‰¿",
      "ç—¼",
      "ç¥»",
      "éŒ®",
      "é”¢",
      "é›‡",
      "é¡§",
      "é¡¾",
      "é¯",
      "é²´"
    ],
    jiÄng: [
      "åƒµ",
      "å£ƒ",
      "å§œ",
      "æ©¿",
      "æ®­",
      "æ±Ÿ",
      "ç••",
      "ç–…",
      "ç¤“",
      "ç¹®",
      "ç¼°",
      "ç¿ž",
      "èŒ³",
      "è‘",
      "è–‘",
      "èž€",
      "èž¿",
      "è±‡",
      "éŸ",
      "é±‚",
      "é³‰"
    ],
    mÇn: [
      "åƒ¶",
      "å†º",
      "åˆ¡",
      "å‹„",
      "æ‚¯",
      "æƒ½",
      "æ„",
      "æ…œ",
      "æ†«",
      "æŠ¿",
      "æ•ƒ",
      "æ•",
      "æ•¯",
      "æ³¯",
      "æ½£",
      "çš¿",
      "ç¬¢",
      "ç¬½",
      "ç°¢",
      "è  ",
      "é–”",
      "é–©",
      "é—µ",
      "é—½",
      "é°µ",
      "é³˜",
      "é»½"
    ],
    jÃ¬n: [
      "åƒ¸",
      "å‡š",
      "å™¤",
      "åš",
      "å¢",
      "å£—",
      "å¦—",
      "å¬§",
      "æ¢",
      "æ™‰",
      "æ™‹",
      "æžƒ",
      "æ®£",
      "æµ•",
      "æµ¸",
      "æº",
      "æ¿…",
      "æ¿œ",
      "çƒ¬",
      "ç…¡",
      "ç‡¼",
      "çŽ",
      "ç‘¨",
      "ç’¶",
      "ç›¡",
      "ç¥²",
      "ç¸‰",
      "ç¼™",
      "è©",
      "è—Ž",
      "è¦²",
      "è§",
      "è³®",
      "è´",
      "èµ†",
      "è¿‘",
      "è¿›",
      "é€²",
      "é³",
      "é½½"
    ],
    "jiÃ  jie": ["åƒ¹"],
    qiÃ o: [
      "åƒº",
      "å³­",
      "å¸©",
      "æ’¬",
      "æ®»",
      "çª",
      "ç«…",
      "èªš",
      "è¯®",
      "èºˆ",
      "é™—",
      "éž©",
      "éŸ’",
      "é«š"
    ],
    pÃ¬: ["åƒ»", "åª²", "å«“", "å±", "æ¾¼", "ç”“", "ç–ˆ", "è­¬", "é—¢", "é·¿", "é¸Š", "ä´™"],
    sÃ i: ["åƒ¿", "ç°º", "è³½", "èµ›"],
    "chÃ¡n tÇŽn shÃ n": ["å„ƒ"],
    "dÄng dÃ ng": ["å„…", "å½“", "é—£"],
    xuÄn: [
      "å„‡",
      "å–§",
      "å¡‡",
      "åª—",
      "å®£",
      "æ„ƒ",
      "æ„‹",
      "æŽ",
      "æ˜",
      "æš„",
      "ç…Š",
      "ç…–",
      "ç‘„",
      "ç»",
      "çŸŽ",
      "ç¦¤",
      "ç®®",
      "ç¿§",
      "ç¿¾",
      "è±",
      "è²",
      "è“’",
      "è•¿",
      "è—¼",
      "è˜",
      "è–",
      "è ‰",
      "è« ",
      "è«¼",
      "è­ž",
      "è°–",
      "è»’",
      "è½©",
      "é¹",
      "é§½",
      "é°š",
      "ð«“¶",
      "ð«½"
    ],
    "dÄn dÃ n": ["å„‹", "æ“”", "ç˜…"],
    cÃ n: ["å„", "æ¾¯", "ç¿", "ç‡¦", "ç’¨", "ç²²", "è–’", "è¬²"],
    "bÄ«n bÃ¬n": ["å„"],
    "Ã¡n Ã n": ["å„‘"],
    tÃ¡i: [
      "å„“",
      "å®",
      "å¬¯",
      "æŠ¬",
      "æ“¡",
      "æª¯",
      "ç‚±",
      "ç‚²",
      "ç±‰",
      "è‡º",
      "è–¹",
      "è·†",
      "é‚°",
      "é¢±",
      "é®",
      "é²"
    ],
    lÃ¡n: [
      "å„–",
      "å…°",
      "å›’",
      "å©ª",
      "å²š",
      "åµ",
      "å¹±",
      "æ‹¦",
      "æ””",
      "æ–“",
      "æ–•",
      "æ ",
      "æ¬„",
      "æ¬—",
      "æ¾œ",
      "ç€¾",
      "ç†",
      "ç¡",
      "ç‡£",
      "ç‡·",
      "ç’¼",
      "ç¯®",
      "ç±ƒ",
      "ç±£",
      "ç¹¿",
      "è‘»",
      "è“",
      "è—",
      "è˜«",
      "è˜­",
      "è¤´",
      "è¥•",
      "è¥¤",
      "è¥´",
      "è¥½",
      "è­‹",
      "è®•",
      "è°°",
      "èº",
      "é‘­",
      "é•§",
      "é—Œ",
      "é˜‘",
      "éŸŠ",
      "ð¬’—"
    ],
    "nÇ yÃ¬ Ã i yÃ­": ["å„—"],
    mÃ©ng: [
      "å„š",
      "å¹ª",
      "æ›š",
      "æœ¦",
      "æ©—",
      "æª¬",
      "æ°‹",
      "æº•",
      "æ¿›",
      "ç”",
      "ç”¿",
      "ç›Ÿ",
      "ç¤ž",
      "è‰¨",
      "èŽ”",
      "èŒ",
      "è•„",
      "è™»",
      "è±",
      "é„³",
      "é„¸",
      "éœ¿",
      "é€",
      "é¡­",
      "é¥›",
      "é¯",
      "é¸",
      "é¹²",
      "ð«‘¡",
      "ã “"
    ],
    nÃ­ng: [
      "å„œ",
      "å‡",
      "å’›",
      "åš€",
      "å¬£",
      "æŸ ",
      "æ©£",
      "æª¸",
      "ç‹ž",
      "ç°",
      "è",
      "è¹",
      "è–´",
      "é‘",
      "é¬¡",
      "é¸‹"
    ],
    qiÃ³ng: [
      "å„",
      "å­",
      "å®†",
      "æƒ¸",
      "æ†Œ",
      "æ¡",
      "æ©©",
      "ç„ª",
      "ç„­",
      "ç…¢",
      "ç†",
      "ç¼",
      "ç“Š",
      "ç˜",
      "ç©·",
      "ç©¹",
      "çª®",
      "ç«†",
      "ç¬»",
      "ç­‡",
      "èˆ¼",
      "èŒ•",
      "è—‘",
      "è—­",
      "è›©",
      "è›¬",
      "èµ¹",
      "è·«",
      "é‚›",
      "éŠŽ",
      "ä“–"
    ],
    liÃ¨: [
      "å„ ",
      "å†½",
      "åˆ—",
      "åŠ£",
      "åŠ½",
      "åŸ’",
      "åŸ“",
      "å§´",
      "å³›",
      "å·¤",
      "æŒ’",
      "æ©",
      "æ µ",
      "æ´Œ",
      "æµ–",
      "çƒˆ",
      "çƒ®",
      "ç…­",
      "çŠ£",
      "çŒŽ",
      "çŒŸ",
      "çµ",
      "è—",
      "è„Ÿ",
      "èŒ¢",
      "è›š",
      "è¶”",
      "èº",
      "è¿¾",
      "é¢²",
      "é¬›",
      "é¬£",
      "é®¤",
      "é±²",
      "é´·",
      "ä´•",
      "ð«š­"
    ],
    kuÇŽng: ["å„£", "å¤¼", "æ‡­"],
    bÃ o: [
      "å„¤",
      "å‹½",
      "å ±",
      "å¿",
      "æŠ¥",
      "æŠ±",
      "æ›“",
      "çˆ†",
      "çŠ¦",
      "è¢",
      "è™£",
      "èš«",
      "è±¹",
      "é‰‹",
      "é‘¤",
      "é“‡",
      "éª²",
      "é«±",
      "é®‘",
      "é²"
    ],
    biÄo: [
      "å„¦",
      "å¢‚",
      "å¹–",
      "å½ª",
      "æ ‡",
      "æ¨™",
      "æ»®",
      "ç€Œ",
      "ç†›",
      "çˆ‚",
      "çŒ‹",
      "ç˜­",
      "ç£¦",
      "è†˜",
      "è‡•",
      "è¬¤",
      "è´†",
      "é¢",
      "é‘£",
      "é•–",
      "é•³",
      "é¢®",
      "é¢·",
      "é£†",
      "é£‡",
      "é£ˆ",
      "é£Š",
      "é£‘",
      "é£™",
      "é£š",
      "é©«",
      "éª‰",
      "é«Ÿ"
    ],
    zÇŽn: ["å„§", "å„¹", "å™†", "æ”…", "æ˜", "è¶±", "è¶²"],
    hÃ¡o: [
      "å„«",
      "å—¥",
      "å˜·",
      "å™‘",
      "åšŽ",
      "å£•",
      "æ¤ƒ",
      "æ¯œ",
      "æ¯«",
      "æ¿ ",
      "ç†",
      "ç”",
      "ç«“",
      "ç±‡",
      "èš",
      "è ”",
      "è­¹",
      "è±ª"
    ],
    qÃ¬ng: ["å„¬", "å‡Š", "åº†", "æ…¶", "æ«¦", "æ¿ª", "ç¢ƒ", "ç£¬", "ç½„", "é˜"],
    chÃ¨n: [
      "å„­",
      "åš«",
      "æ¦‡",
      "æ«¬",
      "ç–¢",
      "è¡¬",
      "è¥¯",
      "è®–",
      "è°¶",
      "è¶",
      "è¶‚",
      "é½“",
      "é½”",
      "é¾€"
    ],
    tÃ©ng: [
      "å„¯",
      "å¹",
      "æ»•",
      "æ¼›",
      "ç–¼",
      "ç±",
      "ç±˜",
      "ç¸¢",
      "è…¾",
      "è—¤",
      "è™…",
      "èž£",
      "èªŠ",
      "è¬„",
      "é‚†",
      "é§¦",
      "é¨°",
      "é©£",
      "é°§",
      "ä²¢"
    ],
    "lÇ’ng lÃ³ng lÃ²ng": ["å„±"],
    "chÃ¡n chÃ n": ["å„³"],
    "rÃ¡ng xiÄng": ["å„´", "å‹·"],
    "huÃ¬ xiÃ©": ["å„¶"],
    luÃ³: [
      "å„¸",
      "æ”ž",
      "æ¤¤",
      "æ¬",
      "çŒ¡",
      "çŽ€",
      "ç®©",
      "ç±®",
      "ç½—",
      "ç¾…",
      "è„¶",
      "è…¡",
      "è",
      "è˜¿",
      "èžº",
      "è¦¼",
      "é€»",
      "é‚",
      "é",
      "é‘¼",
      "é”£",
      "é•™",
      "é¥ ",
      "é¨¾",
      "é©˜",
      "éª¡",
      "é¸"
    ],
    lÃ©i: [
      "å„½",
      "å«˜",
      "æª‘",
      "æ¬™",
      "ç“ƒ",
      "ç•¾",
      "ç¸²",
      "çº",
      "çº",
      "ç¼§",
      "ç½",
      "ç¾¸",
      "è”‚",
      "è˜²",
      "è™†",
      "è½ ",
      "é³",
      "é‘˜",
      "é•­",
      "é›·",
      "é",
      "é±©",
      "é¼º"
    ],
    "nÃ ng nÄng": ["å„¾"],
    "wÃ¹ wÅ«": ["å…€"],
    yÇ”n: [
      "å…",
      "å–—",
      "å¤½",
      "æŠŽ",
      "æ®’",
      "æ®ž",
      "ç‹",
      "ç£’",
      "èº",
      "è³±",
      "éˆ—",
      "é˜­",
      "é™¨",
      "éš•",
      "éœ£",
      "é¦»",
      "é½«",
      "é½³"
    ],
    zÄn: ["å…‚", "æ©µ", "ç°ª", "ç°®", "ç³Œ", "é•", "éŸ", "éµ¤"],
    yuÃ¡n: [
      "å…ƒ",
      "å††",
      "åŽŸ",
      "åŽ¡",
      "åŽµ",
      "å›­",
      "åœ†",
      "åœŽ",
      "åœ’",
      "åœ“",
      "åž£",
      "å¡¬",
      "åª´",
      "å«„",
      "æ´",
      "æ¦ž",
      "æ¦¬",
      "æ©¼",
      "æ«ž",
      "æ²…",
      "æ¹²",
      "æº",
      "æº’",
      "çˆ°",
      "çŒ¨",
      "çŒ¿",
      "ç¬Ž",
      "ç·£",
      "ç¸",
      "ç¼˜",
      "ç¾±",
      "èŒ’",
      "è–—",
      "è",
      "è¯",
      "èžˆ",
      "è¢",
      "è¤¤",
      "è¬œ",
      "è½…",
      "è¾•",
      "é‚",
      "é‚§",
      "é…›",
      "éˆ¨",
      "éŽ±",
      "é¨µ",
      "é­­",
      "é¶¢",
      "é¶°",
      "é»¿",
      "é¼‹",
      "ð«˜ª"
    ],
    xiÅng: [
      "å…„",
      "å…‡",
      "å‡¶",
      "åŒ‚",
      "åŒˆ",
      "å“…",
      "å¿·",
      "æŸ",
      "æ±¹",
      "æ´¶",
      "èƒ·",
      "èƒ¸",
      "èŠŽ",
      "è¨©",
      "è©¾",
      "è®»"
    ],
    chÅng: [
      "å……",
      "å˜ƒ",
      "å¿¡",
      "æ†ƒ",
      "æ†§",
      "æ‘",
      "æ²–",
      "æµº",
      "ç«",
      "ç½¿",
      "ç¿€",
      "èˆ‚",
      "è‰Ÿ",
      "èŒº",
      "è¡",
      "è¹–",
      "ã³˜"
    ],
    zhÃ o: [
      "å…†",
      "åž—",
      "æ—",
      "æ›Œ",
      "æž›",
      "æ«‚",
      "ç…§",
      "ç‡³",
      "ç‹£",
      "çž¾",
      "ç¬Š",
      "ç½€",
      "ç½©",
      "ç¾„",
      "è‚",
      "è‚‡",
      "è‚ˆ",
      "è©”",
      "è¯",
      "èµµ",
      "è¶™",
      "é®¡",
      "ð¬¶"
    ],
    "duÃ¬ ruÃ¬ yuÃ¨": ["å…Š", "å…Œ", "å…‘"],
    kÃ¨: [
      "å…‹",
      "åˆ»",
      "å‹€",
      "å‹Š",
      "å ",
      "å¨”",
      "å®¢",
      "æª",
      "æ„™",
      "æ°ª",
      "æº˜",
      "ç¢¦",
      "ç·™",
      "ç¼‚",
      "è‰",
      "è¡‰",
      "èª²",
      "è¯¾",
      "éŒ",
      "é”ž",
      "é¨",
      "éª’"
    ],
    tÃ¹: ["å…Ž", "å…”", "å ", "è¿Œ", "éµµ"],
    dÇŽng: ["å…š", "æ”©", "æ¬“", "è­¡", "è®œ", "è° ", "é»¨", "ð£—‹"],
    dÅu: ["å…œ", "å… ", "å”—", "æ©·", "ç¯¼", "è”¸"],
    huÇŽng: [
      "å…¤",
      "å¥›",
      "å¹Œ",
      "æ€³",
      "æ",
      "æ™„",
      "ç‚¾",
      "ç†€",
      "ç¸¨",
      "è©¤",
      "è¬Š",
      "è°Ž"
    ],
    rÃ¹: ["å…¥", "å—•", "åª·", "æ‰–", "æ", "æ´³", "æº½", "ç¸Ÿ", "ç¼›", "è“", "è¤¥", "é³°"],
    nÃ¨i: ["å…§", "æ°", "æ°ž", "éŒ—"],
    "yÃº shÃ¹": ["å…ª"],
    "liÃ¹ lÃ¹": ["å…­"],
    han: ["å…¯", "çˆ³"],
    tiÄn: ["å…²", "å¤©", "å©–", "æ·»", "é…Ÿ", "é”", "é", "é»‡"],
    "xÄ«ng xÃ¬ng": ["å…´"],
    diÇŽn: [
      "å…¸",
      "åš¸",
      "å¥Œ",
      "å©°",
      "æ•Ÿ",
      "æ¤£",
      "ç‚¹",
      "ç¢˜",
      "è’§",
      "è•‡",
      "è¸®",
      "é»ž"
    ],
    "zÄ« cÃ­": ["å…¹"],
    jiÄn: [
      "å…¼",
      "å†¿",
      "å›",
      "åš",
      "å …",
      "å¥¸",
      "å§¦",
      "å§§",
      "å°–",
      "å¹µ",
      "æƒ¤",
      "æˆ‹",
      "æˆ”",
      "æ›",
      "æ¤¾",
      "æ¨«",
      "æ«¼",
      "æ­¼",
      "æ®±",
      "æ®²",
      "æ¹”",
      "ç€",
      "ç€¸",
      "ç…Ž",
      "ç†ž",
      "ç†¸",
      "ç‰‹",
      "ç‘Š",
      "ç·",
      "ç¤›",
      "ç¤·",
      "ç¬º",
      "ç®‹",
      "ç·˜",
      "ç¸‘",
      "ç¼„",
      "ç¼£",
      "è‚©",
      "è‰°",
      "è‰±",
      "è…",
      "èº",
      "è‘Œ",
      "è’¹",
      "è”ª",
      "è•‘",
      "è•³",
      "è™ƒ",
      "è­¼",
      "è±œ",
      "é‘¯",
      "é›ƒ",
      "éž¯",
      "éŸ€",
      "éŸ‰",
      "é¤°",
      "é¦¢",
      "é°”",
      "é°œ",
      "é°¹",
      "é²£",
      "é³’",
      "éµ‘",
      "éµ³",
      "é¶¼",
      "é¹£",
      "éº‰"
    ],
    shÃ²u: [
      "å…½",
      "å—",
      "å”®",
      "å£½",
      "å¤€",
      "å¯¿",
      "æŽˆ",
      "ç‹©",
      "ç£",
      "ç¸",
      "ç—©",
      "ç˜¦",
      "ç¶¬",
      "ç»¶",
      "è†„"
    ],
    jÃ¬: [
      "å…¾",
      "å†€",
      "å‰‚",
      "å‰¤",
      "åŠ‘",
      "å‹£",
      "å–",
      "åž",
      "å¡ˆ",
      "å¦“",
      "å­£",
      "å¯‚",
      "å¯„",
      "å»­",
      "å½‘",
      "å¾›",
      "å¿Œ",
      "æ‚¸",
      "æƒŽ",
      "æ‡»",
      "æŠ€",
      "æ—¡",
      "æ—¢",
      "æ—£",
      "æš¨",
      "æš©",
      "æ›",
      "æ¢ž",
      "æª•",
      "æªµ",
      "æ´Ž",
      "æ¼ƒ",
      "æ¼ˆ",
      "ç€±",
      "ç—µ",
      "ç™ ",
      "ç¦",
      "ç¨©",
      "ç¨·",
      "ç©„",
      "ç©Š",
      "ç©§",
      "ç´€",
      "ç¶™",
      "ç¸¾",
      "ç¹‹",
      "ç¹¼",
      "ç»§",
      "ç»©",
      "ç½½",
      "è‡®",
      "èŠ°",
      "èŒ",
      "èŒ¤",
      "è‘ª",
      "è“Ÿ",
      "è”‡",
      "è–Š",
      "è˜Ž",
      "è˜®",
      "è˜»",
      "è£š",
      "è¥€",
      "è¦¬",
      "è§Š",
      "è¨ˆ",
      "è¨˜",
      "èª‹",
      "è®¡",
      "è®°",
      "è·¡",
      "è·½",
      "è¹Ÿ",
      "è¿¹",
      "é™…",
      "éš›",
      "éœ",
      "éœ½",
      "é©¥",
      "éª¥",
      "é«»",
      "é¬¾",
      "é­",
      "é­¥",
      "é¯š",
      "é¯½",
      "é°¶",
      "é°¿",
      "é±€",
      "é±­",
      "é²š",
      "é²«",
      "éµ‹",
      "é·‘",
      "é½Œ",
      "ðªŸ",
      "ð¬¶¨",
      "ð¬¶­"
    ],
    jiÅng: ["å†‚", "å†‹", "å°", "åŸ›", "æ‰ƒ", "è˜", "è˜”", "é§‰", "é§«", "ð¬³¶"],
    mÃ o: [
      "å†ƒ",
      "å†",
      "åª¢",
      "å¸½",
      "æ„—",
      "æ‡‹",
      "æš“",
      "æŸ•",
      "æ¥™",
      "æ¯·",
      "ç‘",
      "çšƒ",
      "çœŠ",
      "çž€",
      "è€„",
      "èŒ‚",
      "èº",
      "è",
      "è¢¤",
      "è¦’",
      "è²Œ",
      "è²¿",
      "è´¸",
      "é„š",
      "é„®"
    ],
    rÇŽn: ["å†„", "å†‰", "å§Œ", "åª£", "æŸ“", "çƒ", "è‹’", "è’…", "äŽƒ"],
    "nÃ¨i nÃ ": ["å†…"],
    gÄng: [
      "å†ˆ",
      "å†®",
      "åˆš",
      "å‰›",
      "å ˆ",
      "å ½",
      "å²¡",
      "æŽ†",
      "æ‘ƒ",
      "æ£¡",
      "ç‰¨",
      "çŠ…",
      "ç–˜",
      "ç¶±",
      "çº²",
      "ç¼¸",
      "ç½",
      "ç½¡",
      "è‚›",
      "é‡­",
      "éŽ ",
      "ã­Ž"
    ],
    cÃ¨: [
      "å†Š",
      "å†Œ",
      "åŽ•",
      "åŽ ",
      "å¤¨",
      "å»",
      "æ»",
      "æƒ»",
      "æ†¡",
      "æ•‡",
      "æµ‹",
      "æ¸¬",
      "ç¬§",
      "ç­–",
      "ç­ž",
      "ç­´",
      "ç®£",
      "è",
      "è—",
      "è´",
      "è“›"
    ],
    guÇŽ: ["å†Ž", "å‰", "å‰®", "å§", "å¯¡"],
    "mÃ o mÃ²": ["å†’"],
    gÃ²u: [
      "å†“",
      "å•‚",
      "å¸",
      "åž¢",
      "å¤Ÿ",
      "å¤ ",
      "åª¾",
      "å½€",
      "æ†",
      "æ’€",
      "æž„",
      "æ§‹",
      "ç…¹",
      "è¦¯",
      "è§",
      "è¨½",
      "è©¬",
      "è¯Ÿ",
      "è³¼",
      "è´­",
      "é˜",
      "é›Š"
    ],
    xÇ”: ["å†”", "å–£", "æšŠ", "æ ©", "ç", "ç›¨", "ç³ˆ", "è©¡", "è«¿", "è¯©", "é„¦", "é†‘"],
    mÃ¬: [
      "å†–",
      "å†ª",
      "å˜§",
      "å¡“",
      "å®»",
      "å¯†",
      "å³š",
      "å¹‚",
      "å¹Ž",
      "å¹¦",
      "æ€½",
      "æ¦“",
      "æ¨’",
      "æ«",
      "æ±¨",
      "æ·§",
      "æ»µ",
      "æ¼ž",
      "æ¿—",
      "ç†",
      "ç¾ƒ",
      "è”¤",
      "èœœ",
      "è¦“",
      "è¦”",
      "è¦›",
      "è§…",
      "è¬",
      "è°§",
      "é¼"
    ],
    "yÃ³u yÃ­n": ["å†˜"],
    xiÄ›: ["å†™", "å†©", "è—›"],
    jÅ«n: [
      "å†›",
      "å›",
      "å‡",
      "æ¡¾",
      "æ±®",
      "çš²",
      "çš¸",
      "çš¹",
      "ç¢…",
      "èŽ™",
      "èš",
      "è¢€",
      "è¦ ",
      "è»",
      "éˆž",
      "éŠ",
      "éŠž",
      "é•",
      "é’§",
      "é µ",
      "é®¶",
      "é²ª",
      "éº"
    ],
    mÃ­: [
      "å†ž",
      "æ“Ÿ",
      "ç€°",
      "çˆ¢",
      "çŒ•",
      "ç¼",
      "ç¥¢",
      "ç¦°",
      "ç¸»",
      "è’¾",
      "è—Œ",
      "è˜ª",
      "è˜¼",
      "è¢®",
      "è©¸",
      "è¬Ž",
      "è¿·",
      "é†š",
      "é†¾",
      "é†¿",
      "é‡„",
      "é•¾",
      "é¸",
      "éºŠ",
      "éº‹",
      "éº›"
    ],
    "guÄn guÃ n": ["å† ", "è¦Œ", "è¦³", "è§€", "è§‚"],
    mÄ›ng: [
      "å†¡",
      "å‹",
      "æ‡µ",
      "æŽ¹",
      "çŒ›",
      "ç´",
      "è‰‹",
      "èœ¢",
      "è “",
      "éŒ³",
      "é”°",
      "é¯­",
      "é¼†"
    ],
    zhÇ’ng: ["å†¢", "å¡š", "å°°", "æ­±", "ç…„", "ç˜‡", "è‚¿", "è…«", "è¸µ"],
    zuÃ¬: [
      "å†£",
      "å¶µ",
      "æ™¬",
      "æœ€",
      "æ ¬",
      "æ§œ",
      "æª‡",
      "æªŒ",
      "ç¥½",
      "çµŠ",
      "ç½ª",
      "è•ž",
      "è¾ ",
      "é…”",
      "é…»",
      "é†‰",
      "éŒŠ"
    ],
    yuÄn: [
      "å†¤",
      "å‰ˆ",
      "å›¦",
      "å¬½",
      "å¯ƒ",
      "æ£©",
      "æ·µ",
      "æ¸",
      "æ¸†",
      "æ¸Š",
      "æ¸•",
      "ç",
      "çœ¢",
      "è‚™",
      "è‘¾",
      "è’¬",
      "èœŽ",
      "èœµ",
      "é§Œ",
      "é³¶",
      "é´›",
      "éµ·",
      "é¸¢",
      "é¸³",
      "é¹“",
      "é¼˜",
      "é¼"
    ],
    mÃ­ng: [
      "å†¥",
      "å",
      "æ˜Ž",
      "æš",
      "æœ™",
      "æ¦ ",
      "æ´º",
      "æºŸ",
      "çŒ½",
      "çœ€",
      "çœ³",
      "çž‘",
      "èŒ—",
      "èžŸ",
      "è¦­",
      "è©º",
      "é„",
      "éŠ˜",
      "é“­",
      "é³´",
      "é¸£"
    ],
    kÃ²u: [
      "å†¦",
      "å©",
      "å®¼",
      "å¯‡",
      "æ‰£",
      "æ•‚",
      "æ»±",
      "çª›",
      "ç­˜",
      "ç°†",
      "è”²",
      "è”»",
      "é‡¦",
      "é·‡"
    ],
    tÃ i: [
      "å†­",
      "å¤ª",
      "å¤³",
      "å¿²",
      "æ€",
      "æ…‹",
      "æ±°",
      "æ±±",
      "æ³°",
      "æº™",
      "è‚½",
      "èˆ¦",
      "é…ž",
      "éˆ¦",
      "é’›"
    ],
    "fÃ©ng pÃ­ng": ["å†¯", "é¦®"],
    "chÅng chÃ²ng": ["å†²"],
    kuÃ ng: [
      "å†µ",
      "åœ¹",
      "å£™",
      "å²²",
      "æ‡¬",
      "æ—·",
      "æ˜¿",
      "æ› ",
      "æ¡†",
      "æ³",
      "çˆŒ",
      "çœ–",
      "çœ¶",
      "çŸ¿",
      "ç ¿",
      "ç¤¦",
      "ç©¬",
      "çµ‹",
      "çµ–",
      "çºŠ",
      "çº©",
      "è²º",
      "è´¶",
      "è»¦",
      "é‚",
      "é„º",
      "é‰±",
      "é‹›",
      "é‘›",
      "é»‹"
    ],
    lÄ›ng: ["å†·"],
    pÃ n: [
      "å†¸",
      "åˆ¤",
      "å›",
      "æ²œ",
      "æ³®",
      "æº¿",
      "ç‚",
      "ç‰‰",
      "ç•”",
      "ç›¼",
      "è",
      "è¢¢",
      "è¥»",
      "è©Š",
      "é‹¬",
      "é‘»",
      "é –",
      "éµ¥"
    ],
    fÄ: ["å†¹", "å½‚", "æ²·", "ç™º", "ç™¼"],
    xiÇŽn: [
      "å†¼",
      "å°Ÿ",
      "å° ",
      "å´„",
      "å¶®",
      "å¹°",
      "æ”‡",
      "æ˜¾",
      "æ«¶",
      "æ¯¨",
      "ç¦",
      "çƒ",
      "ç‡¹",
      "ç‹",
      "çŒƒ",
      "ç«",
      "ç®",
      "çŽ",
      "ç¦’",
      "ç­…",
      "ç®²",
      "è—“",
      "è˜š",
      "èš¬",
      "èœ†",
      "è­£",
      "èµ»",
      "è·£",
      "éŒ",
      "é™©",
      "é™º",
      "éšª",
      "éŸ…",
      "é¡•",
      "é¡¯",
      "ã¬Ž"
    ],
    qiÃ : ["å†¾", "åœ¶", "å¸¢", "æ°", "æ®Ž", "æ´½", "ç¡ˆ", "èƒ¢", "é«‚"],
    "jÃ¬ng chÄ“ng": ["å‡€", "å‡ˆ", "æ·¨"],
    sÅu: [
      "å‡",
      "å—–",
      "å»€",
      "å»‹",
      "æœ",
      "æœ",
      "æ‘‰",
      "æº²",
      "ç€",
      "è‰˜",
      "è’",
      "èž‹",
      "é„‹",
      "é†™",
      "éŽª",
      "é”¼",
      "é¢¼",
      "é£•",
      "é¤¿",
      "é¦Š",
      "é¨ª"
    ],
    mÄ›i: [
      "å‡‚",
      "åª„",
      "åªº",
      "å¬",
      "åµ„",
      "æŒ´",
      "æ¯Ž",
      "æ¯",
      "æµ¼",
      "æ¸¼",
      "ç‡˜",
      "ç¾Ž",
      "èº¾",
      "éŽ‚",
      "é•",
      "é»£"
    ],
    tÃº: [
      "å‡ƒ",
      "å›³",
      "å›¾",
      "åœ–",
      "åœ—",
      "å¡—",
      "å± ",
      "å³¹",
      "åµž",
      "åº©",
      "å»œ",
      "å¾’",
      "æ‚‡",
      "æ¬",
      "æ¶‚",
      "ç˜",
      "ç­¡",
      "è…¯",
      "è¼",
      "è’¤",
      "è·¿",
      "é€”",
      "é…´",
      "éˆ¯",
      "éŽ",
      "é¦Ÿ",
      "é§¼",
      "éµŒ",
      "é¶Ÿ",
      "é·‹",
      "é·µ",
      "ð¬³¿"
    ],
    zhÇ”n: ["å‡†", "å‡–", "åŸ»", "æº–", "ð¬˜¯"],
    "liÃ¡ng liÃ ng": ["å‡‰", "æ¶¼", "é‡"],
    diÄo: [
      "å‡‹",
      "åˆ",
      "åˆŸ",
      "å¼",
      "å¥",
      "å¼´",
      "å½«",
      "æ±ˆ",
      "ç±",
      "ç¢‰",
      "ç°“",
      "è™­",
      "è›",
      "è²‚",
      "éŒ­",
      "é›•",
      "é®‰",
      "é¯›",
      "é²·",
      "éµ°",
      "é¼¦"
    ],
    cÃ²u: ["å‡‘", "æ¹Š", "è… ", "è¼³", "è¾"],
    Ã¡i: ["å‡’", "å•€", "å˜Š", "æ±", "æº°", "ç™Œ", "çš‘", "çšš"],
    duÃ³: ["å‡™", "å‰«", "å¤º", "å¥ª", "ç—¥", "è¸±", "éˆ¬", "é¸", "é“Ž"],
    dÃº: [
      "å‡Ÿ",
      "åŒµ",
      "å¬»",
      "æ¤Ÿ",
      "æ«",
      "æ®°",
      "æ¶œ",
      "ç‰",
      "ç‰˜",
      "çŠŠ",
      "çŠ¢",
      "ç‹¬",
      "ç¨",
      "ç“„",
      "çš¾",
      "è£»",
      "èª­",
      "è®€",
      "è®Ÿ",
      "è±„",
      "è´•",
      "éŒ–",
      "é‘Ÿ",
      "éŸ‡",
      "éŸ£",
      "éŸ¥",
      "é¨³",
      "é«‘",
      "é»©",
      "é»·"
    ],
    "jÇ jÄ«": ["å‡ "],
    fÃ¡n: [
      "å‡¡",
      "å‡¢",
      "å‡£",
      "åŒ¥",
      "å¢¦",
      "æ‹",
      "æŸ‰",
      "æ£¥",
      "æ¨Š",
      "ç€¿",
      "çƒ¦",
      "ç…©",
      "ç‡”",
      "ç’ ",
      "çŸ¾",
      "ç¤¬",
      "ç¬²",
      "ç±µ",
      "ç·",
      "ç¾³",
      "èˆ¤",
      "èˆ§",
      "è– ",
      "è˜©",
      "è œ",
      "è¥Ž",
      "è¹¯",
      "é‡©",
      "é‡",
      "é¢",
      "é’’",
      "é·­",
      "ð«”",
      "ð¬¸ª"
    ],
    jÅ«: [
      "å‡¥",
      "åŒŠ",
      "å¨µ",
      "å©®",
      "å±…",
      "å´Œ",
      "æŠ…",
      "æŒ¶",
      "æŽ¬",
      "æ¢®",
      "æ¤",
      "æª‹",
      "æ¯©",
      "æ¯±",
      "æ³ƒ",
      "æ¶º",
      "ç‹™",
      "çš",
      "ç–½",
      "ç  ",
      "ç½",
      "è…’",
      "è‰",
      "èœ›",
      "è£¾",
      "è«Š",
      "è·”",
      "è¸˜",
      "èº¹",
      "é™±",
      "é›Ž",
      "éž ",
      "éž«",
      "é§’",
      "é©¹",
      "é®ˆ",
      "é´¡",
      "é¶‹",
      "ð¬¶‹"
    ],
    "chÃ¹ chÇ”": ["å‡¦", "å¤„"],
    zhÇ: [
      "å‡ª",
      "åŠ§",
      "å’«",
      "å€",
      "å§",
      "å¸‹",
      "æ‰",
      "æ‰º",
      "æŒ‡",
      "æ—¨",
      "æž³",
      "æ­¢",
      "æ±¦",
      "æ²š",
      "æ´”",
      "æ·½",
      "ç–»",
      "ç ‹",
      "ç¥‰",
      "ç§–",
      "ç´™",
      "çº¸",
      "èŠ·",
      "è—¢",
      "è¡¹",
      "è¥§",
      "è¨¨",
      "è¶¾",
      "è»¹",
      "è½µ",
      "é…¯",
      "é˜¯",
      "é»¹"
    ],
    pÃ­ng: [
      "å‡­",
      "å‡´",
      "å‘¯",
      "åª",
      "å¡€",
      "å²¼",
      "å¸¡",
      "å¸²",
      "å¹ˆ",
      "å¹³",
      "æ…¿",
      "æ†‘",
      "æž°",
      "æ´´",
      "ç„©",
      "çŽ¶",
      "ç“¶",
      "ç”",
      "ç«®",
      "ç®³",
      "ç°ˆ",
      "ç¼¾",
      "è“",
      "è",
      "è“±",
      "èš²",
      "è›¢",
      "è©•",
      "è¯„",
      "è»¿",
      "è¼§",
      "éƒ±",
      "é®ƒ",
      "é²†"
    ],
    kÇŽi: [
      "å‡¯",
      "å‡±",
      "å‰€",
      "å‰´",
      "åž²",
      "å¡",
      "æº",
      "æ„·",
      "æ…¨",
      "æšŸ",
      "è’ˆ",
      "è¼†",
      "é‡",
      "éŽ§",
      "é“ ",
      "é”´",
      "é—“",
      "é—¿",
      "é¢½"
    ],
    gÄn: [
      "å‡²",
      "å©",
      "å°²",
      "å°´",
      "å°¶",
      "å°·",
      "æŸ‘",
      "æ³”",
      "æ¼§",
      "çŽ•",
      "ç”˜",
      "ç–³",
      "çŸ¸",
      "ç«¿",
      "ç­¸",
      "ç²“",
      "è‚",
      "è‹·",
      "è¿€",
      "é…",
      "é­"
    ],
    "kÇŽn qiÇŽn": ["å‡µ"],
    tÅ«: [
      "å‡¸",
      "å —",
      "å¶€",
      "æ¸",
      "æ¶‹",
      "æ¹¥",
      "ç—œ",
      "ç¦¿",
      "ç§ƒ",
      "çª",
      "è‘–",
      "é‹µ",
      "éµš",
      "é¼µ",
      "ã»¬"
    ],
    "Äo wÄ": ["å‡¹"],
    chÅ«: ["å‡º", "åˆ", "å²€", "æ‘´", "æ¦‹", "æ¨—", "è²™", "é½£", "ä¢º", "ä™"],
    dÃ ng: [
      "å‡¼",
      "åœµ",
      "åž±",
      "å£‹",
      "æ¡£",
      "æª”",
      "æ°¹",
      "ç’—",
      "ç“½",
      "ç›ª",
      "çžŠ",
      "ç €",
      "ç¢­",
      "ç¤‘",
      "ç°œ",
      "è¡",
      "èª",
      "è•©",
      "è˜¯",
      "è¶¤",
      "é€¿",
      "é›¼",
      "ð¬¡"
    ],
    hÃ¡n: [
      "å‡½",
      "å‡¾",
      "å«",
      "åœ…",
      "å¨¢",
      "å¯’",
      "å´¡",
      "æ™—",
      "æ¢’",
      "æµ›",
      "æ¶µ",
      "æ¾",
      "ç„“",
      "ç€",
      "ç”",
      "ç­¨",
      "èœ¬",
      "é‚—",
      "é‚¯",
      "é‹¡",
      "éŸ“",
      "éŸ©"
    ],
    zÃ¡o: ["å‡¿", "é‘¿"],
    dÄo: ["åˆ€", "åˆ‚", "å¿‰", "æ°˜", "èˆ ", "èž©", "é‡–", "é­›", "é±½"],
    chuÄng: ["åˆ…", "æ‘", "ç‰Ž", "ç‰•", "ç–®", "ç˜¡", "çª“", "çª—", "çª»"],
    "fÄ“n fÃ¨n": ["åˆ†"],
    "qiÃ¨ qiÄ“": ["åˆ‡"],
    kÄn: ["åˆŠ", "å‹˜", "å ª", "æˆ¡", "æ ž", "é¾•", "é¾›"],
    cÇ”n: ["åˆŒ", "å¿–"],
    chÃº: [
      "åˆ",
      "åŽ¨",
      "å¹®",
      "å»š",
      "æ©±",
      "æ«‰",
      "æ«¥",
      "æ»",
      "çŠ“",
      "ç¯¨",
      "è€¡",
      "èŠ»",
      "è’¢",
      "è’­",
      "èœ",
      "èŸµ",
      "è± ",
      "è¶Ž",
      "è¹°",
      "èº‡",
      "èº•",
      "é‰",
      "é‹¤",
      "é”„",
      "é™¤",
      "é›",
      "é››",
      "é¶µ"
    ],
    "huÃ  huÃ¡": ["åˆ’"],
    lÃ­: [
      "åˆ•",
      "å‰“",
      "å‰º",
      "åŠ™",
      "åŽ˜",
      "å–±",
      "åšŸ",
      "å›„",
      "å« ",
      "å­·",
      "å»²",
      "æ‚¡",
      "æ¢¨",
      "æ¢¸",
      "æ£ƒ",
      "æ¼“",
      "ç•",
      "çŠ",
      "çŠ‚",
      "ç‹¸",
      "ç",
      "ç’ƒ",
      "ç“ˆ",
      "ç› ",
      "ç",
      "ç¦»",
      "ç©²",
      "ç«°",
      "ç­£",
      "ç¯±",
      "ç±¬",
      "ç³Ž",
      "ç¸­",
      "ç¼¡",
      "ç½¹",
      "è‰ƒ",
      "è²",
      "èž",
      "è“ ",
      "è”¾",
      "è—œ",
      "è˜º",
      "èœŠ",
      "èŸ",
      "èŸ¸",
      "è «",
      "è¤µ",
      "è¬§",
      "è²",
      "é†¨",
      "é‹«",
      "éŒ…",
      "é«",
      "é‘—",
      "é›¢",
      "é©ª",
      "éªŠ",
      "é¯",
      "é¯¬",
      "é±º",
      "é²¡",
      "éµ¹",
      "é¸",
      "é¹‚",
      "é»Ž",
      "é»§",
      "ã°€"
    ],
    yuÃ¨: [
      "åˆ–",
      "å¬³",
      "å²„",
      "å²³",
      "å¶½",
      "æ±",
      "æ‚…",
      "æ‚¦",
      "æˆ‰",
      "æŠˆ",
      "æ³",
      "æœˆ",
      "æ¨¾",
      "ç€¹",
      "çˆš",
      "çŽ¥",
      "ç¤¿",
      "ç¦´",
      "ç¯—",
      "ç±†",
      "ç±¥",
      "ç±°",
      "ç²¤",
      "ç²µ",
      "è˜¥",
      "èšŽ",
      "èš",
      "èª¬",
      "è¶Š",
      "è·€",
      "è·ƒ",
      "èº",
      "è»",
      "éˆ…",
      "é‰ž",
      "é‘°",
      "é’º",
      "é–±",
      "é–²",
      "é˜…",
      "é¸‘",
      "é¸™",
      "é»¦",
      "é¾ ",
      "ð«„",
      "ð¬¸š"
    ],
    liÃº: [
      "åˆ˜",
      "åŠ‰",
      "åš ",
      "åª¹",
      "åµ§",
      "æ—ˆ",
      "æ—’",
      "æ¦´",
      "æ©Š",
      "æµ",
      "æµ",
      "ç€",
      "ç‰",
      "ç‘ ",
      "ç‘¬",
      "ç’¢",
      "ç•„",
      "ç•™",
      "ç•±",
      "ç–",
      "ç˜¤",
      "ç™…",
      "ç¡«",
      "è’¥",
      "è“…",
      "èŸ‰",
      "è£—",
      "éŽ",
      "é",
      "é‚",
      "é• ",
      "é£€",
      "é£…",
      "é£—",
      "é§ ",
      "é§µ",
      "é¨®",
      "é©‘",
      "éª",
      "é°¡",
      "é¶¹",
      "é¹ ",
      "éº"
    ],
    zÃ©: [
      "åˆ™",
      "å‰‡",
      "å•§",
      "å˜–",
      "å«§",
      "å¸»",
      "å¹˜",
      "æŠž",
      "æ¨",
      "æ­µ",
      "æ²¢",
      "æ³Ž",
      "æº­",
      "çšŸ",
      "çž”",
      "çŸ ",
      "ç¤‹",
      "ç®¦",
      "ç°€",
      "èˆ´",
      "è”¶",
      "è Œ",
      "è¥—",
      "è¬®",
      "è³¾",
      "èµœ",
      "è¿®",
      "é¸…",
      "é½š",
      "é½°"
    ],
    "chuÃ ng chuÄng": ["åˆ›", "å‰µ"],
    qÃ¹: ["åˆž", "åŽº", "åŽ»", "é–´", "é—ƒ", "é˜’", "éº®", "é¼"],
    "biÃ© biÃ¨": ["åˆ¥", "åˆ«"],
    "pÃ¡o bÃ o": ["åˆ¨"],
    "chÇŽn chÃ n": ["åˆ¬", "å‰—", "å¹"],
    guÄ: [
      "åˆ®",
      "åŠ€",
      "æ¡°",
      "æ­„",
      "ç…±",
      "ç“œ",
      "èƒ",
      "è¸»",
      "é¢ª",
      "é¢³",
      "é¨§",
      "é´°",
      "é¸¹"
    ],
    gÄ“ng: [
      "åˆ¯",
      "åºš",
      "æ¤©",
      "æµ­",
      "ç„¿",
      "ç•Š",
      "çµš",
      "ç¾®",
      "ç¾¹",
      "è€•",
      "è®",
      "è³¡",
      "èµ“",
      "é¶Š",
      "é¹’"
    ],
    dÃ o: [
      "åˆ°",
      "å™µ",
      "æ‚¼",
      "æ¤¡",
      "æª¤",
      "ç‡¾",
      "ç“™",
      "ç›—",
      "ç›œ",
      "ç¨²",
      "ç¨»",
      "çº›",
      "ç¿¿",
      "è‰”",
      "è¿",
      "è¡œ",
      "è¡Ÿ",
      "è»‡",
      "é“"
    ],
    chuÃ ng: ["åˆ±", "å‰", "å‰™", "æ€†", "æ„´"],
    kÅ«: ["åˆ³", "å“­", "åœ", "å €", "æž¯", "æ¡", "çŸ»", "çªŸ", "è·", "éƒ€", "éª·", "é®¬"],
    duÃ²: [
      "åˆ´",
      "å‰",
      "å¢¯",
      "å°®",
      "æƒ°",
      "æ†œ",
      "æŒ…",
      "æ¡—",
      "èˆµ",
      "è·¥",
      "è·º",
      "é™Š",
      "é™",
      "é£¿",
      "é¥³",
      "éµ½"
    ],
    "shuÄ shuÃ ": ["åˆ·"],
    "quÃ n xuÃ n": ["åˆ¸"],
    "chÃ  shÄ": ["åˆ¹", "å‰Ž"],
    "cÃ¬ cÄ«": ["åˆº"],
    guÃ¬: [
      "åˆ½",
      "åˆ¿",
      "åŠŠ",
      "åŠŒ",
      "æ’Œ",
      "æ”°",
      "æ˜‹",
      "æ¡‚",
      "æ¤¢",
      "æ§¶",
      "æ¨»",
      "æ«ƒ",
      "çŒ¤",
      "ç¦¬",
      "ç­€",
      "è“•",
      "è¥˜",
      "è²´",
      "è´µ",
      "è·ª",
      "é€",
      "é‘Ž",
      "éž¼",
      "é±–",
      "é±¥"
    ],
    lÃ³u: [
      "å‰…",
      "å¨„",
      "å©",
      "å»”",
      "æ¥¼",
      "æ¨“",
      "æº‡",
      "æ¼Š",
      "ç†¡",
      "è€§",
      "è€¬",
      "è‰›",
      "è’Œ",
      "è”ž",
      "è¼",
      "èž»",
      "è¬±",
      "è»",
      "é±",
      "éž»",
      "é«…",
      "é«",
      "ðª£»"
    ],
    cuÃ²: [
      "å‰‰",
      "å‰’",
      "åŽ",
      "å¤Ž",
      "æŒ«",
      "æŽª",
      "æ£¤",
      "èŽ",
      "èŽ¡",
      "è“Œ",
      "é€ª",
      "éŠ¼",
      "éŒ¯",
      "é”‰",
      "é”™"
    ],
    "xiÄo xuÄ“": ["å‰Š"],
    "kÄ“i kÃ¨": ["å‰‹", "å°…"],
    "lÃ  lÃ¡": ["å‰Œ"],
    tÄ«: ["å‰”", "æ¢¯", "è¸¢", "éŠ»", "é”‘", "é·ˆ", "é·‰", "ä²", "ä´˜"],
    pÅu: ["å‰–"],
    wÄn: ["å‰œ", "å¡†", "å£ª", "å¸µ", "å¼¯", "å½Ž", "æ¹¾", "æ½«", "ç£", "ç•", "èœ¿", "è±Œ"],
    "bÄo bÅ": ["å‰", "å‰¥"],
    duÅ: ["å‰Ÿ", "å’„", "å“†", "åš‰", "å¤š", "å¤›", "æŽ‡", "æ¯²", "ç•“", "è£°", "ã™"],
    qÃ­ng: [
      "å‰ ",
      "å‹",
      "å¤",
      "æƒ…",
      "æ“Ž",
      "æ™´",
      "æš’",
      "æ£¾",
      "æ¨ˆ",
      "æª ",
      "æ°°",
      "ç” ",
      "ç¡˜",
      "è‘",
      "é»¥"
    ],
    "yÇŽn shÃ n": ["å‰¡"],
    "dÅ« zhuÃ³": ["å‰¢"],
    yÄn: [
      "å‰¦",
      "å«£",
      "å´¦",
      "å¶–",
      "æ¹",
      "æ‡•",
      "æ‡¨",
      "æ¨®",
      "æ·Š",
      "æ·¹",
      "æ¼¹",
      "çƒŸ",
      "ç„‰",
      "ç„‘",
      "ç…™",
      "çš",
      "ç¯¶",
      "èƒ­",
      "è‡™",
      "è¸",
      "é„¢",
      "é†ƒ",
      "é–¹",
      "é˜‰",
      "é»«"
    ],
    huÅ: ["å‰¨", "åŠ", "å™", "æ”‰", "ç§´", "è€ ", "é”ª", "é¨ž", "ð¬´ƒ"],
    shÃ¨ng: [
      "å‰©",
      "å‰°",
      "å‹",
      "åœ£",
      "å¢­",
      "åµŠ",
      "æ™ ",
      "æ¦º",
      "æ©³",
      "çž",
      "è–",
      "è•‚",
      "è²¹",
      "è³¸"
    ],
    "duÄn zhÃ¬": ["å‰¬"],
    wÅ«: [
      "å‰­",
      "å‘œ",
      "å—š",
      "åœ¬",
      "å±‹",
      "å·«",
      "å¼™",
      "æ‡",
      "æ­",
      "æ±™",
      "æ±š",
      "æ±¡",
      "æ´¿",
      "çƒ",
      "çª",
      "ç®¼",
      "èž",
      "èªˆ",
      "èª£",
      "è¯¬",
      "é‚¬",
      "é„”",
      "éŽ¢",
      "é’¨",
      "é°ž",
      "é´®"
    ],
    gÄ“: [
      "å‰²",
      "å“¥",
      "åœª",
      "å½",
      "æˆˆ",
      "æˆ“",
      "æˆ¨",
      "æ­Œ",
      "æ»’",
      "çŠµ",
      "è‚",
      "è¢¼",
      "è¬Œ",
      "éŽ¶",
      "é´š",
      "é´¿",
      "é¸½"
    ],
    "dÃ¡ zhÃ¡": ["å‰³"],
    chuÃ¡n: ["å‰¶", "æš·", "æ¤½", "ç¯…", "èˆ¡", "èˆ©", "èˆ¹", "è¼²", "é„"],
    "tuÃ¡n zhuÄn": ["å‰¸", "æ¼™", "ç¯¿"],
    "lÃ¹ jiÅ«": ["å‰¹"],
    pÄ“ng: ["å‰»", "åŒ‰", "å˜­", "æ€¦", "æ²", "æŠ¨", "æ¢ˆ", "çƒ¹", "ç °", "è»¯", "é§"],
    piÄo: ["å‰½", "å‹¡", "æ…“", "æ—š", "çŠ¥", "ç¿²", "èžµ", "é£ƒ", "é£„", "é£˜", "é­’"],
    kÅu: ["å‰¾", "å½„", "æŠ ", "æ‘³", "çœ", "çž˜", "èŠ¤", "ð«¸©"],
    "jiÇŽo chÄo": ["å‰¿", "åŠ‹", "å‹¦", "æ‘·"],
    qiÄo: [
      "åŠ",
      "å‹ª",
      "å¢",
      "å¹§",
      "æ•²",
      "æ©‡",
      "æ¯ƒ",
      "ç‡†",
      "ç¡—",
      "ç£½",
      "ç¹‘",
      "è¶¬",
      "è··",
      "è¸",
      "è¹º",
      "è¹»",
      "éƒ»",
      "é„¡",
      "é„¥",
      "é«",
      "é¬",
      "é°",
      "é”¹",
      "é "
    ],
    "huÃ¡ huÃ ": ["åŠƒ"],
    "zhÄ zhÃ¡": ["åŠ„"],
    "pÄ« pÇ": ["åŠˆ", "æ‚‚"],
    tÄng: ["åŠ", "å˜¡", "ç¾°", "è–š", "èª", "è¹š", "éžº", "é¼ž"],
    chÃ¡n: [
      "åŠ–",
      "åšµ",
      "å£¥",
      "å©µ",
      "å¬‹",
      "å·‰",
      "å»›",
      "æ£Ž",
      "æ¯š",
      "æ¹¹",
      "æ½¹",
      "æ½º",
      "æ¾¶",
      "ç€",
      "ç€º",
      "ç…˜",
      "ç‘",
      "ç£›",
      "ç·¾",
      "çº",
      "çº’",
      "ç¼ ",
      "è‰¬",
      "è‰",
      "èŸ",
      "èŸ¬",
      "èŸ¾",
      "èª—",
      "è®’",
      "è°—",
      "èº”",
      "é„½",
      "é…",
      "é‹‹",
      "é‘±",
      "é•µ",
      "é¥ž",
      "é¦‹"
    ],
    zuÄn: ["åŠ—", "èºœ", "èº¦", "é‰†", "é‘š"],
    mÃ³: [
      "åŠ˜",
      "å««",
      "å¬¤",
      "å¬·",
      "å°›",
      "æ‘¹",
      "æ“µ",
      "æ©…",
      "ç³¢",
      "è†œ",
      "è—¦",
      "è˜‘",
      "è¬¨",
      "è¬©",
      "è°Ÿ",
      "é¥ƒ",
      "é¥",
      "é¦",
      "é«",
      "é­”",
      "é­¹"
    ],
    zhÃº: [
      "åŠš",
      "æ–¸",
      "æ›¯",
      "æ¬˜",
      "çŸ",
      "ç‚¢",
      "çƒ›",
      "ç‡­",
      "çˆ¥",
      "ç˜ƒ",
      "ç«¹",
      "ç¬",
      "ç¬œ",
      "èˆ³",
      "èŒ¿",
      "è“«",
      "è ‹",
      "è ¾",
      "èº…",
      "é€",
      "é€«",
      "é’ƒ",
      "é±"
    ],
    quÃ n: ["åŠ", "å‹§", "å‹¸", "ç‰¶", "éŸ"],
    "jÃ¬n jÃ¬ng": ["åŠ¤", "åŠ²", "å‹"],
    kÄ“ng: ["åŠ¥", "å‘", "ç‰¼", "ç¡", "ç¡œ", "èª™", "éŠµ", "éž", "é—", "é“¿", "é˜¬"],
    "xiÃ© liÃ¨": ["åŠ¦"],
    "zhÃ¹ chÃº": ["åŠ©"],
    nÇ”: ["åŠª", "å¼©", "ç ®", "èƒ¬"],
    shÃ o: ["åŠ­", "å²", "å“¨", "æ½²", "ç´¹", "ç¶¤", "ç»", "è¢‘", "é‚µ"],
    miÇŽo: ["åŠ°", "æª", "æ·¼", "æ¸º", "çœ‡", "ç§’", "ç¯Ž", "ç·²", "ç¼ˆ", "è—", "é‚ˆ"],
    kÇ’u: ["åŠ¶", "å£"],
    wÄ: [
      "åŠ¸",
      "å¨²",
      "åª§",
      "å±²",
      "æŒ–",
      "æ”¨",
      "æ´¼",
      "æº›",
      "æ¼¥",
      "ç“¾",
      "ç•–",
      "ç©µ",
      "çªŠ",
      "çªª",
      "è›™",
      "éŸˆ",
      "é¼ƒ"
    ],
    kuÄng: [
      "åŠ»",
      "åŒ¡",
      "åŒ©",
      "å“",
      "æ‡",
      "æ´­",
      "ç­",
      "ç­º",
      "èª†",
      "è¯“",
      "è»­",
      "é‚¼"
    ],
    hÃ©: [
      "åŠ¾",
      "å’Š",
      "å•",
      "å§€",
      "å³†",
      "æ•†",
      "æ›·",
      "æŸ‡",
      "æ¥",
      "æ¯¼",
      "æ²³",
      "æ¶¸",
      "æ¸®",
      "æ¾•",
      "ç††",
      "çš¬",
      "ç›‡",
      "ç›‰",
      "ç›",
      "ç›’",
      "ç¦¾",
      "ç¯•",
      "ç±º",
      "ç²­",
      "ç¿®",
      "è",
      "è‚",
      "è¦ˆ",
      "è¨¸",
      "è©¥",
      "éƒƒ",
      "é‡›",
      "é‰Œ",
      "é‘‰",
      "é–¡",
      "é—”",
      "é˜‚",
      "é˜–",
      "éž¨",
      "é œ",
      "é¤„",
      "é¥¸",
      "é­º",
      "é¹–",
      "éº§",
      "é½•",
      "é¾",
      "é¾¢",
      "ð¬Œ—"
    ],
    gÃ o: [
      "å‹‚",
      "å¿",
      "å‘Š",
      "å³¼",
      "ç¥®",
      "ç¥°",
      "ç¦ž",
      "ç­¶",
      "èª¥",
      "è¯°",
      "éƒœ",
      "é‹¯",
      "é”†"
    ],
    "bÃ³ bÃ¨i": ["å‹ƒ"],
    lÃ¡ng: [
      "å‹†",
      "å«",
      "å»Š",
      "æ–",
      "æ¡¹",
      "æ¦”",
      "æ¨ƒ",
      "æ¬´",
      "ç‹¼",
      "ç…",
      "ç‘¯",
      "ç¡ ",
      "ç¨‚",
      "è‰†",
      "è“ˆ",
      "èœ‹",
      "èž‚",
      "èº´",
      "éƒ’",
      "éƒž",
      "é‹ƒ",
      "éŽ¯",
      "é”’"
    ],
    xÅ«n: [
      "å‹‹",
      "å‹›",
      "å‹²",
      "å‹³",
      "åš‘",
      "åƒ",
      "åŸ™",
      "å¡¤",
      "å£Ž",
      "å£¦",
      "æ››",
      "ç‡»",
      "ç¯",
      "çŸ„",
      "çº",
      "è‡",
      "è–«",
      "è–°",
      "è˜",
      "é†º",
      "ð«„¸"
    ],
    "juÃ n juÄn": ["å‹Œ", "ç“¹"],
    "lÃ¨ lÄ“i": ["å‹’"],
    kÃ i: ["å‹“", "ç‚Œ", "çƒ—", "éŽŽ"],
    "wÄ›ng yÇŽng": ["å‹œ"],
    qÃ­n: [
      "å‹¤",
      "å—ª",
      "å™™",
      "å¶œ",
      "åºˆ",
      "æ‡ƒ",
      "æ‡„",
      "æ¦",
      "æ“’",
      "æ–³",
      "æªŽ",
      "æ¾¿",
      "ç¡",
      "ç´",
      "ç¹",
      "ç˜½",
      "ç¦½",
      "ç§¦",
      "è€¹",
      "èŠ©",
      "èŠ¹",
      "è¦",
      "èž“",
      "è „",
      "éˆ™",
      "éˆ«",
      "é›‚",
      "é²",
      "é³¹",
      "éµ­"
    ],
    jiÃ ng: [
      "å‹¥",
      "åŒž",
      "åŒ ",
      "åµ¹",
      "å¼œ",
      "å¼¶",
      "æ‘¾",
      "æ«¤",
      "æ´š",
      "æ»°",
      "çŠŸ",
      "ç³¡",
      "ç³¨",
      "çµ³",
      "ç»›",
      "è¬½",
      "é…±",
      "é†¤",
      "é†¬"
    ],
    fÄn: [
      "å‹«",
      "å¬",
      "å¸†",
      "å¹¡",
      "å¿›",
      "æ†£",
      "æ—™",
      "æ—›",
      "ç¹™",
      "ç¿»",
      "è—©",
      "è½“",
      "é¢¿",
      "é£œ",
      "é±•"
    ],
    juÄn: ["å‹¬", "å§¢", "å¨Ÿ", "æ", "æ¶“", "è ²", "è£", "éŽ¸", "é«", "é•Œ", "é¹ƒ"],
    "tÃ³ng dÃ²ng": ["å‹­", "çƒ”", "ç‡‘", "ç‹ª"],
    lÇœ: [
      "å‹´",
      "åž",
      "åµ‚",
      "å¾‹",
      "æ…®",
      "æ°¯",
      "æ»¤",
      "æ¿¾",
      "çˆˆ",
      "ç®»",
      "ç¶ ",
      "ç¹‚",
      "è†Ÿ",
      "è‘Ž",
      "è™‘",
      "é‘¢"
    ],
    chÃ¨: [
      "å‹¶",
      "å¼",
      "å½»",
      "å¾¹",
      "æŽ£",
      "æ’¤",
      "æ¾ˆ",
      "çƒ¢",
      "çˆ¡",
      "çž®",
      "ç¡©",
      "è…",
      "è¿ ",
      "é ™",
      "ã¬š"
    ],
    shÃ¡o: ["å‹º", "çŽ¿", "éŸ¶"],
    "gÅu gÃ²u": ["å‹¾"],
    cÅng: [
      "åŒ†",
      "å›ª",
      "å›±",
      "å¿©",
      "æ€±",
      "æ‚¤",
      "æš°",
      "æ¨¬",
      "æ¼—",
      "ç‘½",
      "ç’",
      "çž›",
      "ç¯µ",
      "ç¹±",
      "è¡",
      "è¦",
      "èª",
      "è°",
      "è‹",
      "èŒ",
      "è‘±",
      "è“¯",
      "è”¥",
      "èŸŒ",
      "é¯",
      "é“",
      "é¦",
      "é¨˜",
      "é©„",
      "éª¢"
    ],
    "tÃ¡o yÃ¡o": ["åŒ‹", "é™¶"],
    pÃ¡o: ["åŒ", "å’†", "åž‰", "åº–", "çˆ®", "ç‹", "è¢", "è¤œ", "è»³", "éž„", "éº…"],
    dÃ¡: [
      "åŒ’",
      "å¦²",
      "æ€›",
      "ç‚Ÿ",
      "ç‡µ",
      "ç•£",
      "ç¬ª",
      "ç¾",
      "è™",
      "è–˜",
      "èŸ½",
      "è©š",
      "è¾¾",
      "è¿",
      "è¿–",
      "è¿š",
      "é€¹",
      "é”",
      "é½",
      "é¼",
      "éž‘",
      "éŸƒ",
      "é¾–",
      "é¾˜",
      "ð«Ÿ¼"
    ],
    "huÃ  huÄ": ["åŒ–"],
    "bÄ›i bÃ¨i": ["åŒ—"],
    nÇŽo: ["åŒ˜", "åž´", "å –", "å«", "æ¼", "æ‚©", "æƒ±", "ç‘™", "ç¢¯", "è„‘", "è„³", "è…¦"],
    "chÃ­ shi": ["åŒ™"],
    fÄng: ["åŒš", "å ", "æ–¹", "æ·“", "ç‰¥", "èŠ³", "é‚¡", "éˆ", "éŒº", "é’«", "é´‹"],
    zÄ: ["åŒ", "å’‚", "å¸€", "æ²ž", "è‡œ", "è‡¢", "è¿Š", "é‰”", "é­³"],
    qiÃ¨: [
      "åŒ§",
      "åŽ’",
      "å¦¾",
      "æ€¯",
      "æ‚",
      "æƒ¬",
      "æ„œ",
      "æŒˆ",
      "ç©•",
      "çªƒ",
      "ç«Š",
      "ç¬¡",
      "ç®§",
      "ç¯‹",
      "ç±¡",
      "è¸¥",
      "é¥",
      "é”²",
      "é¯œ"
    ],
    "zÄng cÃ¡ng": ["åŒ¨"],
    fÄ›i: ["åŒª", "å¥œ", "æ‚±", "æ£", "æ¦§", "ç¯š", "ç¿¡", "è•œ", "èª¹", "è¯½"],
    "kuÃ¬ guÃ¬": ["åŒ®", "åŒ±"],
    suÇŽn: ["åŒ´"],
    pÇ: ["åŒ¹", "å™½", "åš­", "åœ®", "åº€", "ç—ž", "ç™–", "è„´", "è‹‰", "éŠ¢", "é´„"],
    "qÅ« Åu": ["åŒº", "å€"],
    "kÄ“ qiÃ ": ["åŒ¼"],
    "yÇŽn yÃ n": ["åŒ½", "æ£ª"],
    biÇŽn: ["åŒ¾", "æƒ¼", "æ™", "ç¢¥", "ç¨¨", "çª†", "è—Š", "è¤Š", "è²¶", "è´¬", "é´˜"],
    nÃ¬: [
      "åŒ¿",
      "å „",
      "å«Ÿ",
      "å¬º",
      "æƒ„",
      "æ„µ",
      "æ˜µ",
      "æš±",
      "æ°¼",
      "çœ¤",
      "ç¨",
      "ç¸Œ",
      "èƒ’",
      "è…»",
      "è†©",
      "é€†",
      "ð¨º™"
    ],
    niÃ n: ["å„", "å”¸", "åŸ", "å»¿", "å¿µ", "æƒ—", "è‰Œ"],
    sÃ : ["å…", "æ«’", "è„Ž", "è¨", "è•¯", "è–©", "éˆ’", "éš¡", "é¢¯", "é£’", "é¦º"],
    zÃº: ["å†", "å“«", "å´ª", "æ—", "ç®¤", "è¶³", "è¸¤", "é•ž"],
    shÄ“ng: [
      "å‡",
      "å‘",
      "å£°",
      "æ–˜",
      "æ˜‡",
      "æ›»",
      "æž¡",
      "æ®…",
      "æ³©",
      "æ¹¦",
      "ç„º",
      "ç‰²",
      "ç„",
      "ç”Ÿ",
      "ç”¥",
      "ç«”",
      "ç¬™",
      "è²",
      "é‰Ž",
      "éŸ",
      "é˜©",
      "é™ž",
      "é™¹",
      "éµ¿",
      "é¼ª"
    ],
    wÃ n: [
      "å",
      "å",
      "å¿¨",
      "æ¤",
      "çž£",
      "è„•",
      "è…•",
      "è¬",
      "èŸƒ",
      "è´Ž",
      "è¼",
      "éŒ½",
      "ð¬‡•"
    ],
    "huÃ¡ huÃ  huÄ": ["åŽ", "è¯"],
    bÄ“i: ["å‘", "æ‚²", "æ¹", "æ¯", "æ¡®", "ç›ƒ", "ç¢‘", "è—£", "éµ¯", "é¹Ž"],
    "zÃº cÃ¹": ["å’"],
    "dÄn shÃ n chÃ¡n": ["å•", "å–®"],
    "nÃ¡n nÄ": ["å—"],
    "shuÃ i lÇœ": ["å›"],
    "bÇ” bo pÃº": ["åœ"],
    "kuÃ ng guÃ n": ["å"],
    biÃ n: [
      "åž",
      "å˜",
      "å¤‰",
      "å³…",
      "å¼",
      "å¾§",
      "å¿­",
      "æŠƒ",
      "æ˜ª",
      "æ±³",
      "æ±´",
      "çŽ£",
      "è‰‘",
      "è‹„",
      "è¦",
      "è«š",
      "è®Š",
      "è¾¡",
      "è¾§",
      "è¾¨",
      "è¾©",
      "è¾«",
      "è¾®",
      "è¾¯",
      "é",
      "é‡†",
      "ð¨š•"
    ],
    bÇ”: ["åŸ", "å“º", "æ•", "è¡¥", "è£œ", "é¸”", "ð¬·•"],
    "zhÃ n zhÄn": ["å ", "è¦±"],
    "kÇŽ qiÇŽ": ["å¡"],
    lÃº: [
      "å¢",
      "åš§",
      "åž†",
      "å£š",
      "åº",
      "å»¬",
      "æ›¥",
      "æž¦",
      "æ Œ",
      "æ«¨",
      "æ³¸",
      "ç€˜",
      "ç‚‰",
      "çˆ",
      "ç¹",
      "çŽˆ",
      "ç“",
      "ç›§",
      "çŸ‘",
      "ç±š",
      "çº‘",
      "ç½",
      "èƒª",
      "è‡š",
      "èˆ®",
      "èˆ»",
      "è‰«",
      "èŠ¦",
      "è˜†",
      "è ¦",
      "è½¤",
      "è½³",
      "éˆ©",
      "é‘ª",
      "é¡±",
      "é¢…",
      "é¦¿",
      "é«—",
      "é­²",
      "é±¸",
      "é²ˆ",
      "é¸•",
      "é¸¬",
      "é»¸",
      "ð¬¬»"
    ],
    lÇ”: [
      "å¤",
      "å¡·",
      "æŽ³",
      "æ“„",
      "æ¨",
      "æ©¹",
      "æ«“",
      "æ°Œ",
      "æ»·",
      "æ¾›",
      "ç€‚",
      "ç¡µ",
      "ç£ ",
      "ç©ž",
      "è‰£",
      "è‰ª",
      "è“¾",
      "è™",
      "è™œ",
      "é€",
      "éª",
      "é‘¥",
      "é•¥",
      "é­¯",
      "é²",
      "é¹µ"
    ],
    guÃ : ["å¦", "å•©", "æŒ‚", "æŽ›", "ç½£", "è¤‚", "è©¿", "è¯–"],
    "Ã¡ng yÇŽng": ["å¬"],
    yÃ¬n: [
      "å°",
      "åž½",
      "å ·",
      "å»•",
      "æ…­",
      "æ†–",
      "æ†—",
      "æ‡š",
      "æ´•",
      "æ¹š",
      "çŒŒ",
      "ç™Š",
      "èƒ¤",
      "èŒš",
      "é…³",
      "é®£",
      "ä²Ÿ"
    ],
    quÃ¨: [
      "å´",
      "å»",
      "å¡™",
      "å´…",
      "æ‚«",
      "æ„¨",
      "æ…¤",
      "æ‰",
      "æ¦·",
      "ç‡©",
      "ç·",
      "çšµ",
      "ç¡®",
      "ç¢º",
      "ç¤­",
      "é—‹",
      "é˜•",
      "éµ²",
      "é¹Š",
      "ð¬’ˆ"
    ],
    luÇŽn: ["åµ"],
    "juÃ n juÇŽn": ["å·", "å·»"],
    "chÇŽng Än hÃ n": ["åŽ‚"],
    "wÄ›i yÃ¡n": ["åŽƒ"],
    tÄ«ng: [
      "åŽ…",
      "åŽ›",
      "å¬",
      "åº",
      "å»°",
      "å»³",
      "æ±€",
      "çƒƒ",
      "çƒ´",
      "ç¶Ž",
      "è€“",
      "è´",
      "è¼",
      "è½",
      "éž“",
      "ð¬˜©"
    ],
    "zhÃ© zhÃ¡i": ["åŽ‡"],
    "hÃ n Ã n": ["åŽˆ", "å±½"],
    yÇŽ: ["åŽŠ", "å”–", "åºŒ", "ç—–", "ç˜‚", "è•¥"],
    shÃ¨: [
      "åŽ",
      "åŽ™",
      "å¼½",
      "æ…‘",
      "æ…´",
      "æ‡¾",
      "æ‘‚",
      "æ¬‡",
      "æ¶‰",
      "æ¶»",
      "æ¸‰",
      "æ» ",
      "ç„",
      "ç¤¾",
      "èˆŽ",
      "è”Ž",
      "è ‚",
      "è¨­",
      "è®¾",
      "èµ¦",
      "é¨‡",
      "éº"
    ],
    dÇ: [
      "åŽŽ",
      "å‘§",
      "å˜",
      "å¼¤",
      "æŠµ",
      "æ‹ž",
      "æŽ‹",
      "ç‰´",
      "ç ¥",
      "è§",
      "è§",
      "è©†",
      "è¯‹",
      "è»§",
      "é‚¸",
      "é˜º",
      "éª¶",
      "é¯³"
    ],
    "zhÇŽ zhÇŽi": ["åŽ"],
    pÃ¡ng: ["åŽ", "å«Ž", "åºž", "å¾¬", "èˆ½", "èžƒ", "é€„", "é°Ÿ", "é³‘", "é¾Ž", "é¾"],
    "zhÃ¬ shÄ«": ["åŽ”"],
    mÃ¡ng: [
      "åŽ–",
      "å‚",
      "å“¤",
      "å¨",
      "å¿™",
      "æ¾",
      "æ—",
      "æ§",
      "æ±’",
      "æµ",
      "ç‰»",
      "ç—",
      "ç›²",
      "ç¡­",
      "ç¬€",
      "èŠ’",
      "èŒ«",
      "è˜‰",
      "é‚™",
      "é‡¯",
      "é‹©",
      "é““",
      "é§¹"
    ],
    zuÄ«: ["åŽœ", "æ¨¶", "çº—", "èŸ•"],
    "shÃ  xiÃ ": ["åŽ¦", "å»ˆ"],
    Ã¡o: [
      "åŽ«",
      "å—·",
      "å—¸",
      "å»’",
      "æ•–",
      "æ»¶",
      "ç’",
      "ç“",
      "ç’ˆ",
      "ç¿±",
      "ç¿¶",
      "ç¿º",
      "è±",
      "è”œ",
      "èž¯",
      "è¬·",
      "è¬¸",
      "é¨",
      "é–",
      "éšž",
      "é°²",
      "é³Œ",
      "é·”",
      "é¼‡"
    ],
    "lÃ¡n qiÄn": ["åŽ±"],
    "sÄ« mÇ’u": ["åŽ¶"],
    "gÅng hÃ³ng": ["åŽ·"],
    "lÃ­n miÇŽo": ["åŽ¸"],
    "qiÃº rÃ³u": ["åŽ¹"],
    dÅ«: ["åŽ¾", "å˜Ÿ", "ç£", "é†"],
    "xiÃ n xuÃ¡n": ["åŽ¿", "ç¸£"],
    "cÄn shÄ“n cÄ“n sÄn": ["å‚", "åƒ", "å„", "å…"],
    "Ã i yÇ": ["å†"],
    "chÄ chÃ  chÇŽ chÃ¡": ["å‰"],
    shuÄng: [
      "åŒ",
      "å­€",
      "å­‡",
      "æ¬†",
      "ç¤µ",
      "è‰­",
      "é›™",
      "éœœ",
      "é¨»",
      "é©¦",
      "éª¦",
      "é·ž",
      "é¸˜",
      "é¹´"
    ],
    shÅu: ["åŽ", "æ”¶"],
    guÃ¡i: ["å"],
    bÃ¡: [
      "å",
      "å¦­",
      "æŠœ",
      "æ‹”",
      "ç‚¦",
      "ç™¹",
      "èƒˆ",
      "èŒ‡",
      "è",
      "è©™",
      "è·‹",
      "è»·",
      "é­ƒ",
      "é¼¥"
    ],
    "fÄ fÃ ": ["å‘"],
    "zhuÃ³ yÇ lÃ¬ juÃ©": ["å•"],
    qÇ”: ["å–", "å¨¶", "ç«¬", "èº", "è©“", "é½²", "é¾‹"],
    "jiÇŽ xiÃ¡": ["åš", "å¾¦"],
    "wÃ¨i yÃ¹": ["åž", "å°‰", "è”š"],
    diÃ©: [
      "å ",
      "åž¤",
      "å ž",
      "å³Œ",
      "å¹‰",
      "æŽ",
      "æƒµ",
      "æˆœ",
      "æ›¡",
      "æ®œ",
      "æ°Ž",
      "ç‰ƒ",
      "ç‰’",
      "ç“ž",
      "ç•³",
      "ç–‚",
      "ç–‰",
      "ç–Š",
      "ç¢Ÿ",
      "çµ°",
      "ç»–",
      "è€Š",
      "è€‹",
      "èƒ…",
      "è‰“",
      "è‹µ",
      "èœ¨",
      "è¶",
      "è¤‹",
      "è©„",
      "è«œ",
      "è°",
      "è·®",
      "è¹€",
      "è¿­",
      "é•»",
      "é°ˆ",
      "é²½",
      "é´©",
      "ð«¶‡"
    ],
    ruÃ¬: ["å¡", "æž˜", "æ±­", "ç‘ž", "ç¿", "èŠ®", "èš‹", "èœ¹", "éŠ³", "é‹­", "é”"],
    "jÃ¹ gÅu": ["å¥"],
    lÃ¬ng: ["å¦", "å‘¤", "ç‚©", "è˜¦"],
    "dÄo dÃ¡o tÄo": ["å¨"],
    "zhÄ« zhÇ": ["åª"],
    jiÃ o: [
      "å«",
      "å‘Œ",
      "å˜‚",
      "å˜¦",
      "å™",
      "å¬“",
      "æ–",
      "æ– ",
      "æ»˜",
      "æ¼–",
      "ç¥",
      "ç“",
      "çš­",
      "çª–",
      "è— ",
      "è¨†",
      "è­¥",
      "è¶­",
      "è¼ƒ",
      "è½Ž",
      "è½¿",
      "è¾ƒ",
      "é…µ",
      "é†®",
      "é‡‚"
    ],
    "zhÃ o shÃ o": ["å¬"],
    "kÄ› kÃ¨": ["å¯"],
    "tÃ¡i tÄi": ["å°", "è‹”"],
    pÇ’: ["åµ", "å°€", "ç¬¸", "ç®¥", "é‰•", "é’·", "é§Š"],
    "yÃ¨ xiÃ©": ["å¶"],
    "hÃ o hÃ¡o": ["å·"],
    tÃ n: ["å¹", "å˜†", "æŽ¢", "æ­Ž", "æ¹ ", "ç‚­", "ç¢³", "èˆ•"],
    "hÅng hÃ³ng": ["å¿"],
    miÄ“: ["å€", "å’©", "å“¶", "å­­"],
    "xÅ« yÅ« yÃ¹": ["å"],
    chÄ«: [
      "åƒ",
      "å“§",
      "å–«",
      "å—¤",
      "å™„",
      "å¦›",
      "åª¸",
      "å½¨",
      "å½²",
      "æ‘›",
      "æ”¡",
      "æ®¦",
      "ç“»",
      "ç—´",
      "ç™¡",
      "çœµ",
      "çž",
      "ç¬ž",
      "ç²š",
      "èƒµ",
      "èš©",
      "èž­",
      "è¨µ",
      "é­‘",
      "é´Ÿ",
      "éµ„",
      "é¸±",
      "é»",
      "é½",
      "ð«„¨"
    ],
    "xuÄn sÃ²ng": ["å…"],
    yÄo: [
      "å†",
      "å–“",
      "å¤­",
      "å¦–",
      "å¹º",
      "æ¥†",
      "æ®€",
      "ç¥…",
      "è…°",
      "è‘½",
      "è¨ž",
      "é‚€",
      "é´",
      "é´¢",
      "ã™˜"
    ],
    zÇ: [
      "å‡",
      "å§‰",
      "å§Š",
      "å­",
      "æ",
      "æ¢“",
      "æ¦Ÿ",
      "æ©´",
      "æ»“",
      "çŸ·",
      "ç§­",
      "ç¬«",
      "ç±½",
      "ç´«",
      "è€”",
      "è™¸",
      "è¨¿",
      "é‡¨"
    ],
    "hÃ© gÄ›": ["åˆ", "é²„"],
    "cÃ¹n dÃ²u": ["å‹"],
    "tÃ³ng tÃ²ng": ["åŒ"],
    "tÇ” tÃ¹": ["å", "å”‹"],
    "zhÃ  zhÄ": ["å’", "å¥“"],
    "xiÃ  hÃ¨": ["å“"],
    "Ä yÄ": ["å–"],
    "ma mÃ¡ mÇŽ": ["å—"],
    lÃ¬n: [
      "å",
      "æ¡",
      "æ‚‹",
      "æ©‰",
      "ç„›",
      "ç”",
      "è†¦",
      "è”º",
      "è—º",
      "è³ƒ",
      "èµ",
      "è¹¸",
      "èº",
      "èº™",
      "èºª",
      "è½¥",
      "é–µ"
    ],
    tÅ«n: ["åž", "æš¾", "æœœ", "ç„ž"],
    "bÇ pÇ": ["å¡"],
    qÃ¬n: ["å¢", "å£", "å”š", "æŠ‹", "æ¿", "æ‡", "æ’³", "æ²", "ç€™", "è£", "è—½"],
    "jiÃ¨ gÃ¨": ["å¤"],
    "fÇ’u pÇ": ["å¦"],
    "ba bÄ": ["å§"],
    dÅ«n: [
      "å¨",
      "å™¸",
      "å¢©",
      "å¢ª",
      "æƒ‡",
      "æ’‰",
      "æ’´",
      "çŠœ",
      "ç¤",
      "ç¤…",
      "èœ³",
      "è¹¾",
      "é©"
    ],
    fÄ“n: [
      "å©",
      "å¸‰",
      "æ˜",
      "æœ†",
      "æ¢¤",
      "æ£»",
      "æ°›",
      "ç«•",
      "ç´›",
      "çº·",
      "ç¿‚",
      "èŠ¬",
      "è¡¯",
      "è¨œ",
      "èº®",
      "é…š",
      "éˆ–",
      "é›°",
      "é¤´",
      "é¥™",
      "é¦š"
    ],
    "Ã© huÄ": ["åª"],
    "kÄ“ng hÃ¡ng": ["å­", "å¦”"],
    shÇ”n: ["å®"],
    "zhÄ« zÄ«": ["å±"],
    "yÇn shÄ›n": ["å²"],
    wÃº: [
      "å³",
      "å´",
      "å‘‰",
      "å¢²",
      "å³¿",
      "æ¢§",
      "æ©†",
      "æ¯‹",
      "æ´–",
      "æµ¯",
      "ç„¡",
      "ç¸",
      "ç’‘",
      "ç¥¦",
      "èŠœ",
      "èŒ£",
      "èŽ",
      "è•ª",
      "èœˆ",
      "èŸ±",
      "è­•",
      "éƒš",
      "é‹™",
      "é“»",
      "é¯ƒ",
      "éµ",
      "é·¡",
      "é¹€",
      "é¼¯"
    ],
    "chÇŽo chÄo": ["åµ"],
    "nÃ  nÃ¨": ["å¶"],
    "xuÃ¨ chuÃ² juÃ©": ["å·"],
    chuÄ«: ["å¹", "ç‚Š", "é¾¡"],
    "dÅu rÃº": ["åº"],
    hÇ’u: ["å¼", "çŠ¼"],
    "hÅng hÇ’u Åu": ["å½"],
    "wÃº yÃ¹": ["å¾"],
    "ya yÄ": ["å‘€"],
    "Ã¨ e": ["å‘ƒ"],
    dÄi: ["å‘†", "æ‡›", "çƒ"],
    "mÃ¨n qÇ": ["å‘‡"],
    hÅng: [
      "å‘",
      "åš",
      "æˆ",
      "ç´",
      "çƒ˜",
      "ç„¢",
      "ç¡¡",
      "è–¨",
      "è¨‡",
      "è°¾",
      "è»£",
      "è¼·",
      "è½Ÿ",
      "è½°",
      "é§"
    ],
    nÃ : [
      "å‘",
      "æº",
      "ç¬",
      "ç´",
      "çº³",
      "è‚­",
      "è’³",
      "è¡²",
      "è±½",
      "è²€",
      "è»œ",
      "éƒ",
      "éˆ‰",
      "é’ ",
      "é¹",
      "é­¶"
    ],
    "tÅ«n tiÄn": ["å‘‘"],
    "fÇ” á¸¿": ["å‘’", "å˜¸"],
    "dÄi tÇŽi": ["å‘”"],
    "Ç’u Åu Ã²u": ["å‘•"],
    "bÃ i bei": ["å‘—"],
    "yuÃ¡n yÃºn yÃ¹n": ["å‘˜", "å“¡"],
    guÅ: [
      "å‘™",
      "å•¯",
      "å˜“",
      "åŸš",
      "å ",
      "å¢Ž",
      "å´ž",
      "å½‰",
      "å½",
      "æ‡–",
      "çŒ“",
      "ç˜‘",
      "è’",
      "èˆ",
      "èŸˆ",
      "éƒ­",
      "éˆ›",
      "é‹",
      "é”…"
    ],
    "huÃ¡ qÃ¬": ["å‘š"],
    "qiÃ ng qiÄng": ["å‘›", "è·„"],
    shÄ«: [
      "å‘ž",
      "å¤±",
      "å°¸",
      "å±",
      "å¸ˆ",
      "å¸«",
      "æ–½",
      "æµ‰",
      "æ¹¤",
      "æ¹¿",
      "æº®",
      "æº¼",
      "æ¿•",
      "ç‹®",
      "ç…",
      "ç‘¡",
      "çµ",
      "è‘¹",
      "è’’",
      "è“",
      "è™±",
      "è¨",
      "è¤·",
      "è¥¹",
      "è©©",
      "è¯—",
      "é‚¿",
      "é‡ƒ",
      "é‰‡",
      "é¦",
      "é¯´",
      "é°¤",
      "é²º",
      "é³²",
      "é³¾",
      "é¶³",
      "é¸¤",
      "ä´“",
      "ð«š•"
    ],
    juÇŽn: ["å‘Ÿ", "åŸ", "è‡‡", "è¤", "éŒˆ", "é”©"],
    pÄ›n: ["å‘ ", "ç¿¸"],
    "wÄ›n mÇn": ["å‘¡"],
    "ne nÃ­": ["å‘¢"],
    "á¸¿ mÌ€ mÃ³u": ["å‘£"],
    rÃ¡n: [
      "å‘¥",
      "å˜«",
      "ç„¶",
      "ç‡ƒ",
      "ç¹Ž",
      "è‚°",
      "èš¦",
      "èšº",
      "è¡»",
      "è¢‡",
      "è¢¡",
      "é«¥",
      "é«¯"
    ],
    "tiÃ¨ chÃ¨": ["å‘«"],
    "qÃ¬ zhÄ«": ["å‘®"],
    "zÇ cÄ«": ["å‘°"],
    "guÄ gÅ« guÇŽ": ["å‘±"],
    "cÄ« zÄ«": ["å‘²"],
    "hÇ’u xÇ” gÃ²u": ["å‘´"],
    "hÄ“ Ä Ã¡ ÇŽ Ã  a": ["å‘µ"],
    nÃ¡o: [
      "å‘¶",
      "å¤’",
      "å³±",
      "å¶©",
      "å·Ž",
      "æŒ ",
      "æ’“",
      "çŒ±",
      "ç¡‡",
      "è›²",
      "èŸ¯",
      "è©‰",
      "è­Š",
      "éƒ",
      "é“™"
    ],
    "xiÄ gÄ": ["å‘·"],
    pÄ“i: ["å‘¸", "æ€Œ", "è‚§", "èƒš", "è¡ƒ", "é†…"],
    "hÃ¡o xiÄo": ["å‘º"],
    mÃ¬ng: ["å‘½", "æŽµ"],
    "dÃ¡ dÃ n": ["å‘¾"],
    "zuÇ jÇ”": ["å’€"],
    "xiÃ¡n gÄn": ["å’"],
    pÇ’u: ["å’…", "å“£", "çŠƒ"],
    "yÇŽng yÄng": ["å’‰"],
    "zÇŽ zÃ© zhÄ": ["å’‹"],
    "hÃ© hÃ¨ huÃ³ huÃ² hÃº": ["å’Œ"],
    hÄi: ["å’"],
    dÄ: ["å’‘", "å“’", "å™ ", "å¢¶", "æ­", "æ’˜", "è€·", "è¤¡", "éŽ", "ð¨±"],
    "kÇŽ kÄ": ["å’”"],
    gÅ«: [
      "å’•",
      "å”‚",
      "å”ƒ",
      "å§‘",
      "å«´",
      "å­¤",
      "å·¬",
      "å·­",
      "æŸ§",
      "æ©­",
      "æ²½",
      "æ³’",
      "ç¨’",
      "ç¬Ÿ",
      "ç®",
      "ç®›",
      "ç¯",
      "ç½›",
      "è‹½",
      "è‡",
      "è°",
      "è“‡",
      "è§š",
      "è»±",
      "è»²",
      "è½±",
      "è¾œ",
      "é…¤",
      "éˆ²",
      "é®•",
      "é´£",
      "é¸ª"
    ],
    "kÄ gÄ": ["å’–"],
    zuo: ["å’—"],
    lÃ³ng: [
      "å’™",
      "åš¨",
      "å¶",
      "å·ƒ",
      "å·„",
      "æ˜½",
      "æ›¨",
      "æœ§",
      "æ Š",
      "æ§ž",
      "æ«³",
      "æ¹°",
      "æ»",
      "æ¼‹",
      "çˆ–",
      "ç‘",
      "ç“",
      "ç™ƒ",
      "çœ¬",
      "çŸ“",
      "ç »",
      "ç¤±",
      "ç¤²",
      "çª¿",
      "ç«œ",
      "è‹",
      "è¾",
      "èƒ§",
      "èŒ",
      "è˜¢",
      "è ª",
      "è ¬",
      "è¥±",
      "è±…",
      "é§",
      "é‘¨",
      "éœ³",
      "é‡",
      "é©¡",
      "é¸—",
      "é¾",
      "é¾’",
      "é¾™"
    ],
    "xiÃ n xiÃ¡n": ["å’ž"],
    qÃ¬: [
      "å’ ",
      "å”­",
      "å™",
      "å™¨",
      "å¤¡",
      "å¼ƒ",
      "æ†‡",
      "æ†©",
      "æš£",
      "æ£„",
      "æ¬«",
      "æ°”",
      "æ°—",
      "æ°£",
      "æ±”",
      "æ±½",
      "æ³£",
      "æ¹†",
      "æ¹‡",
      "ç‚",
      "ç”ˆ",
      "ç›µ",
      "çŸµ",
      "ç¢›",
      "ç¢¶",
      "ç£œ",
      "ç£§",
      "ç½Š",
      "èŠž",
      "è‘º",
      "è—’",
      "èŸ¿",
      "è¨–",
      "è®«",
      "è¿„",
      "é‘"
    ],
    "xÃ¬ diÃ©": ["å’¥"],
    "liÄ“ liÄ› liÃ© lie": ["å’§"],
    zÄ«: [
      "å’¨",
      "å—ž",
      "å§•",
      "å§¿",
      "å­œ",
      "å­³",
      "å­¶",
      "å´°",
      "åµ«",
      "æ ¥",
      "æ¤”",
      "æ·„",
      "æ¹½",
      "æ»‹",
      "æ¾¬",
      "çŽ†",
      "ç¦Œ",
      "ç§¶",
      "ç²¢",
      "ç´Ž",
      "ç·‡",
      "ç·•",
      "çºƒ",
      "ç¼",
      "èŒŠ",
      "èŒ²",
      "è‘˜",
      "è«®",
      "è°˜",
      "è²²",
      "è³‡",
      "èµ€",
      "èµ„",
      "èµ¼",
      "è¶‘",
      "è¶¦",
      "è¼œ",
      "è¼º",
      "è¾Ž",
      "é„‘",
      "éˆ­",
      "éŒ™",
      "é¿",
      "éŽ¡",
      "é”±",
      "é•ƒ",
      "é ¾",
      "é ¿",
      "é«­",
      "é¯”",
      "é°¦",
      "é²»",
      "é¶…",
      "é¼’",
      "é½",
      "é½œ",
      "é¾‡"
    ],
    mÄ«: ["å’ª"],
    "jÄ« xÄ« qiÃ ": ["å’­"],
    "gÄ“ luÃ² kÇŽ lo": ["å’¯"],
    "shÃ¹ xÃºn": ["å’°"],
    "zÃ¡n zÃ¡ zÇŽ zan": ["å’±"],
    "hÄi kÃ©": ["å’³"],
    huÄ«: [
      "å’´",
      "å™…",
      "å™•",
      "å©Ž",
      "åªˆ",
      "å¹‘",
      "å¾½",
      "æ¢",
      "æ‹»",
      "æŒ¥",
      "æ®",
      "æ™–",
      "æš‰",
      "æ¥Ž",
      "æ´ƒ",
      "ç€ˆ",
      "ç°",
      "ç³",
      "çƒ£",
      "ç³",
      "ç¦ˆ",
      "ç¿š",
      "ç¿¬",
      "è˜³",
      "è¢†",
      "è¤˜",
      "è©¼",
      "è¯™",
      "è±—",
      "è¼",
      "è¾‰",
      "é°´",
      "éº¾",
      "ã§‘"
    ],
    "huÃ i shÃ¬": ["å’¶"],
    tÃ¡o: [
      "å’·",
      "å••",
      "æ¡ƒ",
      "æª®",
      "æ´®",
      "æ·˜",
      "ç¥¹",
      "ç¶¯",
      "ç»¹",
      "è„",
      "èœª",
      "è£ª",
      "è¿¯",
      "é€ƒ",
      "é†„",
      "é‹¾",
      "éž€",
      "éž‰",
      "é¥€",
      "é§£",
      "é¨Š",
      "é¼—",
      "ð«˜¦"
    ],
    xiÃ¡n: [
      "å’¸",
      "å•£",
      "å¨´",
      "å¨¹",
      "å©±",
      "å«Œ",
      "å«º",
      "å«»",
      "å¼¦",
      "æŒ¦",
      "æ’",
      "æ¶Ž",
      "æ¹º",
      "æ¾–",
      "ç”‰",
      "ç—«",
      "ç™‡",
      "ç™Ž",
      "çµƒ",
      "èƒ˜",
      "èˆ·",
      "è—–",
      "èš¿",
      "è›",
      "è¡”",
      "è¡˜",
      "èª¸",
      "è«´",
      "è³¢",
      "è´’",
      "è´¤",
      "è¼±",
      "é†Ž",
      "éŠœ",
      "é‘¦",
      "é–‘",
      "é—²",
      "é·³",
      "é·´",
      "é·¼",
      "é¹‡",
      "é¹¹",
      "éº™",
      "ð«¯"
    ],
    "Ã¨ Ã n": ["å’¹"],
    "xuÄn xuÇŽn": ["å’º", "çƒœ"],
    "wÄi hÃ© wÇ’ guÇŽ guÅ": ["å’¼"],
    "yÃ n yÃ¨ yÄn": ["å’½"],
    Äi: ["å“€", "å“Ž", "åŸƒ", "æº¾", "éŠ°", "éŽ„", "é”¿"],
    pÇn: ["å“", "æ¦€"],
    shÄ›n: [
      "å“‚",
      "å©¶",
      "å¬¸",
      "å®¡",
      "å®·",
      "å¯©",
      "å¼ž",
      "æ›‹",
      "æ¸–",
      "ç€‹",
      "çž«",
      "çŸ¤",
      "çŸ§",
      "è¦¾",
      "è¨ ",
      "è«—",
      "è®…",
      "è°‚",
      "è°‰",
      "é‚¥",
      "é £",
      "é­«"
    ],
    "hÇ’ng hÅng hÃ²ng": ["å“„"],
    "wÄ wa": ["å“‡"],
    "hÄ hÇŽ hÃ ": ["å“ˆ"],
    zÄi: ["å“‰", "æ ½", "æ¸½", "æº¨", "ç½", "ç¾", "çƒ–", "çµ", "è³³"],
    "dÃ¬ diÃ¨": ["å“‹"],
    pÃ i: ["å“Œ", "æ² ", "æ´¾", "æ¸’", "æ¹ƒ", "è’Ž", "éŽƒ"],
    "gÃ©n hÄ›n": ["å“"],
    "yÇŽ yÄ": ["å“‘", "é›…"],
    "yuÄ› huÃ¬": ["å“•", "å™¦"],
    niÃ¡n: ["å“–", "å¹´", "ç§Š", "ç§¥", "é®Ž", "é¯°", "é²‡", "é²¶", "éµ‡", "é»"],
    "huÃ¡ huÄ": ["å“—", "å˜©"],
    "jÃ¬ jiÄ“ zhÄi": ["å“œ", "åšŒ"],
    mÅu: ["å“ž"],
    "yÅ yo": ["å“Ÿ", "å–²"],
    lÃ²ng: ["å“¢", "æ¢‡", "è´š"],
    "Ã² Ã³ Ã©": ["å“¦"],
    "lÄ« lÇ li": ["å“©"],
    "nÇŽ na nÇŽi nÃ© nÄ›i": ["å“ª"],
    hÃ¨: [
      "å“¬",
      "åžŽ",
      "å£‘",
      "å¯‰",
      "æƒ’",
      "ç„ƒ",
      "ç…‚",
      "ç‡º",
      "çˆ€",
      "ç™‹",
      "ç¢‹",
      "ç¿¯",
      "è¤",
      "è¬ž",
      "è³€",
      "è´º",
      "èµ«",
      "é",
      "éŽ",
      "é",
      "é¶´",
      "é¸–",
      "é¹¤"
    ],
    "bÅ pÃ² bÄ": ["å“±"],
    zhÃ©: [
      "å“²",
      "å• ",
      "å–†",
      "åšž",
      "åŸ‘",
      "æ‚Š",
      "æ‘º",
      "æ™¢",
      "æ™£",
      "æ­½",
      "çŸº",
      "ç “",
      "ç£”",
      "ç±·",
      "ç²",
      "è™´",
      "è›°",
      "èŸ„",
      "è¢©",
      "è©Ÿ",
      "è¬«",
      "è¬º",
      "è®",
      "è®‹",
      "è°ª",
      "è¼’",
      "è¼™",
      "è½",
      "è¾„",
      "è¾™",
      "é®¿"
    ],
    "liÃ ng lÃ¡ng": ["å“´"],
    "liÃ¨ lÇœ": ["å“·"],
    hÄn: ["å“»", "æ†¨", "èš¶", "è°½", "é…£", "é ‡", "é¡¸", "é¦ ", "é­½", "é¼¾"],
    "hÄ“ng hng": ["å“¼"],
    gÄ›ng: [
      "å“½",
      "åŸ‚",
      "å³º",
      "æŒ­",
      "æ¢—",
      "ç¶†",
      "ç» ",
      "è€¿",
      "èŽ„",
      "éƒ ",
      "éª¾",
      "é¯",
      "é² ",
      "ð¬’”"
    ],
    "chuÃ² yuÃ¨": ["å“¾"],
    "gÄ› jiÄ": ["å“¿"],
    "bei bÃ i": ["å”„"],
    "hÃ¡n hÃ n": ["å”…"],
    chÃºn: [
      "å”‡",
      "æµ±",
      "æ¹»",
      "æ»£",
      "æ¼˜",
      "çŠ‰",
      "ç´”",
      "çº¯",
      "è„£",
      "èŽ¼",
      "è’“",
      "è“´",
      "é†‡",
      "é†•",
      "éŒž",
      "é™™",
      "é¯™",
      "é¶‰",
      "é¹‘",
      "ð¬­š"
    ],
    "Ã i Äi": ["å”‰"],
    "jiÃ¡ qiÇŽn": ["å”Š"],
    "yÃ¡n dÃ n xiÃ¡n": ["å”Œ"],
    chÄ“: ["å”“", "ç —", "ç¡¨", "èŽ—", "è›¼"],
    "wÃº Å„g Å„": ["å””"],
    zÃ o: [
      "å”•",
      "å”£",
      "å™ª",
      "æ…¥",
      "æ¢",
      "ç¶",
      "ç…°",
      "ç‡¥",
      "çš",
      "çš‚",
      "ç«ƒ",
      "ç«ˆ",
      "ç°‰",
      "è‰",
      "è­Ÿ",
      "è¶®",
      "èº",
      "é€ ",
      "ð¥–¨"
    ],
    dÃ­: [
      "å”™",
      "å•‡",
      "å˜€",
      "åš",
      "å«¡",
      "å»¸",
      "æ•Œ",
      "æ•µ",
      "æ¢‘",
      "æ¶¤",
      "æ»Œ",
      "ç‹„",
      "ç¬›",
      "ç±´",
      "ç³´",
      "è‹–",
      "è»",
      "è”‹",
      "è”",
      "è—¡",
      "è¦¿",
      "è§Œ",
      "è±´",
      "è¿ª",
      "é®",
      "é ”",
      "é¦°",
      "é«¢",
      "é¸",
      "ð¬±–"
    ],
    "gÃ²ng hÇ’ng gÇ’ng": ["å”", "å—Š"],
    dÃ³u: ["å”ž"],
    "lÃ o lÃ¡o": ["å” ", "å˜®", "æ†¦"],
    huÃ n: [
      "å”¤",
      "å–š",
      "å¥‚",
      "å¥",
      "å®¦",
      "åµˆ",
      "å¹»",
      "æ‚£",
      "æ„Œ",
      "æ¢",
      "æ›",
      "æ“",
      "æ”Œ",
      "æ¢™",
      "æ§µ",
      "æµ£",
      "æ¶£",
      "æ¸™",
      "æ¼¶",
      "æ¾£",
      "çƒ‰",
      "ç„•",
      "ç…¥",
      "ç‘",
      "ç—ª",
      "ç˜“",
      "ç†",
      "è‚’",
      "è—§",
      "è±¢",
      "è½˜",
      "é€­",
      "é¯‡",
      "é¯¶",
      "é°€",
      "é²©"
    ],
    lÃ©ng: ["å”¥", "å¡„", "æ¥ž", "ç¢", "è–"],
    "wÅ wÄ›i": ["å”©"],
    fÄ›ng: ["å”ª", "è¦‚", "è«·", "è®½"],
    "yÃ­n jÃ¬n": ["å”«"],
    "hÇ” xiÃ ": ["å”¬"],
    wÃ©i: [
      "å”¯",
      "å›´",
      "åœ",
      "å£",
      "å³—",
      "å³ž",
      "åµ¬",
      "å¸",
      "å¸·",
      "å¹ƒ",
      "æƒŸ",
      "æ¡…",
      "æ²©",
      "æ´ˆ",
      "æ¶ ",
      "æ¹‹",
      "æºˆ",
      "æ½",
      "æ½™",
      "æ½¿",
      "æ¿°",
      "çŠ©",
      "çŸ€",
      "ç¶­",
      "ç»´",
      "è“¶",
      "è¦¹",
      "è¿",
      "é•",
      "é„¬",
      "é†€",
      "é",
      "é—ˆ",
      "é—±",
      "éŸ‹",
      "éŸ¦",
      "é® ",
      "ð£²—",
      "ð¬¶"
    ],
    shuÄ: ["å”°"],
    chÃ ng: ["å”±", "æ€…", "æ‚µ", "æš¢", "ç„»", "ç•…", "ç•¼", "èª¯", "éŸ”", "é¬¯"],
    "Ã©r wÄ": ["å”²"],
    qiÃ ng: ["å”´", "ç‚", "ç†—", "ç¾»"],
    yÅ: ["å”·"],
    yÅ«: ["å”¹", "æ·¤", "ç˜€", "ç›“", "ç®Š", "ç´†", "çº¡", "è¾¼", "è¿‚", "è¿ƒ", "é™“"],
    lÃ i: [
      "å”»",
      "æ¿‘",
      "ç€¨",
      "ç€¬",
      "ç™ž",
      "ç™©",
      "ç",
      "çž",
      "ç±",
      "ç±Ÿ",
      "è—¾",
      "è³š",
      "è³´",
      "èµ‰",
      "èµ–",
      "é ¼",
      "é¡‚",
      "éµ£"
    ],
    tuÃ²: ["å”¾", "å¶ž", "æŸ", "æ¯¤", "æ¯»", "ç®¨", "ç±œ", "èš", "è˜€", "è·…"],
    "zhÅu zhÄo tiÃ o": ["å•"],
    kÄ›n: ["å•ƒ", "åž¦", "å¢¾", "æ³", "æ‡‡", "è‚Ž", "è‚¯", "è‚»", "è±¤", "éŒ¹"],
    "zhuÃ³ zhÃ o": ["å•…", "æ¿¯"],
    "hÄ“ng hÃ¨ng": ["å•ˆ", "æ‚™"],
    "lÃ­n lÃ¡n": ["å•‰"],
    "a Ä Ã¡ ÇŽ Ã ": ["å•Š"],
    qiÄng: [
      "å•Œ",
      "å—´",
      "å¶ˆ",
      "æˆ•",
      "æ‘¤",
      "æ–¨",
      "æžª",
      "æ§",
      "æº¬",
      "ç‰„",
      "çŒ",
      "ç‡",
      "ç¾Œ",
      "ç¾—",
      "è…”",
      "èœ£",
      "è¬’",
      "é˜",
      "é”–",
      "é”µ"
    ],
    "tÅ«n zhÅ«n xiÄng duÇ": ["å•"],
    wÃ¨n: ["å•", "å¦", "æ¾", "æµ", "ç’º", "é—®", "é¡"],
    "cuÃ¬ qi": ["å•"],
    "diÃ© shÃ  jiÃ© tÃ¬": ["å•‘"],
    "yuÄ“ wÄ": ["å•˜"],
    "zÇ cÇ": ["å•™"],
    "bÇ tÃº": ["å•š"],
    "chuÃ² chuÃ i": ["å•œ"],
    "yÇŽ yÄ Ã¨": ["å•ž"],
    fÄ“i: [
      "å•¡",
      "å©“",
      "å©”",
      "æ‰‰",
      "æšƒ",
      "æ¸„",
      "çŒ†",
      "ç·‹",
      "ç»¯",
      "è£¶",
      "éœ",
      "éž",
      "éŸ",
      "é£›",
      "é£",
      "é£ž",
      "é¤¥",
      "é¦¡",
      "é¨‘",
      "é¨›",
      "é¯¡",
      "é²±",
      "ð¬´‚"
    ],
    pÃ­: [
      "å•¤",
      "å£€",
      "æž‡",
      "æ¯—",
      "æ¯˜",
      "ç„·",
      "çµ",
      "ç–²",
      "çš®",
      "ç¯º",
      "ç½´",
      "ç¾†",
      "è„¾",
      "è…—",
      "è†",
      "èš",
      "èš½",
      "èœ±",
      "èž·",
      "è ¯",
      "è±¼",
      "è²”",
      "éƒ«",
      "éˆ¹",
      "é˜°",
      "é™´",
      "éš¦",
      "é­®",
      "é®",
      "é²",
      "éµ§",
      "é¼™"
    ],
    shÃ¡: ["å•¥"],
    "lÄ la": ["å•¦"],
    "yÄ«ng qÃ­ng": ["å•¨"],
    pÄ: ["å•ª", "å¦‘", "èˆ¥", "è‘©", "è¶´"],
    "zhÄ› shÃ¬": ["å•«"],
    sÃ¨: [
      "å•¬",
      "å—‡",
      "æ‡Ž",
      "æ“Œ",
      "æ œ",
      "æ­®",
      "æ¶©",
      "æ¸‹",
      "æ¾€",
      "æ¾",
      "æ¿‡",
      "æ¿",
      "ç€’",
      "ç‘Ÿ",
      "ç’±",
      "ç˜·",
      "ç©‘",
      "ç©¡",
      "ç©¯",
      "ç¹¬",
      "è­…",
      "è½–",
      "éŠ«",
      "é¼",
      "é“¯",
      "é£‹"
    ],
    niÃ¨: [
      "å•®",
      "å—«",
      "å™›",
      "åš™",
      "å›",
      "å›“",
      "åœ¼",
      "å­¼",
      "å­½",
      "åµ²",
      "å¶­",
      "å·•",
      "å¸‡",
      "æ•œ",
      "æž¿",
      "æ§·",
      "æ«±",
      "æ¶…",
      "æ¹¼",
      "ç—†",
      "ç¯ž",
      "ç±‹",
      "ç³±",
      "ç³µ",
      "è‚",
      "è¶",
      "è‡¬",
      "è‡²",
      "è˜–",
      "è ¥",
      "è®˜",
      "è¸‚",
      "è¸—",
      "è¸™",
      "è¹‘",
      "èº¡",
      "éŒœ",
      "éŽ³",
      "é‘ˆ",
      "é‘·",
      "é’€",
      "é•Š",
      "é•",
      "é—‘",
      "é™§",
      "éš‰",
      "é¡³",
      "é¢ž",
      "é½§",
      "ð«”¶"
    ],
    "luÅ luÃ³ luo": ["å•°", "å›‰"],
    "tÄn chÇŽn tuÅ": ["å•´"],
    bo: ["å•µ", "è””"],
    dÃ¬ng: [
      "å•¶",
      "å®š",
      "æ¤—",
      "çŸ´",
      "ç¢‡",
      "ç¢ ",
      "ç£¸",
      "è¢",
      "è…š",
      "è£",
      "èŠ",
      "è¨‚",
      "è®¢",
      "éŒ ",
      "é”­",
      "é¡",
      "é££",
      "é¥¤"
    ],
    lÄng: ["å•·"],
    "Ã¡n Än": ["å•½"],
    kÄ: ["å–€", "æ“–"],
    "yÃ³ng yÃº": ["å–"],
    "lÄ lÃ¡ lÇŽ": ["å–‡"],
    jiÄ“: [
      "å–ˆ",
      "å–¼",
      "å—Ÿ",
      "å ¦",
      "åª˜",
      "æŽ¥",
      "æŽ²",
      "æ“‘",
      "æ¹",
      "ç…¯",
      "ç––",
      "ç—Ž",
      "ç™¤",
      "çš†",
      "ç§¸",
      "ç¨­",
      "è„»",
      "è”",
      "è¡—",
      "è¬¯",
      "é˜¶",
      "éšŽ",
      "éž‚",
      "é¶›"
    ],
    hÃ³u: [
      "å–‰",
      "å¸¿",
      "çŒ´",
      "ç˜Š",
      "çº",
      "ç¯Œ",
      "ç³‡",
      "ç¿­",
      "è‘”",
      "é„‡",
      "é­",
      "é¤±",
      "éªº",
      "é¯¸",
      "ð¬­¤"
    ],
    "diÃ© zhÃ¡": ["å–‹"],
    wÄi: ["å–Ž", "æ­ª", "ç«µ"],
    "nuÃ² rÄ›": ["å–"],
    "xÃ¹ huÃ² guÃ³": ["å–"],
    zÃ¡n: ["å–’"],
    "wÅ Å": ["å–”"],
    hÃº: [
      "å––",
      "å˜",
      "å›«",
      "å£¶",
      "å£·",
      "å£º",
      "åª©",
      "å¼§",
      "æ°",
      "æ–›",
      "æ¥œ",
      "æ§²",
      "æ¹–",
      "ç€«",
      "ç„€",
      "ç…³",
      "ç‹",
      "çŒ¢",
      "ç‘š",
      "ç“³",
      "ç®¶",
      "çµ—",
      "ç¸ ",
      "èƒ¡",
      "è‘«",
      "è”›",
      "è´",
      "èžœ",
      "è¡š",
      "è§³",
      "é†",
      "é¸",
      "é ¶",
      "é¤¬",
      "é¬",
      "é­±",
      "é°—",
      "éµ ",
      "é¶˜",
      "é¶¦",
      "é¹•"
    ],
    "huÃ n yuÃ¡n xuÇŽn hÃ©": ["å–›"],
    xÇ: [
      "å–œ",
      "å›",
      "å£",
      "å±£",
      "å¾™",
      "æ†™",
      "æž²",
      "æ©²",
      "æ­–",
      "æ¼‡",
      "çŽº",
      "ç’½",
      "çŸ–",
      "ç¦§",
      "ç¸°",
      "è‘ˆ",
      "è‘¸",
      "è“°",
      "èŸ¢",
      "è¬‘",
      "è¹",
      "èº§",
      "éˆ¢",
      "é‰¨",
      "é‰©",
      "é±š",
      "ð¬­³",
      "ð¬¶®"
    ],
    "hÄ“ hÃ¨ yÃ¨": ["å–"],
    kuÃ¬: [
      "å–Ÿ",
      "å˜³",
      "åª¿",
      "å¬‡",
      "æ„¦",
      "æ„§",
      "æ†’",
      "ç¯‘",
      "ç°£",
      "ç±„",
      "è©",
      "è­",
      "èµ",
      "è†­",
      "è•¢",
      "è¬‰",
      "é¤½",
      "é¥‹",
      "é¦ˆ"
    ],
    "zhÇ’ng chuÃ¡ng": ["å– "],
    "wÃ©i wÃ¨i": ["å–¡", "ç‚º", "çˆ²"],
    "duÃ³ zhÃ ": ["å–¥"],
    "sÄng sÃ ng": ["å–ª"],
    "qiÃ¡o jiÄo": ["å–¬"],
    "pÃ¨n bÄ“n": ["å–¯"],
    "cÄn sÅ«n qÄ«": ["å–°"],
    "zhÄ chÄ": ["å–³"],
    miÄo: ["å–µ"],
    "pÄ“n pÃ¨n": ["å–·"],
    kuÃ­: [
      "å–¹",
      "å¤”",
      "å¥Ž",
      "å·™",
      "æˆ£",
      "æ†",
      "æ™†",
      "æšŒ",
      "æ¥",
      "æ¥‘",
      "æ«†",
      "çŠª",
      "ç½",
      "è‘µ",
      "è—ˆ",
      "è˜·",
      "è™",
      "è°",
      "èº¨",
      "é€µ",
      "é„ˆ",
      "é¨",
      "é·",
      "é ¯",
      "é¦—",
      "é¨¤",
      "éª™",
      "é­"
    ],
    "lou lÃ³u": ["å–½"],
    "zÃ o qiÄo": ["å–¿"],
    "hÃ¨ xiÄo xiÃ o hÃ¹": ["å—ƒ"],
    "Ã¡ shÃ ": ["å—„"],
    xiÃ¹: [
      "å—…",
      "å²«",
      "å³€",
      "æº´",
      "ç›",
      "ç‡",
      "ç’“",
      "ç§€",
      "ç¶‰",
      "ç¹",
      "ç¹¡",
      "ç»£",
      "èž‘",
      "è¢–",
      "è¤Ž",
      "è¤",
      "éŠ¹",
      "é¥",
      "é½",
      "é”ˆ",
      "é½…"
    ],
    "qiÄng qiÃ ng": ["å—†", "æˆ—", "æˆ§", "è¹Œ", "è¹¡"],
    "Ã i yÃ¬": ["å—Œ", "è‰¾"],
    "mÃ¡ mÇŽ ma": ["å—Ž"],
    "kÃ¨ kÄ“": ["å—‘"],
    "dÄ tÃ ": ["å—’", "éŽ‰"],
    sÇŽng: ["å—“", "æ¡", "ç£‰", "è¤¬", "éŽŸ", "é¡™", "é¢¡"],
    chÄ“n: ["å—”", "æŠ»", "ç›", "çž‹", "è«ƒ", "è¬“", "è³", "éƒ´", "ð¬˜­"],
    "wÄ gÇ”": ["å——"],
    "pÇŽng bÄ“ng": ["å—™"],
    "xiÃ¡n qiÇŽn qiÄn": ["å—›"],
    lÃ o: ["å— ", "å«ª", "æ©¯", "æ¶", "æ¾‡", "è€¢", "è€®", "èº¼", "è»‚", "é…ª"],
    wÄ“ng: ["å—¡", "ç¿", "è¬", "èž‰", "éŽ“", "é¶²", "é¹Ÿ", "ð¬­©"],
    wÃ : ["å—¢", "è…½", "è†ƒ", "è¢œ", "è¥ª", "éŸ¤"],
    "hÄ“i hÄi": ["å—¨"],
    hÄ“: ["å—¬", "æ¬±", "è š", "è¨¶", "è¯ƒ"],
    zi: ["å—­"],
    sÇŽi: ["å—®"],
    "Ç¹g Å„g Åˆg": ["å—¯"],
    gÄ›: ["å—°", "èˆ¸"],
    nÃ¡: ["å—±", "æ‹", "æ‹¿", "éŽ¿", "é•Ž"],
    diÇŽ: ["å—²"],
    "Ã i ÇŽi Äi": ["å—³"],
    tÅng: ["å—µ", "æ¨‹", "ç‚µ", "è“ª"],
    "zuÄ« suÄ«": ["å—º"],
    "zhÄ“ zhÃ¨ zhÃ¹ zhe": ["å—»"],
    mÃ²: [
      "å—¼",
      "åœ½",
      "å¡»",
      "å¢¨",
      "å¦º",
      "å«¼",
      "å¯ž",
      "å¸ž",
      "æ˜©",
      "æœ«",
      "æžº",
      "æ­¿",
      "æ®",
      "æ²«",
      "æ¼ ",
      "çˆ…",
      "ç",
      "ç˜¼",
      "çšŒ",
      "çœ½",
      "çœ¿",
      "çž",
      "çž™",
      "ç ž",
      "ç¤³",
      "ç§£",
      "çµˆ",
      "çº†",
      "è€±",
      "èŒ‰",
      "èŽˆ",
      "è“¦",
      "è›¨",
      "èŸ”",
      "è²ƒ",
      "è²Š",
      "è²˜",
      "éŠ†",
      "éŒ",
      "é•†",
      "é™Œ",
      "éº",
      "é©€",
      "é­©",
      "é»˜",
      "é»™",
      "ð¬™Š"
    ],
    sÃ²u: ["å—½", "ç˜¶"],
    tÇŽn: [
      "å—¿",
      "å¦",
      "å¿",
      "æ†³",
      "æ†»",
      "æšº",
      "æ¯¯",
      "ç’®",
      "è¼",
      "è¢’",
      "è¥¢",
      "é†“",
      "é‰­",
      "é’½"
    ],
    "jiÃ o dÇŽo": ["å˜„"],
    "kÇŽi gÄ›": ["å˜…"],
    "shÄn cÃ n": ["å˜‡"],
    cÃ¡o: ["å˜ˆ", "å¶†", "æ›¹", "æ›º", "æ§½", "æ¼•", "è‰š", "è“¸", "èž¬", "è¤¿", "éª", "ð¥•¢"],
    piÃ o: ["å˜Œ", "å¾±", "è”ˆ", "é©ƒ"],
    "lÃ³u lou": ["å˜"],
    gÇŽ: ["å°•", "çŽ"],
    "gÇ” jiÇŽ": ["å˜"],
    "jiÄo xiÄo": ["å˜"],
    "xÅ« shÄ«": ["å˜˜", "å™“"],
    pÃ³: ["å˜™", "åš©", "å©†", "æ«‡", "çš¤", "é„±"],
    "dÄ“ dÄ“i": ["å˜š"],
    "ma mÃ¡": ["å˜›"],
    "lÄ“ lei": ["å˜ž"],
    "gÄ gÃ¡ gÇŽ": ["å˜ "],
    sÄi: ["å˜¥", "å™»", "æ¯¢", "è…®", "é¡‹", "é°“"],
    "zuÅ chuÃ i": ["å˜¬"],
    "chÃ¡o zhÄo": ["å˜²", "æœ", "é¼‚"],
    zuÇ: ["å˜´", "å™¿", "å¶Š", "ç’»"],
    "qiÃ¡o qiÃ o": ["å˜º", "ç¿¹", "è°¯"],
    "chÃ¹ xÃ¹ shÃ²u": ["å˜¼"],
    "tÄn chÇŽn": ["å˜½"],
    "dÃ n tÃ¡n": ["å˜¾", "å¼¾", "å½ˆ", "æƒ”", "æ¾¹"],
    "hÄ“i mÃ²": ["å˜¿"],
    Ä›: ["å™", "ç ¨", "é ‹", "é¨€", "éµˆ"],
    "fÄn bo": ["å™ƒ"],
    chuÃ¡ng: ["å™‡", "åºŠ", "ç‰€"],
    "cÃ¹ zÄ hÃ©": ["å™ˆ"],
    "tÅ«n kuÃ²": ["å™‹"],
    "cÄ“ng chÄ“ng": ["å™Œ"],
    dÄ“ng: ["å™”", "å¬", "ç¯", "ç‡ˆ", "ç’’", "ç™»", "ç«³", "ç°¦", "è‰ ", "è±‹"],
    pÅ«: ["å™—", "æ‰‘", "æ’²", "æ”´", "æ”µ", "æ½½", "ç‚‡", "é™ "],
    juÄ“: ["å™˜", "å±©", "å±«", "æ’§"],
    lÅ«: ["å™œ", "åš•", "æ’¸", "æ“¼", "è¬¢"],
    zhÄn: [
      "å™¡",
      "å²¾",
      "æƒ‰",
      "æ—ƒ",
      "æ—œ",
      "æž¬",
      "æ ´",
      "æ¯¡",
      "æ°ˆ",
      "æ°Š",
      "æ²¾",
      "çž»",
      "è–",
      "è›…",
      "è©€",
      "è©¹",
      "è­«",
      "è°µ",
      "è¶ˆ",
      "é‚…",
      "é–š",
      "éœ‘",
      "é£¦",
      "é¥˜",
      "é©™",
      "é­™",
      "é±£",
      "é¸‡",
      "é¹¯",
      "ð«—´"
    ],
    Å: ["å™¢"],
    "zhÃ²u zhuÃ³": ["å™£"],
    "jiÃ o qiÃ o chÄ«": ["å™­"],
    yuÃ n: [
      "å™®",
      "å¦´",
      "æ€¨",
      "æ„¿",
      "æŽ¾",
      "ç‘—",
      "ç¦",
      "è‹‘",
      "è¡",
      "è£«",
      "è¤‘",
      "é™¢",
      "é¡˜"
    ],
    "ÇŽi Ã i Äi": ["å™¯"],
    "yÅng yÇ’ng": ["å™°", "æ¾­"],
    "juÃ© xuÃ©": ["å™±"],
    "pÄ“n pÃ¨n fÃ¨n": ["å™´"],
    gÃ¡: ["å™¶", "å°œ", "é‡“", "éŒ·", "é’†"],
    "xÄ«n hÄ›n hÃ¨n": ["å™·"],
    dÄng: ["å™¹", "æ¾¢", "ç°", "ç’«", "ç­œ", "ç°¹", "è‰¡", "èŸ·", "è£†", "è¥ "],
    lÃ n: ["åš‚", "æ»¥", "æ¿«", "çƒ‚", "ç‡—", "çˆ", "çˆ›", "çˆ¤", "ç““", "ç³·", "é’„"],
    tÃ : [
      "åšƒ",
      "åšº",
      "å´‰",
      "æŒž",
      "æ¨",
      "æ’»",
      "æ¦»",
      "æ©½",
      "æ¯¾",
      "æ¶¾",
      "æ¾¾",
      "æ¿Œ",
      "ç¦¢",
      "ç²",
      "èª»",
      "è­¶",
      "è¹‹",
      "è¹¹",
      "èº‚",
      "èº¢",
      "é",
      "éŒ”",
      "é—’",
      "é—¥",
      "é—¼",
      "é˜˜",
      "éžœ",
      "éž³"
    ],
    "huÅ huÃ² Ç’": ["åš„"],
    hÄo: ["åš†", "èŒ ", "è’¿", "è–…"],
    "hÃ¨ xiÃ ": ["åš‡"],
    "xiÃ¹ pÃ¬": ["åšŠ"],
    "zhÅu chÃ³u": ["åš‹", "ç›©", "è¯ª"],
    mÄ“: ["åš’"],
    "chÄ cÄ": ["åš“"],
    "bÃ³ pÃ o bÃ o": ["åš—"],
    "me mÃ¨i mÃ²": ["åšœ"],
    "xiÃ© hÃ¡i": ["åš¡"],
    "Ã¡o xiÄo": ["åš£"],
    mÅ: ["åš¤", "æ‘¸"],
    pÃ­n: [
      "åš¬",
      "å¨¦",
      "å«”",
      "å¬ª",
      "çŽ­",
      "çŸ‰",
      "è–²",
      "è ™",
      "è²§",
      "è´«",
      "é¡°",
      "é¢¦",
      "ð¬žŸ"
    ],
    mÃ¨: ["åš°", "æ¿¹"],
    "rÇŽng rÄng": ["åš·"],
    lÃ¡: ["åš¹", "æ—¯"],
    "jiÃ¡o juÃ© jiÃ o": ["åš¼"],
    chuÃ²: [
      "åš½",
      "å¨–",
      "æ“‰",
      "æ­ ",
      "æ¶°",
      "ç£­",
      "è¸€",
      "è¼Ÿ",
      "è¾",
      "è¾µ",
      "è¾¶",
      "é…«",
      "é‘¡",
      "é¤Ÿ",
      "é½ª",
      "é¾Š"
    ],
    "huÄn huÃ n": ["åš¾"],
    "zÃ¡ cÃ ": ["å›ƒ"],
    chÃ i: ["å›†", "è™¿", "è †", "è¢ƒ", "è¨"],
    "nÃ¡ng nÄng": ["å›Š"],
    "zÃ¡ zÃ n cÄn": ["å›‹"],
    sÅ«: ["å›Œ", "æ«¯", "ç”¦", "ç¨£", "ç©Œ", "çª£", "è˜‡", "è˜“", "é…¥", "é¯‚"],
    zÃ¨ng: ["å›Ž", "ç†·", "ç”‘", "è´ˆ", "èµ ", "é‹¥", "é”ƒ"],
    "zÃ¡ niÃ¨ yÃ n": ["å›"],
    nÄng: ["å›”"],
    "luÃ³ luÅ luo": ["å›–"],
    "wÃ©i guÃ³": ["å›—"],
    huÃ­: [
      "å›˜",
      "å›ž",
      "å›¬",
      "å»»",
      "å»½",
      "æ›",
      "æ´„",
      "ç—",
      "èŒ´",
      "èš˜",
      "è›”",
      "è›•",
      "èœ–",
      "è¿´",
      "é€¥",
      "é®°"
    ],
    nÃ­n: ["å›œ", "æ‚¨", "è„Œ"],
    "jiÇŽn nÄn": ["å›"],
    nÄn: ["å›¡"],
    tuÃ¡n: ["å›¢", "å›£", "åœ˜", "æ…±", "æŠŸ", "æ‘¶", "æª²", "ç³°", "é„", "é·’", "é·»"],
    "tÃºn dÃ¹n": ["å›¤", "å‰"],
    guÃ³: [
      "å›¯",
      "å›¶",
      "å›»",
      "å›½",
      "åœ€",
      "åœ‹",
      "å¸¼",
      "å¹—",
      "æ…–",
      "æ‘‘",
      "æ¼",
      "è",
      "è…˜",
      "è†•",
      "è”®",
      "è™¢",
      "é¦˜",
      "ð¬‡¹"
    ],
    kÃ¹n: ["å›°", "æ¶ƒ", "ç"],
    "wÃ©i tÅng": ["å›²"],
    qÅ«n: ["å›·", "å¤‹", "é€¡"],
    rÃ¬: ["å›¸", "æ—¥", "è¡µ", "éˆ¤", "é¦¹", "é©²"],
    tÄi: ["å›¼", "å­¡", "èƒŽ"],
    pÇ”: [
      "åœƒ",
      "åœ‘",
      "æ“ˆ",
      "æ™®",
      "æšœ",
      "æ¨¸",
      "æª",
      "æ°†",
      "æµ¦",
      "æº¥",
      "çƒ³",
      "è«©",
      "è­œ",
      "è°±",
      "è¹¼",
      "é ",
      "é•¨"
    ],
    "quÄn juÃ n juÄn": ["åœˆ", "åœ"],
    "chuÃ­ chuÃ¡n": ["åœŒ"],
    tuÇŽn: ["åœ•", "ç•½", "ç–ƒ"],
    lÃ¼Ã¨: ["åœ™", "æŽ ", "ç•¥", "ç•§", "ç¨¤", "é‹", "é‹¢", "é”Š", "ä‚®"],
    "huÃ¡n yuÃ¡n": ["åœœ"],
    luÃ¡n: [
      "åœ",
      "åœž",
      "å¥±",
      "å¨ˆ",
      "å­Œ",
      "å­ª",
      "å­¿",
      "å³¦",
      "å·’",
      "æŒ›",
      "æ”£",
      "æ›«",
      "æ ¾",
      "æ¬’",
      "æ»¦",
      "ç¤",
      "ç™´",
      "ç™µ",
      "ç¾‰",
      "è„”",
      "è‡ ",
      "è™Š",
      "éŠ®",
      "é‘¾",
      "éµ‰",
      "é¸ž",
      "é¸¾"
    ],
    tÇ”: ["åœŸ", "åœ¡", "é‡·", "é’"],
    "xÅ« wÃ©i": ["åœ©"],
    "dÃ¬ de": ["åœ°", "å¶³"],
    "qiÄn sÃº": ["åœ±"],
    zhÃ¨n: [
      "åœ³",
      "å¡¦",
      "æŒ‹",
      "æŒ¯",
      "æœ•",
      "æ š",
      "ç”½",
      "çœ¹",
      "ç´–",
      "çµ¼",
      "çº¼",
      "èª«",
      "è³‘",
      "èµˆ",
      "é‹´",
      "éŽ­",
      "éŽ®",
      "é•‡",
      "é˜µ",
      "é™£",
      "éœ‡",
      "é´†",
      "é¸©"
    ],
    "chÇŽng chÃ¡ng": ["åœº", "å ´", "å¡²"],
    "qÃ­ yÃ­n": ["åœ»"],
    jiÃ¡: [
      "åœ¿",
      "å¿¦",
      "æ",
      "æˆž",
      "æ‰´",
      "è„¥",
      "èš",
      "èŽ¢",
      "è›±",
      "è›º",
      "è£Œ",
      "è·²",
      "éƒ",
      "éƒŸ",
      "é‹",
      "é“—",
      "é ¬",
      "é °",
      "é¢Š",
      "é´¶",
      "éµŠ"
    ],
    "zhÇ zhÃ¬": ["å"],
    bÇŽn: [
      "å‚",
      "å²…",
      "æ˜„",
      "æ¿",
      "ç‰ˆ",
      "ç“ª",
      "ç²„",
      "èˆ¨",
      "è‚",
      "éˆ‘",
      "é’£",
      "é˜ª",
      "é­¬"
    ],
    qÇn: ["å…", "å¯‘", "å¯", "å¯¢", "æ˜‘", "æ¢«", "ç¬‰", "èž¼", "èµ¾", "é‹Ÿ", "é”“"],
    "mÃ©i fÃ©n": ["å†"],
    "rÇ’ng kÄ“ng": ["åˆ"],
    "fÄng fÃ¡ng": ["åŠ"],
    "fÃ¨n bÃ¨n": ["å‹"],
    tÄn: ["å", "æ€¹", "æ‘Š", "æ“¹", "æ”¤", "æ»©", "ç˜", "ç˜«", "ç™±", "èˆ‘", "è²ª", "è´ª"],
    "huÃ i pÄ“i pÄ« pÃ©i": ["å"],
    "dÃ¬ lÃ n": ["å”"],
    tÃ¡n: [
      "å›",
      "å¢°",
      "å¢µ",
      "å£‡",
      "å£œ",
      "å©’",
      "æ†›",
      "æ˜™",
      "æ›‡",
      "æ¦ƒ",
      "æª€",
      "æ½­",
      "ç‡‚",
      "ç—°",
      "ç£¹",
      "ç½ˆ",
      "ç½Ž",
      "è—«",
      "è«‡",
      "è­š",
      "è­ ",
      "è°ˆ",
      "è°­",
      "è²š",
      "éƒ¯",
      "é†°",
      "éŒŸ",
      "é¡ƒ"
    ],
    bÃ : ["å", "åž»", "å£©", "å¼", "æ¬›", "çž", "çˆ¸", "çŸ²", "è¦‡", "éœ¸", "é®", "é²…"],
    fÃ©n: [
      "åŸ",
      "å¢³",
      "å¦¢",
      "å²Ž",
      "å¹©",
      "æžŒ",
      "æ£¼",
      "æ±¾",
      "ç„š",
      "ç‡Œ",
      "ç‡“",
      "ç¾’",
      "ç¾µ",
      "è’¶",
      "è•¡",
      "èš ",
      "èš¡",
      "è±®",
      "è±¶",
      "è½’",
      "é¼",
      "éš«",
      "é¦©",
      "é­µ",
      "é»‚",
      "é¼–",
      "é¼¢",
      "ð£¸£"
    ],
    zhuÃ¬: [
      "å ",
      "å¢œ",
      "æƒ´",
      "ç”€",
      "ç•·",
      "ç¤ˆ",
      "ç¶´",
      "ç¸‹",
      "ç¼€",
      "ç¼’",
      "è…",
      "è†‡",
      "è«ˆ",
      "è´…",
      "èµ˜",
      "é†Š",
      "éŒ£",
      "é‘†"
    ],
    pÅ: ["å¡", "å²¥", "æ³¼", "æºŒ", "æ½‘", "é‡™", "éº", "é’‹", "é —", "é¢‡", "ä¥½"],
    "pÇŽn bÃ n": ["å¢"],
    kÅ«n: [
      "å¤",
      "å ƒ",
      "å ’",
      "å´",
      "å´‘",
      "æ˜†",
      "æ™œ",
      "æ½‰",
      "ç„œ",
      "ç†´",
      "çŒ‘",
      "ç¨",
      "ç‘»",
      "èŽ",
      "èœ«",
      "è£ˆ",
      "è£©",
      "è¤Œ",
      "é†Œ",
      "éŒ•",
      "é”Ÿ",
      "é¨‰",
      "é« ",
      "é«¡",
      "é«¨",
      "é¯¤",
      "é²²",
      "éµ¾",
      "é¶¤",
      "é¹"
    ],
    diÃ n: [
      "å«",
      "åž«",
      "å¢Š",
      "å£‚",
      "å¥ ",
      "å©",
      "åº—",
      "æƒ¦",
      "æ‰‚",
      "æ©‚",
      "æ®¿",
      "æ·€",
      "æ¾±",
      "çŽ·",
      "ç”",
      "ç”µ",
      "ç™œ",
      "ç°Ÿ",
      "èœ”",
      "éˆ¿",
      "é›»",
      "é›",
      "é©”"
    ],
    "mÃ¹ mÇ”": ["å¶"],
    "kÄ“ kÄ›": ["å·", "è»»"],
    xuÃ¨: ["å¹", "å²¤", "æ¡–", "ç€¥", "ç‹˜", "çž²", "è¬”", "è°‘", "è¶"],
    "dÇ chÃ­": ["å»", "æŸ¢"],
    lÄ: ["åžƒ", "æŸ†", "èˆ", "é‚‹"],
    lÇ’ng: ["åž„", "åž…", "å£Ÿ", "å£ ", "æ‹¢", "æ”", "ç«‰", "é™‡", "éš´", "ð¬•‚"],
    mÃ­n: [
      "åžŠ",
      "å§„",
      "å²·",
      "å´",
      "æª",
      "æ—»",
      "æ—¼",
      "æ°‘",
      "ç‰",
      "ç˜",
      "ç",
      "ç‘‰",
      "ç—»",
      "ç›¿",
      "ç ‡",
      "ç·",
      "ç·¡",
      "ç¼—",
      "ç½ ",
      "è‹ ",
      "éˆ±",
      "éŒ‰",
      "é²",
      "é´–"
    ],
    "dÃ²ng tÃ³ng": ["åžŒ", "å³’", "æ´ž"],
    cÃ­: [
      "åž",
      "å¬¨",
      "æ…ˆ",
      "æŸŒ",
      "æ¿¨",
      "ç",
      "ç“·",
      "ç”†",
      "ç£",
      "ç¤ ",
      "ç¥ ",
      "ç³",
      "èŒ¨",
      "è©ž",
      "è¯",
      "è¾",
      "è¾ž",
      "è¾¤",
      "è¾­",
      "é›Œ",
      "é£º",
      "é¤ˆ",
      "é´œ",
      "é¶¿",
      "é·€",
      "é¹š"
    ],
    duÄ«: ["åž–", "å †", "å¡ ", "ç—½", "ç£“", "é“", "éœ", "é´­"],
    "duÃ² duÇ’": ["åž›"],
    "duÇ’ duÃ²": ["åžœ", "æŒ†"],
    chÃ¡: ["åžž", "å¯Ÿ", "åµ–", "æ½", "æ§Ž", "æª«", "çŒ¹", "èŒ¬", "èŒ¶", "è©§", "é«", "ð¥»—"],
    shÇŽng: ["åž§", "æ™Œ", "æ¨‰", "è³ž", "è´˜", "èµ", "é‹¿", "é›", "é‘œ"],
    shÇ’u: ["åž¨", "å®ˆ", "æ‰‹", "æ‰Œ", "è‰", "é¦–"],
    da: ["åž¯", "ç¹¨", "è·¶"],
    hÃ¡ng: [
      "åž³",
      "æ–»",
      "æ­",
      "ç­•",
      "çµŽ",
      "ç»—",
      "èˆª",
      "è‹€",
      "èš¢",
      "è£„",
      "è²¥",
      "è¿’",
      "é ",
      "é¢ƒ",
      "é­§"
    ],
    "Än ÇŽn": ["åžµ"],
    xÄ«ng: [
      "åž¶",
      "æƒº",
      "æ˜Ÿ",
      "æ›",
      "ç…‹",
      "çŒ©",
      "ç‘†",
      "çš¨",
      "ç¯‚",
      "è…¥",
      "èˆˆ",
      "è§ª",
      "è§²",
      "è¬ƒ",
      "é¨‚",
      "éª",
      "é®",
      "é¯¹"
    ],
    "yuÃ n huÃ¡n": ["åž¸"],
    bÄng: [
      "åž¹",
      "å¸®",
      "å¹‡",
      "å¹š",
      "å¹«",
      "æ ",
      "æ¢†",
      "æµœ",
      "é‚¦",
      "é‚«",
      "éž¤",
      "ð ³"
    ],
    "pÃ³u fÃº": ["åžº"],
    cÃ©n: ["åŸ", "å²‘", "æ¶”"],
    "bÄ›ng fÄ“ng": ["åŸ„"],
    "dÃ¬ fÃ¡ng": ["åŸ…"],
    "xiÃ¡ jiÄ": ["åŸ‰"],
    "mÃ¡i mÃ¡n": ["åŸ‹"],
    lÃ ng: ["åŸŒ", "å´€", "æµª", "è’—", "é–¬", "ã«°"],
    "shÄn yÃ¡n": ["åŸ"],
    "qÃ­n jÄ«n": ["åŸ"],
    "pÇ” bÃ¹": ["åŸ”"],
    huÄ: ["åŸ–", "å©²", "æ¤›", "ç¡´", "ç³€", "èŠ±", "è’Š", "è˜¤", "èª®", "éŒµ"],
    "suÃ¬ sÃ¹": ["åŸ£"],
    "pÃ­ pÃ¬": ["åŸ¤"],
    "qÄ«ng zhÄ“ng": ["åŸ¥", "é²­"],
    "wÇŽn wÄn": ["åŸ¦"],
    lÇ”n: ["åŸ¨", "ç¨", "ð«­¢"],
    "zhÄ“ng chÃ©ng": ["åŸ©"],
    kÅng: ["åŸª", "å´†", "ç®œ", "èº»", "éŒ“", "éµ¼"],
    "cÇŽi cÃ i": ["åŸ°", "å¯€", "é‡‡"],
    "chÃ¹ tÃ²u": ["åŸ±"],
    bÄ›ng: ["åŸ²", "ç«", "è¶", "éž›"],
    "kÇŽn xiÃ n": ["åŸ³"],
    "yÃ¬ shÃ¬": ["åŸ¶", "é†³"],
    pÃ©i: ["åŸ¹", "æ¯°", "è£´", "è£µ", "è³ ", "èµ”", "éŒ‡", "é”«", "é˜«", "é™ª"],
    "sÃ o sÇŽo": ["åŸ½"],
    "jÇn qÄ«n jÃ¬n": ["å ‡"],
    "pÃ©ng bÃ¨ng": ["å ‹"],
    "qiÃ n zÃ n jiÃ n": ["å ‘"],
    Ã n: [
      "å “",
      "å±µ",
      "å²¸",
      "æŒ‰",
      "æš—",
      "æ¡ˆ",
      "èƒº",
      "èŒ",
      "è±»",
      "è²‹",
      "éŒŒ",
      "é—‡",
      "éšŒ",
      "é»¯"
    ],
    "duÃ² huÄ«": ["å •", "å¢®"],
    huÃ¡n: [
      "å š",
      "å¯",
      "å¯°",
      "å³˜",
      "æ¡“",
      "æ´¹",
      "æ¾´",
      "ç‚",
      "çŽ¯",
      "ç’°",
      "ç³«",
      "ç¹¯",
      "ç¼³",
      "ç¾¦",
      "è",
      "èˆ",
      "è‘",
      "è±²",
      "é°",
      "é¶",
      "é”¾",
      "é•®",
      "é—¤",
      "é˜›",
      "é›ˆ",
      "é¬Ÿ",
      "é¹®",
      "ð¬˜«",
      "ð¤©½"
    ],
    "bÇŽo bÇ” pÃ¹": ["å ¡"],
    "mÃ¡o mÃ³u wÇ”": ["å ¥"],
    ruÃ¡n: ["å §", "å£–", "æ’‹"],
    "Ã i Ã¨ yÃ¨": ["å ¨"],
    gÃ¨ng: ["å ©", "æš…"],
    mÃ©i: [
      "å ³",
      "å¡º",
      "åª’",
      "åµ‹",
      "å¾¾",
      "æ”—",
      "æžš",
      "æ ‚",
      "æ¢…",
      "æ¥£",
      "æ¥³",
      "æ§‘",
      "æ¹„",
      "æ¹ˆ",
      "ç…¤",
      "çŒ¸",
      "çŽ«",
      "ç»",
      "ç‘‚",
      "çœ‰",
      "ç‚",
      "ç¦–",
      "è„„",
      "è„¢",
      "è…œ",
      "è‹º",
      "èŽ“",
      "è‘¿",
      "éƒ¿",
      "é…¶",
      "éŽ‡",
      "é•…",
      "éœ‰",
      "é¶¥",
      "é¹›",
      "é»´"
    ],
    dÇ”: ["å µ", "ç½", "ç¹", "ç¬ƒ", "ç¯¤", "è¦©", "è³­", "èµŒ"],
    fÃ©ng: ["å ¸", "ç¶˜", "è‰‚", "é€¢"],
    hÃ¨ng: ["å ¼"],
    chÅ«n: [
      "å ¾",
      "åª‹",
      "æ—¾",
      "æ˜¥",
      "æš™",
      "æ¶",
      "æ¤¿",
      "æ§†",
      "æ©",
      "æ«„",
      "ç‘ƒ",
      "ç®º",
      "è…",
      "è½",
      "è¼´",
      "é°†",
      "é¶ž",
      "ä² "
    ],
    jiÇŽng: [
      "å¡‚",
      "å¥–",
      "å¥¨",
      "å¥¬",
      "æ¡¨",
      "æ§³",
      "çŽ",
      "è€©",
      "è†™",
      "è’‹",
      "è”£",
      "è¬›",
      "è®²",
      "é¡œ"
    ],
    huÄng: ["å¡ƒ", "å·Ÿ", "æ…Œ", "è‚“", "è’", "è¡"],
    duÃ n: [
      "å¡…",
      "æ–­",
      "æ–·",
      "æ¤´",
      "æ®µ",
      "æ¯ˆ",
      "ç……",
      "ç‘–",
      "ç¢«",
      "ç°–",
      "ç±ª",
      "ç·ž",
      "ç¼Ž",
      "è…¶",
      "è‘®",
      "èº–",
      "é›",
      "é”»"
    ],
    tÇŽ: ["å¡”", "å¢–", "ç­", "çº", "é®™", "é°¨", "é³Ž"],
    wÄ›ng: ["å¡•", "å¥£", "åµ¡", "æ”š", "æš¡", "çžˆ", "è“Š"],
    "sÄi sÃ i sÃ¨": ["å¡ž"],
    zÃ ng: ["å¡Ÿ", "å¼‰", "è‡“", "è‡Ÿ", "è‘¬", "è”µ", "éŠº"],
    tiÃ¡n: [
      "å¡¡",
      "å±‡",
      "æ¬",
      "æ²º",
      "æ¹‰",
      "ç’³",
      "ç”›",
      "ç”œ",
      "ç”°",
      "ç•‹",
      "ç•‘",
      "ç¢µ",
      "ç£Œ",
      "èƒ‹",
      "é—",
      "é˜—",
      "é´«",
      "é·†",
      "é·"
    ],
    zhÃ¨ng: [
      "å¡£",
      "å¹",
      "æ”¿",
      "è¨¼",
      "è«",
      "è­‰",
      "è¯",
      "è¯¤",
      "éƒ‘",
      "é„­",
      "é•",
      "é´Š"
    ],
    "tiÃ¡n zhÃ¨n": ["å¡«"],
    wÄ“n: [
      "å¡­",
      "æ˜·",
      "æ¦²",
      "æ®Ÿ",
      "æ¸©",
      "æº«",
      "ç‘¥",
      "ç˜Ÿ",
      "è•°",
      "è±±",
      "è¼¼",
      "è½€",
      "è¾’",
      "éŽ¾",
      "é¥‚",
      "é°›",
      "é°®",
      "é³"
    ],
    liÃ¹: ["å¡¯", "å»‡", "ç£Ÿ", "ç¿", "é›¡", "éœ¤", "é¤¾", "é¬¸", "é·š", "é¹¨"],
    hÇŽi: ["å¡°", "æµ·", "çƒ¸", "é…¼", "é†¢"],
    lÇŽng: ["å¡±", "æœ–", "æœ—", "æœ¤", "çƒº", "è“¢", "ã®¾"],
    bÃ¨ng: ["å¡´", "æ¼", "æ³µ", "ç”", "ç¶³", "è¹¦", "è¿¸", "é€¬", "é°", "é•š"],
    chÃ©n: [
      "å¡µ",
      "å®¸",
      "å°˜",
      "å¿±",
      "æ•",
      "æ•¶",
      "æ™¨",
      "æ›Ÿ",
      "æ •",
      "æ¨„",
      "æ²‰",
      "ç…",
      "ç˜Ž",
      "è‡£",
      "èŒž",
      "èŽ€",
      "èŽ",
      "è”¯",
      "è–¼",
      "èž´",
      "è¨¦",
      "è«¶",
      "è»™",
      "è¾°",
      "è¿§",
      "éˆ‚",
      "é™ˆ",
      "é™³",
      "éœƒ",
      "é·",
      "éºŽ"
    ],
    "Åu qiÅ«": ["å¡¸"],
    "qiÃ n jiÃ n": ["å¡¹"],
    "zhuÄn tuÃ¡n": ["å¡¼"],
    shuÇŽng: ["å¡½", "æ…¡", "æ¼º", "çˆ½", "ç¸”", "é¯"],
    shÃº: ["å¡¾", "å©Œ", "å­°", "ç’¹", "ç§«", "è´–", "èµŽ"],
    lÇ’u: ["å¡¿", "åµ", "å¶", "ç”Š", "ç¯“", "ç°"],
    chÃ­: [
      "å¢€",
      "å¼›",
      "æŒ",
      "æ± ",
      "æ¼¦",
      "ç«¾",
      "ç­‚",
      "ç®Ž",
      "ç¯ª",
      "èŒŒ",
      "èŽ",
      "èš³",
      "è¬˜",
      "è²¾",
      "èµ¿",
      "è¸Ÿ",
      "è¿Ÿ",
      "è¿¡",
      "é…",
      "éŸ",
      "é²",
      "é‰",
      "é¦³",
      "é©°"
    ],
    shÃ¹: [
      "å¢…",
      "åº¶",
      "åº»",
      "æ€·",
      "æ•",
      "æˆ",
      "æŸ",
      "æ ‘",
      "æ¨¹",
      "æ²­",
      "æ¼±",
      "æ½„",
      "æ¿–",
      "ç«–",
      "ç«ª",
      "çµ‰",
      "è…§",
      "è—",
      "è’",
      "è™ª",
      "è¡“",
      "è£‹",
      "è±Ž",
      "è¿°",
      "é‰¥",
      "éŒ°",
      "é£",
      "éœ”",
      "é¶",
      "ð¬¬¸"
    ],
    "dÃ¬ zhÃ¬": ["å¢†", "ç–"],
    kÃ n: ["å¢ˆ", "å´", "çž°", "çŸ™", "ç£¡", "è¡Ž", "é¬«"],
    chÄ›n: ["å¢‹", "å¤¦", "ç¡¶", "ç¢œ", "ç££", "è´‚", "è¶»", "è¸¸", "é–"],
    "zhÇ zhuÃ³": ["å¢Œ"],
    qiÇŽng: ["å¢", "ç¹ˆ", "ç¹¦", "ç¾¥", "è¥"],
    zÄ“ng: ["å¢—", "å¢ž", "æ†Ž", "ç’”", "çŸ°", "ç£³", "ç½¾", "è­„", "é„«", "é±›", "äŽ–"],
    qiÃ¡ng: [
      "å¢™",
      "å¢»",
      "å«±",
      "å¬™",
      "æ¨¯",
      "æª£",
      "æ¼’",
      "ç‰†",
      "è‰¢",
      "è”ƒ",
      "è”·",
      "è˜ "
    ],
    "kuÃ i tuÃ­": ["å¢¤"],
    "tuÇŽn dÇ’ng": ["å¢¥"],
    "qiÃ¡o quÃ¨": ["å¢§"],
    "zÅ«n dÅ«n": ["å¢«"],
    "qiÄo Ã¡o": ["å¢½"],
    "yÃ¬ tÃº": ["å¢¿"],
    "xuÃ© bÃ³ juÃ©": ["å£†"],
    lÇŽn: [
      "å£ˆ",
      "å¬¾",
      "å­„",
      "å­",
      "æ‡’",
      "æ‡¶",
      "æ½",
      "æ“¥",
      "æ”¬",
      "æ¦„",
      "æ¬–",
      "æµ¨",
      "æ¼¤",
      "ç ",
      "çºœ",
      "ç¼†",
      "ç½±",
      "è¦§",
      "è¦½",
      "è§ˆ",
      "é†‚",
      "é¡²"
    ],
    huÃ i: ["å£Š", "å£ž", "è˜¾"],
    rÇŽng: ["å£Œ", "å£¤", "æ”˜", "çˆ™"],
    "lÃ n xiÃ n": ["å£"],
    dÇŽo: [
      "å£”",
      "å¯¼",
      "å°Ž",
      "å²›",
      "å³¶",
      "å¶‹",
      "å¶Œ",
      "å¶¹",
      "æ£",
      "æ—",
      "æ“£",
      "æ§",
      "ç¥·",
      "ç¦‚",
      "ç¦±",
      "è¹ˆ",
      "é™¦",
      "éš",
      "éš¯"
    ],
    ruÇ: ["å£¡", "æ¡µ", "æ©¤", "ç¹ ", "è•Š", "è•‹", "è˜‚", "è˜ƒ"],
    san: ["å£­"],
    zhuÃ ng: ["å£®", "å£¯", "å£µ", "æ’ž", "ç„‹", "çŠ¶", "ç‹€"],
    "kÃ© qiÃ o": ["å£³", "æ®¼"],
    kÇ”n: [
      "å£¸",
      "å£¼",
      "æ‚ƒ",
      "æ†",
      "æ¢±",
      "ç¡±",
      "ç¥µ",
      "ç¨‡",
      "ç¨›",
      "ç¶‘",
      "è£",
      "é–«",
      "é–¸",
      "é˜ƒ"
    ],
    mÇŽng: ["å£¾", "æ¼­", "èŒ»", "èŽ½", "èŽ¾", "è Ž"],
    cÃºn: ["å£¿", "å­˜"],
    "zhÇ zhÅng": ["å¤‚"],
    "gÇ” yÃ­ng": ["å¤ƒ"],
    "jiÃ ng xiÃ¡ng": ["å¤…", "é™"],
    "pÃ¡ng fÃ©ng fÄ“ng": ["å¤†"],
    zhÄi: ["å¤ˆ", "æš", "æ‘˜", "æ–‹", "æ–Ž", "æ¦¸", "ç²‚", "é½‹"],
    "xuÃ n xiÃ²ng": ["å¤"],
    wÃ i: ["å¤–", "é¡¡"],
    "wÇŽn yuÃ n wÄn yuÄn": ["å¤—"],
    "mÇŽo wÇŽn": ["å¤˜"],
    mÃ¨ng: ["å¤¢", "å¤£", "å­Ÿ", "æ¢¦", "ç™¦", "éœ¥"],
    "dÃ  dÃ i": ["å¤§"],
    "fÅ« fÃº": ["å¤«", "å§‡", "æžŽ", "ç²°"],
    guÃ i: ["å¤¬", "æ€ª", "æ "],
    yÄng: [
      "å¤®",
      "å§Ž",
      "æŠ°",
      "æ®ƒ",
      "æ³±",
      "ç§§",
      "èƒ¦",
      "é‰ ",
      "éˆ",
      "é›µ",
      "é´¦",
      "é¸¯"
    ],
    "hÄng bÃ¨n": ["å¤¯"],
    gÇŽo: [
      "å¤°",
      "æž",
      "æ²",
      "æ§€",
      "æ§",
      "æªº",
      "ç¨",
      "ç¨¾",
      "ç¨¿",
      "ç¸ž",
      "ç¼Ÿ",
      "è’",
      "è—",
      "è—³"
    ],
    "tÄo bÄ›n": ["å¤²"],
    "tÃ³u tou": ["å¤´"],
    "yÇŽn tÄo": ["å¤µ"],
    "kuÄ kuÃ ": ["å¤¸", "èª‡"],
    "jiÃ¡ jiÄ gÄ xiÃ¡": ["å¤¹"],
    huÃ : [
      "å¤»",
      "å©³",
      "å«¿",
      "å¬…",
      "å´‹",
      "æ‘¦",
      "æ¹",
      "æž ",
      "æ¡¦",
      "æ§¬",
      "æ¨º",
      "æ¾…",
      "ç”»",
      "ç•«",
      "ç•µ",
      "ç¹£",
      "èˆ™",
      "è©±",
      "è«™",
      "è­®",
      "è¯",
      "é»Š"
    ],
    "jiÄ jiÃ¡ gÄ xiÃ¡": ["å¤¾"],
    Ä“n: ["å¥€", "æ©", "è’½"],
    "dÄ« tÃ¬": ["å¥ƒ"],
    "yÇŽn yÄn": ["å¥„", "æ¸°"],
    pÃ o: ["å¥…", "ç–±", "çš°", "ç ²", "ç¤Ÿ", "ç¤®", "é¤", "éº­"],
    nÃ i: ["å¥ˆ", "æŸ°", "æ¸¿", "è€", "è˜", "è¤¦", "éŒ¼", "é¼"],
    "quÄn juÃ n": ["å¥", "å¼®", "æ£¬"],
    zÃ²u: ["å¥", "æ"],
    "qÃ¬ qiÃ¨ xiÃ¨": ["å¥‘"],
    kÄi: ["å¥’", "å¼€", "æ©", "é¦", "é”Ž", "é–‹"],
    "bÄ“n bÃ¨n": ["å¥”", "æ³"],
    tÃ o: ["å¥—"],
    "zÃ ng zhuÇŽng": ["å¥˜"],
    bÄ›n: ["å¥™", "æœ¬", "æ¥", "ç•š", "ç¿‰", "è‹¯"],
    "xÃ¹n zhuÃ¬": ["å¥ž"],
    shÄ“: ["å¥¢", "æª¨", "çŒž", "ç•­", "ç•²", "è³’", "è³–", "èµŠ", "è¼‹", "ðª¨¶"],
    "hÇŽ pÃ² tÇŽi": ["å¥¤"],
    "Ã o yÃ¹": ["å¥¥", "å¥§", "æ¾š"],
    yÅ«n: ["å¥«", "æ°²", "æ°³", "è’€", "è’•", "è¹", "è´‡", "èµŸ", "ð«–³"],
    "duÇ’ chÄ›": ["å¥²"],
    "nÇš rÇ”": ["å¥³"],
    nÃº: ["å¥´", "å­¥", "ç¬¯", "é§‘", "é©½"],
    "dÄ«ng dÇng tiÇŽn": ["å¥µ"],
    "tÄ jiÄ›": ["å¥¹"],
    nuÃ¡n: ["å¥»"],
    "hÇŽo hÃ o": ["å¥½"],
    fÃ n: [
      "å¥¿",
      "å¬Ž",
      "æ¢µ",
      "æ±Ž",
      "æ³›",
      "æ»¼",
      "ç€ª",
      "çŠ¯",
      "ç•ˆ",
      "ç›•",
      "ç¬µ",
      "ç¯„",
      "èŒƒ",
      "è¨‰",
      "è²©",
      "è´©",
      "è»¬",
      "è¼½",
      "é£¯",
      "é£°",
      "é¥­"
    ],
    shuÃ²: ["å¦", "æ ", "æœ”", "æ§Š", "çƒ", "çˆ", "çŸŸ", "è’´", "éŽ™", "é‘ ", "é“„"],
    "fÄ“i pÃ¨i": ["å¦ƒ"],
    wÃ ng: ["å¦„", "å¿˜", "æ—º", "æœ›", "æœ¢"],
    zhuÄng: [
      "å¦†",
      "å¦",
      "å¨¤",
      "åº„",
      "åº’",
      "æ¡©",
      "æ¢‰",
      "æ¨",
      "ç²§",
      "ç³š",
      "è˜",
      "èŽŠ",
      "è£…",
      "è£"
    ],
    mÄ: ["å¦ˆ", "åª½"],
    "fÅ« yÅu": ["å¦‹"],
    "hÃ i jiÃ¨": ["å¦Ž"],
    dÃ¹: [
      "å¦’",
      "å¦¬",
      "æœ",
      "æ®¬",
      "æ¸¡",
      "ç§º",
      "èŠ",
      "è°",
      "èž™",
      "è §",
      "è ¹",
      "é",
      "é•€",
      "é¯",
      "ð¬­Š"
    ],
    miÃ o: ["å¦™", "åº™", "åº¿", "å»Ÿ", "çŽ…", "ç«—"],
    "fÇ’u pÄ“i pÄ«": ["å¦š"],
    "yuÃ¨ juÃ©": ["å¦œ"],
    niÅ«: ["å¦ž"],
    "nÃ  nÃ n": ["å¦ "],
    tuÇ’: ["å¦¥", "å«·", "åº¹", "æ¤­", "æ¥•", "æ©¢", "é¬Œ", "é°–", "éµŽ"],
    "wÃ n yuÃ¡n": ["å¦§"],
    fÃ¡ng: ["å¦¨", "æˆ¿", "è‚ª", "é˜²", "é­´", "é²‚"],
    nÄ«: ["å¦®"],
    zhÃ³u: ["å¦¯", "ç¢¡"],
    zhÄo: ["å¦±", "å·¶", "æ‹›", "æ˜­", "é‡—", "é‰Š", "é£", "é’Š", "é§‹", "ð¬¬¿"],
    "nÇŽi nÇ": ["å¦³"],
    tÇ’u: ["å¦µ", "æ•¨", "ç´", "è˜£", "é»ˆ"],
    "xiÃ¡n xuÃ¡n xÃ¹": ["å¦¶"],
    "zhÃ­ yÃ¬": ["å¦·", "ç§‡"],
    Ä“: ["å¦¸", "å¦¿", "å©€", "å±™"],
    mÃ¨i: [
      "å¦¹",
      "åªš",
      "å¯",
      "æŠº",
      "æ—€",
      "æ˜§",
      "æ²¬",
      "ç…",
      "ç——",
      "çœ›",
      "ç¸",
      "ç¥™",
      "ç¯ƒ",
      "èž",
      "è¢‚",
      "è·Š",
      "é¬½",
      "é­…"
    ],
    "qÄ« qÃ¬": ["å¦»"],
    "xÅ« xÇ”": ["å§", "ç¨°"],
    "shÄn shÃ n": ["å§", "å§—", "è‹«", "é‡¤", "é’"],
    mÃ¡n: ["å§", "æ…²", "æ¨ ", "è›®", "è »", "è¬¾", "é¥…", "é¦’", "é¬—", "é¬˜", "é°»", "é³—"],
    jiÄ›: ["å§", "åªŽ", "æªž", "æ¯‘", "é£·"],
    "wÄ›i wÄ“i": ["å§”"],
    pÄ«n: ["å§˜", "æ‹¼", "ç¤—", "ç©¦", "é¦ª", "é©ž"],
    "huÃ¡ huÃ³": ["å§¡"],
    "jiÄo xiÃ¡o": ["å§£"],
    "gÃ²u dÃ¹": ["å§¤"],
    "lÇŽo mÇ”": ["å§¥"],
    "niÃ¡n niÃ n": ["å§©"],
    zhÄ›n: [
      "å§«",
      "å±’",
      "å¼«",
      "æŠ®",
      "æ˜£",
      "æž•",
      "ç•›",
      "ç–¹",
      "çœ•",
      "ç¨¹",
      "ç¸",
      "ç¸¥",
      "ç¼œ",
      "è„",
      "è™",
      "è¢—",
      "è£–",
      "è¦™",
      "è¨º",
      "è¯Š",
      "è»«",
      "è½¸",
      "è¾´",
      "é§—",
      "é¬’"
    ],
    hÃ©ng: [
      "å§®",
      "æ†",
      "æ’",
      "çƒ†",
      "ç©",
      "èƒ»",
      "è˜…",
      "è¡¡",
      "é‘…",
      "é´´",
      "éµ†",
      "é¸»"
    ],
    "jÅ«n xÃºn": ["å§°"],
    "kuÄ hÃ¹": ["å§±"],
    "Ã¨ yÃ ": ["å§¶"],
    "xiÄn shÄ“n": ["å§º"],
    wÃ¡: ["å¨ƒ"],
    "rÃ¡o rÇŽo": ["å¨†", "å¬ˆ"],
    "shÃ o shÄo": ["å¨‹"],
    xiÄ“: ["å¨Ž", "æ³", "æ¥”", "æ­‡", "èŽ", "è "],
    "wÇ” mÃ©i mÇ”": ["å¨’"],
    "chuÃ² lÃ i": ["å¨•"],
    niÃ¡ng: ["å¨˜", "å¬¢", "å­ƒ"],
    "nÃ  nuÃ³": ["å¨œ", "ð¦°¡"],
    "pÅu bÇ": ["å¨"],
    "nÄ›i suÄ«": ["å¨ž"],
    tuÃ¬: ["å¨§", "ç…º", "è›»", "èœ•", "é€€", "é§¾"],
    mÇŽn: ["å¨¨", "å±˜", "æº€", "æ»¡", "æ»¿", "èž¨", "èŸŽ", "è¥”", "é‹"],
    "wÃº wÃ¹ yÃº": ["å¨ª"],
    "xÄ« Äi": ["å¨­"],
    "zhuÃ¬ shuÃ¬": ["å¨·"],
    "dÅng dÃ²ng": ["å¨»"],
    "ÇŽi Ã¡i Ã¨": ["å¨¾"],
    "Ä“ Ä›": ["å¨¿"],
    miÃ¡n: [
      "å©‚",
      "å¬µ",
      "å®€",
      "æ£",
      "æ£‰",
      "æª°",
      "æ«‹",
      "çœ ",
      "çŸˆ",
      "çŸŠ",
      "çŸ",
      "ç¶¿",
      "ç·œ",
      "ç»µ",
      "èŠ‡",
      "è’"
    ],
    "pÇ’u pÃ©i bÃ¹": ["å©„"],
    biÇŽo: ["å©Š", "è„¿", "è¡¨", "è£±", "è¤¾", "è«˜", "éŒ¶"],
    "fÃ¹ fÃ n": ["å©"],
    wÇ’: ["å©", "å©‘", "æˆ‘"],
    "nÃ­ nÇ": ["å©—", "æ£¿"],
    "quÃ¡n juÃ n": ["å©˜", "æƒ“"],
    hÅ«n: [
      "å©š",
      "æ˜",
      "æ˜¬",
      "æ£”",
      "æ¶½",
      "ç§",
      "ç¯",
      "ç¢ˆ",
      "è¤",
      "è‘·",
      "è”’",
      "è½‹",
      "é–½",
      "é˜"
    ],
    "qiÄn jÇn": ["å©œ"],
    "wÄn wÃ ": ["å© "],
    "lÃ¡i lÃ i": ["å©¡", "å¾•", "å¾ "],
    "zhÅu chÅu": ["å©¤"],
    "chuÃ² nÃ o": ["å©¥"],
    "nÃ¼Ã¨ Ã n": ["å©©"],
    "hÃ¹n kÅ«n": ["å©«"],
    "dÃ ng yÃ¡ng": ["å©¸"],
    nÃ n: ["å©»"],
    "ruÃ² chuÃ²": ["å©¼"],
    jiÇŽ: ["å©½", "å²¬", "æ–š", "æ–", "æ¦Ž", "æ§š", "æªŸ", "çŽ¾", "ç”²", "èƒ›", "é‰€", "é’¾"],
    "tÅu yÃº": ["å©¾", "åª®"],
    "yÃ¹ yÃº": ["åª€"],
    "wÃ©i wÄ›i": ["åª"],
    "dÃ¬ tÃ­": ["åª‚", "ç¶", "è‹"],
    rÃ³u: [
      "åªƒ",
      "æ‰",
      "æŸ”",
      "æ¸˜",
      "ç…£",
      "ç‘ˆ",
      "ç“‡",
      "ç¦¸",
      "ç²ˆ",
      "ç³…",
      "è„œ",
      "è…¬",
      "è‘‡",
      "èš",
      "è¹‚",
      "è¼®",
      "é’",
      "éž£",
      "é¨¥",
      "é°‡",
      "é¶”",
      "ð«“"
    ],
    "ruÇŽn nÃ¨n": ["åª†"],
    miÃ¡o: ["åªŒ", "å«¹", "æ", "çž„", "è‹—", "é¶“", "é¹‹"],
    "yÃ­ pÃ¨i": ["åª"],
    "miÃ¡n miÇŽn": ["åª”"],
    "tÃ­ shÃ¬": ["åªž", "æƒ¿"],
    "duÃ² tuÃ³": ["åª ", "æ²²"],
    ÇŽo: ["åªª", "åª¼", "è‰¹", "èŠº", "è¢„", "è¥–", "é•º"],
    "chÃº zÃ²u": ["åª°"],
    yÃ¬ng: ["åªµ", "æ˜ ", "æšŽ", "ç¡¬", "è†¡", "é±¦"],
    "qÃ­n shÄ“n": ["å«€"],
    jiÃ : ["å«", "å¹", "æž¶", "æ¦¢", "ç¨¼", "é§•", "é©¾"],
    sÇŽo: ["å«‚"],
    "zhÄ“n zhÄ›n": ["å«ƒ"],
    "jiÄ“ suÇ’": ["å«…"],
    "mÃ­ng mÇng": ["å«‡"],
    niÇŽo: ["å«‹", "å¬", "å¬²", "èŒ‘", "è”¦", "è¢…", "è£Š", "è¤­", "é¸Ÿ"],
    tÄo: [
      "å«",
      "å¹",
      "å¼¢",
      "æ…†",
      "æŽ",
      "æ¯",
      "æ§„",
      "æ¶›",
      "æ»”",
      "æ¿¤",
      "ç‘«",
      "çµ›",
      "ç¸š",
      "ç¸§",
      "ç»¦",
      "è©œ",
      "è¬Ÿ",
      "è½",
      "éž±",
      "éŸœ",
      "éŸ¬",
      "é£¸",
      "é¥•"
    ],
    biÃ¡o: ["å«‘"],
    "piÃ¡o piÄo": ["å«–", "è–¸"],
    xuÃ¡n: [
      "å«™",
      "æ‚¬",
      "æ‡¸",
      "æš¶",
      "æªˆ",
      "æ¼©",
      "çŽ„",
      "ç’‡",
      "ç’¿",
      "ç—ƒ",
      "èœ",
      "ð« Š"
    ],
    "mÃ n mÄn": ["å«š"],
    kÄng: [
      "å«",
      "åµ»",
      "åº·",
      "æ…·",
      "æ§º",
      "æ¼®",
      "ç Š",
      "ç©…",
      "ç³ ",
      "èº¿",
      "é®",
      "é±‡",
      "ð¡“",
      "ð©¾Œ"
    ],
    "hÄn nÇŽn": ["å«¨"],
    nÃ¨n: ["å«©", "å«°"],
    zhÄ“: ["å«¬", "é®"],
    "mÄ mÃ¡": ["å«²"],
    piÃ¨: ["å«³"],
    zhÇŽn: [
      "å«¸",
      "å±•",
      "æŒ",
      "æ–©",
      "æ–¬",
      "ç–",
      "ç›",
      "ç›ž",
      "è¼¾",
      "é††",
      "é¢­",
      "é£"
    ],
    "xiÄn yÇŽn jÃ¬n": ["å¬"],
    liÇŽn: [
      "å¬š",
      "æ•›",
      "æ–‚",
      "ç",
      "ç’‰",
      "ç¾·",
      "è„¸",
      "è‡‰",
      "è”¹",
      "è˜",
      "è˜ž",
      "è££",
      "è¥",
      "é„»"
    ],
    "qiÃ³ng huÃ¡n xuÄn": ["å¬›"],
    dÇ’ng: ["å¬ž", "æ‡‚", "ç®½", "è‘£", "è•«", "è«Œ"],
    cÄn: ["å¬ ", "æ¹Œ", "çˆ˜", "é£¡", "é¤", "é©‚", "éª–"],
    tiÇŽo: ["å¬¥", "å®¨", "æ™€", "æœ“", "çª±", "è„"],
    bÃ­: ["å¬¶", "è¸", "é¼»"],
    liÇ”: [
      "å¬¼",
      "æŸ³",
      "æ ",
      "æ¡ž",
      "æ¡º",
      "æ©®",
      "ç†®",
      "ç‹",
      "ç¶¹",
      "ç»º",
      "ç½¶",
      "ç¾€",
      "é‹¶",
      "é”"
    ],
    "qiÄn xiÄn": ["å­…", "æ¬¦"],
    "xiÃ© huÄ«": ["å­ˆ"],
    "huÄn quÃ¡n": ["å­‰"],
    "lÃ­ lÃ¬": ["å­‹", "éº—"],
    "zhÃº chuÃ²": ["å­Ž"],
    kÇ’ng: ["å­”", "æ"],
    "mÄ zÄ«": ["å­–"],
    "sÅ«n xÃ¹n": ["å­™", "å­«"],
    "bÃ¨i bÃ³": ["å­›", "èª–"],
    "yÃ²u niÅ«": ["å­§"],
    zhuÇŽn: ["å­¨", "ç«±", "è½‰"],
    hÃ¡i: ["å­©", "éª¸"],
    nÄo: ["å­¬"],
    "chÃ¡n cÃ n": ["å­±"],
    bÃ²: ["å­¹", "æª—", "è˜—", "è­’"],
    nÃ¡i: ["å­»", "è…‰"],
    "nÃ­ng nÃ¬ng": ["å®", "å¯", "å¯—", "å¯œ", "å¯§", "ç”¯"],
    zhÃ¡i: ["å®…"],
    "tÅ« jiÄ": ["å®Š"],
    sÃ²ng: ["å®‹", "è¨Ÿ", "èª¦", "è®¼", "è¯µ", "é€", "éŽ¹", "é Œ", "é¢‚", "é¤¸"],
    rÃ²u: ["å®", "è‚‰", "è­³"],
    zhÅ«n: ["å®’", "çª€", "è¡ ", "è«„", "è°†", "è¿"],
    "mÃ¬ fÃº": ["å®“"],
    "dÃ ng tÃ n": ["å®•"],
    "wÇŽn yuÄn": ["å®›"],
    chÇ’ng: ["å® ", "å¯µ"],
    qÃºn: ["å®­", "å³®", "å¸¬", "ç¾£", "ç¾¤", "è£™", "è£ "],
    zÇŽi: ["å®°", "å´½"],
    "bÇŽo shÃ­": ["å®²"],
    "jiÄ jia jie": ["å®¶"],
    "huÄng huÇŽng": ["å®º"],
    kuÄn: ["å®½", "å¯›", "å¯¬", "è‡—", "é‘§", "é«‹", "é«–"],
    "sÃ¹ xiÇ” xiÃ¹": ["å®¿"],
    "jiÃ© zÇŽn": ["å¯"],
    "bÃ¬ng bÇng": ["å¯Ž"],
    "jÃ¬n qÇn": ["å¯–"],
    "lÃ³u jÃ¹": ["å¯ "],
    "xiÄ› xiÃ¨": ["å¯«"],
    "qÄ«n qÃ¬n": ["å¯´"],
    cÃ¹n: ["å¯¸", "ç±¿"],
    duÃ¬: [
      "å¯¹",
      "å¯¾",
      "å°",
      "æ€¼",
      "æ†",
      "æ‡Ÿ",
      "æ¿§",
      "ç€©",
      "ç¢“",
      "ç¥‹",
      "ç¶",
      "è–±",
      "è­ˆ",
      "è­µ",
      "è½›",
      "é˜Ÿ",
      "é™®"
    ],
    "lÃ¼Ã¨ luÃ³": ["å¯½"],
    "shÃ¨ yÃ¨ yÃ¬": ["å°„"],
    "jiÄng jiÃ ng qiÄng": ["å°†"],
    "jiÄng jiÃ ng": ["å°‡", "æµ†", "æ¼¿", "ç•º"],
    zÅ«n: ["å°Š", "å¶Ÿ", "æ¨½", "ç½‡", "éµ", "é", "é±’", "é³Ÿ", "é¶Ž", "é··", "ð¨±”"],
    "shÃ¹ zhÃ¹": ["å°Œ", "æ¾"],
    xiÇŽo: ["å°", "æ™“", "æš", "æ›‰", "çš›", "çš¢", "ç­±", "ç­¿", "ç¯ ", "è¬", "ð«²"],
    "jiÃ© jÃ­": ["å°", "è¯˜", "éžŠ"],
    "shÇŽo shÃ o": ["å°‘"],
    Ä›r: [
      "å°’",
      "å°“",
      "å°”",
      "æ ®",
      "æ¯¦",
      "æ´±",
      "çˆ¾",
      "ç¥",
      "è€³",
      "è–¾",
      "è¡ˆ",
      "è¶°",
      "è¿©",
      "é‚‡",
      "é‰º",
      "é“’",
      "é¤Œ",
      "é¥µ",
      "é§¬"
    ],
    "wÄng yÃ³u": ["å°¢"],
    wÄng: ["å°£", "å°©", "å°ª", "å°«", "æ±ª"],
    liÃ o: ["å°¥", "å°¦", "å»–", "æ’‚", "æ–™", "ç‚“", "çª·", "é", "é•£", "ðª¤—"],
    "mÃ©ng mÃ¡ng lÃ³ng pÃ¡ng": ["å°¨"],
    gÃ : ["å°¬", "é­€"],
    "kuÃ¬ kuÇ": ["å°¯"],
    tuÃ­: ["å°µ", "å¼š", "ç©¨", "è˜ˆ", "è¹ª", "éš¤", "é ¹", "é º", "é ½", "é¢“", "é­‹", "ð¬¯Ž"],
    yÇn: [
      "å°¹",
      "å¶¾",
      "å¼•",
      "æœ„",
      "æªƒ",
      "æª¼",
      "æ«½",
      "æ·¾",
      "æ¿¥",
      "ç˜¾",
      "ç™®",
      "ç²Œ",
      "è˜Ÿ",
      "èš“",
      "èž¾",
      "è®”",
      "èµº",
      "è¶›",
      "è¼‘",
      "éˆ",
      "é·"
    ],
    "chÇ chÄ›": ["å°º"],
    kÄo: ["å°»", "é«›"],
    "jÃ¬n jÇn": ["å°½"],
    "wÄ›i yÇ": ["å°¾"],
    "niÃ o suÄ«": ["å°¿"],
    cÃ©ng: ["å±‚", "å±¤", "å¶’", "é©“"],
    diÇŽo: ["å±Œ"],
    "pÃ­ng bÇng bÄ«ng": ["å±"],
    lÃ²u: ["å±š", "æ¼", "ç˜˜", "ç˜º", "ç˜»", "é¤", "é•‚", "é™‹"],
    "shÇ” zhÇ”": ["å±ž", "å±¬"],
    "xiÃ¨ tÃ¬": ["å±Ÿ"],
    "chÃ¨ cÇŽo": ["å±®"],
    "tÃºn zhÅ«n": ["å±¯"],
    "nÃ¬ jÇ": ["å±°"],
    "hÃ³ng lÃ³ng": ["å±¸"],
    "qÇ kÇŽi": ["å²‚", "è±ˆ"],
    Ã¡ng: ["å²‡", "æ˜‚", "æ˜»"],
    "gÇŽng gÄng": ["å²—", "å´—"],
    kÄ›: ["å²¢", "æ•¤", "æ¸‡", "æ¸´", "ç‚£"],
    gÇ’u: ["å²£", "ç‹—", "çŽ½", "ç¬±", "è€‡", "è€ˆ", "è€‰", "è‹Ÿ", "è±¿"],
    tiÃ¡o: [
      "å²§",
      "å²¹",
      "æ¨¤",
      "ç¥’",
      "ç¬¤",
      "èŠ€",
      "è”",
      "è“š",
      "è“¨",
      "èœ©",
      "è¿¢",
      "é‹š",
      "éŽ¥",
      "éž—",
      "é««",
      "é¯ˆ",
      "é°·",
      "é²¦",
      "é½ ",
      "é¾†"
    ],
    "qÅ« jÅ«": ["å²¨"],
    lÇng: ["å²­", "å¶º", "é ˜", "é¢†"],
    pÃ²: ["å²¶", "æ•€", "æ´¦", "æ¹", "çƒž", "ç€", "ç ´", "ç ¶", "ç²•", "è’ª", "é­„"],
    "bÄ kÃ¨": ["å³‡"],
    luÃ²: [
      "å³ˆ",
      "æ‘ž",
      "æ´›",
      "æ´œ",
      "çŠ–",
      "çž",
      "ç¬¿",
      "çº™",
      "è¦",
      "è©»",
      "é›’",
      "é§±",
      "éª†",
      "éµ…"
    ],
    "fÃ¹ niÃ¨": ["å³Š"],
    Ä›n: ["å³Ž"],
    "zhÃ¬ shÃ¬": ["å³™", "å´»"],
    qiÇŽ: ["å³ ", "è·’", "é… ", "éž"],
    "qiÃ¡o jiÃ o": ["å³¤", "ç™„"],
    "xiÃ© yÃ©": ["å³«"],
    bÅ«: ["å³¬", "åº¯", "æ™¡", "èª§", "é€‹", "éˆ½", "éŒ»", "é’¸", "é¤”", "éµ"],
    chÃ³ng: ["å´‡", "å´ˆ", "çˆž", "è™«", "è©", "èŸ²", "è¤ˆ", "éš€"],
    "zÃº cuÃ¬": ["å´’", "æ¤Š"],
    "lÃ­ng lÃ©ng": ["å´š"],
    "dÃ²ng dÅng": ["å´ "],
    xiÃ¡o: ["å´¤", "æ´¨", "æ·†", "è¨¤", "èªµ"],
    "pÃ­ bÇ": ["å´¥", "èŠ˜"],
    "zhÇŽn chÃ¡n": ["å´­", "å¶ƒ", "å¶„"],
    "wÇŽi wÄ“i": ["å´´"],
    "yÃ¡ng dÃ ng": ["å´µ"],
    "shÃ¬ diÃ©": ["å´¼"],
    yÃ o: [
      "å´¾",
      "æ›œ",
      "ç†Ž",
      "ç‡¿",
      "çŸ…",
      "ç©¾",
      "çª”",
      "ç­„",
      "è€€",
      "è‰ž",
      "è¯",
      "è‘¯",
      "è–¬",
      "è—¥",
      "è¢Ž",
      "è¦ž",
      "è©",
      "è®‘",
      "é¿",
      "é·‚",
      "é¹ž",
      "é¼¼"
    ],
    "kÄn zhÃ n": ["åµ"],
    "hÃ¡n dÇŽng": ["åµ…"],
    "qiÃ n kÃ n": ["åµŒ"],
    "wÃ¹ mÃ¡o": ["åµ"],
    "kÄ› jiÃ©": ["åµ‘", "å¶±"],
    "wÄ“i wÄ›i": ["åµ”"],
    kÄ“: [
      "åµ™",
      "æŸ¯",
      "æ£µ",
      "æ¦¼",
      "æ¨–",
      "ç‰",
      "ç‰±",
      "çŠ",
      "ç‚",
      "ç–´",
      "çžŒ",
      "ç£•",
      "ç¤š",
      "ç§‘",
      "ç¨ž",
      "çª ",
      "èª",
      "è––",
      "èšµ",
      "èŒ",
      "è¶·",
      "è½²",
      "é†˜",
      "éˆ³",
      "é’¶",
      "é ¦",
      "é¡†",
      "é¢—",
      "é«"
    ],
    "dÃ ng tÃ¡ng": ["åµ£"],
    "rÃ³ng yÃ­ng": ["åµ¤", "çˆƒ"],
    "Ã¡i kÇŽi": ["åµ¦"],
    "kÄo qiÄo": ["åµª"],
    cuÃ³: ["åµ¯", "åµ³", "ç—¤", "çŸ¬", "è’«", "è”–", "è™˜", "é¹º", "é¹¾"],
    "qiÇŽn qÄ«n": ["åµ°"],
    "dÃ¬ diÃ©": ["åµ½"],
    cÄ“n: ["åµ¾"],
    dÇng: ["åµ¿", "è‰¼", "è–¡", "é¤", "é ‚", "é¡¶", "é¼Ž", "é¼‘"],
    "Ã¡o Ã o": ["å¶…"],
    "pÇ pÃ¨i": ["å¶"],
    "jiÃ o qiÃ¡o": ["å¶ ", "æ½"],
    "juÃ© guÃ¬": ["å¶¡", "é³œ"],
    "zhÄn shÃ n": ["å¶¦", "é³£"],
    "xiÃ¨ jiÃ¨": ["å¶°"],
    "guÄ« xÄ« juÃ n": ["å¶²"],
    rÅ«: ["å¶¿"],
    "lÃ¬ liÃ¨": ["å·", "æ£™", "çˆ„", "ç¶Ÿ"],
    "xÄ« guÄ« juÃ n": ["å·‚"],
    "yÃ­ng hÅng": ["å·†"],
    yÇng: [
      "å·Š",
      "å»®",
      "å½±",
      "æ‘¬",
      "æ¢¬",
      "æ½",
      "ç˜¿",
      "ç™­",
      "çŸ¨",
      "ç©Ž",
      "éƒ¢",
      "é›",
      "é ´",
      "é¢",
      "é¢•",
      "é¢–"
    ],
    chÇŽo: ["å·", "ç‚’", "ç…¼", "çœ§", "éº¨"],
    cuÃ¡n: ["å·‘", "æ«•", "æ¬‘"],
    chuÄn: ["å·›", "å·", "æ°š", "ç‘", "ç©¿"],
    "jÄ«ng xÃ­ng": ["å· "],
    chÃ¡o: [
      "å·¢",
      "å·£",
      "æ™",
      "æ¼…",
      "æ½®",
      "ç‰Š",
      "çª²",
      "ç½º",
      "è¬¿",
      "è½ˆ",
      "é„›",
      "é¼Œ"
    ],
    qiÇŽo: ["å·§", "æ„€", "é«œ"],
    gÇ’ng: ["å·©", "å»¾", "æ‹±", "æ‹²", "æ ±", "æ±ž", "ç™", "è¼", "éž"],
    "chÃ  chÄ chÄi cÄ«": ["å·®"],
    "xiÃ ng hÃ ng": ["å··"],
    shuÃ i: ["å¸…", "å¸¥", "èŸ€"],
    pÃ : ["å¸Š", "å¸•", "æ€•", "è¢™"],
    "tÇŽng nÃº": ["å¸‘"],
    "mÃ² wÃ ": ["å¸“"],
    "tiÄ“ tiÄ› tiÃ¨": ["å¸–"],
    zhÇ’u: ["å¸š", "æ™­", "ç–›", "ç­", "ç®’", "è‚˜", "è·", "é¯ž"],
    "juÇŽn juÃ n": ["å¸£"],
    shuÃ¬: ["å¸¨", "æ¶—", "æ¶š", "ç¡", "ç¨…", "ç¨Ž", "è£ž"],
    "chÃ³u dÃ o": ["å¸±", "å¹¬"],
    "jiÇŽn jiÄn sÃ n": ["å¸´"],
    "shÃ  qiÃ¨": ["å¸¹"],
    "qÃ­ jÃ¬": ["å¸º", "è "],
    "shÄn qiÄo shÄ“n": ["å¹“"],
    "zhuÃ ng chuÃ¡ng": ["å¹¢"],
    "chÄn chÃ n": ["å¹¨"],
    miÃ¨: [
      "å¹­",
      "æ‡±",
      "æ£",
      "æ»…",
      "ç­",
      "çƒ•",
      "ç¤£",
      "ç¯¾",
      "è”‘",
      "è–Ž",
      "è ›",
      "è¡Š",
      "é‘–",
      "é±´",
      "é´“"
    ],
    "gÄn gÃ n": ["å¹²"],
    "bÃ¬ng bÄ«ng": ["å¹¶", "å¹·"],
    "jÄ« jÇ": ["å¹¾"],
    "guÇŽng Än": ["å¹¿"],
    guÇŽng: ["åºƒ", "å»£", "çŠ·", "ç·"],
    me: ["åº…"],
    "dÃ¹n tÃºn": ["åº‰"],
    "bÃ i tÄ«ng": ["åº"],
    "yÃ¬ng yÄ«ng": ["åº”"],
    "dÇ de": ["åº•"],
    "dÃ¹ duÃ³": ["åº¦"],
    "mÃ¡ng mÃ©ng pÃ¡ng": ["åº¬"],
    "bÃ¬ng pÃ­ng": ["åº°"],
    chÄ›ng: ["åº±", "æ‚œ", "çˆ", "é€ž", "é¨", "éª‹"],
    "jÄ« cuÃ²": ["åº´"],
    qÇng: ["åº¼", "å»Ž", "æª¾", "æ¼€", "è‹˜", "è«‹", "è¬¦", "è¯·", "é ƒ", "é¡·"],
    "guÄ« wÄ›i huÃ¬": ["å»†"],
    "jÇn qÃ­n": ["å»‘"],
    kuÃ²: [
      "å»“",
      "æ‰©",
      "æ‹¡",
      "æ“´",
      "æ¿¶",
      "ç­ˆ",
      "è¿",
      "è‘€",
      "è›ž",
      "é—Š",
      "é˜”",
      "éœ©",
      "éžŸ",
      "éž¹",
      "éŸ•",
      "é ¢",
      "é¬ "
    ],
    "qiÃ¡ng sÃ¨": ["å»§", "è–”"],
    "yÇn yÃ¬n": ["å»´", "éš", "éš ", "éš±", "é£®", "é£²", "é¥®"],
    "pÃ² pÇŽi": ["å»¹", "è¿«"],
    "nÃ²ng lÃ²ng": ["å¼„"],
    "dÃ¬ tÃ¬ tuÃ­": ["å¼Ÿ"],
    "juÃ© zhÄng": ["å¼¡"],
    "mÃ­ mÇ": ["å¼¥", "å½Œ", "é¡"],
    chÄo: ["å¼¨", "æ€Š", "æŠ„", "æ¬©", "è¨¬", "è¶…", "éˆ”", "é’ž"],
    yi: ["å¼¬"],
    shÄo: [
      "å¼°",
      "æ—“",
      "çƒ§",
      "ç„¼",
      "ç‡’",
      "ç­²",
      "è‰„",
      "è·",
      "è•±",
      "è¼Ž",
      "é«¾",
      "é®¹"
    ],
    "xuÄn yuÄn": ["å¼²"],
    "qiÃ¡ng qiÇŽng jiÃ ng": ["å¼·", "å¼º"],
    "tÃ¡n dÃ n": ["å¼¹", "é†ˆ"],
    biÃ¨: ["å½†"],
    "qiÃ¡ng jiÃ ng qiÇŽng": ["å½Š"],
    "jÃ¬ xuÄ›": ["å½"],
    tuÃ n: ["å½–", "è¤–"],
    yuÄ“: ["å½Ÿ", "æ›°", "æ›±", "çŸ±"],
    "shÄn xiÇŽn": ["å½¡"],
    wÃ©n: [
      "å½£",
      "æ–‡",
      "ç‚†",
      "ç³",
      "ç˜’",
      "ç¹§",
      "èž",
      "èŠ ",
      "èš‰",
      "èšŠ",
      "èž¡",
      "èŸ",
      "é–º",
      "é–¿",
      "é—…",
      "é—¦",
      "é—»",
      "é˜Œ",
      "é›¯",
      "é¦¼",
      "é§‡",
      "é­°",
      "é³¼",
      "é´",
      "é¼¤",
      "ð«˜œ"
    ],
    "pÃ©ng bÄng": ["å½­"],
    "piÄo piÃ o": ["å½¯"],
    "zhuÃ³ bÃ³": ["å½´"],
    "tuÇ’ yÃ­": ["å½µ"],
    "pÃ¡ng fÇŽng": ["å½·"],
    wÇŽng: [
      "å½º",
      "å¾€",
      "å¾ƒ",
      "æƒ˜",
      "æž‰",
      "æ£¢",
      "ç¶²",
      "ç½‘",
      "ç½’",
      "ç½“",
      "ç½”",
      "ç½–",
      "èµ",
      "è›§",
      "è„",
      "èª·",
      "è¼ž",
      "è¾‹",
      "é­"
    ],
    cÃº: ["å¾‚", "æ®‚"],
    "dÃ i dÄi": ["å¾…"],
    huÃ¡i: ["å¾Š", "æ€€", "æ‡", "æ‡·", "æ§", "æ·®", "è€²", "è˜¹", "è¤¢", "è¤±", "è¸"],
    "wÄ wÃ ng jiÄ": ["å¾"],
    "chÄ›ng zhÃ¨ng": ["å¾Ž"],
    "dÃ© dÄ›i de": ["å¾—"],
    "cÃ³ng zÃ²ng": ["å¾ž"],
    "shÃ¬ tÇ": ["å¾¥"],
    "tÃ­ chÃ­": ["å¾²", "é¶—", "é¶™"],
    dÃ©: ["å¾³", "å¾·", "æ´", "æ‚³", "æƒª", "æ·‚", "é€", "é”"],
    "zhÇ zhÄ“ng": ["å¾´", "å¾µ"],
    biÃ©: ["å¾¶", "ç™¿", "èŽ‚", "è›‚", "è¥’", "è¹©"],
    "chÅng zhÇ’ng": ["å¾¸"],
    "jiÇŽo jiÃ o": ["å¾¼", "ç¬…", "ç­Š"],
    "lÃ²ng lÇ’ng": ["å¾¿"],
    "qÃº jÃ¹": ["å¿‚", "æ¸ ", "çž¿", "èž¶"],
    "dÃ¬ng tÃ¬ng": ["å¿Š"],
    gÇŽi: ["å¿‹", "æ”¹"],
    rÄ›n: ["å¿", "æ  ", "æ £", "ç§¹", "ç¨”", "ç¶›", "è", "èµ", "èºµ"],
    chÃ n: ["å¿", "æ‡´", "æ‡º", "ç¡Ÿ", "ç¾¼", "éŸ‚", "é¡«"],
    tÃ¨: ["å¿‘", "æ…", "ç‰¹", "èŸ˜", "é‹±", "é“½"],
    "tÃ¨ tÄ“i tuÄ«": ["å¿’"],
    "gÄn hÃ n": ["å¿“", "æ”¼"],
    "yÃ¬ qÃ¬": ["å¿”"],
    "tÃ i shÃ¬": ["å¿•"],
    "xÄ« liÄ›": ["å¿š"],
    "yÄ«ng yÃ¬ng": ["å¿œ", "æ‡‰", "è­"],
    "mÇn wÄ›n mÃ­n": ["å¿ž", "å¿Ÿ"],
    "sÅng zhÅng": ["å¿ª"],
    "yÃ¹ shÅ«": ["å¿¬", "æ‚†"],
    "qÃ­ shÃ¬": ["å¿¯", "è€†"],
    "tÃºn zhÅ«n dÃ¹n": ["å¿³"],
    "qiÃ¡n qÃ­n": ["å¿´", "æ‰²"],
    hÃºn: ["å¿¶", "æµ‘", "æ¸¾", "é¤›", "é¦„", "é­‚", "é¼²"],
    niÇ”: ["å¿¸", "æ‰­", "ç‚„", "ç‹ƒ", "ç´", "çº½", "èŽ¥", "éˆ•", "é’®", "éµ"],
    "kuÃ¡ng wÇŽng": ["å¿¹"],
    "kÄng hÃ ng": ["å¿¼"],
    "kÃ i xÃ¬": ["å¿¾", "æ„¾"],
    Ã²u: ["æ€„", "æ…ª"],
    "bÇŽo bÃ o": ["æ€‰"],
    "mÃ­n mÃ©n": ["æ€‹"],
    "zuÃ² zhÃ ": ["æ€"],
    zÄ›n: ["æ€Ž"],
    yÃ ng: ["æ€", "æ™", "æ ·", "æ§˜", "æ¨£", "æ¼¾", "ç¾•", "è©‡"],
    "kÃ²u jÃ¹": ["æ€"],
    "nÃ¡o niÃº": ["æ€“"],
    "zhÄ“ng zhÃ¨ng": ["æ€”", "æŽ™", "é’²", "é“®"],
    "tiÄ“ zhÄn": ["æ€—"],
    "hÃ¹ gÃ¹": ["æ€˜"],
    "cÅ« jÃ¹ zÅ«": ["æ€š"],
    "sÄ« sÄi": ["æ€"],
    "yÃ³u chÃ³u": ["æ€ž"],
    "tÅ« diÃ©": ["æ€¢"],
    "yÅu yÃ o": ["æ€®"],
    xuÃ n: [
      "æ€°",
      "æ˜¡",
      "æ¥¦",
      "æ³«",
      "æ¸²",
      "ç‚«",
      "ç„",
      "çœ©",
      "ç¢¹",
      "çµ¢",
      "ç¸¼",
      "ç¹",
      "ç»š",
      "è”™",
      "è¡’",
      "è¢¨",
      "è´™",
      "é‰‰",
      "é‡",
      "é“‰",
      "é•Ÿ",
      "é¢´"
    ],
    "xÃ¹ xuÃ¨": ["æ€´"],
    "bÃ¬ pÄ«": ["æ€¶"],
    "xÄ« shÃ¹": ["æ€¸"],
    "nÃ¨n nÃ­n": ["æ"],
    "tiÄo yÃ¡o": ["æŒ"],
    "xÄ« qÄ« xÃ¹": ["æ“"],
    "xiÃ o jiÇŽo": ["æ”"],
    "hÅ« kuÄ": ["æ—"],
    nÇœ: ["æ§", "æœ’", "è¡‚", "è¡„"],
    hÃ¨n: ["æ¨"],
    "dÃ²ng tÅng": ["æ«"],
    "quÃ¡n zhuÄn": ["æ®"],
    "Ã¨ wÃ¹ Ä› wÅ«": ["æ¶", "æƒ¡"],
    tÃ²ng: ["æ¸", "æ…Ÿ", "æ†…", "ç—›", "è¡•"],
    "yuÄn juÃ n": ["æ‚"],
    "qiÄo qiÇŽo": ["æ‚„"],
    "jiÃ¨ kÃ¨": ["æ‚ˆ"],
    "hÃ o jiÃ o": ["æ‚Ž"],
    huÇ: ["æ‚”", "æª“", "æ¯€", "æ¯", "æ¯‡", "ç‡¬", "è­­"],
    "mÃ¡n mÃ¨n": ["æ‚—", "éž”"],
    "yÄ« yÃ¬": ["æ‚˜", "è¡£"],
    quÄn: ["æ‚›", "ç®ž", "é‰", "ð¨Ÿ "],
    "kuÄ« lÇ": ["æ‚"],
    "yÃ¬ niÃ n": ["æ‚¥"],
    "mÃ¨n mÄ“n": ["æ‚¶"],
    guÃ n: [
      "æ‚¹",
      "æ‚º",
      "æƒ¯",
      "æ…£",
      "æŽ¼",
      "æ‘œ",
      "æ¨Œ",
      "æ¬Ÿ",
      "æ³´",
      "æ¶«",
      "æ½…",
      "çŒ",
      "çˆŸ",
      "ç“˜",
      "ç›¥",
      "ç¤¶",
      "ç¥¼",
      "ç½†",
      "ç½",
      "è²«",
      "è´¯",
      "èº€",
      "é¦",
      "é†",
      "é‘µ",
      "é±¹",
      "é¸›",
      "é¹³"
    ],
    "kÅng kÇ’ng": ["æ‚¾"],
    "lÇ”n lÃ¹n": ["æƒ€"],
    guÇ’: [
      "æƒˆ",
      "æžœ",
      "æ¤",
      "æ§¨",
      "ç²¿",
      "ç¶¶",
      "è“",
      "èœ¾",
      "è£¹",
      "è¤",
      "è¼ ",
      "é¤œ",
      "é¦ƒ"
    ],
    "yuÄn wÇŽn": ["æƒŒ", "ç®¢"],
    "lÃ¡n lÃ­n": ["æƒ"],
    "yÃ¹ xÃ¹": ["æƒ", "æ·¢"],
    "chuÃ² chuÃ¬": ["æƒ™"],
    "hÅ«n mÃ¨n": ["æƒ›"],
    "chÇŽng tÇŽng": ["æƒ"],
    "suÇ’ ruÇ": ["æƒ¢"],
    cÇŽn: ["æƒ¨", "æ…˜", "æ†¯", "é»ª", "é»²", "ä…Ÿ"],
    cÃ¡n: ["æƒ­", "æ…™", "æ…š", "æ®‹", "æ®˜", "èš•", "è…", "è ¶", "è º"],
    "dÃ n dÃ¡": ["æƒ®", "æ†š"],
    rÄ›: ["æƒ¹"],
    "yÃº tÅu": ["æ„‰"],
    "kÃ i qÃ¬": ["æ„’"],
    "dÃ ng tÃ¡ng shÄng yÃ¡ng": ["æ„“"],
    "chÃ©n xÃ¬n dÄn": ["æ„–"],
    "kÃ¨ qiÃ ": ["æ„˜"],
    nuÃ²: [
      "æ„ž",
      "æ‡¦",
      "æ‡§",
      "æŽ¿",
      "æ¦",
      "æ¦’",
      "ç¨¬",
      "ç©¤",
      "ç³‘",
      "ç³¥",
      "ç³¯",
      "è«¾",
      "è¯º",
      "è¹ƒ",
      "é€½",
      "é©",
      "é”˜"
    ],
    gÇŽn: [
      "æ„Ÿ",
      "æ“€",
      "æ•¢",
      "æ¡¿",
      "æ©„",
      "æ¾‰",
      "æ¾¸",
      "çš¯",
      "ç§†",
      "ç¨ˆ",
      "ç¬´",
      "èŠ‰",
      "è¡¦",
      "èµ¶",
      "è¶•",
      "é±¤",
      "é³¡"
    ],
    "cÃ²ng sÅng": ["æ„¡"],
    "sÄi sÄ« sÇ": ["æ„¢"],
    "gÅng gÃ²ng hÇ’ng": ["æ„©", "æ…"],
    "shuÃ² sÃ¹": ["æ„¬", "æ´¬"],
    "yÃ¡o yÃ o": ["æ„®"],
    huÃ ng: ["æ„°", "æ›‚", "æ¦¥", "æ»‰", "çš", "çš©", "éŽ¤", "ã¿ "],
    zhÄ›ng: ["æ„¸", "æŠ", "æ‹¯", "æ•´", "æ™¸"],
    cÇŽo: ["æ„º", "è‰¸", "è‰", "é¨²"],
    "xÃ¬ xiÃ©": ["æ…€"],
    "cÇŽo sÄo": ["æ……"],
    "xÃ¹ chÃ¹": ["æ…‰"],
    "qiÃ¨ qiÃ n": ["æ…Š"],
    "cÃ¡o cÃ³ng": ["æ…’"],
    "Ã o Ã¡o": ["æ… "],
    "liÃ¡n liÇŽn": ["æ…©", "æ¢¿", "æ§¤", "æ«£"],
    "jÃ¬n qÃ­n jÇn": ["æ…¬"],
    "dÃ¬ chÃ¬": ["æ…¸"],
    "zhÃ­ zhÃ©": ["æ…¹"],
    "lÃ³u lÇš": ["æ…º", "é·œ"],
    cÃ²ng: ["æ†", "è¬¥"],
    "zhÄ« zhÃ¬": ["æ†„", "çŸ¥", "ç¹”", "ç»‡"],
    chÄ“ng: [
      "æ††",
      "æ‘š",
      "æ’",
      "æ’‘",
      "æ™¿",
      "æŸ½",
      "æ£¦",
      "æ©•",
      "æª‰",
      "æ³Ÿ",
      "æµ¾",
      "ç¤",
      "çž ",
      "ç¢€",
      "ç·½",
      "ç½‰",
      "è›",
      "èŸ¶",
      "èµª",
      "èµ¬",
      "é¿",
      "é£",
      "é˜·",
      "é—",
      "é ³",
      "é¥“"
    ],
    biÄ“: ["æ†‹", "è™Œ", "é±‰", "é³–", "é¼ˆ", "é¾ž"],
    "chÃ©ng dÃ¨ng zhÃ¨ng": ["æ†•"],
    "xÇ xÄ«": ["æ†˜"],
    "duÃ¬ dÃ¹n tÅ«n": ["æ†ž"],
    "xiÄo jiÄo": ["æ†¢"],
    "xiÃ¡n xiÃ n": ["æ†ª"],
    "liÃ¡o liÇŽo": ["æ†­", "ç‡Ž", "çˆŽ", "çˆ’"],
    shÃ©ng: ["æ†´", "ç¸„", "ç¹‰", "ç¹©", "ç»³", "è­"],
    "nÃ¡o nÇŽo nÃ¡ng": ["æ†¹"],
    "jÇng jÃ¬ng": ["æ†¼"],
    "jÇ jiÇŽo": ["æ†¿"],
    "xuÄn huÄn": ["æ‡"],
    "cÇŽo sÄo sÃ o": ["æ‡†"],
    mÃ¨n: ["æ‡‘", "æ‡£", "æšª", "ç„–", "ç‡œ"],
    "mÃ¨ng mÃ©ng mÄ›ng": ["æ‡œ"],
    "Ã i yÃ¬ nÇ": ["æ‡"],
    "mÃ©ng mÄ›ng": ["æ‡ž", "çž¢", "çŸ’"],
    "qÃ­ jÄ« jÃ¬": ["æ‡ "],
    mÇ’: ["æ‡¡"],
    "lÃ¡n xiÃ n": ["æ‡¢"],
    "yÅu yÇ’u": ["æ‡®"],
    "liÃº liÇ”": ["æ‡°", "è—°"],
    rÃ ng: ["æ‡¹", "è­²", "è®“", "è®©"],
    huÄn: ["æ‡½", "æ¬¢", "æ­“", "æ­¡", "ç¾", "è®™", "è²›", "é…„", "é©©", "é´…", "éµ"],
    nÇŽn: ["æˆ", "æ‡", "æ¹³", "ç…µ", "è…©", "è»", "èµ§"],
    "mÃ­ mÃ³": ["æˆ‚"],
    "gÃ ng zhuÃ ng": ["æˆ…", "æˆ†"],
    "zhuÃ ng gÃ ng": ["æˆ‡"],
    "xÅ« qu": ["æˆŒ"],
    "xÃ¬ hÅ«": ["æˆ", "æˆ¯", "æˆ²"],
    "jiÃ¡ gÄ": ["æˆ›"],
    zÃ©i: ["æˆ", "è ˆ", "è³Š", "è´¼", "é°‚", "é±¡", "é²—"],
    dÄ›ng: ["æˆ¥", "ç­‰"],
    "hÅ« xÃ¬": ["æˆ±"],
    chuÅ: ["æˆ³", "è¸”", "é€´"],
    "biÇŽn piÄn": ["æ‰"],
    "shÇŽng jiÅng": ["æ‰„"],
    "shÃ n shÄn": ["æ‰‡"],
    cÃ¡i: ["æ‰", "æ", "çº”", "è£", "è²¡", "è´¢"],
    "zhÄ zÄ zhÃ¡": ["æ‰Ž"],
    "lÃ¨ lÃ¬ cÃ¡i": ["æ‰"],
    "bÄ pÃ¡": ["æ‰’"],
    "dÇŽ dÃ¡": ["æ‰“"],
    rÄ“ng: ["æ‰”"],
    "fÇŽn fÃº": ["æ‰•"],
    "diÇŽo dÃ­ yuÄ“ lÃ¬": ["æ‰š"],
    "kÃ¡ng gÄng": ["æ‰›"],
    "yÅ« wÅ«": ["æ‰œ"],
    "yÅ« wÅ« kÅ«": ["æ‰"],
    "tuÅ chÇ yÇ": ["æ‰¡"],
    "gÇ” jiÃ© xÃ¬ gÄ“": ["æ‰¢"],
    dÃ¨n: ["æ‰¥", "æ‰½"],
    "sÇŽo sÃ o": ["æ‰«", "æŽƒ"],
    rÇŽo: ["æ‰°", "æ“¾", "éš¢"],
    "xÄ« chÄ qÃ¬": ["æ‰±"],
    "bÄn pÄn": ["æ‰³"],
    "bÄ Ã o": ["æ‰·"],
    "xÄ« zhÃ©": ["æ‰¸"],
    "zhÃ¬ sÇ”n kÇŽn": ["æ‰»"],
    zhÇŽo: ["æ‰¾", "æ²¼", "ç‘µ"],
    "kuÃ¡ng wÇŽng zÃ i": ["æŠ‚"],
    "hÃº gÇ”": ["æŠ‡", "é¹„", "é¹˜"],
    "bÇŽ bÃ ": ["æŠŠ"],
    "dÇŽn shÄ›n": ["æŠŒ"],
    "nÃ¨ nÃ¬ ruÃ¬ nÃ ": ["æŠ"],
    zhuÄ: ["æŠ“", "æª›", "ç°»", "è†¼", "é«½"],
    pÃ³u: ["æŠ”", "è£’"],
    "zhÃ© shÃ© zhÄ“": ["æŠ˜"],
    "pÃ³u pÅu fÅ«": ["æŠ™", "æŠ"],
    pÄo: ["æŠ›", "æ‹‹", "è„¬", "è¢"],
    "ÇŽo Ã o niÃ¹": ["æŠ"],
    "lÅ«n lÃºn": ["æŠ¡", "æŽ„"],
    "qiÇŽng qiÄng chÄ“ng": ["æŠ¢"],
    "zhÇ zhÇŽi": ["æŠ§"],
    "bÃ¹ pÅ«": ["æŠª", "æŸ¨"],
    "yÇŽo tÄo": ["æŠ­"],
    "hÄ“ hÃ¨ qiÄ": ["æŠ²"],
    "nÇ nÃ­": ["æŠ³"],
    "pÄ« pÄ“i": ["æŠ·"],
    "mÇ’ mÃ² mÄ": ["æŠ¹"],
    chÅu: ["æŠ½", "çŠ¨", "çŠ«", "ç˜³", "ç¯˜"],
    "jiÄ yÃ¡": ["æ‹"],
    "fÃº bÃ¬": ["æ‹‚", "ç•", "é¶"],
    zhÇŽ: ["æ‹ƒ", "çœ¨", "ç Ÿ", "é®º", "é²"],
    "dÄn dÃ n dÇŽn": ["æ‹…"],
    "chÄi cÄ": ["æ‹†"],
    niÄn: ["æ‹ˆ", "è”«"],
    "lÄ lÃ¡ lÇŽ lÃ ": ["æ‹‰"],
    "bÃ n pÃ n": ["æ‹Œ"],
    pÄi: ["æ‹"],
    lÄ«n: ["æ‹Ž"],
    guÇŽi: ["æ‹", "æž´", "æŸº"],
    "tuÃ² tÃ  zhÃ­": ["æ‹“"],
    "Ã o ÇŽo niÃ¹": ["æ‹—"],
    "jÅ« gÅu": ["æ‹˜"],
    "pÄ«n pÃ n fÄn": ["æ‹š"],
    "bÃ i bÃ¡i": ["æ‹œ"],
    bÃ i: ["æ‹", "æ•—", "ç¨—", "ç²º", "è–­", "è´", "è´¥", "éŸ›"],
    qiÃ¡: ["æ‹¤"],
    "nÇng nÃ­ng nÃ¬ng": ["æ‹§"],
    "zÃ© zhÃ¡i": ["æ‹©", "æ“‡"],
    hÃ©n: ["æ‹«", "ç—•", "éžŽ"],
    "kuÃ² guÄ": ["æ‹¬"],
    "jiÃ© jiÃ¡": ["æ‹®"],
    nÇn: ["æ‹°"],
    shuÄn: ["æ‹´", "æ “", "é–‚", "é—©"],
    "cÃºn zÃ¹n": ["æ‹µ"],
    "zÄ zÇŽn": ["æ‹¶", "æ¡š"],
    kÇŽo: ["æ‹·", "æ”·", "æ ²", "çƒ¤", "è€ƒ"],
    "yÃ­ chÇ hÃ i": ["æ‹¸"],
    "cÃ¨ sÃ¨ chuÃ²": ["æ‹º"],
    "zhuÃ i zhuÄi yÃ¨": ["æ‹½"],
    "shÃ­ shÃ¨": ["æ‹¾"],
    bÄi: ["æŒ€", "æŽ°"],
    "kuÃ² guÄng": ["æŒ„"],
    nÃ²ng: ["æŒŠ", "æŒµ", "é½ˆ"],
    "jiÃ o jiÄo": ["æŒ", "æ•Ž", "æ•™"],
    "kuÃ  kÅ«": ["æŒŽ"],
    "nÃ¡ rÃº": ["æŒ"],
    "tiÄo tiÇŽo": ["æŒ‘"],
    "diÃ© shÃ¨": ["æŒ•"],
    liÄ›: ["æŒ˜", "æ¯Ÿ"],
    "yÃ  yÇŽ": ["æŒœ", "æŽ—"],
    "wÅ zhuÄ": ["æŒ"],
    "xiÃ© jiÄ": ["æŒŸ", "æŒ¾"],
    "dÇŽng dÃ ng": ["æŒ¡", "æ“‹"],
    "zhÃ¨ng zhÄ“ng": ["æŒ£", "æ­£", "ç—‡"],
    "Äi Ã¡i": ["æŒ¨"],
    "tuÅ shuÃ¬": ["æŒ©", "æ"],
    "tÇ tÃ¬": ["æŒ®"],
    "suÅ shÄ": ["æŒ±"],
    "sÄ shÄ suÅ": ["æŒ²"],
    "kÄ“ng qiÄn": ["æŒ³", "æ‘¼"],
    "bÃ ng pÃ©ng": ["æŒ·"],
    "ruÃ³ ruÃ¡": ["æŒ¼"],
    "jiÇŽo kÃ¹": ["æ"],
    "wÇ” wÃº": ["æ‚"],
    tÇ’ng: ["æ…", "æ¡¶", "ç­’", "ç­©", "çµ±", "ç¶‚", "ç»Ÿ", "ã›š"],
    "huÃ² chÃ¬": ["æ‡"],
    "tÃº shÅ« chÃ¡": ["æˆ"],
    "lÇš luÅ": ["æ‹"],
    "shÄo shÃ o": ["æŽ", "ç¨"],
    niÄ“: ["æ", "æ‘"],
    "shÃ¹ sÇ’ng sÅu": ["æ’"],
    "yÃ© yÃº": ["æ“"],
    "juÃ© zhuÃ³": ["æ”"],
    "bÃ¹ pÃº zhÃ¬": ["æ—"],
    zÃ¹n: ["æ˜", "éŠŒ"],
    lÄo: ["æž", "æ’ˆ", "ç²©"],
    sÇ”n: ["æŸ", "æ", "æ¦«", "ç¬‹", "ç­", "ç®°", "éŽ¨", "éš¼"],
    "wÃ n wÇŽn wÄn yÃ¹": ["æ¥"],
    pÄ›ng: ["æ§", "æ·Ž", "çš"],
    shÄ›: ["æ¨"],
    "fÇ” fÃ¹ bÇ”": ["æ¬"],
    dÃ¡o: ["æ¯"],
    "luÃ² luÇ’ wÇ’": ["æ°"],
    "juÇŽn quÃ¡n": ["æ²"],
    "chÄ“n tiÇŽn": ["æµ"],
    "niÇŽn niÄ“": ["æ»"],
    "ruÃ³ wÄ›i rÃ©": ["æ¼"],
    zuÃ³: ["æ½", "æ˜¨", "ç§¨", "ç¨“", "ç­°", "èŽ‹", "éˆ¼"],
    "wÃ² xiÃ¡": ["æ¾"],
    "qÃ¬ng qiÃ n": ["æŽ…"],
    "pÃ³u pÇ’u": ["æŽŠ"],
    qiÄ: ["æŽ", "è‘œ"],
    "pÃ¡i pÇŽi": ["æŽ’"],
    "qiÄn wÃ n": ["æŽ”"],
    "yÃ¨ yÄ“": ["æŽ–"],
    "niÃ¨ nÇ yÃ¬": ["æŽœ"],
    "huÃ² xÃ¹": ["æŽ"],
    "yÃ n shÃ n yÇŽn": ["æŽž"],
    "zhÄ›ng dÃ¬ng": ["æŽŸ"],
    kÃ²ng: ["æŽ§", "éžš"],
    tuÄ«: ["æŽ¨", "è“·", "è—¬"],
    "zÅu zhÅu chÅu": ["æŽ«"],
    tiÃ n: ["æŽ­", "èˆš"],
    kÃ¨n: ["æŽ¯", "è£‰", "è¤ƒ"],
    pÃ¡: ["æŽ±", "æ·", "æ½–", "çˆ¬", "ç¶", "ç­¢"],
    "guÃ³ guÄi": ["æŽ´"],
    "dÇŽn shÃ n": ["æŽ¸", "æ’£"],
    "chÄn xiÄn cÃ n shÇŽn": ["æŽº"],
    sÄo: ["æŽ»", "æ”", "æºž", "ç¹…", "ç¼«", "èž¦", "é¨’", "é¨·", "é° ", "é±¢", "é³‹"],
    pÃ¨ng: ["æŽ½", "æ¤ª", "æ§°", "ç¢°", "è¸«"],
    "zhÄ“ng kÄ“ng": ["æ"],
    "jiÅ« yÃ³u": ["æ‚"],
    "jiÄn jiÇŽn": ["æƒ", "ç±›"],
    "pÃ¬ chÃ¨": ["æŠ"],
    "sÄi zÇ’ng cÄi": ["æŒ"],
    "tÃ­ dÄ« dÇ": ["æ"],
    "zÇ’ng sÅng": ["æ”"],
    "huÃ¡ng yÃ³ng": ["æ˜"],
    "zÇŽn zuÃ n": ["æ"],
    "xÅ« jÅ«": ["æŸ"],
    "kÃ© qiÄ": ["æ¢"],
    "chuÄi chuÇŽi chuÃ i tuÃ¡n zhuÄ«": ["æ£"],
    "dÃ¬ tÃ¬": ["æ¥"],
    "lÃ¡ lÃ ": ["æ¦"],
    lÃ : [
      "æ§",
      "æ¥‹",
      "æº‚",
      "ç“Ž",
      "ç˜Œ",
      "ç¿‹",
      "è‡˜",
      "è‹",
      "è²",
      "è Ÿ",
      "è¾¢",
      "è¾£",
      "é‘ž",
      "é•´",
      "é¬Ž",
      "é¯»",
      "ð¬¶Ÿ"
    ],
    "jiÄ“ qÃ¬": ["æ­"],
    "chÃ²ng dÇ’ng": ["æ°"],
    "diÃ© shÃ© yÃ¨": ["æ²"],
    "jiÃ n qiÃ¡n jiÇŽn": ["æµ"],
    yÃ©: ["æ¶", "çˆ·", "çˆº", "ç‘˜", "é‹£", "éŽ", "é“˜"],
    chÄn: ["æ€", "æ‘»", "æ”™", "è£§", "è¥œ", "è¦˜", "è§‡", "è¾¿", "é‹“"],
    "gÄ“ gÃ©": ["æ", "æ“±"],
    "lÇ’u lÅu": ["æ‚", "æ‘Ÿ"],
    "chÅu zÇ’u": ["æŠ"],
    chuÄi: ["æ‹"],
    sÅ«n: ["æŽ", "æ§‚", "ç‹²", "çŒ»", "èª", "è“€", "è•µ", "è–ž", "é£§", "é£±"],
    "rÃ³ng nÃ¡ng nÇŽng": ["æ‘"],
    "pÃ©ng bÃ ng": ["æ’"],
    cuÅ: ["æ“", "ç‘³", "ç£‹", "è¹‰", "é³", "é†"],
    "kÄ“ Ã¨": ["æ•"],
    "nÃ¹ nuÃ² nÃ²u": ["æ™"],
    "lÄ xiÃ© xiÃ n": ["æš"],
    qiÇ”: ["æ", "ç³—"],
    "xiÇŽn xiÄn": ["æŸ"],
    "jiÃ© zhÃ©": ["æ©"],
    "pÃ¡n bÄn pÃ³": ["æ«"],
    bÄn: [
      "æ¬",
      "æ”½",
      "æ–‘",
      "æ–’",
      "ç­",
      "ç˜¢",
      "ç™",
      "è‚¦",
      "èž",
      "èžŒ",
      "è¤©",
      "è¾¬",
      "é ’",
      "é¢",
      "ð¨­‰"
    ],
    "zhÃ¬ nÃ¡i": ["æ±"],
    "wÄ wÇŽ wÃ ": ["æ²"],
    huÃ¡: ["æ³", "æ’¶", "æ»‘", "çŒ¾", "è•", "èž–", "è­", "éµ", "é“§", "é©Š", "éª…", "é·¨"],
    "qiÄng qiÇŽng chÄ“ng": ["æ¶"],
    "tiÃ¡n shÄ“n": ["æ·"],
    "nÃ¡ nuÃ²": ["æ»"],
    Ã¨n: ["æ‘"],
    "shÃ¨ niÃ¨": ["æ‘„", "æ”"],
    bÃ¬n: ["æ‘ˆ", "æ“¯", "æ®¡", "æ®¯", "è†‘", "è‡", "é«Œ", "é«•", "é«©", "é¬‚", "é¬“", "é¬¢"],
    "shÄ sÃ  shÇŽi": ["æ‘‹"],
    "chÇŽn sÃ¹n": ["æ‘Œ"],
    "jiÅ« liÃº liÃ¡o jiÇŽo nÃ¡o": ["æ‘Ž"],
    "fÃ©ng pÄ›ng": ["æ‘“"],
    shuÄi: ["æ‘”"],
    "dÃ¬ tÃº zhÃ­": ["æ‘•"],
    "qÃ¬ jÃ¬ chÃ¡": ["æ‘–"],
    "sÅu sÇ’ng": ["æ‘—"],
    "liÇŽn liÃ n": ["æ‘™"],
    "gÃ i xÃ¬": ["æ‘¡"],
    "hÃ¹ chÅ«": ["æ‘¢"],
    tÃ ng: ["æ‘¥", "çƒ«", "ç‡™", "é‹"],
    "nÃ¡i zhÃ¬": ["æ‘¨"],
    "mÃ³ mÄ": ["æ‘©"],
    "jiÄng qiÃ ng": ["æ‘ª"],
    "Ã¡o qiÃ¡o": ["æ‘®"],
    "niÃ¨ chÃ¨": ["æ‘°"],
    "mÃ¡n mÃ n": ["æ‘±"],
    "chÃ n cÃ¡n": ["æ‘²"],
    "sÃ¨ mÃ­ sÃ¹": ["æ‘µ"],
    "biÄo biÃ o": ["æ‘½"],
    "juÄ“ juÃ©": ["æ’…"],
    piÄ“: ["æ’†", "æš¼", "æ°•", "çž¥"],
    "piÄ› piÄ“": ["æ’‡"],
    "zÇŽn zÄn zÄ“n qiÃ¡n": ["æ’"],
    "sÄ sÇŽ": ["æ’’"],
    hÃ²ng: ["æ’”", "è¨Œ", "è®§", "é—€", "é¬¨"],
    "hÃ©ng guÃ ng": ["æ’—"],
    niÇŽn: [
      "æ’š",
      "æ’µ",
      "æ”†",
      "æ¶Š",
      "ç„¾",
      "ç¢¾",
      "ç°",
      "è¹",
      "è¹¨",
      "èºŽ",
      "è¼¦",
      "è¾‡"
    ],
    "chÃ©ng zhÄ›ng": ["æ’œ"],
    "huÄ« wÃ©i": ["æ’"],
    cÄo: ["æ’¡", "æ“", "ç³™"],
    "xiÄo sÅu": ["æ’¨"],
    "liÃ¡o liÄo": ["æ’©"],
    "cuÅ zuÇ’": ["æ’®"],
    "wÄ›i tuÇ’": ["æ’±"],
    cuÄn: ["æ’º", "æ”›", "æ±†", "è¹¿", "èº¥", "é‘¹", "é•©"],
    "qiÃ o yÄo jÄ«": ["æ’½"],
    "zhuÄ wÅ": ["æ’¾"],
    "lÃ¨i lÃ©i": ["æ“‚"],
    nÇŽng: ["æ“ƒ", "æ”®", "æ›©", "ç¢"],
    "qÃ­ng jÇng": ["æ“"],
    kuÇŽi: ["æ““", "è’¯", "ã§Ÿ"],
    "pÇ bÃ²": ["æ“—"],
    "bÃ² bÄi": ["æ“˜"],
    "jÃ¹ jÇ": ["æ“š"],
    mÄ“ng: ["æ“"],
    "sÇ’u sÃ²u": ["æ“ž"],
    xÇng: ["æ“¤", "ç®µ", "é†’"],
    cÄ: ["æ“¦"],
    "nÃ­ng nÇng nÃ¬ng": ["æ“°"],
    "zhÃ¬ jiÃ©": ["æ“³"],
    "lÃ  liÃ¨": ["æ“¸", "çˆ‰"],
    "sÃ²u sÇ’u": ["æ“»"],
    "lÃ¬ luÃ² yuÃ¨": ["æ“½"],
    "tÄ« zhÄi zhÃ¬": ["æ“¿"],
    pÄn: ["æ”€", "æ½˜", "çœ…", "è "],
    lÃ¨i: [
      "æ”‚",
      "æ³ª",
      "æ¶™",
      "æ·š",
      "ç¦·",
      "ç±»",
      "çº‡",
      "è˜±",
      "é…¹",
      "éŠ‡",
      "éŒ‘",
      "é ›",
      "é ª",
      "é¡ž",
      "é¢£"
    ],
    "cÄ sÇŽ": ["æ”ƒ"],
    "jÃ¹n pÃ¨i": ["æ”ˆ"],
    "lÃ¬ luÃ²": ["æ”Š", "èº’"],
    "lÃ  lÃ i": ["æ”‹", "æ«´"],
    "lÃº luÃ³": ["æ”Ž"],
    "zÇŽn cuÃ¡n": ["æ”’"],
    "xiÄn jiÄn": ["æ”•"],
    "mÃ­ mÇ mÃ³": ["æ” "],
    "zÇŽn cuÃ¡n zÃ n zuÄn": ["æ”¢"],
    zuÃ n: ["æ”¥"],
    "lÃ¬ shÃ i": ["æ”¦"],
    "lÃ¬ luÇ’": ["æ”­"],
    "guÇ guÃ¬": ["æ”±"],
    "jÄ« qÄ« yÇ": ["æ”²"],
    fÃ ng: ["æ”¾"],
    "wÃ¹ mÃ³u": ["æ•„"],
    "chÃ¹ shÅu": ["æ•Š"],
    "gÃ© guÃ³ Ã¨": ["æ•‹"],
    "duÃ³ duÃ¬": ["æ•“", "æ•š"],
    "duÅ quÃ¨": ["æ• ", "æ•ª"],
    "sÃ n sÇŽn": ["æ•£"],
    "dÅ«n duÃ¬": ["æ•¦", "é•¦"],
    "qÄ« yÇ jÄ«": ["æ•§"],
    "xiÃ o xuÃ©": ["æ•©"],
    "shÃ¹ shÇ” shuÃ²": ["æ•°", "æ•¸"],
    "Ã¡i zhÃº": ["æ•±", "æ•³"],
    "xiÃ²ng xuÃ n": ["æ•»"],
    "zhuÃ³ zhÃº": ["æ–€"],
    "yÃ¬ dÃ¹": ["æ–"],
    "lÃ­ tÃ¡i": ["æ–„"],
    "fÄ›i fÄ“i": ["æ–"],
    "yÇ” zhÅng": ["æ–”"],
    "dÃ²u dÇ’u": ["æ–—"],
    "wÃ² guÇŽn": ["æ–¡"],
    "tÇ’u tiÇŽo": ["æ–¢"],
    dÃ²u: [
      "æ–£",
      "æ¢ª",
      "æµ¢",
      "ç—˜",
      "çª¦",
      "ç«‡",
      "è„°",
      "è³",
      "è±†",
      "é€—",
      "éƒ–",
      "é…˜",
      "é–—",
      "é—˜",
      "é¤–",
      "é¥¾",
      "é¬¥",
      "é¬¦",
      "é¬ª",
      "é¬¬",
      "é¬­"
    ],
    "yÃ­n zhÃ¬": ["æ–¦"],
    "chÇŽn jiÃ¨": ["æ–º"],
    "wÅ« yÅ« yÃº": ["æ–¼"],
    "yÃ³u liÃº": ["æ–¿"],
    "pÃ¡ng bÃ ng": ["æ—"],
    "mÃ¡o mÃ o": ["æ—„"],
    "pÄ« bÃ¬": ["æ—‡"],
    "xuÃ¡n xuÃ n": ["æ—‹"],
    "wÃº mÃ³": ["æ— "],
    zÇŽo: ["æ—©", "æž£", "æ †", "æ£—", "æ¾¡", "ç’ª", "è–»", "è—»", "èš¤"],
    gÄ: ["æ—®"],
    "gÃ n hÃ n": ["æ—°"],
    "tÃ¡i yÄ«ng": ["æ—²"],
    "xÅ« xÃ¹": ["æ—´"],
    "tÅ«n zhÃ¹n": ["æ—½"],
    "wÃ¹ wÇ”": ["æ—¿"],
    "pÃ² pÃ¨i": ["æ˜¢"],
    zÃ²ng: ["æ˜®", "çŒ”", "ç–­", "ç˜²", "ç²½", "ç³‰", "ç³­", "ç¸¦"],
    ÇŽi: ["æ˜¹", "æ¯", "çŸ®", "è”¼", "è—¹", "è­ª", "èº·", "éœ­", "é„"],
    "huÃ ng huÇŽng": ["æ™ƒ"],
    xuÇŽn: ["æ™…", "ç™£", "ç™¬", "é€‰", "é¸"],
    "xÃ¹ kuÄ": ["æ™‡"],
    hÇ’ng: ["æ™Ž"],
    shÃ i: ["æ™’", "æ›¬"],
    "yÅ«n yÃ¹n": ["æ™•", "ç…´"],
    "shÃ¨ng chÃ©ng": ["æ™Ÿ", "æ¤‰", "ç››"],
    "jÇng yÇng": ["æ™¯"],
    shÇŽn: ["æ™±", "ç†Œ", "ç’", "è¦¢", "é–ƒ", "é—ª", "é™•", "é™"],
    "qÇ dÃ¹": ["æ™µ"],
    "ÇŽn Ã n yÇŽn": ["æ™»"],
    "wÇŽng wÃ ng": ["æš€"],
    zÃ n: [
      "æš‚",
      "æš«",
      "ç“‰",
      "ç“’",
      "ç“š",
      "ç¦¶",
      "è¥¸",
      "è®ƒ",
      "è®š",
      "è³›",
      "è´Š",
      "èµž",
      "è¹”",
      "é„¼",
      "éŒ¾",
      "é¨",
      "é¥¡"
    ],
    "yÃ¹n yÅ«n": ["æšˆ"],
    "mÃ­n mÇn": ["æš‹"],
    "dÇ” shÇ”": ["æš"],
    shÇ”: [
      "æš‘",
      "æ›™",
      "æ½»",
      "ç™™",
      "ç³¬",
      "ç½²",
      "è–¥",
      "è–¯",
      "è—·",
      "èœ€",
      "è ´",
      "è¥¡",
      "è¥©",
      "é±ª",
      "é±°",
      "é»",
      "é¼ ",
      "é¼¡"
    ],
    "jiÇŽn lÃ¡n": ["æš•"],
    nuÇŽn: ["æš–", "ç…—", "é¤ª"],
    "bÃ o pÃ¹": ["æš´"],
    "xÄ« xÇ": ["æš¿"],
    "pÃ¹ bÃ o": ["æ›", "ç€‘"],
    "qÅ« qÇ”": ["ç´¶"],
    "qÇ” qÅ«": ["æ›²"],
    "gÃ¨ng gÄ“ng": ["æ›´"],
    "hÅ« hÃ¹": ["æ›¶", "é›½"],
    "zÄ“ng cÃ©ng": ["æ›½", "æ©§"],
    "cÃ©ng zÄ“ng": ["æ›¾", "ç«²"],
    "cÇŽn qiÃ¡n jiÃ n": ["æœ"],
    "qiÃ¨ hÃ©": ["æœ…"],
    "bÃ¬ pÃ­": ["æœ‡", "ç¦†", "ç¬“", "è£¨"],
    "yÇ’u yÃ²u": ["æœ‰"],
    "bÄn fÃ©n": ["æœŒ", "é³»"],
    "fÃº fÃ¹": ["æœ", "æ´‘"],
    "fÄ›i kÅ«": ["æœ", "èƒ"],
    "qÃº xÃ¹ chÇ”n": ["æœ"],
    "juÄn zuÄ«": ["æœ˜"],
    "huÄng mÃ¡ng wÃ¡ng": ["æœš"],
    "qÄ« jÄ«": ["æœŸ"],
    "tÃ³ng chuÃ¡ng": ["æœ£", "æ©¦"],
    zhÃ¡: ["æœ­", "ç‰", "ç®š", "èš»", "è­—", "é˜", "é“¡", "é–˜", "é—¸"],
    "zhÃº shÃ¹ shÃº": ["æœ®"],
    "shÃ¹ shÃº zhÃº": ["æœ¯"],
    "zhÅ« shÃº": ["æœ±"],
    "pÇ” pÃ² pÅ piÃ¡o": ["æœ´"],
    "dÄo tiÃ¡o mÃ¹": ["æœ·"],
    "guÇ qiÃº": ["æœ¹"],
    xiÇ”: ["æœ½", "æ»«", "æ½ƒ", "ç³”"],
    "chÃ©ng chÄ“ng": ["æœ¾"],
    zÃ¡: ["æ‚", "æ²¯", "ç ¸", "è¥", "é›‘", "é›œ", "é›¥", "éŸ´"],
    "yÃº wÅ«": ["æ…"],
    "gÄn gÇŽn": ["æ†"],
    "chÄ chÃ ": ["æˆ"],
    "shÄn shÄ": ["æ‰"],
    cÅ«n: ["æ‘", "çš´", "ç«´", "è†¥", "è¸†", "é‚¨"],
    "rÃ¨n Ã©r": ["æ’", "æ¢•"],
    "shÃ¡o biÄo": ["æ“"],
    "dÃ¬ duÃ²": ["æ•", "æž¤"],
    "gÅ« gÃ i": ["æš"],
    "yÃ­ zhÃ¬ lÃ­ duÃ²": ["æ"],
    "gÃ ng gÄng": ["æ "],
    "tiÃ¡o tiÄo": ["æ¡", "æ¢"],
    "mÃ  mÇŽ": ["æ©"],
    "sÃ¬ zhÇ xÇ": ["æ«"],
    "yuÃ¡n wÃ¡n": ["æ¬", "èš–"],
    "bÃ¨i fÃ¨i": ["æ®"],
    "shÅ« duÃ¬": ["æ¸"],
    "niÇ” chÇ’u": ["æ»"],
    "wÃ² yuÃ¨": ["æž‚", "è‡’"],
    mÃ¡o: [
      "æž†",
      "æ¯›",
      "æ°‚",
      "æ¸µ",
      "ç‰¦",
      "çŸ›",
      "ç½ž",
      "èŒ…",
      "èŒ†",
      "è¥",
      "èŸŠ",
      "è»ž",
      "é…•",
      "é‰¾",
      "éŒ¨",
      "é”š",
      "é«¦",
      "é¶œ"
    ],
    "pÄ« mÃ¬": ["æžˆ"],
    Ã ng: ["æžŠ", "ç›Ž", "é† "],
    "fÄng bÃ¬ng": ["æž‹"],
    "hÃ¹ dÇ": ["æž‘"],
    xÃ­n: ["æž”", "è¥‘", "é”", "é¬µ"],
    "yÄo yÇŽo": ["æž–"],
    "Ä› Ã¨": ["æž™"],
    "zhÄ« qÃ­": ["æž"],
    "cÅng zÅng": ["æžž", "æ¨…"],
    "xiÄn zhÄ“n": ["æž®"],
    "tÃ¡i sÃ¬": ["æž±"],
    "gÇ’u jÇ” gÅu": ["æž¸"],
    "bÄo fÃº": ["æž¹"],
    "yÃ¬ xiÃ¨": ["æž»", "æ §"],
    "tuÃ³ duÃ²": ["æŸ", "é¦±", "é§„", "é©®"],
    "yÃ­ duÃ² lÃ­": ["æŸ‚"],
    "nÇ chÃ¬": ["æŸ…"],
    "pÃ¡n bÃ n": ["æŸˆ", "è·˜"],
    "yÇŽng yÃ ng yÄng yÄ«ng": ["æŸ"],
    "fÃ¹ fÅ« fÇ”": ["æŸŽ"],
    "bÇŽi bÃ³ bÃ²": ["æŸ"],
    mÇ’u: ["æŸ"],
    "shÃ¡o shÃ o": ["æŸ–"],
    zhÃ¨: ["æŸ˜", "æ¨œ", "æµ™", "æ·›", "è”—", "èŸ…", "é€™", "é·“", "é¹§", "ä—ª"],
    "yÃ²u yÃ³u": ["æŸš", "æ«¾"],
    "guÃ¬ jÇ”": ["æŸœ"],
    "zhÃ  zuÃ²": ["æŸž"],
    "diÃ© zhÃ¬": ["æŸ£", "çœ°"],
    "zhÄ zÇ” zÅ«": ["æŸ¤"],
    "chÃ¡ zhÄ": ["æŸ¥", "æŸ»"],
    "Äo Ã o": ["æŸª", "è»ª"],
    "bÄ fÃº pÃ¨i bÃ³ biÄ“": ["æŸ­"],
    "duÃ² zuÃ³ wÃ¹": ["æŸ®"],
    "bÃ¬ biÃ©": ["æŸ²"],
    "zhÃ¹ chÃ¹": ["æŸ·"],
    "bÄ“i pÄ“i": ["æŸ¸"],
    "shÃ¬ fÃ¨i": ["æŸ¹"],
    "shÄn zhÃ  shi cÃ¨": ["æ …"],
    "lÃ¬ yuÃ¨": ["æ Ž", "æ«Ÿ"],
    "qÃ¬ qiÃ¨": ["æ ”", "ç Œ"],
    "qÄ« xÄ«": ["æ –", "è¹Š"],
    "guÄ kuÃ²": ["æ "],
    "bÄ«ng bÄ“n": ["æ Ÿ"],
    "xiÃ o jiÃ o": ["æ ¡"],
    "jiÃ n zÃ¹n": ["æ «", "è¢¸"],
    "yÇ’u yÃ¹": ["æ ¯"],
    "hÃ© hÃº": ["æ ¸"],
    gÄ“n: ["æ ¹", "è·Ÿ"],
    "zhÄ« yÃ¬": ["æ º"],
    "gÃ© gÄ“": ["æ ¼"],
    "hÃ©ng hÃ¡ng": ["æ¡"],
    "guÃ ng guÄng": ["æ¡„"],
    "yÃ­ tÃ­": ["æ¡‹", "è‘"],
    sÄng: ["æ¡‘", "æ¡’", "æ§¡"],
    "jÃº jiÃ©": ["æ¡”"],
    "yÃº mÃ³u": ["æ¡™"],
    "rÃ¡o nÃ¡o": ["æ¡¡", "æ©ˆ"],
    "guÃ¬ huÃ¬": ["æ¡§", "æªœ"],
    "chÃ©n zhÃ¨n": ["æ¡­"],
    "tÄ«ng yÃ­ng": ["æ¡¯"],
    "bÃ³ po": ["æ¡²"],
    "bÃ¨n fÃ n": ["æ¡³"],
    "fÄ“ng fÃ¨ng": ["æ¡»", "è‘‘"],
    "sÃ¹ yÃ¬n": ["æ¢€"],
    "tÇng tÃ¬ng": ["æ¢ƒ"],
    "xuÄn juÄn xiÃ©": ["æ¢‹"],
    "tÃº chÃ¡": ["æ¢Œ"],
    "Äo yÃ²u": ["æ¢Ž"],
    kuÇŽn: ["æ¢¡", "æ¬µ", "æ¬¾", "æ­€"],
    "shÄo sÃ o": ["æ¢¢"],
    "qÃ­n chÃ©n cÃ©n": ["æ¢£"],
    "lÃ­ sÃ¬ qÇ": ["æ¢©"],
    "chÄn yÃ¡n": ["æ¢´"],
    "bÄ«n bÄ«ng": ["æ¢¹", "æ§Ÿ", "æª³"],
    "tÃ¡o chÃ³u dÃ o": ["æ¢¼"],
    "cÅng sÅng": ["æ£‡"],
    "gÃ¹n hÃ¹n": ["æ£"],
    "dÃ© zhÃ©": ["æ£"],
    "pÃ¡i bÃ¨i pÃ¨i": ["æ£‘"],
    "bÃ ng pÇ’u bÃ¨i bÄ“i": ["æ£“"],
    "dÃ¬ dÃ i tÃ¬": ["æ££"],
    sÄ“n: ["æ£®", "æ¤®", "æ§®", "è¥‚"],
    "rÄ›n shÄ›n": ["æ£¯"],
    "lÃ©ng lÄ“ng lÃ­ng": ["æ£±"],
    "fÃº sÃ¹": ["æ£´"],
    "zÅu sÇ’u": ["æ£·"],
    zÅu: [
      "æ£¸",
      "ç®ƒ",
      "ç·…",
      "è«",
      "è¯¹",
      "é‚¹",
      "éƒ°",
      "é„’",
      "é„¹",
      "é™¬",
      "é¨¶",
      "é©º",
      "é¯«",
      "é²°",
      "é»€",
      "é½±",
      "é½º"
    ],
    "zhÃ o zhuÅ": ["æ£¹"],
    "chÄ“n shÄ“n": ["æ£½"],
    "jiÄ“ qiÃ¨": ["æ¤„"],
    "yÇ yÄ«": ["æ¤…"],
    "chÃ³u zhÃ²u diÄo": ["æ¤†"],
    "qiÄng kÅng": ["æ¤Œ"],
    "zhuÄ« chuÃ­": ["æ¤Ž"],
    "bÄ“i pÃ­": ["æ¤‘"],
    mÄ“n: ["æ¤š"],
    "quÄn juÃ n quÃ¡n": ["æ¤¦"],
    "duÇ’ chuÃ¡n": ["æ¤¯"],
    "wÄ›i huÄ«": ["æ¤²"],
    "jiÇŽ jiÄ": ["æ¤µ"],
    "hÃ¡n jiÄn": ["æ¤·"],
    "shÃ¨n zhÄ“n": ["æ¤¹"],
    "yÃ n yÃ ": ["æ¤»"],
    "zhÄ chÃ¡": ["æ¥‚"],
    "guÅ kuÇŽ": ["æ¥‡"],
    "jÃ­ zhÃ¬": ["æ¥–"],
    "kÇ” hÃ¹": ["æ¥›"],
    "yÃ³u yÇ’u": ["æ¥¢"],
    "sÇ’ng cÅng": ["æ¥¤"],
    "yuÃ¡n xuÃ n": ["æ¥¥"],
    "yÇŽng yÃ ng yÄ«ng": ["æ¥§"],
    piÃ¡n: ["æ¥©", "èƒ¼", "è…", "è³†", "è¹", "é§¢", "é¨ˆ", "éªˆ", "éª¿", "ã›¹"],
    "diÃ© yÃ¨": ["æ¥ª"],
    "dÃ¹n shÇ”n": ["æ¥¯"],
    "cÃ²u zÃ²u": ["æ¥±"],
    "dÃ¬ dÇ shÃ¬": ["æ¥´"],
    "kÇŽi jiÄ“": ["æ¥·"],
    "rÃ³u rÃ²u": ["æ¥º"],
    "lÃ¨ yuÃ¨": ["æ¥½"],
    "wÄ“n yÃ¹n": ["æ¦…", "éž°"],
    lÇ˜: ["æ¦ˆ", "æ«š", "æ°€", "è†¢", "è—˜", "é–­", "é—¾", "é©¢", "é©´"],
    shÃ©n: ["æ¦Š", "ç¥ž", "é‰®", "é°°", "ð¬¬¹"],
    "bÄ« pi": ["æ¦Œ"],
    "zhÇŽn niÇŽn zhÃ¨n": ["æ¦"],
    "fÃº fÃ¹ bÃ³": ["æ¦‘"],
    "jiÃ n jÃ¬n": ["æ¦—"],
    "bÇŽng bÃ ng": ["æ¦œ"],
    "shÄ xiÃ¨": ["æ¦", "æ¨§"],
    nÃ²u: ["æ§ˆ", "è€¨", "éŽ’", "éž"],
    "qiÇŽn liÃ¡n xiÃ n": ["æ§"],
    gÃ ng: ["æ§“", "ç„µ", "ç„¹", "ç­»", "é¿"],
    gÄo: [
      "æ§”",
      "æ§¹",
      "æ©°",
      "æ«œ",
      "ç¾",
      "ç¯™",
      "ç³•",
      "ç¾”",
      "è‡¯",
      "éŸŸ",
      "é¤»",
      "é«˜",
      "é«™",
      "é·Ž",
      "é·±",
      "é¼›"
    ],
    "diÄn zhÄ›n zhÄ“n": ["æ§™"],
    "kÇŽn jiÃ n": ["æ§›"],
    "xÃ­ diÃ©": ["æ§¢"],
    "jÄ« guÄ«": ["æ§£"],
    "rÃ³ng yÅng": ["æ§¦"],
    "tuÃ¡n shuÃ n quÃ¡n": ["æ§«"],
    "qÃ¬ sÃ¨": ["æ§­"],
    "cuÄ« zhÇ": ["æ§¯"],
    "yÇ’u chÇŽo": ["æ§±"],
    "mÃ n wÃ n": ["æ§¾"],
    "lÃ­ chÄ«": ["æ¨†"],
    "lÃ©i lÄ›i": ["æ¨", "æ«‘", "ç¤Œ"],
    "chÃ¡o jiÇŽo chÄo": ["æ¨”"],
    "chÄ“ng tÃ¡ng": ["æ¨˜"],
    "jiÅ« liÃ¡o": ["æ¨›"],
    "mÃ³ mÃº": ["æ¨¡"],
    "niÇŽo mÃ¹": ["æ¨¢"],
    "hÃ©ng hÃ¨ng": ["æ¨ª", "æ©«"],
    xuÄ›: ["æ¨°", "è†¤", "è‰", "è½Œ", "é›ª", "é±ˆ", "é³•"],
    "fÃ¡ fÃ¨i": ["æ©ƒ"],
    rÃ¹n: ["æ©", "æ¶¦", "æ½¤", "è†¶", "é–", "é– ", "é—°"],
    "zhÇŽn jiÇŽn": ["æ©"],
    shÃ¹n: ["æ©“", "çžš", "çž¬", "èˆœ", "è•£", "é †", "é¡º", "é¬Š"],
    "tuÃ­ dÅ«n": ["æ©”"],
    "tÃ¡ng chÄ“ng": ["æ©–"],
    "sÃ¹ qiÅ«": ["æ©š"],
    "tÃ¡n diÃ n": ["æ©"],
    "fÃ©n fÃ¨n fÃ¨i": ["æ©¨"],
    "rÇŽn yÄn": ["æ©ª"],
    "cÅ« chu": ["æ©»"],
    "shÅ« qiÄo": ["æ©¾"],
    "pÃ­ng bÃ²": ["æª˜"],
    "zhÃ¡i shÃ¬ tÃº": ["æª¡"],
    "biÇŽo biÄo": ["æª¦"],
    "qiÄn liÃ¡n": ["æª¶"],
    "nÇ mÃ­": ["æª·"],
    "jiÃ n kÇŽn": ["æª»"],
    "nÃ²u ruÇŽn rÃº": ["æª½"],
    "jÄ« jÃ¬": ["æ«…", "ç¦¨"],
    "huÇŽng guÇ’ gÇ”": ["æ«Ž"],
    "lÇœ chÅ«": ["æ«–"],
    "miÃ¨ mÃ¨i": ["æ«—"],
    Åu: [
      "æ«™",
      "æ¬§",
      "æ­",
      "æ®´",
      "æ¯†",
      "ç“¯",
      "ç”Œ",
      "è†’",
      "è—²",
      "è¬³",
      "è®´",
      "é‚",
      "é´Ž",
      "é·—",
      "é¸¥"
    ],
    "zhÃ¹ zhuÃ³": ["æ«¡"],
    "juÃ© jÃ¬": ["æ«­"],
    "huÃ¡i guÄ«": ["æ«°"],
    "chÃ¡n zhÃ n": ["æ¬ƒ"],
    "wÃ©i zuÃ¬": ["æ¬ˆ"],
    cÃ¡ng: ["æ¬Œ", "é‘¶"],
    "yÃ¹ yÃ¬": ["æ¬¥"],
    "chÃ¹ qÃ¹ xÃ¬": ["æ¬ª"],
    "kÃ i Ã i": ["æ¬¬"],
    "yÃ¬ yÄ«n": ["æ¬­"],
    "xÃ¬ kÃ i": ["æ¬¯"],
    "shuÃ² sÃ²u": ["æ¬¶"],
    "ÇŽi Ä“i Ã©i Ä›i Ã¨i ÃªÌ„ áº¿ ÃªÌŒ á»": ["æ¬¸"],
    "qÄ« yÄ«": ["æ¬¹"],
    "chuÄ xÅ«": ["æ¬»"],
    "chÇ chuÃ i": ["æ¬¼"],
    "kÇŽn qiÃ n": ["æ¬¿"],
    "kÇŽn kÃ¨": ["æ­"],
    "chuÇŽn chuÃ¡n": ["æ­‚"],
    "yÄ«n yÄn": ["æ­…"],
    "jÃ¬n qÅ«n": ["æ­"],
    pÄ“n: ["æ­•"],
    "xÅ« chuÄ": ["æ­˜"],
    "xÄ« shÃ¨": ["æ­™"],
    "liÇŽn hÄn": ["æ­›"],
    "zhÃ¬ chÃ­": ["æ­­"],
    "sÃ¨ shÃ ": ["æ­°"],
    sÇ: ["æ­»"],
    "wÄ›n mÃ²": ["æ­¾"],
    piÇŽo: ["æ®", "çš«", "çžŸ", "é†¥", "é¡ "],
    "qÃ­ng jÃ¬ng": ["æ®‘"],
    "fÇ’u bÃ³": ["æ®•"],
    "zhÃ­ shi": ["æ®–"],
    "yÃ¨ yÄn yÃ n": ["æ®—"],
    "hÅ«n mÃ¨i": ["æ®™"],
    chÃ²u: ["æ® ", "è‡°", "éš"],
    "kuÃ¬ huÃ¬": ["æ®¨", "æºƒ", "æ½°"],
    cuÃ n: ["æ®©", "ç†¶", "çˆ¨", "çªœ", "ç«„", "ç¯¡", "ç°’"],
    "yÄ«n yÄn yÇn": ["æ®·"],
    "qÃ¬ng kÄ“ng shÄ“ng": ["æ®¸"],
    "yÃ¡o xiÃ¡o xiÃ o": ["æ®½"],
    "gÅ« gÇ”": ["æ¯‚", "è›„"],
    "guÃ n wÄn": ["æ¯Œ"],
    "dÃº dÃ i": ["æ¯’"],
    "xÃºn xÃ¹n": ["æ¯¥"],
    mÃº: ["æ¯ª", "æ°"],
    "dÃ²u nuÃ²": ["æ¯­"],
    "sÄi suÄ«": ["æ¯¸"],
    lu: ["æ°‡"],
    sÃ o: ["æ°‰", "ç˜™", "çŸ‚", "é«ž"],
    "shÃ¬ zhÄ«": ["æ°"],
    "dÄ« dÇ": ["æ°"],
    "mÃ¡ng mÃ©ng": ["æ°“"],
    "yÃ¡ng rÃ¬": ["æ°œ"],
    shuÇ: ["æ°´", "æ°µ", "æ°º", "é––"],
    "zhÄ›ng chÃ©ng zhÃ¨ng": ["æ°¶"],
    tÇ”n: ["æ°½"],
    "fÃ¡n fÃ n": ["æ°¾"],
    "guÇ jiÇ”": ["æ°¿"],
    "bÄ«n pÃ  pÄ": ["æ±ƒ"],
    "zhuÃ³ quÃ¨": ["æ±‹"],
    "dÃ  tÃ i": ["æ±"],
    pÃ¬n: ["æ±–", "ç‰", "è˜"],
    "hÃ n hÃ¡n": ["æ±—", "é¦¯"],
    tu: ["æ±¢"],
    "tÄng shÄng": ["æ±¤", "æ¹¯"],
    "zhÄ« jÃ¬": ["æ±¥"],
    "gÃ n hÃ¡n cÃ©n": ["æ±µ"],
    "wÃ¨n mÃ©n": ["æ±¶"],
    "fÄng pÄng": ["æ±¸"],
    "hÇ” huÇŽng": ["æ±»"],
    "niÃº yÃ³u": ["æ±¼"],
    hÃ ng: ["æ²†"],
    "shÄ›n chÃ©n": ["æ²ˆ"],
    "dÃ¹n zhuÃ n": ["æ²Œ"],
    "nÇœ niÇ”": ["æ²‘"],
    "mÃ©i mÃ²": ["æ²’", "æ²¡"],
    "tÃ  dÃ¡": ["æ²“"],
    "mÃ¬ wÃ¹": ["æ²•"],
    "hÃ³ng pÄng": ["æ²—"],
    "shÄ shÃ ": ["æ²™"],
    "zhuÇ zÇ": ["æ²"],
    "Åu Ã²u": ["æ²¤", "æ¼š"],
    "jÇ” jÃ¹": ["æ²®"],
    "tuÅ duÃ³": ["æ²°"],
    "mÇ lÃ¬": ["æ²µ"],
    "yÃ­ chÃ­": ["æ²¶"],
    "xiÃ¨ yÃ¬": ["æ³„"],
    "bÃ³ pÅ": ["æ³Š"],
    "mÃ¬ bÃ¬": ["æ³Œ", "ç§˜"],
    "chÃ¹ shÃ¨": ["æ³"],
    "yÅu yÃ²u Äo": ["æ³‘"],
    "pÄ“ng pÃ­ng": ["æ³™", "ç¡‘"],
    "pÃ o pÄo": ["æ³¡"],
    "nÃ­ nÃ¬": ["æ³¥", "ç§œ"],
    "yuÃ¨ sÃ ": ["æ³§"],
    "juÃ© xuÃ¨": ["æ³¬", "ç–¦"],
    "lÃ³ng shuÄng": ["æ³·", "ç€§"],
    "luÃ² pÅ": ["æ³º", "æ¿¼"],
    "zÃ© shÃ¬": ["æ³½", "æ¾¤"],
    "sÇŽ xÇ": ["æ´’"],
    "sÃ¨ qÃ¬ zÃ¬": ["æ´“"],
    "xÇ xiÇŽn": ["æ´—"],
    "kÇŽo kÃ o": ["æ´˜"],
    "Ã n yÃ n Ã¨": ["æ´"],
    "lÄ›i lÃ¨i": ["æ´¡"],
    "qiÃ¨ jiÃ©": ["æ´¯"],
    "qiÇŽn jiÄn": ["æµ…"],
    "jÃ¬ jÇ": ["æµŽ", "æ¸ˆ", "æ¿Ÿ", "çºª"],
    "hÇ” xÇ”": ["æµ’", "æ»¸"],
    "jÃ¹n xÃ¹n": ["æµš", "æ¿¬"],
    "yÇng chÃ©ng yÃ­ng": ["æµ§"],
    "liÃ n lÃ¬": ["æµ°"],
    "fÃ©ng hÃ³ng": ["æµ²", "æº„"],
    "jiÇ’ng jiÅng": ["æµ»"],
    "suÄ« nÄ›i": ["æµ½"],
    "yÇ’ng chÅng": ["æ¶Œ"],
    "tÅ«n yÅ«n": ["æ¶’"],
    "wÅ guÅ": ["æ¶¡", "æ¸¦"],
    hÄ“ng: ["æ¶¥", "è„"],
    "zhÇŽng zhÃ ng": ["æ¶¨", "æ¼²"],
    "shÃ²u tÄo": ["æ¶­"],
    shuÃ n: ["æ¶®", "è…¨"],
    "kÅng nÃ¡ng": ["æ¶³"],
    "wÃ² wÇŽn yuÄn": ["æ¶´"],
    "tuÅ tuÃ²": ["æ¶¶"],
    wÅ: ["æ¶¹", "çŒ§", "çª", "çª©", "èŽ´", "èµ", "èœ—", "è¸", "è¸’"],
    "qiÃ¨ jÃ­": ["æ·"],
    "guÇ’ guÃ n": ["æ·‰"],
    "lÃ­n lÃ¬n": ["æ·‹", "çœ", "ç–„"],
    "tÇŽng chÇŽng": ["æ·Œ"],
    "nÃ o chuÃ² zhuÅ": ["æ·–"],
    "pÃ©ng pÃ­ng": ["æ·œ"],
    fÃ©i: ["æ·", "è‚¥", "è…“", "èœ°"],
    "pÃ¬ pÃ¨i": ["æ· "],
    "niÇŽn shÄ›n": ["æ·°"],
    "biÄo hÇ”": ["æ·²"],
    "chÃºn zhÅ«n": ["æ·³"],
    "hÃ¹n hÃºn": ["æ··"],
    qiÇŽn: ["æ·º", "ç¹¾", "ç¼±", "è‚·", "è†", "èœ¸", "è­´", "è°´", "é£", "é‘“"],
    "wÃ¨n mÃ­n": ["æ¸‚"],
    "rÃ¨ ruÃ² luÃ²": ["æ¸ƒ"],
    "dÃº dÃ²u": ["æ¸Ž", "ç€†", "è¯»"],
    "jiÃ n jiÄn": ["æ¸", "æº…", "æ¼¸", "æ¿º"],
    "miÇŽn shÃ©ng": ["æ¸‘", "æ¾ "],
    "nuÇŽn nuÃ¡n": ["æ¸œ"],
    "qiÃº wÃ¹": ["æ¸ž"],
    "tÃ­ng tÄ«ng": ["æ¸Ÿ"],
    "dÃ¬ tÃ­ dÄ«": ["æ¸§"],
    "gÇŽng jiÇŽng": ["æ¸¯"],
    "hÅng qÃ¬ng": ["æ¸¹"],
    tuÄn: ["æ¹", "ç…“"],
    "huÃ¬ mÇn xÅ«": ["æ¹"],
    "xÇ” xÃ¹": ["æ¹‘"],
    pÃ©n: ["æ¹“", "ç“«", "ç›†", "è‘"],
    "mÇn hÅ«n": ["æ¹£"],
    "tuÃ n nuÇŽn": ["æ¹ª"],
    "qiÅ« jiÇŽo": ["æ¹«", "æ¹¬"],
    "yÄn yÄ«n": ["æ¹®"],
    "bÃ n pÃ¡n": ["æ¹´"],
    "zhuÄng hÃºn": ["æ¹·"],
    "yÃ n guÃ¬": ["æºŽ"],
    "liÃ¡n liÇŽn niÃ¡n xiÃ¡n xiÃ n": ["æº“"],
    "dÃ¡ tÇŽ": ["æºš", "é¿Ž"],
    "liÅ« liÃ¹": ["æºœ", "æ¾‘", "è¹“"],
    lÃ¹n: ["æº£"],
    mÇŽ: [
      "æº¤",
      "çŠ¸",
      "ç",
      "çŽ›",
      "ç‘ª",
      "ç ",
      "ç¢¼",
      "é¤",
      "éŽ·",
      "é¦¬",
      "é©¬",
      "é°¢",
      "é·Œ"
    ],
    "zhÄ“n qÃ­n": ["æº±"],
    "nÃ¬ niÃ o": ["æºº"],
    "chÃ¹ xÃ¹": ["æ»€", "ç•œ"],
    "wÄ›ng wÄ“ng": ["æ»ƒ"],
    "hÃ o xuÃ¨": ["æ»ˆ"],
    "qÃ¬ xÃ¬ xiÄ“": ["æ»Š"],
    "xÃ­ng yÃ­ng": ["æ»Ž"],
    "zÃ© hÃ o": ["æ»œ"],
    "piÄo piÃ o piÇŽo": ["æ¼‚"],
    "cÃ³ng sÇ’ng": ["æ¼Ž"],
    "fÃ©ng pÃ©ng": ["æ¼¨"],
    "luÃ² tÃ ": ["æ¼¯"],
    "pÄ“ng bÄ“n": ["æ¼°"],
    "chÃ³ng shuÄng": ["æ¼´"],
    "huÇ’ kuÃ² huÃ²": ["æ¼·"],
    "liÃ¡o liÃº": ["æ¼»"],
    "cuÇ cuÄ«": ["æ¼¼"],
    "cÃ³ng zÇ’ng": ["æ½€"],
    "cÃ³ng zÅng": ["æ½ˆ"],
    "pÃ¬ piÄ“": ["æ½Ž"],
    "dÃ ng xiÃ ng": ["æ½’"],
    "huÃ¡ng guÄng": ["æ½¢"],
    "liÃ¡o lÃ o lÇŽo": ["æ½¦"],
    "cÅng zÃ²ng": ["æ½¨"],
    "zhÃ­ zhÃ¬": ["æ½ª"],
    "tÄn shÃ n": ["æ½¬"],
    "tÃº zhÄ": ["æ½³"],
    "sÃ n sÇŽ": ["æ½µ"],
    hÄ“i: ["æ½¶", "é»‘", "é»’", "ð¬­¶"],
    "chÃ©ng dÃ¨ng": ["æ¾„", "ç€“"],
    "cÅ«n cÃºn": ["æ¾Š"],
    "pÃ©ng pÄ“ng": ["æ¾Ž"],
    "hÃ²ng gÇ’ng": ["æ¾’", "éŠ¾"],
    "wÃ n mÃ n": ["æ¾«"],
    "kuÃ i huÃ¬": ["æ¾®"],
    "guÅ wÅ": ["æ¿„"],
    "pÄ“n fÃ©n": ["æ¿†"],
    "jÃ­ shÃ ": ["æ¿ˆ"],
    "huÃ¬ huÃ²": ["æ¿Š"],
    "dÇng tÃ¬ng": ["æ¿Ž"],
    "mÇ nÇ": ["æ¿”"],
    "bÃ¬ pÃ¬": ["æ¿ž"],
    "cuÃ¬ zuÇ": ["æ¿¢"],
    "hÃ¹ huÃ²": ["æ¿©"],
    "ÇŽi kÃ i kÃ¨": ["æ¿­"],
    "wÄ›i duÃ¬": ["æ¿»", "ç€¢"],
    "zÃ n cuÃ¡n": ["æ¿½", "ç’"],
    "yÇŽng yÃ ng": ["ç€"],
    "wÇŽng wÄng": ["ç€‡"],
    "mÃ² miÃ¨": ["ç€Ž", "çœœ"],
    suÇ: ["ç€¡", "è†¸", "é«“"],
    "huÃ¡i wÄi": ["ç€¤"],
    "zÃ¹n jiÃ n": ["ç€³"],
    "yÄ«ng yÇng yÃ¬ng": ["ç€´"],
    "rÃ¡ng rÃ ng": ["ç€¼"],
    shuÃ ng: ["ç€"],
    "zhuÃ³ jiÃ o zÃ©": ["ç‚"],
    sÇŽ: ["ç‘", "è¨¯", "é¸"],
    "luÃ¡n luÃ n": ["ç“"],
    "dÇŽng tÇŽng": ["ç™"],
    "xÃºn quÃ¡n quÃ n": ["ç¥"],
    "huÇ’ biÄo": ["ç¬"],
    "zhÃ  yÃ¹": ["ç¹"],
    "fÃ©n bÃ¨n": ["ç‚ƒ"],
    "jiÇ’ng guÃ¬": ["ç‚…"],
    "pÃ ng fÄ“ng": ["ç‚"],
    quÄ“: ["ç‚”", "ç¼º", "ç¼¼", "è’›"],
    biÄn: [
      "ç‚ž",
      "ç…¸",
      "ç”‚",
      "ç ­",
      "ç¬¾",
      "ç®¯",
      "ç±©",
      "ç·¨",
      "ç¼–",
      "è™",
      "é‚‰",
      "é‚Š",
      "é½",
      "éž­",
      "é¯¾",
      "é¯¿",
      "é³Š"
    ],
    "zhÄo zhÃ o": ["ç‚¤"],
    "zhuÅ chÃ¹": ["ç‚ª"],
    "pÃ o pÃ¡o bÄo": ["ç‚®"],
    "pÃ¡o fÇ’u": ["ç‚°"],
    "shÇŽn qiÃ¡n shÄn": ["ç‚¶"],
    "zhÃ  zhÃ¡": ["ç‚¸"],
    "jiÇŽo yÃ o": ["çƒ„"],
    quÇŽn: ["çƒ‡", "çŠ¬", "çŠ­", "ç•Ž", "ç¶£", "ç»»", "è™‡"],
    "yÃ ng yÃ¡ng": ["çƒŠ"],
    "lÃ o luÃ²": ["çƒ™"],
    "huÃ­ huÇ": ["çƒ "],
    rÃ¨: ["çƒ­", "ç†±"],
    "fÃº pÃ¡o": ["çƒ°"],
    "xiÃ¨ chÃ¨": ["çƒ²", "ç„Ž"],
    "yÃ n shÄn": ["çƒ»"],
    "hÅ«n xÅ«n": ["ç„„"],
    kÃ o: ["ç„…", "çŠ’", "éŠ¬", "é“", "é ", "é®³", "é¯Œ", "é²“", "ã¸†"],
    "juÄn yÃ¨": ["ç„†"],
    "jÃ¹n qÅ«": ["ç„Œ"],
    "tÄo dÃ o": ["ç„˜"],
    "chÇŽo jÃ¹": ["ç„£"],
    "wÃ² Ã i": ["ç„¥"],
    "zÇ’ng cÅng": ["ç„§"],
    "xÄ« yÃ¬": ["ç„¬"],
    "xÃ¬n xÄ«n": ["ç„®"],
    "chÄo zhuÅ": ["ç„¯"],
    "xiÇ’ng yÄ«ng": ["ç„¸", "ç„½"],
    kuÇ: ["ç…ƒ", "è·¬", "è¹ž", "é ", "ð« †"],
    "huÄ« yÃ¹n xÅ«n": ["ç…‡"],
    "jiÇŽo qiÄo": ["ç…"],
    "qiÃ¡n shÇŽn shÄn": ["ç…”"],
    "xÄ« yÃ­": ["ç…•"],
    "shÃ  shÄ": ["ç…ž"],
    "yÃ¨ zhÃ¡": ["ç… "],
    "yÃ¡ng yÃ ng": ["ç…¬"],
    "Ä“n yÅ«n": ["ç…¾"],
    "yÅ«n yÇ”n": ["ç†…"],
    "hÃ¨ xiÄo": ["ç†‡"],
    xiÃ³ng: ["ç†Š", "ç†‹", "é›„"],
    "xÅ«n xÃ¹n": ["ç†", "çˆ‹"],
    gÃ²ng: ["ç†•", "è²¢", "è´¡"],
    liÅ«: ["ç†˜"],
    "cÅng zÇ’ng": ["ç†œ"],
    "lÃ¹ Äo": ["ç†"],
    "shÃº shÃ³u": ["ç†Ÿ"],
    "fÄ“ng pÃ©ng": ["ç†¢"],
    "cuÇ suÄ«": ["ç†£"],
    tÄ“ng: ["ç†¥", "è†¯", "é¼Ÿ"],
    "yÃ¹n yÃ¹": ["ç†¨"],
    "Ã¡o Äo": ["ç†¬"],
    "hÃ n rÇŽn": ["ç†¯"],
    "Åu Ç’u": ["ç†°"],
    "huÃ¡ng huÇŽng": ["ç†¿"],
    "chÇŽn dÇŽn chÃ n": ["ç‡€"],
    "jiÄo zhuÃ³ qiÃ¡o juÃ©": ["ç‡‹"],
    "yÃ n yÄn": ["ç‡•"],
    "tÃ i liÃ¨": ["ç‡¤"],
    Äo: ["çˆŠ"],
    "yÃ n xÃºn": ["çˆ“"],
    "juÃ© jiÃ o": ["çˆ", "è¦", "è¦š", "è¦º", "è§‰"],
    "lÇŽn lÃ n": ["çˆ¦"],
    "zhuÇŽ zhÇŽo": ["çˆª"],
    "zhÇŽo zhuÇŽ": ["çˆ«"],
    "fÃ¹ fÇ”": ["çˆ¶"],
    diÄ“: ["çˆ¹", "è¤º", "è·Œ"],
    zÄng: ["ç‰‚", "ç¾˜", "è‡§", "è³", "è³˜", "è´“", "è´œ", "èµƒ", "é«’"],
    "piÃ n piÄn": ["ç‰‡"],
    "biÄn miÃ n": ["ç‰‘"],
    bÇŽng: ["ç‰“", "ç¶", "ç»‘"],
    "yÇ’u yÅng": ["ç‰—"],
    "chÄ“ng chÃ¨ng": ["ç‰š", "ç«€"],
    niÃº: ["ç‰›", "ç‰œ"],
    "jiÅ« lÃ¨": ["ç‰ž"],
    "mÃ¹ mÃ³u": ["ç‰Ÿ"],
    mÄng: ["ç‰¤"],
    "gÄ“ qiÃº": ["ç‰«"],
    "yÃ²u chÅu": ["ç‰°"],
    "tÃ¨ zhÃ­": ["çŠ†"],
    bÄ“n: ["çŠ‡", "éŒ›", "é”›"],
    "jiÄn qiÃ¡n": ["çŠ", "çŽª"],
    mÃ¡: ["çŠ˜", "ç—²", "è”´", "èŸ‡", "éº»"],
    "mÃ¡o lÃ­": ["çŠ›"],
    "bÃ¡ quÇŽn": ["çŠ®"],
    "zhuÃ³ bÃ o": ["çŠ³"],
    "Ã n hÄn": ["çŠ´"],
    "kÃ ng gÇŽng": ["çŠº"],
    "pÃ¨i fÃ¨i": ["çŠ»"],
    "fÄn huÄn": ["çŠ¿"],
    kuÃ¡ng: ["ç‹‚", "ç‹…", "èª‘", "è¯³", "è»–", "è» ", "éµŸ", "ð«›­"],
    "yÃ­ quÃ¡n chÃ­": ["ç‹‹"],
    "xÄ«ng shÄ“ng": ["ç‹Œ"],
    "tuÃ³ yÃ­": ["ç‹"],
    kÇ”: ["ç‹œ", "è‹¦"],
    "huÃ¡n huÄn": ["ç‹Ÿ"],
    "hÃ© mÃ²": ["ç‹¢"],
    "tÃ  shÃ¬": ["ç‹§"],
    "mÃ¡ng dÃ²u": ["ç‹µ"],
    "xÄ« shÇ": ["ç‹¶"],
    suÄn: ["ç‹»", "ç— ", "é…¸"],
    "bÃ i pÃ­": ["çŒˆ"],
    "jiÄn yÃ n": ["çŒ", "è±£"],
    "yÄ« yÇ": ["çŒ—"],
    "yÃ¡ wÃ¨i": ["çŒš"],
    cÄi: ["çŒœ"],
    "mÄo mÃ¡o": ["çŒ«", "è²“"],
    "chuÃ n chuÄn": ["çŒ­"],
    "tuÄn tuÃ n": ["çŒ¯", "è²’"],
    "yÃ  jiÃ¡ qiÃ¨": ["çŒ°"],
    "hÃ¨ xiÄ“ gÃ© hÃ i": ["çŒ²"],
    "biÄn piÃ n": ["çŒµ", "ç±"],
    "bÃ³ pÃ²": ["çŒ¼"],
    "hÃ¡o gÄo": ["ç‹"],
    "fÃ©n fÃ¨n": ["ç–"],
    "yÃ o xiÄo": ["çŸ"],
    "shuÃ² xÄ«": ["ç¡"],
    "gÃ© liÃ¨ xiÄ“": ["ç¦"],
    "nÃ²u rÃº": ["ç³"],
    "nÃ¡o nÇŽo yÅu": ["ç¶"],
    rÃ¡ng: ["ç½", "ç“¤", "ç¦³", "ç©£", "ç©°", "è˜˜", "èºŸ", "é¬¤"],
    "nÃ¡o yÅu": ["ç¿"],
    "lÇœ shuÃ i": ["çŽ‡"],
    "wÃ¡ng wÃ ng": ["çŽ‹"],
    "yÃ¡ng chÃ ng": ["çŽš"],
    "mÃ­n wÃ©n": ["çŽŸ"],
    "bÄ«n fÄ“n": ["çŽ¢"],
    "mÃ©n yÇ”n": ["çŽ§"],
    "qiÄng cÄng": ["çŽ±", "ç‘²", "ç¯¬"],
    "Ã¡n gÄn": ["çŽµ"],
    "xuÃ¡n xiÃ¡n": ["çŽ¹"],
    "cÄ« cÇ": ["çŽ¼", "è·"],
    "yÃ­ tÄi": ["ç†"],
    "zÇ” jÃ¹": ["ç‡"],
    fÃ : ["ç", "çº", "è•Ÿ", "é«ª", "é«®"],
    "yÃ­n kÃ¨n": ["ç¢"],
    "huÄ« hÃºn": ["ç²"],
    "xuÃ¡n qiÃ³ng": ["ç"],
    "fÃº fÅ«": ["çˆ"],
    "bÇng pÃ­n": ["ç•"],
    "cuÃ¬ sÃ¨": ["ç—"],
    "yÃ¹ wÃ©i": ["çŸ"],
    "tiÇŽn tiÃ n": ["ç "],
    "zhuÃ³ zuÃ³": ["ç¢"],
    "bÄ›ng pÄ›i": ["ç£"],
    guÇŽn: ["ç¯", "ç’­", "ç—¯", "ç­¦", "ç®¡", "èˆ˜", "è¼¨", "éŒ§", "é¤¨", "é¦†", "é³¤"],
    "hÃºn huÄ«": ["ç¿"],
    "xiÃ© jiÄ“": ["ç‘Ž"],
    "chÃ ng dÃ ng yÃ¡ng": ["ç‘’"],
    "tiÃ n zhÃ¨n": ["ç‘±"],
    "bÄ«n piÃ¡n": ["ç‘¸", "ç’¸"],
    "tÃº shÅ«": ["ç‘¹"],
    cuÇ: ["ç’€", "çš ", "è¶¡"],
    "zÇŽo suÇ’": ["ç’…"],
    "juÃ© qiÃ³ng": ["ç’š"],
    "lÃº fÅ«": ["ç’·"],
    "jÃ¬ zÄ«": ["ç’¾"],
    suÃ­: ["ç“", "ç¶", "ç»¥", "é€", "éš", "éš¨", "é«„"],
    "mÃ­ xÇ": ["ç“•"],
    "qiÃ³ng wÄ›i wÃ¨i": ["ç“—"],
    "huÃ¡n yÃ¨ yÃ ": ["ç“›"],
    "bÃ³ pÃ¡o": ["ç“Ÿ"],
    "zhÃ­ hÃº": ["ç“¡"],
    piÃ¡o: ["ç“¢", "é—"],
    "wÇŽ wÃ ": ["ç“¦"],
    "xiÃ¡ng hÃ³ng": ["ç“¨"],
    wÃ¨ng: ["ç“®", "ç”•", "ç½‹", "è•¹", "é½†"],
    "shÃ¨n shÃ©n": ["ç”š"],
    ruÃ­: ["ç”¤", "ç·Œ", "è•¤"],
    yÃ²ng: ["ç”¨", "ç ½", "è‹š", "è’", "é†Ÿ", "ã¶²"],
    shuÇŽi: ["ç”©"],
    bÃ©ng: ["ç”­", "ç”®"],
    "yÃ³u zhÃ¡": ["ç”´"],
    "diÃ n tiÃ¡n shÃ¨ng": ["ç”¸"],
    "tÇng dÄ«ng": ["ç”º", "ç”¼"],
    "zÄi zÄ«": ["ç”¾"],
    "bÃ¬ qÃ­": ["ç•"],
    "dÃ¡ fÃº": ["ç•—"],
    "cÃ¨ jÃ¬": ["ç•Ÿ"],
    "zÄi zÄ« tiÃ¡n": ["ç• "],
    "zhÃ¬ chÃ³u shÃ¬": ["ç•¤"],
    "fÄn pÄn": ["ç•¨", "ç•ª"],
    "shÄ“ yÃº": ["ç•¬"],
    "dÄng dÃ ng dÇŽng": ["ç•¶"],
    "jiÄng qiÃ¡ng": ["ç–†"],
    "pÇ yÇŽ shÅ«": ["ç–‹"],
    "jiÃ© qiÃ¨": ["ç–Œ"],
    "yÃ­ nÇ": ["ç–‘"],
    nÃ¨: ["ç–’", "çœ²", "è¨¥", "è®·"],
    "gÄ“ yÃ¬": ["ç–™"],
    "nÃ¼Ã¨ yÃ o": ["ç–Ÿ", "ç˜§"],
    "lÃ¬ lÃ i": ["ç– ", "ç™˜"],
    "yÇŽ xiÄ": ["ç–¨"],
    xuÄ“: ["ç–¶", "è’†", "è–›", "è¾¥", "è¾ª", "é´", "éž¾"],
    "dÇŽn da": ["ç–¸"],
    "fÃ¡ biÇŽn": ["ç–º"],
    "fÃ¨i fÃ©i": ["ç–¿", "ç—±"],
    "shÄn diÃ n": ["ç—"],
    "tÃ©ng chÃ³ng": ["ç—‹"],
    "tÅng tÃ³ng": ["ç—Œ"],
    "wÄ›i yÃ²u yÃ¹": ["ç—"],
    "tÄn shÇ": ["ç—‘"],
    "pÅ« pÃ¹": ["ç—¡", "é‹ª"],
    "bÄ“ng pÃ©ng": ["ç—­"],
    "mÃ¡ lÃ¬n": ["ç—³"],
    "tiÇŽn diÃ n": ["ç—¶"],
    "Än yÃ¨ Ã¨": ["ç—·"],
    "kÄ“ Ä“": ["ç—¾"],
    "zhÃ¬ chÃ¬": ["ç˜ˆ"],
    "jiÇŽ xiÃ¡ xiÄ": ["ç˜•"],
    "lÄ›i huÃ¬": ["ç˜£"],
    "chÃ i cuÃ³": ["ç˜¥"],
    "diÄn chÄ“n": ["ç˜¨"],
    "da dÃ¡": ["ç˜©"],
    "biÄ› biÄ“": ["ç˜ª"],
    quÃ©: ["ç˜¸"],
    "dÃ n dÄn": ["ç™‰"],
    "guÃ¬ wÄ“i": ["ç™"],
    "nÃ²ng nÃ³ng": ["ç™‘"],
    "biÄ“ biÄ›": ["ç™Ÿ"],
    "bÅ bÇ’": ["ç™·"],
    bÃ¡i: ["ç™½"],
    "jÃ­ bÄ«": ["çš€"],
    "de dÃ¬ dÃ­ dÄ«": ["çš„"],
    "pÄ bÃ ": ["çš…"],
    "gÄo hÃ¡o": ["çš‹"],
    "gÄo yÃ¡o": ["çš"],
    "lÃ¬ luÃ² bÅ": ["çšª"],
    "zhÄ cÇ”": ["çš»"],
    "zhÄo zhÇŽn dÇŽn": ["çš½"],
    "jiÄn jiÃ n": ["ç›‘", "ç›£", "é‹»", "é—´", "éž¬"],
    "gÃ i gÄ› hÃ©": ["ç›–"],
    "mÃ¡ng wÃ ng": ["ç›³"],
    yuÇŽn: ["ç›¶", "é€º", "é "],
    "tiÃ¡n xiÃ¡n": ["ç›·"],
    "xiÄng xiÃ ng": ["ç›¸"],
    dÇ”n: ["ç›¹", "è¶¸", "èº‰"],
    "xÃ¬ pÇŽn": ["ç›»"],
    "shÄ›ng xÇng": ["çœ"],
    "yÃºn hÃ¹n": ["çœƒ"],
    "miÇŽn miÃ n": ["çœ„"],
    "kÃ n kÄn": ["çœ‹"],
    "yÃ¬ng yÄng yÇŽng": ["çœ"],
    "yÇŽo Äo ÇŽo": ["çœ‘"],
    "jÅ« xÅ« kÅu": ["çœ—"],
    "yÃ­ chÃ¬": ["çœ™"],
    "diÃ© tÃ¬": ["çœ£"],
    "bÇng fÇŽng": ["çœª"],
    "pÃ ng pÃ¡n": ["çœ«"],
    "mÄ« mÃ­": ["çœ¯", "çž‡"],
    "xuÃ n shÃ¹n xÃºn": ["çœ´"],
    tiÃ o: ["çœº", "ç²œ", "ç³¶", "è¦œ", "è¶’"],
    "zhe zhuÃ³ zhÃ¡o zhÄo": ["ç€"],
    "qiÃ¡o shÃ o xiÄo": ["ç„"],
    "cuÃ³ zhuÃ i": ["ç‰"],
    gÃ¹n: ["ç”", "è¬´"],
    "suÃ¬ zuÃ¬": ["çŸ"],
    "pÃ¬ bÃ¬": ["ç¥", "ç¨«", "è¾Ÿ"],
    "yÃ¬ zÃ© gÄo": ["çª"],
    "xÇng xÃ¬ng": ["ç²"],
    "guÃ¬ wÃ¨i kuÃ¬": ["çž†"],
    "kÃ²u jÃ¬": ["çž‰"],
    "qiÃ³ng huÃ¡n": ["çž"],
    "mÃ¡n mÃ©n": ["çž’", "çžž"],
    "diÄo dÅu": ["çž—"],
    "lou lÃ³u lÇ˜": ["çžœ"],
    "shÃ¹n rÃºn": ["çž¤"],
    "liÃ o liÇŽo": ["çž­", "é’Œ"],
    "jiÃ n xiÃ¡n": ["çž¯"],
    "wÇ” mÃ­": ["çž´"],
    "guÃ¬ kuÃ¬": ["çž¶"],
    "nÇng chÄ“ng": ["çŸƒ"],
    "huÃ² yuÃ¨": ["çŸ†"],
    "mÄ“ng mÃ©ng": ["çŸ‡"],
    "kuÃ ng guÅ": ["çŸŒ"],
    "guÃ n quÃ¡n": ["çŸ”"],
    "mÇŽn mÃ¡n": ["çŸ•"],
    "jÄ«n guÄn qÃ­n": ["çŸœ"],
    "jÄ«n qÃ­n guÄn": ["çŸ"],
    "yÃ¹ xÃ¹ juÃ©": ["çŸž"],
    "jiÇŽo jiÃ¡o": ["çŸ«", "çŸ¯"],
    duÇŽn: ["çŸ­"],
    "shÃ­ dÃ n": ["çŸ³"],
    "gÄng qiÄng kÃ²ng": ["çŸ¼"],
    "huÄ xÅ«": ["ç ‰"],
    "pÄ«n bÄ«n fÄ“n": ["ç "],
    "yÃ¡n yÃ n": ["ç ”", "ç¡"],
    "luÇ’ kÄ“": ["ç ¢"],
    "fÃº fÃ¨i": ["ç ©", "ç¬°"],
    "zhÇ” zhÃ¹": ["ç «"],
    "lÃ¡ lÃ¬ lÄ": ["ç ¬"],
    "kuÄng guÄng": ["ç¡„"],
    "gÃ¨ luÃ²": ["ç¡Œ"],
    "shuÃ² shÃ­": ["ç¡•", "ç¢©"],
    "wÃ¨i wÃ©i Ã¡i": ["ç¡™"],
    "quÃ¨ kÃ¨ kÃ¹": ["ç¡ž"],
    "mÇŽng bÃ ng": ["ç¡¥"],
    "luÃ² lÃ²ng": ["ç¡¦"],
    "yÇ’ng tÃ³ng": ["ç¡§"],
    nÃ¼Ã¨: ["ç¡¸", "è™"],
    "kÄ“ng kÄ›ng": ["ç¡»"],
    "yÄn yÇŽn": ["ç¡½"],
    "zhuÃ¬ chuÃ­ duÇ’": ["ç¡¾"],
    "kÅng kÃ²ng": ["ç¡¿"],
    "zÃ²ng cÃ³ng": ["ç¢‚"],
    "jiÄn zhÃ n": ["ç¢Š"],
    "lÃ¹ liÃ¹": ["ç¢Œ", "é™†"],
    "quÃ¨ xÄ«": ["ç¢"],
    "lÃºn lÇ”n lÃ¹n": ["ç¢–"],
    "nÃ¡o gÄng": ["ç¢™"],
    "jiÃ© yÃ ": ["ç¢£"],
    "wÃ¨i wÄ›i": ["ç¢¨"],
    "tÃ­ dÄ«": ["ç¢®"],
    "chÃ¡ chÄ": ["ç¢´"],
    "qiÄo quÃ¨": ["ç¢»"],
    "sÃ¹ xiÃ¨": ["ç¢¿"],
    "liÃº liÃ¹": ["ç£‚", "é›", "éŽ¦", "é¦"],
    "sÄ« tÃ­": ["ç£ƒ"],
    "bÃ ng pÃ¡ng": ["ç£…"],
    "huÃ¡ kÄ› gÅ«": ["ç£†"],
    "wÄ›i kuÇ": ["ç£ˆ"],
    "xiÃ¡ qiÃ  yÃ ": ["ç£"],
    "liÃ¡n qiÄn": ["ç£"],
    "wÃ¨i Ã¡i gÃ i": ["ç£‘"],
    "lÃ¡ lÄ": ["ç£–"],
    "Ã¡o qiÄo": ["ç£"],
    "pÄ“ng pÃ¨ng": ["ç£ž", "é–›"],
    "yÄ«n yÇn": ["ç£¤"],
    "lÄ›i lÃ©i": ["ç£¥"],
    "mÃ³ mÃ²": ["ç£¨"],
    "qÃ¬ zhÃº": ["ç£©"],
    "lÃ¡o luÃ²": ["ç£±"],
    "pÃ¡n bÅ": ["ç£»"],
    "jÃ­ shÃ©": ["ç£¼"],
    "hÃ© qiÄo qiÃ o": ["ç¤‰"],
    "kÃ¨ huÃ²": ["ç¤Š"],
    "quÃ¨ hÃº": ["ç¤"],
    "Ã¨ qÃ¬": ["ç¤˜"],
    cÇŽ: ["ç¤¤", "ç¤¸"],
    "xiÃ¡n xÃ­n": ["ç¤¥"],
    "lÃ©i lÄ›i lÃ¨i": ["ç¤§"],
    "yÃ¡n yÇŽn": ["ç¤¹"],
    "qÃ­ zhÇ": ["ç¥‡", "èš”"],
    "bÄ“ng fÄng": ["ç¥Š"],
    "bÃ¬ mÃ¬": ["ç¥•"],
    suÃ n: ["ç¥˜", "ç¬‡", "ç­­", "ç®—", "è’œ"],
    "piÃ o piÄo": ["ç¥¨"],
    "jÃ¬ zhÃ i": ["ç¥­"],
    "shuÃ¬ lÃ¨i": ["ç¥±"],
    "jÃ¬n jÄ«n": ["ç¦"],
    "chÃ¡n shÃ n": ["ç¦…"],
    "yÃ¡ng shÄng": ["ç¦“"],
    "zhÄ« zhÇ tÃ­": ["ç¦”"],
    "shÃ n chÃ¡n": ["ç¦ª"],
    "yÃº yÃ¹ Ç’u": ["ç¦º"],
    "zÇ zÃ¬": ["ç§„"],
    "chÃ¡ nÃ¡": ["ç§…"],
    "zhÇ’ng zhÃ²ng chÃ³ng": ["ç§"],
    "hÃ o mÃ o": ["ç§"],
    "kÃ¹ kÅ«": ["ç§™"],
    zÅ«: ["ç§Ÿ", "è‘…"],
    chÃ¨ng: ["ç§¤", "ç©ª"],
    "huÃ³ kuÃ²": ["ç§®", "ç§³"],
    "chÄ“ng chÃ¨n chÃ¨ng": ["ç§°", "ç¨±"],
    "shÃ¬ zhÃ¬": ["ç§²", "éŠ´"],
    "fÃ¹ pÅ«": ["ç§¿"],
    "xÃ¹n zÃ¨": ["ç¨„"],
    "tÃº shÇ”": ["ç¨Œ"],
    "zhÃ¹n zhÇ”n": ["ç¨•"],
    "jÄ« qÃ­": ["ç¨˜", "ç¶¨", "è§­"],
    "lÃ©ng lÃ­ng": ["ç¨œ"],
    "zuÃ¬ zÃº sÅ«": ["ç¨¡"],
    "xÃ¬ qiÃ¨": ["ç¨§", "éƒ„"],
    "zhÇ’ng zhÃ²ng": ["ç¨®"],
    "zÅng zÇ’ng": ["ç¨¯"],
    "xiÃ¡n jiÄn liÃ n": ["ç¨´"],
    "zÄ« jiÅ«": ["ç¨µ"],
    "jÄ« qÇ": ["ç¨½"],
    rÃ²ng: ["ç©ƒ"],
    "shÄn cÇŽn cÄ“n": ["ç©‡"],
    "mÃ©n mÃ©i": ["ç©ˆ"],
    "jÇ jÃ¬": ["ç©–"],
    "xiÄo rÃ o": ["ç©˜"],
    "zhuÅ bÃ³": ["ç©›"],
    "tÃ³ng zhÇ’ng zhÃ²ng": ["ç©œ"],
    zuÅ: ["ç©"],
    "biÄo pÄo": ["ç©®", "è—¨"],
    "zhuÅ juÃ©": ["ç©±"],
    "cuÃ¡n zÃ n": ["ç©³"],
    "kÅng kÃ²ng kÇ’ng": ["ç©º"],
    "yÅ« yÇ”": ["ç©»"],
    zhÇŽi: ["çª„", "é‰™"],
    bÃ¡o: ["çª‡", "é›¹"],
    "kÅ« zhÃº": ["çª‹"],
    "jiÃ o liÃ¡o liÃ¹": ["çªŒ"],
    "wÄ guÄ«": ["çª"],
    "tiÇŽo yÃ¡o": ["çª•"],
    "xÅ«n yÃ¬n": ["çª¨"],
    "yÃ  yÄ“": ["çª«"],
    "tiÃ¡n diÄn yÇŽn": ["çª´"],
    "chÄo kÄ“": ["çª¼"],
    "kuÇŽn cuÃ n": ["çª½", "çª¾"],
    "chÃ¹ qÃ¬": ["ç«"],
    "qÇ” kÇ’u": ["ç«˜"],
    "jÃ¬ng zhÄ›n": ["ç«§"],
    "kÇŽn kÃ n": ["ç«·"],
    "zhÃº dÇ”": ["ç«º"],
    "lÃ¨ jÄ«n": ["ç«»"],
    "zhuÃ¬ ruÃ¬": ["ç¬"],
    "hÃ¡ng hÃ ng": ["ç¬"],
    "cÃ©n jÃ¬n hÃ¡n": ["ç¬’"],
    "dÄ xiÃ¡ nÃ ": ["ç¬š"],
    "zÃ© zuÃ³": ["ç¬®"],
    "lÃ³ng lÇ’ng": ["ç¬¼", "ç¯­", "ç± ", "èº˜", "é¾“"],
    "zhÃ¹ zhÃº": ["ç­‘", "ç¯‰"],
    "dÃ¡ dÄ": ["ç­”", "è…"],
    shÄi: ["ç­›", "ç¯©", "ç°", "ç±­"],
    "yÃºn jÅ«n": ["ç­ "],
    "lÃ¡ng lÃ ng": ["ç­¤", "éƒŽ", "é˜†"],
    "zhÃ¬ zhÇ": ["ç­«"],
    o: ["ç­½"],
    "pÃ³u bÃ¹ fÃº pÃº": ["ç®"],
    "pÃ¡i bÄ“i": ["ç®„"],
    gÃ¨: ["ç®‡", "è™¼", "é‰»", "é“¬"],
    "tÃ¡i chÃ­": ["ç®ˆ"],
    "guÇŽi dÃ i": ["ç®‰"],
    "zhÃ o dÃ o": ["ç®Œ"],
    "jÄ«ng qÃ¬ng": ["ç®"],
    "lÃ­n lÇn": ["ç®–"],
    "jÃ¹n qÅ«n": ["ç®˜"],
    "shÄ« yÃ­": ["ç®·", "é‡¶"],
    "yuÄ“ yÃ o chuÃ²": ["ç®¹"],
    "xiÄo shuÃ² qiÃ o": ["ç®¾"],
    "gÅng gÇŽn lÇ’ng": ["ç¯¢"],
    "pÃ¡ng pÃ©ng": ["ç¯£"],
    "zhuÃ³ huÃ²": ["ç¯§"],
    "jiÇŽn jiÄn": ["ç¯¯"],
    "dÃ­ zhÃº": ["ç¯´"],
    "zÄn cÄ“n cÇŽn": ["ç¯¸"],
    "zhuÃ n suÇŽn zuÃ n": ["ç¯¹"],
    "piÇŽo biÄo": ["ç¯»"],
    "guÃ³ guÃ¬": ["ç°‚"],
    "cÃ¨ jÃ­": ["ç°Ž"],
    "mÃ¬ miÃ¨": ["ç°š"],
    "shÄi sÄ«": ["ç°›"],
    "sÇ”n zhuÃ n": ["ç°¨"],
    "gÃ n gÇŽn": ["ç°³"],
    "bÃ² bÇ’": ["ç°¸"],
    "bÃ³ bÃ¹": ["ç°¿"],
    shi: ["ç±‚"],
    "zhÄ“n jiÄn": ["ç±ˆ"],
    "zhuÃ n zuÇŽn": ["ç±‘"],
    "fÄn pÄn biÄn": ["ç±“"],
    "sÇ’u shÇ”": ["ç±”"],
    zuÇŽn: ["ç±«", "ç¹¤", "çº‚", "çº‰", "çº˜", "ç¼µ"],
    nÇš: ["ç±¹", "é‡¹", "é’•"],
    "shÄ chÇŽo": ["ç²†"],
    "kÄng jÄ«ng": ["ç²‡"],
    fÄ›n: ["ç²‰", "é»º"],
    cÅ«: ["ç²—", "è§•", "éº", "éº„", "éº¤"],
    "niÃ¡n zhÄn": ["ç²˜"],
    "cÃ¨ sÃ¨": ["ç²£"],
    "zhÅu yÃ¹": ["ç²¥"],
    "shÄ“n sÇŽn": ["ç³"],
    "biÄn biÇŽn": ["ç³„", "è¹"],
    miÃ n: ["ç³†", "é¢", "é£", "éºª", "éº«", "éºµ", "éºº"],
    "hÃº hÅ« hÃ¹": ["ç³Š"],
    "gÇ” gÃ²u": ["ç³“"],
    "mÃ­ mÃ©i": ["ç³œ"],
    "sÇŽn shÄ“n": ["ç³", "ç³£"],
    zÄo: ["ç³Ÿ", "è¹§", "é­", "é†©"],
    "mÃ¬ sÄ«": ["ç³¸"],
    "jiÅ« jiÇ”": ["ç³º"],
    "xÃ¬ jÃ¬": ["ç³»", "ç¹«"],
    "zhÄ“ng zhÄ›ng": ["ç³½"],
    "chÃ  chÇŽ": ["ç´", "è¡©"],
    "yuÄ“ yÄo": ["ç´„", "çº¦"],
    "hÃ³ng gÅng": ["ç´…", "çº¢"],
    "hÃ© gÄ“": ["ç´‡", "çº¥"],
    "wÃ©n wÃ¨n": ["ç´‹", "çº¹"],
    fÃ³u: ["ç´‘"],
    "jÃ¬ jiÃ© jiÃ¨": ["ç´’"],
    "pÄ« pÃ­ bÇ": ["ç´•", "çº°"],
    "jÄ«n jÃ¬n": ["ç´Ÿ"],
    "zhÄ zÄ": ["ç´¥", "ç´®"],
    hÄ: ["ç´¦"],
    "fÅ« fÃ¹": ["ç´¨"],
    "chÅu chÃ³u": ["ç´¬"],
    "lÃ¨i lÃ©i lÄ›i": ["ç´¯"],
    "bÅ bÃ¬": ["ç´´"],
    "tiÇŽn zhÄ›n": ["ç´¾"],
    "jiÅng jiÇ’ng": ["çµ…"],
    "jiÃ© jiÄ“": ["çµ", "ç»“", "èŠ‚"],
    "guÃ  kuÄ": ["çµ“"],
    "bÇŽi mÃ²": ["çµ”"],
    "gÄ“ng huÃ¡n": ["çµ™"],
    "jiÃ© xiÃ©": ["çµœ"],
    "quÃ¡n shuÄn": ["çµŸ"],
    "gÇŽi ÇŽi": ["çµ "],
    "luÃ² lÃ o": ["çµ¡", "ç»œ"],
    "bÄ«ng bÄ“ng pÄ“ng": ["çµ£"],
    "gÄ›i jÇ": ["çµ¦", "ç»™"],
    "tÃ³ng tÅng dÃ²ng": ["çµ§"],
    "tiÃ o diÃ o dÃ o": ["çµ©"],
    "lÄ›i lÃ¨i lÃ©i": ["çµ«"],
    "gÄi hÃ i": ["çµ¯"],
    "chÄ« zhÇ": ["çµº"],
    "wÃ¨n miÇŽn mÃ¡n wÃ n": ["çµ»"],
    "huÃ¡n huÃ n wÃ n": ["ç¶„"],
    "qÄ«n xiÄn": ["ç¶…"],
    "tÃ¬ tÃ­": ["ç¶ˆ"],
    "yÃ¡n xiÃ n": ["ç¶–"],
    "zÅng zÃ¨ng zÃ²ng": ["ç¶œ"],
    "chÄ“n lÃ­n": ["ç¶"],
    "zhÇ”n zhÃ¹n": ["ç¶§"],
    "qiÃ n qÄ«ng zhÄ“ng": ["ç¶ª"],
    "qÃ¬ng qÇ": ["ç¶®"],
    "lÃºn guÄn": ["ç¶¸", "çº¶"],
    "chuÃ² chÄo": ["ç¶½", "ç»°"],
    "tiÃ¡n tÇŽn chÄn": ["ç·‚"],
    "lÇœ lÃ¹": ["ç·‘", "ç»¿"],
    "ruÇŽn ruÃ n": ["ç·›"],
    "jÃ­ qÄ«": ["ç·"],
    "zhÃ²ng chÃ³ng": ["ç·Ÿ", "é‡"],
    "miÃ¡o mÃ¡o": ["ç·¢"],
    "xiÃ¨ yÃ¨": ["ç·¤"],
    huÇŽn: ["ç·©", "ç¼“", "ã¬Š"],
    "gÄ“ng gÃ¨ng": ["ç·ª", "ç¸†"],
    "tÅu xÅ« shÅ«": ["ç·°"],
    "zÅng zÃ²ng": ["ç·µ", "ç¹Œ"],
    "yÃ¹n gÇ”n": ["ç··"],
    "guÄ wÅ": ["ç·º"],
    "yÃ¹n yÅ«n wÄ“n": ["ç·¼", "ç¸•"],
    "bÄng bÃ ng": ["ç¸"],
    "gÇ” hÃº": ["ç¸Ž", "é¶»"],
    "cÄ« cuÃ² suÇ’": ["ç¸’"],
    "cuÄ« shuÄi": ["ç¸—"],
    "rÃ³ng rÇ’ng rÃ²ng": ["ç¸™"],
    "zÃ i zÄ“ng": ["ç¸¡"],
    cÃ i: ["ç¸©", "èœ", "è”¡"],
    "fÃ©ng fÃ¨ng": ["ç¸«"],
    "suÅ sÃ¹": ["ç¸®", "ç¼©"],
    "yÇŽn yÇn": ["ç¸¯", "é…“"],
    "zÃ²ng zÇ’ng": ["ç¸±", "çºµ"],
    "zhuÃ n juÃ n": ["ç¸³"],
    "mÃ² mÃ¹": ["ç¸¸", "èŽ«"],
    "piÇŽo piÄo": ["ç¸¹", "ç¼¥"],
    "fÃ¡n pÃ³": ["ç¹"],
    "bÄ“ng bÃ¨ng": ["ç¹ƒ"],
    "mÃ³u miÃ¹ miÃ o liÇŽo": ["ç¹†"],
    "yÃ¡o yÃ³u zhÃ²u": ["ç¹‡"],
    "zÄ“ng zÃ¨ng": ["ç¹’", "ç¼¯"],
    "jÃº juÃ©": ["ç¹˜"],
    "chuÅ chuÃ²": ["ç¹›"],
    "zÅ«n zÇ”n": ["ç¹œ"],
    rÃ o: ["ç¹ž", "ç»•", "é¶"],
    "chÇŽn chÃ¡n": ["ç¹Ÿ"],
    "huÃ¬ huÃ­": ["ç¹¢", "ç¼‹", "è—±"],
    "qiÄo sÄo zÇŽo": ["ç¹°"],
    "jiÇŽo zhuÃ³": ["ç¹³", "ç¼´"],
    "dÃ n tÃ¡n chÃ¡n": ["ç¹µ"],
    nÇ’ng: ["ç¹·"],
    "pÃº fÃº": ["çº€"],
    "yÃ o lÃ¬": ["çº…"],
    "rÇŽng xiÄng": ["çº•"],
    "lÃ­ sÇŽ xÇ lÇ": ["çºš"],
    "xiÄn qiÃ n": ["çº¤"],
    "jÄ«ng jÃ¬ng": ["ç»"],
    "tÃ­ tÃ¬": ["ç»¨"],
    "bÄ“ng bÄ›ng bÃ¨ng": ["ç»·"],
    "zÅng zÃ¨ng": ["ç»¼"],
    "jÄ« qÄ«": ["ç¼‰"],
    "wÄ“n yÃ¹n yÅ«n": ["ç¼Š"],
    "fÃ¨ng fÃ©ng": ["ç¼"],
    "shuÄi cuÄ« suÄ«": ["ç¼ž"],
    "miÃ¹ mÃ³u liÃ¡o miÃ o mÃ¹": ["ç¼ª"],
    "qiÄo sÄo": ["ç¼²"],
    fÇ’u: ["ç¼¶", "ç¼¹", "ç¼»", "é›¬", "é´€"],
    "bÃ  ba pÃ­": ["ç½¢", "ç½·"],
    "guÃ  guÇŽi": ["ç½«"],
    "yÃ¡ng xiÃ¡ng": ["ç¾Š", "ç¾"],
    "mÄ›i gÄo": ["ç¾™"],
    "yÃ¬ xÄ«": ["ç¾›"],
    "qiÇŽng qiÄn": ["ç¾Ÿ"],
    "qiÄng kÃ²ng": ["ç¾«"],
    "qiÃ¡n xiÃ¡n yÃ¡n": ["ç¾¬"],
    nÃ³u: ["ç¾º"],
    "hÃ³ng gÃ²ng": ["ç¾¾"],
    "pÄ« bÃ¬ pÅ": ["ç¿"],
    "qÃº yÃ¹": ["ç¿‘"],
    kÃ©: ["ç¿—"],
    "qiÃ o qiÃ¡o": ["ç¿˜"],
    "zhÃ¡i dÃ­": ["ç¿Ÿ"],
    "dÃ o zhÅu": ["ç¿¢"],
    "hÃ³u qÃº": ["ç¿µ"],
    shuÇŽ: ["è€"],
    "ruÇŽn nuÃ²": ["è€Ž"],
    "Ã©r nÃ i": ["è€"],
    "zhuÄn duÄn": ["è€‘"],
    "pÃ¡ bÃ ": ["è€™"],
    "chÃ­ sÃ¬": ["è€›"],
    "qÃ¹ chÃº": ["è€"],
    "lÃºn lÇ”n": ["è€£"],
    "jÃ­ jiÃ¨": ["è€¤"],
    "tÄng tÇŽng": ["è€¥"],
    pÇŽng: ["è€ª", "è¦«"],
    "zhÃ¡ zÃ©": ["è€«"],
    "yÄ“ yÃ©": ["è€¶"],
    "yÃºn yÃ­ng": ["è€º"],
    "wÃ  tuÇ zhuÃ³": ["è‰"],
    "Ã©r nÇœ": ["è"],
    "tiÄ“ zhÃ©": ["è‘"],
    "dÇ zhÃ¬": ["èœ"],
    qiÃ©: ["èº"],
    "nÇ jiÃ n": ["è»"],
    "lÃ¨i lÄ“": ["è‚‹"],
    cÃ o: ["è‚", "è¥™", "é„µ", "é¼œ"],
    "bÃ³ dÃ­": ["è‚‘"],
    "xiÃ o xiÄo": ["è‚–"],
    "dÃ¹ dÇ”": ["è‚š"],
    chÄi: ["è‚ž", "é‡µ", "é’—"],
    "hÃ¡n qÃ­n hÃ n": ["è‚£"],
    "pÃ ng pÃ¡n pÃ n": ["è‚¨", "èƒ–"],
    "zhÅ«n chÃºn": ["è‚«"],
    Äng: ["è‚®", "éª¯"],
    "yÃ¹ yÅ": ["è‚²"],
    "pÃ­ bÇ bÃ¬": ["è‚¶"],
    "fÃ¨i bÃ¬": ["èƒ‡"],
    "bÃ¨i bÄ“i": ["èƒŒ"],
    "fÃ¨i zÇ": ["èƒ"],
    "pÃ­ng pÄ“ng": ["èƒ“", "è‹¹"],
    "fÅ« fÃº zhÇ’u": ["èƒ•"],
    "shÃ¨ng shÄ“ng": ["èƒœ"],
    kuÃ : ["èƒ¯", "è·¨", "éª»"],
    "gÇŽi hÇŽi": ["èƒ²"],
    "gÄ“ gÃ© gÄ": ["èƒ³"],
    "nÃ©ng nÃ i": ["èƒ½"],
    "guÄ« kuÃ¬": ["èƒ¿"],
    "mÃ i mÃ²": ["è„‰"],
    "zÄng zÃ ng": ["è„"],
    "jiÇŽo juÃ©": ["è„š", "è§’"],
    cuÇ’: ["è„ž"],
    "de te": ["è„¦"],
    "zuÄ« juÄn": ["è„§"],
    nÄ›i: ["è„®", "è…‡", "é¤’", "é¦", "é®¾", "é¯˜"],
    "pÃº fÇ”": ["è„¯"],
    niÃ o: ["è„²"],
    shuÃ­: ["è„½"],
    guÃ²: ["è…‚", "éŽ", "é¹"],
    "lÃ  xÄ«": ["è…Š"],
    "yÄn Ä": ["è…Œ"],
    "gÄo gÃ o": ["è†"],
    "lÃ¹ biÄo": ["è†”"],
    chuÃ¡i: ["è†—"],
    "zhuÄn chuÃ¡n chÃºn zhuÇŽn": ["è†ž"],
    chuÃ i: ["è†ª", "è¸¹"],
    "fÃ¡n pÃ¡n": ["è†°"],
    "wÇ” hÅ«": ["è†´"],
    "shÄn dÃ n": ["è†»"],
    tÃºn: ["è‡€", "è‡‹", "è›Œ", "è±˜", "è±š", "è»˜", "éœ•", "é£©", "é¥¨", "é­¨", "é²€", "é»—"],
    "bÃ¬ bei": ["è‡‚"],
    "lÃ  gÃ©": ["è‡ˆ"],
    "sÃ o sÄo": ["è‡Š"],
    nÃ o: ["è‡‘", "é–™", "é—¹", "é¬§"],
    "nÃ­ luÃ¡n": ["è‡¡"],
    "qiÄn xiÃ¡n": ["è‡¤"],
    "guÃ ng jiÇ’ng": ["è‡¦"],
    "guÇŽng jiÇ’ng": ["è‡©"],
    "chÃ²u xiÃ¹": ["è‡­"],
    "miÃ¡n biÄn": ["è‡±"],
    "diÃ© zhÃ­": ["è‡·"],
    "zhÄ« jÃ¬n": ["è‡¸"],
    "shÃ¨ shÄ›": ["èˆ"],
    pÃ¹: ["èˆ–", "èˆ—"],
    "bÄn bÅ pÃ¡n": ["èˆ¬"],
    kuÄ: ["èˆ¿"],
    "gÃ¨n gÄ›n": ["è‰®"],
    "sÃ¨ shÇŽi": ["è‰²"],
    "fÃº bÃ³": ["è‰´"],
    "jiÄo qiÃº": ["è‰½"],
    "chÄi chÄ": ["èŠ†"],
    "shÃ¡o quÃ¨": ["èŠ"],
    "hÃ¹ xiÃ ": ["èŠ"],
    "zÃ¬ zÇ": ["èŠ“"],
    "huÃ¬ hÅ«": ["èŠ”"],
    "tÃºn chÅ«n": ["èŠš"],
    "jiÃ¨ gÃ i": ["èŠ¥"],
    "xÃ¹ zhÃ¹": ["èŠ§"],
    "yuÃ¡n yÃ¡n": ["èŠ«"],
    "xÄ«n xÃ¬n": ["èŠ¯"],
    "lÃºn huÄ": ["èŠ²"],
    "wÃ¹ hÅ«": ["èŠ´"],
    "gÅu gÇ’u": ["èŠ¶"],
    "mÃ o mÃ¡o": ["èŠ¼"],
    "fÃ¨i fÃº": ["èŠ¾"],
    "chÃ¡n yÃ­n": ["è‹‚"],
    qiÄ“: ["è‹†"],
    "sÅ« sÃ¹": ["è‹"],
    "tiÃ¡o shÃ¡o": ["è‹•"],
    "lÃ¬ jÄ«": ["è‹™"],
    "kÄ“ hÄ“": ["è‹›"],
    "jÃ¹ qÇ”": ["è‹£"],
    "ruÃ² rÄ›": ["è‹¥"],
    "zhÃ¹ nÃ­ng": ["è‹§"],
    "pÄ bÃ³": ["è‹©"],
    xiÃº: ["è‹¬"],
    "zhÇŽ zuÃ³": ["è‹²"],
    "jÅ« chÃ¡": ["è‹´"],
    niÃ©: ["è‹¶"],
    "shÄ“ng ruÃ­": ["è‹¼"],
    "qiÃ© jiÄ": ["èŒ„"],
    "zÇ cÃ­": ["èŒˆ"],
    "qiÃ n xÄ«": ["èŒœ"],
    chÇŽi: ["èŒ"],
    "fÃ¡ pÃ¨i": ["èŒ·"],
    rÃ¡o: ["è›", "è•˜", "è¥“", "é¥’", "é¥¶"],
    "yÃ­ng xÃ­ng": ["è¥"],
    "qiÃ¡n xÃºn": ["è¨", "è•"],
    "yÃ¬n yÄ«n": ["è«"],
    "hÃ© hÃ¨": ["è·"],
    "shÄ suÅ": ["èŽŽ"],
    "pÃ©ng fÄ“ng": ["èŽ‘"],
    "shÄ“n xÄ«n": ["èŽ˜"],
    "wÇŽn guÄn guÇŽn": ["èŽž"],
    "yÃ³u sÃ¹": ["èŽ¤"],
    "shÄo xiÄo": ["èŽ¦", "è›¸"],
    "lÃ ng liÃ¡ng": ["èŽ¨"],
    "piÇŽo fÃº": ["èŽ©"],
    "wÃ¨n wÇŽn miÇŽn": ["èŽ¬"],
    "shÃ¬ shÃ­": ["èŽ³", "è’”"],
    "tÃ¹ tÃº": ["èŽµ"],
    "xiÄn liÇŽn": ["èŽ¶", "è–Ÿ"],
    "wÇŽn yÃ¹": ["è€"],
    "zÅu chÃ¹": ["è†"],
    "lÃ¹ lÇœ": ["è‰"],
    "jÅ«n jÃ¹n": ["èŒ"],
    "niÃ¨ rÄ›n": ["è"],
    "zÄ« zÃ¬ zÄi": ["è‘"],
    "tÃº tÃ¹": ["èŸ"],
    "jiÄ“ shÃ ": ["è¨"],
    "qiÃ¡o zhÇŽo": ["è¬"],
    "tÃ¡i zhÄ« chÃ­": ["è­"],
    "fÄ“i fÄ›i": ["è²", "èœš"],
    "qÃ­n qÄ«n jÄ«n": ["è³"],
    "zÅ« jÃ¹": ["è¹", "è’©"],
    "lÇn mÃ¡": ["è»"],
    "tiÃ¡n tiÃ n": ["è¾"],
    tiÄ“: ["èœ", "è²¼", "è´´"],
    "luÃ² lÃ  lÃ o luÅ": ["è½"],
    "zhÃ¹ zhuÃ³ zhe": ["è‘—"],
    "shÃ¨n rÃ¨n": ["è‘š"],
    "gÄ› gÃ©": ["è‘›"],
    "jÃ¹n suÇ’": ["è‘°"],
    "kuÃ¬ kuÃ i": ["è’‰"],
    "rÃº nÃ¡": ["è’˜"],
    "mÃ©ng mÄ“ng mÄ›ng": ["è’™"],
    "yuÃ¡n huÃ¡n": ["è’"],
    "xÃº shÃº": ["è’£"],
    "xÃ­ xÃ¬": ["è’µ"],
    "mÃ¬ mÃ­ng": ["è“‚"],
    "sÅu sÇ’u": ["è“ƒ"],
    "gÃ i gÄ› hÃ© hÃ i": ["è“‹"],
    "yÇŽo zhuÃ³": ["è“”"],
    "diÃ o tiÃ¡o dÃ­": ["è“§"],
    "xÅ« qiÅ« fÅ«": ["è“²"],
    "zÃ­ jÃº": ["è“»"],
    "liÇŽo lÃ¹": ["è“¼"],
    xu: ["è“¿"],
    "hÃ n hÇŽn": ["è”Š"],
    "mÃ n wÃ n mÃ¡n": ["è”“"],
    "pÃ³ bÃ²": ["è”¢"],
    "fÄn fÃ¡n bÅ": ["è•ƒ"],
    "hÃ³ng hÃ²ng": ["è•»"],
    "yÃ¹ Ã o": ["è–", "éš©"],
    "xÃ­ xiÃ o": ["è–‚"],
    "bÃ¡o bÃ³ bÃ²": ["è–„"],
    "cÃ­ zÄ«": ["è–‹"],
    "wÃ n luÃ n": ["è–"],
    "kÇŽo hÄo": ["è–§"],
    "yuÇŽn wÄ›i": ["è–³"],
    "zhÃ²u chÃ³u": ["è–µ"],
    "wÅ mÃ¡i": ["è–¶"],
    "xiÄo hÃ o": ["è—ƒ"],
    "yÃ¹ xÃ¹ xÅ«": ["è—‡"],
    "jiÃ¨ jÃ­": ["è—‰"],
    "diÃ o zhuÃ³": ["è—‹"],
    "cÃ¡ng zÃ ng": ["è—"],
    lÇŽ: ["è—ž"],
    "chÃº zhÅ«": ["è—¸"],
    "pÃ­n pÃ­ng": ["è˜‹"],
    "gÄn hÃ¡n": ["è™·"],
    "hÃ³ng jiÃ ng": ["è™¹"],
    "huÄ« huÇ": ["è™º"],
    "xiÄ hÃ¡": ["è™¾"],
    "mÇŽ mÃ  mÄ": ["èš‚"],
    "fÄng bÃ ng": ["èš„"],
    "bÃ ng bÃ¨ng": ["èšŒ"],
    "juÃ© quÄ“": ["èš—"],
    "qÃ­n qiÃ¡n": ["èš™"],
    "gÅng zhÅng": ["èš£"],
    "fÇ” fÃ¹": ["èš¥"],
    "dÃ i dÃ©": ["èš®"],
    "gÇ’u qÃº xÃ¹": ["èš¼"],
    "bÇ’ pÃ­": ["èš¾"],
    "shÃ© yÃ­": ["è›‡"],
    tiÄ›: ["è›ˆ", "é‰„", "éŠ•", "é¡", "éµ", "é“", "é©–"],
    "gÃ© luÃ²": ["è›’"],
    "mÃ¡ng bÃ ng": ["è›–"],
    "yÃ¬ xÇ”": ["è›¡"],
    "hÃ¡ gÃ©": ["è›¤"],
    "qiÃ¨ nÃ­": ["è›ª"],
    "Ã© yÇ": ["è›¾"],
    "zhÄ“ zhÃ©": ["èœ‡"],
    "lÃ  zhÃ ": ["èœ¡"],
    suÃ²: ["èœ¶", "é€¤"],
    "yÃ³u qiÃº": ["è¤"],
    "xiÄ hÄ": ["è¦"],
    "xÄ« qÄ«": ["èž‡"],
    "bÄ« pÃ­": ["èž•"],
    "nÃ i nÄ›ng": ["èžš"],
    "hÃ© xiÃ¡": ["èž›"],
    "guÃ¬ huÇ": ["èž"],
    "mÇŽ mÄ mÃ ": ["èžž"],
    "shÃ¬ zhÄ“": ["èž«"],
    "zhÃ¬ diÃ©": ["èž²"],
    "jiÃ n chÃ¡n": ["èž¹"],
    "ma mÃ¡ mÃ²": ["èŸ†"],
    "mÇŽng mÄ›ng": ["èŸ’"],
    "biÄ“ biÃ©": ["èŸž"],
    "bÄ“n fÃ¨i": ["èŸ¦"],
    "lÃ¡o liÃ¡o": ["èŸ§"],
    "yÃ­n xÃºn": ["èŸ«"],
    "lÃ­ lÇ": ["è ¡"],
    "xuÃ¨ xiÄ›": ["è¡€"],
    "xÃ­ng hÃ¡ng hÃ ng hÃ©ng": ["è¡Œ"],
    "shuÄi cuÄ«": ["è¡°"],
    "tuÃ³ tuÅ": ["è¢‰"],
    "lÇng lÃ­ng": ["è¢Š"],
    "bÃ o pÃ¡o pÃ o": ["è¢Œ"],
    "jÃ¹ jiÄ“": ["è¢“"],
    "hÃ¨ kÃ¨": ["è¢”"],
    "yÃ­ yÃ¬": ["è¢˜", "è²¤"],
    "nÃ  juÃ©": ["è¢¦"],
    "bÃ¨i pÄ«": ["è¢«"],
    "chÇ nuÇ’": ["è¢²"],
    "chÇ qÇ duÇ’ nuÇ’": ["è¢³"],
    "jiÃ¡ qiÄ jiÃ©": ["è¢·"],
    "bÃ³ mÃ²": ["è¢¹"],
    "guÄ« guÃ ": ["è¢¿"],
    "liÃ¨ liÄ›": ["è£‚"],
    "chÃ©ng chÄ›ng": ["è£Ž"],
    "jiÄ“ gÃ©": ["è£“"],
    "dÄo chÃ³u": ["è£¯"],
    "shang chÃ¡ng": ["è£³"],
    "yuÄn gÇ”n": ["è£·"],
    "yÇŽn Än": ["è£º"],
    "tÃ¬ xÄ«": ["è£¼"],
    "fÃ¹ fÃº": ["è¤”"],
    "chÇ” zhÇ”": ["è¤š"],
    "tuÃ¬ tÃ¹n": ["è¤ª"],
    lÇŽi: ["è¥°"],
    "yÃ o yÄo": ["è¦"],
    "qÃ­n tÃ¡n": ["è¦ƒ"],
    "jiÃ n xiÃ n": ["è¦‹", "è§"],
    piÇŽn: ["è¦‘", "è«ž", "è°", "è²µ", "ð¡Žš"],
    "piÄ“ miÃ¨": ["è¦•"],
    "yÃ­ng yÇng": ["è¦®"],
    "qÃ¹ qÅ«": ["è¦°", "è¦·", "è§‘"],
    "jiÃ n biÇŽn": ["è¦µ"],
    "luÃ³ luÇŽn": ["è¦¶"],
    "zÄ« zuÇ": ["è§œ"],
    "huÃ  xiÃ¨": ["è§Ÿ"],
    "jiÄ› jiÃ¨ xiÃ¨": ["è§£", "è§§"],
    "xuÃ© hÃ¹": ["è§·"],
    "lÃ¬ lÃ¹": ["è§»"],
    tÇŽo: ["è¨Ž", "è®¨"],
    zhÃ¹n: ["è¨°"],
    "zÄ« zÇ": ["è¨¾"],
    "yÃ­ dÃ i": ["è©’", "è¯’"],
    xiÃ²ng: ["è©—", "è¯‡"],
    "diÃ o tiÇŽo": ["èª‚"],
    "yÃ­ chÇ chÃ¬": ["èªƒ"],
    "lÇŽng lÃ ng": ["èª"],
    "Ä“i Ã©i Ä›i Ã¨i xÄ«": ["èª’", "è¯¶"],
    shuÃ : ["èªœ"],
    "yÇ” yÃ¹": ["èªž", "è¯­", "é›¨"],
    "shuÅ shuÃ¬ yuÃ¨": ["èªª", "è¯´"],
    "shuÃ­ shÃ©i": ["èª°", "è°"],
    "qÅ« juÃ¨": ["èª³"],
    "chÄ« lÃ i": ["èªº"],
    "nÃ¬ nÃ¡": ["èª½"],
    "diÃ o tiÃ¡o": ["èª¿"],
    "pÇ bÄ“i": ["è«€"],
    "jÃ¬ jÄ«": ["è«…"],
    "zÃ© zuÃ² zhÇŽ cuÃ²": ["è«Ž"],
    "chÃ¹ jÃ­": ["è«”"],
    "hÃ¡o xiÃ ": ["è«•"],
    "lÃ¹n lÃºn": ["è«–", "è®º"],
    "shÃ¬ dÃ¬": ["è«Ÿ"],
    "huÃ  guÄ": ["è«£"],
    "xÇ shÄi Äi": ["è«°"],
    "nÃ¡n nÃ n": ["è«µ", "é›£"],
    miÃ¹: ["è¬¬", "è°¬"],
    zÃ¨n: ["è­–", "è°®"],
    "shÃ­ zhÃ¬": ["è­˜", "è¯†"],
    "juÃ n xuÄn": ["è®‚"],
    "yÃ­ tuÄ«": ["è®‰"],
    zhÃ¡n: ["è®"],
    "xÇ” hÇ”": ["è®¸"],
    "xiÃ¡ng yÃ¡ng": ["è¯¦"],
    "tiÃ¡o diÃ o zhÅu": ["è°ƒ"],
    "chÃ©n shÃ¨n": ["è°Œ"],
    "mÃ­ mÃ¨i": ["è°œ"],
    "mÃ n mÃ¡n": ["è°©"],
    "gÇ” yÃ¹": ["è°·"],
    "huÅ huÃ² huÃ¡": ["è±"],
    "zhÃ¬ zhÃ i": ["è±¸"],
    "huÄn huÃ¡n": ["è²†"],
    "kÄ›n kÅ«n": ["è²‡"],
    "mÃ² hÃ©": ["è²ˆ"],
    "mÃ² hÃ© hÃ¡o": ["è²‰"],
    "jÃ¹ lÃ³u": ["è²—"],
    "zÃ© zhÃ i": ["è²¬", "è´£"],
    "dÃ i tÃ¨": ["è²¸"],
    "bÃ¬ bÄ“n": ["è³"],
    "jiÇŽ gÇ” jiÃ ": ["è³ˆ"],
    "xiÅng mÃ­n": ["è³¯"],
    cÃ ng: ["è³¶"],
    "zhuÃ n zuÃ n": ["è³º", "èµš"],
    "wÃ n zhuÃ n": ["è´ƒ"],
    "gÃ n gÃ²ng zhuÃ ng": ["è´›"],
    "yuÃ¡n yÃ¹n": ["è´ "],
    "bÄ“n bÃ¬": ["è´²"],
    "jiÇŽ gÇ”": ["è´¾"],
    zÇ’u: ["èµ°", "èµ±", "é¯"],
    "diÃ© tÃº": ["è¶ƒ"],
    "jÅ« qiÃ¨": ["è¶„"],
    "qÅ« cÃ¹": ["è¶‹", "è¶¨"],
    "jÃ­ jiÃ©": ["è¶Œ"],
    "guÄ huÃ³": ["è¶"],
    "quÃ¨ qÃ¬ jÃ­": ["è¶ž"],
    "tÃ ng tÄng": ["è¶Ÿ"],
    "chuÅ zhuÃ³": ["è¶ "],
    "qÃ¹ cÃ¹": ["è¶£"],
    "yuÃ¨ tÃ¬": ["è¶¯"],
    "bÅ bÃ o": ["è¶µ"],
    "kuÃ  wÃ¹": ["è¶¶"],
    "guÃ¬ juÃ©": ["è¶¹"],
    "fÄng fÃ ng pÃ¡ng": ["è¶½"],
    "pÃ¡o bÃ ": ["è·"],
    "qÃ­ qÇ": ["è·‚"],
    "jiÃ n chÃ©n": ["è·ˆ"],
    "pÇŽo pÃ¡o": ["è·‘"],
    "diÇŽn diÄ“ tiÄ“": ["è·•"],
    "jÅ« jÃ¹ qiÃ¨": ["è·™"],
    bÇ’: ["è·›"],
    "luÃ² lÃ¬": ["è·ž"],
    "dÃ i duÃ² duÅ chÃ­": ["è·¢"],
    zhuÇŽi: ["è·©"],
    "bÃ¨ng piÃ¡n": ["è·°"],
    "tiÃ o tÃ¡o": ["è·³"],
    "shÅ« chÅu": ["è·¾"],
    "liÃ ng liÃ¡ng": ["è¸‰"],
    "tÃ  tÄ": ["è¸"],
    chÇŽ: ["è¹…", "é‘”", "é•²"],
    "dÃ­ zhÃ­": ["è¹¢"],
    "dÄ“ng dÃ¨ng": ["è¹¬", "é™", "é•«"],
    cÃ¨ng: ["è¹­"],
    "dÅ«n cÃºn": ["è¹²"],
    "juÄ› juÃ©": ["è¹¶"],
    liÄo: ["è¹½"],
    "xiÃ¨ sÇŽ": ["èº "],
    tÇ: ["èº°", "è»†", "éªµ"],
    "yÃ  zhÃ¡ gÃ¡": ["è½§", "è»‹"],
    "xÃ¬n xiÃ n": ["è»"],
    "fÃ n guÇ": ["è»“"],
    "zhuÃ n zhuÇŽn": ["è»¢"],
    "zhÃ³u zhÃ²u": ["è»¸", "è½´"],
    bÃº: ["è½", "é†­", "é³ª"],
    "zhuÇŽn zhuÃ n zhuÇŽi": ["è½¬"],
    "zÇŽi zÃ i": ["è½½"],
    "niÇŽn zhÇŽn": ["è¾—"],
    "biÄn bian": ["è¾¹"],
    "dÃ o biÄn": ["è¾º"],
    "yÇ yÃ­": ["è¿†", "è¿¤", "è¿±"],
    "guÃ² guo guÅ": ["è¿‡"],
    "wÃ ng kuÄng": ["è¿‹"],
    "hÃ¡i huÃ¡n": ["è¿˜"],
    "zhÃ¨ zhÃ¨i": ["è¿™"],
    "yuÇŽn yuÃ n": ["è¿œ"],
    "zhÃ¬ lÃ¬": ["è¿£"],
    "zhÃ¹ wÇŽng": ["è¿¬"],
    "zhuÄ« duÄ«": ["è¿½"],
    "shÃ¬ kuÃ²": ["é€‚"],
    tÃ²u: ["é€"],
    "tÅng tÃ²ng": ["é€š"],
    guÃ ng: ["é€›"],
    "dÇŽi dÃ i": ["é€®"],
    "suÃ¬ suÃ­": ["é‚"],
    "tÃ­ dÃ¬": ["é†"],
    "yÃ­ wÃ¨i": ["é—"],
    "shÃ¬ dÃ­ zhÃ©": ["é©"],
    cÃ : ["éª"],
    "huÃ¡n hÃ¡i": ["é‚„"],
    "lÃ­ chÃ­": ["é‚Œ"],
    "kÃ ng hÃ¡ng": ["é‚Ÿ"],
    "nÃ  nÃ¨i nÄ": ["é‚£"],
    "xiÃ© yÃ¡ yÃ© yÃº xÃº": ["é‚ª"],
    "gÄi hÃ¡i": ["éƒ‚"],
    "huÃ¡n xÃºn": ["éƒ‡"],
    "chÄ« xÄ«": ["éƒ—"],
    hÇŽo: ["éƒ"],
    "lÃ¬ zhÃ­": ["éƒ¦"],
    "xiÃ¡o ÇŽo": ["éƒ©"],
    "dÅu dÅ«": ["éƒ½"],
    liÇŽo: ["æ›¢", "é„", "é•½"],
    "zÃ n cuÃ¡n cuÃ³": ["é…‚", "é…‡"],
    "dÄ«ng dÇng": ["é…Š"],
    "cÃ¹ zuÃ²": ["é…¢"],
    "fÄ pÅ": ["é…¦"],
    "shÄi shÄ«": ["é…¾"],
    niÃ ng: ["é…¿", "é†¸"],
    "qiÃº chÅu": ["é†”"],
    "pÅ fÄ": ["é†—", "é†±"],
    "chÇŽn chÄ›n": ["é†¦"],
    "yÃ n liÇŽn xiÄn": ["é†¶"],
    "niÃ ng niÃ¡ng": ["é‡€"],
    "lÇ li": ["é‡Œ"],
    "lÃ­ xÇ xÄ«": ["é‡"],
    "liÇŽo liÃ o": ["é‡•"],
    "dÄ«ng dÃ¬ng": ["é‡˜", "é’‰"],
    "qiÇŽo jiÇŽo": ["é‡¥"],
    "yÃº huÃ¡": ["é‡ª"],
    "huÃ¡ wÅ«": ["é‡«"],
    "rÃ¬ rÃ¨n jiÃ n": ["é‡°", "é‡¼"],
    "dÃ¬ dÃ i": ["é‡±"],
    "pÄ« zhÄo": ["é‡½"],
    "yÃ¡ yÃ©": ["é‡¾"],
    "bÇŽ pÃ¡": ["éˆ€", "é’¯"],
    "tÄ tuÃ³": ["é‰ˆ", "é“Š"],
    bÄ›i: ["é‰³"],
    "bÇng pÃ­ng": ["é‰¼"],
    "hÄ kÄ“": ["é‰¿", "é“ª"],
    chÃ²ng: ["éŠƒ", "é“³"],
    "xiÇŽng jiÅng": ["éŠ„"],
    "yÃ¹ sÃ¬": ["éŠ‰"],
    "xÃ¹ huÃ¬": ["éŠŠ"],
    "rÃ©n rÄ›n": ["éŠ‹"],
    "shÃ n shuÃ²": ["éŠ"],
    "chÃ¬ lÃ¬": ["éŠ"],
    "xiÇŽn xÇ": ["éŠ‘", "é“£"],
    "hÃ³u xiÃ ng": ["éŠ—"],
    "diÃ o tiÃ¡o yÃ¡o": ["éŠš"],
    "xiÄn kuÃ² tiÇŽn guÄ": ["éŠ›", "éŠ½", "é“¦"],
    "zhÃ© niÃ¨": ["éŠ¸"],
    "zhÅng yÅng": ["éŠ¿"],
    "tÅu tÃ¹ dÃ²u": ["é‹€"],
    "mÃ©i mÃ©ng": ["é‹‚"],
    "wÃ n jiÇŽn": ["é‹„", "éŽ«"],
    "tÇng dÃ¬ng": ["é‹Œ", "é“¤"],
    "juÄn jiÄn cuÄn": ["é‹‘"],
    "sÄ« tuÃ³": ["é‹–"],
    "juÄn xuÄn juÃ n": ["é‹—"],
    "wÃº huÃ¡ wÅ«": ["é‹˜"],
    "zhuÃ³ chuÃ²": ["é‹œ"],
    "xÃ­ng xÃ¬ng jÄ«ng": ["é‹ž"],
    "jÅ« jÃº": ["é‹¦", "é””"],
    "zuÃ¬ niÃ¨": ["é‹·"],
    "yuÄn yuÇŽn wÇŽn wÄn": ["é‹º"],
    "gÄng gÃ ng": ["é‹¼", "é’¢"],
    zhuÄ«: ["éŒ", "é”¥", "é¨…", "éª“", "éµ»"],
    Ä: ["éŒ’", "é”•"],
    "cuÅ chÄ": ["éŽˆ"],
    "suÇ’ sÃ¨": ["éŽ"],
    "yÃ¡o zÃº": ["éŽ"],
    "yÃ¨ tÃ  gÃ©": ["éŽ‘"],
    "qiÄng chÄ“ng": ["éŽ—"],
    "gÃ© lÃ¬": ["éŽ˜", "é•‰", "é¬²"],
    "bÄ« pÄ« bÃ¬": ["éŽž"],
    "gÇŽo hÃ o": ["éŽ¬"],
    "zÃº chuÃ²": ["éƒ"],
    "xiÅ« xiÃ¹": ["é…"],
    "shÃ²u sÅu": ["é‰"],
    "dÃ­ dÄ«": ["é‘", "é•"],
    "qiÄo sÇŽn cÃ n": ["é’"],
    "lÃ¹ Ã¡o": ["é•"],
    "tÄng tÃ¡ng": ["éœ"],
    "jiÃ n zÃ n": ["é©"],
    "huÃ¬ suÃ¬ ruÃ¬": ["é¸"],
    "qiÇŽng qiÄng": ["é¹", "é•ª"],
    "sÇŽn xiÃ n sÃ ": ["é¾"],
    "jiÇŽn jiÃ n": ["é§", "é”"],
    "dÄng chÄ“ng": ["éº", "é“›"],
    "zuÄn zuÃ n": ["é‘½"],
    "sÃ  xÃ¬": ["é’‘"],
    "yÃ o yuÃ¨": ["é’¥"],
    "tÇ’u dÇ’u": ["é’­"],
    "zuÃ n zuÄn": ["é’»"],
    "qiÄn yÃ¡n": ["é“…"],
    "pÃ­ pÄ«": ["é“"],
    "yÃ¡o diÃ o tiÃ¡o": ["é“«"],
    "tÄng tÃ ng": ["é“´"],
    "pÃ¹ pÅ«": ["é“º"],
    "tÃ¡n xiÄn": ["é”¬"],
    "liÃ¹ liÃº": ["é•"],
    "hÃ o gÇŽo": ["é•"],
    "tÃ¡ng tÄng": ["é•—"],
    "tÃ¡n chÃ¡n xÃ­n": ["é•¡"],
    "huÃ² shÇŽn": ["é–„"],
    "hÃ n bÃ¬": ["é–ˆ", "é—¬"],
    "kÄng kÃ ng": ["é–Œ", "é—¶"],
    "xiÃ¡n jiÃ n jiÄn jiÇŽn": ["é–’"],
    "xiÄ xiÇŽ": ["é–•"],
    "xiÇŽ kÄ›": ["é–œ"],
    "biÃ n guÄn": ["é–ž"],
    "hÃ© gÃ©": ["é–¤", "é¢Œ"],
    "hÃ²ng xiÃ ng": ["é–§"],
    "sÄ“ xÄ«": ["é–ª"],
    "tÃ­ng tÇng": ["é–®"],
    "Ã¨ yÄn": ["é–¼", "é˜"],
    "hÃ²ng juÇŽn xiÃ ng": ["é—‚"],
    "bÇŽn pÃ n": ["é—†"],
    "dÅ« shÃ©": ["é—", "é˜‡"],
    "quÃ¨ quÄ“": ["é—•"],
    "tÄng tÃ¡ng chÄng": ["é—›"],
    "kÃ n hÇŽn": ["é—ž", "é˜š"],
    "xÃ¬ sÃ¨ tÃ ": ["é—Ÿ"],
    "mÄ“n mÃ¨n": ["é—·"],
    "quÄ“ quÃ¨": ["é˜™"],
    "yÃ¡n diÃ n": ["é˜½"],
    "Ä Ä“": ["é˜¿"],
    "bÄ“i pÅ pÃ­": ["é™‚"],
    "yÃ n yÇŽn": ["éš"],
    "yÃº yÃ¡o shÃ¹": ["éšƒ"],
    "lÃ³ng lÅng": ["éš†"],
    "duÃ¬ zhuÃ¬": ["éšŠ"],
    "suÃ­ duÃ²": ["éš‹"],
    "gÄi qÃ­ Ã¡i": ["éš‘"],
    "huÄ« duÃ²": ["éš“", "éš³"],
    "wÄ›i kuÃ­": ["éš—"],
    "lÃ¬ dÃ i": ["éš¸"],
    "zhuÄ« cuÄ« wÃ©i": ["éš¹"],
    "hÃ¨ hÃº": ["éšº", "é¶®"],
    "jÃ¹n juÃ n": ["éš½", "é›‹"],
    "nÃ¡n nÃ n nuÃ³": ["éš¾"],
    "quÃ¨ qiÄo qiÇŽo": ["é›€"],
    "guÃ n huÃ¡n": ["é›š"],
    "guÄ« xÄ«": ["é›Ÿ"],
    "sÃ¨ xÃ­": ["é›­"],
    Ã¡n: ["é›¸"],
    "wÃ¹ mÃ©ng": ["é›º"],
    tÃ¨ng: ["éœ¯"],
    "lÃ¹ lÃ²u": ["éœ²"],
    mÃ¡i: ["éœ¾"],
    "jÃ¬ng liÃ ng": ["éš"],
    "gÃ© jÃ­": ["é©"],
    bÇŽ: ["é¶"],
    "yÄng yÃ ng": ["éž…"],
    "gÃ© tÃ  sÇŽ": ["éžˆ"],
    "biÄn yÃ¬ng": ["éž•"],
    "qiÃ o shÄo": ["éž˜"],
    "juÄn xuÄn": ["éž™"],
    "shÃ ng zhÇŽng": ["éž"],
    "pÃ­ bÇng bÃ¬ bÄ“i": ["éžž"],
    la: ["éž¡"],
    "xiÃ¨ diÃ©": ["éž¢"],
    Ä“ng: ["éž¥"],
    "mÃ³u mÃ¹": ["éžª"],
    "bÃ¬ bÇng": ["éž¸"],
    "mÃ¨i wÃ ": ["éŸŽ"],
    rÇ’u: ["éŸ–"],
    "shÃ¨ xiÃ¨": ["éŸ˜"],
    "yÃ¹n wÄ“n": ["éŸ«"],
    "dÃ¹n dÃº": ["é “", "é¡¿"],
    duÇ: ["é §"],
    luÅ: ["é ±"],
    "bÄ«n pÃ­n": ["é »"],
    yÃ³ng: ["é¡’", "é¢™", "é°«"],
    mÄn: ["é¡¢", "é¢Ÿ"],
    "jÇng gÄ›ng": ["é¢ˆ"],
    "jiÃ© xiÃ© jiÃ¡": ["é¢‰"],
    "kÄ“ kÃ©": ["é¢"],
    "pÃ­n bÄ«n": ["é¢‘"],
    "chÃ n zhÃ n": ["é¢¤"],
    "fÄ“ng fÄ›ng": ["é¢¨", "é£Ž"],
    "biÄo diÅ«": ["é¢©"],
    "bÃ¡ fÃº": ["é¢°"],
    "sÄo sÅu": ["é¢¾"],
    "liÃ¹ liÃ¡o": ["é£‚"],
    "shÃ­ sÃ¬ yÃ¬": ["é£Ÿ"],
    "yÇŽng juÃ n": ["é£¬"],
    "zhÃ¹ tÇ’u": ["é£³"],
    "yÃ­ sÃ¬": ["é£´"],
    "zuÃ² zÃ© zhÄ": ["é£µ"],
    tiÃ¨: ["é£»", "é¤®"],
    "xiÇŽng nÃ¡ng": ["é¥Ÿ"],
    "tÃ¡ng xÃ­ng": ["é¥§"],
    "gÄ“ le": ["é¥¹"],
    "chÄ zha": ["é¦‡"],
    "nÃ¡ng nÇŽng": ["é¦•"],
    "yÅ«n wÃ²": ["é¦§"],
    "zhÄ« shÃ¬": ["é¦¶"],
    "xÃ¬n jÃ¬n": ["é¦¸"],
    "kuÃ i juÃ©": ["é§ƒ"],
    zÇŽng: ["é§”", "é©µ"],
    "tÃ¡i dÃ i": ["é§˜"],
    "xÃºn xuÄn": ["é§¨"],
    "liÃ¡ng lÃ¡ng": ["é§º"],
    piÃ n: ["é¨—", "é¨™", "éª—", "é­¸"],
    "dÃ i tÃ¡i": ["éª€"],
    "sÄo sÇŽo": ["éªš"],
    "gÇ” gÅ«": ["éª¨"],
    "bÃ¨i mÃ³": ["éª³"],
    "xiÄo qiÄo": ["éª¹"],
    "bÇŽng pÇŽng": ["é«ˆ"],
    "bÃ³ juÃ©": ["é«‰"],
    "bÃ¬ pÇ’": ["é«²"],
    "mÃ¡o mÃ©ng": ["é«³"],
    "kuÃ² yuÃ¨": ["é«º"],
    "bÄ bÃ ": ["é­ž", "é²ƒ"],
    "jÃ¬ cÇ": ["é®†"],
    "bÃ³ bÃ ": ["é®Š"],
    "zhÇŽ zhÃ ": ["é®“", "é²Š"],
    "chÃ³u dÃ i": ["é®˜"],
    "luÃ² gÃ©": ["é®¥"],
    "guÄ« xiÃ© wÄ kuÃ­": ["é®­"],
    "xiÄn xiÇŽn": ["é®®", "é²œ"],
    "pÅ« bÅ«": ["é¯†"],
    "yÃ¬ sÄ«": ["é¯£"],
    "bÃ  bÃ³": ["é²Œ"],
    "guÄ« xiÃ©": ["é²‘"],
    "sÄi xÇ": ["é³ƒ"],
    "niÇŽo diÇŽo": ["é³¥"],
    "diÄo zhÄo": ["é³­"],
    "gÄn hÃ n yÃ n": ["é³±"],
    "fÅ« guÄ«": ["é³º"],
    "jiÄn qiÄn zhÄn": ["é³½"],
    "hÃ© jiÃ¨": ["é¶¡"],
    "piÄn biÇŽn": ["é¶£"],
    "chuÃ n zhÃ¬": ["é¶¨"],
    "cÄng qiÄng": ["é¶¬"],
    "sÇ”n xÃ¹n": ["é¶½"],
    "biÄo pÃ¡o": ["éºƒ"],
    "zhÃ¹ cÅ«": ["éº†"],
    "jÅ«n qÃºn": ["éº‡", "éº•"],
    chi: ["éº¶"],
    "mÃ³ me": ["éº¼"],
    "mÃ³ me ma": ["éº½"],
    "mÃ­ mÇ’": ["éº¿"],
    "dÃ n shÃ¨n": ["é»®"],
    "zhÄ›n yÄn": ["é»°"],
    "dÇŽn zhÇŽn": ["é»µ"],
    "miÇŽn mÇn mÄ›ng": ["é»¾"],
    hÅu: ["é½"],
    nÃ ng: ["é½‰"],
    "qÃ­ jÃ¬ zÄ« zhÄi": ["é½"],
    "yÃ­n kÄ›n yÇŽn": ["é¾‚"],
    "yÃ­n kÄ›n": ["é¾ˆ"],
    "gÅng wÃ²": ["é¾"],
    "guÄ« jÅ«n qiÅ«": ["é¾œ", "é¾Ÿ"],
    "kuÃ­ wÄ": ["ä–¯"],
    lÅu: ["ä–"],
    "Åu qÅ«": ["ð«­Ÿ"],
    "lÃ³u lÇ˜": ["ð¦¼"],
    "gÇŽ gÄ gÃ¡": ["å˜Ž"],
    "wÄ guÃ ": ["å¬"],
    "zhÇ dÇ": ["èŒ‹"],
    "gÇ’ng hÃ³ng": ["ç¡”"],
    "yÃ¡o xiÃ o": ["æ»§"]
  };
  const DICT1 = new FastDictFactory();
  Object.keys(map).forEach((key) => {
    const chars = map[key];
    for (let char of chars) {
      DICT1.set(char, key);
    }
  });
  const InitialList = [
    "zh",
    "ch",
    "sh",
    "z",
    "c",
    "s",
    "b",
    "p",
    "m",
    "f",
    "d",
    "t",
    "n",
    "l",
    "g",
    "k",
    "h",
    "j",
    "q",
    "x",
    "r",
    "y",
    "w",
    ""
  ];
  const SpecialInitialList = ["j", "q", "x"];
  const SpecialFinalList = [
    "uÄn",
    "uÃ¡n",
    "uÇŽn",
    "uÃ n",
    "uan",
    "uÄ“",
    "uÃ©",
    "uÄ›",
    "uÃ¨",
    "ue",
    "Å«n",
    "Ãºn",
    "Ç”n",
    "Ã¹n",
    "un",
    "Å«",
    "Ãº",
    "Ç”",
    "Ã¹",
    "u"
  ];
  const SpecialFinalMap = {
    uÄn: "Ã¼Än",
    uÃ¡n: "Ã¼Ã¡n",
    uÇŽn: "Ã¼ÇŽn",
    uÃ n: "Ã¼Ã n",
    uan: "Ã¼an",
    uÄ“: "Ã¼Ä“",
    uÃ©: "Ã¼Ã©",
    uÄ›: "Ã¼Ä›",
    uÃ¨: "Ã¼Ã¨",
    ue: "Ã¼e",
    Å«n: "Ç–n",
    Ãºn: "Ç˜n",
    Ç”n: "Çšn",
    Ã¹n: "Çœn",
    un: "Ã¼n",
    Å«: "Ç–",
    Ãº: "Ç˜",
    Ç”: "Çš",
    Ã¹: "Çœ",
    u: "Ã¼"
  };
  const doubleFinalList = [
    "ia",
    "ian",
    "iang",
    "iao",
    "ie",
    "iu",
    "iong",
    "ua",
    "uai",
    "uan",
    "uang",
    "ue",
    "ui",
    "uo",
    "Ã¼an",
    "Ã¼e",
    "van",
    "ve"
  ];
  const Numbers = {
    ä¸€: "yÃ¬",
    äºŒ: "Ã¨r",
    ä¸‰: "sÄn",
    å››: "sÃ¬",
    äº”: "wÇ”",
    å…­: "liÃ¹",
    ä¸ƒ: "qÄ«",
    å…«: "bÄ",
    ä¹: "jiÇ”",
    å: "shÃ­",
    ç™¾: "bÇŽi",
    åƒ: "qiÄn",
    ä¸‡: "wÃ n",
    äº¿: "yÃ¬",
    å•: "dÄn",
    ä¸¤: "liÇŽng",
    åŒ: "shuÄng",
    å¤š: "duÅ",
    å‡ : "jÇ",
    åä¸€: "shÃ­ yÄ«",
    é›¶ä¸€: "lÃ­ng yÄ«",
    ç¬¬ä¸€: "dÃ¬ yÄ«",
    ä¸€å: "yÄ« shÃ­",
    ä¸€åä¸€: "yÄ« shÃ­ yÄ«"
  };
  const NumberWordMap = {
    é‡: "chÃ³ng",
    è¡Œ: "hÃ¡ng",
    æ–—: "dÇ’u",
    æ›´: "gÄ“ng"
  };
  function genNumberDict() {
    const dict = {
      é›¶ä¸€: "lÃ­ng yÄ«",
      "ã€‡ä¸€": "lÃ­ng yÄ«",
      åä¸€: "shÃ­ yÄ«",
      ä¸€å: "yÄ« shÃ­",
      ç¬¬ä¸€: "dÃ¬ yÄ«",
      ä¸€åä¸€: "yÄ« shÃ­ yÄ«"
    };
    for (let number in Numbers) {
      for (let key in NumberWordMap) {
        const word = `${number}${key}`;
        const pinyin2 = `${Numbers[number]} ${NumberWordMap[key]}`;
        dict[word] = pinyin2;
      }
    }
    return dict;
  }
  const NumberDict = genNumberDict();
  const PatternNumberDict = Object.keys(NumberDict).map((key) => ({
    zh: key,
    pinyin: NumberDict[key],
    probability: 1e-12,
    length: stringLength(key),
    priority: Priority.Normal,
    dict: Symbol("rule")
  }));
  const toneSandhiMap = {
    // è¯´ä¸è¯´ï¼Œè¯´ä¸€è¯´ï¼Œå è¯ä¹‹é—´å‘éŸ³ä¸ºè½»å£°
    ä¸: {
      bÃº: [4]
      // "ä¸" åŽé¢è·Ÿ 4 å£°æ—¶ï¼Œå˜è°ƒä¸º 2 å£°
    },
    ä¸€: {
      yÃ­: [4],
      yÃ¬: [1, 2, 3]
    }
  };
  const toneSandhiIgnoreSuffix = {
    ä¸: ["çš„", "è€Œ", "ä¹‹", "åŽ", "ä¹Ÿ", "è¿˜", "åœ°"],
    ä¸€: ["çš„", "è€Œ", "ä¹‹", "åŽ", "ä¹Ÿ", "è¿˜", "æ˜¯"]
  };
  const toneSandhiList = Object.keys(toneSandhiMap);
  function processToneSandhi(cur, pre, next) {
    if (toneSandhiList.indexOf(cur) === -1) {
      return getSingleWordPinyin(cur);
    }
    if (pre === next && pre && getSingleWordPinyin(pre) !== pre) {
      return getPinyinWithoutTone(getSingleWordPinyin(cur));
    }
    if (next && !toneSandhiIgnoreSuffix[cur].includes(next)) {
      const nextPinyin = getSingleWordPinyin(next);
      if (nextPinyin !== next) {
        const nextTone = getNumOfTone(nextPinyin);
        const pinyinMap = toneSandhiMap[cur];
        for (let pinyin2 in pinyinMap) {
          const tones = pinyinMap[pinyin2];
          if (tones.indexOf(Number(nextTone)) !== -1) {
            return pinyin2;
          }
        }
      }
    }
  }
  function processToneSandhiLiao(cur, pre) {
    if (cur === "äº†" && (!pre || !DICT1.get(pre))) {
      return "liÇŽo";
    }
  }
  function processReduplicationChar(cur, pre) {
    if (cur === "ã€…") {
      if (!pre || !DICT1.get(pre)) {
        return "tÃ³ng";
      } else {
        return DICT1.get(pre).split(" ")[0];
      }
    }
  }
  function processSepecialPinyin(cur, pre, next) {
    return processReduplicationChar(cur, pre) || processToneSandhiLiao(cur, pre) || processToneSandhi(cur, pre, next) || getSingleWordPinyin(cur);
  }
  const Surnames = {
    å—å®«: "nÃ¡n gÅng",
    ç¬¬äº”: "dÃ¬ wÇ”",
    ä¸‡ä¿Ÿ: "mÃ² qÃ­",
    å¸é©¬: "sÄ« mÇŽ",
    ä¸Šå®˜: "shÃ ng guÄn",
    æ¬§é˜³: "Åu yÃ¡ng",
    å¤ä¾¯: "xiÃ  hÃ³u",
    è¯¸è‘›: "zhÅ« gÄ›",
    é—»äºº: "wÃ©n rÃ©n",
    ä¸œæ–¹: "dÅng fÄng",
    èµ«è¿ž: "hÃ¨ liÃ¡n",
    çš‡ç”«: "huÃ¡ng fÇ”",
    å°‰è¿Ÿ: "yÃ¹ chÃ­",
    å…¬ç¾Š: "gÅng yÃ¡ng",
    æ¾¹å°: "tÃ¡n tÃ¡i",
    å…¬å†¶: "gÅng yÄ›",
    å®—æ”¿: "zÅng zhÃ¨ng",
    æ¿®é˜³: "pÃº yÃ¡ng",
    æ·³äºŽ: "chÃºn yÃº",
    å¤ªå”: "tÃ i shÅ«",
    ç”³å± : "shÄ“n tÃº",
    å…¬å­™: "gÅng sÅ«n",
    ä»²å­™: "zhÃ²ng sÅ«n",
    è½©è¾•: "xuÄn yuÃ¡n",
    ä»¤ç‹: "lÃ­ng hÃº",
    é’Ÿç¦»: "zhÅng lÃ­",
    å®‡æ–‡: "yÇ” wÃ©n",
    é•¿å­™: "zhÇŽng sÅ«n",
    æ…•å®¹: "mÃ¹ rÃ³ng",
    é²œäºŽ: "xiÄn yÃº",
    é—¾ä¸˜: "lÇ˜ qiÅ«",
    å¸å¾’: "sÄ« tÃº",
    å¸ç©º: "sÄ« kÅng",
    äº“å®˜: "qÃ­ guÄn",
    å¸å¯‡: "sÄ« kÃ²u",
    ä»‰ç£: "zhÇŽng dÅ«",
    å­è½¦: "zÇ jÅ«",
    é¢›å­™: "zhuÄn sÅ«n",
    ç«¯æœ¨: "duÄn mÃ¹",
    å·«é©¬: "wÅ« mÇŽ",
    å…¬è¥¿: "gÅng xÄ«",
    æ¼†é›•: "qÄ« diÄo",
    ä¹æ­£: "yuÃ¨ zhÃ¨ng",
    å£¤é©·: "rÇŽng sÃ¬",
    å…¬è‰¯: "gÅng liÃ¡ng",
    æ‹“è·‹: "tuÃ² bÃ¡",
    å¤¹è°·: "jiÃ¡ gÇ”",
    å®°çˆ¶: "zÇŽi fÇ”",
    æ¦–æ¢: "gÇ” liÃ¡ng",
    æ®µå¹²: "duÃ n gÄn",
    ç™¾é‡Œ: "bÇŽi lÇ",
    ä¸œéƒ­: "dÅng guÅ",
    å—é—¨: "nÃ¡n mÃ©n",
    å‘¼å»¶: "hÅ« yÃ¡n",
    ç¾ŠèˆŒ: "yÃ¡ng shÃ©",
    æ¢ä¸˜: "liÃ¡ng qiÅ«",
    å·¦ä¸˜: "zuÇ’ qiÅ«",
    ä¸œé—¨: "dÅng mÃ©n",
    è¥¿é—¨: "xÄ« mÃ©n",
    å¥é¾™: "gÅu lÃ³ng",
    æ¯Œä¸˜: "guÃ n qiÅ«",
    èµµ: "zhÃ o",
    é’±: "qiÃ¡n",
    å­™: "sÅ«n",
    æŽ: "lÇ",
    å‘¨: "zhÅu",
    å´: "wÃº",
    éƒ‘: "zhÃ¨ng",
    çŽ‹: "wÃ¡ng",
    å†¯: "fÃ©ng",
    é™ˆ: "chÃ©n",
    è¤š: "chÇ”",
    å«: "wÃ¨i",
    è’‹: "jiÇŽng",
    æ²ˆ: "shÄ›n",
    éŸ©: "hÃ¡n",
    æ¨: "yÃ¡ng",
    æœ±: "zhÅ«",
    ç§¦: "qÃ­n",
    å°¤: "yÃ³u",
    è®¸: "xÇ”",
    ä½•: "hÃ©",
    å•: "lÇš",
    æ–½: "shÄ«",
    å¼ : "zhÄng",
    å­”: "kÇ’ng",
    æ›¹: "cÃ¡o",
    ä¸¥: "yÃ¡n",
    åŽ: "huÃ ",
    é‡‘: "jÄ«n",
    é­: "wÃ¨i",
    é™¶: "tÃ¡o",
    å§œ: "jiÄng",
    æˆš: "qÄ«",
    è°¢: "xiÃ¨",
    é‚¹: "zÅu",
    å–»: "yÃ¹",
    æŸ: "bÇŽi",
    æ°´: "shuÇ",
    çª¦: "dÃ²u",
    ç« : "zhÄng",
    äº‘: "yÃºn",
    è‹: "sÅ«",
    æ½˜: "pÄn",
    è‘›: "gÄ›",
    å¥š: "xÄ«",
    èŒƒ: "fÃ n",
    å½­: "pÃ©ng",
    éƒŽ: "lÃ¡ng",
    é²: "lÇ”",
    éŸ¦: "wÃ©i",
    æ˜Œ: "chÄng",
    é©¬: "mÇŽ",
    è‹—: "miÃ¡o",
    å‡¤: "fÃ¨ng",
    èŠ±: "huÄ",
    æ–¹: "fÄng",
    ä¿ž: "yÃº",
    ä»»: "rÃ©n",
    è¢: "yuÃ¡n",
    æŸ³: "liÇ”",
    é…†: "fÄ“ng",
    é²: "bÃ o",
    å²: "shÇ",
    å”: "tÃ¡ng",
    è´¹: "fÃ¨i",
    å»‰: "liÃ¡n",
    å²‘: "cÃ©n",
    è–›: "xuÄ“",
    é›·: "lÃ©i",
    è´º: "hÃ¨",
    å€ª: "nÃ­",
    æ±¤: "tÄng",
    æ»•: "tÃ©ng",
    æ®·: "yÄ«n",
    ç½—: "luÃ³",
    æ¯•: "bÃ¬",
    éƒ: "hÇŽo",
    é‚¬: "wÅ«",
    å®‰: "Än",
    å¸¸: "chÃ¡ng",
    ä¹: "yuÃ¨",
    äºŽ: "yÃº",
    æ—¶: "shÃ­",
    å‚…: "fÃ¹",
    çš®: "pÃ­",
    åž: "biÃ n",
    é½: "qÃ­",
    åº·: "kÄng",
    ä¼: "wÇ”",
    ä½™: "yÃº",
    å…ƒ: "yuÃ¡n",
    åœ: "bÇ”",
    é¡¾: "gÃ¹",
    å­Ÿ: "mÃ¨ng",
    å¹³: "pÃ­ng",
    é»„: "huÃ¡ng",
    å’Œ: "hÃ©",
    ç©†: "mÃ¹",
    è§: "xiÄo",
    å°¹: "yÇn",
    å§š: "yÃ¡o",
    é‚µ: "shÃ o",
    æ¹›: "zhÃ n",
    æ±ª: "wÄng",
    ç¥: "qÃ­",
    æ¯›: "mÃ¡o",
    ç¦¹: "yÇ”",
    ç‹„: "dÃ­",
    ç±³: "mÇ",
    è´: "bÃ¨i",
    æ˜Ž: "mÃ­ng",
    è‡§: "zÄng",
    è®¡: "jÃ¬",
    ä¼: "fÃº",
    æˆ: "chÃ©ng",
    æˆ´: "dÃ i",
    è°ˆ: "tÃ¡n",
    å®‹: "sÃ²ng",
    èŒ…: "mÃ¡o",
    åºž: "pÃ¡ng",
    ç†Š: "xiÃ³ng",
    çºª: "jÇ",
    èˆ’: "shÅ«",
    å±ˆ: "qÅ«",
    é¡¹: "xiÃ ng",
    ç¥: "zhÃ¹",
    è‘£: "dÇ’ng",
    æ¢: "liÃ¡ng",
    æœ: "dÃ¹",
    é˜®: "ruÇŽn",
    è“: "lÃ¡n",
    é—µ: "mÇn",
    å¸­: "xÃ­",
    å­£: "jÃ¬",
    éº»: "mÃ¡",
    å¼º: "qiÃ¡ng",
    è´¾: "jiÇŽ",
    è·¯: "lÃ¹",
    å¨„: "lÃ³u",
    å±: "wÄ“i",
    æ±Ÿ: "jiÄng",
    ç«¥: "tÃ³ng",
    é¢œ: "yÃ¡n",
    éƒ­: "guÅ",
    æ¢…: "mÃ©i",
    ç››: "shÃ¨ng",
    æž—: "lÃ­n",
    åˆ: "diÄo",
    é’Ÿ: "zhÅng",
    å¾: "xÃº",
    é‚±: "qiÅ«",
    éª†: "luÃ²",
    é«˜: "gÄo",
    å¤: "xiÃ ",
    è”¡: "cÃ i",
    ç”°: "tiÃ¡n",
    æ¨Š: "fÃ¡n",
    èƒ¡: "hÃº",
    å‡Œ: "lÃ­ng",
    éœ: "huÃ²",
    è™ž: "yÃº",
    ä¸‡: "wÃ n",
    æ”¯: "zhÄ«",
    æŸ¯: "kÄ“",
    æ˜: "zÇŽn",
    ç®¡: "guÇŽn",
    å¢: "lÃº",
    èŽ«: "mÃ²",
    ç»: "jÄ«ng",
    æˆ¿: "fÃ¡ng",
    è£˜: "qiÃº",
    ç¼ª: "miÃ o",
    å¹²: "gÄn",
    è§£: "xiÃ¨",
    åº”: "yÄ«ng",
    å®—: "zÅng",
    ä¸: "dÄ«ng",
    å®£: "xuÄn",
    è´²: "bÄ“n",
    é‚“: "dÃ¨ng",
    éƒ: "yÃ¹",
    å•: "shÃ n",
    æ­: "hÃ¡ng",
    æ´ª: "hÃ³ng",
    åŒ…: "bÄo",
    è¯¸: "zhÅ«",
    å·¦: "zuÇ’",
    çŸ³: "shÃ­",
    å´”: "cuÄ«",
    å‰: "jÃ­",
    é’®: "niÇ”",
    é¾š: "gÅng",
    ç¨‹: "chÃ©ng",
    åµ‡: "jÄ«",
    é‚¢: "xÃ­ng",
    æ»‘: "huÃ¡",
    è£´: "pÃ©i",
    é™†: "lÃ¹",
    è£: "rÃ³ng",
    ç¿: "wÄ“ng",
    è€: "xÃºn",
    ç¾Š: "yÃ¡ng",
    æ–¼: "yÅ«",
    æƒ : "huÃ¬",
    ç”„: "zhÄ“n",
    æ›²: "qÅ«",
    å®¶: "jiÄ",
    å°: "fÄ“ng",
    èŠ®: "ruÃ¬",
    ç¾¿: "yÃ¬",
    å‚¨: "chÇ”",
    é³: "jÃ¬n",
    æ±²: "jÃ­",
    é‚´: "bÇng",
    ç³œ: "mÃ­",
    æ¾: "sÅng",
    äº•: "jÇng",
    æ®µ: "duÃ n",
    å¯Œ: "fÃ¹",
    å·«: "wÅ«",
    ä¹Œ: "wÅ«",
    ç„¦: "jiÄo",
    å·´: "bÄ",
    å¼“: "gÅng",
    ç‰§: "mÃ¹",
    éš—: "wÄ›i",
    å±±: "shÄn",
    è°·: "gÇ”",
    è½¦: "chÄ“",
    ä¾¯: "hÃ³u",
    å®“: "mÃ¬",
    è“¬: "pÃ©ng",
    å…¨: "quÃ¡n",
    éƒ—: "xÄ«",
    ç­: "bÄn",
    ä»°: "yÇŽng",
    ç§‹: "qiÅ«",
    ä»²: "zhÃ²ng",
    ä¼Š: "yÄ«",
    å®«: "gÅng",
    å®: "nÃ¬ng",
    ä»‡: "qiÃº",
    æ ¾: "luÃ¡n",
    æš´: "bÃ o",
    ç”˜: "gÄn",
    é’­: "tÇ’u",
    åŽ‰: "lÃ¬",
    æˆŽ: "rÃ³ng",
    ç¥–: "zÇ”",
    æ­¦: "wÇ”",
    ç¬¦: "fÃº",
    åˆ˜: "liÃº",
    æ™¯: "jÇng",
    è©¹: "zhÄn",
    æŸ: "shÃ¹",
    é¾™: "lÃ³ng",
    å¶: "yÃ¨",
    å¹¸: "xÃ¬ng",
    å¸: "sÄ«",
    éŸ¶: "shÃ¡o",
    éƒœ: "gÃ o",
    é»Ž: "lÃ­",
    è“Ÿ: "jÃ¬",
    è–„: "bÃ³",
    å°: "yÃ¬n",
    å®¿: "sÃ¹",
    ç™½: "bÃ¡i",
    æ€€: "huÃ¡i",
    è’²: "pÃº",
    é‚°: "tÃ¡i",
    ä»Ž: "cÃ³ng",
    é„‚: "Ã¨",
    ç´¢: "suÇ’",
    å’¸: "xiÃ¡n",
    ç±: "jÃ­",
    èµ–: "lÃ i",
    å“: "zhuÃ³",
    è”º: "lÃ¬n",
    å± : "tÃº",
    è’™: "mÃ©ng",
    æ± : "chÃ­",
    ä¹”: "qiÃ¡o",
    é˜´: "yÄ«n",
    é¬±: "yÃ¹",
    èƒ¥: "xÅ«",
    èƒ½: "nÃ i",
    è‹: "cÄng",
    åŒ: "shuÄng",
    é—»: "wÃ©n",
    èŽ˜: "shÄ“n",
    å…š: "dÇŽng",
    ç¿Ÿ: "zhÃ¡i",
    è°­: "tÃ¡n",
    è´¡: "gÃ²ng",
    åŠ³: "lÃ¡o",
    é€„: "pÃ¡ng",
    å§¬: "jÄ«",
    ç”³: "shÄ“n",
    æ‰¶: "fÃº",
    å µ: "dÇ”",
    å†‰: "rÇŽn",
    å®°: "zÇŽi",
    éƒ¦: "lÃ¬",
    é›: "yÅng",
    éƒ¤: "xÃ¬",
    ç’©: "qÃº",
    æ¡‘: "sÄng",
    æ¡‚: "guÃ¬",
    æ¿®: "pÃº",
    ç‰›: "niÃº",
    å¯¿: "shÃ²u",
    é€š: "tÅng",
    è¾¹: "biÄn",
    æ‰ˆ: "hÃ¹",
    ç‡•: "yÄn",
    å†€: "jÃ¬",
    éƒ: "jiÃ¡",
    æµ¦: "pÇ”",
    å°š: "shÃ ng",
    å†œ: "nÃ³ng",
    æ¸©: "wÄ“n",
    åˆ«: "biÃ©",
    åº„: "zhuÄng",
    æ™: "yÃ n",
    æŸ´: "chÃ¡i",
    çž¿: "qÃº",
    é˜Ž: "yÃ¡n",
    å……: "chÅng",
    æ…•: "mÃ¹",
    è¿ž: "liÃ¡n",
    èŒ¹: "rÃº",
    ä¹ : "xÃ­",
    å®¦: "huÃ n",
    è‰¾: "Ã i",
    é±¼: "yÃº",
    å®¹: "rÃ³ng",
    å‘: "xiÃ ng",
    å¤: "gÇ”",
    æ˜“: "yÃ¬",
    æ…Ž: "shÃ¨n",
    æˆˆ: "gÄ“",
    å»–: "liÃ o",
    åº¾: "yÇ”",
    ç»ˆ: "zhÅng",
    æš¨: "jÃ¬",
    å±…: "jÅ«",
    è¡¡: "hÃ©ng",
    æ­¥: "bÃ¹",
    éƒ½: "dÅ«",
    è€¿: "gÄ›ng",
    æ»¡: "mÇŽn",
    å¼˜: "hÃ³ng",
    åŒ¡: "kuÄng",
    å›½: "guÃ³",
    æ–‡: "wÃ©n",
    å¯‡: "kÃ²u",
    å¹¿: "guÇŽng",
    ç¦„: "lÃ¹",
    é˜™: "quÄ“",
    ä¸œ: "dÅng",
    æ¬§: "Åu",
    æ®³: "shÅ«",
    æ²ƒ: "wÃ²",
    åˆ©: "lÃ¬",
    è”š: "wÃ¨i",
    è¶Š: "yuÃ¨",
    å¤”: "kuÃ­",
    éš†: "lÃ³ng",
    å¸ˆ: "shÄ«",
    å·©: "gÇ’ng",
    åŽ: "shÃ¨",
    è‚: "niÃ¨",
    æ™: "chÃ¡o",
    å‹¾: "gÅu",
    æ•–: "Ã¡o",
    èž: "rÃ³ng",
    å†·: "lÄ›ng",
    è¨¾: "zÄ«",
    è¾›: "xÄ«n",
    é˜š: "kÃ n",
    é‚£: "nÄ",
    ç®€: "jiÇŽn",
    é¥¶: "rÃ¡o",
    ç©º: "kÅng",
    æ›¾: "zÄ“ng",
    æ¯: "mÇ”",
    æ²™: "shÄ",
    ä¹œ: "niÃ¨",
    å…»: "yÇŽng",
    éž : "jÅ«",
    é¡»: "xÅ«",
    ä¸°: "fÄ“ng",
    å·¢: "chÃ¡o",
    å…³: "guÄn",
    è’¯: "kuÇŽi",
    ç›¸: "xiÃ ng",
    æŸ¥: "zhÄ",
    åŽ: "hÃ²u",
    è†: "jÄ«ng",
    çº¢: "hÃ³ng",
    æ¸¸: "yÃ³u",
    ç«º: "zhÃº",
    æƒ: "quÃ¡n",
    é€¯: "lÃ¹",
    ç›–: "gÄ›",
    ç›Š: "yÃ¬",
    æ¡“: "huÃ¡n",
    å…¬: "gÅng",
    ç‰Ÿ: "mÃ³u",
    å“ˆ: "hÇŽ",
    è¨€: "yÃ¡n",
    ç¦: "fÃº",
    è‚–: "xiÄo",
    åŒº: "Åu",
    è¦ƒ: "qÃ­n",
    æœ´: "piÃ¡o",
    ç¹: "pÃ³",
    å‘˜: "yÃ¹n",
    å¥: "gÅu",
    è¦: "yÄo",
    è¿‡: "guÅ",
    é’»: "zuÄn",
    è°Œ: "chÃ©n",
    æŠ˜: "shÃ©",
    å¬: "shÃ o",
    éƒ„: "qiÃ¨",
    æ’’: "sÇŽ",
    ç”¯: "nÃ¬ng",
    å…­: "lÃ¹",
    å•œ: "chuÃ i",
    è¡Œ: "xÃ­ng"
  };
  const PatternSurname = Object.keys(Surnames).map((key) => ({
    zh: key,
    pinyin: Surnames[key],
    probability: 1 + stringLength(key),
    length: stringLength(key),
    priority: Priority.Surname,
    dict: Symbol("surname")
  }));
  const DICT2 = {
    è¿™ä¸ª: "zhÃ¨ ge",
    æˆä¸º: "chÃ©ng wÃ©i",
    è®¤ä¸º: "rÃ¨n wÃ©i",
    ä½œä¸º: "zuÃ² wÃ©i",
    éƒ¨åˆ†: "bÃ¹ fen",
    è¦æ±‚: "yÄo qiÃº",
    åº”è¯¥: "yÄ«ng gÄi",
    å¢žé•¿: "zÄ“ng zhÇŽng",
    æä¾›: "tÃ­ gÅng",
    è§‰å¾—: "juÃ© de",
    ä»»åŠ¡: "rÃ¨n wu",
    é‚£ä¸ª: "nÃ  ge",
    ç§°ä¸º: "chÄ“ng wÃ©i",
    ä¸ºä¸»: "wÃ©i zhÇ”",
    äº†è§£: "liÇŽo jiÄ›",
    å¤„ç†: "chÇ” lÇ",
    çš‡ä¸Š: "huÃ¡ng shang",
    åªè¦: "zhÇ yÃ o",
    å¤§é‡: "dÃ  liÃ ng",
    åŠ›é‡: "lÃ¬ liÃ ng",
    å‡ ä¹Ž: "jÄ« hÅ«",
    å¹²éƒ¨: "gÃ n bÃ¹",
    ç›®çš„: "mÃ¹ dÃ¬",
    è¡Œä¸º: "xÃ­ng wÃ©i",
    åªè§: "zhÇ jiÃ n",
    è®¤è¯†: "rÃ¨n shi",
    å¸‚é•¿: "shÃ¬ zhÇŽng",
    å¸ˆçˆ¶: "shÄ« fu",
    è°ƒæŸ¥: "diÃ o chÃ¡",
    é‡æ–°: "chÃ³ng xÄ«n",
    åˆ†ä¸º: "fÄ“n wÃ©i",
    çŸ¥è¯†: "zhÄ« shi",
    å¯¼å¼¹: "dÇŽo dÃ n",
    è´¨é‡: "zhÃ¬ liÃ ng",
    è¡Œæ¬¾: "hÃ¡ng kuÇŽn",
    è¡Œåˆ—: "hÃ¡ng liÃ¨",
    è¡Œè¯: "hÃ¡ng huÃ ",
    è¡Œä¸š: "hÃ¡ng yÃ¨",
    éš”è¡Œ: "gÃ© hÃ¡ng",
    åœ¨è¡Œ: "zÃ i hÃ¡ng",
    è¡Œå®¶: "hÃ¡ng jia",
    å†…è¡Œ: "nÃ¨i hÃ¡ng",
    å¤–è¡Œ: "wÃ i hÃ¡ng",
    åŒè¡Œ: "tÃ³ng hÃ¡ng",
    æœ¬è¡Œ: "bÄ›n hÃ¡ng",
    è¡Œä¼: "hÃ¡ng wÇ”",
    æ´‹è¡Œ: "yÃ¡ng hÃ¡ng",
    é“¶è¡Œ: "yÃ­n hÃ¡ng",
    å•†è¡Œ: "shÄng hÃ¡ng",
    æ”¯è¡Œ: "zhÄ« hÃ¡ng",
    æ€»è¡Œ: "zÇ’ng hÃ¡ng",
    è¡Œæƒ…: "hÃ¡ng qÃ­ng",
    æ‡‚è¡Œ: "dÇ’ng hÃ¡ng",
    è¡Œè§„: "hÃ¡ng guÄ«",
    è¡Œå½“: "hÃ¡ng dang",
    è¡Œè´§: "hÃ¡ng huÃ²",
    å¤ªè¡Œ: "tÃ i hÃ¡ng",
    å…¥è¡Œ: "rÃ¹ hÃ¡ng",
    ä¸­è¡Œ: "zhÅng hÃ¡ng",
    å†œè¡Œ: "nÃ³ng hÃ¡ng",
    å·¥è¡Œ: "gÅng hÃ¡ng",
    å»ºè¡Œ: "jiÃ n hÃ¡ng",
    å„è¡Œ: "gÃ¨ hÃ¡ng",
    è¡Œå·: "hÃ¡ng hÃ o",
    è¡Œé«˜: "hÃ¡ng gÄo",
    è¡Œé¦–: "hÃ¡ng shÇ’u",
    è¡Œå°¾: "hÃ¡ng wÄ›i",
    è¡Œæœ«: "hÃ¡ng mÃ²",
    è¡Œé•¿: "hÃ¡ng chÃ¡ng",
    è¡Œè·: "hÃ¡ng jÃ¹",
    æ¢è¡Œ: "huÃ n hÃ¡ng",
    è¡Œä¼š: "hÃ¡ng huÃ¬",
    è¡Œè¾ˆ: "hÃ¡ng bÃ¨i",
    è¡Œé“: "hÃ¡ng dÃ o",
    é“è¡Œ: "dÃ o heng",
    å‚ä¸Ž: "cÄn yÃ¹",
    å……åˆ†: "chÅng fÃ¨n",
    å°½ç®¡: "jÇn guÇŽn",
    ç”Ÿé•¿: "shÄ“ng zhÇŽng",
    æ•°é‡: "shÃ¹ liÃ ng",
    åº”å½“: "yÄ«ng dÄng",
    é™¢é•¿: "yuÃ n zhÇŽng",
    å¼ºè°ƒ: "qiÃ¡ng diÃ o",
    åªèƒ½: "zhÇ nÃ©ng",
    éŸ³ä¹: "yÄ«n yuÃ¨",
    ä»¥ä¸º: "yÇ wÃ©i",
    å¤„äºŽ: "chÇ” yÃº",
    éƒ¨é•¿: "bÃ¹ zhÇŽng",
    è’™å¤: "mÄ›ng gÇ”",
    åªæœ‰: "zhÇ yÇ’u",
    é€‚å½“: "shÃ¬ dÃ ng",
    åªå¥½: "zhÇ hÇŽo",
    æˆé•¿: "chÃ©ng zhÇŽng",
    é«˜å…´: "gÄo xÃ¬ng",
    ä¸äº†: "bÃ¹ liÇŽo",
    äº§é‡: "chÇŽn liÃ ng",
    èƒ–å­: "pÃ ng zi",
    æ˜¾å¾—: "xiÇŽn de",
    åªæ˜¯: "zhÇ shÃ¬",
    ä¼¼çš„: "shÃ¬ de",
    çŽ‡é¢†: "shuÃ i lÇng",
    æ”¹ä¸º: "gÇŽi wÃ©i",
    ä¸ç¦: "bÃ¹ jÄ«n",
    æˆåˆ†: "chÃ©ng fÃ¨n",
    ç­”åº”: "dÄ ying",
    å°‘å¹´: "shÃ o niÃ¡n",
    å…´è¶£: "xÃ¬ng qÃ¹",
    å¤ªç›‘: "tÃ i jian",
    ä¼‘æ¯: "xiÅ« xi",
    æ ¡é•¿: "xiÃ o zhÇŽng",
    æ›´æ–°: "gÄ“ng xÄ«n",
    åˆåŒ: "hÃ© tong",
    å–é“: "hÃ¨ dÃ o",
    é‡åº†: "chÃ³ng qÃ¬ng",
    é‡å»º: "chÃ³ng jiÃ n",
    ä½¿å¾—: "shÇ de",
    å®¡æŸ¥: "shÄ›n chÃ¡",
    ç´¯è®¡: "lÄ›i jÃ¬",
    ç»™äºˆ: "jÇ yÇ”",
    æžä¸º: "jÃ­ wÃ©i",
    å† å†›: "guÃ n jÅ«n",
    ä»¿ä½›: "fÇŽng fÃº",
    å¤´å‘: "tÃ³u fa",
    æŠ•é™: "tÃ³u xiÃ¡ng",
    å®¶é•¿: "jiÄ zhÇŽng",
    ä»”ç»†: "zÇ xÃ¬",
    è¦æ˜¯: "yÃ o shi",
    å°†é¢†: "jiÃ ng lÇng",
    å«é‡: "hÃ¡n liÃ ng",
    æ›´ä¸º: "gÃ¨ng wÃ©i",
    ç§¯ç´¯: "jÄ« lÄ›i",
    åœ°å¤„: "dÃ¬ chÇ”",
    åŽ¿é•¿: "xiÃ n zhÇŽng",
    å°‘å¥³: "shÃ o nÇš",
    è·¯ä¸Š: "lÃ¹ shang",
    åªæ€•: "zhÇ pÃ ",
    èƒ½é‡: "nÃ©ng liÃ ng",
    å‚¨é‡: "chÇ” liÃ ng",
    ä¾›åº”: "gÅng yÃ¬ng",
    æŒ‘æˆ˜: "tiÇŽo zhÃ n",
    è¥¿è—: "xÄ« zÃ ng",
    è®°å¾—: "jÃ¬ de",
    æ€»é‡: "zÇ’ng liÃ ng",
    å½“çœŸ: "dÃ ng zhÄ“n",
    å°†å£«: "jiÃ ng shÃ¬",
    å·®åˆ«: "chÄ biÃ©",
    è¾ƒä¸º: "jiÃ o wÃ©i",
    é•¿è€: "zhÇŽng lÇŽo",
    å¤§å¤«: "dÃ i fu",
    å·®å¼‚: "chÄ yÃ¬",
    æ‡‚å¾—: "dÇ’ng de",
    å°½é‡: "jÇn liÃ ng",
    æ¨¡æ ·: "mÃº yÃ ng",
    çš„ç¡®: "dÃ­ quÃ¨",
    ä¸ºé¦–: "wÃ©i shÇ’u",
    ä¾¿å®œ: "piÃ¡n yi",
    æ›´å: "gÄ“ng mÃ­ng",
    çŸ³å¤´: "shÃ­ tou",
    å·žé•¿: "zhÅu zhÇŽng",
    ä¸ºæ­¢: "wÃ©i zhÇ",
    æ¼‚äº®: "piÃ o liang",
    ç‚®å¼¹: "pÃ o dÃ n",
    è—æ—: "zÃ ng zÃº",
    è§’è‰²: "juÃ© sÃ¨",
    å½“ä½œ: "dÃ ng zuÃ²",
    å°½å¿«: "jÇn kuÃ i",
    äººä¸º: "rÃ©n wÃ©i",
    é‡å¤: "chÃ³ng fÃ¹",
    èƒ¡åŒ: "hÃº tÃ²ng",
    å·®è·: "chÄ jÃ¹",
    å¼Ÿå…„: "dÃ¬ xiong",
    å¤§å°†: "dÃ  jiÃ ng",
    ç¡è§‰: "shuÃ¬ jiÃ o",
    ä¸€è§‰: "yÃ­ jiÃ o",
    å›¢é•¿: "tuÃ¡n zhÇŽng",
    é˜Ÿé•¿: "duÃ¬ zhÇŽng",
    åŒºé•¿: "qÅ« zhÇŽng",
    éš¾å¾—: "nÃ¡n dÃ©",
    ä¸«å¤´: "yÄ tou",
    ä¼šé•¿: "huÃ¬ zhÇŽng",
    å¼Ÿå¼Ÿ: "dÃ¬ di",
    çŽ‹çˆ·: "wÃ¡ng ye",
    é‡é‡: "zhÃ²ng liÃ ng",
    èª‰ä¸º: "yÃ¹ wÃ©i",
    å®¶ä¼™: "jiÄ huo",
    åŽå±±: "huÃ  shÄn",
    æ¤…å­: "yÇ zi",
    æµé‡: "liÃº liÃ ng",
    é•¿å¤§: "zhÇŽng dÃ ",
    å‹‰å¼º: "miÇŽn qiÇŽng",
    ä¼šè®¡: "kuÃ i jÃ¬",
    è¿‡åˆ†: "guÃ² fÃ¨n",
    æµŽå—: "jÇ nÃ¡n",
    è°ƒåŠ¨: "diÃ o dÃ²ng",
    ç‡•äº¬: "yÄn jÄ«ng",
    å°‘å°†: "shÃ o jiÃ ng",
    ä¸­æ¯’: "zhÃ²ng dÃº",
    æ™“å¾—: "xiÇŽo de",
    å˜æ›´: "biÃ n gÄ“ng",
    æ‰“æ›´: "dÇŽ gÄ“ng",
    è®¤å¾—: "rÃ¨n de",
    è‹¹æžœ: "pÃ­ng guÇ’",
    å¿µå¤´: "niÃ n tou",
    æŒ£æ‰Ž: "zhÄ“ng zhÃ¡",
    ä¸‰è—: "sÄn zÃ ng",
    å‰¥å‰Š: "bÅ xuÄ“",
    ä¸žç›¸: "chÃ©ng xiÃ ng",
    å°‘é‡: "shÇŽo liÃ ng",
    å¯»æ€: "xÃºn si",
    å¤ºå¾—: "duÃ³ dÃ©",
    å¹²çº¿: "gÃ n xiÃ n",
    å‘¼å: "hÅ« yÃ¹",
    å¤„ç½š: "chÇ” fÃ¡",
    é•¿å®˜: "zhÇŽng guÄn",
    æŸæž—: "bÃ³ lÃ­n",
    äº²æˆš: "qÄ«n qi",
    èº«åˆ†: "shÄ“n fÃ¨n",
    èƒ³è†Š: "gÄ“ bo",
    ç€æ‰‹: "zhuÃ³ shÇ’u",
    ç‚¸å¼¹: "zhÃ  dÃ n",
    å’³å—½: "kÃ© sou",
    å¶å­: "yÃ¨ zi",
    å¤–é•¿: "wÃ i zhÇŽng",
    ä¾›ç»™: "gÅng jÇ",
    å¸ˆé•¿: "shÄ« zhÇŽng",
    å˜é‡: "biÃ n liÃ ng",
    åº”æœ‰: "yÄ«ng yÇ’u",
    ä¸‹è½½: "xiÃ  zÃ i",
    ä¹å™¨: "yuÃ¨ qÃ¬",
    é—´æŽ¥: "jiÃ n jiÄ“",
    åº•ä¸‹: "dÇ xiÃ ",
    æ‰“æ‰®: "dÇŽ bÃ n",
    å­å¼¹: "zÇ dÃ n",
    å¼¹è¯: "dÃ n yÃ o",
    çƒ­é‡: "rÃ¨ liÃ ng",
    å‰Šå¼±: "xuÄ“ ruÃ²",
    éª¨å¹²: "gÇ” gÃ n",
    å®¹é‡: "rÃ³ng liÃ ng",
    æ¨¡ç³Š: "mÃ³ hu",
    è½¬åŠ¨: "zhuÃ n dÃ²ng",
    ç§°å‘¼: "chÄ“ng hu",
    ç§‘é•¿: "kÄ“ zhÇŽng",
    å¤„ç½®: "chÇ” zhÃ¬",
    ç€é‡: "zhuÃ³ zhÃ²ng",
    ç€æ€¥: "zhÃ¡o jÃ­",
    å¼ºè¿«: "qiÇŽng pÃ²",
    åº­é•¿: "tÃ­ng zhÇŽng",
    é¦–ç›¸: "shÇ’u xiÃ ng",
    å–‡å˜›: "lÇŽ ma",
    é•‡é•¿: "zhÃ¨n zhÇŽng",
    åªç®¡: "zhÇ guÇŽn",
    é‡é‡: "chÃ³ng chÃ³ng",
    å…å¾—: "miÇŽn de",
    ç€å®ž: "zhuÃ³ shÃ­",
    åº¦å‡: "dÃ¹ jiÃ ",
    çœŸç›¸: "zhÄ“n xiÃ ng",
    ç›¸è²Œ: "xiÃ ng mÃ o",
    å¤„åˆ†: "chÇ” fÃ¨n",
    å§”å±ˆ: "wÄ›i qu",
    ä¸ºæœŸ: "wÃ©i qÄ«",
    ä¼¯ä¼¯: "bÃ³ bo",
    ä¼¯å­: "bÇŽi zi",
    åœˆå­: "quÄn zi",
    è§è¯†: "jiÃ n shi",
    ç¬¼ç½©: "lÇ’ng zhÃ o",
    ä¸Žä¼š: "yÃ¹ huÃ¬",
    éƒ½ç£: "dÅ« du",
    éƒ½å¸‚: "dÅ« shÃ¬",
    æˆéƒ½: "chÃ©ng dÅ«",
    é¦–éƒ½: "shÇ’u dÅ«",
    å¸éƒ½: "dÃ¬ dÅ«",
    çŽ‹éƒ½: "wÃ¡ng dÅ«",
    ä¸œéƒ½: "dÅng dÅ«",
    éƒ½æŠ¤: "dÅ« hÃ¹",
    éƒ½åŸŽ: "dÅ« chÃ©ng",
    å»ºéƒ½: "jiÃ n dÅ«",
    è¿éƒ½: "qiÄn dÅ«",
    æ•…éƒ½: "gÃ¹ dÅ«",
    å®šéƒ½: "dÃ¬ng dÅ«",
    ä¸­éƒ½: "zhÅng dÅ«",
    å…­å®‰: "lÃ¹ Än",
    å®°ç›¸: "zÇŽi xiÃ ng",
    è¾ƒé‡: "jiÃ o liÃ ng",
    å¯¹ç§°: "duÃ¬ chÃ¨n",
    æ€»é•¿: "zÇ’ng zhÇŽng",
    ç›¸å…¬: "xiÃ ng gong",
    ç©ºç™½: "kÃ²ng bÃ¡i",
    æ‰“é‡: "dÇŽ liang",
    æ°´åˆ†: "shuÇ fÃ¨n",
    èˆŒå¤´: "shÃ© tou",
    æ²¡æ”¶: "mÃ² shÅu",
    è¡ŒæŽ: "xÃ­ng li",
    åˆ¤å¤„: "pÃ n chÇ”",
    æ•£æ–‡: "sÇŽn wÃ©n",
    å¤„å¢ƒ: "chÇ” jÃ¬ng",
    å­™å­: "sÅ«n zi",
    æ‹³å¤´: "quÃ¡n tou",
    æ‰“å‘: "dÇŽ fÄ",
    ç»„é•¿: "zÇ” zhÇŽng",
    éª¨å¤´: "gÇ” tou",
    å®å¯: "nÃ¬ng kÄ›",
    æ›´æ¢: "gÄ“ng huÃ n",
    è–„å¼±: "bÃ³ ruÃ²",
    è¿˜åŽŸ: "huÃ¡n yuÃ¡n",
    é‡ä¿®: "chÃ³ng xiÅ«",
    é‡æ¥: "chÃ³ng lÃ¡i",
    åªé¡¾: "zhÇ gÃ¹",
    çˆ±å¥½: "Ã i hÃ o",
    é¦’å¤´: "mÃ¡n tou",
    å†›é•¿: "jÅ«n zhÇŽng",
    é¦–é•¿: "shÇ’u zhÇŽng",
    åŽ‚é•¿: "chÇŽng zhÇŽng",
    å¸é•¿: "sÄ« zhÇŽng",
    é•¿å­: "zhÇŽng zÇ",
    å¼ºåŠ²: "qiÃ¡ng jÃ¬ng",
    æ°å½“: "qiÃ  dÃ ng",
    å¤´å„¿: "tÃ³u er",
    ç«™é•¿: "zhÃ n zhÇŽng",
    æŠ˜è…¾: "zhÄ“ teng",
    ç›¸å¤„: "xiÄng chÇ”",
    ç»ŸçŽ‡: "tÇ’ng shuÃ i",
    ä¸­å°†: "zhÅng jiÃ ng",
    å‘½ä¸­: "mÃ¬ng zhÃ²ng",
    åå°†: "mÃ­ng jiÃ ng",
    æœ¨å¤´: "mÃ¹ tou",
    åŠ¨å¼¹: "dÃ²ng tan",
    åœ°å£³: "dÃ¬ qiÃ o",
    å¹²æ´»: "gÃ n huÃ³",
    å°‘çˆ·: "shÃ o ye",
    æ°´é‡: "shuÇ liÃ ng",
    è¡¥ç»™: "bÇ” jÇ",
    å°¾å·´: "wÄ›i ba",
    æ¥å¾—: "lÃ¡i de",
    å¥½å¥‡: "hÃ o qÃ­",
    é’¥åŒ™: "yÃ o shi",
    å½“åš: "dÃ ng zuÃ²",
    æ²‰ç€: "chÃ©n zhuÃ³",
    å“‘å·´: "yÇŽ ba",
    è½¦å­: "chÄ“ zi",
    ä¸Šå°†: "shÃ ng jiÃ ng",
    æ¶å¿ƒ: "Ä› xÄ«n",
    æ‹…å­: "dÃ n zi",
    åº”å±Š: "yÄ«ng jiÃ¨",
    ä¸»è§’: "zhÇ” juÃ©",
    è¿è½¬: "yÃ¹n zhuÇŽn",
    å…„é•¿: "xiÅng zhÇŽng",
    æ ¼å¼: "gÃ© shÃ¬",
    æ­£æœˆ: "zhÄ“ng yuÃ¨",
    è¥é•¿: "yÃ­ng zhÇŽng",
    å½“æˆ: "dÃ ng chÃ©ng",
    å¥³å©¿: "nÇš xu",
    å’½å–‰: "yÄn hÃ³u",
    é‡é˜³: "chÃ³ng yÃ¡ng",
    åŒ–ä¸º: "huÃ  wÃ©i",
    åè•ƒ: "tÇ” bÅ",
    é’»è¿›: "zuÄn jÃ¬n",
    ä¹é˜Ÿ: "yuÃ¨ duÃ¬",
    äº®ç›¸: "liÃ ng xiÃ ng",
    è¢«å­: "bÃ¨i zi",
    èˆå¾—: "shÄ› de",
    æ‰æœ¨: "shÄ mÃ¹",
    å‡»ä¸­: "jÄ« zhÃ²ng",
    æŽ’é•¿: "pÃ¡i zhÇŽng",
    å‡æœŸ: "jiÃ  qÄ«",
    åˆ†é‡: "fÃ¨n liÃ ng",
    æ•°æ¬¡: "shÃ¹ cÃ¬",
    æé˜²: "dÄ« fÃ¡ng",
    å†å–: "yÄo he",
    æŸ¥å¤„: "chÃ¡ chÇ”",
    é‡å­: "liÃ ng zÇ",
    é‡Œå¤´: "lÇ tou",
    è°ƒç ”: "diÃ o yÃ¡n",
    ä¼ºå€™: "cÃ¬ hou",
    é‡ç”³: "chÃ³ng shÄ“n",
    æž•å¤´: "zhÄ›n tou",
    æ‹šå‘½: "pÄ«n mÃ¬ng",
    ç¤¾é•¿: "shÃ¨ zhÇŽng",
    å½’è¿˜: "guÄ« huÃ¡n",
    æ‰¹é‡: "pÄ« liÃ ng",
    ç•œç‰§: "xÃ¹ mÃ¹",
    ç‚¹ç€: "diÇŽn zhÃ¡o",
    ç”šä¸º: "shÃ¨n wÃ©i",
    å°å°†: "xiÇŽo jiÃ ng",
    ç€çœ¼: "zhuÃ³ yÇŽn",
    å¤„æ­»: "chÇ” sÇ",
    åŽŒæ¶: "yÃ n wÃ¹",
    é¼“ä¹: "gÇ” yuÃ¨",
    æ ‘å¹²: "shÃ¹ gÃ n",
    ç§˜é²: "bÃ¬ lÇ”",
    å¤§æ–¹: "dÃ  fÄng",
    å¤–å¤´: "wÃ i tou",
    ç­é•¿: "bÄn zhÇŽng",
    æ˜Ÿå®¿: "xÄ«ng xiÃ¹",
    å®æ„¿: "nÃ¬ng yuÃ n",
    é’¦å·®: "qÄ«n chÄi",
    ä¸ºæ•°: "wÃ©i shÃ¹",
    å‹¾å½“: "gÃ²u dÃ ng",
    å‰Šå‡: "xuÄ“ jiÇŽn",
    é—´è°: "jiÃ n diÃ©",
    åŸ‹æ€¨: "mÃ¡n yuÃ n",
    ç»“å®ž: "jiÄ“ shi",
    è®¡é‡: "jÃ¬ liÃ¡ng",
    æ·¹æ²¡: "yÄn mÃ²",
    æ‘é•¿: "cÅ«n zhÇŽng",
    è¿žé•¿: "liÃ¡n zhÇŽng",
    è‡ªç»™: "zÃ¬ jÇ",
    æ­¦å°†: "wÇ” jiÃ ng",
    æ¸©å·®: "wÄ“n chÄ",
    ç›´å¥”: "zhÃ­ bÃ¨n",
    ä¾›æ±‚: "gÅng qiÃº",
    å‰‚é‡: "jÃ¬ liÃ ng",
    é“é•¿: "dÃ o zhÇŽng",
    æ³„éœ²: "xiÃ¨ lÃ²u",
    çŽ‹å…«: "wÃ¡ng ba",
    åˆ‡å‰²: "qiÄ“ gÄ“",
    é—´éš”: "jiÃ n gÃ©",
    ä¸€æ™ƒ: "yÃ¬ huÇŽng",
    é•¿å‡: "chÃ¡ng jiÃ ",
    ä»¤ç‹: "lÃ­ng hÃº",
    ä¸ºå®³: "wÃ©i hÃ i",
    å¥å­: "jÃ¹ zi",
    å¿è¿˜: "chÃ¡ng huÃ¡n",
    ç–™ç˜©: "gÄ“ da",
    ç‡•å±±: "yÄn shÄn",
    å µå¡ž: "dÇ” sÃ¨",
    å¤ºå† : "duÃ³ guÃ n",
    æ‰Žå®ž: "zhÄ shi",
    ç”µè·: "diÃ n hÃ¨",
    çœ‹å®ˆ: "kÄn shÇ’u",
    å¤è¾Ÿ: "fÃ¹ bÃ¬",
    éƒé—·: "yÃ¹ mÃ¨n",
    å°½æ—©: "jÇn zÇŽo",
    åˆ‡æ–­: "qiÄ“ duÃ n",
    æŒ‡å¤´: "zhÇ tou",
    ä¸ºç”Ÿ: "wÃ©i shÄ“ng",
    ç•œç”Ÿ: "chÃ¹ sheng",
    åˆ‡é™¤: "qiÄ“ chÃº",
    ç€åŠ›: "zhuÃ³ lÃ¬",
    ç€æƒ³: "zhuÃ³ xiÇŽng",
    çº§å·®: "jÃ­ chÄ",
    æŠ•å¥”: "tÃ³u bÃ¨n",
    æ£å­: "gÃ¹n zi",
    å«ç³Š: "hÃ¡n hu",
    å°‘å¦‡: "shÃ o fÃ¹",
    å…´è‡´: "xÃ¬ng zhÃ¬",
    çº³é—·: "nÃ  mÃ¨n",
    å¹²æµ: "gÃ n liÃº",
    å·èµ·: "juÇŽn qÇ",
    æ‰‡å­: "shÃ n zi",
    æ›´æ”¹: "gÄ“ng gÇŽi",
    ç¬¼ç»œ: "lÇ’ng luÃ²",
    å–‡å­: "lÇŽ ba",
    è½½è·: "zÃ i hÃ¨",
    å¦¥å½“: "tuÇ’ dÃ ng",
    ä¸ºéš¾: "wÃ©i nÃ¡n",
    ç€é™†: "zhuÃ³ lÃ¹",
    ç‡•å­: "yÃ n zi",
    å¹²å—: "gÃ n mÃ¡",
    ç™½å‘: "bÃ¡i fÃ ",
    æ€»å¾—: "zÇ’ng dÄ›i",
    å¤¹å‡»: "jiÄ jÄ«",
    æ›å…‰: "bÃ o guÄng",
    æ›²è°ƒ: "qÇ” diÃ o",
    ç›¸æœº: "xiÃ ng jÄ«",
    å«åŒ–: "jiÃ o huÃ ",
    è§’é€: "juÃ© zhÃº",
    å•Šå“Ÿ: "Ä yÅ",
    è½½é‡: "zÃ i zhÃ²ng",
    é•¿è¾ˆ: "zhÇŽng bÃ¨i",
    å‡ºå·®: "chÅ« chÄi",
    åž›å£: "duÇ’ kÇ’u",
    æ’‡å¼€: "piÄ“ kÄi",
    åŽ…é•¿: "tÄ«ng zhÇŽng",
    ç»„åˆ†: "zÇ” fÃ¨n",
    è¯¯å·®: "wÃ¹ chÄ",
    å®¶å½“: "jiÄ dÃ ng",
    ä¼ è®°: "zhuÃ n jÃ¬",
    ä¸ªå­: "gÃ¨ zi",
    é“ºè®¾: "pÅ« shÃ¨",
    å¹²äº‹: "gÃ n shÃ¬",
    æ†èŒ: "gÇŽn jÅ«n",
    å®šé‡: "dÃ¬ng liÃ ng",
    è¿è½½: "yÃ¹n zÃ i",
    ä¼šå„¿: "huÃ¬ er",
    é…‹é•¿: "qiÃº zhÇŽng",
    é‡è¿”: "chÃ³ng fÇŽn",
    å·®é¢: "chÄ Ã©",
    éœ²é¢: "lÃ²u miÃ n",
    é’»ç ”: "zuÄn yÃ¡n",
    å¤§åŸŽ: "dÃ i chÃ©ng",
    ä¸Šå½“: "shÃ ng dÃ ng",
    é”€é‡: "xiÄo liÃ ng",
    ä½œåŠ: "zuÅ fang",
    ç…§ç›¸: "zhÃ o xiÃ ng",
    å“Žå‘€: "Äi yÄ",
    è°ƒé›†: "diÃ o jÃ­",
    çœ‹ä¸­: "kÃ n zhÃ²ng",
    è®®é•¿: "yÃ¬ zhÇŽng",
    é£Žç­: "fÄ“ng zheng",
    è¾Ÿé‚ª: "bÃ¬ xiÃ©",
    ç©ºéš™: "kÃ²ng xÃ¬",
    æ›´è¿­: "gÄ“ng diÃ©",
    åå·®: "piÄn chÄ",
    å£°è°ƒ: "shÄ“ng diÃ o",
    é€‚é‡: "shÃ¬ liÃ ng",
    å±¯å­: "tÃºn zi",
    æ— é‡: "wÃº liÃ ng",
    ç©ºåœ°: "kÃ²ng dÃ¬",
    è°ƒåº¦: "diÃ o dÃ¹",
    æ•£å°„: "sÇŽn shÃ¨",
    åˆ›ä¼¤: "chuÄng shÄng",
    æµ·å‚: "hÇŽi shÄ“n",
    æ»¡è½½: "mÇŽn zÃ i",
    é‡å : "chÃ³ng diÃ©",
    è½å·®: "luÃ² chÄ",
    å•è°ƒ: "dÄn diÃ o",
    è€å°†: "lÇŽo jiÃ ng",
    äººå‚: "rÃ©n shÄ“n",
    é—´æ–­: "jiÃ n duÃ n",
    é‡çŽ°: "chÃ³ng xiÃ n",
    å¤¹æ‚: "jiÄ zÃ¡",
    è°ƒç”¨: "diÃ o yÃ²ng",
    èåœ: "luÃ³ bo",
    é™„ç€: "fÃ¹ zhuÃ³",
    åº”å£°: "yÃ¬ng shÄ“ng",
    ä¸»å°†: "zhÇ” jiÃ ng",
    ç½ªè¿‡: "zuÃ¬ guo",
    å’€åš¼: "jÇ” juÃ©",
    ä¸ºæ”¿: "wÃ©i zhÃ¨ng",
    è¿‡é‡: "guÃ² liÃ ng",
    ä¹æ›²: "yuÃ¨ qÇ”",
    è´Ÿè·: "fÃ¹ hÃ¨",
    æžªå¼¹: "qiÄng dÃ n",
    æ‚„ç„¶: "qiÇŽo rÃ¡n",
    å¤„æ–¹: "chÇ” fÄng",
    æ‚„å£°: "qiÇŽo shÄ“ng",
    æ›²å­: "qÇ” zi",
    æƒ…è°ƒ: "qÃ­ng diÃ o",
    æŒ‘è¡…: "tiÇŽo xÃ¬n",
    ä»£ä¸º: "dÃ i wÃ©i",
    äº†ç»“: "liÇŽo jiÃ©",
    æ‰“ä¸­: "dÇŽ zhÃ²ng",
    é…’å§: "jiÇ” bÄ",
    æ‡’å¾—: "lÇŽn de",
    å¢žé‡: "zÄ“ng liÃ ng",
    è¡£ç€: "yÄ« zhuÃ³",
    éƒ¨å°†: "bÃ¹ jiÃ ng",
    è¦å¡ž: "yÃ o sÃ i",
    èŒ¶å‡ : "chÃ¡ jÄ«",
    æ æ†: "gÃ ng gÇŽn",
    å‡ºæ²¡: "chÅ« mÃ²",
    é²œæœ‰: "xiÇŽn yÇ’u",
    é—´éš™: "jiÃ n xÃ¬",
    é‡æ‹…: "zhÃ²ng dÃ n",
    é‡æ¼”: "chÃ³ng yÇŽn",
    é‡è¯•: "chÃ³ng shÃ¬",
    åº”é…¬: "yÃ¬ng chou",
    åªå½“: "zhÇ dÄng",
    æ¯‹å®: "wÃº nÃ¬ng",
    åŒ…æ‰Ž: "bÄo zÄ",
    å‰å¤´: "qiÃ¡n tou",
    å·çƒŸ: "juÇŽn yÄn",
    éžå¾—: "fÄ“i dÄ›i",
    å¼¹é“: "dÃ n dÃ o",
    æ†å­: "gÄn zi",
    é—¨å°†: "mÃ©n jiÃ ng",
    åŽå¤´: "hÃ²u tou",
    å–å½©: "hÃ¨ cÇŽi",
    æš–å’Œ: "nuÇŽn huo",
    ç´¯ç§¯: "lÄ›i jÄ«",
    è°ƒé£: "diÃ o qiÇŽn",
    å€”å¼º: "juÃ© jiÃ ng",
    å®è—: "bÇŽo zÃ ng",
    ä¸§äº‹: "sÄng shÃ¬",
    çº¦èŽ«: "yuÄ“ mo",
    çº¤å¤«: "qiÃ n fÅ«",
    æ›´æ›¿: "gÄ“ng tÃ¬",
    è£…è½½: "zhuÄng zÃ i",
    èƒŒåŒ…: "bÄ“i bÄo",
    å¸–å­: "tiÄ› zi",
    æ¾æ•£: "sÅng sÇŽn",
    å‘¼å–: "hÅ« hÃ¨",
    å¯æ¶: "kÄ› wÃ¹",
    è‡ªè½¬: "zÃ¬ zhuÃ n",
    ä¾›ç”µ: "gÅng diÃ n",
    åçœ: "fÇŽn xÇng",
    å¦çŽ‡: "tÇŽn shuÃ i",
    è‹æ‰“: "sÅ« dÃ¡",
    æœ¬åˆ†: "bÄ›n fÃ¨n",
    è½å¾—: "luÃ² de",
    é„™è–„: "bÇ bÃ³",
    ç›¸é—´: "xiÄng jiÃ n",
    å•è–„: "dÄn bÃ³",
    æ··è›‹: "hÃºn dÃ n",
    è´žè§‚: "zhÄ“n guÄn",
    é™„å’Œ: "fÃ¹ hÃ¨",
    èƒ½è€: "nÃ©ng nÃ i",
    å“å”¬: "xiÃ  hu",
    æœªäº†: "wÃ¨i liÇŽo",
    å¼•ç€: "yÇn zhÃ¡o",
    æŠ½è°ƒ: "chÅu diÃ o",
    æ²™å­: "shÄ zi",
    å¸­å·: "xÃ­ juÇŽn",
    æ ‡çš„: "biÄo dÃ¬",
    åˆ«æ‰­: "biÃ¨ niu",
    æ€é‡: "sÄ« liang",
    å–é‡‡: "hÃ¨ cÇŽi",
    è®ºè¯­: "lÃºn yÇ”",
    ç›–å­: "gÃ i zi",
    åˆ†å¤–: "fÃ¨n wÃ i",
    å¼„å ‚: "lÃ²ng tÃ¡ng",
    ä¹èˆž: "yuÃ¨ wÇ”",
    é›¨é‡: "yÇ” liÃ ng",
    æ¯›å‘: "mÃ¡o fÃ ",
    å·®é£: "chÄi qiÇŽn",
    èƒŒè´Ÿ: "bÄ“i fÃ¹",
    è½¬é€Ÿ: "zhuÃ n sÃ¹",
    å£°ä¹: "shÄ“ng yuÃ¨",
    å¤¹æ”»: "jiÄ gÅng",
    ä¾›æ°´: "gÅng shuÇ",
    ä¸»å¹²: "zhÇ” gÃ n",
    æƒ©å¤„: "chÃ©ng chÇ”",
    é•¿ç›¸: "zhÇŽng xiÃ ng",
    å…¬å·®: "gÅng chÄi",
    æ¦´å¼¹: "liÃº dÃ n",
    çœå¾—: "shÄ›ng de",
    æ¡å­: "tiÃ¡o zi",
    é‡å›´: "chÃ³ng wÃ©i",
    é˜»å¡ž: "zÇ” sÃ¨",
    åŠ²é£Ž: "jÃ¬ng fÄ“ng",
    çº è‘›: "jiÅ« gÃ©",
    é¢ ç°¸: "diÄn bÇ’",
    ç‚¹ä¸­: "diÇŽn zhÃ²ng",
    é‡åˆ›: "zhÃ²ng chuÄng",
    å§¥å§¥: "lÇŽo lao",
    è¿·ç³Š: "mÃ­ hu",
    å…¬å®¶: "gÅng jia",
    å‡ çŽ‡: "jÄ« lÇœ",
    è‹¦é—·: "kÇ” mÃ¨n",
    åº¦é‡: "dÃ¹ liÃ ng",
    å·®é”™: "chÄ cuÃ²",
    æš‘å‡: "shÇ” jiÃ ",
    å‚å·®: "cÄ“n cÄ«",
    æ­è½½: "dÄ zÃ i",
    åŠ©é•¿: "zhÃ¹ zhÇŽng",
    ç›¸ç§°: "xiÄng chÃ¨n",
    çº¢æ™•: "hÃ³ng yÃ¹n",
    èˆå‘½: "shÄ› mÃ¬ng",
    å–œå¥½: "xÇ hÃ o",
    åˆ—ä¼ : "liÃ¨ zhuÃ n",
    åŠ²æ•Œ: "jÃ¬ng dÃ­",
    è›¤èŸ†: "hÃ¡ ma",
    è¯·å‡: "qÇng jiÃ ",
    é’‰å­: "dÄ«ng zi",
    æ²‰æ²¡: "chÃ©n mÃ²",
    é«˜ä¸½: "gÄo lÃ­",
    ä¼‘å‡: "xiÅ« jiÃ ",
    æ— ä¸º: "wÃº wÃ©i",
    å·´ç»“: "bÄ jie",
    äº†å¾—: "liÇŽo dÃ©",
    å˜ç›¸: "biÃ n xiÃ ng",
    æ ¸å¼¹: "hÃ© dÃ n",
    äº²å®¶: "qÃ¬ng jia",
    æ‰¿è½½: "chÃ©ng zÃ i",
    å–é—®: "hÃ¨ wÃ¨n",
    è¿˜å‡»: "huÃ¡n jÄ«",
    äº¤è¿˜: "jiÄo huÃ¡n",
    å°†ä»¤: "jiÃ ng lÃ¬ng",
    å•äºŽ: "chÃ¡n yÃº",
    ç©ºç¼º: "kÃ²ng quÄ“",
    ç»¿æž—: "lÃ¹ lÃ­n",
    èƒ†é‡: "dÇŽn liÃ ng",
    æ‰§ç€: "zhÃ­ zhuÃ³",
    ä½Žè°ƒ: "dÄ« diÃ o",
    é—­å¡ž: "bÃ¬ sÃ¨",
    è½»è–„: "qÄ«ng bÃ³",
    å¾—å½“: "dÃ© dÃ ng",
    å åœ: "zhÄn bÇ”",
    æ‰«å¸š: "sÃ o zhou",
    é¾Ÿå…¹: "qiÅ« cÃ­",
    å¹´é•¿: "niÃ¡n zhÇŽng",
    å¤–ä¼ : "wÃ i zhuÃ n",
    å¤´å­: "tÃ³u zi",
    è£ç¼: "cÃ¡i feng",
    ç¤¼ä¹: "lÇ yuÃ¨",
    è¡€æ³Š: "xuÃ¨ pÅ",
    æ•£ä¹±: "sÇŽn luÃ n",
    åŠ¨é‡: "dÃ²ng liÃ ng",
    å€’è…¾: "dÇŽo teng",
    å–èˆ: "qÇ” shÄ›",
    å’±å®¶: "zÃ¡n jiÄ",
    é•¿å‘: "chÃ¡ng fÃ ",
    çˆªå“‡: "zhÇŽo wÄ",
    å¼¹å£³: "dÃ n kÃ©",
    çœæ‚Ÿ: "xÇng wÃ¹",
    åš·åš·: "rÄng rang",
    è¿žç´¯: "liÃ¡n lÃ¨i",
    åº”å¾—: "yÄ«ng dÃ©",
    æ—é•¿: "zÃº zhÇŽng",
    æŸœå­: "guÃ¬ zi",
    æ“‚é¼“: "lÃ©i gÇ”",
    çœ©æ™•: "xuÃ n yÃ¹n",
    è°ƒé…: "tiÃ¡o pÃ¨i",
    èº¯å¹²: "qÅ« gÃ n",
    å·®å½¹: "chÄi yÃ¬",
    åŽå·: "kÇŽn kÄ›",
    å°‘å„¿: "shÃ o Ã©r",
    ä¹å›¢: "yuÃ¨ tuÃ¡n",
    å…»åˆ†: "yÇŽng fÃ¨n",
    é€€è¿˜: "tuÃ¬ huÃ¡n",
    æ ¼è°ƒ: "gÃ© diÃ o",
    è¯­è°ƒ: "yÇ” diÃ o",
    éŸ³è°ƒ: "yÄ«n diÃ o",
    ä¹åºœ: "yuÃ¨ fÇ”",
    å¤æœ´: "gÇ” pÇ”",
    æ‰“ç‚¹: "dÇŽ diÇŽn",
    å·®ä½¿: "chÄi shÇ",
    åŒ€ç§°: "yÃºn chÃ¨n",
    ç˜¦å‰Š: "shÃ²u xuÄ“",
    è†è¯: "gÄo yao",
    åžæ²¡: "tÅ«n mÃ²",
    è°ƒä»»: "diÃ o rÃ¨n",
    æ•£å±…: "sÇŽn jÅ«",
    ä¸Šå¤´: "shÃ ng tÃ³u",
    é£Žé¡: "fÄ“ng mÇ",
    æ”¾å‡: "fÃ ng jiÃ ",
    ä¼°é‡: "gÅ« liang",
    å¤±å½“: "shÄ« dÃ ng",
    ä¸­å¼¹: "zhÃ²ng dÃ n",
    å¦„ä¸º: "wÃ ng wÃ©i",
    é•¿è€…: "zhÇŽng zhÄ›",
    èµ·å“„: "qÇ hÃ²ng",
    æœ«äº†: "mÃ² liÇŽo",
    ç›¸å£°: "xiÃ ng sheng",
    æ ¡æ­£: "jiÃ o zhÃ¨ng",
    åŠé™: "quÃ n xiÃ¡ng",
    çŸ¢é‡: "shÇ liÃ ng",
    æ²‰é—·: "chÃ©n mÃ¨n",
    ç»™ä¸Ž: "jÇ yÇ”",
    è§£æ³•: "jiÄ› fÇŽ",
    å¡žå¤–: "sÃ i wÃ i",
    å°†æ ¡: "jiÃ ng xiÃ o",
    å—œå¥½: "shÃ¬ hÃ o",
    æ²¡è½: "mÃ² luÃ²",
    æœ´åˆ€: "pÅ dÄo",
    ç‰‡å­: "piÄn zi",
    åˆ‡å‰Š: "qiÄ“ xiÄo",
    å¼¹ä¸¸: "dÃ n wÃ¡n",
    ç¨€è–„: "xÄ« bÃ³",
    äºå¾—: "kuÄ« dÃ©",
    é—´æ­‡: "jiÃ n xiÄ“",
    ç¿˜é¦–: "qiÃ¡o shÇ’u",
    è‰²è°ƒ: "sÃ¨ diÃ o",
    å¤„å†³: "chÇ” juÃ©",
    è¡¨çŽ‡: "biÇŽo shuÃ i",
    å°ºå­: "chÇ zi",
    æ‹›é™: "zhÄo xiÃ¡ng",
    ç§°èŒ: "chÃ¨n zhÃ­",
    æ–—ç¯·: "dÇ’u peng",
    é“ºå­: "pÃ¹ zi",
    åº•å­: "dÇ zi",
    è´Ÿè½½: "fÃ¹ zÃ i",
    å¹²è­¦: "gÃ n jÇng",
    å€’æ•°: "dÃ o shÇ”",
    å°†å®˜: "jiÃ ng guÄn",
    é”„å¤´: "chÃº tou",
    å½’é™: "guÄ« xiÃ¡ng",
    ç–Ÿç–¾: "nÃ¼Ã¨ ji",
    å” å¨: "lÃ¡o dao",
    é™é‡: "xiÃ n liÃ ng",
    å±æ¯: "bÇng xÄ«",
    é‡é€¢: "chÃ³ng fÃ©ng",
    å™¨ä¹: "qÃ¬ yuÃ¨",
    æ°¢å¼¹: "qÄ«ng dÃ n",
    è„–é¢ˆ: "bÃ³ gÄ›ng",
    å¦ƒå­: "fÄ“i zi",
    å¤„äº‹: "chÇ” shÃ¬",
    å‚é‡: "cÄn liÃ ng",
    è½»çŽ‡: "qÄ«ng shuÃ i",
    ç¼¥ç¼ˆ: "piÄo miÇŽo",
    ä¸­å¥–: "zhÃ²ng jiÇŽng",
    æ‰å¹²: "cÃ¡i gÃ n",
    æ–½èˆ: "shÄ« shÄ›",
    å·å­: "juÃ n zi",
    æ¸¸è¯´: "yÃ³u shuÃ¬",
    å··å­: "xiÃ ng zi",
    è†€èƒ±: "pÃ¡ng guÄng",
    åˆ‡å‹¿: "qiÃ¨ wÃ¹",
    çœ‹ç®¡: "kÄn guÇŽn",
    é£Žå¤´: "fÄ“ng tou",
    ç²¾å¹²: "jÄ«ng gÃ n",
    é«˜å·®: "gÄo chÄ",
    æå“: "kÇ’ng hÃ¨",
    æ‰æ‹…: "biÇŽn dÃ n",
    ç»™å…»: "jÇ yÇŽng",
    æ ¼å­: "gÃ© zi",
    ä¾›éœ€: "gÅng xÅ«",
    åå·®: "fÇŽn chÄ",
    é£žå¼¹: "fÄ“i dÃ n",
    å¾®è–„: "wÄ“i bÃ³",
    å‘åž‹: "fÃ  xÃ­ng",
    å³å…´: "jÃ­ xÃ¬ng",
    æ”’åŠ¨: "cuÃ¡n dÃ²ng",
    é—´æˆ–: "jiÃ n huÃ²",
    æµ…è–„: "qiÇŽn bÃ³",
    ä¹ç« : "yuÃ¨ zhÄng",
    é¡ºå·®: "shÃ¹n chÄ",
    è°ƒå­: "diÃ o zi",
    ç›¸ä½: "xiÃ ng wÃ¨i",
    è½¬å­: "zhuÃ n zÇ",
    åŠ²æ—…: "jÃ¬ng lÇš",
    å’”åš“: "kÄ chÄ",
    äº†äº‹: "liÇŽo shÃ¬",
    è½¬æ‚ : "zhuÃ n you",
    å½“é“º: "dÃ ng pÃ¹",
    çˆªå­: "zhuÇŽ zi",
    å•å­: "dÄn zi",
    å¥½æˆ˜: "hÃ o zhÃ n",
    ç‡•éº¦: "yÃ n mÃ i",
    åªè®¸: "zhÇ xÇ”",
    å¹²ç»ƒ: "gÃ n liÃ n",
    å¥³å°†: "nÇš jiÃ ng",
    é…’é‡: "jiÇ” liÃ ng",
    åˆ’èˆ¹: "huÃ¡ chuÃ¡n",
    ä¼Žä¿©: "jÃ¬ liÇŽng",
    æŒ‘æ‹¨: "tiÇŽo bÅ",
    å°‘æ ¡: "shÃ o xiÃ o",
    ç€è½: "zhuÃ³ luÃ²",
    æ†Žæ¶: "zÄ“ng wÃ¹",
    åˆ»è–„: "kÃ¨ bÃ³",
    è¦æŒŸ: "yÄo xiÃ©",
    ç”¨å¤„: "yÃ²ng chu",
    è¿˜æ‰‹: "huÃ¡n shÇ’u",
    æ¨¡å…·: "mÃº jÃ¹",
    æ‰§è‘—: "zhÃ­ zhuÃ³",
    å–ä»¤: "hÃ¨ lÃ¬ng",
    ä¿é•¿: "bÇŽo zhÇŽng",
    å¸ç€: "xÄ« zhe",
    ç—‡ç»“: "zhÄ“ng jiÃ©",
    å…¬è½¬: "gÅng zhuÃ n",
    æ ¡å‹˜: "jiÃ o kÄn",
    é‡æ: "chÃ³ng tÃ­",
    æ‰«å…´: "sÇŽo xÃ¬ng",
    é“ºç›–: "pÅ« gÃ i",
    é•¿å²: "zhÇŽng shÇ",
    å·®ä»·: "chÄ jiÃ ",
    åŽ‹æ ¹: "yÃ  gÄ“n",
    æ€”ä½: "zhÃ¨ng zhÃ¹",
    åº”å…: "yÄ«ng yÇ”n",
    åˆ‡å…¥: "qiÄ“ rÃ¹",
    æˆ˜å°†: "zhÃ n jiÃ ng",
    å¹´å°‘: "niÃ¡n shÃ o",
    èˆèº«: "shÄ› shÄ“n",
    æ‰§æ‹—: "zhÃ­ niÃ¹",
    å¤„ä¸–: "chÇ” shÃ¬",
    ä¸­é£Ž: "zhÃ²ng fÄ“ng",
    ç­‰é‡: "dÄ›ng liÃ ng",
    æ”¾é‡: "fÃ ng liÃ ng",
    è…”è°ƒ: "qiÄng diÃ o",
    è€å°‘: "lÇŽo shÃ o",
    æ²¡å…¥: "mÃ² rÃ¹",
    ç“œè‘›: "guÄ gÃ©",
    å°†å¸…: "jiÃ ng shuÃ i",
    è½¦è½½: "chÄ“ zÃ i",
    çªå›Š: "wÅ nang",
    é•¿è¿›: "zhÇŽng jÃ¬n",
    å¯æ±—: "kÃ¨ hÃ¡n",
    å¹¶å·ž: "bÄ«ng zhÅu",
    ä¾›é”€: "gÅng xiÄo",
    åˆ‡ç‰‡: "qiÄ“ piÃ n",
    å·®äº‹: "chÄi shÃ¬",
    çŸ¥ä¼š: "zhÄ« hui",
    é¹°çˆª: "yÄ«ng zhÇŽo",
    å¤„å¥³: "chÇ” nÇš",
    åˆ‡ç£‹: "qiÄ“ cuÅ",
    æ—¥å¤´: "rÃ¬ tou",
    æŠ¼è§£: "yÄ jiÃ¨",
    æ»‹é•¿: "zÄ« zhÇŽng",
    é“è§‚: "dÃ o guÃ n",
    è„šè‰²: "juÃ© sÃ¨",
    å½“é‡: "dÄng liÃ ng",
    å©†å®¶: "pÃ³ jia",
    ç¼˜åˆ†: "yuÃ¡n fÃ¨n",
    ç©ºé—²: "kÃ²ng xiÃ¡n",
    å¥½è‰²: "hÃ o sÃ¨",
    æ€’å–: "nÃ¹ hÃ¨",
    ç¬¼ç»Ÿ: "lÇ’ng tÇ’ng",
    è¾¹å¡ž: "biÄn sÃ i",
    ä½•æ›¾: "hÃ© cÃ©ng",
    é‡åˆ: "chÃ³ng hÃ©",
    é›¶æ•£: "lÃ­ng sÇŽn",
    è½°éš†: "hÅng lÅng",
    åŒ–å­: "huÃ  zi",
    å†…è’™: "nÃ¨i mÄ›ng",
    æ•°è½: "shÇ” luÃ²",
    é€†å·®: "nÃ¬ chÄ",
    ç‰Ÿåˆ©: "mÃ³u lÃ¬",
    æ …æ : "zhÃ  lan",
    ä¸­æ ‡: "zhÃ²ng biÄo",
    è°ƒæ¡£: "diÃ o dÃ ng",
    ä½å»: "gÅu lÃ³u",
    åœºå­: "chÇŽng zi",
    ç”²å£³: "jiÇŽ qiÃ o",
    é‡æ¸©: "chÃ³ng wÄ“n",
    ç‚®åˆ¶: "pÃ¡o zhÃ¬",
    è¿”è¿˜: "fÇŽn huÃ¡n",
    è‡ªä¼ : "zÃ¬ zhuÃ n",
    é«˜è°ƒ: "gÄo diÃ o",
    æ®·çº¢: "yÄn hÃ³ng",
    å›ºç€: "gÃ¹ zhuÃ³",
    å¼ºæ±‚: "qiÇŽng qiÃº",
    æœ¬ç›¸: "bÄ›n xiÃ ng",
    éª„æ¨ª: "jiÄo hÃ¨ng",
    è‰çŽ‡: "cÇŽo shuÃ i",
    æ°”é—·: "qÃ¬ mÃ¨n",
    ç€è‰²: "zhuÃ³ sÃ¨",
    å®è‚¯: "nÃ¬ng kÄ›n",
    å…´å¤´: "xÃ¬ng tou",
    æ‹˜æ³¥: "jÅ« nÃ¬",
    å¤¹è§’: "jiÄ jiÇŽo",
    å‘é«»: "fÃ  jÃ¬",
    çŒ›å°†: "mÄ›ng jiÃ ng",
    çº¦æ‘¸: "yuÄ“ mo",
    æ‹–ç´¯: "tuÅ lÄ›i",
    å‘¢ç»’: "nÃ­ rÃ³ng",
    é’»æŽ¢: "zuÄn tÃ n",
    å¤¹å±‚: "jiÄ cÃ©ng",
    è½é­„: "luÃ² pÃ²",
    å··é“: "hÃ ng dÃ o",
    è¿é‡: "yÃ¹n liÃ ng",
    è§£é—·: "jiÄ› mÃ¨n",
    ç©ºå„¿: "kÃ²ng er",
    ä¼°æ‘¸: "gÅ« mo",
    å¥½å®¢: "hÃ o kÃ¨",
    é’»å­”: "zuÄn kÇ’ng",
    ç³Šå¼„: "hÃ¹ nÃ²ng",
    è¥é˜³: "xÃ­ng yÃ¡ng",
    çƒ¦é—·: "fÃ¡n mÃ¨n",
    ä»“å’: "cÄng cÃ¹",
    åˆ†å‰: "fÄ“n chÃ ",
    åŽ‚å­: "chÇŽng zi",
    å°è°ƒ: "xiÇŽo diÃ o",
    å°‘é˜³: "shÃ o yÃ¡ng",
    å—é™: "shÃ²u xiÃ¡ng",
    æŸ“åŠ: "rÇŽn fÃ¡ng",
    èƒ³è‡‚: "gÄ“ bei",
    å°†é—¨: "jiÃ ng mÃ©n",
    æ¨¡æ¿: "mÃº bÇŽn",
    é…ç»™: "pÃ¨i jÇ",
    ä¸ºä¼: "wÃ©i wÇ”",
    è·Ÿå¤´: "gÄ“n tou",
    åˆ’ç®—: "huÃ¡ suÃ n",
    ç´¯èµ˜: "lÃ©i zhui",
    å“„ç¬‘: "hÅng xiÃ o",
    æ™•çœ©: "yÅ«n xuÃ n",
    å¹²æŽ‰: "gÃ n diÃ o",
    ç¼åˆ¶: "fÃ©ng zhÃ¬",
    éš¾å¤„: "nÃ¡n chÃ¹",
    ç€æ„: "zhuÃ³ yÃ¬",
    è›®æ¨ª: "mÃ¡n hÃ¨ng",
    å¥‡æ•°: "jÄ« shÃ¹",
    çŸ­å‘: "duÇŽn fÃ ",
    ç”Ÿè¿˜: "shÄ“ng huÃ¡n",
    è¿˜æ¸…: "huÃ¡n qÄ«ng",
    çœ‹æŠ¤: "kÄn hÃ¹",
    ç›´çŽ‡: "zhÃ­ shuÃ i",
    å¥ä¹: "zÃ²u yuÃ¨",
    è½½å®¢: "zÃ i kÃ¨",
    ä¸“æ¨ª: "zhuÄn hÃ¨ng",
    æ¹®æ²¡: "yÄn mÃ²",
    ç©ºæ ¼: "kÃ²ng gÃ©",
    é“ºåž«: "pÅ« diÃ n",
    è‰¯å°†: "liÃ¡ng jiÃ ng",
    å“—å•¦: "huÄ lÄ",
    æ•£æ¼«: "sÇŽn mÃ n",
    è„±å‘: "tuÅ fÃ ",
    é€è¿˜: "sÃ²ng huÃ¡n",
    åŸ‹æ²¡: "mÃ¡i mÃ²",
    ç´¯åŠ: "lÄ›i jÃ­",
    è–„é›¾: "bÃ³ wÃ¹",
    è°ƒç¦»: "diÃ o lÃ­",
    èˆŒè‹”: "shÃ© tÄi",
    æœºé•¿: "jÄ« zhÇŽng",
    æ “å¡ž: "shuÄn sÃ¨",
    é…è§’: "pÃ¨i juÃ©",
    åˆ‡å£: "qiÄ“ kÇ’u",
    åˆ›å£: "chuÄng kÇ’u",
    å“ˆæ¬ : "hÄ qian",
    å®žå¼¹: "shÃ­ dÃ n",
    é“ºå¹³: "pÅ« pÃ­ng",
    å“ˆè¾¾: "hÇŽ dÃ¡",
    æ‡’æ•£: "lÇŽn sÇŽn",
    å®žå¹²: "shÃ­ gÃ n",
    å¡«ç©º: "tiÃ¡n kÃ²ng",
    åˆé’»: "diÄo zuÄn",
    ä¹å¸ˆ: "yuÃ¨ shÄ«",
    é‡å˜: "liÃ ng biÃ n",
    è¯±é™: "yÃ²u xiÃ¡ng",
    æªå¡ž: "tÃ¡ng sÃ¨",
    å¾è°ƒ: "zhÄ“ng diÃ o",
    å¤¹é“: "jiÄ dÃ o",
    å¹²å’³: "gÄn kÃ©",
    æ­¢å’³: "zhÇ kÃ©",
    ä¹å·¥: "yuÃ¨ gÅng",
    åˆ’è¿‡: "huÃ¡ guÃ²",
    ç€ç«: "zhÃ¡o huÇ’",
    æ›´æ­£: "gÄ“ng zhÃ¨ng",
    ç»™ä»˜: "jÇ fÃ¹",
    ç©ºå­: "kÃ²ng zi",
    å“ªå’: "nÃ© zhÄ",
    æ­£ç€: "zhÃ¨ng zhÃ¡o",
    åˆ·å­: "shuÄ zi",
    ä¸§è‘¬: "sÄng zÃ ng",
    å¤¹å¸¦: "jiÄ dÃ i",
    å®‰åˆ†: "Än fÃ¨n",
    ä¸­æ„: "zhÃ²ng yÃ¬",
    é•¿å­™: "zhÇŽng sÅ«n",
    æ ¡è®¢: "jiÃ o dÃ¬ng",
    å·æ›²: "juÇŽn qÅ«",
    è½½è¿: "zÃ i yÃ¹n",
    æŠ•å¼¹: "tÃ³u dÃ n",
    æŸžèš•: "zuÃ² cÃ¡n",
    ä»½é‡: "fÃ¨n liÃ ng",
    è°ƒæ¢: "diÃ o huÃ n",
    äº†ç„¶: "liÇŽo rÃ¡n",
    å’§å˜´: "liÄ› zuÇ",
    å…¸å½“: "diÇŽn dÃ ng",
    å¯’å‡: "hÃ¡n jiÃ ",
    é•¿å…„: "zhÇŽng xiÅng",
    ç»™æ°´: "jÇ shuÇ",
    é¡»å‘: "xÅ« fÃ ",
    æžå¹²: "zhÄ« gÃ n",
    å±žç›¸: "shÇ” xiÃ ng",
    å“„æŠ¢: "hÅng qiÇŽng",
    åˆ»åˆ’: "kÃ¨ huÃ ",
    å¡žå­: "sÄi zi",
    å•å¹²: "dÄn gÃ n",
    è¿˜ä¹¡: "huÃ¡n xiÄng",
    å…†å¤´: "zhÃ o tou",
    å¯ºè§‚: "sÃ¬ guÃ n",
    ç£çŽ‡: "dÅ« shuÃ i",
    å•Šå“ˆ: "Ä ha",
    å‰²èˆ: "gÄ“ shÄ›",
    æŠ¹å¸ƒ: "mÄ bÃ¹",
    å¥½æ¶: "hÃ o wÃ¹",
    ä¸‹å¤„: "xiÃ  chÇ”",
    æ¶ˆé•¿: "xiÄo zhÇŽng",
    ç¦»é—´: "lÃ­ jiÃ n",
    å‡†å¤´: "zhÇ”n tou",
    æ ¡å¯¹: "jiÃ o duÃ¬",
    ä»€ç‰©: "shÃ­ wÃ¹",
    ç•ªç¦º: "pÄn yÃº",
    ä½›çˆ·: "fÃ³ ye",
    å—å•¡: "mÇŽ fÄ“i",
    ç›åˆ†: "yÃ¡n fÃ¨n",
    è™Žå°†: "hÇ” jiÃ ng",
    è–„è·: "bÃ² he",
    ç‹¬å¤„: "dÃº chÇ”",
    ç©ºä½: "kÃ²ng wÃ¨i",
    é“ºè·¯: "pÅ« lÃ¹",
    ä¹Œæ‹‰: "wÅ« lÄ",
    è°ƒå›ž: "diÃ o huÃ­",
    æ¥å¤´: "lÃ¡i tou",
    é—²æ•£: "xiÃ¡n sÇŽn",
    èƒ¶å·: "jiÄo juÇŽn",
    å†’å¤±: "mÃ o shi",
    å¹²åŠ²: "gÃ n jÃ¬n",
    å¼¦ä¹: "xiÃ¡n yuÃ¨",
    ç›¸å›½: "xiÃ ng guÃ³",
    ä¸¹å‚: "dÄn shÄ“n",
    åŠ©å…´: "zhÃ¹ xÃ¬ng",
    é“ºå¼€: "pÅ« kÄi",
    æ¬¡é•¿: "cÃ¬ zhÇŽng",
    å‘å¡: "fÃ  qiÇŽ",
    æ‹®æ®: "jiÃ© jÅ«",
    åˆ¹è½¦: "shÄ chÄ“",
    ç”Ÿå‘: "shÄ“ng fÃ ",
    é‡æ’­: "chÃ³ng bÅ",
    ç¼åˆ: "fÃ©ng hÃ©",
    éŸ³é‡: "yÄ«n liÃ ng",
    å°‘å°‰: "shÃ o wÃ¨i",
    å†²åŽ‹: "chÃ²ng yÄ",
    è‹åŠ²: "cÄng jÃ¬ng",
    åŽšè–„: "hÃ²u bÃ¡o",
    å¨å“: "wÄ“i hÃ¨",
    å¤–ç›¸: "wÃ i xiÃ ng",
    å‘¼å·: "hÅ« hÃ¡o",
    ç€è¿·: "zhÃ¡o mÃ­",
    æŒ‘æ‹…: "tiÄo dÃ n",
    çº¹è·¯: "wÃ©n lÃ¹",
    è¿˜ä¿—: "huÃ¡n sÃº",
    å¼ºæ¨ª: "qiÃ¡ng hÃ¨ng",
    ç€æ•°: "zhÄo shÃ¹",
    é™é¡º: "xiÃ¡ng shÃ¹n",
    æŒ‘æ˜Ž: "tiÇŽo mÃ­ng",
    çœ¯ç¼: "mÄ« feng",
    åˆ†å†…: "fÃ¨n nÃ¨i",
    æ›´è¡£: "gÄ“ng yÄ«",
    è½¯å’Œ: "ruÇŽn huo",
    å°½å…´: "jÃ¬n xÃ¬ng",
    å·å­: "hÃ o zi",
    çˆªç‰™: "zhÇŽo yÃ¡",
    è´¥å°†: "bÃ i jiÃ ng",
    çŒœä¸­: "cÄi zhÃ²ng",
    ç»“æ‰Ž: "jiÃ© zÄ",
    æ²¡ç©º: "mÃ©i kÃ²ng",
    å¤¹ç¼: "jiÄ fÃ¨ng",
    æ‹¾æŽ‡: "shÃ­ duo",
    æŽºå’Œ: "chÄn huo",
    ç°¸ç®•: "bÃ² ji",
    ç”µé‡: "diÃ n liÃ ng",
    è·è½½: "hÃ¨ zÇŽi",
    è°ƒå¼: "diÃ o shÃ¬",
    å¤„èº«: "chÇ” shÄ“n",
    æ‰“æ‰‹: "dÇŽ shÇ’u",
    å¼¹å¼“: "dÃ n gÅng",
    æ¨ªè›®: "hÃ¨ng mÃ¡n",
    èƒ½å¹²: "nÃ©ng gÃ n",
    æ ¡ç‚¹: "jiÃ o diÇŽn",
    åŠ è½½: "jiÄ zÃ i",
    å¹²æ ¡: "gÃ n xiÃ o",
    å“„ä¼ : "hÅng chuÃ¡n",
    æ ¡æ³¨: "jiÃ o zhÃ¹",
    æ·¤å¡ž: "yÅ« sÃ¨",
    é©¬æ‰Ž: "mÇŽ zhÃ¡",
    æœˆæ°: "yuÃ¨ zhÄ«",
    é«˜å¹²: "gÄo gÃ n",
    ç»ä¼ : "jÄ«ng zhuÃ n",
    æ›¾å­™: "zÄ“ng sÅ«n",
    å¥½æ–—: "hÃ o dÃ²u",
    å…³å¡: "guÄn qiÇŽ",
    é€ƒå¥”: "tÃ¡o bÃ¨n",
    ç£¨è¹­: "mÃ³ ceng",
    ç‰Ÿå–: "mÃ³u qÇ”",
    é¢¤æ —: "zhÃ n lÃ¬",
    èš‚èš±: "mÃ  zha",
    æ’®åˆ: "cuÅ he",
    è¶”è¶„: "liÃ¨ qie",
    æ‘”æ‰“: "shuÄi dÇŽ",
    å°å­: "tÃ¡i zi",
    åˆ†å¾—: "fÄ“n de",
    ç²˜ç€: "niÃ¡n zhuÃ³",
    é‡‡é‚‘: "cÃ i yÃ¬",
    æ•£è£…: "sÇŽn zhuÄng",
    å©€å¨œ: "Ä“ nuÃ³",
    å…´å‘³: "xÃ¬ng wÃ¨i",
    è¡Œå¤´: "xÃ­ng tou",
    æ°”é‡: "qÃ¬ liÃ ng",
    è°ƒè¿: "diÃ o yÃ¹n",
    å¤„æ²»: "chÇ” zhÃ¬",
    ä¹éŸ³: "yuÃ¨ yÄ«n",
    å……å¡ž: "chÅng sÃ¨",
    æ«å“: "dÃ²ng hÃ¨",
    è®ºè°ƒ: "lÃ¹n diÃ o",
    ç›¸ä¸­: "xiÄng zhÃ²ng",
    æ°‘ä¹: "mÃ­n yuÃ¨",
    ç‚®ä»—: "pÃ o zhang",
    ä¸§æœ: "sÄng fÃº",
    éªå°†: "xiÄo jiÃ ng",
    é‡åˆ‘: "liÃ ng xÃ­ng",
    ç¼è¡¥: "fÃ©ng bÇ”",
    è´¢ä¼š: "cÃ¡i kuÃ i",
    å¤§å¹²: "dÃ  gÃ n",
    åŽ†æ•°: "lÃ¬ shÇ”",
    æ ¡åœº: "jiÃ o chÇŽng",
    å¡žåŒ—: "sÃ i bÄ›i",
    è¯†ç›¸: "shÃ­ xiÃ ng",
    è¾±æ²¡: "rÇ” mÃ²",
    é²œäº®: "xiÄn liÃ ng",
    è¯­å¡ž: "yÇ” sÃ¨",
    éœ²è„¸: "lÃ²u liÇŽn",
    å‡‰å¿«: "liÃ¡ng kuai",
    è…°æ†: "yÄo gÇŽn",
    æºœè¾¾: "liÅ« da",
    å˜Žå˜Ž: "gÄ gÄ",
    å…¬å¹²: "gÅng gÃ n",
    æ¡”æ¢—: "jiÃ© gÄ›ng",
    æŒ‘é€—: "tiÇŽo dÃ²u",
    çœ‹é—¨: "kÄn mÃ©n",
    ä¹æ­Œ: "yuÃ¨ gÄ“",
    æ‹“ç‰‡: "tÃ  piÃ n",
    æŒ‘åŠ¨: "tiÇŽo dÃ²ng",
    å‡†å°†: "zhÇ”n jiÃ ng",
    é’åŠ²: "qiÃº jÃ¬ng",
    ç£¨åŠ: "mÃ² fÃ¡ng",
    é€¶è¿¤: "wÄ“i yÃ­",
    æ…å’Œ: "jiÇŽo huo",
    æ‘©æŒ²: "mÃ³ suÅ",
    ä½œå¼„: "zuÃ² nÃ²ng",
    è‹—å¤´: "miÃ¡o tou",
    æ‰“é¢¤: "dÇŽ zhÃ n",
    å¤§è—: "dÃ  zÃ ng",
    ç•œç‰²: "chÃ¹ shÄ“ng",
    å‹¾æ­: "gÅu da",
    æ ‘è«: "shÃ¹ yÄ«n",
    æ ‘æˆ: "shÃ¹ chÃ ",
    é“æ†: "tiÄ› gÇŽn",
    å°†ç›¸: "jiÃ ng xiÃ ng",
    ä»½å­: "fÃ¨n zi",
    è§†å·®: "shÃ¬ chÄ",
    ç»¿è«: "lÇœ yÄ«n",
    æžªæ†: "qiÄng gÇŽn",
    ç¼çº«: "fÃ©ng rÃ¨n",
    æ„é—·: "chÃ³u mÃ¨n",
    ç‚¹å°†: "diÇŽn jiÃ ng",
    åŽä½—: "huÃ  tuÃ³",
    åŠ²å°„: "jÃ¬ng shÃ¨",
    ç®±ç¬¼: "xiÄng lÇ’ng",
    ç»ˆäº†: "zhÅng liÇŽo",
    é¬“å‘: "bÃ¬n fÃ ",
    ç»“å·´: "jiÄ“ ba",
    è‹¦å¹²: "kÇ” gÃ n",
    çœ‹å®¶: "kÄn jiÄ",
    æ­£æ—¦: "zhÄ“ng dÃ n",
    ä¸­è‚¯: "zhÃ²ng kÄ›n",
    åŽ¦é—¨: "xiÃ  mÃ©n",
    ä¸œèŽž: "dÅng guÇŽn",
    é£Ÿé‡: "shÃ­ liÃ ng",
    å®«è°ƒ: "gÅng diÃ o",
    é—´ä½œ: "jiÃ n zuÃ²",
    å¼¹ç‰‡: "dÃ n piÃ n",
    å·®æ± : "chÄ chÃ­",
    æ¼‚ç™½: "piÇŽo bÃ¡i",
    æ å­: "gÃ ng zi",
    è°ƒå¤„: "tiÃ¡o chÇ”",
    å¥½åŠ¨: "hÃ o dÃ²ng",
    è½¬ç‚‰: "zhuÃ n lÃº",
    å±æ°”: "bÇng qÃ¬",
    å¤¹æ¿: "jiÄ bÇŽn",
    å“€ä¹: "Äi yuÃ¨",
    å¹²é“: "gÃ n dÃ o",
    è‹¦å¤„: "kÇ” chÃ¹",
    åŠˆæŸ´: "pÇ chÃ¡i",
    é•¿åŠ¿: "zhÇŽng shÃ¬",
    å¤©åŽ: "tiÄn huÃ¡",
    å…±å¤„: "gÃ²ng chÇ”",
    æ ¡éªŒ: "jiÃ o yÃ n",
    å‡ºå¡ž: "chÅ« sÃ i",
    ç£¨ç›˜: "mÃ² pÃ¡n",
    èŽé¡: "wÄ›i mÇ",
    å¥”ä¸§: "bÄ“n sÄng",
    å”±å’Œ: "chÃ ng hÃ¨",
    å¤§è°ƒ: "dÃ  diÃ o",
    éžåˆ†: "fÄ“i fÃ¨n",
    é’»è¥: "zuÄn yÃ­ng",
    å¤¹å­: "jiÄ zi",
    è¶…è½½: "chÄo zÃ i",
    æ›´å§‹: "gÄ“ng shÇ",
    é“ƒé“›: "lÃ­ng dang",
    æŠ«æ•£: "pÄ« sÃ n",
    å‘è¿˜: "fÄ huÃ¡n",
    è½¬è½®: "zhuÃ n lÃºn",
    æ¨ªè´¢: "hÃ¨ng cÃ¡i",
    æ³¡æ¡: "pÄo tÃ³ng",
    æŠ›æ’’: "pÄo sÇŽ",
    å¤©å‘€: "tiÄn yÄ",
    ç³Šç³Š: "hÅ« hu",
    èº¯å£³: "qÅ« qiÃ o",
    é€šé‡: "tÅng liÃ ng",
    å¥‰è¿˜: "fÃ¨ng huÃ¡n",
    åˆè§‰: "wÇ” jiÃ o",
    é—·æ£: "mÃ¨n gÃ¹n",
    æµªå¤´: "lÃ ng tou",
    ç šå°: "yÃ n tÃ¡i",
    æ²¹åŠ: "yÃ³u fÃ¡ng",
    å­¦é•¿: "xuÃ© zhÇŽng",
    è¿‡è½½: "guÃ² zÃ i",
    ç¬”è°ƒ: "bÇ diÃ o",
    è¡£è¢«: "yÄ« bÃ¨i",
    ç•œäº§: "xÃ¹ chÇŽn",
    è°ƒé˜…: "diÃ o yuÃ¨",
    è›®å¹²: "mÃ¡n gÃ n",
    æ›¾ç¥–: "zÄ“ng zÇ”",
    æå¹²: "tÃ­ gÃ n",
    å˜è°ƒ: "biÃ n diÃ o",
    è¦†æ²¡: "fÃ¹ mÃ²",
    æ¨¡å­: "mÃº zi",
    ä¹å¾‹: "yuÃ¨ lÇœ",
    ç§°å¿ƒ: "chÃ¨n xÄ«n",
    æœ¨æ†: "mÃ¹ gÄn",
    é‡å°: "chÃ³ng yÃ¬n",
    è‡ªçœ: "zÃ¬ xÇng",
    æè°ƒ: "tÃ­ diÃ o",
    çœ‹ç›¸: "kÃ n xiÃ ng",
    èŠ‹å¤´: "yÃ¹ tou",
    ä¸‹åˆ‡: "xiÃ  qiÄ“",
    å¡žä¸Š: "sÃ i shÃ ng",
    é“ºå¼ : "pÅ« zhÄng",
    è—¤è”“: "tÃ©ng wÃ n",
    è–„å¹¸: "bÃ³ xÃ¬ng",
    è§£æ•°: "xiÃ¨ shÃ¹",
    è¤ªåŽ»: "tuÃ¬ qÃ¹",
    éœ°å¼¹: "xiÃ n dÃ n",
    æŸšæœ¨: "yÃ³u mÃ¹",
    ç—•é‡: "hÃ©n liÃ ng",
    é›…ä¹: "yÇŽ yuÃ¨",
    å·å“­: "hÃ¡o kÅ«",
    è¯ˆé™: "zhÃ  xiÃ¡ng",
    çŒªåœˆ: "zhÅ« juÃ n",
    å’‹èˆŒ: "zÃ© shÃ©",
    é“£åºŠ: "xÇ chuÃ¡ng",
    é˜²å¼¹: "fÃ¡ng dÃ n",
    å¥å°†: "jiÃ n jiÃ ng",
    ä¸½æ°´: "lÃ­ shuÇ",
    å‰Šå‘: "xuÄ“ fÃ ",
    ç©ºå½“: "kÃ²ng dÄng",
    å¤šç›¸: "duÅ xiÃ ng",
    é²œè§: "xiÇŽn jiÃ n",
    åˆ’æ¡¨: "huÃ¡ jiÇŽng",
    è½½æ³¢: "zÃ i bÅ",
    è·³èš¤: "tiÃ o zao",
    ä¿çš®: "qiÃ o pÃ­",
    å§å—’: "bÄ dÄ",
    ç»“å‘: "jiÃ© fÃ ",
    äº†æ–­: "liÇŽo duÃ n",
    åŒè°ƒ: "tÃ³ng diÃ o",
    çŸ³ç£¨: "shÃ­ mÃ²",
    æ—¶å·®: "shÃ­ chÄ",
    é¼»å¡ž: "bÃ­ sÃ¨",
    æŒ‘å­: "tiÄo zi",
    æŽ¨ç£¨: "tuÄ« mÃ²",
    æ­¦ä¾¯: "wÇ” hÃ³u",
    æŠ¹ç…ž: "mÇ’ shÄ",
    è°ƒè½¬: "diÃ o zhuÇŽn",
    ç±æ²¡: "jÃ­ mÃ²",
    è¿˜å€º: "huÃ¡n zhÃ i",
    è°ƒæ¼”: "diÃ o yÇŽn",
    åˆ†åˆ’: "fÄ“n huÃ¡",
    å¥‡å¶: "jÄ« Ç’u",
    æ–­å–: "duÃ n hÃ¨",
    é—·é›·: "mÃ¨n lÃ©i",
    ç‹¼è—‰: "lÃ¡ng jÃ­",
    é¥­é‡: "fÃ n liÃ ng",
    è¿˜ç¤¼: "huÃ¡n lÇ",
    è½¬è°ƒ: "zhuÇŽn diÃ o",
    æ˜Ÿç›¸: "xÄ«ng xiÃ ng",
    æ‰‹ç›¸: "shÇ’u xiÃ ng",
    é…ä¹: "pÃ¨i yuÃ¨",
    ç›–å¤´: "gÃ i tou",
    è¿žæ†: "liÃ¡n gÇŽn",
    ç°¿è®°: "bÃ¹ jÃ¬",
    åˆ€æŠŠ: "dÄo bÃ ",
    é‡è¯: "liÃ ng cÃ­",
    åè§’: "mÃ­ng juÃ©",
    æ­¥è°ƒ: "bÃ¹ diÃ o",
    æ ¡æœ¬: "jiÃ o bÄ›n",
    è´¦ç°¿: "zhÃ ng bÃ¹",
    éš½æ°¸: "juÃ n yÇ’ng",
    ç¨ä¸º: "shÄo wÃ©i",
    æ˜“ä¼ : "yÃ¬ zhuÃ n",
    ä¹è°±: "yuÃ¨ pÇ”",
    ç‰µç´¯: "qiÄn lÄ›i",
    ç­”ç†: "dÄ li",
    å–æ–¥: "hÃ¨ chÃ¬",
    åŸå“¦: "yÃ­n Ã©",
    å¹²æ¸ : "gÃ n qÃº",
    æµ·é‡: "hÇŽi liÃ ng",
    ç²¾å½“: "jÄ«ng dÃ ng",
    ç€åºŠ: "zhuÃ³ chuÃ¡ng",
    æœˆç›¸: "yuÃ¨ xiÃ ng",
    åº¶å‡ : "shÃ¹ jÄ«",
    å®«è§‚: "gÅng guÃ n",
    è®ºå¤„: "lÃ¹n chÇ”",
    å¾è¾Ÿ: "zhÄ“ng bÃ¬",
    åŽšæœ´: "hÃ²u pÃ²",
    ä»‹å£³: "jiÃ¨ qiÃ o",
    å­å“§: "kÄ“ng chÄ«",
    å’¯è¡€: "kÇŽ xiÄ›",
    é“ºé™ˆ: "pÅ« chÃ©n",
    é‡ç”Ÿ: "chÃ³ng shÄ“ng",
    ä¹ç†: "yuÃ¨ lÇ",
    å“€å·: "Äi hÃ¡o",
    è—åŽ†: "zÃ ng lÃ¬",
    åˆšåŠ²: "gÄng jÃ¬ng",
    å‰Šå¹³: "xuÄ“ pÃ­ng",
    æµ“è«: "nÃ³ng yÄ«n",
    åŸŽåž›: "chÃ©ng duÇ’",
    å½“å·®: "dÄng chÄi",
    æ­£ä¼ : "zhÃ¨ng zhuÃ n",
    å¹¶å¤„: "bÃ¬ng chÇ”",
    åˆ›é¢: "chuÄng miÃ n",
    æ—¦è§’: "dÃ n juÃ©",
    è–„ç¤¼: "bÃ³ lÇ",
    æ™ƒè¡: "huÃ ng dang",
    è‡Šå­: "sÃ o zi",
    å®¶ä»€: "jiÄ shÃ­",
    é—·å¤´: "mÄ“n tÃ³u",
    ç¾Žå‘: "mÄ›i fÃ ",
    åº¦æ•°: "dÃ¹ shu",
    ç€å‡‰: "zhÃ¡o liÃ¡ng",
    é—¯å°†: "chuÇŽng jiÃ ng",
    å‡ æ¡ˆ: "jÄ« Ã n",
    å§˜å¤´: "pÄ«n tou",
    å·®æ•°: "chÄ shÃ¹",
    æ•£ç¢Ž: "sÇŽn suÃ¬",
    å£…å¡ž: "yÅng sÃ¨",
    å¯’é¢¤: "hÃ¡n zhÃ n",
    ç‰µå¼º: "qiÄn qiÇŽng",
    æ— é—´: "wÃº jiÃ n",
    è½®è½¬: "lÃºn zhuÃ n",
    å·å«: "hÃ¡o jiÃ o",
    é“ºæŽ’: "pÅ« pÃ¡i",
    é™ä¼: "xiÃ¡ng fÃº",
    è½§é’¢: "zhÃ¡ gÄng",
    ä¸œé˜¿: "dÅng Ä“",
    ç—…å‡: "bÃ¬ng jiÃ ",
    ç´¯åŠ : "lÄ›i jiÄ",
    æ¢—å¡ž: "gÄ›ng sÃ¨",
    å¼¹å¤¹: "dÃ n jiÄ",
    é’»å¿ƒ: "zuÄn xÄ«n",
    æ™ƒçœ¼: "huÇŽng yÇŽn",
    é­”çˆª: "mÃ³ zhÇŽo",
    æ ‡é‡: "biÄo liÃ ng",
    æ†‹é—·: "biÄ“ mÃ¨n",
    çŒœåº¦: "cÄi duÃ³",
    å¤„å£«: "chÇ” shÃ¬",
    å®˜å·®: "guÄn chÄi",
    è®¨è¿˜: "tÇŽo huÃ¡n",
    é•¿é—¨: "chÃ¡ng mÃ©n",
    é¦åˆ†: "liÃº fÄ“n",
    é‡Œå¼„: "lÇ lÃ²ng",
    è‰²ç›¸: "sÃ¨ xiÃ ng",
    é›…å…´: "yÇŽ xÃ¬ng",
    è§’åŠ›: "juÃ© lÃ¬",
    å¼¹å‘: "dÃ n kÄ“ng",
    æžæˆ: "zhÄ« chÃ ",
    å¤¹å…·: "jiÄ jÃ¹",
    å¤„åˆ‘: "chÇ” xÃ­ng",
    æ‚å°†: "hÃ n jiÃ ng",
    å¥½å­¦: "hÃ o xuÃ©",
    å¥½å¥½: "hÇŽo hÇŽo",
    é“¶å‘: "yÃ­n fÃ ",
    æ‰«æŠŠ: "sÃ o bÇŽ",
    æ³•ç›¸: "fÇŽ xiÃ ng",
    è´µå¹²: "guÃ¬ gÃ n",
    ä¾›æ°”: "gÅng qÃ¬",
    ç©ºä½™: "kÃ²ng yÃº",
    æ†æ‰Ž: "kÇ”n zÄ",
    ç˜ è–„: "jÃ­ bÃ³",
    æµ†ç³Š: "jiÃ ng hu",
    å˜Žå±: "gÄ zhÄ«",
    è°ƒä»¤: "diÃ o lÃ¬ng",
    æ³•å¸–: "fÇŽ tiÃ¨",
    æ·‹ç—…: "lÃ¬n bÃ¬ng",
    è°ƒæ´¾: "diÃ o pÃ i",
    è½¬ç›˜: "zhuÃ n pÃ¡n",
    ä¾›ç¨¿: "gÅng gÇŽo",
    å·®å®˜: "chÄi guÄn",
    å¿§é—·: "yÅu mÃ¨n",
    æ•™é•¿: "jiÃ o zhÇŽng",
    é‡å”±: "chÃ³ng chÃ ng",
    é…’å…´: "jiÇ” xÃ¬ng",
    ä¹å›: "yuÃ¨ tÃ¡n",
    èŠ±å‘¢: "huÄ nÃ­",
    å±å–: "chÃ¬ hÃ¨",
    è†€è‡‚: "bÇŽng bÃ¬",
    å¾—ç©º: "dÃ© kÃ²ng",
    è½¬åœˆ: "zhuÃ n quÄn",
    æ¨ªæš´: "hÃ¨ng bÃ o",
    å“„æŠ¬: "hÅng tÃ¡i",
    å¼•å­: "yÇn hÃ¡ng",
    è½½è´§: "zÃ i huÃ²",
    ä¸­è®¡: "zhÃ²ng jÃ¬",
    å®˜é•¿: "guÄn zhÇŽng",
    ç›¸é¢: "xiÃ ng miÃ n",
    çœ‹å¤´: "kÃ n tou",
    ç›¼å¤´: "pÃ n tou",
    æ„å…´: "yÃ¬ xÃ¬ng",
    å†›ä¹: "jÅ«n yuÃ¨",
    ç´¯æ¬¡: "lÄ›i cÃ¬",
    éª¨å˜Ÿ: "gÇ” dÅ«",
    ç‡•èµµ: "yÄn zhÃ o",
    æŠ¥ä¸§: "bÃ o sÄng",
    å¼¥æ’’: "mÃ­ sa",
    æŒ¨æ–—: "Ã¡i dÃ²u",
    æ‰èˆŸ: "piÄn zhÅu",
    ä¸‘è§’: "chÇ’u juÃ©",
    åŠä¸§: "diÃ o sÄng",
    å¼ºå°†: "qiÃ¡ng jiÃ ng",
    é‡å¥: "chÃ³ng zÃ²u",
    å‘è¾«: "fÃ  biÃ n",
    ç€é­”: "zhÃ¡o mÃ³",
    ç€æ³•: "zhÄo fÇŽ",
    ç››æ”¾: "shÃ¨ng fÃ ng",
    å¡«å¡ž: "tiÃ¡n sÃ¨",
    å‡¶æ¨ª: "xiÅng hÃ¨ng",
    ç¨½é¦–: "qÇ shÇ’u",
    ç¢‘å¸–: "bÄ“i tiÃ¨",
    å†²é‡: "chÅng liÃ ng",
    å‘èœ: "fÃ  cÃ i",
    å‡å‘: "jiÇŽ fÃ ",
    ç¿»å·: "fÄn juÇŽn",
    å°é‡: "xiÇŽo liÃ ng",
    èƒ¶ç€: "jiÄo zhuÃ³",
    é‡Œå­: "lÇ zi",
    è°ƒè°ƒ: "diÃ o diao",
    æ•£å…µ: "sÇŽn bÄ«ng",
    é«˜æŒ‘: "gÄo tiÇŽo",
    æ’­æ’’: "bÅ sÇŽ",
    å¤¹å¿ƒ: "jiÄ xÄ«n",
    æ‰‡åŠ¨: "shÄn dÃ²ng",
    å¨æ‰°: "tÄo rÇŽo",
    éœ“è£³: "nÃ­ chÃ¡ng",
    æ»å­: "niÇŽn zi",
    å¼¥ç¼: "mÃ­ fÃ©ng",
    æ’’å¸ƒ: "sÇŽ bÃ¹",
    åœºé™¢: "chÃ¡ng yuÃ n",
    çœäº²: "xÇng qÄ«n",
    ææ‹‰: "tÃ­ lÄ",
    æƒ¯é‡: "guÃ n liÃ ng",
    å¼ºé€¼: "qiÃ¡ng bÄ«",
    å¼ºå¾: "qiÃ¡ng zhÄ“ng",
    æ™•è½¦: "yÃ¹n chÄ“",
    æ•°é“: "shÃ¹ dÃ o",
    å¸¦ç´¯: "dÃ i lÃ¨i",
    æ‹“æœ¬: "tÃ  bÄ›n",
    å«Œæ¶: "xiÃ¡n wÃ¹",
    å®¿å°†: "sÃ¹ jiÃ ng",
    é¾Ÿè£‚: "jÅ«n liÃ¨",
    ç¼ å¤¹: "chÃ¡n jiÄ",
    å‘å¼: "fÃ  shÃ¬",
    éš”æ‰‡: "gÃ© shÃ n",
    å¤©åˆ†: "tiÄn fÃ¨n",
    ç™–å¥½: "pÇ hÃ o",
    å››é€š: "sÃ¬ tÅng",
    ç™½æœ¯: "bÃ¡i zhÃº",
    åˆ’ä¼¤: "huÃ¡ shÄng",
    è§’æ–—: "juÃ© dÃ²u",
    å¬å·®: "tÄ«ng chÄi",
    å²å·®: "suÃ¬ chÄ",
    ä¸§ç¤¼: "sÄng lÇ",
    è„‰è„‰: "mÃ² mÃ²",
    å‰Šç˜¦: "xuÄ“ shÃ²u",
    æ’’æ’­: "sÇŽ bÅ",
    èŽŽè‰: "suÅ cÇŽo",
    çŠä¸º: "qiÃ¡n wÃ©i",
    è°ƒå¤´: "diÃ o tÃ³u",
    é¾™å·: "lÃ³ng juÇŽn",
    å¤–è°ƒ: "wÃ i diÃ o",
    å­—å¸–: "zÃ¬ tiÃ¨",
    å·å‘: "juÇŽn fÃ ",
    æ£åº¦: "chuÇŽi duÃ³",
    æ´‹ç›¸: "yÃ¡ng xiÃ ng",
    æ•£å…‰: "sÇŽn guÄng",
    éª¨ç¢Œ: "gÅ« lu",
    è–„å‘½: "bÃ³ mÃ¬ng",
    ç¬¼å¤´: "lÃ³ng tÃ³u",
    å’½ç‚Ž: "yÄn yÃ¡n",
    ç¢Œç¢¡: "liÃ¹ zhou",
    ç‰‡å„¿: "piÃ n er",
    çº¤æ‰‹: "qiÃ n shÇ’u",
    æ•£ä½“: "sÇŽn tÇ",
    å†…çœ: "nÃ¨i xÇng",
    å¼ºç•™: "qiÃ¡ng liÃº",
    è§£é€: "jiÃ¨ sÃ²ng",
    åé—´: "fÇŽn jiÃ n",
    å°‘å£®: "shÃ o zhuÃ ng",
    ç•™ç©º: "liÃº kÅng",
    å‘Šå‡: "gÃ o jiÃ ",
    å’³è¡€: "kÃ© xuÃ¨",
    è–„æš®: "bÃ³ mÃ¹",
    é“ºè½¨: "pÅ« guÇ",
    ç£¨å‰Š: "mÃ³ xuÄ“",
    æ²»ä¸§: "zhÃ¬ sÄng",
    å‰å­: "chÄ zi",
    å“„åŠ¨: "hÅng dÃ²ng",
    è›¾å­: "Ã© zi",
    å‡ºè½: "chÅ« luÃ²",
    è‚¡é•¿: "gÇ” zhÇŽng",
    è´µå¤„: "guÃ¬ chÃ¹",
    è¿˜é­‚: "huÃ¡n hÃºn",
    ä¾‹å‡: "lÃ¬ jiÃ ",
    åˆ¹ä½: "shÄ zhÃ¹",
    èº«é‡: "shÄ“n liÃ ng",
    åŒå¥½: "tÃ³ng hÃ o",
    æ¨¡é‡: "mÃ³ liÃ ng",
    æ›´ç”Ÿ: "gÄ“ng shÄ“ng",
    æœä¸§: "fÃº sÄng",
    çŽ‡ç›´: "shuÃ i zhÃ­",
    å­—æ¨¡: "zÃ¬ mÃº",
    æ•£æž¶: "sÇŽn jiÃ ",
    ç­”è…”: "dÄ qiÄng",
    äº¤æ¶: "jiÄo wÃ¹",
    è–„æƒ…: "bÃ³ qÃ­ng",
    çœ¼æ³¡: "yÇŽn pÄo",
    è¢…å¨œ: "niÇŽo nuÃ³",
    è‰åž›: "cÇŽo duÃ²",
    å†²åŠ²: "chÃ²ng jÃ¬n",
    å‘¢å–ƒ: "nÃ­ nÃ¡n",
    åˆ‡ä¸­: "qiÃ¨ zhÃ²ng",
    æŒ‘ç¯: "tiÇŽo dÄ“ng",
    è¿˜æ„¿: "huÃ¡n yuÃ n",
    æ¿€å°†: "jÄ« jiÃ ng",
    æ›´é¼“: "gÄ“ng gÇ”",
    æ²¡è¯: "mÃ² yÃ o",
    è´¥å…´: "bÃ i xÃ¬ng",
    åˆ‡é¢: "qiÄ“ miÃ n",
    æ•£æˆ·: "sÇŽn hÃ¹",
    ç´¯è¿›: "lÄ›i jÃ¬n",
    èƒŒå¸¦: "bÄ“i dÃ i",
    ç§¤æ†: "chÃ¨ng gÇŽn",
    ç¢¾åŠ: "niÇŽn fÃ¡ng",
    ç°¿å­: "bÃ¹ zi",
    æ‰³æ‰‹: "bÄn shÇ’u",
    é“…å±±: "yÃ¡n shÄn",
    å„’å°†: "rÃº jiÃ ng",
    é‡å…‰: "chÃ³ng guÄng",
    å‰ªå‘: "jiÇŽn fÃ ",
    é•¿ä¸Š: "zhÇŽng shÃ ng",
    å°ä¼ : "xiÇŽo zhuÃ n",
    åŽ‹è½´: "yÄ zhÃ²u",
    å¼±å† : "ruÃ² guÃ n",
    èŠ±å·: "huÄ juÇŽn",
    æ¨ªç¥¸: "hÃ¨ng huÃ²",
    å¤¹å…‹: "jiÄ kÃ¨",
    å…‰æ™•: "guÄng yÃ¹n",
    æŠ«é¡: "pÄ« mÇ",
    å¯¹è°ƒ: "duÃ¬ diÃ o",
    å¤¹æŒ: "jiÄ chÃ­",
    ç©ºé¢: "kÃ²ng Ã©",
    å¹³è°ƒ: "pÃ­ng diÃ o",
    é“ºåºŠ: "pÅ« chuÃ¡ng",
    ä¸§é’Ÿ: "sÄng zhÅng",
    ä½œä¹: "zuÃ² lÃ¨",
    å°‘åºœ: "shÃ o fÇ”",
    æ•°æ•°: "shuÃ² shuÃ²",
    å¥”å¤´: "bÃ¨n tou",
    è¿›ç»™: "jÃ¬n jÇ",
    çŽ‡æ€§: "shuÃ i xÃ¬ng",
    ä¹å­: "lÃ¨ zi",
    ç»‘æ‰Ž: "bÇŽng zÄ",
    æŒ‘å”†: "tiÇŽo suÅ",
    æ¼‚æ´—: "piÇŽo xÇ",
    å¤¹å¢™: "jiÄ qiÃ¡ng",
    å’³å–˜: "kÃ© chuÇŽn",
    ä¹œæ–œ: "miÄ“ xie",
    é”™å¤„: "cuÃ² chÃ¹",
    é—·é…’: "mÃ¨n jiÇ”",
    æ—¶è°ƒ: "shÃ­ diÃ o",
    é‡å­™: "chÃ³ng sÅ«n",
    ç»å¹¢: "jÄ«ng chuÃ¡ng",
    åœ©åœº: "xÅ« chÇŽng",
    è°ƒé—¨: "diÃ o mÃ©n",
    èŠ±å¤´: "huÄ tÃ³u",
    åˆ’æ‹‰: "huÃ¡ la",
    å¥—è‰²: "tÃ o shÇŽi",
    ç²—çŽ‡: "cÅ« shuÃ i",
    ç›¸çŽ‡: "xiÄng shuÃ i",
    æ¬¾è¯†: "kuÇŽn zhÃ¬",
    åè¯·: "yÃ¹ qÇng",
    è«è”½: "yÄ«n bÃ¬",
    æ–‡è›¤: "wÃ©n gÃ©",
    å˜€å—’: "dÄ« dÄ",
    è°ƒå–: "diÃ o qÇ”",
    äº¤å·®: "jiÄo chÄi",
    è½å­: "luÃ² zÇ",
    ç›¸å†Œ: "xiÃ ng cÃ¨",
    çµ®å¨: "xÃ¹ dao",
    è½å‘: "luÃ² fÃ ",
    å¼‚ç›¸: "yÃ¬ xiÃ ng",
    æµ¸æ²¡: "jÃ¬n mÃ²",
    è§’æŠµ: "juÃ© dÇ",
    å¸è½½: "xiÃ¨ zÃ i",
    æ˜¥å·: "chÅ«n juÇŽn",
    æ‰ŽæŒ£: "zhÃ¡ zheng",
    ç•œå…»: "xÃ¹ yÇŽng",
    å¡å’¯: "bÇ luÃ²",
    åž›å­: "duÃ² zi",
    æ¶å°‘: "Ã¨ shÃ o",
    å‘é™…: "fÃ  jÃ¬",
    çº¢è‹•: "hÃ³ng shÃ¡o",
    ç³¨ç³Š: "jiÃ ng hu",
    å“­ä¸§: "kÅ« sÄng",
    ç¨æ¯: "shÃ o xÄ«",
    æ™•èˆ¹: "yÃ¹n chuÃ¡n",
    æ ¡æ ·: "jiÃ o yÃ ng",
    å¤–å·®: "wÃ i chÄ",
    è„šçˆª: "jiÇŽo zhÇŽo",
    é“ºå±•: "pÅ« zhÇŽn",
    èŠ«è½: "yÃ¡n sui",
    å¤¹ç´§: "jiÄ jÇn",
    å°¿æ³¡: "suÄ« pÃ o",
    ä¸§ä¹±: "sÄng luÃ n",
    å‡¶ç›¸: "xiÅng xiÃ ng",
    åŽå‘: "huÃ¡ fÃ ",
    æ‰“åœº: "dÇŽ chÃ¡ng",
    äº‘é‡: "yÃºn liÃ ng",
    æ­£åˆ‡: "zhÃ¨ng qiÄ“",
    åˆ’æ‹³: "huÃ¡ quÃ¡n",
    åˆ’è‰‡: "huÃ¡ tÇng",
    è¯„ä¼ : "pÃ­ng zhuÃ n",
    æ‹‰çº¤: "lÄ qiÃ n",
    å¥è¯»: "jÃ¹ dÃ²u",
    æ•£å‰‚: "sÇŽn jÃ¬",
    éª¨æ®–: "gÇ” shi",
    å¡žéŸ³: "sÃ¨ yÄ«n",
    é“ºå™: "pÅ« xÃ¹",
    é˜æ°: "yÄn zhÄ«",
    å†·é¢¤: "lÄ›ng zhÃ n",
    ç…žä½: "shÄ zhÃ¹",
    å°‘ç”·: "shÃ o nÃ¡n",
    ç®¡ä¹: "guÇŽn yuÃ¨",
    å·å••: "hÃ¡o tÃ¡o",
    çº³é™: "nÃ  xiÃ¡ng",
    æ‹¥å¡ž: "yÅng sÃ¨",
    ä¸‡ä¹˜: "wÃ n shÃ¨ng",
    æ†å„¿: "gÇŽn Ã©r",
    è‘›è—¤: "gÃ© tÃ©ng",
    ç°¿ç±: "bÃ¹ jÃ­",
    çš®å¤¹: "pÃ­ jiÄ",
    æ ¡å‡†: "jiÃ o zhÇ”n",
    å…å½“: "yÇ”n dÃ ng",
    å™¨é‡: "qÃ¬ liÃ ng",
    é€‰è°ƒ: "xuÇŽn diÃ o",
    æ‰®ç›¸: "bÃ n xiÃ ng",
    å¹²æ‰: "gÃ n cÃ¡i",
    åŸºå¹²: "jÄ« gÃ n",
    å‰²åˆ‡: "gÄ“ qiÄ“",
    å›½ä¹: "guÃ³ yuÃ¨",
    å¡å£³: "qiÇŽ kÃ©",
    è¾Ÿè°·: "bÃ¬ gÇ”",
    ç£¨æˆ¿: "mÃ² fÃ¡ng",
    å’¿å‘€: "yÄ« yÄ",
    èŠ¥æœ«: "jiÃ¨ mo",
    è–„æŠ€: "bÃ³ jÃ¬",
    äº§å‡: "chÇŽn jiÃ ",
    è¯—å…´: "shÄ« xÃ¬ng",
    é‡å‡º: "chÃ³ng chÅ«",
    è½¬æ¤…: "zhuÃ n yÇ",
    é…Œé‡: "zhuÃ³ liang",
    ç°¿å†Œ: "bÃ¹ cÃ¨",
    è—é’: "zÃ ng qÄ«ng",
    çš„å£«: "dÄ« shÃ¬",
    è°ƒäºº: "diÃ o rÃ©n",
    è§£å…ƒ: "jiÃ¨ yuÃ¡n",
    èŒŽå¹²: "jÄ«ng gÃ n",
    å·¨é‡: "jÃ¹ liÃ ng",
    æ¦”å¤´: "lÃ¡ng tou",
    çŽ‡çœŸ: "shuÃ i zhÄ“n",
    å–·é¦™: "pÃ¨n xiÄng",
    é”é’¥: "suÇ’ yuÃ¨",
    è™¾èŸ†: "hÃ¡ mÃ¡",
    ç›¸å›¾: "xiÃ ng tÃº",
    å…´ä¼š: "xÃ¬ng huÃ¬",
    ç¶å¤´: "zÃ o tÃ³u",
    é‡å©š: "chÃ³ng hÅ«n",
    é’»æ´ž: "zuÄn dÃ²ng",
    å¿–åº¦: "cÇ”n duÃ³",
    å…šå‚: "dÇŽng shÄ“n",
    è°ƒæ¸©: "diÃ o wÄ“n",
    æ†å¡”: "gÄn tÇŽ",
    è‘›å¸ƒ: "gÃ© bÃ¹",
    æ‹±åˆ¸: "gÇ’ng xuÃ n",
    å¤¹ç”Ÿ: "jiÄ shÄ“ng",
    éœ²é¦…: "lÃ²u xiÃ n",
    æ°åˆ‡: "qiÃ  qiÃ¨",
    æ•£è§: "sÇŽn jiÃ n",
    å“¨å¡: "shÃ o qiÇŽ",
    çƒ«å‘: "tÃ ng fÃ ",
    ä½“é‡: "tÇ liÃ ng",
    æŒºæ‹¬: "tÇng kuÃ²",
    ç³»å¸¦: "jÃ¬ dÃ i",
    ç›¸å£«: "xiÃ ng shÃ¬",
    ç¾Šåœˆ: "yÃ¡ng juÃ n",
    è½¬çŸ©: "zhuÃ n jÇ”",
    å§å°: "bÄ tÃ¡i",
    è‹æœ¯: "cÄng zhÃº",
    è²è–„: "fÄ›i bÃ³",
    è›¤èš§: "gÃ© jiÃ¨",
    è›¤èœŠ: "gÃ© lÃ­",
    ç“œè”“: "guÄ wÃ n",
    æ€ªç›¸: "guÃ i xiÃ ng",
    ä¸´å¸–: "lÃ­n tiÃ¨",
    å¥³çº¢: "nÇš gÅng",
    åˆ¨åºŠ: "bÃ o chuÃ¡ng",
    ç¿˜æ¥š: "qiÃ¡o chÇ”",
    æ•°ä¹: "shÇ” jiÇ”",
    è°ˆå…´: "tÃ¡n xÃ¬ng",
    é›„åŠ²: "xiÃ³ng jÃ¬ng",
    æ‰ŽæŸ“: "zÄ rÇŽn",
    é®è«: "zhÄ“ yÄ«n",
    å‘¨æ­£: "zhÅu zhÃ¨ng",
    èµšå¤´: "zhuÃ n tou",
    æ‰’æ‰‹: "pÃ¡ shÇ’u",
    æ€å’Œ: "chÄn huo",
    è¯šæœ´: "chÃ©ng pÇ”",
    è‚šé‡: "dÃ¹ liÃ ng",
    å¹²ç»“: "gÄn jiÃ©",
    å·¥å°º: "gÅng chÄ›",
    å®¶ç´¯: "jiÄ lÄ›i",
    æ›²æ°´: "qÅ« shuÇ",
    æ²™å‚: "shÄ shÄ“n",
    æŒ‘èŠ±: "tiÇŽo huÄ",
    é˜¿é—¨: "Ä mÃ©n",
    èƒŒç¯“: "bÄ“i lÇ’u",
    ç˜ªä¸‰: "biÄ“ sÄn",
    è£å¤„: "cÃ¡i chÇ”",
    åˆ›ç—›: "chuÄng tÃ²ng",
    ç¦ç›¸: "fÃº xiÃ ng",
    æ›´åŠ¨: "gÄ“ng dÃ²ng",
    è±ªå…´: "hÃ¡o xÃ¬ng",
    è¿˜é˜³: "huÃ¡n yÃ¡ng",
    è¿˜å˜´: "huÃ¡n zuÇ",
    å€Ÿè°ƒ: "jiÃ¨ diÃ o",
    å·äº‘: "juÇŽn yÃºn",
    æµå¼¹: "liÃº dÃ n",
    æƒ³å¤´: "xiÇŽng tou",
    å‰Šä»·: "xuÄ“ jiÃ ",
    æ ¡é˜…: "jiÃ o yuÃ¨",
    é›…é‡: "yÇŽ liÃ ng",
    åˆ«ä¼ : "biÃ© zhuÃ n",
    è–„é…’: "bÃ³ jiÇ”",
    æ˜¥å‡: "chÅ«n jiÃ ",
    å‘å¦»: "fÃ  qÄ«",
    å“—å“—: "huÄ huÄ",
    å®½ç»°: "kuÄn chuo",
    äº†æ‚Ÿ: "liÇŽo wÃ¹",
    åˆ‡èŠ±: "qiÄ“ huÄ",
    å®¡åº¦: "shÄ›n duÃ³",
    åº”è®¸: "yÄ«ng xÇ”",
    è½¬å°: "zhuÃ n tÃ¡i",
    ä»”çŒª: "zÇ zhÅ«",
    è£é‡: "cÃ¡i liÃ¡ng",
    è—æˆ: "zÃ ng xÃ¬",
    ä¹˜å…´: "chÃ©ng xÃ¬ng",
    ç»¸ç¼ª: "chÃ³u mÃ³u",
    æ‘§æŠ˜: "cuÄ« zhÃ©",
    è°ƒç»: "tiÃ¡o jÄ«ng",
    è°ƒèŒ: "diÃ o zhÃ­",
    ç¼ç¼€: "fÃ©ng zhuÃ¬",
    éª¨æœµ: "gÅ« duÇ’",
    æ ¸å„¿: "hÃº er",
    æ’é‡: "hÃ©ng liÃ ng",
    è¿˜ä»·: "huÃ¡n jiÃ ",
    æµ‘æœ´: "hÃºn pÇ”",
    è‹¦å·®: "kÇ” chÄi",
    é¢ç³Š: "miÃ n hÃ¹",
    ç…žè½¦: "shÄ chÄ“",
    çœè§†: "xÇng shÃ¬",
    ä»€é”¦: "shÃ­ jÇn",
    ä¿¡å·®: "xÃ¬n chÄi",
    ä½™åˆ‡: "yÃº qiÄ“",
    æ”’çœ‰: "cuÃ¡n mÃ©i",
    ç‚¸ç³•: "zhÃ¡ gÄo",
    é’»æ†: "zuÃ n gÇŽn",
    æ‰’ç°: "pÃ¡ huÄ«",
    æ‹Œå’Œ: "bÃ n huÃ²",
    é•¿è°ƒ: "chÃ¡ng diÃ o",
    å¤§æºœ: "dÃ  liÃ¹",
    æŠ–æ‚: "dÇ’u lÅu",
    é£žè½¬: "fÄ“i zhuÃ n",
    å¹²ä»—: "gÃ n zhÃ ng",
    å¥½èƒœ: "hÃ o shÃ¨ng",
    ç”»ç‰‡: "huÃ  piÃ n",
    æ…æ··: "jiÇŽo hÃºn",
    èžºæ†: "luÃ³ gÇŽn",
    æœ¨æ¨¡: "mÃ¹ mÃº",
    æ€’å·: "nÃ¹ hÃ¡o",
    é¢‘æ•°: "pÃ­n shÃ¹",
    æ— å®: "wÃº nÃ­ng",
    é—å°‘: "yÃ­ shÃ o",
    é‚®å·®: "yÃ³u chÄi",
    å å¦: "zhÄn guÃ ",
    å æ˜Ÿ: "zhÄn xÄ«ng",
    é‡å®¡: "chÃ³ng shÄ›n",
    è‡ªé‡: "zÃ¬ liÃ ng",
    è°ƒé˜²: "diÃ o fÃ¡ng",
    å‘å»Š: "fÃ  lÃ¡ng",
    åè°ƒ: "fÇŽn diÃ o",
    ç¼å­: "fÃ¨ng zi",
    æ›´å¤«: "gÄ“ng fÅ«",
    éª¨å­: "gÇ” zi",
    å…‰æ†: "guÄng gÇŽn",
    å¤¹æ£: "jiÄ gÃ¹n",
    å±…ä¸§: "jÅ« sÄng",
    å·¨è´¾: "jÃ¹ gÇ”",
    çœ‹æŠ¼: "kÄn yÄ",
    ç©ºè½¬: "kÅng zhuÃ n",
    é‡åŠ›: "liÃ ng lÃ¬",
    ç‚®çƒ™: "pÃ¡o luÃ²",
    èµ”è¿˜: "pÃ©i huÃ¡n",
    æ‰‘æ‰‡: "pÅ« shÄn",
    æ•£è®°: "sÇŽn jÃ¬",
    æ•£ä»¶: "sÇŽn jiÃ n",
    åˆ å‰Š: "shÄn xuÄ“",
    å°„å¹²: "shÃ¨ gÃ n",
    æ¡å‡ : "tiÃ¡o jÄ«",
    å·ç©º: "tÅu kÃ²ng",
    å‰Šå£: "xuÄ“ bÃ¬",
    æ ¡æ ¸: "jiÃ o hÃ©",
    é˜´å¹²: "yÄ«n gÄn",
    æ‹©èœ: "zhÃ¡i cÃ i",
    é‡ä¹: "chÃ³ng jiÇ”",
    ä¸»è°ƒ: "zhÇ” diÃ o",
    è‡ªç¦: "zÃ¬ jÄ«n",
    å§å”§: "bÄ jÄ«",
    ä¾¿æºº: "biÃ n niÃ o",
    è¯è°ƒ: "cÃ­ diÃ o",
    å¨å’•: "dÃ¡o gu",
    è½æž•: "lÃ o zhÄ›n",
    é“ºç Œ: "pÅ« qÃ¬",
    åˆ·ç™½: "shuÃ  bÃ¡i",
    å§”é¡: "wÄ›i mÇ",
    ç³»æ³Š: "xÃ¬ bÃ³",
    ç›¸é©¬: "xiÃ ng mÇŽ",
    ç†¨å¸–: "yÃ¹ tiÄ“",
    è½¬ç­‹: "zhuÃ n jÄ«n",
    æ£’å–: "bÃ ng hÃ¨",
    å‚§ç›¸: "bÄ«n xiÃ ng",
    é•å¤´: "gÇŽo tÃ³u",
    é—´è‹—: "jiÃ n miÃ¡o",
    ä¹æ± : "yuÃ¨ chÃ­",
    å–ç›¸: "mÃ i xiÃ ng",
    å±å¼ƒ: "bÇng qÃ¬",
    é“…å¼¹: "qiÄn dÃ n",
    åˆ‡å˜: "qiÄ“ biÃ n",
    è¯·è°ƒ: "qÇng diÃ o",
    ç¾¤æ°“: "qÃºn mÃ©ng",
    æ•£æ¿: "sÇŽn bÇŽn",
    çœå¯Ÿ: "xÇng chÃ¡",
    äº‹å‡: "shÃ¬ jiÃ ",
    çº¤ç»³: "qiÃ n shÃ©ng",
    é‡å½±: "chÃ³ng yÇng",
    è€•ç§: "gÄ“ng zhÃ²ng",
    ç§åœ°: "zhÃ²ng dÃ¬",
    ç§èœ: "zhÃ²ng cÃ i",
    æ ½ç§: "zÄi zhÃ²ng",
    æŽ¥ç§: "jiÄ“ zhÃ²ng",
    åž¦ç§: "kÄ›n zhÃ²ng",
    ç§æ®–: "zhÃ²ng zhÃ­",
    ç§ç“œ: "zhÃ²ng guÄ",
    ç§è±†: "zhÃ²ng dÃ²u",
    ç§æ ‘: "zhÃ²ng shÃ¹",
    ç¡ç€: "shuÃ¬ zhÃ¡o",
    ç¬¼å­: "lÃ³ng zi",
    é‡å¯: "chÃ³ng qÇ",
    é‡æ•´: "chÃ³ng zhÄ›ng",
    é‡å¼¹: "chÃ³ng tÃ¡n",
    é‡è¶³: "chÃ³ng zÃº",
    é‡å±±: "chÃ³ng shÄn",
    é‡æ¸¸: "chÃ³ng yÃ³u",
    é‡å³¦: "chÃ³ng luÃ¡n",
    çˆ·çˆ·: "yÃ© ye",
    å¥¶å¥¶: "nÇŽi nai",
    å§¥çˆ·: "lÇŽo ye",
    çˆ¸çˆ¸: "bÃ  ba",
    å¦ˆå¦ˆ: "mÄ ma",
    å©¶å©¶: "shÄ›n shen",
    èˆ…èˆ…: "jiÃ¹ jiu",
    å§‘å§‘: "gÅ« gu",
    å”å”: "shÅ« shu",
    å§¨å¤«: "yÃ­ fu",
    èˆ…æ¯: "jiÃ¹ mu",
    å§‘çˆ¶: "gÅ« fu",
    å§å¤«: "jiÄ› fu",
    å©†å©†: "pÃ³ po",
    å…¬å…¬: "gÅng gong",
    èˆ…å­: "jiÃ¹ zi",
    å§å§: "jiÄ› jie",
    å“¥å“¥: "gÄ“ ge",
    å¦¹å¦¹: "mÃ¨i mei",
    å¦¹å¤«: "mÃ¨i fu",
    å§¨å­: "yÃ­ zi",
    å®å®: "bÇŽo bao",
    å¨ƒå¨ƒ: "wÃ¡ wa",
    å­©å­: "hÃ¡i zi",
    æ—¥å­: "rÃ¬ zi",
    æ ·å­: "yÃ ng zi",
    ç‹®å­: "shÄ« zi",
    èº«å­: "shÄ“n zi",
    æž¶å­: "jiÃ  zi",
    å«‚å­: "sÇŽo zi",
    é¼»å­: "bÃ­ zi",
    äº­å­: "tÃ­ng zi",
    æŠ˜å­: "zhÃ© zi",
    é¢å­: "miÃ n zi",
    è„–å­: "bÃ³ zi",
    è¾ˆå­: "bÃ¨i zi",
    å¸½å­: "mÃ o zi",
    æ‹å­: "pÄi zi",
    æŸ±å­: "zhÃ¹ zi",
    è¾«å­: "biÃ n zi",
    é¸½å­: "gÄ“ zi",
    æˆ¿å­: "fÃ¡ng zi",
    ä¸¸å­: "wÃ¡n zi",
    æ‘Šå­: "tÄn zi",
    ç‰Œå­: "pÃ¡i zi",
    èƒ¡å­: "hÃº zi",
    é¬¼å­: "guÇ zi",
    çŸ®å­: "ÇŽi zi",
    é¸­å­: "yÄ zi",
    å°å­: "xiÇŽo zi",
    å½±å­: "yÇng zi",
    å±‹å­: "wÅ« zi",
    å¯¹å­: "duÃ¬ zi",
    ç‚¹å­: "diÇŽn zi",
    æœ¬å­: "bÄ›n zi",
    ç§å­: "zhÇ’ng zi",
    å„¿å­: "Ã©r zi",
    å…”å­: "tÃ¹ zi",
    éª—å­: "piÃ n zi",
    é™¢å­: "yuÃ n zi",
    çŒ´å­: "hÃ³u zi",
    å—“å­: "sÇŽng zi",
    ä¾„å­: "zhÃ­ zi",
    æŸ¿å­: "shÃ¬ zi",
    é’³å­: "qiÃ¡n zi",
    è™±å­: "shÄ« zi",
    ç“¶å­: "pÃ­ng zi",
    è±¹å­: "bÃ o zi",
    ç­·å­: "kuÃ i zi",
    ç¯®å­: "lÃ¡n zi",
    ç»³å­: "shÃ©ng zi",
    å˜´å·´: "zuÇ ba",
    è€³æœµ: "Ä›r duo",
    èŒ„å­: "qiÃ© zi",
    èšŒåŸ : "bÃ¨ng bÃ¹",
    å´†å³’: "kÅng tÃ³ng",
    çµç¶: "pÃ­ pa",
    è˜‘è‡: "mÃ³ gu",
    è‘«èŠ¦: "hÃº lu",
    ç‹ç‹¸: "hÃº li",
    æ¡”å­: "jÃº zi",
    ç›’å­: "hÃ© zi",
    æ¡Œå­: "zhuÅ zi",
    ç«¹å­: "zhÃº zi",
    å¸ˆå‚…: "shÄ« fu",
    è¡£æœ: "yÄ« fu",
    è¢œå­: "wÃ  zi",
    æ¯å­: "bÄ“i zi",
    åˆºçŒ¬: "cÃ¬ wei",
    éº¦å­: "mÃ i zi",
    é˜Ÿä¼: "duÃ¬ wu",
    çŸ¥äº†: "zhÄ« liÇŽo",
    é±¼å„¿: "yÃº er",
    é¦„é¥¨: "hÃºn tun",
    ç¯ç¬¼: "dÄ“ng long",
    åº„ç¨¼: "zhuÄng jia",
    èªæ˜Ž: "cÅng ming",
    é•œå­: "jÃ¬ng zi",
    é“¶å­: "yÃ­n zi",
    ç›˜å­: "pÃ¡n zi",
    äº†å´: "liÇŽo quÃ¨",
    åŠ›æ°”: "lÃ¬ qi",
    å¸­å­: "xÃ­ zi",
    æž—å­: "lÃ­n zi",
    æœéœž: "zhÄo xiÃ¡",
    æœå¤•: "zhÄo xÄ«",
    æœæ°”: "zhÄo qÃ¬",
    ç¿…è†€: "chÃ¬ bÇŽng",
    çœé•¿: "shÄ›ng zhÇŽng",
    è‡§å¦: "zÄng pÇ",
    å¦æ³°: "pÇ tÃ i",
    å˜å¾—: "biÃ n de",
    ä¸ˆå¤«: "zhÃ ng fu",
    è±†è…: "dÃ²u fu",
    ç¬”æ†: "bÇ gÇŽn",
    æžžé˜³: "zÅng yÃ¡ng",
    è¡Œäºº: "xÃ­ng rÃ©n",
    æ‰“ç€: "dÇŽ zhe",
    // ä¸€å­—ä¸å˜è°ƒçš„è¯è¯­ï¼ˆéœ€è¦å¢žè¡¥æ›´å¤šï¼‰
    // æœ‰æ­§ä¹‰çš„è¯ï¼šä¸€æ¥¼ã€ä¸€æ ‹ã€ä¸€å±‚ã€ä¸€æŽ’ã€ä¸€è¿ž
    // â€œä¸€æ¥¼â€è¿™ä¸ªè¯ï¼Œä¸Šä¸‹æ–‡è¯­æ„æ˜¯â€œä¸€æ•´æ ‹æ¥¼â€æ—¶ï¼Œéœ€è¦å˜è°ƒæˆå››å£°ï¼›æˆ‘ä½ä¸€æ¥¼æ—¶ï¼Œåˆ™æ˜¯ä¸€å£°
    ç¬¬ä¸€: "dÃ¬ yÄ«",
    ä¸‡ä¸€: "wÃ n yÄ«",
    ä¹‹ä¸€: "zhÄ« yÄ«",
    å¾—ä¹‹: "dÃ© zhÄ«",
    ç»Ÿä¸€: "tÇ’ng yÄ«",
    å”¯ä¸€: "wÃ©i yÄ«",
    ä¸“ä¸€: "zhuÄn yÄ«",
    å•ä¸€: "dÄn yÄ«",
    å¦‚ä¸€: "rÃº yÄ«",
    å…¶ä¸€: "qÃ­ yÄ«",
    åˆä¸€: "hÃ© yÄ«",
    é€ä¸€: "zhÃº yÄ«",
    å‘¨ä¸€: "zhÅu yÄ«",
    åˆä¸€: "chÅ« yÄ«",
    ç ”ä¸€: "yÃ¡n yÄ«",
    å½’ä¸€: "guÄ« yÄ«",
    å‡ä¸€: "jiÇŽ yÄ«",
    é—»ä¸€: "wÃ©n yÄ«",
    äº†äº†: "liÇŽo liÇŽo",
    å…¬äº†: "gÅng liÇŽo",
    ç§äº†: "sÄ« liÇŽo",
    // ä¸€ å‘éŸ³
    ä¸€æœˆ: "yÄ« yuÃ¨",
    ä¸€å·: "yÄ« hÃ o",
    ä¸€çº§: "yÄ« jÃ­",
    ä¸€ç­‰: "yÄ« dÄ›ng",
    ä¸€å“¥: "yÄ« gÄ“",
    æœˆä¸€: "yuÃ¨ yÄ«",
    ä¸€ä¸€: "yÄ« yÄ«",
    äºŒä¸€: "Ã¨r yÄ«",
    ä¸‰ä¸€: "sÄn yÄ«",
    å››ä¸€: "sÃ¬ yÄ«",
    äº”ä¸€: "wÇ” yÄ«",
    å…­ä¸€: "liÃ¹ yÄ«",
    ä¸ƒä¸€: "qÄ« yÄ«",
    å…«ä¸€: "bÄ yÄ«",
    ä¹ä¸€: "jiÇ” yÄ«",
    "ä¸€ã€‡": "yÄ« lÃ­ng",
    ä¸€é›¶: "yÄ« lÃ­ng",
    ä¸€äºŒ: "yÄ« Ã¨r",
    ä¸€ä¸‰: "yÄ« sÄn",
    ä¸€å››: "yÄ« sÃ¬",
    ä¸€äº”: "yÄ« wÇ”",
    ä¸€å…­: "yÄ« liÃ¹",
    ä¸€ä¸ƒ: "yÄ« qÄ«",
    ä¸€å…«: "yÄ« bÄ",
    ä¸€ä¹: "yÄ« jiÇ”",
    ä¸€åˆ: "yÄ« yÃ²u",
    ä¸€é¥¼: "yÄ« bÇng",
    ä¸€æ¥¼: "yÄ« lÃ³u",
    ä¸ºä¾‹: "wÃ©i lÃ¬",
    ä¸ºå‡†: "wÃ©i zhÇ”n",
    æ²§æµ·: "cÄng hÇŽi",
    éš¾ä¸º: "nÃ¡n wÃ©i",
    è´£éš¾: "zÃ© nÃ n",
    æ‚£éš¾: "huÃ n nÃ n",
    ç£¨éš¾: "mÃ³ nÃ n",
    å¤§éš¾: "dÃ  nÃ n",
    åˆéš¾: "diÄo nÃ n",
    æ®‰éš¾: "xÃ¹n nÃ n",
    è½éš¾: "luÃ² nÃ n",
    ç½¹éš¾: "lÃ­ nÃ n",
    ç¾éš¾: "zÄi nÃ n",
    éš¾æ°‘: "nÃ n mÃ­n",
    è‹¦éš¾: "kÇ” nÃ n",
    å±éš¾: "wÄ“i nÃ n",
    å‘éš¾: "fÄ nÃ n",
    é€ƒéš¾: "tÃ¡o nÃ n",
    é¿éš¾: "bÃ¬ nÃ n",
    é‡éš¾: "yÃ¹ nÃ n",
    é˜»éš¾: "zÇ” nÃ n",
    åŽ„éš¾: "Ã¨ nÃ n",
    å¾‡éš¾: "xÃ¹n nÃ n",
    ç©ºéš¾: "kÅng nÃ n",
    å–œæ¬¢: "xÇ huan",
    æœæœ: "zhÄo zhÄo",
    ä¸è¡Œ: "bÃ¹ xÃ­ng",
    è½§è½§: "yÃ  yÃ ",
    å¼¯æ›²: "wÄn qÅ«",
    æ‰­æ›²: "niÇ” qÅ«",
    æ›²ç›´: "qÅ« zhÃ­",
    å§”æ›²: "wÄ›i qÅ«",
    é…’æ›²: "jiÇ” qÅ«",
    æ›²å¾„: "qÅ« jÃ¬ng",
    æ›²è§£: "qÅ« jiÄ›",
    æ­ªæ›²: "wÄi qÅ«",
    æ›²çº¿: "qÅ« xiÃ n",
    æ›²é˜œ: "qÅ« fÃ¹",
    ä¹æ›²: "jiÇ” qÅ«",
    æ›²æŠ˜: "qÅ« zhÃ©",
    æ›²è‚±: "qÅ« gÅng",
    æ›²æ„: "qÅ« yÃ¬",
    ä»¡ä½¬: "gÄ“ lÇŽo"
  };
  const Pattern2 = Object.keys(DICT2).map((key) => ({
    zh: key,
    pinyin: DICT2[key],
    probability: 2e-8,
    length: 2,
    priority: Priority.Normal,
    dict: Symbol("dict2")
  }));
  const DICT3 = {
    ä¸ºä»€ä¹ˆ: "wÃ¨i shÃ©n me",
    å®žé™…ä¸Š: "shÃ­ jÃ¬ shang",
    æ£€å¯Ÿé•¿: "jiÇŽn chÃ¡ zhÇŽng",
    å¹²ä»€ä¹ˆ: "gÃ n shÃ©n me",
    è¿™ä¼šå„¿: "zhÃ¨ huÃ¬ er",
    å°½å¯èƒ½: "jÇn kÄ› nÃ©ng",
    è‘£äº‹é•¿: "dÇ’ng shÃ¬ zhÇŽng",
    äº†ä¸èµ·: "liÇŽo bÃ¹ qÇ",
    å‚è°‹é•¿: "cÄn mÃ³u zhÇŽng",
    æœé²œæ—: "chÃ¡o xiÇŽn zÃº",
    æµ·å†…å¤–: "hÇŽi nÃ¨i wÃ i",
    ç¦ä¸ä½: "jÄ«n bÃº zhÃ¹",
    æŸæ‹‰å›¾: "bÃ³ lÄ tÃº",
    ä¸åœ¨ä¹Ž: "bÃº zÃ i hu",
    æ´›æ‰çŸ¶: "luÃ² shÄn jÄ«",
    æœ‰ç‚¹å„¿: "yÇ’u diÇŽn er",
    è¿«å‡»ç‚®: "pÇŽi jÄ« pÃ o",
    ä¸å¾—äº†: "bÃ¹ dÃ© liÇŽo",
    é©¬å°¾æ¾: "mÇŽ wÄ›i sÅng",
    è¿è¾“é‡: "yÃ¹n shÅ« liÃ ng",
    å‘è„¾æ°”: "fÄ pÃ­ qi",
    å£«å¤§å¤«: "shÃ¬ dÃ  fÅ«",
    é¸­ç»¿æ±Ÿ: "yÄ lÃ¹ jiÄng",
    åŽ‹æ ¹å„¿: "yÃ  gÄ“n er",
    å¯¹å¾—èµ·: "duÃ¬ de qÇ",
    é‚£ä¼šå„¿: "nÃ  huÃ¬ er",
    è‡ªä¸ªå„¿: "zÃ¬ gÄ› er",
    ç‰©ç†é‡: "wÃ¹ lÇ liÃ ng",
    æ€Žä¹ˆç€: "zÄ›n me zhÄo",
    æ˜Žæ™ƒæ™ƒ: "mÃ­ng huÇŽng huÇŽng",
    èŠ‚å‡æ—¥: "jiÃ© jiÃ  rÃ¬",
    å¿ƒé‡Œè¯: "xÄ«n lÇ huÃ ",
    å‘è¡Œé‡: "fÄ xÃ­ng liÃ ng",
    å…´å†²å†²: "xÃ¬ng chÅng chÅng",
    åˆ†å­é‡: "fÄ“n zÇ liÃ ng",
    å›½å­ç›‘: "guÃ³ zÇ jiÃ n",
    è€å¤§éš¾: "lÇŽo dÃ  nÃ¡n",
    å…šå†…å¤–: "dÇŽng nÃ¨i wÃ i",
    è¿™ä¹ˆç€: "zhÃ¨ me zhÄo",
    å°‘å¥¶å¥¶: "shÃ o nÇŽi nai",
    æš—åœ°é‡Œ: "Ã n dÃ¬ lÇ",
    æ›´å¹´æœŸ: "gÄ“ng niÃ¡n qÄ«",
    å·¥ä½œé‡: "gÅng zuÃ² liÃ ng",
    èƒŒåœ°é‡Œ: "bÃ¨i dÃ¬ lÇ",
    å±±é‡Œçº¢: "shÄn li hÃ³ng",
    å¥½å¥½å„¿: "hÇŽo hÄo er",
    äº¤å“ä¹: "jiÄo xiÇŽng yuÃ¨",
    å¥½æ„æ€: "hÇŽo yÃ¬ si",
    åè°·æµ‘: "tÇ” yÃ¹ hÃºn",
    æ²¡æ„æ€: "mÃ©i yÃ¬ si",
    ç†å‘å¸ˆ: "lÇ fÃ  shÄ«",
    å¡”ä»€å¹²: "tÇŽ shÃ­ gÄn",
    å……å…¶é‡: "chÅng qÃ­ liÃ ng",
    é å¾—ä½: "kÃ o de zhÃ¹",
    è½¦è¡Œé“: "chÄ“ xÃ­ng dÃ o",
    äººè¡Œé“: "rÃ©n xÃ­ng dÃ o",
    ä¸­éƒŽå°†: "zhÅng lÃ¡ng jiÃ ng",
    ç…§æ˜Žå¼¹: "zhÃ o mÃ­ng dÃ n",
    çƒŸå¹•å¼¹: "yÄn mÃ¹ dÃ n",
    æ²¡å¥ˆä½•: "mÃ² nÃ i hÃ©",
    ä¹±å“„å“„: "luÃ n hÅng hÅng",
    æƒ æ›´æ–¯: "huÃ¬ gÄ“ng sÄ«",
    è½½é‡é‡: "zÃ i zhÃ²ng liÃ ng",
    çž§å¾—èµ·: "qiÃ¡o de qÇ",
    çºªä¼ ä½“: "jÃ¬ zhuÃ n tÇ",
    é˜¿æˆ¿å®«: "Ä“ pÃ¡ng gÅng",
    å·å¿ƒèœ: "juÇŽn xÄ«n cÃ i",
    æˆç­å­: "xÃ¬ bÄn zi",
    è¿‡å¾—åŽ»: "guÃ² de qÃ¹",
    èŠ±å²—çŸ³: "huÄ gÄng shÃ­",
    å¤–ç”¥å¥³: "wÃ i sheng nÇš",
    å›¢å›¢è½¬: "tuÃ¡n tuÃ¡n zhuÃ n",
    å¤§å ¡ç¤: "dÃ  bÇŽo jiÄo",
    ç‡ƒçƒ§å¼¹: "rÃ¡n shÄo dÃ n",
    åŠ³ä»€å­: "lÃ¡o shÃ­ zi",
    æ‘‡æ»šä¹: "yÃ¡o gÇ”n yuÃ¨",
    å¤¹ç«¹æ¡ƒ: "jiÄ zhÃº tÃ¡o",
    é—¹å“„å“„: "nÃ o hÅng hÅng",
    ä¸‰è¿žå† : "sÄn liÃ¡n guÃ n",
    é‡å¤´æˆ: "zhÃ²ng tÃ³u xÃ¬",
    äºŒäººè½¬: "Ã¨r rÃ©n zhuÃ n",
    èŠ‚éª¨çœ¼: "jiÄ“ gÇ” yÇŽn",
    çŸ¥è¯†é¢: "zhÄ« shi miÃ n",
    æŠ¤å£«é•¿: "hÃ¹ shi zhÇŽng",
    ä¿¡å·å¼¹: "xÃ¬n hÃ o dÃ n",
    å¹²ç”µæ± : "gÄn diÃ n chÃ­",
    æžªæ†å­: "qiÄng gÇŽn zi",
    å“­ä¸§æ£’: "kÅ« sÄng bÃ ng",
    é¼»å’½ç™Œ: "bÃ­ yÄn Ã¡i",
    ç“¦å²—å†›: "wÇŽ gÄng jÅ«n",
    ä¹°å¾—èµ·: "mÇŽi de qÇ",
    ç™žè›¤èŸ†: "lÃ i hÃ¡ ma",
    è„Šæ¢éª¨: "jÇ liang gÇ”",
    å­æ¯å¼¹: "zÇ mÇ” dÃ n",
    å¼€å°å·®: "kÄi xiÇŽo chÄi",
    å¥³å¼ºäºº: "nÇš qiÃ¡ng rÃ©n",
    è‹±é›„ä¼ : "yÄ«ng xiÃ³ng zhuÃ n",
    çˆµå£«ä¹: "juÃ© shÃ¬ yuÃ¨",
    è¯´ç¬‘è¯: "shuÅ xiÃ o hua",
    ç¢°å¤´ä¼š: "pÃ¨ng tÃ³u huÃ¬",
    çŽ»ç’ƒé’¢: "bÅ li gÄng",
    æ›³å…‰å¼¹: "yÃ¨ guÄng dÃ n",
    å°‘æž—æ‹³: "shÃ o lÃ­n quÃ¡n",
    å’å¹è°ƒ: "yÇ’ng tÃ n diÃ o",
    å°‘å…ˆé˜Ÿ: "shÃ o xiÄn duÃ¬",
    çµé•¿ç›®: "lÃ­ng zhÇŽng mÃ¹",
    å¯¹ç€å¹²: "duÃ¬ zhe gÃ n",
    è’™è’™äº®: "mÃ©ng mÃ©ng liÃ ng",
    è½¯éª¨å¤´: "ruÇŽn gÇ” tou",
    é“ºç›–å·: "pÅ« gÃ i juÇŽn",
    å’Œç¨€æ³¥: "huÃ² xÄ« nÃ­",
    èƒŒé»‘é”…: "bÄ“i hÄ“i guÅ",
    çº¢å½¤å½¤: "hÃ³ng tÅng tÅng",
    æ­¦ä¾¯ç¥ : "wÇ” hÃ³u cÃ­",
    æ‰“å“†å—¦: "dÇŽ duÅ suo",
    æˆ·å£ç°¿: "hÃ¹ kÇ’u bÃ¹",
    é©¬å°¾è—»: "mÇŽ wÄ›i zÇŽo",
    å¤œçŒ«å­: "yÃ¨ mÄo zi",
    æ‰“æ‰‹åŠ¿: "dÇŽ shÇ’u shÃ¬",
    é¾™çŽ‹çˆ·: "lÃ³ng wÃ¡ng yÃ©",
    æ°”å¤´ä¸Š: "qÃ¬ tÃ³u shang",
    ç³Šæ¶‚è™«: "hÃº tu chÃ³ng",
    ç¬”æ†å­: "bÇ gÇŽn zi",
    å ä¾¿å®œ: "zhÃ n piÃ¡n yi",
    æ‰“ä¸»æ„: "dÇŽ zhÇ” yÃ¬",
    å¤šå¼¹å¤´: "duÅ dÃ n tÃ³u",
    éœ²ä¸€æ‰‹: "lÃ²u yÃ¬ shÇ’u",
    å °å¡žæ¹–: "yÃ n sÃ¨ hÃº",
    ä¿å¾—ä½: "bÇŽo de zhÃ¹",
    è¶µçªæ³‰: "bÃ o tÅ« quÃ¡n",
    å¥¥å¾—æ²³: "Ã o de hÃ©",
    å¸åŠ¡é•¿: "sÄ« wÃ¹ zhÇŽng",
    ç¦ä¸èµ·: "jÄ«n bÃ¹ qÇ",
    ä»€åˆ¹æµ·: "shÃ­ chÃ  hÇŽi",
    èŽ²èŠ±è½: "liÃ¡n huÄ lÃ o",
    è§ä¸–é¢: "jiÃ n shÃ¬ miÃ n",
    è±å‡ºåŽ»: "huÅ chÅ« qÃ¹",
    ç”µä½å·®: "diÃ n wÃ¨i chÄ",
    æŒ¨ä¸ªå„¿: "Äi gÃ¨ er",
    é‚£é˜µå„¿: "nÃ  zhÃ¨n er",
    è‚ºæ´»é‡: "fÃ¨i huÃ³ liÃ ng",
    å¤§å¸ˆå‚…: "dÃ  shÄ« fu",
    æŽ·å¼¹ç­’: "zhÃ¬ dÃ n tÇ’ng",
    æ‰“å‘¼å™œ: "dÇŽ hÅ« lu",
    å¹¿æ¸ é—¨: "Än qÃº mÃ©n",
    æœªè§å¾—: "wÃ¨i jiÃ n dÃ©",
    å¤§å©¶å„¿: "dÃ  shÄ›n er",
    è°ˆå¾—æ¥: "tÃ¡n de lÃ¡i",
    è„šä¸«å­: "jiÇŽo yÄ zi",
    ç©ºåŒ…å¼¹: "kÅng bÄo dÃ n",
    çªé‡Œæ–—: "wÅ li dÃ²u",
    å¼¹ç€ç‚¹: "dÃ n zhuÃ³ diÇŽn",
    ä¸ªå¤´å„¿: "gÃ¨ tÃ³u er",
    çœ‹å¾—èµ·: "kÃ n de qÇ",
    ç³Šæ¶‚è´¦: "hÃº tu zhÃ ng",
    å¤§çŒ©çŒ©: "dÃ  xÄ«ng xing",
    ç¦å¾—èµ·: "jÄ«n de qÇ",
    æ³•ç›¸å®—: "fÇŽ xiÃ ng zÅng",
    å¯æ€œç›¸: "kÄ› liÃ¡n xiÃ ng",
    åƒå¾—ä¸‹: "chÄ« de xiÃ ",
    æ±‰å ¡åŒ…: "hÃ n bÇŽo bÄo",
    é—¹åš·åš·: "nÃ o rÄng rÄng",
    æ•°æ¥å®: "shÇ” lÃ¡i bÇŽo",
    åˆå¾—æ¥: "hÃ© de lÃ¡i",
    å¹²æ€§æ²¹: "gÄn xÃ¬ng yÃ³u",
    é—·è‘«èŠ¦: "mÃ¨n hÃº lu",
    å‘±å‘±å«: "guÄ guÄ jiÃ o",
    è¥¿æ´‹å‚: "xÄ« yÃ¡ng shÄ“n",
    æž—è«é“: "lÃ­n yÄ«n dÃ o",
    æ‹‰å®¶å¸¸: "lÄ jiÄ chÃ¡ng",
    å·é“ºç›–: "juÇŽn pÅ« gÃ i",
    è¿‡å¾—ç¡¬: "guÃ² de yÃ¬ng",
    é£žå°†å†›: "fÄ“i jiÄng jÅ«n",
    æŒ‘å¤§æ¢: "tiÇŽo dÃ  liÃ¡ng",
    å“ˆå·´ç‹—: "hÇŽ ba gÇ’u",
    è¿‡å®¶å®¶: "guÃ² jiÄ jiÄ",
    å‚¬æ³ªå¼¹: "cuÄ« lÃ¨i dÃ n",
    é›¨å¤¹é›ª: "yÇ” jiÄ xuÄ›",
    æ•²ç«¹æ : "qiÄo zhÃº gÃ ng",
    åˆ—è½¦é•¿: "liÃ¨ chÄ“ zhÇŽng",
    åŽè¾¾å‘¢: "huÃ¡ dÃ¡ nÃ­",
    çŠ¯å¾—ç€: "fÃ n de zhÃ¡o",
    åœŸç–™ç˜©: "tÇ” gÄ“ da",
    ç…žé£Žæ™¯: "shÄ fÄ“ng jÇng",
    è½»é‡çº§: "qÄ«ng liÃ ng jÃ­",
    ç¾žç­”ç­”: "xiÅ« dÄ dÄ",
    çŸ³å­å„¿: "shÃ­ zÇ er",
    è¾¾å§†å¼¹: "dÃ¡ mÇ” dÃ n",
    ç§‘æ•™ç‰‡: "kÄ“ jiÃ o piÄn",
    ä¾ƒå¤§å±±: "kÇŽn dÃ  shÄn",
    ä¸ç‚¹å„¿: "dÄ«ng diÇŽn er",
    åƒå¾—æ¶ˆ: "chÄ« de xiÄo",
    æ‹è™Žé¡»: "luÅ hÇ” xÅ«",
    é«˜ä¸½å‚: "gÄo lÃ­ shÄ“n",
    ä¼—ç”Ÿç›¸: "zhÃ²ng shÄ“ng xiÃ ng",
    å’½å³¡ç‚Ž: "yÄn xiÃ¡ yÃ¡n",
    ç¦å¾—ä½: "jÄ«n de zhÃ¹",
    åƒå¾—å¼€: "chÄ« de kÄi",
    æŸžä¸ç»¸: "zuÃ² sÄ« chÃ³u",
    åº”å£°è™«: "yÃ¬ng shÄ“ng chÃ³ng",
    æ•°å¾—ç€: "shÇ” de zhÃ¡o",
    å‚»åŠ²å„¿: "shÇŽ jÃ¬n er",
    é“…çŽ»ç’ƒ: "qiÄn bÅ li",
    å¯çš„æ¾: "kÄ› dÃ¬ sÅng",
    åˆ’å¾—æ¥: "huÃ¡ de lÃ¡i",
    æ™•ä¹Žä¹Ž: "yÅ«n hÅ« hÅ«",
    å±Žå£³éƒŽ: "shÇ ke lÃ ng",
    å°¥è¹¶å­: "liÃ o juÄ› zi",
    è—çº¢èŠ±: "zÃ ng hÃ³ng huÄ",
    é—·ç½è½¦: "mÃ¨n guÃ n chÄ“",
    å¡è„–å­: "qiÇŽ bÃ³ zi",
    çº¢æ¾„æ¾„: "hÃ³ng deng deng",
    èµ¶å¾—åŠ: "gÇŽn de jÃ­",
    å½“é—´å„¿: "dÄng jiÃ n er",
    éœ²é©¬è„š: "lÃ²u mÇŽ jiÇŽo",
    é¸¡å†…é‡‘: "jÄ« nÃ¨i jÄ«n",
    çŠ¯å¾—ä¸Š: "fÃ n de shÃ ng",
    é’‰é½¿è€™: "dÄ«ng chÇ bÃ ",
    é¥±å’Œç‚¹: "bÇŽo hÃ© diÇŽn",
    é¾™çˆªæ§: "lÃ³ng zhÇŽo huÃ¡i",
    å–å€’å½©: "hÃ¨ dÃ o cÇŽi",
    å®šå† è¯: "dÃ¬ng guÃ n cÃ­",
    æ‹…æ‹…é¢: "dÃ n dan miÃ n",
    åƒå¾—ä½: "chÄ« de zhÃ¹",
    çˆªå°–å„¿: "zhuÇŽ jiÄn er",
    æ”¯ç€å„¿: "zhÄ« zhÄo er",
    æŠ˜è·Ÿå¤´: "zhÄ“ gÄ“n tou",
    é˜´ç€å„¿: "yÄ«n zhÄo er",
    çƒŸå·å„¿: "yÄn juÇŽn er",
    å®£ä¼ å¼¹: "xuÄn chuÃ¡n dÃ n",
    ä¿¡çš®å„¿: "xÃ¬n pÃ­ er",
    å¼¦åˆ‡è§’: "xiÃ¡n qiÄ“ jiÇŽo",
    ç¼©ç ‚å¯†: "sÃ¹ shÄ mÃ¬",
    è¯´å¾—æ¥: "shuÅ de lÃ¡i",
    æ°´æ¼‚å„¿: "shuÇ piÄo er",
    è€ç¬”æ†: "shuÇŽ bÇ gÇŽn",
    æ•°å¾—ä¸Š: "shÇ” de shÃ ng",
    æ•°ä¸ç€: "shÇ” bÃ¹ zhÃ¡o",
    æ•°ä¸æ¸…: "shÇ” bÃ¹ qÄ«ng",
    ä»€ä»¶å„¿: "shÃ­ jiÃ n er",
    ç”Ÿæ­»ç°¿: "shÄ“ng sÇ bÃ¹",
    æ‰‡é£Žæœº: "shÄn fÄ“ng jÄ«",
    æ’’å‘“æŒ£: "sÄ yÃ¬ zheng",
    æ—¥è®°ç°¿: "rÃ¬ jÃ¬ bÃ¹",
    çƒ­å¾—å¿«: "rÃ¨ de kuÃ i",
    äº²å®¶å…¬: "qÃ¬ng jia gÅng",
    å¥‡å‡½æ•°: "jÄ« hÃ¡n shÃ¹",
    æ‹çº¸ç°¿: "pÄi zhÇ bÃ¹",
    åŠªåŠ²å„¿: "nÇ” jÃ¬n er",
    æ³¥å¨ƒå¨ƒ: "nÃ­ wÃ¡ wa",
    å†…åˆ‡åœ†: "nÃ¨i qiÄ“ yuÃ¡n",
    å“ªä¼šå„¿: "nÇŽ huÃ¬ er",
    é—·å¤´å„¿: "mÄ“n tÃ³u er",
    æ²¡è°±å„¿: "mÃ©i pÇ” er",
    é“†åŠ²å„¿: "mÇŽo jÃ¬n er",
    æºœè‚©è†€: "liÅ« jiÄn bÇŽng",
    äº†æœ›å°: "liÃ o wÃ ng tÃ¡i",
    è€æ¥å°‘: "lÇŽo lÃ¡i shÃ o",
    å¤è§’å„¿: "kÅ«n juÃ© er",
    è€ƒå‹¤ç°¿: "kÇŽo qÃ­n bÃ¹",
    å·ç¬”åˆ€: "juÇŽn bÇ dÄo",
    è¿›ç»™é‡: "jÃ¬n jÇ liÃ ng",
    åˆ’ä¸æ¥: "huÃ¡ bÃ¹ lÃ¡i",
    æ±—è¤‚å„¿: "hÃ n guÃ  er",
    é¼“å›Šå›Š: "gÇ” nÄng nÄng",
    å¤ŸåŠ²å„¿: "gÃ²u jÃ¬n er",
    å…¬åˆ‡çº¿: "gÅng qiÄ“ xiÃ n",
    æå¾—ä½: "gÃ© de zhÃ¹",
    èµ¶æµªå¤´: "gÇŽn lÃ ng tÃ³u",
    èµ¶å¾—ä¸Š: "gÇŽn de shÃ ng",
    å¹²é…µæ¯: "gÄn jiÃ o mÇ”",
    å˜Žæ¸£å„¿: "gÄ zhÄ er",
    å˜Žå˜£è„†: "gÄ bÄ“ng cuÃ¬",
    å¯¹å¾—ä½: "duÃ¬ de zhÃ¹",
    é€—é—·å­: "dÃ²u mÃ¨n zi",
    é¡¶å‘±å‘±: "dÇng guÄ guÄ",
    æ»´æºœå„¿: "dÄ« liÃ¹ er",
    å¤§è½´å­: "dÃ  zhÃ²u zi",
    æ‰“æ¿å­: "dÇŽ bÇŽn zi",
    å¯¸åŠ²å„¿: "cÃ¹n jÃ¬n er",
    é†‹åŠ²å„¿: "cÃ¹ jÃ¬n er",
    æ£æ‰‹å„¿: "chuÄi shÇ’u er",
    å†²åŠ²å„¿: "chÃ²ng jÃ¬n er",
    åƒå¾—æ¥: "chÄ« de lÃ¡i",
    ä¸æ›´äº‹: "bÃ¹ gÄ“ng shÃ¬",
    å¥”å¤´å„¿: "bÃ¨n tou er",
    ç™¾å¤«é•¿: "bÇŽi fÅ« zhÇŽng",
    å¨ƒå¨ƒäº²: "wÃ¡ wa qÄ«n",
    æ­»åŠ²å„¿: "sÇ jÃ¬n er",
    éª¨æœµå„¿: "gÅ« duÇ’ er",
    åŠŸåŠ³ç°¿: "gÅng lÃ¡o bÃ¹",
    éƒ½æ±Ÿå °: "dÅ« jiÄng yÃ n",
    ä¸€æ‹…æ°´: "yÃ­ dÃ n shuÇ",
    å¦æžæ³°: "pÇ jÃ­ tÃ i",
    æ³°æ¥å¦: "tÃ i lÃ¡i pÇ",
    å’³ç‰¹çµ: "kÃ© tÃ¨ lÃ­ng",
    å¼€æˆ·è¡Œ: "kÄi hÃ¹ hÃ¡ng",
    éƒ¦é£Ÿå…¶: "lÃ¬ yÃ¬ jÄ«",
    èŠ±äº‹äº†: "huÄ shÃ¬ liÇŽo",
    // ä¸€å­—å˜è°ƒçš„è¯è¯­ï¼ˆä¸Žä¸¤ä¸ªå­—çš„å­—å…¸å†²çªï¼Œæ•…éœ€è¦é‡æ–°å®šä¹‰ï¼‰
    ä¸€æ›´æ›´: "yÃ¬ gÄ“ng gÄ“ng",
    ä¸€é‡å±±: "yÃ¬ chÃ³ng shÄn",
    é£Žä¸€æ›´: "fÄ“ng yÃ¬ gÄ“ng",
    é›ªä¸€æ›´: "xuÄ› yÃ¬ gÄ“ng",
    å½’ä¸€ç : "guÄ« yÃ¬ mÇŽ",
    // ä¸€å­—ä¸å˜è°ƒçš„è¯è¯­ï¼ˆéœ€è¦å¢žè¡¥æ›´å¤šï¼‰
    æ˜ŸæœŸä¸€: "xÄ«ng qÄ« yÄ«",
    ç¤¼æ‹œä¸€: "lÇ bÃ i yÄ«",
    ä¸€å­£åº¦: "yÄ« jÃ¬ dÃ¹",
    ä¸€æœˆä¸€: "yÄ« yuÃ¨ yÄ«",
    ä¸€å­—é©¬: "yÄ« zÃ¬ mÇŽ",
    ä¸€æ˜¯ä¸€: "yÄ« shÃ¬ yÄ«",
    ä¸€æ¬¡æ–¹: "yÄ« cÃ¬ fÄng",
    ä¸€é˜³æŒ‡: "yÄ« yÃ¡ng zhÇ",
    ä¸€å­—å†³: "yÄ« zÃ¬ juÃ©",
    ä¸€å¹´çº§: "yÄ« niÃ¡n jÃ­",
    ä¸€ä¸åš: "yÄ« bÃº zuÃ²",
    å±ˆæˆŒå„¿: "qÅ« qu Ã©r",
    éš¾ä¸ºæ°´: "nÃ¡n wÃ©i shuÇ",
    éš¾ä¸ºæƒ…: "nÃ¡n wÃ©i qÃ­ng",
    è¡Œä¸€è¡Œ: "xÃ­ng yÃ¬ hÃ¡ng",
    åˆ«åˆ«çš„: "biÃ¨ biÃ© de",
    å¹²å“ªè¡Œ: "gÃ n nÇŽ hÃ¡ng",
    å¹²ä¸€è¡Œ: "gÃ n yÃ¬ hÃ¡ng",
    æ›²åˆ«é’ˆ: "qÅ« biÃ© zhÄ“n"
  };
  const Pattern3 = Object.keys(DICT3).map((key) => ({
    zh: key,
    pinyin: DICT3[key],
    probability: 2e-8,
    length: 3,
    priority: Priority.Normal,
    dict: Symbol("dict3")
  }));
  const DICT4 = {
    æˆå‰æ€æ±—: "chÃ©ng jÃ­ sÄ« hÃ¡n",
    å››é€šå…«è¾¾: "sÃ¬ tÅng bÄ dÃ¡",
    ä¸€æ¨¡ä¸€æ ·: "yÃ¬ mÃº yÃ­ yÃ ng",
    é’è—é«˜åŽŸ: "qÄ«ng zÃ ng gÄo yuÃ¡n",
    é˜¿å¼¥é™€ä½›: "Ä“ mÃ­ tuÃ³ fÃ³",
    è§£æ”¾æ€æƒ³: "jiÃ¨ fÃ ng sÄ« xiÇŽng",
    æ‰€ä½œæ‰€ä¸º: "suÇ’ zuÃ² suÇ’ wÃ©i",
    è¿·è¿·ç³Šç³Š: "mÃ­ mÃ­ hu hÅ«",
    è·æžªå®žå¼¹: "hÃ¨ qiÄng shÃ­ dÃ n",
    å…´é«˜é‡‡çƒˆ: "xÃ¬ng gÄo cÇŽi liÃ¨",
    æ— èƒ½ä¸ºåŠ›: "wÃº nÃ©ng wÃ©i lÃ¬",
    å¸ƒé²å¡žå°”: "bÃ¹ lÇ” sÃ i Ä›r",
    ä¸ºæ‰€æ¬²ä¸º: "wÃ©i suÇ’ yÃ¹ wÃ©i",
    å…‹ä»€ç±³å°”: "kÃ¨ shÃ­ mÇ Ä›r",
    æ²¡å®Œæ²¡äº†: "mÃ©i wÃ¡n mÃ©i liÇŽo",
    ä¸ä¸ºäººçŸ¥: "bÃ¹ wÃ©i rÃ©n zhÄ«",
    ç»“ç»“å·´å·´: "jiÄ“ jiÄ“ bÄ bÄ",
    å‰ä»†åŽç»§: "qiÃ¡n pÅ« hÃ²u jÃ¬",
    é“ºå¤©ç›–åœ°: "pÅ« tiÄn gÃ i dÃ¬",
    ç›´æˆªäº†å½“: "zhÃ­ jiÃ© liÇŽo dÃ ng",
    ä¾›ä¸åº”æ±‚: "gÅng bÃº yÃ¬ng qiÃº",
    å¾¡å²å¤§å¤«: "yÃ¹ shÇ dÃ  fÅ«",
    ä¸ä¸ºç“¦å…¨: "bÃ¹ wÃ©i wÇŽ quÃ¡n",
    ä¸å¯æ”¶æ‹¾: "bÃ¹ kÄ› shÅu shi",
    èƒ¡ä½œéžä¸º: "hÃº zuÃ² fÄ“i wÃ©i",
    åˆ†æ¯«ä¸å·®: "fÄ“n hÃ¡o bÃº chÃ ",
    æ¨¡æ¨¡ç³Šç³Š: "mÃ³ mÃ³ hu hÅ«",
    ä¸è¶³ä¸ºå¥‡: "bÃ¹ zÃº wÃ©i qÃ­",
    æ‚„æ— å£°æ¯: "qiÇŽo wÃº shÄ“ng xÄ«",
    äº†å¦‚æŒ‡æŽŒ: "liÇŽo rÃº zhÇ zhÇŽng",
    æ·±æ¶ç—›ç»: "shÄ“n wÃ¹ tÃ²ng juÃ©",
    é«˜é«˜å…´å…´: "gÄo gÄo xÃ¬ng xÃ¬ng",
    å”‰å£°å¹æ°”: "Äi shÄ“ng tÃ n qÃ¬",
    æ±‰è—è¯­ç³»: "hÃ n zÃ ng yÇ” xÃ¬",
    å¤„å¿ƒç§¯è™‘: "chÇ” xÄ«n jÄ« lÇœ",
    æ³£ä¸æˆå£°: "qÃ¬ bÃ¹ chÃ©ng shÄ“ng",
    åŠå¤œä¸‰æ›´: "bÃ n yÃ¨ sÄn gÄ“ng",
    å¤±é­‚è½é­„: "shÄ« hÃºn luÃ² pÃ²",
    äºŒåå…«å®¿: "Ã¨r shÃ­ bÄ xiÃ¹",
    è½¬æ¥è½¬åŽ»: "zhuÃ n lÃ¡i zhuÃ n qÃ¹",
    æ•°ä»¥ä¸‡è®¡: "shÇ” yÇ wÃ n jÃ¬",
    ç›¸ä¾ä¸ºå‘½: "xiÄng yÄ« wÃ©i mÃ¬ng",
    æ‹æ‹ä¸èˆ: "liÃ n liÃ n bÃ¹ shÄ›",
    å±ˆæŒ‡å¯æ•°: "qÅ« zhÇ kÄ› shÇ”",
    ç¥žå‡ºé¬¼æ²¡: "shÃ©n chÅ« guÇ mÃ²",
    ç»“ç»“å®žå®ž: "jiÄ“ jiÄ“ shÃ­ shÃ­",
    æœ‰çš„æ”¾çŸ¢: "yÇ’u dÃ¬ fÃ ng shÇ",
    å½å“©å’•å™œ: "jÄ« lÇ gÅ« lÅ«",
    è°ƒå…µé£å°†: "diÃ o bÄ«ng qiÇŽn jiÃ ng",
    è½½æ­Œè½½èˆž: "zÃ i gÄ“ zÃ i wÇ”",
    è½¬å±ä¸ºå®‰: "zhuÇŽn wÄ“i wÃ©i Än",
    è¸è¸å®žå®ž: "tÄ tÄ shi shÃ­",
    æ¡‘ç»™å·´å°”: "sÄng jÇ bÄ Ä›r",
    è£…æ¨¡ä½œæ ·: "zhuÄng mÃº zuÃ² yÃ ng",
    è§ä¹‰å‹‡ä¸º: "jiÃ n yÃ¬ yÇ’ng wÃ©i",
    ç›¸å·®æ— å‡ : "xiÄng chÄ wÃº jÇ",
    å¹ä¸ºè§‚æ­¢: "tÃ n wÃ©i guÄn zhÇ",
    é—·é—·ä¸ä¹: "mÃ¨n mÃ¨n bÃº lÃ¨",
    å–œæ€’å“€ä¹: "xÇ nÃ¹ Äi lÃ¨",
    é²œä¸ºäººçŸ¥: "xiÇŽn wÃ©i rÃ©n zhÄ«",
    å¼ ç‰™èˆžçˆª: "zhÄng yÃ¡ wÇ” zhÇŽo",
    ä¸ºéžä½œæ­¹: "wÃ©i fÄ“i zuÃ² dÇŽi",
    å«ç³Šå…¶è¾ž: "hÃ¡n hÃº qÃ­ cÃ­",
    ç–²äºŽå¥”å‘½: "pÃ­ yÃº bÄ“n mÃ¬ng",
    å‹‰ä¸ºå…¶éš¾: "miÇŽn wÃ©i qÃ­ nÃ¡n",
    ä¾ä¾ä¸èˆ: "yÄ« yÄ« bÃ¹ shÄ›",
    é¡¶å¤´ä¸Šå¸: "dÇng tÃ³u shÃ ng si",
    ä¸ç€è¾¹é™…: "bÃ¹ zhuÃ³ biÄn jÃ¬",
    å¤§æ¨¡å¤§æ ·: "dÃ  mÃº dÃ  yÃ ng",
    å¯»æ¬¢ä½œä¹: "xÃºn huÄn zuÃ² lÃ¨",
    ä¸€èµ°äº†ä¹‹: "yÃ¬ zÇ’u liÇŽo zhÄ«",
    å­—é‡Œè¡Œé—´: "zÃ¬ lÇ hÃ¡ng jiÄn",
    å«å«ç³Šç³Š: "hÃ¡n hÃ¡n hu hÅ«",
    æ°å¦‚å…¶åˆ†: "qiÃ  rÃº qÃ­ fÃ¨n",
    ç ´æ¶•ä¸ºç¬‘: "pÃ² tÃ¬ wÃ©i xiÃ o",
    æ·±æ›´åŠå¤œ: "shÄ“n gÄ“ng bÃ n yÃ¨",
    åƒå·®ä¸‡åˆ«: "qiÄn chÄ wÃ n biÃ©",
    æ•°ä¸èƒœæ•°: "shÇ” bÃº shÃ¨ng shÇ”",
    æ®ä¸ºå·±æœ‰: "jÃ¹ wÃ©i jÇ yÇ’u",
    å¤©æ—‹åœ°è½¬: "tiÄn xuÃ¡n dÃ¬ zhuÃ n",
    å…»å°Šå¤„ä¼˜: "yÇŽng zÅ«n chÇ” yÅu",
    çŽ»ç’ƒçº¤ç»´: "bÅ li xiÄn wÃ©i",
    åµåµé—¹é—¹: "chÄo chao nÃ o nÃ o",
    æ™•å¤´è½¬å‘: "yÅ«n tÃ³u zhuÃ n xiÃ ng",
    åœŸç”ŸåœŸé•¿: "tÇ” shÄ“ng tÇ” zhÇŽng",
    å®æ­»ä¸å±ˆ: "nÃ¬ng sÇ bÃ¹ qÅ«",
    ä¸çœäººäº‹: "bÃ¹ xÇng rÃ©n shÃ¬",
    å°½åŠ›è€Œä¸º: "jÃ¬n lÃ¬ Ã©r wÃ©i",
    ç²¾æ˜Žå¼ºå¹²: "jÄ«ng mÃ­ng qiÃ¡ng gÃ n",
    å” å” å¨å¨: "lÃ¡o lao dÄo dÄo",
    å½å½å–³å–³: "jÄ« ji zhÄ zhÄ",
    åŠŸä¸å¯æ²¡: "gÅng bÃ¹ kÄ› mÃ²",
    é”²è€Œä¸èˆ: "qiÃ¨ Ã©r bÃ¹ shÄ›",
    æŽ’å¿§è§£éš¾: "pÃ¡i yÅu jiÄ› nÃ n",
    ç¨€é‡Œç³Šæ¶‚: "xÄ« li hÃº tÃº",
    å„æœ‰æ‰€é•¿: "gÃ¨ yÇ’u suÇ’ chÃ¡ng",
    çš„çš„ç¡®ç¡®: "dÃ­ dÃ­ quÃ¨ quÃ¨",
    å“„å ‚å¤§ç¬‘: "hÅng tÃ¡ng dÃ  xiÃ o",
    å¬è€Œä¸é—»: "tÄ«ng Ã©r bÃ¹ wÃ©n",
    åˆ€è€•ç«ç§: "dÄo gÄ“ng huÇ’ zhÃ²ng",
    å†…åˆ†æ³Œè…º: "nÃ¨i fÃ¨n mÃ¬ xiÃ n",
    åŒ–é™©ä¸ºå¤·: "huÃ  xiÇŽn wÃ©i yÃ­",
    ç™¾å‘ç™¾ä¸­: "bÇŽi fÄ bÇŽi zhÃ²ng",
    é‡è§å¤©æ—¥: "chÃ³ng jiÃ n tiÄn rÃ¬",
    åè´¥ä¸ºèƒœ: "fÇŽn bÃ i wÃ©i shÃ¨ng",
    ä¸€äº†ç™¾äº†: "yÃ¬ liÇŽo bÇŽi liÇŽo",
    å¤§å¤§å’§å’§: "dÃ  da liÄ“ liÄ“",
    å¿ƒæ€¥ç«ç‡Ž: "xÄ«n jÃ­ huÇ’ liÇŽo",
    ç²—å¿ƒå¤§æ„: "cÅ« xÄ«n dÃ  yi",
    é¸¡çš®ç–™ç˜©: "jÄ« pÃ­ gÄ“ da",
    å¤·ä¸ºå¹³åœ°: "yÃ­ wÃ©i pÃ­ng dÃ¬",
    æ—¥ç§¯æœˆç´¯: "rÃ¬ jÄ« yuÃ¨ lÄ›i",
    è®¾èº«å¤„åœ°: "shÃ¨ shÄ“n chÇ” dÃ¬",
    æŠ•å…¶æ‰€å¥½: "tÃ³u qÃ­ suÇ’ hÃ o",
    é—´ä¸å®¹å‘: "jiÄn bÃ¹ rÃ³ng fÃ ",
    äººæ»¡ä¸ºæ‚£: "rÃ©n mÇŽn wÃ©i huÃ n",
    ç©·è¿½ä¸èˆ: "qiÃ³ng zhuÄ« bÃ¹ shÄ›",
    ä¸ºæ—¶å·²æ™š: "wÃ©i shÃ­ yÇ wÇŽn",
    å¦‚æ•°å®¶ç: "rÃº shÇ” jiÄ zhÄ“n",
    å¿ƒé‡Œæœ‰æ•°: "xÄ«n lÇ yÇ’u shÃ¹",
    ä»¥ç‰™è¿˜ç‰™: "yÇ yÃ¡ huÃ¡n yÃ¡",
    ç¥žä¸å®ˆèˆ: "shÃ©n bÃ¹ shÇ’u shÄ›",
    å­Ÿä»€ç»´å…‹: "mÃ¨ng shÃ­ wÃ©i kÃ¨",
    å„è‡ªä¸ºæˆ˜: "gÃ¨ zÃ¬ wÃ©i zhÃ n",
    æ€¨å£°è½½é“: "yuÃ n shÄ“ng zÃ i dÃ o",
    æ•‘è‹¦æ•‘éš¾: "jiÃ¹ kÇ” jiÃ¹ nÃ n",
    å¥½å¥½å…ˆç”Ÿ: "hÇŽo hÇŽo xiÄn sheng",
    æ€ªæ¨¡æ€ªæ ·: "guÃ i mÃº guÃ i yÃ ng",
    æŠ›å¤´éœ²é¢: "pÄo tÃ³u lÃ¹ miÃ n",
    æ¸¸æ‰‹å¥½é—²: "yÃ³u shÇ’u hÃ o xiÃ¡n",
    æ— æ‰€ä¸ä¸º: "wÃº suÇ’ bÃ¹ wÃ©i",
    è°ƒè™Žç¦»å±±: "diÃ o hÇ” lÃ­ shÄn",
    æ­¥æ­¥ä¸ºè¥: "bÃ¹ bÃ¹ wÃ©i yÃ­ng",
    å¥½å¤§å–œåŠŸ: "hÃ o dÃ  xÇ gÅng",
    ä¼—çŸ¢ä¹‹çš„: "zhÃ²ng shÇ zhÄ« dÃ¬",
    é•¿ç”Ÿä¸æ­»: "chÃ¡ng shÄ“ng bÃ¹ sÇ",
    è”šä¸ºå£®è§‚: "wÃ¨i wÃ©i zhuÃ ng guÄn",
    ä¸å¯èƒœæ•°: "bÃ¹ kÄ› shÃ¨ng shÇ”",
    é¬¼ä½¿ç¥žå·®: "guÇ shÇ shÃ©n chÄi",
    æ´èº«è‡ªå¥½: "jiÃ© shÄ“n zÃ¬ hÃ o",
    æ•¢ä½œæ•¢ä¸º: "gÇŽn zuÃ² gÇŽn wÃ©i",
    èŒ…å¡žé¡¿å¼€: "mÃ¡o sÃ¨ dÃ¹n kÄi",
    èµ°é©¬æ¢å°†: "zÇ’u mÇŽ huÃ n jiÃ ng",
    ä¸ºæ—¶è¿‡æ—©: "wÃ©i shÃ­ guÃ² zÇŽo",
    ä¸ºäººå¸ˆè¡¨: "wÃ©i rÃ©n shÄ« biÇŽo",
    é˜´å·®é˜³é”™: "yÄ«n chÄ yÃ¡ng cuÃ²",
    æ²¹è…”æ»‘è°ƒ: "yÃ³u qiÄng huÃ¡ diÃ o",
    é‡è¹ˆè¦†è¾™: "chÃ³ng dÇŽo fÃ¹ zhÃ©",
    éª‚éª‚å’§å’§: "mÃ  ma liÄ“ liÄ“",
    çµ®çµ®å¨å¨: "xÃ¹ xÃ¹ dÄo dÄo",
    å¦‚å±¥è–„å†°: "rÃº lÇš bÃ³ bÄ«ng",
    æŸå…µæŠ˜å°†: "sÇ”n bÄ«ng zhÃ© jiÃ ng",
    æ‹å¼¯æŠ¹è§’: "guÇŽi wÄn mÃ² jiÇŽo",
    åƒæ¨¡åƒæ ·: "xiÃ ng mÃº xiÃ ng yÃ ng",
    ä¾›è¿‡äºŽæ±‚: "gÅng guÃ² yÃº qiÃº",
    å¼€èŠ±ç»“æžœ: "kÄi huÄ jiÄ“ guÇ’",
    ä»”ä»”ç»†ç»†: "zÇ zÇ xÃ¬ xÃ¬",
    å·è—å…¬è·¯: "chuÄn zÃ ng gÅng lÃ¹",
    æ²³åŒ—æ¢†å­: "hÃ© bÄ›i bÄng zi",
    é•¿å¹´ç´¯æœˆ: "chÃ¡ng niÃ¡n lÄ›i yuÃ¨",
    æ­£å„¿å…«ç»: "zhÃ¨ng er bÄ jÄ«ng",
    ä¸è¯†æŠ¬ä¸¾: "bÃ¹ shÃ­ tÃ¡i ju",
    é‡æŒ¯æ——é¼“: "chÃ³ng zhÃ¨n qÃ­ gÇ”",
    æ°”æ¯å¥„å¥„: "qÃ¬ xÄ« yÄn yÄn",
    ç´§è¿½ä¸èˆ: "jÇn zhuÄ« bÃ¹ shÄ›",
    æœæœå¸–å¸–: "fÃº fu tiÄ“ tiÄ“",
    å¼ºè¯å¤ºç†: "qiÇŽng cÃ­ duÃ³ lÇ",
    å™¼é‡Œå•ªå•¦: "pÄ« li pÄ lÄ",
    äººæ‰æµŽæµŽ: "rÃ©n cÃ¡i jÇ jÇ",
    å‘äººæ·±çœ: "fÄ rÃ©n shÄ“n xÇng",
    ä¸è¶³ä¸ºå‡­: "bÃ¹ zÃº wÃ©i pÃ­ng",
    ä¸ºå¯Œä¸ä»: "wÃ©i fÃ¹ bÃ¹ rÃ©n",
    è¿žç¯‡ç´¯ç‰: "liÃ¡n piÄn lÄ›i dÃº",
    å‘¼å¤©æŠ¢åœ°: "hÅ« tiÄn qiÄng dÃ¬",
    è½è½å¤§æ–¹: "luÃ² luÃ² dÃ  fÄng",
    è‡ªå¹è‡ªæ“‚: "zÃ¬ chuÄ« zÃ¬ lÃ©i",
    ä¹å–„å¥½æ–½: "lÃ¨ shÃ n hÃ o shÄ«",
    ä»¥æ”»ä¸ºå®ˆ: "yÇ gÅng wÃ©i shÇ’u",
    ç£¨ç£¨è¹­è¹­: "mÃ³ mÃ³ cÃ¨ng cÃ¨ng",
    å‰Šé“å¦‚æ³¥: "xuÄ“ tiÄ› rÃº nÃ­",
    åŠ©çº£ä¸ºè™: "zhÃ¹ zhÃ²u wÃ©i nÃ¼Ã¨",
    ä»¥é€€ä¸ºè¿›: "yÇ tuÃ¬ wÃ©i jÃ¬n",
    å˜å˜å–³å–³: "qÄ« qÄ« chÄ chÄ",
    æžªæž—å¼¹é›¨: "qiÄng lÃ­n dÃ n yÇ”",
    ä»¤äººå‘æŒ‡: "lÃ¬ng rÃ©n fÃ  zhÇ",
    è½¬è´¥ä¸ºèƒœ: "zhuÇŽn bÃ i wÃ©i shÃ¨ng",
    è½¬å¼¯æŠ¹è§’: "zhuÇŽn wÄn mÃ² jiÇŽo",
    åœ¨åŠ«éš¾é€ƒ: "zÃ i jiÃ© nÃ¡n tÃ¡o",
    æ­£å½“é˜²å«: "zhÃ¨ng dÃ ng fÃ¡ng wÃ¨i",
    ä¸è¶³ä¸ºæ€ª: "bÃ¹ zÃº wÃ©i guÃ i",
    éš¾å…„éš¾å¼Ÿ: "nÃ n xiÅng nÃ n dÃ¬",
    å’¿å’¿å‘€å‘€: "yÄ« yÄ« yÄ yÄ",
    å¼¹å°½ç²®ç»: "dÃ n jÃ¬n liÃ¡ng juÃ©",
    é˜¿è°€å¥‰æ‰¿: "Ä“ yÃº fÃ¨ng chÃ©ng",
    ç¨€é‡Œå“—å•¦: "xÄ« li huÄ lÄ",
    è¿”è€è¿˜ç«¥: "fÇŽn lÇŽo huÃ¡n tÃ³ng",
    å¥½é«˜éª›è¿œ: "hÃ o gÄo wÃ¹ yuÇŽn",
    é¹¿æ­»è°æ‰‹: "lÃ¹ sÇ shÃ©i shÇ’u",
    å·®å¼ºäººæ„: "chÄ qiÃ¡ng rÃ©n yÃ¬",
    å¤§å¹å¤§æ“‚: "dÃ  chuÄ« dÃ  lÃ©i",
    æˆå®¶ç«‹ä¸š: "chÃ©ng jiÄ lÃ¬ yÃ¨",
    è‡ªæ€¨è‡ªè‰¾: "zÃ¬ yuÃ n zÃ¬ yÃ¬",
    è´Ÿå€ºç´¯ç´¯: "fÃ¹ zhÃ i lÄ›i lÄ›i",
    å¤ä¸ºä»Šç”¨: "gÇ” wÃ©i jÄ«n yÃ²ng",
    å…¥åœŸä¸ºå®‰: "rÃ¹ tÇ” wÃ©i Än",
    ä¸‹ä¸ä¸ºä¾‹: "xiÃ  bÃ¹ wÃ©i lÃ¬",
    ä¸€å“„è€Œä¸Š: "yÃ¬ hÅng Ã©r shÃ ng",
    æ²¡å¤´è‹è‡: "mÃ©i tÃ³u cÄng ying",
    å¤©å·®åœ°è¿œ: "tiÄn chÄ dÃ¬ yuÇŽn",
    é£Žå·æ®‹äº‘: "fÄ“ng juÇŽn cÃ¡n yÃºn",
    å¤šç¾å¤šéš¾: "duÅ zÄi duÅ nÃ n",
    ä¹³è‡­æœªå¹²: "rÇ” xiÃ¹ wÃ¨i gÄn",
    è¡Œå®¶é‡Œæ‰‹: "hÃ¡ng jiÄ lÇ shÇ’u",
    ç‹¼ç‹ˆä¸ºå¥¸: "lÃ¡ng bÃ¨i wÃ©i jiÄn",
    å¤„å˜ä¸æƒŠ: "chÇ” biÃ n bÃ¹ jÄ«ng",
    ä¸€å”±ä¸€å’Œ: "yÃ­ chÃ ng yÃ­ hÃ¨",
    ä¸€å¿µä¹‹å·®: "yÃ­ niÃ n zhÄ« chÄ",
    é‡‘è‰è„±å£³: "jÄ«n chÃ¡n tuÅ qiÃ o",
    æ»´æ»´ç­”ç­”: "dÄ« dÄ« dÄ dÄ",
    ç¡•æžœç´¯ç´¯: "shuÃ² guÇ’ lÃ©i lÃ©i",
    å¥½æ•´ä»¥æš‡: "hÃ o zhÄ›ng yÇ xiÃ¡",
    çº¢å¾—å‘ç´«: "hÃ³ng de fÄ zÇ",
    ä¼ ä¸ºç¾Žè°ˆ: "chuÃ¡n wÃ©i mÄ›i tÃ¡n",
    å¯Œå•†å¤§è´¾: "fÃ¹ shÄng dÃ  gÇ”",
    å››æµ·ä¸ºå®¶: "sÃ¬ hÇŽi wÃ©i jiÄ",
    äº†è‹¥æŒ‡æŽŒ: "liÇŽo ruÃ² zhÇ zhÇŽng",
    å¤§æœ‰å¯ä¸º: "dÃ  yÇ’u kÄ› wÃ©i",
    å‡ºå¤´éœ²é¢: "chÅ« tÃ³u lÃ¹ miÃ n",
    é¼“é¼“å›Šå›Š: "gÇ” gu nÄng nÄng",
    çª—æ˜Žå‡ å‡€: "chuÄng mÃ­ng jÄ« jÃ¬ng",
    æ³°ç„¶å¤„ä¹‹: "tÃ i rÃ¡n chÇ” zhÄ«",
    æ€’å‘å†²å† : "nÃ¹ fÃ  chÅng guÄn",
    æœ‰æœºçŽ»ç’ƒ: "yÇ’u jÄ« bÅ li",
    éª¨å¤´æž¶å­: "gÇ” tou jiÃ  zi",
    ä¹‰è–„äº‘å¤©: "yÃ¬ bÃ³ yÃºn tiÄn",
    ä¸€ä¸ç‚¹å„¿: "yÄ« dÄ«ng diÇŽn er",
    æ—¶æ¥è¿è½¬: "shÃ­ lÃ¡i yÃ¹n zhuÇŽn",
    é™ˆè¯æ»¥è°ƒ: "chÃ©n cÃ­ lÃ n diÃ o",
    åŒ–æ•´ä¸ºé›¶: "huÃ  zhÄ›ng wÃ©i lÃ­ng",
    ç«çƒ§ç«ç‡Ž: "huÇ’ shÄo huÇ’ liÇŽo",
    å¹²è„†åˆ©ç´¢: "gÃ n cuÃ¬ lÃ¬ suÇ’",
    åŠå„¿éƒŽå½“: "diÃ o er lÃ¡ng dÄng",
    å¹¿ç§è–„æ”¶: "guÇŽng zhÃ²ng bÃ³ shÅu",
    ç§ç“œå¾—ç“œ: "zhÃ²ng guÄ dÃ© guÄ",
    ç§è±†å¾—è±†: "zhÃ²ng dÃ²u dÃ© dÃ²u",
    éš¾èˆéš¾åˆ†: "nÃ¡n shÄ› nÃ¡n fÄ“n",
    æ­ƒè¡€ä¸ºç›Ÿ: "shÃ  xuÃ¨ wÃ©i mÃ©ng",
    å¥‹å‘æœ‰ä¸º: "fÃ¨n fÄ yÇ’u wÃ©i",
    é˜´é”™é˜³å·®: "yÄ«n cuÃ² yÃ¡ng chÄ",
    ä¸œèº²è¥¿è—: "dÅng duÇ’ xÄ« cÃ¡ng",
    çƒŸç†ç«ç‡Ž: "yÄn xÅ«n huÇ’ liÇŽo",
    é’»ç‰›è§’å°–: "zuÄn niÃº jiÇŽo jiÄn",
    ä¹”è£…æ‰“æ‰®: "qiÃ¡o zhuÄng dÇŽ bÃ n",
    æ”¹å¼¦æ›´å¼ : "gÇŽi xiÃ¡n gÄ“ng zhÄng",
    æ²³å—æ¢†å­: "hÃ© nÃ¡n bÄng zi",
    å¥½åƒæ‡’åš: "hÃ o chÄ« lÇŽn zuÃ²",
    ä½•ä¹ä¸ä¸º: "hÃ© lÃ¨ bÃ¹ wÃ©i",
    å¤§å‡ºé£Žå¤´: "dÃ  chÅ« fÄ“ng tÃ³u",
    æ”»åŸŽæŽ åœ°: "gÅng chÃ©ng lÃ¼Ã¨ dÃ¬",
    æ¼‚æ¼‚äº®äº®: "piÃ o piÃ o liang liang",
    æŠ˜è¡·ä¸»ä¹‰: "zhÃ© zhÅng zhÇ” yÃ¬",
    å¤§é©¬å“ˆé±¼: "dÃ  mÇŽ hÇŽ yÃº",
    ç»¿æ ‘æˆè«: "lÇœ shÃ¹ chÃ©ng yÄ«n",
    çŽ‡å…ˆåž‚èŒƒ: "shuÃ i xiÄn chuÃ­ fÃ n",
    å®¶é•¿é‡ŒçŸ­: "jiÄ chÃ¡ng lÇ duÇŽn",
    å®½å¤§ä¸ºæ€€: "kuÄn dÃ  wÃ©i huÃ¡i",
    å·¦è†€å³è‡‚: "zuÇ’ bÇŽng yÃ²u bÃ¬",
    ä¸€ç¬‘äº†ä¹‹: "yÃ­ xiÃ o liÇŽo zhÄ«",
    å¤©ä¸‹ä¸ºå…¬: "tiÄn xiÃ  wÃ©i gÅng",
    è¿˜æˆ‘æ²³å±±: "huÃ¡n wÇ’ hÃ© shÄn",
    ä½•è¶³ä¸ºå¥‡: "hÃ© zÃº wÃ©i qÃ­",
    å¥½è‡ªä¸ºä¹‹: "hÇŽo zÃ¬ wÃ©i zhÄ«",
    é£Žå§¿ç»°çº¦: "fÄ“ng zÄ« chuÃ² yuÄ“",
    å¤§é›¨æ»‚æ²±: "dÃ  yÇ” pÄng tuÃ³",
    ä¼ ä¸ºä½³è¯: "chuÃ¡n wÃ©i jiÄ huÃ ",
    åƒé‡Œæ‰’å¤–: "chÄ« lÇ pÃ¡ wÃ i",
    é‡æ“æ—§ä¸š: "chÃ³ng cÄo jiÃ¹ yÃ¨",
    å°å®¶å­æ°”: "xiÇŽo jiÄ zi qÃ¬",
    å°‘ä¸æ›´äº‹: "shÃ o bÃ¹ gÄ“ng shÃ¬",
    éš¾åˆ†éš¾èˆ: "nÃ¡n fÄ“n nÃ¡n shÄ›",
    æ·»ç –åŠ ç“¦: "tiÄn zhuÄn jiÄ wÇŽ",
    æ˜¯éžåˆ†æ˜Ž: "shÃ¬ fÄ“i fÄ“n mÃ­ng",
    èˆæˆ‘å…¶è°: "shÄ› wÇ’ qÃ­ shuÃ­",
    åå¬åä¿¡: "piÄn tÄ«ng piÄn xÃ¬n",
    é‡å…¥ä¸ºå‡º: "liÃ ng rÃ¹ wÃ©i chÅ«",
    é™é¾™ä¼è™Ž: "xiÃ¡ng lÃ³ng fÃº hÇ”",
    é’¢åŒ–çŽ»ç’ƒ: "gÄng huÃ  bÅ li",
    æ­£ä¸­ä¸‹æ€€: "zhÃ¨ng zhÃ²ng xiÃ  huÃ¡i",
    ä»¥èº«è®¸å›½: "yÇ shÄ“n xÇ” guÃ³",
    ä¸€è¯­ä¸­çš„: "yÃ¬ yÇ” zhÃ²ng dÃ¬",
    ä¸§é­‚è½é­„: "sÃ ng hÃºn luÃ² pÃ²",
    ä¸‰åº§å¤§å±±: "sÄn zuÃ² dÃ  shÄn",
    æµŽæµŽä¸€å ‚: "jÇ jÇ yÃ¬ tÃ¡ng",
    å¥½äº‹ä¹‹å¾’: "hÃ o shÃ¬ zhÄ« tÃº",
    å¹²å‡€åˆ©ç´¢: "gÃ n jÃ¬ng lÃ¬ suÇ’",
    å‡ºå°†å…¥ç›¸: "chÅ« jiÃ ng rÃ¹ xiÃ ng",
    è¢…è¢…å¨œå¨œ: "niÇŽo niÇŽo nuÃ³ nuÃ³",
    ç‹ç‹¸å°¾å·´: "hÃº li wÄ›i ba",
    å¥½é€¸æ¶åŠ³: "hÃ o yÃ¬ wÃ¹ lÃ¡o",
    å¤§è€Œæ— å½“: "dÃ  Ã©r wÃº dÃ ng",
    æ‰“é©¬è™Žçœ¼: "dÇŽ mÇŽ hu yÇŽn",
    æ¿ä¸Šé’‰é’‰: "bÇŽn shÃ ng dÃ¬ng dÄ«ng",
    å†äº”å–å…­: "yÄo wÇ” hÃ¨ liÃ¹",
    è™¾å…µèŸ¹å°†: "xiÄ bÄ«ng xiÃ¨ jiÃ ng",
    æ°´è°ƒæ­Œå¤´: "shuÇ diÃ o gÄ“ tÃ³u",
    æ•°å…¸å¿˜ç¥–: "shÇ” diÇŽn wÃ ng zÇ”",
    äººäº‹ä¸çœ: "rÃ©n shÃ¬ bÃ¹ xÇng",
    æ›²é«˜å’Œå¯¡: "qÇ” gÄo hÃ¨ guÇŽ",
    å±¡æ•™ä¸æ”¹: "lÇš jiÃ o bÃ¹ gÇŽi",
    äº’ä¸ºå› æžœ: "hÃ¹ wÃ©i yÄ«n guÇ’",
    äº’ä¸ºè¡¨é‡Œ: "hÃ¹ wÃ©i biÇŽo lÇ",
    åŽšæ­¤è–„å½¼: "hÃ²u cÇ bÃ³ bÇ",
    è¿‡å…³æ–©å°†: "guÃ² guÄn zhÇŽn jiÃ ng",
    ç–™ç–™ç˜©ç˜©: "gÄ“ ge dÄ dÄ",
    å¤§è…¹ä¾¿ä¾¿: "dÃ  fÃ¹ piÃ¡n piÃ¡n",
    èµ°ä¸ºä¸Šç­–: "zÇ’u wÃ©i shÃ ng cÃ¨",
    å†¤å®¶å¯¹å¤´: "yuÄn jia duÃ¬ tÃ³u",
    æœ‰éš™å¯ä¹˜: "yÇ’u xÃ¬ kÄ› chÃ¨ng",
    ä¸€é³žåŠçˆª: "yÃ¬ lÃ­n bÃ n zhÇŽo",
    ç‰‡è¨€åªè¯­: "piÃ n yÃ¡n zhÇ yÇ”",
    å¼€èŠ±ç»“å®ž: "kÄi huÄ jiÃ© shÃ­",
    ç»å¹´ç´¯æœˆ: "jÄ«ng niÃ¡n lÄ›i yuÃ¨",
    å«ç³Šå…¶è¯: "hÃ¡n hÃº qÃ­ cÃ­",
    å¯¡å»‰é²œè€»: "guÇŽ liÃ¡n xiÇŽn chÇ",
    æˆå¹´ç´¯æœˆ: "chÃ©ng niÃ¡n lÄ›i yuÃ¨",
    ä¸å¾‡ç§æƒ…: "bÃº xÃ¹n sÄ« qÃ­ng",
    ä¸å½“äººå­: "bÃ¹ dÄng rÃ©n zÇ",
    è†€å¤§è…°åœ†: "bÇŽng dÃ  yÄo yuÃ¡n",
    æŒ‡è…¹ä¸ºå©š: "zhÇ fÃ¹ wÃ©i hÅ«n",
    è¿™ä¹ˆç‚¹å„¿: "zhÃ¨ me diÇŽn er",
    æ„å…´ç´¢ç„¶: "yÃ¬ xÄ«ng suÇ’ rÃ¡n",
    ç»£èŠ±æž•å¤´: "xiÃ¹ huÄ zhÄ›n tou",
    æ— çš„æ”¾çŸ¢: "wÃº dÃ¬ fÃ ng shÇ",
    æœ›é—»é—®åˆ‡: "wÃ ng wÃ©n wÃ¨n qiÃ¨",
    èˆå·±ä¸ºäºº: "shÄ› jÇ wÃ¨i rÃ©n",
    ç©·å¹´ç´¯æœˆ: "qiÃ³ng niÃ¡n lÄ›i yuÃ¨",
    æŽ’éš¾è§£çº·: "pÃ¡i nÃ n jiÄ› fÄ“n",
    å¤„ä¹‹æ³°ç„¶: "chÇ” zhÄ« tÃ i rÃ¡n",
    æŒ‡é¹¿ä¸ºé©¬: "zhÇ lÃ¹ wÃ©i mÇŽ",
    å±å¦‚ç´¯åµ: "wÄ“i rÃº lÄ›i luÇŽn",
    å¤©å…µå¤©å°†: "tiÄn bÄ«ng tiÄn jiÃ ng",
    èˆè¿‘æ±‚è¿œ: "shÄ› jÃ¬n qiÃº yuÇŽn",
    å—è…”åŒ—è°ƒ: "nÃ¡n qiÄng bÄ›i diÃ o",
    è‹¦ä¸­ä½œä¹: "kÇ” zhÅng zuÃ² lÃ¨",
    åŽšç§¯è–„å‘: "hÃ²u jÄ« bÃ³ fÄ",
    è‡­å‘³ç›¸æŠ•: "xiÃ¹ wÃ¨i xiÄng tÃ³u",
    é•¿å¹¼æœ‰åº: "zhÇŽng yÃ²u yÇ’u xÃ¹",
    é€¼è‰¯ä¸ºå¨¼: "bÄ« liÃ¡ng wÃ©i chÄng",
    æ‚²æ‚²åˆ‡åˆ‡: "bÄ“i bÄ“i qiÃ¨ qiÄ“",
    è´¥å†›ä¹‹å°†: "bÃ i jÅ«n zhÄ« jiÃ ng",
    æ¬ºè¡Œéœ¸å¸‚: "qÄ« hÃ¡ng bÃ  shÃ¬",
    å‰Šè¶³é€‚å±¥: "xuÄ“ zÃº shÃ¬ lÇš",
    å…ˆç¹ä¸ºå¿«: "xiÄn dÇ” wÃ©i kuÃ i",
    å•¼é¥¥å·å¯’: "tÃ­ jÄ« hÃ¡o hÃ¡n",
    ç–ä¸é—´äº²: "shÅ« bÃº jiÃ n qÄ«n",
    ç¥žå·®é¬¼ä½¿: "shÃ©n chÄi guÇ shÇ",
    æ•²æ•²æ‰“æ‰“: "qiÄo qiÄo dÇŽ dÇŽ",
    å¹³é“ºç›´å™: "pÃ­ng pÅ« zhÃ­ xÃ¹",
    æ²¡å¤´æ²¡å°¾: "mÃ©i tÃ³u mÃ² wÄ›i",
    å¯¥å¯¥å¯æ•°: "liÃ¡o liÃ¡o kÄ› shÇ”",
    å“¼å“ˆäºŒå°†: "hÄ“ng hÄ Ã¨r jiÃ ng",
    é¹¤å‘ç«¥é¢œ: "hÃ¨ fÃ  tÃ³ng yÃ¡n",
    å„å¥”å‰ç¨‹: "gÃ¨ bÃ¨n qiÃ¡n chÃ©ng",
    å¼¹æ— è™šå‘: "dÃ n wÃº xÅ« fÄ",
    å¤§äººå…ˆç”Ÿ: "dÃ  rÃ©n xiÄn sheng",
    ä¸Žæ°‘æ›´å§‹: "yÇ” mÃ­n gÄ“ng shÇ",
    æ ‘ç¢‘ç«‹ä¼ : "shÃ¹ bÄ“i lÃ¬ zhuÃ n",
    æ˜¯éžå¾—å¤±: "shÃ¬ fÄ“i dÃ© shÄ«",
    å®žé€¼å¤„æ­¤: "shÃ­ bÄ« chÇ” cÇ",
    å¡žç¿å¤±é©¬: "sÃ i wÄ“ng shÄ« mÇŽ",
    æ—¥è–„è¥¿å±±: "rÃ¬ bÃ³ xÄ« shÄn",
    åˆ‡èº«ä½“ä¼š: "qiÃ¨ shÄ“n tÇ huÃ¬",
    ç‰‡è¨€åªå­—: "piÃ n yÃ¡n zhÇ zÃ¬",
    è·‘é©¬å–è§£: "pÇŽo mÇŽ mÃ i xiÃ¨",
    å®æŠ˜ä¸å¼¯: "nÃ¬ng zhÃ© bÃ¹ wÄn",
    é›¶é›¶æ•£æ•£: "lÃ­ng lÃ­ng sÇŽn sÇŽn",
    é‡ä½“è£è¡£: "liÃ ng tÇ cÃ¡i yÄ«",
    è¿žä¸­ä¸‰å…ƒ: "liÃ¡n zhÃ²ng sÄn yuÃ¡n",
    ç¤¼å´©ä¹å: "lÇ bÄ“ng yuÃ¨ huÃ i",
    ä¸ä¸ºå·²ç”š: "bÃ¹ wÃ©i yÇ shÃ¨n",
    è½¬æ‚²ä¸ºå–œ: "zhuÇŽn bÄ“i wÃ©i xÇ",
    ä»¥çœ¼è¿˜çœ¼: "yÇ yÇŽn huÃ¡n yÇŽn",
    è”šä¸ºå¤§è§‚: "wÃ¨i wÃ©i dÃ  guÄn",
    æœªä¸ºä¸å¯: "wÃ¨i wÃ©i bÃ¹ kÄ›",
    ç«¥é¢œé¹¤å‘: "tÃ³ng yÃ¡n hÃ¨ fÃ ",
    æœ‹æ¯”ä¸ºå¥¸: "pÃ©ng bÇ wÃ©i jiÄn",
    èŽ«æ­¤ä¸ºç”š: "mÃ² cÇ wÃ©i shÃ¨n",
    å¤¹æžªå¸¦æ£’: "jiÄ qiÄng dÃ i bÃ ng",
    å¯Œå•†å·¨è´¾: "fÃ¹ shÄng jÃ¹ jiÇŽ",
    æ·¡ç„¶å¤„ä¹‹: "dÃ n rÃ¡n chÇ” zhÄ«",
    ç®ªé£Ÿå£¶æµ†: "dÄn shÃ­ hÃº jiÄng",
    åˆ›å·¨ç—›æ·±: "chuÄng jÃ¹ tÃ²ng shÄ“n",
    è‰é•¿èŽºé£ž: "cÇŽo zhÇŽng yÄ«ng fÄ“i",
    åè§†ä¸æ•‘: "zuÃ² shÄ« bÃº jiÃ¹",
    ä»¥å·±åº¦äºº: "yÇ jÇ duÃ³ rÃ©n",
    éšè¡Œå°±å¸‚: "suÃ­ hÃ¡ng jiÃ¹ shÃ¬",
    æ–‡ä»¥è½½é“: "wÃ©n yÇ zÃ i dÃ o",
    æ–‡ä¸å¯¹é¢˜: "wÃ©n bÃº duÃ¬ tÃ­",
    é“æ¿é’‰é’‰: "tiÄ› bÇŽn dÃ¬ng dÄ«ng",
    èº«ä½“å‘è‚¤: "shÄ“n tÇ fÃ  fÅ«",
    ç¼ºåƒå°‘ç©¿: "quÄ“ chÄ« shÇŽo chuÄn",
    ç›®æ— å°Šé•¿: "mÃ¹ wÃº zÅ«n zhÇŽng",
    å‰äººå¤©ç›¸: "jÃ­ rÃ©n tiÄn xiÃ ng",
    æ¯å®¶çº¾éš¾: "huÇ jiÄ shÅ« nÃ n",
    é’¢ç­‹é“éª¨: "gÄng jÄ«n tiÄ› gÇ”",
    ä¸¢å’ä¿è½¦: "diÅ« zÃº bÇŽo jÅ«",
    ä¸¢ä¸‰è½å››: "diÅ« sÄn lÃ  sÃ¬",
    é—­ç›®å¡žå¬: "bÃ¬ mÃ¹ sÃ¨ tÄ«ng",
    å‰Šå°–è„‘è¢‹: "xuÄ“ jiÄn nÇŽo dÃ i",
    ä¸ºéžä½œæ¶: "wÃ©i fÄ“i zuÃ² Ã¨",
    äººæ‰éš¾å¾—: "rÃ©n cÃ¡i nÃ¡n dÃ©",
    æƒ…éžå¾—å·²: "qÃ­ng fÄ“i dÃ© yÇ",
    åˆ‡ä¸­è¦å®³: "qiÃ¨ zhÃ²ng yÃ o hÃ i",
    ç«æ€¥ç«ç‡Ž: "huÇ’ jÃ­ huÇ’ liÇŽo",
    ç”»åœ°ä¸ºç‰¢: "huÃ  dÃ¬ wÃ©i lÃ¡o",
    å¥½é…’è´ªæ¯: "hÃ o jiÇ” tÄn bÄ“i",
    é•¿æ­Œå½“å“­: "chÃ¡ng gÄ“ dÃ ng kÅ«",
    è½½æ²‰è½½æµ®: "zÃ i chÃ©n zÃ i fÃº",
    é‡éš¾å‘ˆç¥¥: "yÃ¹ nÃ n chÃ©ng xiÃ¡ng",
    æ¦†æœ¨ç–™ç˜©: "yÃº mÃ¹ gÄ“ da",
    ä»¥é‚»ä¸ºå£‘: "yÇ lÃ­n wÃ©i hÃ¨",
    æ´‹ä¸ºä¸­ç”¨: "yÃ¡ng wÃ©i zhÅng yÃ²ng",
    è¨€ä¸ºå¿ƒå£°: "yÃ¡n wÃ©i xÄ«n shÄ“ng",
    è¨€å¿…æœ‰ä¸­: "yÃ¡n bÃ¬ yÇ’u zhÃ²ng",
    å›¾ç©·åŒ•è§: "tÃº qiÃ³ng bÇ xiÃ n",
    æ»‚æ²±å¤§é›¨: "pÃ¡ng tuÃ³ dÃ  yÇ”",
    ç›®ä¸æš‡ç»™: "mÃ¹ bÃ¹ xiÃ¡ jÇ",
    é‡æ‰å½•ç”¨: "liÃ ng cÃ¡i lÃ¹ yÃ²ng",
    æ•™å­¦ç›¸é•¿: "jiÃ o xuÃ© xiÄng zhÇŽng",
    æ‚”ä¸å½“åˆ: "huÇ bÃ¹ dÄng chÅ«",
    å‘¼å¹ºå–å…­: "hÅ« yÄo hÃ¨ liÃ¹",
    ä¸è¶³ä¸ºè®­: "bÃ¹ zÃº wÃ©i xÃ¹n",
    ä¸æ‹˜å½¢è¿¹: "bÃ¹ jÅ« xÃ­ng jÄ«",
    å‚è‹¥æ— äºº: "pÃ¡ng ruÃ² wÃº rÃ©n",
    ç½ªè´£éš¾é€ƒ: "zuÃ¬ zÃ© nÃ¡n tÃ¡o",
    è‡ªæˆ‘å¹å˜˜: "zÃ¬ wÇ’ chuÄ« xÅ«",
    è½¬ç¥¸ä¸ºç¦: "zhuÇŽn huÃ² wÃ©i fÃº",
    å‹‡å† ä¸‰å†›: "yÇ’ng guÃ n sÄn jÅ«n",
    æ˜“åœ°è€Œå¤„: "yÃ¬ dÃ¬ Ã©r chÇ”",
    å¸ç£¨æ€é©´: "xiÃ¨ mÃ² shÄ lÇ˜",
    çŽ©å„¿ä¸è½¬: "wÃ¡n Ã©r bÃº zhuÃ n",
    å¤©é“å¥½è¿˜: "tiÄn dÃ o hÇŽo huÃ¡n",
    èº«å•åŠ›è–„: "shÄ“n dÄn lÃ¬ bÃ³",
    æ’’è±†æˆå…µ: "sÇŽ dÃ²u chÃ©ng bÄ«ng",
    ç‰‡çº¸åªå­—: "piÃ n zhÇ zhÄ« zÃ¬",
    å®ç¼ºæ¯‹æ»¥: "nÃ¬ng quÄ“ wÃº lÃ n",
    æ²¡æ²¡æ— é—»: "mÃ² mÃ² wÃº wÃ©n",
    é‡åŠ›è€Œä¸º: "liÃ ng lÃ¬ Ã©r wÃ©i",
    åŽ†åŽ†å¯æ•°: "lÃ¬ lÃ¬ kÄ› shÇ”",
    å£ç¢‘è½½é“: "kÇ’u bÄ“i zÃ i dÃ o",
    å›å­å¥½é€‘: "jÅ«n zÇ hÇŽo qiÃº",
    å¥½ä¸ºäººå¸ˆ: "hÃ o wÃ©i rÃ©n shÄ«",
    è±ªå•†å·¨è´¾: "hÃ¡o shÄng jÃ¹ jiÇŽ",
    å„æœ‰æ‰€å¥½: "gÃ¨ yÇ’u suÇ’ hÃ o",
    åº¦å¾·é‡åŠ›: "duÃ³ dÃ© liÃ ng lÃ¬",
    æŒ‡å¤©ä¸ºèª“: "zhÇ tiÄn wÃ©i shÃ¬",
    é€¸å…´é„é£ž: "yÃ¬ xÃ¬ng chuÃ¡n fÄ“i",
    å¿ƒå®½ä½“èƒ–: "xÄ«n kuÄn tÇ pÃ¡n",
    ä¸ºå¾·ä¸å’: "wÃ©i dÃ© bÃ¹ zÃº",
    å¤©ä¸‹ä¸ºå®¶: "tiÄn xiÃ  wÃ©i jiÄ",
    è§†ä¸ºç•é€”: "shÃ¬ wÃ©i wÃ¨i tÃº",
    ä¸‰ç¾å…«éš¾: "sÄn zÄi bÄ nÃ n",
    æ²çŒ´è€Œå† : "mÃ¹ hÃ³u Ã©r guÃ n",
    å“©å“©å•¦å•¦: "lÄ« li lÄ lÄ",
    è§ç¼å°±é’»: "jiÃ n fÃ¨ng jiÃ¹ zuÄn",
    å¤¹å±‚çŽ»ç’ƒ: "jiÄ cÃ©ng bÅ li",
    æ€¥å…¬å¥½ä¹‰: "jÃ­ gÅng hÃ o yÃ¬",
    ç§¯å¹´ç´¯æœˆ: "jÄ« niÃ¡n lÄ›i yuÃ¨",
    åˆ’åœ°ä¸ºç‰¢: "huÃ¡ dÃ¬ wÃ©i lÃ¡o",
    æ›´åæ”¹å§“: "gÄ“ng mÃ­ng gÇŽi xÃ¬ng",
    å¥‰ä¸ºåœ­è‡¬: "fÃ¨ng wÃ©i guÄ« niÃ¨",
    å¤šéš¾å…´é‚¦: "duÅ nÃ n xÄ«ng bÄng",
    ä¸ç ´ä¸ç«‹: "bÃº pÃ² bÃº lÃ¬",
    ååœ°è‡ªåˆ’: "zuÃ² dÃ¬ zÃ¬ huÃ¡",
    åä¸é‡å¸­: "zuÃ² bÃ¹ chÃ³ng xÃ­",
    åä¸çª¥å ‚: "zuÃ² bÃ¹ kuÄ« tÃ¡ng",
    ä½œå«è¡£è£³: "zuÃ² jiÃ  yÄ« shang",
    å·¦æžå³æ¢§: "zuÇ’ zhÄ« yÃ²u wÃº",
    å·¦å®œå³æœ‰: "zuÇ’ yÃ­ yÃ²u yÇ’u",
    é’»å¤´è§…ç¼: "zuÄn tÃ³u mÃ¬ fÃ¨ng",
    é’»å¤©æ‰“æ´ž: "zuÄn tiÄn dÇŽ dÃ²ng",
    é’»çš®å‡ºç¾½: "zuÄn pÃ­ chÅ« yÇ”",
    é’»ç«å¾—å†°: "zuÄn huÇ’ dÃ© bÄ«ng",
    é’»æ´žè§…ç¼: "zuÃ n dÃ²ng mÃ¬ fÃ©ng",
    é’»å†°æ±‚ç«: "zuÄn bÄ«ng qiÃº huÇ’",
    å­ä¸ºçˆ¶éš: "zÇ wÃ©i fÃ¹ yÇn",
    æ“¢å‘éš¾æ•°: "zhuÃ³ fÃ  nÃ¡n shÇ”",
    ç€äººå…ˆéž­: "zhuÃ³ rÃ©n xiÄn biÄn",
    æ–«é›•ä¸ºæœ´: "zhuÃ³ diÄo wÃ©i pÇ”",
    é”¥å¤„å›Šä¸­: "zhuÄ« chÇ” nÃ¡ng zhÅng",
    æ¤Žå¿ƒé¥®æ³£: "chuÃ­ xÄ«n yÇn qÃ¬",
    æ¤Žå¿ƒæ³£è¡€: "chuÃ­ xÄ«n qÃ¬ xuÃ¨",
    æ¤Žç‰›é£¨å£«: "chuÃ­ niÃº xiÇŽng shÃ¬",
    æ¤Žç‰›æ­ƒè¡€: "chuÃ­ niÃº shÃ  xuÃ¨",
    æ¤Žç‰›å‘å†¢: "chuÃ­ niÃº fÃ  zhÇ’ng",
    æ¤ŽåŸ‹å± ç‹—: "chuÃ­ mÃ¡i tÃº gÇ’u",
    æ¤ŽåŸ‹ç‹—çªƒ: "chuÃ­ mÃ¡i gÇ’u qiÃ¨",
    å£®å‘å†²å† : "zhuÃ ng fÄ chÅng guÃ n",
    åº„ä¸¥å®ç›¸: "zhuÄng yÃ¡n bÇŽo xiÃ ng",
    è½¬æ„ä¸ºå–œ: "zhuÇŽn chÃ³u wÃ©i xÇ",
    è½¬å—”ä¸ºå–œ: "zhuÇŽn chÄ“n wÃ©i xÇ",
    æ‹½å··å•°è¡—: "zhuÃ i xiÃ ng luÃ³ jiÄ“",
    æ‹½è€™æ‰¶çŠ: "zhuÄi pÃ¡ fÃº lÃ­",
    æ‹½å¸ƒæ‹–éº»: "zhuÃ i bÃ¹ tuÅ mÃ¡",
    ç®¸é•¿ç¢—çŸ­: "zhÃ¹ chÃ¡ng wÇŽn duÇŽn",
    é“¸å‰‘ä¸ºçŠ: "zhÃ¹ jiÃ n wÃ©i lÃ­",
    æ¼æŸšå…¶ç©º: "zhÃ¹ yÃ²u qÃ­ kÅng",
    æ¼æŸšç©ºè™š: "zhÃ¹ yÃ²u kÅng xÅ«",
    åŠ©å¤©ä¸ºè™: "zhÃ¹ tiÄn wÃ©i nÃ¼Ã¨",
    å±žåž£æœ‰è€³: "zhÇ” yuÃ¡n yÇ’u Ä›r",
    å±žæ¯›ç¦»é‡Œ: "zhÇ” mÃ¡o lÃ­ lÇ",
    å±žè¾žæ¯”äº‹: "zhÇ” cÃ­ bÇ shÃ¬",
    é€ç‰©ä¸è¿˜: "zhÃº wÃ¹ bÃ¹ huÃ¡n",
    é“¢é‡å¯¸åº¦: "zhÅ« liÃ¡ng cÃ¹n duÃ³",
    é“¢ä¸¤æ‚‰ç§°: "zhÅ« liÇŽng xÄ« chÃ¨n",
    ä¾å„’è§‚æˆ: "zhÅ« rÃº guÄn xÃ¬",
    æœ±è½“çšç›–: "zhÅ« fÄn zÃ o gÃ i",
    æ˜¼åº¦å¤œæ€: "zhÃ²u duÃ³ yÃ¨ sÄ«",
    è¯ªå¼ ä¸ºå¹»: "zhÅu zhÄng wÃ©i huÃ n",
    é‡æ˜Žç»§ç„°: "chÃ³ng mÃ­ng jÃ¬ yÃ n",
    ä¼—å•„åŒéŸ³: "zhÃ²ng zhuÃ³ tÃ³ng yÄ«n",
    ä¼—æ¯›æ”’è£˜: "zhÃ²ng mÃ¡o cuÃ¡n qiÃº",
    ä¼—å¥½ä¼—æ¶: "zhÃ²ng hÃ o zhÃ²ng wÃ¹",
    æ“¿åŸ´ç´¢æ¶‚: "zhÄi zhÃ­ suÇ’ tÃº",
    ç¨šé½¿å©‘åª : "zhÃ¬ chÇ wÇ’ tuÃ³",
    è‡³å½“ä¸æ˜“: "zhÃ¬ dÃ ng bÃº yÃ¬",
    æŒ‡çš‚ä¸ºç™½: "zhÇ zÃ o wÃ©i bÃ¡i",
    æŒ‡é›ä¸ºç¾¹: "zhÇ yÃ n wÃ©i gÄ“ng",
    æŒ‡æ ‘ä¸ºå§“: "zhÇ shÃ¹ wÃ©i xÃ¬ng",
    æŒ‡å±±è¯´ç£¨: "zhÇ shÄn shuÅ mÃ²",
    æ­¢æˆˆä¸ºæ­¦: "zhÇ gÄ“ wÃ©i wÇ”",
    æžå¹²ç›¸æŒ: "zhÄ« gÃ n xiÄng chÃ­",
    æžå¤§äºŽæœ¬: "zh dÃ  yÃº bÄ›n",
    æ”¯å¾å…¶è¯: "zhÄ« wÃº qÃ­ cÃ­",
    æ­£èº«çŽ‡ä¸‹: "zhÃ¨ng shÄ“n shuÃ i xiÃ ",
    æ­£å† æŽä¸‹: "zhÃ¨ng guÃ n lÇ xiÃ ",
    æ•´å† çº³å±¥: "zhÄ›ng guÄn nÃ  lÇš",
    æ•´èº¬çŽ‡ç‰©: "zhÄ›ng gÅng shuÃ i wÃ¹",
    æ•´é¡¿å¹²å¤: "zhÄ›ng dÃ¹n gÃ n kÅ«n",
    é’ˆå¤´å‰Šé“: "zhÄ“n tÃ³u xuÄ“ tiÄ›",
    è´žæ¾åŠ²æŸ: "zhÄ“n sÅng jÃ¬ng bÇŽi",
    èµ­è¡£å¡žè·¯: "zhÄ› yÄ« sÃ¨ lÃ¹",
    æŠ˜ç®­ä¸ºèª“: "shÃ© jiÃ n wÃ©i shÃ¬",
    æŠ˜è€Œæ—ä¹‹: "zhÃ© Ã©r zÃº zhÄ«",
    æ˜­å¾·å¡žè¿: "zhÄo dÃ© sÃ¨ wÃ©i",
    ç« å¥å°å„’: "zhÄng jÃ¹ xiÇŽo rÃº",
    æ¹›æ©æ±ªæ¿Š: "zhÃ n Ä“n wÄng huÃ¬",
    å é£Žæœ›æ°”: "zhÄn fÄ“ng wÃ ng qÃ¬",
    æ–©å°†æ´æ——: "zhÇŽn jiÃ ng qiÄn qÃ­",
    æ›¾æ¯æŠ•æ¼: "zÄ“ng mÇ” tÃ³u zhÃ¹",
    æ›¾å‚æ€äºº: "zÄ“ng shÄ“n shÄ rÃ©n",
    é€ è°£ä¸­ä¼¤: "zÃ o yÃ¡o zhÃ²ng shÄng",
    æ—©å å‹¿è¯: "zÇŽo zhÄn wÃ¹ yÃ o",
    å‡¿é¾Ÿæ•°ç­–: "zÃ¡o guÄ« shÇ” cÃ¨",
    æ”’ä¸‰èšäº”: "cuÃ¡n sÄn jÃ¹ wÇ”",
    æ”’çœ‰è¹™é¢: "cuÃ¡n mei cÃ¹ Ã©",
    æ”’é›¶åˆæ•´: "cuÃ¡n lÃ­ng hÃ© zhÄ›ng",
    æ”’é”‹èšé•: "cuÃ¡n fÄ“ng jÃ¹ dÃ­",
    è½½ç¬‘è½½è¨€: "zÃ i xiÃ o zÃ i yÃ¡n",
    è½½é…’é—®å­—: "zÃ i jiÇ” wÃ¨n zÃ¬",
    æ®’èº«ä¸æ¤: "yÇ”n shÄ“n bÃº xÃ¹",
    äº‘èˆ’éœžå·: "yÃºn shÅ« xiÃ¡ juÇŽn",
    æœˆä¸­æŠ˜æ¡‚: "yuÃ¨ zhÅng shÃ© guÃ¬",
    æœˆè½å‚æ¨ª: "yuÃ¨ luÃ² shÄ“n hÃ©ng",
    é¬»é©½çªƒä»·: "yÃ¹ nÃº qiÃ¨ jiÃ ",
    é¬»é¸¡ä¸ºå‡¤: "yÃ¹ jÄ« wÃ©i fÃ¨ng",
    é‡éš¾æˆç¥¥: "yÃ¹ nÃ n chÃ©ng xiÃ¡ng",
    éƒéƒç´¯ç´¯: "yÃ¹ yÃ¹ lÄ›i lÄ›i",
    çŽ‰å®æ— å½“: "yÃ¹ zhÄ« wÃº dÃ ng",
    è¯­ç¬‘å–§é˜—: "yÇ” xiÃ o xuÄn tiÃ¡n",
    ä¸Žä¸–æ²‰æµ®: "yÇ” shÃ¬ chÃ©n fÃº",
    ä¸Žæ—¶æ¶ˆæ¯: "yÇ” shÃ­ xiÄo xi",
    é€¾å¢™é’»éš™: "yÃº qiÃ¡ng zuÄn xÃ¬",
    æ¸”å¤ºä¾µç‰Ÿ: "yÃº duÃ³ qÄ«n mÃ³u",
    æ…ç©¿çš®è ¹: "yÃº chuÄn pÃ­ dÃ¹",
    ä½™å‹‡å¯è´¾: "yÃº yÇ’ng kÄ› gÇ”",
    äºˆæ™ºäºˆé›„: "yÃº zhÃ¬ yÃº xiÃ³ng",
    äºˆå–äºˆæ±‚: "yÃº qÇ” yÃº qiÃº",
    äºŽå®¶ä¸ºå›½: "yÃº jiÄ wÃ©i guÃ³",
    æœ‰å€Ÿæ— è¿˜: "yÇ’u jiÃ¨ wÃº huÃ¡n",
    æœ‰åŠ æ— å·²: "yÇ’u jiÄ wÃº yÇ",
    æœ‰å›½éš¾æŠ•: "yÇ’u guÃ³ nÃ¡n tÃ³u",
    æ¸¸å¿…æœ‰æ–¹: "yÃ³u bÃ¬ yÇ’u fÄng",
    æ²¹å¹²ç¯å°½: "yÃ³u gÃ n dÄ“ng jÃ¬n",
    å°¤äº‘æ®¢é›¨: "yÃ³u yÃºn tÃ¬ yÇ”",
    åº¸ä¸­çš¦çš¦: "yÅng zhÅng jiÇŽo jiÇŽo",
    éƒ¢ä¹¦ç‡•è¯´: "yÇng shÅ« yÄn shuÅ",
    è¥è‡æ–é”¦: "yÃ­ng yÃ­ng fÄ“i jÇn",
    é¹°å¿ƒé›çˆª: "yÄ«ng xÄ«n yÃ n zhÇŽo",
    èŽºåŸç‡•å„›: "yÄ«ng yÃ­n yÃ n wÇ”",
    åº”å¤©é¡ºæ—¶: "yÄ«ng tiÄn shÃ¹n shÃ­",
    å°ç´¯ç»¶è‹¥: "yÃ¬n lÃ©i shÃ²u ruÃ²",
    éšå èº«ä½“: "yÇn zhÃ n shÄ“n tÇ",
    é¥®çŠŠä¸Šæµ: "yÃ¬n dÃº shÃ ng liÃº",
    å¼•ç»³åˆ‡å¢¨: "yÇn shÃ©ng qiÄ“ mÃ²",
    é¾ˆé½¿å¼¹èˆŒ: "yÃ­n chÇ dÃ n shÃ©",
    å› ç¼˜ä¸ºå¸‚: "yÄ«n yuÃ¡n wÃ©i shÃ¬",
    å› æ ‘ä¸ºå±‹: "yÄ«n shÃ¹ wÃ©i wÅ«",
    æº¢ç¾Žæº¢æ¶: "yÃ¬ mÄ›i yÃ¬ wÃ¹",
    æŠ‘å¡žç£Šè½: "yÃ¬ sÃ¨ lÄ›i luÃ²",
    å€šé—¾æœ›åˆ‡: "yÇ lÇ˜ wÃ ng qiÄ“",
    ä»¥æ„ä¸ºä¹‹: "yÇ yÃ¬ wÃ©i zhÄ«",
    ä»¥è¨€ä¸ºè®³: "yÇ yÃ¡n wÃ©i huÃ¬",
    ä»¥ç–é—´äº²: "yÇ shÅ« jiÃ n qÄ«n",
    ä»¥æ°´æµŽæ°´: "yÇ shuÇ jÇ shuÇ",
    ä»¥ä¹¦ä¸ºå¾¡: "yÇ shÅ« wÃ©i yÃ¹",
    ä»¥å®ˆä¸ºæ”»: "yÇ shÇ’u wÃ©i gÅng",
    ä»¥å‡é‡çŸ³: "yÇ shÄ“ng liÃ¡ng dÃ n",
    ä»¥æ…Žä¸ºé”®: "yÇ shÃ¨n wÃ©i jiÃ n",
    ä»¥ç­Œä¸ºé±¼: "yÇ quÃ¡n wÃ©i yÃº",
    ä»¥åˆ©ç´¯å½¢: "yÇ lÃ¬ lÄ›i xÃ­ng",
    ä»¥æ¯ä¸ºç½š: "yÇ huÇ wÃ©i fÃ¡",
    ä»¥é»‘ä¸ºç™½: "yÇ hÄ“i wÃ©i bÃ¡i",
    ä»¥è§„ä¸ºç‘±: "yÇ guÄ« wÃ©i tiÃ n",
    ä»¥å¤ä¸ºé‰´: "yÇ gÇ” wÃ©i jiÃ n",
    ä»¥å®«ç¬‘è§’: "yÇ gÅng xiÃ o juÃ©",
    ä»¥æ³•ä¸ºæ•™: "yÇ fÇŽ wÃ©i jiÃ o",
    ä»¥å¤§æ¶ç»†: "yÇ dÃ  wÃ¹ xÃ¬",
    é—ä¸–å¿˜ç´¯: "yÃ­ shÃ¬ wÃ ng lÄ›i",
    é—å¯è½½æ€€: "yÃ­ qÇn zÃ i huÃ¡i",
    ç§»çš„å°±ç®­: "yÃ­ dÃ¬ jiÃ¹ jiÃ n",
    ä¾å¤´ç¼•å½“: "yÄ« tÃ³u lÇš dÃ ng",
    è¡£ç§Ÿé£Ÿç¨Ž: "yÃ¬ zÅ« shÃ­ shuÃ¬",
    è¡£è½»ä¹˜è‚¥: "yÃ¬ qÄ«ng chÃ©ng fÃ©i",
    è¡£è£³ä¹‹ä¼š: "yÄ« shang zhÄ« huÃ¬",
    è¡£å•é£Ÿè–„: "yÄ« dÄn shÃ­ bÃ³",
    ä¸€è¿˜ä¸€æŠ¥: "yÃ¬ huÃ¡n yÃ­ bÃ o",
    å¶å…¬å¥½é¾™: "yÃ¨ gÅng hÃ o lÃ³ng",
    é‡Žè°ƒæ— è…”: "yÄ› diÃ o wÃº qiÄng",
    ç‘¶æ± å¥³ä½¿: "yÃ¡o chÃ­ nÇš shÇ",
    å¹ºéº½å°ä¸‘: "yÄo mÃ³ xiÇŽo chÇ’u",
    å…»ç²¾ç•œé”: "yÇŽng jÄ«ng xÃ¹ ruÃ¬",
    å¬é¦–ä¿¡çœ‰: "Ã¡ng shÇ’u shÄ“n mÃ©i",
    æ´‹æ´‹çºšçºš: "yÃ¡ng yÃ¡ng sÇŽ sÇŽ",
    ç¾Šç¾”ç¾Žé…’: "yÃ¡ng gÄo mÄ›i jiÇ”",
    æ‰¬é£Žæ‰¢é›…: "yÃ¡ng fÄ“ng jiÃ© yÇŽ",
    ç‡•æ˜­å¸‚éª: "yÄn zhÄo shÃ¬ jÃ¹n",
    ç‡•æ˜­å¥½é©¬: "yÄn zhÄo hÇŽo mÇŽ",
    ç‡•çŸ³å¦„ç: "yÄn shÃ­ wÃ ng zhÄ“n",
    ç‡•éªåƒé‡‘: "yÄn jÃ¹n qiÄn jÄ«n",
    ç‡•é‡‘å‹Ÿç§€: "yÄn jÄ«n mÃ¹ xiÃ¹",
    ç‡•é©¾è¶Šæ¯‚: "yÄn jiÃ  yuÃ¨ gÇ”",
    ç‡•æ­Œèµµèˆž: "yÄn gÄ“ zhÃ o wÇ”",
    ç‡•å²±ä¹‹çŸ³: "yÄn dÃ i zhÄ« shÃ­",
    ç‡•å¤„å±å·¢: "yÃ n chÇ” wÄ“i chÃ¡o",
    æŽžè—»é£žå£°: "shÃ n zÇŽo fÄ“i shÄ“ng",
    åƒé©ä¸ºè½©: "yÇŽn gÃ© wÃ©i xuÄn",
    å¦èš©å¥½æ¶: "yÃ¡n chÄ« hÇŽo Ã¨",
    åŽ‹è‰¯ä¸ºè´±: "yÄ liÃ¡ng wÃ©i jiÃ n",
    æ€è¡Œå¤ºå¸‚: "chÄn hÃ¡ng duÃ³ shÃ¬",
    æ³£æ•°è¡Œä¸‹: "qÃ¬ shÃ¹ hÃ¡ng xiÃ ",
    å½“è¡Œå‡ºè‰²: "dÄng hÃ¡ng chÅ« sÃ¨",
    ç§€å‡ºç­è¡Œ: "xiÃ¹ chÅ« bÄn hÃ¡ng",
    å„¿å¥³æˆè¡Œ: "Ã©r nÇš chÃ©ng hÃ¡ng",
    å¤§è¡Œå¤§å¸‚: "dÃ  hÃ¡ng dÃ  shÃ¬",
    å¯»è¡Œæ•°å¢¨: "xÃºn hÃ¡ng shÇ” mÃ²",
    åŸ™ç¯ªç›¸å’Œ: "xÅ«n chÃ­ xiÄng hÃ¨",
    è¡€å€ºç´¯ç´¯: "xuÃ¨ zhÃ i lÄ›i lÄ›i",
    ç‚«çŽ‰è´¾çŸ³: "xuÃ n yÃ¹ gÇ” shÃ­",
    ç‚«çŸ³ä¸ºçŽ‰: "xuÃ n shÃ­ wÃ©i yÃ¹",
    æ‚¬çŸ³ç¨‹ä¹¦: "xuÃ¡n dÃ n chÃ©ng shÅ«",
    æ‚¬ç‹Ÿç´ é£¡: "xuÃ¡n huÃ¡n sÃ¹ cÄn",
    æ‚¬é¾Ÿç³»é±¼: "xuÃ¡n guÄ« xÃ¬ yÃº",
    æŽæ‹³æ‹è¢–: "xuÄn quÃ¡n luÅ xiÃ¹",
    è½©é¹¤å† çŒ´: "xuÄn hÃ¨ guÃ n hÃ³u",
    ç•œå¦»å…»å­: "xÃ¹ qÄ« yÇŽng zÇ",
    ç¾žäººç­”ç­”: "xiÅ« rÃ©n dÄ dÄ",
    ä¿®é³žå…»çˆª: "xiÅ« lÃ­n yÇŽng zhÇŽo",
    ç†Šæ®è™Žè·±: "xiÃ³ng jÃ¹ hÇ” zhÃ¬",
    å…„æ­»å¼ŸåŠ: "xiÅng sÇ dÃ¬ jÃ­",
    è…¥é—»åœ¨ä¸Š: "xÄ«ng wÃ©n zÃ i shÃ ng",
    å…´æ–‡åŒ½æ­¦: "xÄ«ng wÃ©n yÇŽn wÇ”",
    å…´è§‚ç¾¤æ€¨: "xÃ¬ng guÄn qÃºn yuÃ n",
    å…´é«˜å½©çƒˆ: "xÃ¬ng gÄo cÇŽi liÃ¨",
    å¿ƒæ‰‹ç›¸åº”: "xÄ«n shÇ’u xiÄng yÃ¬ng",
    å¿ƒå£ç›¸åº”: "xÄ«n kÇ’u xiÄng yÄ«ng",
    æŒŸåŠ¿å¼„æƒ: "xiÃ© shÃ¬ nÃ²ng quÃ¡n",
    èƒè‚©ç´¯è¶³: "xiÃ© jiÄn lÄ›i zÃº",
    æ ¡çŸ­é‡é•¿: "jiÃ o duÇŽn liÃ¡ng chÃ¡ng",
    å°çœ¼è–„çš®: "xiÇŽo yÇŽn bÃ³ pÃ­",
    ç¡äº‘å¼¹é›¨: "xiÄo yÃºn dÃ n yÇ”",
    é¸®é¸£é¼ æš´: "xiÄo mÃ­ng shÇ” bÃ o",
    å‰Šæ ªæŽ˜æ ¹: "xuÄ“ zhÅ« juÃ© gÄ“n",
    å‰Šé“æ— å£°: "xuÄ“ tiÄ› wÃº shÄ“ng",
    å‰ŠèŒä¸ºæ°‘: "xuÄ“ zhÃ­ wÃ©i mÃ­n",
    å‰Šæœ¨ä¸ºå: "xuÄ“ mÃ¹ wÃ©i lÃ¬",
    æƒ³æœ›é£Žè¤±: "xiÇŽng wÃ ng fÄ“ng huÃ¡i",
    é¦™åŸ¹çŽ‰ç¢: "xiang pei yu zhuÃ³",
    ç›¸é¼ æœ‰çš®: "xiÃ ng shÇ” yÇ’u pÃ­",
    ç›¸æ—¶è€ŒåŠ¨: "xiÃ ng shÃ­ Ã©r dÃ²ng",
    ç›¸åˆ‡ç›¸ç£‹: "xiÄng qiÄ“ xiÄng cuÅ",
    ç›¸å¥³é…å¤«: "xiÃ ng nÇš pÃ¨i fÅ«",
    ç›¸é—¨æœ‰ç›¸: "xiÃ ng mÃ©n yÇ’u xiÃ ng",
    æŒ¦ç« æ’¦å¥: "xiÃ¡n zhÄng chÄ› jÃ¹",
    å…ˆæˆ‘ç€éž­: "xiÄn wÇ’ zhuÃ³ biÄn",
    ä¹ ç„‰ä¸å¯Ÿ: "xÃ­ yÄn bÃ¹ chÃ¡",
    æ­™æ¼†é˜¿èƒ¶: "shÃ¨ qÄ« Ä“ jiÄo",
    æ™°æ¯›è¾¨å‘: "xÄ« mÃ¡o biÃ n fÃ ",
    æ‚‰ç´¢è–„èµ‹: "xÄ« suÇ’ bÃ³ fÃ¹",
    é›¾é³žäº‘çˆª: "wÃ¹ lÃ­n yÃºn zhÇŽo",
    ç‰©ç¨€ä¸ºè´µ: "wÃ¹ xÄ« wÃ©i guÃ¬",
    ç¢”ç †æ··çŽ‰: "wÇ” fÅ« hÃ¹n yÃ¹",
    æ­¦æ–­ä¸“æ¨ª: "wÇ” duÃ n zhuÄn hÃ©ng",
    äº”çŸ³å…­é¹¢: "wÇ” shÃ­ liÃ¹ yÃ¬",
    äº”è‰²ç›¸å®£: "wÇ” sÃ¨ xiÄng xuÄn",
    äº”ä¾¯ä¸ƒè´µ: "wÇ” hÃ³u qÄ« guÃ¬",
    äº”ä¾¯èœ¡çƒ›: "wÇ” hÃ²u lÃ  zhÃº",
    äº”ç¾–å¤§å¤«: "wÇ” gÇ” dÃ  fÅ«",
    å¾è‡ªæœ‰å¤„: "wÃº zÃ¬ yÇ’u chÇ”",
    æ— ä¸‹ç®¸å¤„: "wÃº xiÃ  zhÃ¹ chÇ”",
    æ— ä¼¤æ— è‡­: "wÃº shÄng wÃº xiÃ¹",
    æ— èƒ½ä¸ºå½¹: "wÃº nÃ©ng wÃ©i yÃ¬",
    æ— å¯‡æš´æ­»: "wÃº kÃ²u bÃ o sÇ",
    æ— å­”ä¸é’»: "wÃº kÇ’ng bÃº zuÃ n",
    æ— é—´å¯ä¹˜: "wÃº jiÄn kÄ› chÃ©ng",
    æ— é—´å†¬å¤: "wÃº jiÄn dÅng xiÃ ",
    æ— æ¶ä¸ä¸º: "wÃº Ã¨ bÃ¹ wÃ©i",
    æ— åŠ¨ä¸ºå¤§: "wÃº dÃ²ng wÃ©i dÃ ",
    è¯¬è‰¯ä¸ºç›—: "wÅ« liÃ¡ng wÃ©i dÃ o",
    æ¡æ‹³é€çˆª: "wÃ² quÃ¡n tÃ²u zhÇŽo",
    æ–‡æ­¦å·®äº‹: "wÃ©n wÇ” chÄi shÃ¬",
    å§”å§”ä½—ä½—: "wÄ“i wÄ“i tuÃ³ tuÃ³",
    æƒŸæ—¥ä¸ºå²: "wÃ©i rÃ¬ wÃ©i suÃ¬",
    å¸·è–„ä¸ä¿®: "wÃ©i bÃ³ bÃ¹ xiÅ«",
    ä¸ºå–„æœ€ä¹: "wÃ©i shÃ n zuÃ¬ lÃ¨",
    ä¸ºå±±æ­¢ç¯‘: "wÃ©i shÄn zhÇ kuÃ¬",
    ä¸ºä»ä¸å¯Œ: "wÃ©i rÃ©n bÃº fÃ¹",
    ä¸ºè£˜ä¸ºç®•: "wÃ©i qiÃº wÃ©i jÄ«",
    ä¸ºæ°‘çˆ¶æ¯: "wÃ©i mÃ­n fÃ¹ mÇ”",
    ä¸ºè™ºå¼—æ‘§: "wÃ©i huÇ fÃº cuÄ«",
    ä¸ºå¥½æˆæ­‰: "wÃ©i hÇŽo chÃ©ng qiÃ n",
    ä¸ºé¬¼ä¸ºèœ®: "wÃ©i guÇ wÃ©i yÃ¹",
    æœ›é£Žå“åº”: "wÃ ng fÄ“ng xiÇŽng yÄ«ng",
    æœ›å°˜åƒ„å£°: "wÃ ng chÃ©n piÃ o shÄ“ng",
    å¾€æ¸šè¿˜æ±€: "wÇŽng zhÇ” huÃ¡n tÄ«ng",
    çŽ‹è´¡å¼¹å† : "wÃ¡ng gÃ²ng dÃ n guÃ n",
    äº¡å›½å¤§å¤«: "wÃ¡ng guÃ³ dÃ  fÅ«",
    ä¸‡è´¯å®¶ç§: "wÃ n guÃ n jiÄ sÄ«",
    æ™šé£Ÿå½“è‚‰: "wÇŽn shÃ­ dÃ ng rÃ²u",
    æ™šèŠ‚ä¸ä¿: "wÇŽn jiÃ© bÃ¹ bÇŽo",
    çŽ©å²æ„’æ—¶: "wÃ¡n suÃ¬ kÃ i shÃ­",
    è›™èŸ†èƒœè´Ÿ: "wÄ mÃ¡ shÃ¨ng fÃ¹",
    åžè¨€å’½ç†: "tÅ«n yÃ¡n yÃ n lÇ",
    é¢“åž£æ–­å ‘: "tuÃ­ yuÃ¡n duÃ n qiÃ n",
    æŽ¨å¹²å°±æ¹¿: "tuÄ« gÃ n jiÃ¹ shÄ«",
    å‰¸ç¹å†³å‰§: "tuÃ¡n fÃ¡n juÃ© jÃ¹",
    å›¢å¤´èšé¢: "tuÃ¡n tÃ³u jÃ¹ miÃ n",
    å…”ä¸ç‡•éº¦: "tÃ¹ sÄ« yÃ n mÃ i",
    å…”å¤´éºžè„‘: "tÃ¹ tÃ³u zhÄng nÇŽo",
    å…”è‘µç‡•éº¦: "tÃ¹ kuÃ­ yÃ n mÃ i",
    åå“ºæ¡å‘: "tÇ” bÇ” wÃ² fÃ ",
    æŠ•ä¼ è€ŒåŽ»: "tÃ³u zhuÃ n Ã©r qÃ¹",
    å¤´æ²¡æ¯æ¡ˆ: "tÃ³u mÃ² bÄ“i Ã n",
    å¤´æ˜è„‘é—·: "tÃ³u hÅ«n nÇŽo mÃ¨n",
    å¤´ä¼šç®•æ•›: "tÃ³u kuÃ i jÄ« liÇŽn",
    å¤´å‡ºå¤´æ²¡: "tÃ³u chÅ« tÃ³u mÃ²",
    ç—›è‡ªåˆ›è‰¾: "tÃ²ng zÃ¬ chuÄng yÃ¬",
    åŒæ¶ç›¸åŠ©: "tÃ³ng wÃ¹ xiÄng zhÃ¹",
    åŒæ¶ç›¸æ¤: "tÃ³ng wÃ¹ xiÄng xÃ¹",
    ç—Œç˜åœ¨æŠ±: "tÅng guÄn zÃ i bÃ o",
    é€šæ–‡è°ƒæ­¦: "tÅng wÃ©n diÃ o wÇ”",
    åœç•™é•¿æ™º: "tÃ­ng liÃº zhÇŽng zhÃ¬",
    é“æ ‘å¼€åŽ: "tiÄ› shÃ¹ kÄi huÄ",
    æ¡è´¯éƒ¨åˆ†: "tiÃ¡o guÃ n bÃ¹ fÄ“n",
    æŒ‘ç‰™æ–™å”‡: "tiÇŽo yÃ¡ liÃ o chÃºn",
    æŒ‘ä¹ˆæŒ‘å…­: "tiÄo yÄo tiÄo liÃ¹",
    æŒ‘å”‡æ–™å˜´: "tiÇŽo chÃºn liÃ o zuÇ",
    æ¬ä¸ä¸ºæ„: "tiÃ¡n bÃ¹ wÃ©i yÃ¬",
    æ¬ä¸ä¸ºæ€ª: "tiÃ¡n bÃ¹ wÃ©i guÃ i",
    å¤©ä¸‹ä¸ºç¬¼: "tiÄn xiÃ  wÃ©i lÃ³ng",
    å¤©å°è·¯è¿·: "tiÄn tÃ¡i lÃ¹ mÃ­",
    å¤©å¹´ä¸é‚: "tiÄn niÃ¡n bÃº suÃ¬",
    æŽ¢å›Šèƒ ç®§: "tÃ n nÃ¡ng qÅ« qiÃ¨",
    è°­è¨€å¾®ä¸­: "tÃ¡n yÃ¡n wÄ“i zhÃ²ng",
    è°ˆè¨€å¾®ä¸­: "tÃ¡n yÃ¡n wÄ“i zhÃ²ng",
    ç‹§ç©…åŠç±³: "shÃ¬ kÄng jÃ­ mÇ",
    éšç‰©åº”æœº: "suÃ­ wÃ¹ yÄ«ng jÄ«",
    æœå²©é‡‡å¹²: "sÅu yÃ¡n cÇŽi gÃ n",
    å®‹æ–¤é²å‰Š: "sÃ²ng jÄ«n lÇ” xuÄ“",
    æ¾ç­ ä¹‹èŠ‚: "sÅng yÃºn zhÄ« jiÃ©",
    å››äº­å…«å½“: "sÃ¬ tÃ­ng bÄ dÃ ng",
    å››é©¬æ”’è¹„: "sÃ¬ mÇŽ cuÃ¡n tÃ­",
    å››ä¸æ‹—å…­: "sÃ¬ bÃº niÃ¹ liÃ¹",
    æ€æ‰€é€ä¹‹: "sÄ« suÇ’ zhÃº zhÄ«",
    ä¸æ©å‘æ€¨: "sÄ« Ä“n fÃ  yuÃ n",
    ç¡•æœ›å®¿å¾·: "shuÃ² wÃ ng xiÇ” dÃ©",
    é“„å¤åˆ‡ä»Š: "shuÃ² gÇ” qiÄ“ jÄ«n",
    é¡ºé£Žè€Œå‘¼: "shÃ¹n fÄ“ng Ã©r hÅ«",
    é¡ºé£Žå¹ç«: "shÃ¹n fÄ“ng chuÄ« huÇ’",
    æ°´ä¸­è‘—ç›: "shuÇ zhÅng zhuÃ³ yÃ¡n",
    åŒæŸ‘æ–—é…’: "shuÄng gÄn dÇ’u jiÇ”",
    æ•°ç±³è€Œç‚Š: "shÇ” mÇ Ã©r chuÄ«",
    æ•°ç±³é‡æŸ´: "shÇ” mÇ liÃ¡ng chÃ¡i",
    æ•°ç†é€»è¾‘: "shÃ¹ lÇ luÃ³ ji",
    æ•°é»‘è®ºé»„: "shÇ” hÄ“i lÃ¹n huÃ¡ng",
    æ•°ç™½è®ºé»„: "shÇ” bÃ¡i lÃ¹n huÃ¡ng",
    æŸç¼Šè¿˜å¦‡: "shÃ¹ yÅ«n huÃ¡n fÃ¹",
    æŸè’²ä¸ºè„¯: "shÃ¹ pÃº wÃ©i pÃº",
    æŸæ¤½ä¸ºæŸ±: "shÃ¹ chuÃ¡n wÃ©i zhÃ¹",
    ä¹¦ç¼ºæœ‰é—´: "shÅ« quÄ“ yÇ’u jiÃ n",
    æ‰‹è¶³é‡èŒ§: "shÇ’u zÃº chÃ³ng jiÇŽn",
    æ‰‹è¶³å¼‚å¤„: "shÇ’u zÃº yÃ¬ chÇ”",
    æ‰‹è„šå¹²å‡€: "shÇ’u jiÇŽo gÃ n jÃ¬ng",
    æ‰‹ä¸åº”å¿ƒ: "shÇ’u bÃ¹ yÄ«ng xÄ«n",
    èž«æ‰‹è§£è…•: "shÃ¬ shÇ’u jiÄ› wÃ n",
    é‡ŠçŸ¥é—å½¢: "shÃ¬ zhÄ« yÃ­ xÃ­ng",
    é€‚æ—¶åº”åŠ¡: "shÃ¬ shÃ­ yÄ«ng wÃ¹",
    é€‚æƒ…çŽ‡æ„: "shÃ¬ qÃ­ng shuÃ i yÃ¬",
    é€‚å½“å…¶å†²: "shÃ¬ dÄng qÃ­ chÅng",
    è§†ä¸ºçŸ¥å·±: "shÃ¬ wÃ©i zhÄ« jÇ",
    ä½¿ç¾Šå°†ç‹¼: "shÇ yÃ¡ng jiÃ ng lÃ¡ng",
    é£Ÿä¸ºæ°‘å¤©: "shÃ­ wÃ©i mÃ­n tiÄn",
    æ‹¾æŽ‡æ— é—: "shÃ­ duÅ wÃº yÃ­",
    å®žä¸Žæœ‰åŠ›: "shÃ­ yÃ¹ yÇ’u lÃ¬",
    çŸ³è‹±çŽ»ç’ƒ: "shÃ­ yÄ«ng bÅ li",
    çŸ³å®¤é‡‘åŒ®: "shÃ­ shÃ¬ jÄ«n guÃ¬",
    ä»€è¢­çè—: "shÃ­ xÃ­ zhÄ“n cÃ¡ng",
    ä»€ä¼ä¸œè¥¿: "shÃ­ wÇ” dÅng xÄ«",
    ä»€å›´ä¼æ”»: "shÃ­ wÃ©i wÇ” gÅng",
    åé­”ä¹éš¾: "shÃ­ mÃ³ jiÇ” nÃ n",
    è¯—ä¹¦å‘å†¢: "shÄ« shÅ« fÃ  zhÇ’ng",
    è™±å¤„è£ˆä¸­: "shÄ« chÇ” kÅ«n zhÅng",
    å¸ˆç›´ä¸ºå£®: "shÄ« zhÃ­ wÃ©i zhuÃ ng",
    å°¸å±…é¾™è§: "shÄ« jÅ« lÃ³ng xiÃ n",
    åœ£ç»è´¤ä¼ : "shÃ¨ng jÄ«ng xiÃ¡n zhuÃ n",
    åœ£å›è´¤ç›¸: "shÃ¨ng jÅ«n xiÃ¡n xiÃ ng",
    ç”Ÿæ‹–æ­»æ‹½: "shÄ“ng tuÅ sÇ zhuÃ i",
    å®¡å·±åº¦äºº: "shÄ›n jÇ duÃ³ rÃ©n",
    ç¥žæ­¦æŒ‚å† : "shÃ©n wÇ” guÃ  guÃ n",
    ç¥žé¾™å¤±åŸ¶: "shÃ©n lÃ³ng shÄ« shÃ¬",
    æ·±æ–‡æ›²æŠ˜: "shÄ“n wÃ©n qÇ” shÃ©",
    æ·±åŽ‰æµ…æ­: "shÄ“n lÃ¬ qiÇŽn qÃ¬",
    æ·±è°·ä¸ºé™µ: "shÄ“n gÇ” wÃ©i lÃ­ng",
    æ·±æ¶ç—›ç–¾: "shÄ“n wÃ¹ tÃ²ng jÃ­",
    æ·±ä»‡å®¿æ€¨: "shÄ“n chÃ³u xiÇ” yuÃ n",
    èˆå·±ä¸ºå…¬: "shÄ› jÇ wÃ¨i gÅng",
    èˆçŸ­å–é•¿: "shÄ› duÇŽn qÇ” chÃ¡ng",
    èˆç­–è¿½ç¾Š: "shÄ› cÃ¨ zhuÄ« yÃ¡ng",
    è›‡èŽä¸ºå¿ƒ: "shÃ© xiÄ“ wÃ©i xÄ«n",
    å°‘æˆè‹¥æ€§: "shÃ o chÃ©ng ruÃ² xÃ¬ng",
    ä¸Šå½“å­¦ä¹–: "shÃ ng dÃ ng xuÃ© guÄi",
    èµä¸å½“åŠŸ: "shÇŽng bÃ¹ dÄng gÅng",
    å–„è‡ªä¸ºè°‹: "shÃ n zÃ¬ wÃ©i mÃ³u",
    å–„ä¸ºè¯´è¾ž: "shÃ n wÃ©i shuÅ cÃ­",
    å–„å–„æ¶æ¶: "shÃ n shÃ n wÃ¹ Ã¨",
    å–„è´¢éš¾èˆ: "shÃ n cÃ¡i nÃ¡n shÄ›",
    è‹«çœ¼é“ºçœ‰: "shÄn yÇŽn pÅ« mÃ©i",
    è®ªç‰™é—²å—‘: "shÃ n yÃ¡ xiÃ¡n kÄ“",
    å±±é˜´ä¹˜å…´: "shÄn yÄ«n chÃ©ng xÄ«ng",
    å±±æ®½é‡Žæ¹‹: "shÄn yÃ¡o yÄ› wÃ©i",
    å±±æºœç©¿çŸ³: "shÄn liÃ¹ chuÄn shÃ­",
    å±±èŠ‚è—»æ£: "shÄn jiÃ© zÇŽo zhuÅ",
    æ€é¸¡ä¸ºé»: "shÄ jÄ« wÃ©i shÇ”",
    è‰²åŽ‰èƒ†è–„: "sÃ¨ lÃ¬ dÇŽn bÃ³",
    æ¡‘è«æœªç§»: "sÄng yÄ«n wÃ¨i yÃ­",
    æ¡‘è«ä¸å¾™: "sÄng yÄ«n bÃ¹ xÇ",
    æ¡‘åœŸç»¸ç¼ª: "sÄng tÇ” chÃ³u miÃ¹",
    æ¡‘æˆ·æ£¬æž¢: "sÄng hÃ¹ juÃ n shÅ«",
    ä¸‰æˆ˜ä¸‰åŒ—: "sÄn zhÃ n sÄn bÄ›i",
    ä¸‰ç“¦ä¸¤èˆ: "sÄn wÇŽ liÇŽng shÄ›",
    ä¸‰äººä¸ºä¼—: "sÄn rÃ©n wÃ¨i zhÃ²ng",
    ä¸‰å·®ä¸¤é”™: "sÄn chÄ liÇŽng cuÃ²",
    å¡žäº•ç„šèˆ: "sÄi jÇng fÃ©n shÄ›",
    æ´’å¿ƒæ›´å§‹: "sÇŽ xÄ«n gÃ¨ng shÇ",
    æ´’æ‰«åº”å¯¹: "sÇŽ sÇŽo yÃ¬ng duÃ¬",
    è½¯çº¢é¦™åœŸ: "ruÇŽn hÃ³ng xiÄng tÇ”",
    å…¥å¾å½€ä¸­: "rÃ¹ wÃº gÃ²u zhÅng",
    å…¥é“ä¸»ç°¿: "rÃ¹ tiÄ› zhÇ” bÃ¹",
    å…¥ç†åˆ‡æƒ…: "rÃ¹ lÇ qiÄ“ qÃ­ng",
    æ±æˆäººè€¶: "rÇ” chÃ©ng rÃ©n yÃ©",
    å¦‚æ°´æŠ•çŸ³: "rÃº shuÇ tÃ³u shÃ­",
    å¦‚åˆ‡å¦‚ç£‹: "rÃº qiÄ“ rÃº cuÅ",
    å¦‚ç™»æ˜¥å°: "rÃº dÄ“ng chÅ«n tÃ¡i",
    è‚‰è–„éª¨å¹¶: "rÃ²u bÃ³ gÇ” bÃ¬ng",
    æŸ”æƒ…ç»°æ€: "rÃ³u qÃ­ng chuÃ² tÃ i",
    æˆŽé©¬åŠ»å‹·: "rÃ³ng mÇŽ kuÄng rÃ¡ng",
    æ—¥ä¸­ä¸ºå¸‚: "rÃ¬ zhÅng wÃ©i shÃ¬",
    æ—¥æœˆå‚è¾°: "rÃ¬ yuÃ¨ shÄ“n chÃ©n",
    æ—¥çœæœˆä¿®: "rÃ¬ xÇng yuÃ¨ xiÅ«",
    æ—¥å‰Šæœˆå‰²: "rÃ¬ xuÄ“ yuÃ¨ gÄ“",
    æ—¥çœæœˆè¯•: "rÃ¬ xÇng yuÃ¨ shÃ¬",
    ä»»è¾¾ä¸æ‹˜: "rÃ¨n dÃ¡ bÃ¹ jÅ«",
    äººè¨€è—‰è—‰: "rÃ©n yÃ¡n jÃ­ jÃ­",
    äººæ¨¡ç‹—æ ·: "rÃ©n mÃº gÇ’u yÃ ng",
    äººèŽ«äºˆæ¯’: "rÃ©n mÃ² yÃº dÃº",
    çƒ­ç†¬ç¿»é¥¼: "rÃ¨ Ã¡o fÄn bÇng",
    åœˆç‰¢å…»ç‰©: "juÃ n lÃ¡o yÇŽng wÃ¹",
    å–äºˆæœ‰èŠ‚: "qÇ” yÇ” yÇ’u jiÃ©",
    è¯Žè¦æ¡¡è…˜: "qÅ« yÄo rÃ¡o guÃ³",
    ç©·å½¢å°½ç›¸: "qiÃ³ng xÃ­ng jÃ¬n xiÃ ng",
    æƒ…å‡„æ„åˆ‡: "qÃ­ng qÄ« yÃ¬ qiÃ¨",
    æƒ…è§åŠ¿å±ˆ: "qÃ­ng xiÃ n shÃ¬ qÅ«",
    æƒ…è§ä¹Žè¾ž: "qÃ­ng xiÃ n hÅ« cÃ­",
    æ¸…éƒ½ç»›é˜™: "qÄ«ng dÅu jiÃ ng quÃ¨",
    å€¾è‚ å€’è‚š: "qÄ«ng chÃ¡ng dÃ o dÇ”",
    é’ç´«è¢«ä½“: "qÄ«ng zÇ pÄ« tÇ",
    é’æž—é»‘å¡ž: "qÄ«ng lÃ­n hÄ“i sÃ i",
    èž“é¦–è›¾çœ‰: "qÃ­n shÇ’u Ã© mÃ©i",
    ç´ç‘Ÿä¹‹å¥½: "qÃ­n sÃ¨ zhÄ« hÃ o",
    ä¸”ä½ä¸ºä½³: "qiÄ› zhÃ¹ wÃ©i jiÄ",
    åˆ‡æ ‘å€’æ ¹: "qiÄ“ shÃ¹ dÇŽo gÄ“n",
    åˆ‡ç†é¤å¿ƒ: "qiÄ“ lÇ yÃ n xÄ«n",
    åˆ‡è¿‘çš„å½“: "qiÄ“ jÃ¬n de dÄng",
    ç¿˜è¶³å¼•é¢†: "qiÃ¡o zÃº yÇn lÇng",
    å·§å‘å¥‡ä¸­: "qiÇŽo fÄ qÃ­ zhÃ²ng",
    å¼ºå˜´æ‹—èˆŒ: "jiÃ ng zuÇ niÃ¹ shÃ©",
    å¼ºç›´è‡ªé‚: "qiÃ¡ng zhÃ­ zÃ¬ suÃ­",
    å¼ºæ­»å¼ºæ´»: "qiÇŽng sÇ qiÇŽng huÃ³",
    å¼ºé£Ÿè‡ªçˆ±: "qiÇŽng shÃ­ zÃ¬ Ã i",
    å¼ºé£Ÿé¡è§’: "qiÇŽng shÃ­ mÃ­ jiÇŽo",
    å¼ºå¼“åŠ²å¼©: "qiÃ¡ng gÅng jÃ¬ng nÇ”",
    å¼ºè’ä¸èˆ: "qiÇŽng guÅ bÃ¹ shÄ›",
    å¼ºå‡«å˜é¹¤: "qiÃ¡ng fÃº biÃ n hÃ¨",
    å¼ºè€ŒåŽå¯: "qiÇŽng Ã©r hÃ²u kÄ›",
    å¼ºå¾—æ˜“è´«: "qiÇŽng dÃ© yÃ¬ pÃ­n",
    é£å…´é™¶æƒ…: "qiÇŽn xÃ¬ng tÃ¡o qÃ­ng",
    ç‰µç¾Šæ‹…é…’: "qiÄn yÃ¡ng dÄn jiÇ”",
    åƒäº†ç™¾å½“: "qiÄn liÇŽo bÇŽi dÃ ng",
    æ³£ä¸‹å¦‚é›¨: "qÃ¬ xiÃ  rÃº yÇ”",
    èµ·åƒä¸ºç«–: "qÇ yÇŽn wÃ©i shÃ¹",
    å²‚å¼Ÿå›å­: "kÇŽi tÃ¬ jÅ«n zÇ",
    ç¶¦æºªåˆ©è·‚: "qÃ­ xÄ« lÃ¬ qÃ­",
    æ£‹è¾“å…ˆè‘—: "qÃ­ shÅ« xiÄn zhuÃ³",
    é½çŽ‹èˆç‰›: "qÃ­ wÃ¡ng shÄ› niÃº",
    æ¬ºå¤©è¯³åœ°: "qÄ« tiÄn kuÃ¡ng dÃ¬",
    æ™®å¤©çŽ‡åœŸ: "pÇ” tiÄn shuÃ i tÇ”",
    é“ºèƒ¸çº³åœ°: "pÅ« xiÅng nÃ  dÃ¬",
    é“ºé”¦åˆ—ç»£: "pÅ« jÇn liÃ¨ xiÃ¹",
    ç ´å®¶ä¸ºå›½: "pÃ² jiÄ wÃ¨i guÃ³",
    ç ´è§šä¸ºåœœ: "pÃ² gÅ« wÃ©i yuÃ¡n",
    èé£˜è“¬è½¬: "pÃ­ng piÄo pÃ©ng zhuÃ n",
    å¸¡å¤©æžåœ°: "pÃ­ng tiÄn jÃ­ dÃ¬",
    å±å£°æ¯æ°”: "bÇng shÄ“ng xÄ« qÃ¬",
    å‡­å‡ æ®æ–: "pÃ­ng jÄ« jÃ¹ zhÃ ng",
    è´«å˜´è–„èˆŒ: "pÃ­n zuÇ bÃ³ shÃ©",
    ç‰‡è¯­åªè¾ž: "piÃ n yÇ” zhÄ« cÃ­",
    æŠ«å‘æ–‡èº«: "pÄ« fÃ  wÃ©n shÄ“n",
    çƒ¹é¾™ç‚®å‡¤: "pÄ“ng lÃ³ng pÃ¡o fÃ¨ng",
    ç‚°é³–è„é²¤: "fÇ’u biÄ“ kuÃ i lÇ",
    åºžçœ‰çš“å‘: "pÃ¡ng mÃ©i hÃ o fÃ ",
    æ”€èŠ±æŠ˜æŸ³: "pÄn huÄ zhÃ© liÇ”",
    æ”€èŸ¾æŠ˜æ¡‚: "pÄn chÃ¡n shÃ© guÃ¬",
    å¥³å¤§éš¾ç•™: "nÇš dÃ  nÃ¡n liÃº",
    å¼„çŽ‰å¹ç®«: "nÃ²ng yÃ¹ chuÄ« xiÄo",
    å¼„ç®¡è°ƒå¼¦: "nÃ²ng guÇŽn tiÃ¡o xiÃ¡n",
    å¼„ç²‰è°ƒæœ±: "nÃ²ng fÄ›n diÃ o zhÅ«",
    æµ“æŠ¹æ·¡å¦†: "nÃ³ng mÃ² dÃ n zhuÄng",
    æ»åœŸä¸ºé¦™: "niÇŽn tÇ” wÃ©i xiÄng",
    å¹´è°Šä¸–å¥½: "niÃ¡n yÃ¬ shÃ¬ hÇŽo",
    å¹´åŽåž‚æš®: "niÃ¡n huÃ¡ chuÃ­ mÃ¹",
    å„—ä¸äºŽä¼¦: "nÇ bÃ¹ yÃº lÃºn",
    æ³¥è€Œä¸æ»“: "nÃ­ Ã©r bÃ¹ zÇ",
    èƒ½è€…ä¸ºå¸ˆ: "nÃ©ng zhÄ› wÃ©i shÄ«",
    èƒ½ä¸ç§°å®˜: "nÃ©ng bÃº chÃ¨n guÄn",
    æŒ ç›´ä¸ºæ›²: "nÃ¡o zhÃ­ wÃ©i qÅ«",
    éš¾è¿›æ˜“é€€: "nÃ¡n jÃ¬n yÃ¬ tuÃ¬",
    éš¾å¾—ç³Šæ¶‚: "nÃ¡n dÃ© hÃº tÃº",
    å—è›®é´‚èˆŒ: "nÃ¡n mÃ¡n juÃ© shÃ©",
    å—è´©åŒ—è´¾: "nÃ¡n fÃ n bÄ›i gÇ”",
    ç‰§çŒªå¥´æˆ: "mÃ¹ zhÅ« nÃº xÃ¬",
    ç›®çœ¢å¿ƒå¿³: "mÃ¹ yuÄn xÄ«n tÃºn",
    ç›®æŒ‘å¿ƒæ‹›: "mÃ¹ tiÇŽo xÄ«n zhÄo",
    ç›®é‡æ„è¥: "mÃ¹ liÃ ng yÃ¬ yÃ­ng",
    æœ¨å¤´æœ¨è„‘: "mÃ¹ tÃ³u mÃ¹ nÇŽo",
    æœ¨å¹²é¸Ÿæ –: "mÃ¹ gÃ n niÇŽo qÄ«",
    ä¾”è‰²æ£ç§°: "mÃ³u sÃ¨ chuÇŽi chÃ¨n",
    èŽ«äºˆæ¯’ä¹Ÿ: "mÃ² yÃº dÃº yÄ›",
    æŠ¹ç²‰æ–½è„‚: "mÃ² fÄ›n shÄ« zhÄ«",
    ç£¨ç »é•Œåˆ‡: "mÃ³ lÃ³ng juÄn qiÄ“",
    ç£¨æ£±åˆ“è§’: "mÃ³ lÃ©ng wÃ¡n jiÇŽo",
    æ‘¸é—¨ä¸ç€: "mÅ mÃ©n bÃ¹ zhÃ¡o",
    æ‘¸ä¸ç€è¾¹: "mÅ bÃ¹ zhuÃ³ biÄn",
    å‘½ä¸­æ³¨å®š: "mÃ¬ng zhÅng zhÃ¹ dÃ¬ng",
    é¸£é¹¤ä¹‹åº”: "mÃ­ng hÃ¨ zhÄ« yÃ¬ng",
    æ˜Žæ•ˆå¤§éªŒ: "mÃ­ng xiÃ o dÃ  yÃ n",
    åæˆ‘å›ºå½“: "mÃ­ng wÇ’ gÃ¹ dÄng",
    é‚ˆå¤„æ¬¿è§†: "miÇŽo chÇ” kÇŽn shÃ¬",
    é»¾ç©´é¸²å·¢: "mÄ›ng xuÃ© qÃº chÃ¡o",
    ç»µé‡Œè–„æ: "miÃ¡n lÇ bÃ³ cÃ¡i",
    é¡æœ‰å­‘é—: "mÇ yÇ’u jiÃ© yÃ­",
    é¡è¡£å·é£Ÿ: "mÇ yÄ« tÅu shÃ­",
    è¿·æ‹éª¸éª¨: "mÃ­ liÃ n hÃ¡i gÇ”",
    æ‰ªå‚åŽ†äº•: "mÃ©n shÄ“n lÃ¬ jÇng",
    é—¨å•æˆ·è–„: "mÃ©n dÄn hÃ¹ bÃ³",
    æ˜§æ—¦æ™¨å…´: "mÃ¨i dÃ n chÃ©n xÄ«ng",
    å†’åæŽ¥è„š: "mÃ o mÃ­ng jiÄ“ jiÇŽo",
    æ¯›é‚å •äº•: "mÃ¡o suÃ­ duÃ² jÇng",
    æ¯›å‘å€’ç«–: "mÃ¡o fÄ dÇŽo shÃ¹",
    å–æ–‡ä¸ºç”Ÿ: "mÃ i wÃ©n wÃ©i shÄ“ng",
    å–æŽé’»æ ¸: "mÃ i lÇ zuÄn hÃ©",
    ä¹°æ¤Ÿè¿˜ç : "mÇŽi dÃº huÃ¡n zhÅ«",
    åŸ‹ä¸‰æ€¨å››: "mÃ¡n sÄn yuÃ n sÃ¬",
    é©¬å…¥åŽå±±: "mÇŽ rÃ¹ huÃ¡ shÄn",
    è½é­„æ±Ÿæ¹–: "luÃ² pÃ² jiÄng hÃº",
    è½è½éš¾åˆ: "luÃ² luÃ² nÃ¡n hÃ©",
    è½è‰ä¸ºå¯‡: "luÃ² cÇŽo wÃ©i kÃ²u",
    ç½—ç»‡æž„é™·: "luÃ³ zhÄ« gÃ²u xiÃ n",
    é¸¾å‡¤å’Œé¸£: "luÃ¡n fÃ¨ng hÃ¨ mÃ­ng",
    çŽ‡ç”±æ—§ç« : "shuÃ i yÃ³u jiÃ¹ zhÄng",
    çŽ‡åœŸåŒåº†: "shuÃ i tÇ” tÃ³ng qÃ¬ng",
    çŽ‡å…½é£Ÿäºº: "shuÃ i shÃ²u shÃ­ rÃ©n",
    çŽ‡åœŸå½’å¿ƒ: "shuÃ i tÇ” guÄ« xÄ«n",
    çŽ‡é©¬ä»¥éª¥: "shuÃ i mÇŽ yÇ jÃ¬",
    çŽ‡å°”æˆç« : "shuÃ i Ä›r chÃ©ng zhÄng",
    é²æ–¤ç‡•å‰Š: "lÇ” jÄ«n yÃ n xuÄ“",
    æ¼å°½æ›´é˜‘: "lÃ²u jÃ¬n gÄ“ng lÃ¡n",
    ç¬¼é¸Ÿæ§›çŒ¿: "lÃ³ng niÇŽo jiÃ n yuÃ¡n",
    ç¬¼é¸Ÿæ± é±¼: "lÃ³ng niÇŽo chÃ­ yÃº",
    é¾™æ¸¸æ›²æ²¼: "lÃ³ng yÃ³u qÅ« zhÇŽo",
    é¾™è¡€çŽ„é»„: "lÃ³ng xuÃ¨ xuÃ¡n huÃ¡ng",
    é¾™é›•å‡¤å’€: "lÃ³ng diÄo fÃ¨ng jÇ”",
    å…­å°ºä¹‹è®¬: "liÃ¹ chÇ zhÄ« tuÅ",
    ä»¤åŽŸä¹‹æˆš: "lÃ­ng yuÃ¡n zhÄ« qÄ«",
    ä»¤äººæ§è…¹: "lÃ¬ng rÃ©n pÄ›ng fÃ¹",
    é™µåŠ²æ·¬ç º: "lÃ­ng jÃ¬ng cuÃ¬ lÃ¬",
    ä¸´æ•Œæ˜“å°†: "lÃ­n dÃ­ yÃ¬ jiÃ ng",
    è£‚è£³è¡£ç–®: "liÃ¨ shang yÄ« chuÄng",
    è£‚å† æ¯å†•: "liÃ¨ guÃ n huÇ miÇŽn",
    äº†æ— æƒ§è‰²: "liÇŽo wÃº jÃ¹ sÃ¨",
    äº†èº«è¾¾å‘½: "liÇŽo shÄ“n dÃ¡ mÃ¬ng",
    äº†ç„¶æ— é—»: "liÇŽo rÃ¡n wÃº wÃ©n",
    äº†ä¸å¯è§: "liÇŽo bÃ¹ kÄ› jiÃ n",
    äº†ä¸é•¿è¿›: "liÇŽo bÃ¹ zhÇŽng jÃ¬n",
    ç‡Žå‘æ‘§æž¯: "liÇŽo fÃ  cuÄ« kÅ«",
    å®¡æ—¶åº¦åŠ¿: "shÄ›n shÃ­ duÃ³ shÃ¬",
    é‡å°åŠ›å¾®: "liÃ ng xiÇŽo lÃ¬ wÄ“i",
    ç›¸æ—¶åº¦åŠ›: "xiÄng shÃ­ duÃ³ lÃ¬",
    é‡æž˜åˆ¶å‡¿: "liÃ ng ruÃ¬ zhÃ¬ zÃ¡o",
    é‡å¦‚æ±Ÿæµ·: "liÃ ng rÃº jiÄng hÇŽi",
    é‡é‡‘ä¹°èµ‹: "liÃ ng jÄ«n mÇŽi fÃ¹",
    é‡å·±å®¡åˆ†: "liÃ ng jÇ shÄ›n fÄ“n",
    æ•›éª¨å¹é­‚: "liÇŽn gÇ” chuÄ« hÃºn",
    è©ˆå¤·ä¸ºè·–: "lÃ¬ yÃ­ wÃ©i zhÃ­",
    åˆ©ä»¤å¿—æƒ›: "lÃ¬ lÃ¬ng zhÃ¬ hÅ«n",
    æŽå¹¿ä¸ä¾¯: "lÇ guÇŽng bÃº hÃ²u",
    ç¤¼ä¸ºæƒ…è²Œ: "lÇ wÃ©i qÃ­ng mÃ o",
    ç¤¼è®©ä¸ºå›½: "lÇ rÃ ng wÃ©i guÃ³",
    çŠç”Ÿéªè§’: "lÃ­ shÄ“ng xÄ«ng jiÇŽo",
    ç¦»æœ¬å¾¼æœ«: "lÃ­ bÄ›n jiÇŽo mÃ²",
    æ¥žçœ‰æ¨ªçœ¼: "lÃ©ng mÃ©i hÃ¨ng yÇŽn",
    æ“‚å¤©å€’åœ°: "lÃ©i tiÄn dÇŽo dÃ¬",
    ç´¯è¶³æˆæ­¥: "lÄ›i zÃº chÃ©ng bÃ¹",
    ç´¯ç“¦ç»“ç»³: "lÄ›i wÇŽ jiÃ© shÃ©ng",
    ç´¯åœŸè‡³å±±: "lÄ›i tÇ” zhÃ¬ shÄn",
    ç´¯åœŸèšæ²™: "lÄ›i tÇ” jÃ¹ shÄ",
    ç´¯åµä¹‹å±: "lÄ›i luÇŽn zhÄ« wÄ“i",
    ç´¯ç´¯å¦‚ç : "lÄ›i lÄ›i rÃº zhÅ«",
    ç´¯å—ç§¯è‹: "lÄ›i kuÃ i jÄ« sÅ«",
    ä¹å±±ä¹æ°´: "lÃ¨ shÄn lÃ¨ shuÇ",
    æ½¦åŽŸæµ¸å¤©: "lÇŽo yuÃ¡n jÃ¬n tiÄn",
    è€å¸ˆå®¿å„’: "lÇŽo shÄ« xiÇ” rÃº",
    ç‰¢ä»€å¤å­: "lÃ¡o shÃ­ gÇ” zi",
    ç…å¬›ç¦åœ°: "lÃ¡ng huÃ¡n fÃº dÃ¬",
    æ†æƒ…åº¦ç†: "kuÃ­ qÃ­ng duÃ³ lÇ",
    æ—·æ—¥ç´¯æ—¶: "kuÃ ng rÃ¬ lÄ›i shÃ­",
    åŒ¡æ•‘å¼¥ç¼: "kuÄng jiÃ¹ mÃ­ fÃ¨ng",
    æž¯æ ‘ç”ŸåŽ: "kÅ« shÃ¹ shÄ“ng huÄ",
    å£è½»èˆŒè–„: "kÇ’u qÄ«ng shÃ© bÃ³",
    å£è§’ç”Ÿé£Ž: "kÇ’u jiÇŽo shÄ“ng fÄ“ng",
    å£è§’æ˜¥é£Ž: "kÇ’u jiÇŽo chÅ«n fÄ“ng",
    å£è§’é£Žæƒ…: "kÇ’u jiÇŽo fÄ“ng qÃ­ng",
    å£å¹²èˆŒç„¦: "kÇ’u gÄn shÃ© jiÄo",
    å£è…¹ä¹‹ç´¯: "kÇ’u fÃ¹ zhÄ« lÄ›i",
    ç©ºè…¹ä¾¿ä¾¿: "kÅng fÃ¹ piÃ¡n piÃ¡n",
    å—‘ç‰™æ–™å˜´: "kÄ“ yÃ¡ liÃ o zuÇ",
    åˆ»æœ¨ä¸ºé¹„: "kÃ¨ mÃ¹ wÃ©i hÃº",
    å’³ç å”¾çŽ‰: "kÃ© zhÅ« tuÃ² yÃ¹",
    å’³å”¾æˆç : "kÃ© tuÃ² chÃ©ng zhÅ«",
    æŠ—é¢œä¸ºå¸ˆ: "kÃ ng yÃ¡n wÃ©i shÄ«",
    å¼€åŽç»“æžœ: "kÄi huÄ jiÃ© guÇ’",
    å³»é˜ªç›è½¦: "jÃ¹n bÇŽn yÃ¡n chÄ“",
    åš¼é“å’€é‡‘: "jiÃ¡o tiÄ› jÇ” jÄ«n",
    åš¼å¢¨å–·çº¸: "juÃ© mÃ² pÄ“n zhÇ",
    å€”å¤´å¼ºè„‘: "juÃ¨ tÃ³u jiÃ ng nÇŽo",
    å€”å¤´å€”è„‘: "juÃ¨ tÃ³u juÃ¨ nÇŽo",
    å€¦é¸ŸçŸ¥è¿˜: "juÃ n niÇŽo zhÄ« huÃ¡n",
    å·å¸­è€Œè‘¬: "juÇŽn xÃ­ Ã©r zÃ ng",
    å·ç”²å€é“: "juÇŽn jiÇŽ bÃ¨i dÃ o",
    èšç±³ä¸ºå±±: "jÃ¹ mÇ wÃ©i shÄn",
    ä¸¾æ‰‹ç›¸åº†: "jÇ” shÇ’u xiÄng qÃ¬ng",
    ä¸¾ä¸–æ··æµŠ: "jÇ” shÃ¬ hÃºn zhuÃ³",
    éž ä¸ºèŒ‚è‰: "jÅ« wÃ©i mÃ o cÇŽo",
    æ‹˜ç¥žé£å°†: "jÅ« shÃ©n qiÇŽn jiÃ ng",
    å±…ä¸‹è®ªä¸Š: "jÅ« xiÃ  shÃ n shÃ ng",
    ä¹…è¦ä¸å¿˜: "jiÇ” yÄo bÃº wÃ ng",
    ä¹è½¬åŠŸæˆ: "jiÇ” zhuÇŽn gÅng chÃ©ng",
    ä¹è’¸ä¸‰ç†¯: "jiÇ” zhÄ“ng sÄn hÃ n",
    æ•¬ä¸šä¹ç¾¤: "jÃ¬ng yÃ¨ lÃ¨ qÃºn",
    äº•åº•è™¾èŸ†: "jÇng dÇ xiÄ mÃ¡",
    æ—Œæ——å·èˆ’: "jÄ«ng qÃ­ juÇŽn shÅ«",
    è†æ£˜è½½é€”: "jÄ«ng jÃ­ zÃ i tÃº",
    ç¦èˆå¼€å¡ž: "jÃ¬n shÄ› kÄi sÄi",
    ç¥²å¨ç››å®¹: "jÃ¬n wÄ“i shÃ¨ng rÃ³ng",
    è¿›é€€æ¶ˆé•¿: "jÃ¬n tuÃ¬ xiÄo chÃ¡ng",
    è¿›é€€åº”çŸ©: "jÃ¬n tuÃ¬ yÄ«ng jÇ”",
    è¿›é€€è§¦ç±“: "jÃ¬n tuÃ¬ chÃ¹ fÄn",
    è¿›é€€è·‹ç–: "jÃ¬n tuÃ¬ bÃ¡ zhÃ¬",
    å°½å¤šå°½å°‘: "jÇn duÅ jÇn shÇŽo",
    é”¦å›Šè¿˜çŸ¢: "jÇn nÃ¡ng huÃ¡n shÇ",
    çŸœå·±è‡ªé¥°: "jÄ«n jÇ zÃ¬ shÃ¬",
    çŸœåŠŸè´Ÿæ°”: "jÄ«n gÅng fÃ¹ qÃ¬",
    æ´¥å…³é™©å¡ž: "jÄ«n guÄn xiÇŽn sÃ i",
    é‡‘å¾ä¸ç¦: "jÄ«n wÃº bÃº jÃ¬n",
    é‡‘ç¿…æ“˜æµ·: "jÄ«n chÃ¬ bÄi hÇŽi",
    è§£è¡£è¡£äºº: "jiÄ› yÄ« yÄ« rÃ©n",
    è§£äººéš¾å¾—: "jiÄ› rÃ©n nÃ¡n dÃ©",
    è§£é“ƒç³»é“ƒ: "jiÄ› lÃ­ng xÃ¬ lÃ­ng",
    è§£å‘ä½¯ç‹‚: "jiÄ› fÃ  yÃ¡ng kuÃ¡ng",
    è¯˜å±ˆç£ç¢»: "jiÃ© qÅ« Ã¡o qiÄo",
    æ•™çŒ±å‡æœ¨: "jiÄo nÃ¡o shÄ“ng mÃ¹",
    è¾ƒç˜¦é‡è‚¥: "jiÃ o shÃ²u liÃ ng fÃ©i",
    è§’ç«‹æ°å‡º: "jiÇŽo lÃ¬ jiÃ© chÅ«",
    ç„¦æ²™çƒ‚çŸ³: "jiÄo shÄ lÃ n shÃ­",
    éª„å„¿é¨ƒå¥³: "jiÄo Ã©r sÃ¬ nÇš",
    æµ‡é£Žè–„ä¿—: "jiÄo fÄ“ng bÃ³ sÃº",
    é™å¦–æ‰æ€ª: "xiÃ¡ng yÄo zhuÅ guÃ i",
    å°†å–å›ºäºˆ: "jiÄng qÇ” gÃ¹ yÇ”",
    å°†é—¨æœ‰å°†: "jiÃ ng mÃ©n yÇ’u jiÃ ng",
    å°†å¤ºå›ºä¸Ž: "jiÄng duÃ³ gÃ¹ yÇ”",
    æ§›èŠ±ç¬¼é¹¤: "jiÃ n huÄ lÃ³ng hÃ¨",
    é‰´å½±åº¦å½¢: "jiÃ n yÇng duÃ³ xÃ­ng",
    æ¸ä¸å¯é•¿: "jiÃ n bÃ¹ kÄ› zhÇŽng",
    è§ç´ æŠ±æœ´: "xiÃ n sÃ¹ bÃ o pÇ”",
    è§å¼ƒäºŽäºº: "jiÃ n qÃ¬ yÃº rÃ©n",
    ç®€ä¸æ•°ç±³: "jiÇŽn sÄ« shÇ” mÇ",
    ä¿­ä¸ä¸­ç¤¼: "jiÇŽn bÃº zhÃ²ng lÇ",
    é—´è§å±‚å‡º: "jiÃ n xiÃ n cÃ©ng chÅ«",
    å°–å˜´è–„èˆŒ: "jiÄn zuÇ bÃ³ shÃ©",
    ç”²å† å¤©ä¸‹: "jiÇŽ guÃ n tiÄn xiÃ ",
    è‘­èŽ©ä¹‹äº²: "jiÄ fÃº zhÄ« qÄ«n",
    å®¶ç´¯åƒé‡‘: "jiÄ lÃ¨i qiÄn jÄ«n",
    å®¶ç»™äººè¶³: "jiÄ jÇ rÃ©n zÃº",
    å®¶é“ä»Žå®¹: "jiÄ dÃ o cÃ³ng rÃ³ng",
    å¤¹è¢‹äººç‰©: "jiÄ dÃ i rÃ©n wÃ¹",
    éœé£Žæœ—æœˆ: "jÃ¬ fÄ“ng lÇŽng yuÃ¨",
    å¯„å…´å¯“æƒ…: "jÃ¬ xÃ¬ng yÃ¹ qÃ­ng",
    è®¡æ·±è™‘è¿œ: "jÃ¬ shÄ“n lÇœ yuÇŽn",
    è®¡åŠŸé‡ç½ª: "jÃ¬ gÅng liÃ ng zuÃ¬",
    æŽŽè£³è¿žè¥¼: "jÇ shang liÃ¡n yÃ¬",
    è™®è™±ç›¸åŠ: "jÇ shÄ« xiÄng diÃ o",
    ç–¾ä¸å¯ä¸º: "jÃ­ bÃ¹ kÄ› wÃ©i",
    æžæ·±ç ”å‡ : "jÃ­ shÄ“n yÃ¡n jÄ«",
    åŠå®¾æœ‰é±¼: "jÃ­ bÄ«n yÇ’u yÃº",
    æ¿€è–„åœæµ‡: "jÄ« bÃ³ tÃ­ng jiÄo",
    ç§¯ç´ ç´¯æ—§: "jÄ« sÃ¹ lÄ›i jiÃ¹",
    ç§¯æ—¶ç´¯æ—¥: "jÄ« shÃ­ lÄ›i rÃ¬",
    ç§¯éœ²ä¸ºæ³¢: "jÄ« lÃ¹ wÃ©i bÅ",
    ç§¯å¾·ç´¯åŠŸ: "jÄ« dÃ© lÄ›i gÅng",
    ç§¯è°—ç³œéª¨: "jÄ« chÃ¡n mÃ©i gÇ”",
    å‡»æŽ’å†’æ²¡: "jÄ« pÃ¡i mÃ o mÃ²",
    ç¥¸ä¸ºç¦å…ˆ: "huÃ² wÃ©i fÃº xiÄn",
    ç¥¸ç¦ç›¸ä¾: "huÃ² fÃº xiÄng yÄ«",
    èŽ·éš½å…¬è½¦: "huÃ² jÃ¹n gÅng chÄ“",
    æ··åº”æ»¥åº”: "hÃ¹n yÄ«ng lÃ n yÄ«ng",
    æ¯èˆŸä¸ºæ•: "huÇ zhÅu wÃ©i duÃ²",
    æ¯é’Ÿä¸ºé“Ž: "huÇ zhÅng wÃ©i duÃ³",
    æ¯å† è£‚è£³: "huÇ guÄn liÃ¨ chÃ¡ng",
    æ™¦ç›²å¦å¡ž: "huÃ¬ mÃ¡ng pÇ sÃ¨",
    å›žèˆ¹è½¬èˆµ: "huÃ­ chuÃ¡n zhuÃ n duÃ²",
    æ½¢æ± ç›—å¼„: "huÃ¡ng chÃ­ dÃ o nÃ²ng",
    é»„å† è‰å±¥: "huÃ¡ng guÃ n cÇŽo lÇš",
    é»„å‘å„¿é½¿: "huÃ¡ng fÃ  Ã©r chÇ",
    é»„å‘åž‚é««: "huÃ¡ng fÃ  chuÃ­ tiÃ¡o",
    è¿˜ç è¿”ç’§: "huÃ¡n zhÅ« fÇŽn bÃ¬",
    è¿˜å¹´é©»è‰²: "huÃ¡n niÃ¡n zhÃ¹ sÃ¨",
    è¿˜å¹´å´è€: "huÃ¡n niÃ¡n quÃ¨ lÇŽo",
    åè£³ä¸ºè£¤: "huÃ i shang wÃ©i kÃ¹",
    ç”»è»å’Œä¸¸: "huÃ  dÃ­ huÃ² wÃ¡n",
    åŒ–æž­ä¸ºé¸ : "huÃ  xiÄo wÃ©i jiÅ«",
    åŒ–è…ä¸ºå¥‡: "huÃ  fÇ” wÃ©i qÃ­",
    åŒ–é¸±ä¸ºå‡¤: "huÃ  chÄ« wÃ©i fÃ¨ng",
    èŠ±ä¸æ£±ç™»: "huÄ bu lÄ“ng dÄ“ng",
    æˆ·é™ä¸ºç©¿: "hÃ¹ xiÃ n wÃ©i chuÄn",
    å‘¼å¢å–é›‰: "hÅ« lÃº hÃ¨ zhÃ¬",
    å‘¼æ¥å–åŽ»: "hÅ« lÃ¡i hÃ¨ qÃ¹",
    å‘¼ä¸ç»™å¸: "hÅ« bÃ¹ jÇ xÄ«",
    åŽšå‘³è…Šæ¯’: "hÃ²u wÃ¨i xÄ« dÃº",
    åŽšå¾·è½½ç‰©: "hÃ²u dÃ© zÃ i wÃ¹",
    é¸¿æ¸äºŽå¹²: "hÃ³ng jiÃ n yÃº gÃ n",
    æ´ªç‚‰ç‡Žå‘: "hÃ³ng lÃº liÃ¡o fÃ ",
    çº¢ç»³ç³»è¶³: "hÃ³ng shÃ©ng jÃ¬ zÃº",
    çº¢ä¸æ£±ç™»: "hÃ³ng bu lÄ“ng dÄ“ng",
    æ¨ªæŠ¢ç¡¬å¤º: "hÃ¨ng qiÇŽng yÃ¬ng duÃ³",
    æ¨ªæ©æ»¥èµ: "hÃ¨ng Ä“n lÃ n shÇŽng",
    æ¨æµ·éš¾å¡«: "hÃ¨n hÇŽi nÃ¡n tiÃ¡n",
    é¹¤å‘é¸¡çš®: "hÃ¨ fÃ  jÄ« pÃ­",
    æ¶¸æ€å¹²è™‘: "hÃ© sÄ« gÄn lÇœ",
    æ²³æ¶¸æµ·å¹²: "hÃ© hÃ© hÇŽi gÄn",
    å’Œé¢œè¯´è‰²: "hÃ© yÃ¡n yuÃ¨ sÃ¨",
    åˆä»Žè¿žè¡¡: "hÃ© zÃ²ng liÃ¡n hÃ©ng",
    æµ©æµ©æ±¤æ±¤: "hÃ o hÃ o shÄng shÄng",
    å¥½å‹‡æ–—ç‹ : "hÃ o yÇ’ng dÃ²u hÄ›n",
    å¥½é—®åˆ™è£•: "hÃ o wÃ¨n zÃ© yÃ¹",
    å¥½ä¸ºäº‹ç«¯: "hÃ o wÃ©i shÃ¬ duÄn",
    å¥½é—®å†³ç–‘: "hÃ o wÃ¨n juÃ© yÃ­",
    å¥½ç”Ÿä¹‹å¾·: "hÃ o shÄ“ng zhÄ« dÃ©",
    å¥½å¥‡å°šå¼‚: "hÇŽo qÃ­ shÃ ng yÃ¬",
    å¥½æ¶ä¸åŒ: "hÇŽo Ã¨ bÃ¹ tÃ³ng",
    å¥½ä¸¹éžç´ : "hÃ o dÄn fÄ“i sÃ¹",
    è±ªå¹²æš´å–: "hÃ¡o gÃ n bÃ o qÇ”",
    æ¯«å‘ä¸çˆ½: "hÃ¡o fÃ  bÃ¹ shuÇŽng",
    å¯’é…¸è½é­„: "hÃ¡n suÄn luÃ² pÃ²",
    å«è‹±å’€åŽ: "hÃ¡n yÄ«ng jÇ” huÃ¡",
    å«ç³Šä¸æ˜Ž: "hÃ¡n hÃº bÃ¹ mÃ­ng",
    è¿‡ä¸ºå·²ç”š: "guÃ² wÃ©i yÇ shÃ¨n",
    æ¡‚æŠ˜å…°æ‘§: "guÃ¬ shÃ© lÃ¡n cuÄ«",
    è§„æ—‹çŸ©æŠ˜: "guÄ« xuÃ¡n jÇ” shÃ©",
    å¹¿æ–‡å…ˆç”Ÿ: "guÇŽng wÃ©n xiÄn sheng",
    å¹¿é™µæ•£ç»: "guÇŽng lÃ­ng sÇŽn juÃ©",
    å† å±±æˆ´ç²’: "guÃ n shÄn dÃ i lÃ¬",
    å† å±¦å€’æ–½: "guÃ n jÃ¹ dÇŽo shÄ«",
    æŒ‚å¸­ä¸ºé—¨: "guÃ  xÃ­ wÃ©i mÃ©n",
    å¯¡è§é²œé—»: "guÇŽ jiÃ n xiÇŽn wÃ©n",
    ç“œè‘›ç›¸è¿ž: "guÄ gÃ© xiÄng liÃ¡n",
    é¼“å»å¥‹çˆª: "gÇ” wÄ›n fÃ¨n zhÇŽo",
    å¤è°ƒå•å¼¹: "gÇ” diÃ o dÄn tÃ¡n",
    å¤è°ƒä¸å¼¹: "gÇ” diÃ o bÃ¹ tÃ¡n",
    å§‘å°„ç¥žäºº: "gÅ« yÃ¨ shÃ©n rÃ©n",
    è‹Ÿåˆå–å®¹: "gÇ’u hÃ© qÇ” rÃ³ng",
    ç‹—ç»­ä¾¯å† : "gÇ’u xÃ¹ hÃ²u guÃ n",
    é’©çˆªé”¯ç‰™: "gÅu zhÇŽo jÃ¹ yÃ¡",
    å…±æžåˆ«å¹²: "gÃ²ng zhÄ« biÃ© gÃ n",
    å…±ä¸ºå”‡é½¿: "gÃ²ng wÃ©i chÃºn chÇ",
    æ‹±æ‰‹è€Œé™: "gÇ’ng shÇ’u Ã©r xiÃ¡ng",
    æ‹±è‚©ç¼©èƒŒ: "gÇ’ng jiÄn suÅ bÃ¨i",
    åŠŸè–„è‰ç¿¼: "gÅng bÃ³ chÃ¡n yÃ¬",
    å¼“è°ƒé©¬æœ: "gÅng diÃ o mÇŽ fÃº",
    æ›´å§“æ”¹ç‰©: "gÄ“ng xÃ¬ng gÇŽi wÃ¹",
    æ›´ä»†éš¾æ•°: "gÄ“ng pÃº nÃ¡n shÇ”",
    æ›´ä»¤æ˜Žå·: "gÄ“ng lÃ¬ng mÃ­ng hÃ o",
    æ›´å¾…å¹²ç½¢: "gÃ¨ng dÃ i gÃ n bÃ ",
    æ›´å”±è¿­å’Œ: "gÄ“ng chÃ ng diÃ© hÃ©",
    æ›´é•¿æ¢¦çŸ­: "gÄ“ng chÃ¡ng mÃ¨ng duÇŽn",
    å„è‰²åæ ·: "gÃ¨ sÃ¨ mÃ­ng yÃ ng",
    æ ¼æ ¼ä¸çº³: "gÃ© gÃ© bÃº nÃ ",
    æ ¼æ ¼ä¸å: "gÃ© gÃ© bÃ¹ tÇ”",
    å‘Šæœ”é¥©ç¾Š: "gÃ¹ shuÃ² xÃ¬ yÃ¡ng",
    è†è½¦ç§£é©¬: "gÃ o chÄ“ mÃ² mÇŽ",
    é«˜ä¹‰è–„äº‘: "gÄo yÃ¬ bÃ³ yÃºn",
    å²—å¤´æ³½åº•: "gÄng tÃ³u zÃ© dÇ",
    æ•¢ä¸ºæ•¢åš: "gÇŽn wÃ©i gÇŽn zuÃ²",
    ç”˜åˆ†éšæ—¶: "gÄn fÃ¨n suÃ­ shÃ­",
    ç”˜å¤„ä¸‹æµ: "gÄn chÇ” xiÃ  liÃº",
    å¹²å•¼æ¹¿å“­: "gÃ n tÃ­ shÄ« kÅ«",
    å¹²åçŠ¯ä¹‰: "gÃ n mÃ­ng fÃ n yÃ¬",
    å¹²å°†èŽ«é‚ª: "gÄn jiÄng mÃ² yÃ©",
    å¹²åŸŽä¹‹å°†: "gÄn chÃ©ng zhÄ« jiÃ ng",
    è…¹è½½äº”è½¦: "fÃ¹ zÃ i wÇ” chÄ“",
    çˆ¶å€ºå­è¿˜: "fÃ¹ zhÃ i zÇ huÃ¡n",
    çˆ¶ä¸ºå­éš: "fÃ¹ wÃ©i zÇ yÇn",
    è¾…ä¸–é•¿æ°‘: "fÇ” shÃ¬ zhÇŽng mÃ­n",
    ç¦ä¸ºç¥¸å§‹: "fÃº wÃ©i huÃ² shÇ",
    ç¬¦å·é€»è¾‘: "fÃº hÃ o luÃ³ jÃ­",
    æµ®æ”¶å‹’æŠ˜: "fÃº shÅu lÃ¨ shÃ©",
    è‚¤å—ä¹‹æ„¬: "fÅ« shÃ²u zhÄ« sÃ¹",
    å¦ç»ˆåˆ™æ³°: "pÇ zhÅng zÃ© tÃ i",
    ä½›å¤´è‘—ç²ª: "fÃ³ tÃ³u zhuÃ³ fÃ¨n",
    å¥‰ä¸ºæ¥·æ¨¡: "fÃ¨ng wÃ©i kÇŽi mÃ³",
    å‡¤é¡é¸¾åª: "fÃ¨ng mÇ luÃ¡n Ã©",
    å°è±¨ä¿®è›‡: "fÄ“ng xÄ« xiÅ« shÃ©",
    é£Žå½±æ•·è¡: "fÄ“ng yÇng fÅ« yÇŽn",
    ä¸°å±‹è”€å®¶: "fÄ“ng wÅ« bÃ¹ jiÄ",
    ç²ªåœŸä¸å¦‚: "fÃ¨n tÇ” bÃ¹ rÃº",
    åˆ†é£ŽåŠˆæµ: "fÄ“n fÄ“ng pÇ liÃº",
    æ²¸æ²¸æ±¤æ±¤: "fÃ¨i fÃ¨i shÄng shÄng",
    è²é£Ÿè–„è¡£: "fÄ›i shÃ­ bÃ³ yÄ«",
    é£žå°†æ•°å¥‡: "fÄ“i jiÃ ng shÃ¹ qÃ­",
    æ”¾è¾Ÿé‚ªä¾ˆ: "fÃ ng pÃ¬ xiÃ© chÇ",
    æ–¹é¢†åœ†å† : "fÄng lÇng yuÃ¡n guÃ n",
    çŠ¯è€Œä¸æ ¡: "fÃ n Ã©r bÃº jiÃ o",
    è¿”æœ¬è¿˜æº: "fÇŽn bÄ›n huÃ¡n yuÃ¡n",
    ååŠ³ä¸ºé€¸: "fÇŽn lÃ¡o wÃ©i yÃ¬",
    æ³•è½®å¸¸è½¬: "fÇŽ lÃºn chÃ¡ng zhuÃ n",
    ç½šä¸å½“ç½ª: "fÃ¡ bÃ¹ dÄng zuÃ¬",
    å‘å¼•åƒé’§: "fÃ  yÇn qiÄn jÅ«n",
    å‘å¥¸æ“¿ä¼: "fÄ jiÄn tÄ« fÃº",
    å‘çŸ­å¿ƒé•¿: "fÃ  duÇŽn xÄ«n chÃ¡ng",
    äºŒç«–ä¸ºè™: "Ã¨r shÃ¹ wÃ©i nÃ¼Ã¨",
    å„¿å¥³å¿ƒè‚ : "Ã©r nÇš xÄ«n chÃ¡ng",
    å„¿å¥³äº²å®¶: "Ã©r nÇš qÃ¬ng jiÄ",
    éæ¶æ‰¬å–„: "Ã¨ wÃ¹ yÃ¡ng shÃ n",
    é¥¿æ®æž•è—‰: "Ã¨ piÇŽo zhÄ›n jÃ­",
    é¥¿æ®è½½é“: "Ã¨ piÇŽo zÃ i dÃ o",
    æ¶é†‰å¼ºé…’: "wÃ¹ zuÃ¬ qiÇŽng jiÇ”",
    æ¶æ„ä¸­ä¼¤: "Ã¨ yÃ¬ zhÃ²ng shÄng",
    æ¶æ¹¿å±…ä¸‹: "wÃ¹ shÄ« jÅ« xiÃ ",
    æ¶å±…ä¸‹æµ: "wÃ¹ jÅ« xiÃ  liÃº",
    æ¶ä¸åŽ»å–„: "wÃ¹ bÃº qÃ¹ shÃ n",
    æ‰¼å­å¤ºé£Ÿ: "Ã¨ hÃ¡ng duÃ³ shÃ­",
    æ‰¼è¥ŸæŽ§å’½: "Ã¨ jÄ«n kÃ²ng yÄn",
    å³¨å³¨æ±¤æ±¤: "Ã© Ã© shÄng shÄng",
    å±™é‡‘æººé“¶: "Ä“ jÄ«n niÃ o yÃ­n",
    æœµé¢å¤§åš¼: "duÇ’ yÃ­ dÃ  jiÃ¡o",
    å¤ºäººæ‰€å¥½: "duÃ³ rÃ©n suÇ’ hÃ o",
    å¤šè¨€æ•°ç©·: "duÅ yÃ¡n shuÃ² qiÃ³ng",
    å¤šæ–‡ä¸ºå¯Œ: "duÅ wÃ©n wÃ©i fÃ¹",
    å¤šç«¯å¯¡è¦: "duÅ duÄn guÇŽ yÃ o",
    å¤šè´¢å–„è´¾: "duÅ cÃ¡i shÃ n gÇ”",
    éä¸–æ— é—·: "dÃ¹n shÃ¬ wÃº mÃ¨n",
    éè¿¹é»„å† : "dÃ¹n jÃ¬ huÃ¡ng guÃ n",
    å †æ¡ˆç›ˆå‡ : "duÄ« Ã n yÃ­ng jÄ«",
    æ–­è¿˜å½’å®—: "duÃ n huÃ¡n guÄ« zÅng",
    çŸ­è§è–„è¯†: "duÇŽn jiÃ n bÃ³ shÃ­",
    è ¹å±…æ£Šå¤„: "dÃ¹ jÅ« qÃ­ chÇ”",
    åº¦å·±ä»¥ç»³: "duÃ³ jÇ yÇ shÃ©ng",
    æœé»˜ä¸ºè¯—: "dÃ¹ mÃ² wÃ©i shÄ«",
    æœé¹ƒå•¼è¡€: "dÃ¹ juÄn tÃ­ xuÃ¨",
    ç¬ƒè¿‘ä¸¾è¿œ: "dÇ” jÃ¬n jÇ” yuÇŽn",
    ç‹¬æœ‰åƒç§‹: "dÃº yÇ’u qiÄn qiÅ«",
    è¯»ä¹¦å¾—é—´: "dÃº shÅ« dÃ© jiÃ n",
    æ–—è½¬å‚æ¨ª: "dÇ’u zhuÇŽn shÄ“n hÃ©ng",
    å…œè‚šè¿žè‚ : "dÅu dÇ” liÃ¡n chÃ¡ng",
    æ´žè§ç—‡ç»“: "dÃ²ng jiÃ n zhÃ¨ng jiÃ©",
    æ«ç–‘è™šå–: "dÃ²ng yÃ­ xÅ« hÃ¨",
    åŠ¨ä¸­çª¾è¦: "dÃ²ng zhÅng kuÇŽn yÃ o",
    ä¸œé¸£è¥¿åº”: "dÅng mÃ­ng xÄ« yÄ«ng",
    ä¸œé³žè¥¿çˆª: "dÅng lÃ­n xÄ« zhÇŽo",
    ä¸œé‡è¥¿æŠ˜: "dÅng liÃ ng xÄ« shÃ©",
    ä¸œå®¶è¥¿èˆ: "dÅng jiÄ xÄ« shÃ¨",
    ä¸œæ‰¯è¥¿æ‹½: "dÅng chÄ› xÄ« zhuÄi",
    é¼Žé“›æœ‰è€³: "dÇng chÄ“ng yÇ’u Ä›r",
    é¼Žé“›çŽ‰çŸ³: "dÇng chÄ“ng yÃ¹ shÃ­",
    é’‰å¤´ç£·ç£·: "dÄ«ng tÃ³u lÃ­n lÃ­n",
    è·Œå®•ä¸ç¾: "diÄ“ dÃ ng bÃ¹ jÄ«",
    è·Œå¼¹æ–‘é¸ : "diÄ“ dÃ n bÄn jiÅ«",
    é›•å¿ƒé›çˆª: "diÄo xÄ«n yÃ n zhÇŽo",
    é¢ å€’è¡£è£³: "diÄn dÇŽo yÄ« chÃ¡ng",
    å¾·è–„èƒ½é²œ: "dÃ© bÃ³ nÃ©ng xiÇŽn",
    å¾—é©¬æŠ˜è¶³: "dÃ© mÇŽ shÃ© zÃº",
    è¹ˆå…¶è¦†è¾™: "dÇŽo qÃ­ fÃ¹ zhÃ©",
    æ£è™šæ’‡æŠ—: "dÇŽo xÅ« piÄ“ kÃ ng",
    å€’è½½å¹²æˆˆ: "dÃ o zÃ i gÄn gÄ“",
    å€’è£³ç´¢é¢†: "dÃ o chÃ¡ng suÇ’ lÇng",
    å€’æžœä¸ºå› : "dÃ o guÇ’ wÃ©i yÄ«n",
    å¨åœ¨çŸ¥å·±: "tÄo zÃ i zhÄ« jÇ",
    å¨é™ªæœ«åº§: "tÄo pÃ©i mÃ² zuÃ²",
    å…šè±ºä¸ºè™: "dÇŽng chÃ¡i wÃ©i nÃ¼Ã¨",
    å½“è½´å¤„ä¸­: "dÄng zhÃ³u chÇ” zhÅng",
    å½“ç€ä¸ç€: "dÄng zhuÃ³ bÃ¹ zhuÃ³",
    å½“åŠ¡å§‹ç»ˆ: "dÄng wÃ¹ shÇ zhÅng",
    æ·¡æ±æµ“æŠ¹: "dÃ n rÇ” nÃ³ng mÇ’",
    å¼¹ä¸¸è„±æ‰‹: "tÃ¡n wÃ¡n tuÅ shÇ’u",
    å¼¹é“—æ— é±¼: "dÃ n jiÃ¡ wÃº yÃº",
    ç®ªé£Ÿç“¢é¥®: "dÄn sÃ¬ piÃ¡o yÇn",
    å¤§ç’žä¸å®Œ: "dÃ  pÃº bÃ¹ wÃ¡n",
    å¤§æ˜Žæ³•åº¦: "dÃ  mÃ­ng fÇŽ dÃ¹",
    å¤§è½¦ä»¥è½½: "dÃ  chÄ“ yÇ zÃ i",
    æ‰“é—·è‘«èŠ¦: "dÇŽ mÃ¨n hÃº lu",
    æ²“æ¥è¸µè‡³: "tÃ  lÃ¡i zhÇ’ng zhÃ¬",
    åŽç«ç‡ŽåŽŸ: "cuÃ² huÇ’ liÇŽo yuÃ¡n",
    æ’®ç§‘æ‰“å“„: "cuÅ kÄ“ dÇŽ hÃ²ng",
    å¯¸ç§¯é“¢ç´¯: "cÃ¹n jÄ« zhÅ« lÄ›i",
    å•›å•›å–³å–³: "cuÃ¬ cuÃ¬ chÄ chÄ",
    æ‘§æŠ˜è±ªå¼º: "cuÄ« zhÃ© hÃ¡o qiÃ¡ng",
    æ‘§åˆšä¸ºæŸ”: "cuÄ« gÄng wÃ©i rÃ³u",
    ä»Žä¿—å°±ç®€: "cÃ³ng sÃº jiÃ¹ jiÇŽn",
    æ­¤å‘å½¼åº”: "cÇ fÄ bÇ yÄ«ng",
    æ­¤å”±å½¼å’Œ: "cÇ chÃ ng bÇ hÃ¨",
    æ…ˆæ‚²ä¸ºæœ¬: "cÃ­ bÄ“i wÃ©i bÄ›n",
    çº¯å±žéª—å±€: "chÃºn shÇ” piÃ n jÃº",
    æ˜¥ç¬‹æ€’å‘: "chÅ«n sÇ”n nÃ¹ fÄ",
    åž‚å¤´æ¨ç¿¼: "chuÃ­ tÃ³u tÃ  yÃ¬",
    ä¼ ä¸ºç¬‘è°ˆ: "chuÃ¡n wÃ©i xiÃ o tÃ¡n",
    ä¼ é£Žæ‰‡ç«: "chuÃ¡n fÄ“ng shÄn huÇ’",
    ç©¿çº¢ç€ç»¿: "chuÄn hÃ³ng zhuÃ³ lÇœ",
    è§¦å¤„æœºæ¥: "chÃ¹ chÇ” jÄ« lÃ¡i",
    å¤„å°Šå±…æ˜¾: "chÇ” zÅ«n jÅ« xiÇŽn",
    å¤„å ‚ç‡•é›€: "chÇ” tÃ¡ng yÃ n quÃ¨",
    å¤„å®žæ•ˆåŠŸ: "chÇ” shÃ­ xiÃ o gÅng",
    å¤„é«˜ä¸´æ·±: "chÇ” gÄo lÃ­n shÄ“n",
    å‡ºå…¥æ— é—´: "chÅ« rÃ¹ wÃº jiÄn",
    å‡ºé—¨åº”è¾™: "chÅ« mÃ©n yÄ«ng zhÃ©",
    å‡ºå¤„è¯­é»˜: "chÅ« chÇ” yÇ” mÃ²",
    å‡ºå¤„æ®Šé€”: "chÅ« chÇ” shÅ« tÃº",
    å‡ºå¤„è¿›é€€: "chÅ« chÇ” jÃ¬n tuÃ¬",
    æ„å±±é—·æµ·: "chÃ³u shÄn mÃ¨n hÇŽi",
    å†²å† çœ¦è£‚: "chÅng guÃ n zÃ¬ liÃ¨",
    é½¿ç‰™ä¸ºç¥¸: "chÇ yÃ¡ wÃ©i huÃ²",
    å°ºäºŒå†¤å®¶: "chÇ Ã¨r yuÄn jia",
    å°ºçŸ­å¯¸é•¿: "chÇ duÇŽn cÃ¹n chÃ¡ng",
    å°ºå¯¸ä¹‹åŠŸ: "chÇ cÃ¹n zhÄ« gÅng",
    åŸŽåŒ—å¾å…¬: "chÃ©ng bÄ›i xÃº gÅng",
    æˆè´¥å…´åºŸ: "chÃ©ng bÃ i xÄ«ng fÃ¨i",
    è¶æ°´å’Œæ³¥: "chÃ¨n shuÇ huÃ² nÃ­",
    ç§°é›¨é“æ™´: "chÄ“ng yÇ” dÃ o qÃ­ng",
    ç§°ä½“è½½è¡£: "chÄ“ng tÇ zÃ i yÄ«",
    ç§°ä½“è£è¡£: "chÃ¨n tÇ cÃ¡i yÄ«",
    ç§°å®¶æœ‰æ— : "chÃ¨n jiÄ yÇ’u wÃº",
    ç§°å¾·åº¦åŠŸ: "chÄ“ng dÃ© duÃ³ gÅng",
    æ²‰åŸç« å¥: "chÃ©n yÃ­n zhÄng jÃ¹",
    æ²‰åŸä¸å†³: "chÃ©n yÃ­n bÃ¹ juÃ©",
    æ²‰ç–´å®¿ç–¾: "chÃ©n kÄ“ sÃ¹ jÃ­",
    æ‰¯çº¤æ‹‰çƒŸ: "chÄ› qiÃ n lÄ yÄn",
    æ‰¯é¡ºé£Žæ——: "chÄ› shÃ¹n fÄ“ng qÃ­",
    è½¦è½½èˆ¹è£…: "chÄ“ zÇŽi chuÃ¡n zhuÄng",
    æœå‡æš®åˆ: "zhÄo shÄ“ng mÃ¹ gÄ›",
    æœæ”€æš®æŠ˜: "zhÄo pÄn mÃ¹ shÃ©",
    è¶…ä»Šå† å¤: "chÄo jÄ«n guÃ n gÇ”",
    å€¡è€Œä¸å’Œ: "chÃ ng Ã©r bÃº hÃ¨",
    ç•…æ‰€æ¬²ä¸º: "chÃ ng suÇ’ yÃ¹ wÃ©i",
    è‹Œå¼˜ç¢§è¡€: "chÃ¡ng hÃ³ng bÃ¬ xiÄ›",
    é•¿å¹¼å°Šå‘: "zhÇŽng yÃ²u zÅ«n bÄ“i",
    é•¿ç»³ç³»æ—¥: "chÃ¡ng shÃ©ng jÃ¬ rÃ¬",
    é•¿å¹´ä¸‰è€: "zhÇŽng niÃ¡n sÄn lÇŽo",
    é•¿æ˜¥ä¸è€: "chÃ¡ng chÅ«n bÃ¹ lÇŽo",
    é•¿å‚²é¥°éž: "zhÇŽng Ã o shÃ¬ fÄ“i",
    æ˜Œäº­æ—…é£Ÿ: "chÄng tÃ­ng lÇš shÃ­",
    ç¦…çµ®æ²¾æ³¥: "chÃ¡n xÃ¹ zhÄn nÃ­",
    å·®ä¸‰é”™å››: "chÄ sÄn cuÃ² sÃ¬",
    å±‚å°ç´¯æ¦­: "cÃ©ng tÃ¡i lÄ›i xiÃ¨",
    å±‚è§è¿­å‡º: "cÃ©ng xiÃ n diÃ© chÅ«",
    è—è¸ªè¹‘è¿¹: "cÃ¡ng zÅng niÃ¨ jÃ¬",
    è‹è‡è§è¡€: "cÄng yÃ­ng jiÃ n xiÄ›",
    é¤æ¾å•–æŸ: "cÄn sÅng dÃ n bÃ³",
    éª–é£Žé©·éœž: "cÄn fÄ“ng sÃ¬ xiÃ¡",
    å‚ä¼é”™ç»¼: "cÄ“n wÇ” cuÃ² zÅng",
    å‚è¾°å¯é…‰: "shÄ“n chÃ©n mÇŽo yÇ’u",
    æä¼˜å¹²æµŽ: "cÃ¡i yÅu gÄn jÇ",
    æè–„è´¨è¡°: "cÃ¡i bÃ³ zhÃ¬ shuÄi",
    æ‰å¤§éš¾ç”¨: "cÃ¡i dÃ  nÃ¡n yÃ²ng",
    æ‰è–„æ™ºæµ…: "cÃ¡i bÃ³ zhÃ¬ qiÇŽn",
    ä¸è¶³ä¸ºæ„: "bÃ¹ zÃº wÃ©i yÃ¬",
    ä¸è¶³ä¸ºæ®: "bÃ¹ zÃº wÃ©i jÃ¹",
    ä¸è¶³ä¸ºæ³•: "bÃ¹ zÃº wÃ©i fÇŽ",
    ä¸è¶³é½¿æ•°: "bÃ¹ zÃº chÇ shÇ”",
    ä¸ç€ç–¼çƒ­: "bÃ¹ zhuÃ³ tÃ©ng rÃ¨",
    ä¸çŸ¥è–¡è•«: "bÃ¹ zhÄ« dÇng dÇ’ng",
    ä¸è¶Šé›·æ± : "bÃº yuÃ¨ lÃ©i chÃ­",
    ä¸ç›¸ä¸ºè°‹: "bÃ¹ xiÄng wÃ©i mÃ³u",
    ä¸è´ªä¸ºå®: "bÃ¹ tÄn wÃ©i bÇŽo",
    ä¸äº†è€Œäº†: "bÃ¹ liÇŽo Ã©r liÇŽo",
    ä¸å¯æ†åº¦: "bÃ¹ kÄ› kuÃ­ duÃ³",
    ä¸é‘å¯å¤„: "bÃ¹ huÃ¡ng qÇ chÇ”",
    ä¸å½“ä¸æ­£: "bÃ¹ dÄng bÃº zhÃ¨ng",
    ä¸å·®ä»€ä¹ˆ: "bÃº chÃ  shÃ©n me",
    ä¸å·®ç´¯é»: "bÃ¹ chÄ lÄ›i shÇ”",
    æ“˜ä¸¤åˆ†æ˜Ÿ: "bÃ² liÇŽng fÄ“n xÄ«ng",
    ç°¸åœŸæ‰¬æ²™: "bÇ’ tÇ” yÃ¡ng shÄ",
    è–„ç‰©ç»†æ•…: "bÃ³ wÃ¹ xÃ¬ gÃ¹",
    è–„å¯’ä¸­äºº: "bÃ³ hÃ¡n zhÃ²ng rÃ©n",
    åšæ–‡çº¦ç¤¼: "bÃ³ wÃ©n yuÄ“ lÇ",
    æ’­ç³ çœ¯ç›®: "bÅ kÄng mÃ­ mÃ¹",
    å‰¥çš®æŠ½ç­‹: "bÅ pÃ­ chÅu jÄ«n",
    å‰¥è‚¤æ¤Žé«“: "bÅ fÅ« chuÃ­ suÇ",
    æ³¢å±žäº‘å§”: "bÅ zhÇ” yÃºn wÄ›i",
    æ³¢éª‡äº‘å±ž: "bÅ hÃ i yÃºn zhÇ”",
    å…µå¾®å°†å¯¡: "bÄ«ng wÄ“i jiÃ ng guÇŽ",
    å…µå¼ºå°†å‹‡: "bÄ«ng qiÃ¡ng jiÃ ng yÇ’ng",
    å…µå¤šå°†å¹¿: "bÄ«ng duÅ jiÃ ng guÇŽng",
    å…µä¸ç”±å°†: "bÄ«ng bÃ¹ yÃ³u jiÃ ng",
    å†°è§£çš„ç ´: "bÄ«ng jiÄ› dÃ¬ pÃ²",
    å½¬å½¬æµŽæµŽ: "bÄ«n bÄ«n jÇ jÇ",
    æ‘½æ¢…ä¹‹å¹´: "biÃ o mÃ©i zhÄ« niÃ¡n",
    è¡¨é‡Œä¸ºå¥¸: "biÇŽo lÇ wÃ©i jiÄn",
    é£™å‘ç”µä¸¾: "biÄo fÄ diÃ n jÇ”",
    å˜è´ªåŽ‰è–„: "biÃ n tÄn lÃ¬ bÃ³",
    æ•ç›–ä¸å¼ƒ: "bÃ¬ gÃ i bÃº qÃ¬",
    ç§•è¨€è°¬è¯´: "bÇ yÃ¡n miÃ¹ shuÅ",
    æ¯”ç‰©å±žäº‹: "bÇ wÃ¹ zhÇ” shÃ¬",
    è¢«å±±å¸¦æ²³: "pÄ« shÄn dÃ i hÃ©",
    è¢«ç”²æž•æˆˆ: "pÄ« jiÇŽ zhÄ›n gÄ“",
    è¢«ç”²æ®éž: "pÄ« jiÇŽ jÃ¹ Än",
    è¢«è¤æ€€çŽ‰: "pÄ« hÃ¨ huÃ¡i yÃ¹",
    è¢«å‘ç¼¨å† : "pÄ« fÃ  yÄ«ng guÃ n",
    èƒŒæ›²è…°èº¬: "bÃ¨i qÇ” yÄo gÅng",
    åŒ—çª—é«˜å§: "bÄ›i chuÄng gÄo wÃ²",
    åŒ—è¾°æ˜Ÿæ‹±: "bÄ›i chÃ©n xÄ«ng gÇ’ng",
    åŒ—é„™ä¹‹éŸ³: "bÄ›i bÇ zhÄ« yÄ«n",
    å‘å®«è²é£Ÿ: "bÄ“i gÅng fÄ›i shÃ­",
    æš´è¡£éœ²å† : "pÃ¹ yÄ« lÃ¹ guÃ n",
    æš´è…®é¾™é—¨: "pÃ¹ sÄi lÃ³ng mÃ©n",
    æš´éœ²æ–‡å­¦: "bÃ o lÃ¹ wÃ©n xuÃ©",
    æš´è™Žå†¯æ²³: "bÃ o hÇ” pÃ­ng hÃ©",
    æŠ±è”“æ‘˜ç“œ: "bÃ o wÃ n zhÄi guÄ",
    æŠ±æ³•å¤„åŠ¿: "bÃ o fÇŽ chÇ” shÃ¬",
    è¤’è´¬ä¸Žå¤º: "bÄo biÇŽn yÇ” duÃ³",
    å¸®é—²é’»æ‡’: "bÄng xiÃ¡n zuÄn lÇŽn",
    æ‹œå°†å°ä¾¯: "bÃ i jiÃ ng fÄ“ng hÃ³u",
    ç™¾å…½çŽ‡èˆž: "bÇŽi shÃ²u shuÃ i wÇ”",
    ç™¾å­”åƒåˆ›: "bÇŽi kÇ’ng qiÄn chuÄng",
    ç™½è¡£å¿ç›¸: "bÃ¡i yÄ« qÄ«ng xiÃ ng",
    ç™½é¦–ä¸ºéƒŽ: "bÃ¡i shÇ’u wÃ©i lÃ¡ng",
    ç™½é¦–ç›¸çŸ¥: "bÃ¡i shÇ’u xiÄng zhÄ«",
    æŠŠçŽ©æ— åŽŒ: "bÇŽ wÃ¡n wÃº yÃ n",
    æ‹”é”…å·å¸­: "bÃ¡ guÅ juÇŽn xÃ­",
    æ‹”æœ¬å¡žæº: "bÃ¡ bÄ›n sÃ¨ yuÃ¡n",
    å‚²ä¸å¯é•¿: "Ã o bÃ¹ kÄ› zhÇŽng",
    ç†¬æ›´å®ˆå¤œ: "Ã¡o gÄ“ng shÇ’u yÃ¨",
    å®‰æ—¶å¤„é¡º: "Än shÃ­ chÇ” shÃ¹n",
    å®‰èº«ä¸ºä¹: "Än shÄ“n wÃ©i lÃ¨",
    å®‰è€æ€€å°‘: "Än lÇŽo huÃ¡i shÃ o",
    å®‰æ­¥å½“è½¦: "Än bÃ¹ dÃ ng chÄ“",
    çˆ±äººå¥½å£«: "Ã i rÃ©n hÃ o shÃ¬",
    çŸ®äººè§‚åœº: "ÇŽi rÃ©n guÄn chÇŽng",
    æ±é£Žç¼‰ç¼: "Ã¡i fÄ“ng jÄ« fÃ¨ng",
    æŒ¨å±±å¡žæµ·: "Äi shÄn sÃ¨ hÇŽi",
    é˜¿å®¶é˜¿ç¿: "Ä jiÄ Ä wÄ“ng",
    é˜¿å…šç›¸ä¸º: "Ä“ dÇŽng xiÄng wÃ©i",
    è¿½äº¡é€åŒ—: "zhuÄ« wÃ¡ng zhÃº bÄ›i",
    ç«¹ç¯®æ‰“æ°´: "zhÃº lÃ¡n dÃ¡ shuÇ",
    çŸ¥ç–¼ç€çƒ­: "zhÄ« tÃ©ng zhÃ¡o rÃ¨",
    è¯­ä¸æƒŠäºº: "yÇ” bÃ¹ jÄ«ng rÃ©n",
    äºŽä»Šä¸ºçƒˆ: "yÃº jÄ«n wÃ©i liÃ¨",
    ä¸€æ—¥ä¸‰çœ: "yÃ­ rÃ¬ sÄn xÇng",
    ç©´å±…é‡Žå¤„: "xuÃ© jÅ« yÄ› chÇ”",
    äº”è„Šå…­å…½: "wÇ” jÇ liÃ¹ shÃ²u",
    æ— å£°æ— è‡­: "wÃº shÄ“ng wÃº xiÃ¹",
    è°“äºˆä¸ä¿¡: "wÃ¨i yÃº bÃº xÃ¬n",
    èˆèº«ä¸ºå›½: "shÄ› shÄ“n wÃ©i guÃ³",
    æ€å¦»æ±‚å°†: "shÄ qÄ« qiÃº jiÃ ng",
    å¼ºä½œè§£äºº: "qiÇŽng zuÃ² jiÄ› rÃ©n",
    æ°”å†²æ–—ç‰›: "qÃ¬ chÅng dÇ’u niÃº",
    ä¸´æ·±å±¥è–„: "lÃ­n shÄ“n lÇš bÃ³",
    é’§å¤©å¹¿ä¹: "jÅ«n tiÄn guÇŽng yuÃ¨",
    è‰°éš¾ç«­è¹¶: "jiÄn nÃ¡n jiÃ© juÃ©",
    å¤¹ä¸ƒå¤¹å…«: "jiÄ qÄ« jiÄ bÄ",
    æ··æ··å™©å™©: "hÃºn hÃºn Ã¨ Ã¨",
    åŽšå¤è–„ä»Š: "hÃ²u gÇ” bÃ³ jÄ«n",
    é¬¼æ€•æ¶äºº: "guÇ pÃ  Ã¨ rÃ©n",
    ä¼½é©¬å°„çº¿: "gÄ mÇŽ shÃ¨ xiÃ n",
    ä½›å¤´ç€ç²ª: "fÃ³ tÃ³u zhuÃ³ fÃ¨n",
    å¥‰ä¸ºè‡³å®: "fÃ¨ng wÃ©i zhÃ¬ bÇŽo",
    ç™»å›æ‹œå°†: "dÄ“ng tÃ¡n bÃ i jiÃ ng",
    æ™¨æ˜å®šçœ: "chÃ©n hÅ«n dÃ¬ng xÇng",
    å¯Ÿå¯Ÿä¸ºæ˜Ž: "chÃ¡ chÃ¡ wÃ©i mÃ­ng",
    åšé—»å¼ºè¯†: "bÃ³ wÃ©n qiÃ¡ng zhÃ¬",
    é¿éš¾å°±æ˜“: "bÃ¬ nÃ¡n jiÃ¹ yÃ¬",
    äº†æ— ç”Ÿæœº: "liÇŽo wÃº shÄ“ng jÄ«",
    // ä¸€å­—ä¸å˜è°ƒçš„è¯è¯­ï¼Œå¦‚æžœè¯è¯­ä»…æœ‰å•ä¸ªä¸€ä¸”ä¸€å­—åœ¨ç»“å°¾çš„æ— éœ€æ·»åŠ ï¼ˆéœ€è¦å¢žè¡¥æ›´å¤šï¼‰
    æœ‰ä¸€è¯´ä¸€: "yÇ’u yÄ« shuÅ yÄ«",
    ç‹¬ä¸€æ— äºŒ: "dÃº yÄ« wÃº Ã¨r",
    è¯´ä¸€ä¸äºŒ: "shuÅ yÄ« bÃ¹ Ã¨r",
    ä¸¾ä¸€åä¸‰: "jÇ” yÄ« fÇŽn sÄn",
    æ•°ä¸€æ•°äºŒ: "shÇ” yÄ« shÇ” Ã¨r",
    æ€ä¸€å„†ç™¾: "shÄ yÄ« jÇng bÇŽi",
    ä¸ä¸€å¯äºŒ: "dÄ«ng yÄ« mÇŽo Ã¨r",
    ä¸ä¸€ç¡®äºŒ: "dÄ«ng yÄ« quÃ¨ Ã¨r",
    ä¸ä¸€è€Œæ­¢: "bÃ¹ yÄ« Ã©r zhÇ",
    æ— ä¸€å¹¸å…: "wÃº yÄ« xÃ¬ng miÇŽn",
    // æ¥æºï¼šhttps://m.gushici.com/cyxy_4e00_4
    è¡¨é‡Œä¸ä¸€: "biÇŽo lÇ bÃ¹ yÄ«",
    è‰¯èŽ ä¸ä¸€: "liÃ¡ng yÇ’u bÃ¹ yÄ«",
    å¿ƒå£ä¸ä¸€: "xÄ«n kÇ’u bÃ¹ yÄ«",
    è¨€è¡Œä¸ä¸€: "yÃ¡n xÃ­ng bÃ¹ yÄ«",
    æ”¿ä»¤ä¸ä¸€: "zhÃ¨ng lÃ¬ng bÃ¹ yÄ«",
    å‚å·®ä¸ä¸€: "cÄ“n cÄ« bÃ¹ yÄ«",
    çº·çº·ä¸ä¸€: "fÄ“n fÄ“n bÃ¹ yÄ«",
    æ¯èª‰ä¸ä¸€: "huÇ yÃ¹ bÃ¹ yÄ«",
    ä¸ä¸€è€Œä¸‰: "bÃ¹ yÄ« Ã©r sÄn",
    ç™¾ä¸ä¸€é‡: "bÇŽi bÃ¹ yÄ« yÃ¹",
    è¨€è¡ŒæŠ±ä¸€: "yÃ¡n xÃ­ng bÃ o yÄ«",
    ç‘œç™¾ç‘•ä¸€: "yÃº bÇŽi xiÃ¡ yÄ«",
    èƒŒåŸŽå€Ÿä¸€: "bÃ¨i chÃ©ng jiÃ¨ yÄ«",
    å‡­åŸŽå€Ÿä¸€: "pÃ­ng chÃ©ng jiÃ¨ yÄ«",
    åŠç™¾è®½ä¸€: "quÃ n bÇŽi fÄ›ng yÄ«",
    ç¾¤å±…å’Œä¸€: "qÃºn jÅ« hÃ© yÄ«",
    ç™¾ä¸èŽ·ä¸€: "bÇŽi bÃ¹ huÃ² yÄ«",
    ç™¾ä¸å¤±ä¸€: "bÇŽi bÃ¹ shÄ« yÄ«",
    ç™¾æ— å¤±ä¸€: "bÇŽi wÃº shÄ« yÄ«",
    ä¸‡ä¸å¤±ä¸€: "wÃ n bÃ¹ shÄ« yÄ«",
    ä¸‡æ— å¤±ä¸€: "wÃ n wÃº shÄ« yÄ«",
    åˆè€Œä¸ºä¸€: "hÃ© Ã©r wÃ©i yÄ«",
    åˆä¸¤ä¸ºä¸€: "hÃ© liÇŽng wÃ©i yÄ«",
    åˆäºŒä¸ºä¸€: "hÃ© Ã¨r wÃ©i yÄ«",
    å¤©ä¸‹ä¸ºä¸€: "tiÄn xiÃ  wÃ©i yÄ«",
    ç›¸ä¸Žä¸ºä¸€: "xiÄng yÇ” wÃ©i yÄ«",
    è¾ƒè‹¥ç”»ä¸€: "jiÃ o ruÃ² huÃ  yÄ«",
    è¾ƒå¦‚ç”»ä¸€: "jiÃ o rÃº huÃ  yÄ«",
    æ– è‹¥ç”»ä¸€: "jiÃ o ruÃ² huÃ  yÄ«",
    è¨€è¡Œè‹¥ä¸€: "yÃ¡n xÃ­ng ruÃ² yÄ«",
    å§‹ç»ˆè‹¥ä¸€: "shÇ zhÅng ruÃ² yÄ«",
    ç»ˆå§‹è‹¥ä¸€: "zhÅng shÇ ruÃ² yÄ«",
    æƒŸç²¾æƒŸä¸€: "wÃ©i jÄ«ng wÃ©i yÄ«",
    ä¼—å¤šéžä¸€: "zhÃ²ng duÅ fÄ“i yÄ«",
    ä¸èƒ½èµžä¸€: "bÃ¹ nÃ©ng zÃ n yÄ«",
    é—®ä¸€ç­”å: "wÃ¨n yÄ« dÃ¡ shÃ­",
    ä¸€ä¸æ‰­ä¼—: "yÄ« bÃ¹ niÇ” zhÃ²ng",
    ä¸€ä»¥è´¯ä¹‹: "yÄ« yÇ guÃ n zhÄ«",
    ä¸€ä»¥å½“ç™¾: "yÄ« yÇ dÄng bÇŽi",
    ç™¾ä¸å½“ä¸€: "bÇŽi bÃ¹ dÄng yÄ«",
    åä¸å½“ä¸€: "shÃ­ bÃ¹ dÄng yÄ«",
    ä»¥ä¸€è­¦ç™¾: "yÇ yÄ« jÇng bÇŽi",
    ä»¥ä¸€å¥‰ç™¾: "yÇ yÄ« fÃ¨ng bÇŽi",
    ä»¥ä¸€æŒä¸‡: "yÇ yÄ« chÃ­ wÃ n",
    ä»¥ä¸€çŸ¥ä¸‡: "yÇ yÄ« zhÄ« wÃ n",
    ç™¾é‡ŒæŒ‘ä¸€: "bÇŽi lÇ tiÄo yÄ«",
    æ•´é½åˆ’ä¸€: "zhÄ›ng qÃ­ huÃ  yÄ«",
    ä¸€æ¥äºŒåŽ»: "yÄ« lÃ¡i Ã¨r qÃ¹",
    ä¸€è·¯å…¬äº¤: "yÄ« lÃ¹ gÅng jiÄo",
    ä¸€è·¯æ±½è½¦: "yÄ« lÃ¹ qÃ¬ chÄ“",
    ä¸€è·¯å·´å£«: "yÄ« lÃ¹ bÄ shÃ¬",
    æœæœæœè½: "zhÄo chÃ¡o zhÄo luÃ²",
    æ›²æ„é€¢è¿Ž: "qÅ« yÃ¬ fÃ©ng yÃ­ng",
    ä¸€è¡Œä¸è¡Œ: "yÃ¬ hÃ¡ng bÃ¹ xÃ­ng",
    è¡Œè¡Œä¸è¡Œ: "hÃ¡ng hÃ¡ng bÃ¹ xÃ­ng"
  };
  const Pattern4 = Object.keys(DICT4).map((key) => ({
    zh: key,
    pinyin: DICT4[key],
    probability: 2e-8,
    length: 4,
    priority: Priority.Normal,
    dict: Symbol("dict4")
  }));
  const DICT5 = {
    å·´å°”å¹²åŠå²›: "bÄ Ä›r gÃ n bÃ n dÇŽo",
    å·´å°”å–€ä»€æ¹–: "bÄ Ä›r kÄ shÃ­ hÃº",
    ä¸å¹¸è€Œè¨€ä¸­: "bÃº xÃ¬ng Ã©r yÃ¡n zhÃ²ng",
    å¸ƒå°”ä»€ç»´å…‹: "bÃ¹ Ä›r shÃ­ wÃ©i kÃ¨",
    ä½•ä¹è€Œä¸ä¸º: "hÃ© lÃ¨ Ã©r bÃ¹ wÃ©i",
    è‹›æ”¿çŒ›äºŽè™Ž: "kÄ“ zhÃ¨ng mÄ›ng yÃº hÇ”",
    è’™å¾—ç»´çš„äºš: "mÃ©ng dÃ© wÃ©i dÃ¬ yÃ ",
    æ°‘ä»¥é£Ÿä¸ºå¤©: "mÃ­n yÇ shÃ­ wÃ©i tiÄn",
    äº‹åŽè¯¸è‘›äº®: "shÃ¬ hÃ²u zhÅ« gÄ› liÃ ng",
    ç‰©ä»¥ç¨€ä¸ºè´µ: "wÃ¹ yÇ xÄ« wÃ©i guÃ¬",
    å…ˆä¸‹æ‰‹ä¸ºå¼º: "xiÄn xiÃ  shÇ’u wÃ©i qiÃ¡ng",
    è¡Œè¡Œå‡ºçŠ¶å…ƒ: "hÃ¡ng hÃ¡ng chÅ« zhuÃ ng yuan",
    äºšå¾—é‡Œäºšæµ·: "yÃ  dÃ© lÇ yÃ  hÇŽi",
    çœ¼ä¸è§ä¸ºå‡€: "yÇŽn bÃº jiÃ n wÃ©i jÃ¬ng",
    ç«¹ç­’å€’è±†å­: "zhÃº tÇ’ng dÃ o dÃ²u zi"
  };
  const Pattern5 = Object.keys(DICT5).map((key) => ({
    zh: key,
    pinyin: DICT5[key],
    probability: 2e-8,
    length: 5,
    priority: Priority.Normal,
    dict: Symbol("dict5")
  }));
  function getMaxProbability(a2, b2) {
    if (!a2) {
      return b2;
    }
    if (a2.decimal < b2.decimal) {
      return a2;
    } else if (a2.decimal === b2.decimal) {
      return a2.probability > b2.probability ? a2 : b2;
    } else {
      return b2;
    }
  }
  function checkDecimal(prob) {
    if (prob.probability < 1e-300) {
      prob.probability *= 1e300;
      prob.decimal += 1;
    }
  }
  function getPatternDecimal(pattern2) {
    if (pattern2.priority === Priority.Custom) {
      return -(pattern2.length * pattern2.length * 100);
    }
    if (pattern2.priority === Priority.Surname) {
      return -(pattern2.length * pattern2.length * 10);
    }
    return 0;
  }
  function maxProbability(patterns, length) {
    const dp = [];
    let patternIndex = patterns.length - 1;
    let pattern2 = patterns[patternIndex];
    for (let i2 = length - 1; i2 >= 0; i2--) {
      const suffixDP = i2 + 1 >= length ? { probability: 1, decimal: 0, patterns: [] } : dp[i2 + 1];
      while (pattern2 && pattern2.index + pattern2.length - 1 === i2) {
        const startIndex = pattern2.index;
        const curDP = {
          probability: pattern2.probability * suffixDP.probability,
          decimal: suffixDP.decimal + getPatternDecimal(pattern2),
          patterns: suffixDP.patterns,
          concatPattern: pattern2
        };
        checkDecimal(curDP);
        dp[startIndex] = getMaxProbability(dp[startIndex], curDP);
        pattern2 = patterns[--patternIndex];
      }
      const iDP = {
        probability: 1e-13 * suffixDP.probability,
        decimal: 0,
        patterns: suffixDP.patterns
      };
      checkDecimal(iDP);
      dp[i2] = getMaxProbability(dp[i2], iDP);
      if (dp[i2].concatPattern) {
        dp[i2].patterns = dp[i2].patterns.concat(dp[i2].concatPattern);
        dp[i2].concatPattern = void 0;
        delete dp[i2 + 1];
      }
    }
    return dp[0].patterns.reverse();
  }
  function getMinCount(a2, b2) {
    if (!a2) {
      return b2;
    }
    return a2.count <= b2.count ? a2 : b2;
  }
  function getPatternCount(pattern2) {
    if (pattern2.priority === Priority.Custom) {
      return -(pattern2.length * pattern2.length * 1e5);
    }
    if (pattern2.priority === Priority.Surname) {
      return -(pattern2.length * pattern2.length * 100);
    }
    return 1;
  }
  function minTokenization(patterns, length) {
    const dp = [];
    let patternIndex = patterns.length - 1;
    let pattern2 = patterns[patternIndex];
    for (let i2 = length - 1; i2 >= 0; i2--) {
      const suffixDP = i2 + 1 >= length ? { count: 0, patterns: [] } : dp[i2 + 1];
      while (pattern2 && pattern2.index + pattern2.length - 1 === i2) {
        const startIndex = pattern2.index;
        const curDP = {
          count: getPatternCount(pattern2) + suffixDP.count,
          patterns: suffixDP.patterns,
          concatPattern: pattern2
        };
        dp[startIndex] = getMinCount(dp[startIndex], curDP);
        pattern2 = patterns[--patternIndex];
      }
      const iDP = {
        count: 1 + suffixDP.count,
        patterns: suffixDP.patterns
      };
      dp[i2] = getMinCount(dp[i2], iDP);
      if (dp[i2].concatPattern) {
        dp[i2].patterns = dp[i2].patterns.concat(dp[i2].concatPattern);
        dp[i2].concatPattern = void 0;
        delete dp[i2 + 1];
      }
    }
    return dp[0].patterns.reverse();
  }
  function isIgnorablePattern(cur, pre) {
    if (pre.index + pre.length <= cur.index) {
      return false;
    }
    if (pre.priority > cur.priority) {
      return false;
    }
    if (pre.priority === cur.priority && pre.length > cur.length) {
      return false;
    }
    return true;
  }
  function reverseMaxMatch(patterns) {
    const filteredArr = [];
    for (let i2 = patterns.length - 1; i2 >= 0; ) {
      const { index } = patterns[i2];
      let j2 = i2 - 1;
      while (j2 >= 0 && isIgnorablePattern(patterns[i2], patterns[j2])) {
        j2--;
      }
      if (j2 < 0 || patterns[j2].index + patterns[j2].length <= index) {
        filteredArr.push(patterns[i2]);
      }
      i2 = j2;
    }
    return filteredArr.reverse();
  }
  var TokenizationAlgorithm;
  (function(TokenizationAlgorithm2) {
    TokenizationAlgorithm2[TokenizationAlgorithm2["ReverseMaxMatch"] = 1] = "ReverseMaxMatch";
    TokenizationAlgorithm2[TokenizationAlgorithm2["MaxProbability"] = 2] = "MaxProbability";
    TokenizationAlgorithm2[TokenizationAlgorithm2["MinTokenization"] = 3] = "MinTokenization";
  })(TokenizationAlgorithm || (TokenizationAlgorithm = {}));
  class TrieNode {
    constructor(parent, prefix = "", key = "") {
      this.children = /* @__PURE__ */ new Map();
      this.fail = null;
      this.patterns = [];
      this.parent = parent;
      this.prefix = prefix;
      this.key = key;
    }
  }
  class AC {
    constructor() {
      this.dictMap = /* @__PURE__ */ new Map();
      this.queues = [];
      this.root = new TrieNode(null);
    }
    build(patternList) {
      this.buildTrie(patternList);
      this.buildFailPointer();
    }
    // æž„å»º trie æ ‘
    buildTrie(patternList) {
      for (let pattern2 of patternList) {
        const zhChars = splitString(pattern2.zh);
        let cur = this.root;
        for (let i2 = 0; i2 < zhChars.length; i2++) {
          let c2 = zhChars[i2];
          if (!cur.children.has(c2)) {
            const trieNode = new TrieNode(cur, zhChars.slice(0, i2).join(""), c2);
            cur.children.set(c2, trieNode);
            this.addNodeToQueues(trieNode);
          }
          cur = cur.children.get(c2);
        }
        this.insertPattern(cur.patterns, pattern2);
        pattern2.node = cur;
        this.addPatternToDictMap(pattern2);
      }
    }
    // æž„å»ºå¤±è´¥æŒ‡é’ˆ
    buildFailPointer() {
      let queue = [];
      let queueIndex = 0;
      this.queues.forEach((_queue) => {
        queue = queue.concat(_queue);
      });
      this.queues = [];
      while (queue.length > queueIndex) {
        let node = queue[queueIndex++];
        let failNode = node.parent && node.parent.fail;
        let key = node.key;
        while (failNode && !failNode.children.has(key)) {
          failNode = failNode.fail;
        }
        if (!failNode) {
          node.fail = this.root;
        } else {
          node.fail = failNode.children.get(key);
        }
      }
    }
    // å°† pattern æ·»åŠ åˆ° dictMap ä¸­
    addPatternToDictMap(pattern2) {
      if (!this.dictMap.has(pattern2.dict)) {
        this.dictMap.set(pattern2.dict, /* @__PURE__ */ new Set());
      }
      this.dictMap.get(pattern2.dict).add(pattern2);
    }
    addNodeToQueues(trieNode) {
      if (!this.queues[stringLength(trieNode.prefix)]) {
        this.queues[stringLength(trieNode.prefix)] = [];
      }
      this.queues[stringLength(trieNode.prefix)].push(trieNode);
    }
    // æŒ‰ç…§ä¼˜å…ˆçº§æ’å…¥ pattern
    insertPattern(patterns, pattern2) {
      for (let i2 = patterns.length - 1; i2 >= 0; i2--) {
        const _pattern = patterns[i2];
        if (pattern2.priority === _pattern.priority && pattern2.probability >= _pattern.probability) {
          patterns[i2 + 1] = _pattern;
        } else if (pattern2.priority > _pattern.priority) {
          patterns[i2 + 1] = _pattern;
        } else {
          patterns[i2 + 1] = pattern2;
          return;
        }
      }
      patterns[0] = pattern2;
    }
    removeDict(dictName) {
      if (this.dictMap.has(dictName)) {
        const set2 = this.dictMap.get(dictName);
        set2.forEach((pattern2) => {
          pattern2.node.patterns = pattern2.node.patterns.filter((_pattern) => _pattern !== pattern2);
        });
        this.dictMap.delete(dictName);
      }
    }
    // æœç´¢å­—ç¬¦ä¸²è¿”å›žåŒ¹é…çš„æ¨¡å¼ä¸²
    match(text, surname) {
      let cur = this.root;
      let result = [];
      const zhChars = splitString(text);
      for (let i2 = 0; i2 < zhChars.length; i2++) {
        let c2 = zhChars[i2];
        while (cur !== null && !cur.children.has(c2)) {
          cur = cur.fail;
        }
        if (cur === null) {
          cur = this.root;
        } else {
          cur = cur.children.get(c2);
          const pattern2 = cur.patterns.find((item) => {
            if (surname === "off") {
              return item.priority !== Priority.Surname;
            } else if (surname === "head") {
              return item.length - 1 - i2 === 0;
            } else {
              return true;
            }
          });
          if (pattern2) {
            result.push(Object.assign(Object.assign({}, pattern2), { index: i2 - pattern2.length + 1 }));
          }
          let failNode = cur.fail;
          while (failNode !== null) {
            const pattern3 = failNode.patterns.find((item) => {
              if (surname === "off") {
                return item.priority !== Priority.Surname;
              } else if (surname === "head") {
                return item.length - 1 - i2 === 0;
              } else {
                return true;
              }
            });
            if (pattern3) {
              result.push(Object.assign(Object.assign({}, pattern3), { index: i2 - pattern3.length + 1 }));
            }
            failNode = failNode.fail;
          }
        }
      }
      return result;
    }
    search(text, surname, algorithm = 2) {
      const patterns = this.match(text, surname);
      if (algorithm === 1) {
        return reverseMaxMatch(patterns);
      } else if (algorithm === 3) {
        return minTokenization(patterns, stringLength(text));
      }
      return maxProbability(patterns, stringLength(text));
    }
  }
  const PatternsNormal = [
    ...Pattern5,
    ...Pattern4,
    ...Pattern3,
    ...Pattern2,
    ...PatternNumberDict,
    ...PatternSurname
  ];
  const acTree = new AC();
  acTree.build(PatternsNormal);
  const customMultipleDict = new FastDictFactory();
  const getCustomMultpileDict = () => {
    return customMultipleDict;
  };
  const getSingleWordPinyin = (char) => {
    const pinyin2 = DICT1.get(char);
    return pinyin2 ? pinyin2.split(" ")[0] : char;
  };
  const getPinyin = (word, list, surname, segmentit) => {
    const matches = acTree.search(word, surname, segmentit);
    let matchIndex = 0;
    const zhChars = splitString(word);
    for (let i2 = 0; i2 < zhChars.length; ) {
      const match = matches[matchIndex];
      if (match && i2 === match.index) {
        if (match.length === 1 && match.priority <= Priority.Normal) {
          const char = zhChars[i2];
          let pinyin2 = "";
          pinyin2 = processSepecialPinyin(char, zhChars[i2 - 1], zhChars[i2 + 1]);
          list[i2] = {
            origin: char,
            result: pinyin2,
            isZh: pinyin2 !== char,
            originPinyin: pinyin2
          };
          i2++;
          matchIndex++;
          continue;
        }
        const pinyins = match.pinyin.split(" ");
        let pinyinIndex = 0;
        for (let j2 = 0; j2 < match.length; j2++) {
          const zhChars2 = splitString(match.zh);
          list[i2 + j2] = {
            origin: zhChars2[j2],
            result: pinyins[pinyinIndex],
            isZh: true,
            originPinyin: pinyins[pinyinIndex]
          };
          pinyinIndex++;
        }
        i2 += match.length;
        matchIndex++;
      } else {
        const char = zhChars[i2];
        let pinyin2 = "";
        pinyin2 = processSepecialPinyin(char, zhChars[i2 - 1], zhChars[i2 + 1]);
        list[i2] = {
          origin: char,
          result: pinyin2,
          isZh: pinyin2 !== char,
          originPinyin: pinyin2
        };
        i2++;
      }
    }
    return { list, matches };
  };
  const getPinyinWithoutTone = (pinyin2) => {
    return pinyin2.replace(/(Ä|Ã¡|ÇŽ|Ã )/g, "a").replace(/(Å|Ã³|Ç’|Ã²)/g, "o").replace(/(Ä“|Ã©|Ä›|Ã¨)/g, "e").replace(/(Ä«|Ã­|Ç|Ã¬)/g, "i").replace(/(Å«|Ãº|Ç”|Ã¹)/g, "u").replace(/(Ç–|Ç˜|Çš|Çœ)/g, "Ã¼").replace(/(nÌ„|Å„|Åˆ|Ç¹)/g, "n").replace(/(mÌ„|á¸¿|mÌŒ|mÌ€)/g, "m").replace(/(ÃªÌ„|áº¿|ÃªÌŒ|á»)/g, "Ãª");
  };
  const getAllPinyin = (char, surname = "off") => {
    const customMultpileDict = getCustomMultpileDict();
    let pinyin2 = DICT1.get(char) ? DICT1.get(char).split(" ") : [];
    if (customMultpileDict.get(char)) {
      pinyin2 = customMultpileDict.get(char).split(" ");
    } else if (surname !== "off") {
      const surnamePinyin = Surnames[char];
      if (surnamePinyin) {
        pinyin2 = [surnamePinyin].concat(pinyin2.filter((py) => py !== surnamePinyin));
      }
    }
    return pinyin2;
  };
  const getMultiplePinyin = (word, surname = "off") => {
    let pinyin2 = getAllPinyin(word, surname);
    if (pinyin2.length > 0) {
      return pinyin2.map((value) => ({
        origin: word,
        result: value,
        isZh: true,
        originPinyin: value
      }));
    } else {
      return [
        {
          origin: word,
          result: word,
          isZh: false,
          originPinyin: word
        }
      ];
    }
  };
  const getInitialAndFinal = (pinyin2) => {
    const pinyin_arr = pinyin2.split(" ");
    const initial_arr = [];
    const final_arr = [];
    for (let _pinyin of pinyin_arr) {
      for (let _initial of InitialList) {
        if (_pinyin.startsWith(_initial)) {
          let _final = _pinyin.slice(_initial.length);
          if (SpecialInitialList.indexOf(_initial) !== -1 && SpecialFinalList.indexOf(_final) !== -1) {
            _final = SpecialFinalMap[_final];
          }
          initial_arr.push(_initial);
          final_arr.push(_final);
          break;
        }
      }
    }
    return {
      final: final_arr.join(" "),
      initial: initial_arr.join(" ")
      // å£°æ¯
    };
  };
  const getFinalParts = (pinyin2) => {
    const { final } = getInitialAndFinal(pinyin2);
    let head = "", body = "", tail = "";
    if (doubleFinalList.indexOf(getPinyinWithoutTone(final)) !== -1) {
      head = final[0];
      body = final[1];
      tail = final.slice(2);
    } else {
      body = final[0] || "";
      tail = final.slice(1) || "";
    }
    return { head, body, tail };
  };
  const getNumOfTone = (pinyin2) => {
    const reg_tone1 = /(Ä|Å|Ä“|Ä«|Å«|Ç–|nÌ„|mÌ„|ÃªÌ„)/;
    const reg_tone2 = /(Ã¡|Ã³|Ã©|Ã­|Ãº|Ç˜|Å„|á¸¿|áº¿)/;
    const reg_tone3 = /(ÇŽ|Ç’|Ä›|Ç|Ç”|Çš|Åˆ|mÌŒ|ÃªÌŒ)/;
    const reg_tone4 = /(Ã |Ã²|Ã¨|Ã¬|Ã¹|Çœ|Ç¹|mÌ€|á»)/;
    const reg_tone0 = /(a|o|e|i|u|Ã¼|Ãª)/;
    const special_tone = /(n|m)$/;
    const tone_num_arr = [];
    const pinyin_arr = pinyin2.split(" ");
    pinyin_arr.forEach((_pinyin) => {
      if (reg_tone1.test(_pinyin)) {
        tone_num_arr.push("1");
      } else if (reg_tone2.test(_pinyin)) {
        tone_num_arr.push("2");
      } else if (reg_tone3.test(_pinyin)) {
        tone_num_arr.push("3");
      } else if (reg_tone4.test(_pinyin)) {
        tone_num_arr.push("4");
      } else if (reg_tone0.test(_pinyin)) {
        tone_num_arr.push("0");
      } else if (special_tone.test(_pinyin)) {
        tone_num_arr.push("0");
      } else {
        tone_num_arr.push("");
      }
    });
    return tone_num_arr.join(" ");
  };
  const getPinyinWithNum = (pinyin2, originPinyin) => {
    const pinyin_arr = getPinyinWithoutTone(pinyin2).split(" ");
    const tone_num_arr = getNumOfTone(originPinyin).split(" ");
    const res_arr = [];
    pinyin_arr.forEach((item, index) => {
      res_arr.push(`${item}${tone_num_arr[index]}`);
    });
    return res_arr.join(" ");
  };
  const getFirstLetter = (pinyin2, isZh) => {
    const first_letter_arr = [];
    const pinyin_arr = pinyin2.split(" ");
    pinyin_arr.forEach((pinyin3) => {
      first_letter_arr.push(isZh ? pinyin3[0] : pinyin3);
    });
    return first_letter_arr.join(" ");
  };
  const validateType = (word) => {
    if (typeof word !== "string") {
      formatAppLog("error", "at node_modules/pinyin-pro/dist/index.mjs:24201", "The first param of pinyin is error: " + word + ' is not assignable to type "string".');
      return false;
    } else {
      return true;
    }
  };
  function isNonZhScope(char, scope) {
    if (scope instanceof RegExp) {
      return scope.test(char);
    }
    return true;
  }
  const middleWareNonZh = (list, options) => {
    let nonZh = options.nonZh;
    if (nonZh === "removed") {
      return list.filter((item) => item.isZh || !isNonZhScope(item.origin, options.nonZhScope));
    } else if (nonZh === "consecutive") {
      for (let i2 = list.length - 2; i2 >= 0; i2--) {
        const cur = list[i2];
        const pre = list[i2 + 1];
        if (!cur.isZh && !pre.isZh && isNonZhScope(cur.origin, options.nonZhScope) && isNonZhScope(pre.origin, options.nonZhScope)) {
          cur.origin += pre.origin;
          cur.result += pre.result;
          pre.delete = true;
        }
      }
      return list.filter((item) => !item.delete);
    } else {
      return list;
    }
  };
  const middlewareMultiple = (word, options) => {
    if (stringLength(word) === 1 && options.multiple) {
      return getMultiplePinyin(word, options.surname);
    } else {
      return false;
    }
  };
  const middlewarePattern = (list, options) => {
    switch (options.pattern) {
      case "pinyin":
        break;
      case "num":
        list.forEach((item) => {
          item.result = item.isZh ? getNumOfTone(item.result) : "";
        });
        break;
      case "initial":
        list.forEach((item) => {
          item.result = item.isZh ? getInitialAndFinal(item.result).initial : "";
        });
        break;
      case "final":
        list.forEach((item) => {
          item.result = item.isZh ? getInitialAndFinal(item.result).final : "";
        });
        break;
      case "first":
        list.forEach((item) => {
          item.result = getFirstLetter(item.result, item.isZh);
        });
        break;
      case "finalHead":
        list.forEach((item) => {
          item.result = item.isZh ? getFinalParts(item.result).head : "";
        });
        break;
      case "finalBody":
        list.forEach((item) => {
          item.result = item.isZh ? getFinalParts(item.result).body : "";
        });
        break;
      case "finalTail":
        list.forEach((item) => {
          item.result = item.isZh ? getFinalParts(item.result).tail : "";
        });
        break;
    }
  };
  const middlewareToneType = (list, options) => {
    switch (options.toneType) {
      case "symbol":
        break;
      case "none":
        list.forEach((item) => {
          if (item.isZh) {
            item.result = getPinyinWithoutTone(item.result);
          }
        });
        break;
      case "num": {
        list.forEach((item) => {
          if (item.isZh) {
            item.result = getPinyinWithNum(item.result, item.originPinyin);
          }
        });
        break;
      }
    }
  };
  const middlewareV = (list, options) => {
    if (options.v) {
      list.forEach((item) => {
        if (item.isZh) {
          item.result = item.result.replace(/Ã¼/g, "v");
        }
      });
    }
  };
  const middlewareType = (list, options, word) => {
    if (options.multiple && stringLength(word) === 1) {
      let last = "";
      list = list.filter((item) => {
        const res = item.result !== last;
        last = item.result;
        return res;
      });
    }
    if (options.type === "array") {
      return list.map((item) => item.result);
    }
    if (options.type === "all") {
      return list.map((item) => {
        const pinyin2 = item.isZh ? item.result : "";
        const { initial, final } = getInitialAndFinal(pinyin2);
        const { head, body, tail } = getFinalParts(pinyin2);
        let polyphonic = [];
        if (pinyin2 !== "") {
          polyphonic = [pinyin2].concat(getAllPinyin(item.origin, options.surname).filter((item2) => item2 !== pinyin2));
        }
        return {
          origin: item.origin,
          pinyin: pinyin2,
          initial,
          final,
          first: getFirstLetter(item.result, item.isZh),
          finalHead: head,
          finalBody: body,
          finalTail: tail,
          num: Number(getNumOfTone(item.originPinyin)),
          isZh: item.isZh,
          polyphonic,
          inZhRange: !!DICT1.get(item.origin),
          result: item.result
        };
      });
    }
    return list.map((item) => item.result).join(options.separator);
  };
  const middlewareToneSandhi = (list, toneSandhi) => {
    if (toneSandhi === false) {
      list.forEach((item) => {
        if (item.origin === "ä¸€") {
          item.result = item.originPinyin = "yÄ«";
        } else if (item.origin === "ä¸") {
          item.result = item.originPinyin = "bÃ¹";
        }
      });
    }
    return list;
  };
  const DEFAULT_OPTIONS$2 = {
    pattern: "pinyin",
    toneType: "symbol",
    type: "string",
    multiple: false,
    mode: "normal",
    removeNonZh: false,
    nonZh: "spaced",
    v: false,
    separator: " ",
    toneSandhi: true,
    segmentit: 2
  };
  function pinyin(word, options) {
    options = Object.assign(Object.assign({}, DEFAULT_OPTIONS$2), options || {});
    const legal = validateType(word);
    if (!legal) {
      return word;
    }
    if (word === "") {
      return options.type === "array" || options.type === "all" ? [] : "";
    }
    if (options.surname === void 0) {
      if (options.mode === "surname") {
        options.surname = "all";
      } else {
        options.surname = "off";
      }
    }
    if (options.type === "all") {
      options.pattern = "pinyin";
    }
    if (options.pattern === "num") {
      options.toneType = "none";
    }
    if (options.removeNonZh) {
      options.nonZh = "removed";
    }
    let _list = Array(stringLength(word));
    let { list } = getPinyin(word, _list, options.surname, options.segmentit);
    list = middlewareToneSandhi(list, options.toneSandhi);
    list = middleWareNonZh(list, options);
    if (middlewareMultiple(word, options)) {
      list = middlewareMultiple(word, options);
    }
    middlewarePattern(list, options);
    middlewareToneType(list, options);
    middlewareV(list, options);
    return middlewareType(list, options, word);
  }
  var OutputFormat;
  (function(OutputFormat2) {
    OutputFormat2[OutputFormat2["AllSegment"] = 1] = "AllSegment";
    OutputFormat2[OutputFormat2["AllArray"] = 2] = "AllArray";
    OutputFormat2[OutputFormat2["AllString"] = 3] = "AllString";
    OutputFormat2[OutputFormat2["PinyinSegment"] = 4] = "PinyinSegment";
    OutputFormat2[OutputFormat2["PinyinArray"] = 5] = "PinyinArray";
    OutputFormat2[OutputFormat2["PinyinString"] = 6] = "PinyinString";
    OutputFormat2[OutputFormat2["ZhSegment"] = 7] = "ZhSegment";
    OutputFormat2[OutputFormat2["ZhArray"] = 8] = "ZhArray";
    OutputFormat2[OutputFormat2["ZhString"] = 9] = "ZhString";
  })(OutputFormat || (OutputFormat = {}));
  ({
    toneType: "symbol",
    mode: "normal",
    nonZh: "spaced",
    v: false,
    separator: " ",
    toneSandhi: true,
    segmentit: 2,
    format: OutputFormat.AllSegment
  });
  const createGroup = (params, missionid) => {
    return request({
      url: "/group/create",
      method: "post",
      data: params,
      missionId: missionid
    });
  };
  const _sfc_main$2 = {
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const contactsStore = useContactsStore();
      const userStore = useUserStore();
      const searchKeyword = vue.ref("");
      const selectedContacts = vue.ref([]);
      const popup2 = vue.ref(null);
      const isLoading = vue.ref(true);
      vue.onMounted(async () => {
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:106", "åˆ›å»ºç¾¤èŠç»„ä»¶å·²æŒ‚è½½");
        isLoading.value = true;
        await loadCachedContacts();
        await fetchContacts();
        isLoading.value = false;
        vue.nextTick(() => {
          const scrollView = document.querySelector(".contacts-list");
          if (scrollView) {
            scrollView.scrollTop = 0;
          }
        });
      });
      const filteredContacts = vue.computed(() => {
        const contacts = contactsStore.userInformationVOList || [];
        if (!searchKeyword.value)
          return contacts;
        return contacts.filter(
          (contact) => contact.name.toLowerCase().includes(searchKeyword.value.toLowerCase())
        );
      });
      const getFirstLetter2 = (name) => {
        const pinyinResult = pinyin(name, { pattern: "first", toneType: "none" });
        return pinyinResult.charAt(0).toUpperCase();
      };
      const groupedContacts = vue.computed(() => {
        const groups = {};
        filteredContacts.value.forEach((contact) => {
          const firstLetter = getFirstLetter2(contact.name);
          if (!groups[firstLetter]) {
            groups[firstLetter] = [];
          }
          groups[firstLetter].push(contact);
        });
        return groups;
      });
      const sortedLetters = vue.computed(() => {
        return Object.keys(groupedContacts.value).sort();
      });
      const handleBack = () => {
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:155", "è¿”å›žæŒ‰é’®è¢«ç‚¹å‡»");
        navigateToContacts();
      };
      const handleSearch = () => {
      };
      const toggleSelect = (contact) => {
        const index = selectedContacts.value.findIndex((c2) => c2.id === contact.id);
        if (index === -1) {
          selectedContacts.value.push(contact);
        } else {
          selectedContacts.value.splice(index, 1);
        }
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:172", "å·²é€‰æ‹©çš„è”ç³»äºº:", selectedContacts.value);
      };
      const isSelected = (contactId) => {
        return selectedContacts.value.some((contact) => contact.id === contactId);
      };
      const handleComplete = () => {
        if (selectedContacts.value.length === 0)
          return;
        popup2.value.open();
      };
      const confirmGroupName = (name) => {
        if (!name) {
          uni.showToast({
            title: "ç¾¤èŠåç§°ä¸èƒ½ä¸ºç©º",
            icon: "none"
          });
          return;
        }
        const groupData = {
          groupMemberIds: [...selectedContacts.value.map((contact) => contact.id)],
          groupName: name,
          missionId: userStore.state.missionId[0]
        };
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:204", groupData, "groupData");
        createGroup(groupData, groupData.missionId).then((response) => {
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:208", "ç¾¤èŠåˆ›å»ºæˆåŠŸ:", response);
          uni.showToast({
            title: "ç¾¤èŠåˆ›å»ºæˆåŠŸ",
            icon: "success"
          });
          contactsStore.incrementContactsUpdateCounter();
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:215", "ç¾¤èŠåˆ›å»ºæˆåŠŸï¼Œå‡†å¤‡è¿”å›ž");
          setTimeout(() => {
            navigateToContacts();
          }, 100);
        }).catch((error) => {
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:221", "åˆ›å»ºç¾¤èŠå¤±è´¥:", error);
          uni.showToast({
            title: "åˆ›å»ºç¾¤èŠå¤±è´¥",
            icon: "none"
          });
        });
      };
      const closePopup = () => {
        popup2.value.close();
      };
      const loadCachedContacts = async () => {
        const cachedContacts = uni.getStorageSync("cachedContacts");
        if (cachedContacts) {
          contactsStore.setUserInformationVOList(JSON.parse(cachedContacts));
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:239", "å·²åŠ è½½ç¼“å­˜çš„è”ç³»äººæ•°æ®");
        }
      };
      const fetchContacts = async () => {
        try {
          const response = await getMissionAddressBook(userStore.state.missionId[0]);
          if (response.code === 200) {
            contactsStore.setUserInformationVOList(response.data.userInformationVOList);
            uni.setStorageSync("cachedContacts", JSON.stringify(response.data.userInformationVOList));
            formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:250", "å·²æ›´æ–°è”ç³»äººæ•°æ®");
          } else {
            throw new Error(response.msg || "èŽ·å–è”ç³»äººå¤±è´¥");
          }
        } catch (error) {
          formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:255", "èŽ·å–è”ç³»äººå‡ºé”™:", error);
        }
      };
      const navigateToContacts = () => {
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:265", "å‡†å¤‡å¯¼èˆªåˆ°è”ç³»äººé¡µé¢");
        const pages2 = getCurrentPages();
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:267", "å½“å‰é¡µé¢æ ˆ:", pages2.map((page) => page.route));
        if (pages2.length > 1) {
          uni.navigateBack({
            delta: 1,
            success: () => {
              formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:273", "æˆåŠŸè¿”å›žåˆ°è”ç³»äººé¡µé¢");
            },
            fail: (error) => {
              formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:276", "è¿”å›žå¤±è´¥:", error);
              fallbackToRedirect();
            }
          });
        } else {
          fallbackToRedirect();
        }
      };
      const fallbackToRedirect = () => {
        formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:287", "å°è¯•é‡å®šå‘åˆ°è”ç³»äººé¡µé¢");
        uni.redirectTo({
          url: "/pages/tabBar/tabBar",
          success: () => {
            formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:291", "æˆåŠŸé‡å®šå‘åˆ°è”ç³»äººé¡µé¢");
          },
          fail: (redirectError) => {
            formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:294", "é‡å®šå‘å¤±è´¥:", redirectError);
            formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:295", "å°è¯•é‡æ–°å¯åŠ¨åˆ°è”ç³»äººé¡µé¢");
            uni.reLaunch({
              url: "/pages/tabBar/tabBar",
              success: () => {
                formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:299", "æˆåŠŸé‡æ–°å¯åŠ¨åˆ°è”ç³»äººé¡µé¢");
              },
              fail: (reLaunchError) => {
                formatAppLog("log", "at pages/contacts/pages/contacts/create-group-chat/index.vue:302", "é‡æ–°å¯åŠ¨å¤±è´¥:", reLaunchError);
              }
            });
          }
        });
      };
      const __returned__ = { contactsStore, userStore, searchKeyword, selectedContacts, popup: popup2, isLoading, filteredContacts, getFirstLetter: getFirstLetter2, groupedContacts, sortedLetters, handleBack, handleSearch, toggleSelect, isSelected, handleComplete, confirmGroupName, closePopup, loadCachedContacts, fetchContacts, navigateToContacts, fallbackToRedirect, ref: vue.ref, computed: vue.computed, onMounted: vue.onMounted, nextTick: vue.nextTick, get useContactsStore() {
        return useContactsStore;
      }, get useUserStore() {
        return useUserStore;
      }, get pinyin() {
        return pinyin;
      }, get createGroup() {
        return createGroup;
      }, get getMissionAddressBook() {
        return getMissionAddressBook;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_uni_nav_bar = resolveEasycom(vue.resolveDynamicComponent("uni-nav-bar"), __easycom_0$3);
    const _component_uni_popup_dialog = resolveEasycom(vue.resolveDynamicComponent("uni-popup-dialog"), __easycom_1);
    const _component_uni_popup = resolveEasycom(vue.resolveDynamicComponent("uni-popup"), __easycom_2$1);
    return vue.openBlock(), vue.createElementBlock("view", { class: "group-chat-container" }, [
      vue.createCommentVNode(" é¡¶éƒ¨å¯¼èˆªæ  "),
      vue.createVNode(_component_uni_nav_bar, {
        fixed: true,
        "status-bar": "",
        "left-icon": "left",
        onClickLeft: $setup.handleBack,
        title: "å‘èµ·ç¾¤èŠ"
      }, {
        right: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "nav-right" }, [
            vue.createElementVNode("button", {
              class: vue.normalizeClass(["complete-btn", { "active": $setup.selectedContacts.length > 0 }]),
              disabled: $setup.selectedContacts.length === 0,
              onClick: $setup.handleComplete
            }, " å®Œæˆ ", 10, ["disabled"])
          ])
        ]),
        _: 1
        /* STABLE */
      }),
      vue.createCommentVNode(" æœç´¢æ¡† "),
      vue.createElementVNode("view", { class: "search-container" }, [
        vue.createElementVNode("view", { class: "search-box" }, [
          vue.createElementVNode("image", {
            class: "search-icon",
            src: _imports_0$1,
            mode: "aspectFit"
          }),
          vue.withDirectives(vue.createElementVNode(
            "input",
            {
              class: "search-input",
              type: "text",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.searchKeyword = $event),
              placeholder: "æœç´¢",
              onInput: $setup.handleSearch
            },
            null,
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vue.vModelText, $setup.searchKeyword]
          ])
        ])
      ]),
      vue.createCommentVNode(" åŠ è½½çŠ¶æ€ "),
      $setup.isLoading ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "loading"
      }, "åŠ è½½ä¸­...")) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" è”ç³»äººåˆ—è¡¨ "),
      !$setup.isLoading ? (vue.openBlock(), vue.createElementBlock("scroll-view", {
        key: 1,
        class: "contacts-list",
        "scroll-y": ""
      }, [
        $setup.filteredContacts.length > 0 ? (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          { key: 0 },
          vue.renderList($setup.sortedLetters, (letter) => {
            return vue.openBlock(), vue.createElementBlock("view", { key: letter }, [
              vue.createElementVNode(
                "view",
                { class: "letter-index" },
                vue.toDisplayString(letter),
                1
                /* TEXT */
              ),
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList($setup.groupedContacts[letter], (contact) => {
                  return vue.openBlock(), vue.createElementBlock("view", {
                    key: contact.id,
                    class: "contact-item",
                    onClick: ($event) => $setup.toggleSelect(contact)
                  }, [
                    vue.createElementVNode("checkbox", {
                      checked: $setup.isSelected(contact.id),
                      value: contact.id,
                      class: "checkbox"
                    }, null, 8, ["checked", "value"]),
                    vue.createElementVNode("image", {
                      class: "avatar",
                      src: contact.avatarUrl || "/static/message/é»˜è®¤å¤´åƒ.png",
                      mode: "aspectFill"
                    }, null, 8, ["src"]),
                    vue.createElementVNode(
                      "text",
                      { class: "contact-name" },
                      vue.toDisplayString(contact.name),
                      1
                      /* TEXT */
                    )
                  ], 8, ["onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]);
          }),
          128
          /* KEYED_FRAGMENT */
        )) : (vue.openBlock(), vue.createElementBlock("view", {
          key: 1,
          class: "no-results"
        }, [
          vue.createElementVNode("text", null, "æ— æœç´¢ç»“æžœ")
        ]))
      ])) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" ç¾¤èŠåç§°è¾“å…¥å¼¹çª— "),
      vue.createVNode(
        _component_uni_popup,
        {
          ref: "popup",
          type: "dialog"
        },
        {
          default: vue.withCtx(() => [
            vue.createVNode(_component_uni_popup_dialog, {
              title: "è®¾ç½®ç¾¤èŠåç§°",
              mode: "input",
              placeholder: "è¯·è¾“å…¥ç¾¤èŠåç§°",
              "before-close": true,
              onConfirm: $setup.confirmGroupName,
              onClose: $setup.closePopup
            })
          ]),
          _: 1
          /* STABLE */
        },
        512
        /* NEED_PATCH */
      )
    ]);
  }
  const PagesContactsPagesContactsCreateGroupChatIndex = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1], ["__scopeId", "data-v-9480d38a"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/contacts/pages/contacts/create-group-chat/index.vue"]]);
  const _sfc_main$1 = {
    name: "MessageReadStatus",
    components: {
      LocationMessage,
      ImageMessage,
      FileMessage,
      VoiceMessageBubble,
      BurnAfterReadingMessage,
      AudioMessage,
      BurnAfterReadingTextMessage
    },
    setup() {
      formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:114", "æ¶ˆæ¯å·²è¯»çŠ¶æ€ç»„ä»¶è®¾ç½®å¼€å§‹");
      const messageData = vue.ref(null);
      const activeTab = vue.ref("read");
      const readUsers = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = messageData.value) == null ? void 0 : _a.groupMessageUserReadVO) == null ? void 0 : _b.filter((user) => user.isRead)) || [];
      });
      const unreadUsers = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = messageData.value) == null ? void 0 : _a.groupMessageUserReadVO) == null ? void 0 : _b.filter((user) => !user.isRead)) || [];
      });
      const displayUsers = vue.computed(() => {
        return activeTab.value === "read" ? readUsers.value : unreadUsers.value;
      });
      const setActiveTab = (tab) => {
        activeTab.value = tab;
      };
      vue.onMounted(() => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:135", "æ¶ˆæ¯å·²è¯»çŠ¶æ€ç»„ä»¶æŒ‚è½½");
        const cachedData = uni.getStorageSync("messageReadStatusData");
        if (cachedData) {
          try {
            const parsedData = JSON.parse(cachedData);
            formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:142", "ä»Žç¼“å­˜ä¸­è¯»å–çš„æ¶ˆæ¯æ•°æ®:", parsedData);
            messageData.value = {
              ...parsedData,
              type: parsedData.type || "text",
              messageType: parsedData.messageType || "MESSAGE",
              selfDestruct: parsedData.selfDestruct || false,
              id: parsedData.id
            };
            formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:150", "è®¾ç½®çš„æ¶ˆæ¯æ•°æ®:", messageData.value);
            uni.removeStorageSync("messageReadStatusData");
            formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:153", "å·²æ¸…é™¤ç¼“å­˜çš„æ¶ˆæ¯æ•°æ®");
          } catch (error) {
            formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:155", "è§£æžç¼“å­˜æ•°æ®å¤±è´¥:", error);
            handleDataLoadError();
          }
        } else {
          formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:159", "ç¼“å­˜ä¸­æ²¡æœ‰æ‰¾åˆ°æ¶ˆæ¯æ•°æ®");
          handleDataLoadError();
        }
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:163", "æ¶ˆæ¯å·²è¯»çŠ¶æ€ç»„ä»¶æŒ‚è½½å®Œæˆ");
      });
      const handleDataLoadError = () => {
        uni.showToast({
          title: "æ— æ³•åŠ è½½æ¶ˆæ¯æ•°æ®",
          icon: "none"
        });
        setTimeout(() => {
          formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:172", "æ— æ³•åŠ è½½æ¶ˆæ¯æ•°æ®ï¼Œè¿”å›žä¸Šä¸€é¡µ");
          uni.navigateBack();
        }, 2e3);
      };
      const formatTime2 = (timestamp) => {
        if (!timestamp)
          return "";
        const date = new Date(timestamp);
        const month = (date.getMonth() + 1).toString().padStart(2, "0");
        const day = date.getDate().toString().padStart(2, "0");
        const hours = date.getHours().toString().padStart(2, "0");
        const minutes = date.getMinutes().toString().padStart(2, "0");
        return `${month}-${day} ${hours}:${minutes}`;
      };
      const handleBack = () => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:188", "è¿”å›žä¸Šä¸€é¡µ");
        uni.navigateBack();
      };
      const viewBurnAfterReading = (message) => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:193", "æŸ¥çœ‹é˜…åŽå³ç„šæ¶ˆæ¯", message);
      };
      const handleMessageDeleted = (messageId) => {
        formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:197", "æ¶ˆæ¯å·²åˆ é™¤", messageId);
      };
      formatAppLog("log", "at pages/message/ChatComponent/MessageReadStatus.vue:200", "æ¶ˆæ¯å·²è¯»çŠ¶æ€ç»„ä»¶è®¾ç½®å®Œæˆ");
      return {
        messageData,
        activeTab,
        readUsers,
        unreadUsers,
        displayUsers,
        formatTime: formatTime2,
        handleBack,
        setActiveTab,
        viewBurnAfterReading,
        handleMessageDeleted
      };
    }
  };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_LocationMessage = vue.resolveComponent("LocationMessage");
    const _component_ImageMessage = vue.resolveComponent("ImageMessage");
    const _component_FileMessage = vue.resolveComponent("FileMessage");
    const _component_VoiceMessageBubble = vue.resolveComponent("VoiceMessageBubble");
    const _component_AudioMessage = vue.resolveComponent("AudioMessage");
    const _component_BurnAfterReadingMessage = vue.resolveComponent("BurnAfterReadingMessage");
    const _component_BurnAfterReadingTextMessage = vue.resolveComponent("BurnAfterReadingTextMessage");
    return vue.openBlock(), vue.createElementBlock("view", { class: "message-read-status" }, [
      vue.createElementVNode("view", { class: "nav-bar" }, [
        vue.createElementVNode("view", {
          class: "back-button",
          onClick: _cache[0] || (_cache[0] = (...args) => $setup.handleBack && $setup.handleBack(...args))
        }, [
          vue.createElementVNode("text", { class: "back-icon" }, "ï¼œ")
        ]),
        vue.createElementVNode("view", { class: "title" }, "æ¶ˆæ¯è¯¦æƒ…")
      ]),
      $setup.messageData ? (vue.openBlock(), vue.createElementBlock("view", {
        key: 0,
        class: "message-info"
      }, [
        vue.createElementVNode("view", { class: "sender-info" }, [
          vue.createElementVNode(
            "text",
            { class: "sender-name" },
            vue.toDisplayString($setup.messageData.senderName),
            1
            /* TEXT */
          ),
          vue.createElementVNode(
            "text",
            { class: "message-time" },
            vue.toDisplayString($setup.formatTime($setup.messageData.timestamp)),
            1
            /* TEXT */
          )
        ]),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass(["message-content", {
              "location-content": $setup.messageData.type === "location",
              "file-message": $setup.messageData.type === "file",
              "message-image": $setup.messageData.type === "image",
              "voice-message": $setup.messageData.type === "voice_message",
              "audio-message": $setup.messageData.type === "audio"
            }])
          },
          [
            $setup.messageData.type === "location" ? (vue.openBlock(), vue.createBlock(_component_LocationMessage, {
              key: 0,
              content: $setup.messageData.content
            }, null, 8, ["content"])) : $setup.messageData.type === "image" ? (vue.openBlock(), vue.createBlock(_component_ImageMessage, {
              key: 1,
              content: $setup.messageData.content
            }, null, 8, ["content"])) : $setup.messageData.type === "file" ? (vue.openBlock(), vue.createBlock(_component_FileMessage, {
              key: 2,
              content: $setup.messageData.content,
              messageType: $setup.messageData.messageType
            }, null, 8, ["content", "messageType"])) : $setup.messageData.type === "voice_message" ? (vue.openBlock(), vue.createBlock(_component_VoiceMessageBubble, {
              key: 3,
              content: {
                url: $setup.messageData.content,
                duration: $setup.messageData.duration,
                isSelf: false
              }
            }, null, 8, ["content"])) : $setup.messageData.type === "audio" ? (vue.openBlock(), vue.createBlock(_component_AudioMessage, {
              key: 4,
              content: $setup.messageData.content,
              messageType: $setup.messageData.messageType
            }, null, 8, ["content", "messageType"])) : $setup.messageData.type === "burn-after-reading" ? (vue.openBlock(), vue.createBlock(_component_BurnAfterReadingMessage, {
              key: 5,
              content: $setup.messageData.content,
              onViewBurnAfterReading: $setup.viewBurnAfterReading
            }, null, 8, ["content", "onViewBurnAfterReading"])) : $setup.messageData.selfDestruct && $setup.messageData.messageType === "MESSAGE" ? (vue.openBlock(), vue.createBlock(_component_BurnAfterReadingTextMessage, {
              key: 6,
              messageId: $setup.messageData.id,
              isGroup: true,
              onMessageDeleted: $setup.handleMessageDeleted
            }, null, 8, ["messageId", "onMessageDeleted"])) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 7 },
              [
                vue.createTextVNode(
                  vue.toDisplayString($setup.messageData.content || ""),
                  1
                  /* TEXT */
                )
              ],
              64
              /* STABLE_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        )
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("view", { class: "read-status-container" }, [
        vue.createElementVNode("view", { class: "read-status-tabs" }, [
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["tab", { active: $setup.activeTab === "read" }]),
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.setActiveTab("read"))
            },
            [
              vue.createElementVNode(
                "text",
                { class: "tab-number" },
                vue.toDisplayString($setup.readUsers.length),
                1
                /* TEXT */
              ),
              vue.createElementVNode("text", { class: "tab-text" }, "äººå·²è¯»")
            ],
            2
            /* CLASS */
          ),
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["tab", { active: $setup.activeTab === "unread" }]),
              onClick: _cache[2] || (_cache[2] = ($event) => $setup.setActiveTab("unread"))
            },
            [
              vue.createElementVNode(
                "text",
                { class: "tab-number" },
                vue.toDisplayString($setup.unreadUsers.length),
                1
                /* TEXT */
              ),
              vue.createElementVNode("text", { class: "tab-text" }, "äººæœªè¯»")
            ],
            2
            /* CLASS */
          )
        ]),
        vue.createElementVNode("scroll-view", {
          class: "user-list",
          "scroll-y": ""
        }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.displayUsers, (user) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                key: user.userId,
                class: "user-item"
              }, [
                vue.createElementVNode("image", {
                  src: user.avatarUrl || "/static/message/é»˜è®¤å¤´åƒ.png",
                  class: "user-avatar",
                  mode: "aspectFill"
                }, null, 8, ["src"]),
                vue.createElementVNode(
                  "text",
                  { class: "user-name" },
                  vue.toDisplayString(user.userName),
                  1
                  /* TEXT */
                ),
                $setup.activeTab === "read" && user.readTime ? (vue.openBlock(), vue.createElementBlock(
                  "text",
                  {
                    key: 0,
                    class: "read-time"
                  },
                  vue.toDisplayString($setup.formatTime(user.readTime)),
                  1
                  /* TEXT */
                )) : vue.createCommentVNode("v-if", true)
              ]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])
    ]);
  }
  const PagesMessageChatComponentMessageReadStatus = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-c9a2ebe1"], ["__file", "E:/ä»£ç /new/zk_uniapp/pages/message/ChatComponent/MessageReadStatus.vue"]]);
  __definePage("pages/login/camouflageLogin/camouflageLogin", PagesLoginCamouflageLoginCamouflageLogin);
  __definePage("pages/login/login", PagesLoginLogin);
  __definePage("pages/register/register", PagesRegisterRegister);
  __definePage("pages/forgetPassword/forgetPassword", PagesForgetPasswordForgetPassword);
  __definePage("pages/fingerLogin/fingerLogin", PagesFingerLoginFingerLogin);
  __definePage("pages/task/task", PagesTaskTask);
  __definePage("pages/task/task_detail/task_detail", PagesTaskTaskDetailTaskDetail);
  __definePage("pages/task/task_detail/document/document", PagesTaskTaskDetailDocumentDocument);
  __definePage("pages/task/task_detail/baidu_map/baidu_map", PagesTaskTaskDetailBaiduMapBaiduMap);
  __definePage("pages/profile/profile", PagesProfileProfile);
  __definePage("pages/message/main", PagesMessageMain);
  __definePage("pages/message/chat", PagesMessageChat);
  __definePage("pages/tabBar/tabBar", PagesTabBarTabBar);
  __definePage("pages/message/video-call", PagesMessageVideoCall);
  __definePage("pages/message/ChatComponent/CallReminder", PagesMessageChatComponentCallReminder);
  __definePage("pages/message/video-answer", PagesMessageVideoAnswer);
  __definePage("pages/login/camouflageLogin/inputAccount/inputAccount", PagesLoginCamouflageLoginInputAccountInputAccount);
  __definePage("pages/contacts/pages/contacts", PagesContactsPagesContacts);
  __definePage("pages/contacts/pages/contacts/create-group-chat/index", PagesContactsPagesContactsCreateGroupChatIndex);
  __definePage("pages/contacts/components/ContactDetail/ContactDetailView", PagesContactsComponentsContactDetailContactDetailView);
  __definePage("pages/message/ChatComponent/MessageReadStatus", PagesMessageChatComponentMessageReadStatus);
  const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
  const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
  function jsonParseTransform(key, value) {
    if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
      warnKeyDropped(key);
      return;
    }
    return value;
  }
  function warnKeyDropped(key) {
    formatAppLog("warn", "at node_modules/destr/dist/index.mjs:12", `[destr] Dropping "${key}" key to prevent prototype pollution.`);
  }
  function destr(value, options = {}) {
    if (typeof value !== "string") {
      return value;
    }
    const _value = value.trim();
    if (
      // eslint-disable-next-line unicorn/prefer-at
      value[0] === '"' && value.endsWith('"') && !value.includes("\\")
    ) {
      return _value.slice(1, -1);
    }
    if (_value.length <= 9) {
      const _lval = _value.toLowerCase();
      if (_lval === "true") {
        return true;
      }
      if (_lval === "false") {
        return false;
      }
      if (_lval === "undefined") {
        return void 0;
      }
      if (_lval === "null") {
        return null;
      }
      if (_lval === "nan") {
        return Number.NaN;
      }
      if (_lval === "infinity") {
        return Number.POSITIVE_INFINITY;
      }
      if (_lval === "-infinity") {
        return Number.NEGATIVE_INFINITY;
      }
    }
    if (!JsonSigRx.test(value)) {
      if (options.strict) {
        throw new SyntaxError("[destr] Invalid JSON");
      }
      return value;
    }
    try {
      if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
        if (options.strict) {
          throw new Error("[destr] Possible prototype pollution");
        }
        return JSON.parse(value, jsonParseTransform);
      }
      return JSON.parse(value);
    } catch (error) {
      if (options.strict) {
        throw error;
      }
      return value;
    }
  }
  function get(obj, path) {
    if (obj == null)
      return void 0;
    let value = obj;
    for (let i2 = 0; i2 < path.length; i2++) {
      if (value == null || value[path[i2]] == null)
        return void 0;
      value = value[path[i2]];
    }
    return value;
  }
  function set(obj, value, path) {
    if (path.length === 0)
      return value;
    const idx = path[0];
    if (path.length > 1) {
      value = set(
        typeof obj !== "object" || obj === null || !Object.prototype.hasOwnProperty.call(obj, idx) ? Number.isInteger(Number(path[1])) ? [] : {} : obj[idx],
        value,
        Array.prototype.slice.call(path, 1)
      );
    }
    if (Number.isInteger(Number(idx)) && Array.isArray(obj))
      return obj.slice()[idx];
    return Object.assign({}, obj, { [idx]: value });
  }
  function unset(obj, path) {
    if (obj == null || path.length === 0)
      return obj;
    if (path.length === 1) {
      if (obj == null)
        return obj;
      if (Number.isInteger(path[0]) && Array.isArray(obj))
        return Array.prototype.slice.call(obj, 0).splice(path[0], 1);
      const result = {};
      for (const p2 in obj)
        result[p2] = obj[p2];
      delete result[path[0]];
      return result;
    }
    if (obj[path[0]] == null) {
      if (Number.isInteger(path[0]) && Array.isArray(obj))
        return Array.prototype.concat.call([], obj);
      const result = {};
      for (const p2 in obj)
        result[p2] = obj[p2];
      return result;
    }
    return set(
      obj,
      unset(
        obj[path[0]],
        Array.prototype.slice.call(path, 1)
      ),
      [path[0]]
    );
  }
  function deepPickUnsafe(obj, paths) {
    return paths.map((p2) => p2.split(".")).map((p2) => [p2, get(obj, p2)]).filter((t2) => t2[1] !== void 0).reduce((acc, cur) => set(acc, cur[1], cur[0]), {});
  }
  function deepOmitUnsafe(obj, paths) {
    return paths.map((p2) => p2.split(".")).reduce((acc, cur) => unset(acc, cur), obj);
  }
  function hydrateStore(store2, {
    storage,
    serializer,
    key,
    debug,
    pick,
    omit,
    beforeHydrate,
    afterHydrate
  }, context, runHooks = true) {
    try {
      if (runHooks)
        beforeHydrate == null ? void 0 : beforeHydrate(context);
      const fromStorage = storage.getItem(key);
      if (fromStorage) {
        const deserialized = serializer.deserialize(fromStorage);
        const picked = pick ? deepPickUnsafe(deserialized, pick) : deserialized;
        const omitted = omit ? deepOmitUnsafe(picked, omit) : picked;
        store2.$patch(omitted);
      }
      if (runHooks)
        afterHydrate == null ? void 0 : afterHydrate(context);
    } catch (error) {
      if (debug)
        formatAppLog("error", "at node_modules/pinia-plugin-persistedstate/dist/index.js:30", "[pinia-plugin-persistedstate]", error);
    }
  }
  function persistState(state, {
    storage,
    serializer,
    key,
    debug,
    pick,
    omit
  }) {
    try {
      const picked = pick ? deepPickUnsafe(state, pick) : state;
      const omitted = omit ? deepOmitUnsafe(picked, omit) : picked;
      const toStorage = serializer.serialize(omitted);
      storage.setItem(key, toStorage);
    } catch (error) {
      if (debug)
        formatAppLog("error", "at node_modules/pinia-plugin-persistedstate/dist/index.js:48", "[pinia-plugin-persistedstate]", error);
    }
  }
  function createPersistence(context, optionsParser, auto) {
    const { pinia, store: store2, options: { persist = auto } } = context;
    if (!persist)
      return;
    if (!(store2.$id in pinia.state.value)) {
      const originalStore = pinia._s.get(store2.$id.replace("__hot:", ""));
      if (originalStore)
        Promise.resolve().then(() => originalStore.$persist());
      return;
    }
    const persistenceOptions = Array.isArray(persist) ? persist : persist === true ? [{}] : [persist];
    const persistences = persistenceOptions.map(optionsParser);
    store2.$hydrate = ({ runHooks = true } = {}) => {
      persistences.forEach((p2) => {
        hydrateStore(store2, p2, context, runHooks);
      });
    };
    store2.$persist = () => {
      persistences.forEach((p2) => {
        persistState(store2.$state, p2);
      });
    };
    persistences.forEach((p2) => {
      hydrateStore(store2, p2, context);
      store2.$subscribe(
        (_mutation, state) => persistState(state, p2),
        { detached: true }
      );
    });
  }
  function createPersistedState(options = {}) {
    return function(context) {
      createPersistence(
        context,
        (p2) => ({
          key: (options.key ? options.key : (x) => x)(p2.key ?? context.store.$id),
          debug: p2.debug ?? options.debug ?? false,
          serializer: p2.serializer ?? options.serializer ?? {
            serialize: (data) => JSON.stringify(data),
            deserialize: (data) => destr(data)
          },
          storage: p2.storage ?? options.storage ?? window.localStorage,
          beforeHydrate: p2.beforeHydrate,
          afterHydrate: p2.afterHydrate,
          pick: p2.pick,
          omit: p2.omit
        }),
        options.auto ?? false
      );
    };
  }
  var src_default = createPersistedState();
  let store = createPinia();
  store.use(src_default);
  const _sfc_main = {
    onLaunch: function() {
      formatAppLog("warn", "at App.vue:4", "å½“å‰ç»„ä»¶ä»…æ”¯æŒ uni_modules ç›®å½•ç»“æž„ ï¼Œè¯·å‡çº§ HBuilderX åˆ° 3.1.0 ç‰ˆæœ¬ä»¥ä¸Šï¼");
      formatAppLog("log", "at App.vue:5", "App Launch"), plus.screen.lockOrientation("portrait-primary");
    },
    onShow: function() {
      formatAppLog("log", "at App.vue:9", "App Show");
    },
    onHide: function() {
      formatAppLog("log", "at App.vue:12", "App Hide");
    }
  };
  const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "E:/ä»£ç /new/zk_uniapp/App.vue"]]);
  function createApp() {
    const app = vue.createVueApp(App);
    const pinia = createPinia();
    app.use(pinia);
    app.use(store);
    return {
      app,
      pinia
    };
  }
  let main = plus.android.runtimeMainActivity();
  plus.runtime.quit = function() {
    uni.showModal({
      title: "æç¤º",
      content: "æ˜¯å¦é€€å‡ºåº”ç”¨ï¼Ÿ",
      success: function(res) {
        if (res.confirm) {
          if (uni.getStorageSync("token") != "") {
            logout().then((res2) => {
              uni.removeStorageSync("token");
              uni.removeStorageSync("userInfo");
            });
          }
          main.finish();
        } else if (res.cancel)
          ;
      }
    });
  };
  const { app: __app__, Vuex: __Vuex__, Pinia: __Pinia__ } = createApp();
  uni.Vuex = __Vuex__;
  uni.Pinia = __Pinia__;
  __app__.provide("__globalStyles", __uniConfig.styles);
  __app__._component.mpType = "app";
  __app__._component.render = () => {
  };
  __app__.mount("#app");
})(Vue);
